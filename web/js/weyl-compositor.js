/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(
      this,
      "filter",
      fn,
      thisArg,
      (v) => v.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply(
      this,
      "find",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(
      this,
      "findLast",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject(value) ? readonly(value) : value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
    this._raw = toRaw(_object);
    let shallow = true;
    let obj = _object;
    if (!isArray(_object) || !isIntegerKey(String(_key))) {
      do {
        shallow = !isProxy(obj) || isShallow(obj);
      } while (shallow && (obj = obj["__v_raw"]));
    }
    this._shallow = shallow;
  }
  get value() {
    let val = this._object[this._key];
    if (this._shallow) {
      val = unref(val);
    }
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    if (this._shallow && isRef(this._raw[this._key])) {
      const nestedRef = this._object[this._key];
      if (isRef(nestedRef)) {
        nestedRef.value = newVal;
        return;
      }
    }
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(this._raw, this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  return new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue$1 = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue$1[queue$1.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && !(job.flags & 8)) {
        if (job.flags & 4) {
          job.flags &= -2;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= -2;
        }
      }
    }
  } finally {
    for (; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue$1.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText}
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  } else if (disabled) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    invalidatePendingSetRef(oldRawRef);
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
    }
  }
  if (isFunction(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value ;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                const newVal = [refValue];
                {
                  ref3.value = newVal;
                }
                if (rawRef.k) refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          {
            ref3.value = value;
          }
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback)],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || ([]),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (hasOwn(props, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, props, type }
  }, key) {
    let cssModules;
    return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || hasOwn(props, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function useSlots() {
  return getContext().slots;
}
function getContext(calledFunctionName) {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeUnmount,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives} = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (currentInstance) {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, flush} = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
          { attrs, slots, emit: emit2 }
        ) : render2(
          props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text$1:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
      try {
        if (customElement) {
          customElement._beginPatch();
        }
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } finally {
        if (customElement) {
          customElement._endPatch();
        }
      }
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, fallback to el placeholder for unresolved async component
          anchorVNode.el || anchorVNode.placeholder
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text$1 && // avoid cached text nodes retaining detached dom nodes
      c2.patchFlag !== -1) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text$1 = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text$1, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text$1, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}
const version = "3.5.25";

/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const vtcKey = Symbol("_vtc");
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "sandbox" && el.tagName === "IFRAME") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
function castValue(value, trim, number) {
  if (trim) value = value.trim();
  if (number) value = looseToNumber(value);
  return value;
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      el[assignKey](castValue(el.value, trim, castToNumber));
    });
    if (trim || castToNumber) {
      addEventListener(el, "change", () => {
        el.value = castValue(el.value, trim, castToNumber);
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}

/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && true) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$2 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia.state.value[id] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$2({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else ;
  }
  {
    assign$2(store, setupStore);
    assign$2(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$2($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$2(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  }
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (pinia) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}

const Pe = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: false },
    pushOtherPanes: { type: Boolean, default: true },
    maximizePanes: { type: Boolean, default: true },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: false },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: false }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(D, { emit: h$1 }) {
    const y = h$1, u = D, E = useSlots(), l = ref([]), M = computed(() => l.value.reduce((e, n) => (e[~~n.id] = n) && e, {})), m = computed(() => l.value.length), x = ref(null), S = ref(false), c = ref({
      mouseDown: false,
      dragging: false,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), f = ref({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), _ = computed(() => ({
      [`splitpanes splitpanes--${u.horizontal ? "horizontal" : "vertical"}`]: true,
      "splitpanes--dragging": c.value.dragging
    })), R = () => {
      document.addEventListener("mousemove", r, { passive: false }), document.addEventListener("mouseup", P), "ontouchstart" in window && (document.addEventListener("touchmove", r, { passive: false }), document.addEventListener("touchend", P));
    }, O = () => {
      document.removeEventListener("mousemove", r, { passive: false }), document.removeEventListener("mouseup", P), "ontouchstart" in window && (document.removeEventListener("touchmove", r, { passive: false }), document.removeEventListener("touchend", P));
    }, b = (e, n) => {
      const t = e.target.closest(".splitpanes__splitter");
      if (t) {
        const { left: i, top: a } = t.getBoundingClientRect(), { clientX: s, clientY: o } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
        c.value.cursorOffset = u.horizontal ? o - a : s - i;
      }
      R(), c.value.mouseDown = true, c.value.activeSplitter = n;
    }, r = (e) => {
      c.value.mouseDown && (e.preventDefault(), c.value.dragging = true, requestAnimationFrame(() => {
        K(I(e)), d("resize", { event: e }, true);
      }));
    }, P = (e) => {
      c.value.dragging && (window.getSelection().removeAllRanges(), d("resized", { event: e }, true)), c.value.mouseDown = false, c.value.activeSplitter = null, setTimeout(() => {
        c.value.dragging = false, O();
      }, 100);
    }, A = (e, n) => {
      "ontouchstart" in window && (e.preventDefault(), f.value.splitter === n ? (clearTimeout(f.value.timeoutId), f.value.timeoutId = null, U(e, n), f.value.splitter = null) : (f.value.splitter = n, f.value.timeoutId = setTimeout(() => f.value.splitter = null, 500))), c.value.dragging || d("splitter-click", { event: e, index: n }, true);
    }, U = (e, n) => {
      if (d("splitter-dblclick", { event: e, index: n }, true), u.maximizePanes) {
        let t = 0;
        l.value = l.value.map((i, a) => (i.size = a === n ? i.max : i.min, a !== n && (t += i.min), i)), l.value[n].size -= t, d("pane-maximize", { event: e, index: n, pane: l.value[n] }), d("resized", { event: e, index: n }, true);
      }
    }, W = (e, n) => {
      d("pane-click", {
        event: e,
        index: M.value[n].index,
        pane: M.value[n]
      });
    }, I = (e) => {
      const n = x.value.getBoundingClientRect(), { clientX: t, clientY: i } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
      return {
        x: t - (u.horizontal ? 0 : c.value.cursorOffset) - n.left,
        y: i - (u.horizontal ? c.value.cursorOffset : 0) - n.top
      };
    }, J = (e) => {
      e = e[u.horizontal ? "y" : "x"];
      const n = x.value[u.horizontal ? "clientHeight" : "clientWidth"];
      return u.rtl && !u.horizontal && (e = n - e), e * 100 / n;
    }, K = (e) => {
      const n = c.value.activeSplitter;
      let t = {
        prevPanesSize: $(n),
        nextPanesSize: N(n),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (u.pushOtherPanes ? 0 : t.prevPanesSize), a = 100 - (u.pushOtherPanes ? 0 : t.nextPanesSize), s = Math.max(Math.min(J(e), a), i);
      let o = [n, n + 1], v = l.value[o[0]] || null, p = l.value[o[1]] || null;
      const H = v.max < 100 && s >= v.max + t.prevPanesSize, ue = p.max < 100 && s <= 100 - (p.max + N(n + 1));
      if (H || ue) {
        H ? (v.size = v.max, p.size = Math.max(100 - v.max - t.prevPanesSize - t.nextPanesSize, 0)) : (v.size = Math.max(100 - p.max - t.prevPanesSize - N(n + 1), 0), p.size = p.max);
        return;
      }
      if (u.pushOtherPanes) {
        const j = Q(t, s);
        if (!j) return;
        (({ sums: t, panesToResize: o } = j)), v = l.value[o[0]] || null, p = l.value[o[1]] || null;
      }
      v !== null && (v.size = Math.min(Math.max(s - t.prevPanesSize - t.prevReachedMinPanes, v.min), v.max)), p !== null && (p.size = Math.min(Math.max(100 - s - t.nextPanesSize - t.nextReachedMinPanes, p.min), p.max));
    }, Q = (e, n) => {
      const t = c.value.activeSplitter, i = [t, t + 1];
      return n < e.prevPanesSize + l.value[i[0]].min && (i[0] = V(t).index, e.prevReachedMinPanes = 0, i[0] < t && l.value.forEach((a, s) => {
        s > i[0] && s <= t && (a.size = a.min, e.prevReachedMinPanes += a.min);
      }), e.prevPanesSize = $(i[0]), i[0] === void 0) ? (e.prevReachedMinPanes = 0, l.value[0].size = l.value[0].min, l.value.forEach((a, s) => {
        s > 0 && s <= t && (a.size = a.min, e.prevReachedMinPanes += a.min);
      }), l.value[i[1]].size = 100 - e.prevReachedMinPanes - l.value[0].min - e.prevPanesSize - e.nextPanesSize, null) : n > 100 - e.nextPanesSize - l.value[i[1]].min && (i[1] = Z(t).index, e.nextReachedMinPanes = 0, i[1] > t + 1 && l.value.forEach((a, s) => {
        s > t && s < i[1] && (a.size = a.min, e.nextReachedMinPanes += a.min);
      }), e.nextPanesSize = N(i[1] - 1), i[1] === void 0) ? (e.nextReachedMinPanes = 0, l.value.forEach((a, s) => {
        s < m.value - 1 && s >= t + 1 && (a.size = a.min, e.nextReachedMinPanes += a.min);
      }), l.value[i[0]].size = 100 - e.prevPanesSize - N(i[0] - 1), null) : { sums: e, panesToResize: i };
    }, $ = (e) => l.value.reduce((n, t, i) => n + (i < e ? t.size : 0), 0), N = (e) => l.value.reduce((n, t, i) => n + (i > e + 1 ? t.size : 0), 0), V = (e) => [...l.value].reverse().find((t) => t.index < e && t.size > t.min) || {}, Z = (e) => l.value.find((t) => t.index > e + 1 && t.size > t.min) || {}, ee = () => {
      var n;
      const e = Array.from(((n = x.value) == null ? void 0 : n.children) || []);
      for (const t of e) {
        const i = t.classList.contains("splitpanes__pane"), a = t.classList.contains("splitpanes__splitter");
        !i && !a && (t.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, F = (e, n, t = false) => {
      const i = e - 1, a = document.createElement("div");
      a.classList.add("splitpanes__splitter"), t || (a.onmousedown = (s) => b(s, i), typeof window < "u" && "ontouchstart" in window && (a.ontouchstart = (s) => b(s, i)), a.onclick = (s) => A(s, i + 1)), a.ondblclick = (s) => U(s, i + 1), n.parentNode.insertBefore(a, n);
    }, ne = (e) => {
      e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.remove();
    }, C = () => {
      var t;
      const e = Array.from(((t = x.value) == null ? void 0 : t.children) || []);
      for (const i of e)
        i.className.includes("splitpanes__splitter") && ne(i);
      let n = 0;
      for (const i of e)
        i.className.includes("splitpanes__pane") && (!n && u.firstSplitter ? F(n, i, true) : n && F(n, i), n++);
    }, ie = ({ uid: e, ...n }) => {
      const t = M.value[e];
      for (const [i, a] of Object.entries(n)) t[i] = a;
    }, te = (e) => {
      var t;
      let n = -1;
      Array.from(((t = x.value) == null ? void 0 : t.children) || []).some((i) => (i.className.includes("splitpanes__pane") && n++, i.isSameNode(e.el))), l.value.splice(n, 0, { ...e, index: n }), l.value.forEach((i, a) => i.index = a), S.value && nextTick(() => {
        C(), L({ addedPane: l.value[n] }), d("pane-add", { pane: l.value[n] });
      });
    }, ae = (e) => {
      const n = l.value.findIndex((i) => i.id === e);
      l.value[n].el = null;
      const t = l.value.splice(n, 1)[0];
      l.value.forEach((i, a) => i.index = a), nextTick(() => {
        C(), d("pane-remove", { pane: t }), L({ removedPane: { } });
      });
    }, L = (e = {}) => {
      !e.addedPane && !e.removedPane ? le() : l.value.some((n) => n.givenSize !== null || n.min || n.max < 100) ? oe(e) : se(), S.value && d("resized");
    }, se = () => {
      const e = 100 / m.value;
      let n = 0;
      const t = [], i = [];
      for (const a of l.value)
        a.size = Math.max(Math.min(e, a.max), a.min), n -= a.size, a.size >= a.max && t.push(a.id), a.size <= a.min && i.push(a.id);
      n > 0.1 && q(n, t, i);
    }, le = () => {
      let e = 100;
      const n = [], t = [];
      let i = 0;
      for (const s of l.value)
        e -= s.size, s.givenSize !== null && i++, s.size >= s.max && n.push(s.id), s.size <= s.min && t.push(s.id);
      let a = 100;
      if (e > 0.1) {
        for (const s of l.value)
          s.givenSize === null && (s.size = Math.max(Math.min(e / (m.value - i), s.max), s.min)), a -= s.size;
        a > 0.1 && q(a, n, t);
      }
    }, oe = ({ addedPane: e, removedPane: n } = {}) => {
      let t = 100 / m.value, i = 0;
      const a = [], s = [];
      ((e == null ? void 0 : e.givenSize) ?? null) !== null && (t = (100 - e.givenSize) / (m.value - 1));
      for (const o of l.value)
        i -= o.size, o.size >= o.max && a.push(o.id), o.size <= o.min && s.push(o.id);
      if (!(Math.abs(i) < 0.1)) {
        for (const o of l.value)
          (e == null ? void 0 : e.givenSize) !== null && (e == null ? void 0 : e.id) === o.id || (o.size = Math.max(Math.min(t, o.max), o.min)), i -= o.size, o.size >= o.max && a.push(o.id), o.size <= o.min && s.push(o.id);
        i > 0.1 && q(i, a, s);
      }
    }, q = (e, n, t) => {
      let i;
      e > 0 ? i = e / (m.value - n.length) : i = e / (m.value - t.length), l.value.forEach((a, s) => {
        if (e > 0 && !n.includes(a.id)) {
          const o = Math.max(Math.min(a.size + i, a.max), a.min), v = o - a.size;
          e -= v, a.size = o;
        } else if (!t.includes(a.id)) {
          const o = Math.max(Math.min(a.size + i, a.max), a.min), v = o - a.size;
          e -= v, a.size = o;
        }
      }), Math.abs(e) > 0.1 && nextTick(() => {
        S.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, d = (e, n = void 0, t = false) => {
      const i = (n == null ? void 0 : n.index) ?? c.value.activeSplitter ?? null;
      y(e, {
        ...n,
        ...i !== null && { index: i },
        ...t && i !== null && {
          prevPane: l.value[i - (u.firstSplitter ? 1 : 0)],
          nextPane: l.value[i + (u.firstSplitter ? 0 : 1)]
        },
        panes: l.value.map((a) => ({ min: a.min, max: a.max, size: a.size }))
      });
    };
    watch(() => u.firstSplitter, () => C()), onMounted(() => {
      ee(), C(), L(), d("ready"), S.value = true;
    }), onBeforeUnmount(() => S.value = false);
    const re = () => {
      var e;
      return h(
        "div",
        { ref: x, class: _.value },
        (e = E.default) == null ? void 0 : e.call(E)
      );
    };
    return provide("panes", l), provide("indexedPanes", M), provide("horizontal", computed(() => u.horizontal)), provide("requestUpdate", ie), provide("onPaneAdd", te), provide("onPaneRemove", ae), provide("onPaneClick", W), (e, n) => (openBlock(), createBlock(resolveDynamicComponent(re)));
  }
}, ge = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(D) {
    var b;
    const h = D, y = inject("requestUpdate"), u = inject("onPaneAdd"), E = inject("horizontal"), l = inject("onPaneRemove"), M = inject("onPaneClick"), m = (b = getCurrentInstance()) == null ? void 0 : b.uid, x = inject("indexedPanes"), S = computed(() => x.value[m]), c = ref(null), f = computed(() => {
      const r = isNaN(h.size) || h.size === void 0 ? 0 : parseFloat(h.size);
      return Math.max(Math.min(r, R.value), _.value);
    }), _ = computed(() => {
      const r = parseFloat(h.minSize);
      return isNaN(r) ? 0 : r;
    }), R = computed(() => {
      const r = parseFloat(h.maxSize);
      return isNaN(r) ? 100 : r;
    }), O = computed(() => {
      var r;
      return `${E.value ? "height" : "width"}: ${(r = S.value) == null ? void 0 : r.size}%`;
    });
    return watch(() => f.value, (r) => y({ uid: m, size: r })), watch(() => _.value, (r) => y({ uid: m, min: r })), watch(() => R.value, (r) => y({ uid: m, max: r })), onMounted(() => {
      u({
        id: m,
        el: c.value,
        min: _.value,
        max: R.value,
        // The given size (useful to know the user intention).
        givenSize: h.size === void 0 ? null : f.value,
        size: f.value
        // The computed current size at any time.
      });
    }), onBeforeUnmount(() => l(m)), (r, P) => (openBlock(), createElementBlock("div", {
      ref_key: "paneEl",
      ref: c,
      class: "splitpanes__pane",
      onClick: P[0] || (P[0] = (A) => unref(M)(A, r._.uid)),
      style: normalizeStyle(O.value)
    }, [
      renderSlot(r.$slots, "default")
    ], 4));
  }
};

const PI = Math.PI;
const c1$1 = 1.70158;
const c2$1 = c1$1 * 1.525;
const c3$1 = c1$1 + 1;
const c4$1 = 2 * PI / 3;
const c5$1 = 2 * PI / 4.5;
const easings = {
  // Linear - no easing
  linear: (t) => t,
  // Sine easing
  easeInSine: (t) => 1 - Math.cos(t * PI / 2),
  easeOutSine: (t) => Math.sin(t * PI / 2),
  easeInOutSine: (t) => -(Math.cos(PI * t) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
    return (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // Circ (circular)
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (t) => c3$1 * t * t * t - c1$1 * t * t,
  easeOutBack: (t) => 1 + c3$1 * Math.pow(t - 1, 3) + c1$1 * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2$1 + 1) * 2 * t - c2$1) / 2 : (Math.pow(2 * t - 2, 2) * ((c2$1 + 1) * (t * 2 - 2) + c2$1) + 2) / 2,
  // Elastic
  easeInElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4$1);
  },
  easeOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4$1) + 1;
  },
  easeInOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) {
      return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5$1)) / 2;
    }
    return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5$1) / 2 + 1;
  },
  // Bounce
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInBounce: (t) => 1 - easings.easeOutBounce(1 - t),
  easeInOutBounce: (t) => t < 0.5 ? (1 - easings.easeOutBounce(1 - 2 * t)) / 2 : (1 + easings.easeOutBounce(2 * t - 1)) / 2
};
function getEasing(name) {
  if (name in easings) {
    return easings[name];
  }
  return easings.linear;
}

const LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
const config = {
  level: "warn",
  prefix: "[Weyl]"};
function shouldLog(level) {
  return LOG_LEVELS[level] >= LOG_LEVELS[config.level];
}
function formatMessage(level, context, message) {
  const parts = [];
  {
    parts.push(config.prefix);
  }
  if (context) {
    parts.push(`[${context}]`);
  }
  parts.push(message);
  return parts.join(" ");
}
function createLogger(context) {
  return {
    debug(message, ...args) {
      if (shouldLog("debug")) {
        console.log(formatMessage("DEBUG", context, message), ...args);
      }
    },
    info(message, ...args) {
      if (shouldLog("info")) {
        console.info(formatMessage("INFO", context, message), ...args);
      }
    },
    warn(message, ...args) {
      if (shouldLog("warn")) {
        console.warn(formatMessage("WARN", context, message), ...args);
      }
    },
    error(message, ...args) {
      if (shouldLog("error")) {
        console.error(formatMessage("ERROR", context, message), ...args);
      }
    },
    /**
     * Log with a specific level
     */
    log(level, message, ...args) {
      switch (level) {
        case "debug":
          this.debug(message, ...args);
          break;
        case "info":
          this.info(message, ...args);
          break;
        case "warn":
          this.warn(message, ...args);
          break;
        case "error":
          this.error(message, ...args);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(label) {
      if (shouldLog("debug")) {
        console.group(formatMessage("", context, label));
      }
    },
    groupEnd() {
      if (shouldLog("debug")) {
        console.groupEnd();
      }
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(data) {
      if (shouldLog("debug")) {
        console.log(formatMessage("", context, "Table:"));
        console.table(data);
      }
    },
    /**
     * Measure time for an operation
     */
    time(label) {
      if (shouldLog("debug")) {
        console.time(`${config.prefix} [${context}] ${label}`);
      }
    },
    timeEnd(label) {
      if (shouldLog("debug")) {
        console.timeEnd(`${config.prefix} [${context}] ${label}`);
      }
    }
  };
}
const storeLogger = createLogger("Store");
const engineLogger = createLogger("Engine");
const layerLogger = createLogger("Layer");
const renderLogger = createLogger("Render");

const easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
const easeOutSine = (t) => Math.sin(t * Math.PI / 2);
const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
const easeInQuad = (t) => t * t;
const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
const easeInCubic = (t) => t * t * t;
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
const easeInQuart = (t) => t * t * t * t;
const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
const easeInQuint = (t) => t * t * t * t * t;
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
const easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
const easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
const easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
const easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
const easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
const c1 = 1.70158;
const c2 = c1 * 1.525;
const c3 = c1 + 1;
const easeInBack = (t) => c3 * t * t * t - c1 * t * t;
const easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
const easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
const c4 = 2 * Math.PI / 3;
const c5 = 2 * Math.PI / 4.5;
const easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
const easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
const easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
const easeOutBounce = (t) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
const easeInBounce = (t) => 1 - easeOutBounce(1 - t);
const easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
const linear = (t) => t;
const stepStart = (t) => t === 0 ? 0 : 1;
const stepEnd = (t) => t === 1 ? 1 : 0;
const EASING_FUNCTIONS = {
  // Linear
  linear,
  // Sine
  easeInSine,
  easeOutSine,
  easeInOutSine,
  // Quad
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  // Cubic
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  // Quart
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  // Quint
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  // Expo
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  // Circ
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  // Back
  easeInBack,
  easeOutBack,
  easeInOutBack,
  // Elastic
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  // Bounce
  easeInBounce,
  easeOutBounce,
  easeInOutBounce,
  // Step
  stepStart,
  stepEnd
};
function inertia(ctx, amplitude = 0.1, frequency = 2, decay = 2) {
  const { time: time2, keyframes, value, velocity } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let nearestKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      nearestKey = keyframes[i];
      break;
    }
  }
  if (!nearestKey) return value;
  const keyTime = nearestKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const vel = typeof velocity === "number" ? velocity : velocity[0];
  const val = typeof value === "number" ? value : value[0];
  const oscillation = vel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  if (typeof value === "number") {
    return val + oscillation;
  }
  return value.map((v, i) => {
    const componentVel = velocity[i] || 0;
    return v + componentVel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  });
}
function bounce(ctx, elasticity = 0.7, gravity = 4e3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  let bounceTime = t;
  let bounceHeight = 1;
  let totalBounces = 0;
  const maxBounces = 10;
  while (bounceTime > 0 && totalBounces < maxBounces) {
    const bounceDuration2 = Math.sqrt(2 * bounceHeight / gravity);
    if (bounceTime < bounceDuration2 * 2) {
      break;
    }
    bounceTime -= bounceDuration2 * 2;
    bounceHeight *= elasticity * elasticity;
    totalBounces++;
  }
  const bounceDuration = Math.sqrt(2 * bounceHeight / gravity);
  const bounceT = bounceTime / (bounceDuration * 2);
  const bounceOffset = bounceHeight * 4 * bounceT * (1 - bounceT);
  if (typeof value === "number") {
    return value - bounceOffset * (1 - elasticity);
  }
  return value.map((v) => v - bounceOffset * (1 - elasticity));
}
function elastic(ctx, amplitude = 1, period = 0.3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const s = period / 4;
  const decay = Math.pow(2, -10 * t);
  const oscillation = decay * Math.sin((t - s) * (2 * Math.PI) / period);
  if (typeof value === "number") {
    return value + amplitude * oscillation;
  }
  return value.map((v) => v + amplitude * oscillation);
}
function loopOut(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const startIdx = numKeyframes > 0 ? Math.max(0, keyframes.length - numKeyframes) : 0;
  const startKey = keyframes[startIdx];
  const endKey = keyframes[keyframes.length - 1];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 <= endTime) return ctx.value;
  const elapsed = time2 - endTime;
  switch (type) {
    case "cycle": {
      const cycleTime = startTime + elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? 1 - cycleProgress : cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = startTime + elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(endKey.value, startKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value + velocity * elapsed;
      }
      return ctx.value.map((v, i) => v + velocity[i] * elapsed);
    }
  }
}
function loopIn(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const endIdx = numKeyframes > 0 ? Math.min(keyframes.length - 1, numKeyframes - 1) : keyframes.length - 1;
  const startKey = keyframes[0];
  const endKey = keyframes[endIdx];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 >= startTime) return ctx.value;
  const elapsed = startTime - time2;
  switch (type) {
    case "cycle": {
      const cycleTime = endTime - elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? cycleProgress : 1 - cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = endTime - elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(startKey.value, endKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value - velocity * elapsed;
      }
      return ctx.value.map((v, i) => v - velocity[i] * elapsed);
    }
  }
}
function wiggle(ctx, frequency = 5, amplitude = 50, octaves = 1, amplitudeMultiplier = 0.5, time2) {
  const t = time2 ?? ctx.time;
  const { value } = ctx;
  const noise = (seed, t2) => {
    let result = 0;
    let amp = 1;
    let freq = 1;
    for (let i = 0; i < octaves; i++) {
      result += amp * Math.sin(t2 * frequency * freq * Math.PI * 2 + seed * 1e3);
      result += amp * 0.5 * Math.sin(t2 * frequency * freq * Math.PI * 2 * 1.5 + seed * 500);
      amp *= amplitudeMultiplier;
      freq *= 2;
    }
    return result / (1 + (octaves - 1) * amplitudeMultiplier);
  };
  if (typeof value === "number") {
    return value + noise(0, t) * amplitude;
  }
  return value.map((v, i) => v + noise(i, t) * amplitude);
}
const timeExpressions = {
  /**
   * Linear time ramp
   */
  timeRamp(startTime, endTime, startValue, endValue, time2) {
    if (time2 <= startTime) return startValue;
    if (time2 >= endTime) return endValue;
    const t = (time2 - startTime) / (endTime - startTime);
    return startValue + (endValue - startValue) * t;
  },
  /**
   * Periodic function (loops every period seconds)
   */
  periodic(time2, period) {
    return time2 % period / period;
  },
  /**
   * Sawtooth wave
   */
  sawtooth(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * 2 * (t - Math.floor(t + 0.5));
  },
  /**
   * Triangle wave
   */
  triangle(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1);
  },
  /**
   * Square wave
   */
  square(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (t - Math.floor(t) < 0.5 ? 1 : -1);
  },
  /**
   * Sine wave
   */
  sine(time2, frequency, amplitude = 1, phase = 0) {
    return amplitude * Math.sin(2 * Math.PI * frequency * time2 + phase);
  },
  /**
   * Pulse (duty cycle controlled square)
   */
  pulse(time2, frequency, dutyCycle = 0.5, amplitude = 1) {
    const t = time2 * frequency % 1;
    return amplitude * (t < dutyCycle ? 1 : 0);
  }
};
const mathExpressions = {
  /**
   * Linear interpolation
   */
  lerp(a, b, t) {
    return a + (b - a) * t;
  },
  /**
   * Clamp value between min and max
   */
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  },
  /**
   * Map value from one range to another
   */
  map(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  },
  /**
   * Normalized value (0-1) based on range
   */
  normalize(value, min, max) {
    return (value - min) / (max - min);
  },
  /**
   * Smooth step (Hermite interpolation)
   */
  smoothstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  },
  /**
   * Smoother step (Ken Perlin's improved version)
   */
  smootherstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * t * (t * (t * 6 - 15) + 10);
  },
  /**
   * Modulo with support for negative numbers
   */
  mod(a, b) {
    return (a % b + b) % b;
  },
  /**
   * Distance between two 2D points
   */
  distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  },
  /**
   * Angle between two 2D points (in radians)
   */
  angleBetween(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  },
  /**
   * Convert degrees to radians
   */
  degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  },
  /**
   * Convert radians to degrees
   */
  radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  },
  /**
   * Random number with seed (deterministic)
   */
  seedRandom(seed, min = 0, max = 1) {
    const x = Math.sin(seed * 12.9898) * 43758.5453;
    const rand = x - Math.floor(x);
    return min + rand * (max - min);
  },
  /**
   * Gaussian random (normal distribution)
   */
  gaussRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }
};
function interpolateAtTime(keyframes, time2, fps) {
  const frame = time2 * fps;
  let before = null;
  let after = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      before = kf;
    } else if (!after) {
      after = kf;
      break;
    }
  }
  if (!before) return keyframes[0].value;
  if (!after) return before.value;
  const t = (frame - before.frame) / (after.frame - before.frame);
  const easedT = applyEasing$2(t, before.interpolation);
  return lerpValues(before.value, after.value, easedT);
}
function applyEasing$2(t, interpolation) {
  const fn = EASING_FUNCTIONS[interpolation];
  return fn ? fn(t) : t;
}
function lerpValues(a, b, t) {
  if (typeof a === "number" && typeof b === "number") {
    return a + (b - a) * t;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + (b[i] - v) * t);
  }
  return a;
}
function subtractValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v - b[i]);
  }
  return 0;
}
function addValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + b[i]);
  }
  return a;
}
function scaleValue(v, s) {
  if (typeof v === "number") {
    return v * s;
  }
  if (Array.isArray(v)) {
    return v.map((x) => x * s);
  }
  return 0;
}
function evaluateExpression(expression, ctx) {
  if (!expression.enabled) return ctx.value;
  switch (expression.type) {
    case "preset":
      return evaluatePreset(expression.name, ctx, expression.params);
    case "function":
      return evaluateFunction(expression.name, ctx, expression.params);
    default:
      return ctx.value;
  }
}
function evaluatePreset(name, ctx, params) {
  switch (name) {
    case "inertia":
      return inertia(ctx, params.amplitude, params.frequency, params.decay);
    case "bounce":
      return bounce(ctx, params.elasticity, params.gravity);
    case "elastic":
      return elastic(ctx, params.amplitude, params.period);
    case "wiggle":
      return wiggle(ctx, params.frequency, params.amplitude, params.octaves);
    case "loopOut":
      return loopOut(ctx, params.type, params.numKeyframes);
    case "loopIn":
      return loopIn(ctx, params.type, params.numKeyframes);
    default:
      return ctx.value;
  }
}
function evaluateFunction(name, ctx, params) {
  if (name in timeExpressions) {
    const fn = timeExpressions[name];
    return fn(ctx.time, ...Object.values(params));
  }
  if (name in mathExpressions) {
    const fn = mathExpressions[name];
    const val = typeof ctx.value === "number" ? ctx.value : ctx.value[0];
    return fn(val, ...Object.values(params));
  }
  return ctx.value;
}

function findKeyframeIndex(keyframes, frame) {
  let low = 0;
  let high = keyframes.length - 2;
  while (low <= high) {
    const mid = low + high >>> 1;
    const midFrame = keyframes[mid].frame;
    const nextFrame = keyframes[mid + 1].frame;
    if (frame >= midFrame && frame <= nextFrame) {
      return mid;
    } else if (frame < midFrame) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return Math.max(0, Math.min(low, keyframes.length - 2));
}
function getValueDelta(v1, v2) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v2 - v1;
  }
  if (typeof v1 === "object" && v1 !== null && "x" in v1 && "y" in v1 && typeof v2 === "object" && v2 !== null && "x" in v2 && "y" in v2) {
    const dx = v2.x - v1.x;
    const dy = v2.y - v1.y;
    return Math.sqrt(dx * dx + dy * dy) || 1;
  }
  return 1;
}
function interpolateProperty(property, frame, fps = 30, layerId = "") {
  let value;
  if (!property.animated || property.keyframes.length === 0) {
    value = property.value;
  } else {
    const keyframes = property.keyframes;
    if (frame <= keyframes[0].frame) {
      value = keyframes[0].value;
    } else if (frame >= keyframes[keyframes.length - 1].frame) {
      value = keyframes[keyframes.length - 1].value;
    } else {
      const idx = findKeyframeIndex(keyframes, frame);
      const k1 = keyframes[idx];
      const k2 = keyframes[idx + 1];
      const duration = k2.frame - k1.frame;
      const elapsed = frame - k1.frame;
      let t = duration > 0 ? elapsed / duration : 0;
      const interpolation = k1.interpolation || "linear";
      if (interpolation === "hold") {
        value = k1.value;
      } else {
        if (interpolation === "bezier") {
          const valueDelta = getValueDelta(k1.value, k2.value);
          t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
        } else if (interpolation !== "linear" && interpolation in easings) {
          const easingFn = getEasing(interpolation);
          t = easingFn(t);
        } else if (interpolation !== "linear") {
          renderLogger.warn(`Unknown interpolation type: ${interpolation}, using linear`);
        }
        value = interpolateValue$1(k1.value, k2.value, t);
      }
    }
  }
  if (property.expression?.enabled) {
    value = applyPropertyExpression(property, value, frame, fps);
  }
  return value;
}
function applyPropertyExpression(property, value, frame, fps, layerId) {
  const expr = property.expression;
  if (!expr || !expr.enabled) return value;
  const time = frame / fps;
  const velocity = calculateVelocity(property, frame, fps);
  const ctx = {
    time,
    fps,
    value,
    velocity,
    keyframes: property.keyframes
  };
  const expression = {
    type: expr.type,
    name: expr.name,
    params: expr.params,
    enabled: expr.enabled
  };
  const result = evaluateExpression(expression, ctx);
  return result;
}
function calculateVelocity(property, frame, fps) {
  const delta = 0.5;
  const valueBefore = interpolatePropertyBase(property, frame - delta);
  const valueAfter = interpolatePropertyBase(property, frame + delta);
  if (typeof valueBefore === "number" && typeof valueAfter === "number") {
    return (valueAfter - valueBefore) * fps;
  }
  if (typeof valueBefore === "object" && typeof valueAfter === "object") {
    const vb = valueBefore;
    const va = valueAfter;
    if ("x" in vb && "y" in vb) {
      const result = [(va.x - vb.x) * fps, (va.y - vb.y) * fps];
      if ("z" in vb && "z" in va) {
        result.push((va.z - vb.z) * fps);
      }
      return result;
    }
  }
  return 0;
}
function interpolatePropertyBase(property, frame) {
  if (!property.animated || property.keyframes.length === 0) {
    return property.value;
  }
  const keyframes = property.keyframes;
  if (frame <= keyframes[0].frame) {
    return keyframes[0].value;
  }
  if (frame >= keyframes[keyframes.length - 1].frame) {
    return keyframes[keyframes.length - 1].value;
  }
  const idx = findKeyframeIndex(keyframes, frame);
  const k1 = keyframes[idx];
  const k2 = keyframes[idx + 1];
  const duration = k2.frame - k1.frame;
  const elapsed = frame - k1.frame;
  let t = duration > 0 ? elapsed / duration : 0;
  const interpolation = k1.interpolation || "linear";
  if (interpolation === "hold") {
    return k1.value;
  } else if (interpolation === "bezier") {
    const valueDelta = getValueDelta(k1.value, k2.value);
    t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
  } else if (interpolation !== "linear" && interpolation in easings) {
    const easingFn = getEasing(interpolation);
    t = easingFn(t);
  }
  return interpolateValue$1(k1.value, k2.value, t);
}
function cubicBezierEasing(t, outHandle, inHandle, frameDuration = 1, valueDelta = 1) {
  if (!outHandle.enabled && !inHandle.enabled) {
    return t;
  }
  const x1 = frameDuration > 0 ? Math.abs(outHandle.frame) / frameDuration : 0.33;
  const y1 = valueDelta !== 0 ? outHandle.value / valueDelta : 0.33;
  const x2 = frameDuration > 0 ? 1 - Math.abs(inHandle.frame) / frameDuration : 0.67;
  const y2 = valueDelta !== 0 ? 1 - inHandle.value / valueDelta : 0.67;
  let guessT = t;
  const EPSILON = 1e-6;
  const MAX_ITERATIONS = 8;
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const currentX = bezierPoint(guessT, 0, x1, x2, 1);
    const error = currentX - t;
    if (Math.abs(error) < EPSILON) break;
    const currentSlope = bezierDerivative(guessT, 0, x1, x2, 1);
    if (Math.abs(currentSlope) < EPSILON) break;
    guessT -= error / currentSlope;
    guessT = Math.max(0, Math.min(1, guessT));
  }
  return bezierPoint(guessT, 0, y1, y2, 1);
}
function bezierPoint(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
}
function bezierDerivative(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
}
function interpolateValue$1(v1, v2, t) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v1 + (v2 - v1) * t;
  }
  if (typeof v1 === "object" && v1 !== null && typeof v2 === "object" && v2 !== null && "x" in v1 && "y" in v1 && "x" in v2 && "y" in v2) {
    const val1 = v1;
    const val2 = v2;
    const result = {
      x: val1.x + (val2.x - val1.x) * t,
      y: val1.y + (val2.y - val1.y) * t
    };
    if ("z" in val1 && "z" in val2) {
      result.z = val1.z + (val2.z - val1.z) * t;
    } else if ("z" in val1) {
      result.z = val1.z * (1 - t);
    } else if ("z" in val2) {
      result.z = val2.z * t;
    }
    return result;
  }
  if (typeof v1 === "string" && typeof v2 === "string" && v1.startsWith("#") && v2.startsWith("#")) {
    return interpolateColor(v1, v2, t);
  }
  return t < 0.5 ? v1 : v2;
}
function interpolateColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);
  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
const EASING_PRESETS_NORMALIZED = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
const EASING_PRESETS = EASING_PRESETS_NORMALIZED;
function getBezierCurvePointNormalized(t, outHandle, inHandle) {
  const x1 = outHandle.x;
  const y1 = outHandle.y;
  const x2 = 1 - inHandle.x;
  const y2 = 1 - inHandle.y;
  return {
    x: bezierPoint(t, 0, x1, x2, 1),
    y: bezierPoint(t, 0, y1, y2, 1)
  };
}
function applyEasing$1(ratio, preset) {
  const t = Math.max(0, Math.min(1, ratio));
  const point = getBezierCurvePointNormalized(t, preset.outHandle, preset.inHandle);
  return point.y;
}

function getFeatureAtFrame(analysis, feature, frame) {
  const clampedFrame = Math.max(0, Math.min(frame, analysis.frameCount - 1));
  switch (feature) {
    case "amplitude":
      return analysis.amplitudeEnvelope[clampedFrame] ?? 0;
    case "rms":
      return analysis.rmsEnergy[clampedFrame] ?? 0;
    case "spectralCentroid":
      return analysis.spectralCentroid[clampedFrame] ?? 0;
    case "sub":
      return analysis.frequencyBands.sub[clampedFrame] ?? 0;
    case "bass":
      return analysis.frequencyBands.bass[clampedFrame] ?? 0;
    case "lowMid":
      return analysis.frequencyBands.lowMid[clampedFrame] ?? 0;
    case "mid":
      return analysis.frequencyBands.mid[clampedFrame] ?? 0;
    case "highMid":
      return analysis.frequencyBands.highMid[clampedFrame] ?? 0;
    case "high":
      return analysis.frequencyBands.high[clampedFrame] ?? 0;
    case "onsets":
      return analysis.onsets.includes(clampedFrame) ? 1 : 0;
    case "spectralFlux":
      return analysis.spectralFlux?.[clampedFrame] ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return analysis.zeroCrossingRate?.[clampedFrame] ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return analysis.spectralRolloff?.[clampedFrame] ?? 0;
    case "spectralFlatness":
    case "flatness":
      return analysis.spectralFlatness?.[clampedFrame] ?? 0;
    case "chromaEnergy":
      return analysis.chromaFeatures?.chromaEnergy[clampedFrame] ?? 0;
    case "chromaC":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[0] ?? 0;
    case "chromaCs":
    case "chromaDb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[1] ?? 0;
    case "chromaD":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[2] ?? 0;
    case "chromaDs":
    case "chromaEb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[3] ?? 0;
    case "chromaE":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[4] ?? 0;
    case "chromaF":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[5] ?? 0;
    case "chromaFs":
    case "chromaGb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[6] ?? 0;
    case "chromaG":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[7] ?? 0;
    case "chromaGs":
    case "chromaAb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[8] ?? 0;
    case "chromaA":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[9] ?? 0;
    case "chromaAs":
    case "chromaBb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[10] ?? 0;
    case "chromaB":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[11] ?? 0;
    default:
      return 0;
  }
}
function detectPeaks(weights, config) {
  const { threshold, minPeaksDistance, multiply } = config;
  const amplified = weights.map((w) => Math.min(1, w * multiply));
  const rawPeaks = [];
  for (let i = 1; i < amplified.length - 1; i++) {
    const prev = amplified[i - 1];
    const curr = amplified[i];
    const next = amplified[i + 1];
    if (curr > prev && curr > next && curr >= threshold) {
      rawPeaks.push({ index: i, value: curr });
    }
  }
  const filteredPeaks = [];
  for (const peak of rawPeaks) {
    const recentPeakIndex = filteredPeaks.findIndex(
      (p) => Math.abs(p.index - peak.index) < minPeaksDistance
    );
    if (recentPeakIndex === -1) {
      filteredPeaks.push(peak);
    } else {
      if (peak.value > filteredPeaks[recentPeakIndex].value) {
        filteredPeaks[recentPeakIndex] = peak;
      }
    }
  }
  filteredPeaks.sort((a, b) => a.index - b.index);
  const alternating = new Array(weights.length).fill(0);
  let currentState = 0;
  for (let i = 0; i < weights.length; i++) {
    const isPeak = filteredPeaks.some((p) => p.index === i);
    if (isPeak) {
      currentState = 1 - currentState;
    }
    alternating[i] = currentState;
  }
  return {
    indices: filteredPeaks.map((p) => p.index),
    values: filteredPeaks.map((p) => p.value),
    count: filteredPeaks.length,
    alternating
  };
}
function isBeatAtFrame(analysis, frame) {
  return analysis.onsets.includes(frame);
}
function isPeakAtFrame(peaks, frame) {
  return peaks.indices.includes(frame);
}

/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2024 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
// these __PURE__ comments help uglifyjs with dead code removal
//
const SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);
const F2 = 0.5 * (SQRT3 - 1.0);
const G2 = (3.0 - SQRT3) / 6.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x) => Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
    -1, 1,
    1, -1,
    -1, -1,
    1, 0,
    -1, 0,
    1, 0,
    -1, 0,
    0, 1,
    0, -1,
    0, 1,
    0, -1]);
/**
 * Creates a 2D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction2D}
 */
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
/**
 * Builds a random permutation table.
 * This is exported only for (internal) testing purposes.
 * Do not rely on this export.
 * @private
 */
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for (let i = 0; i < tableSize / 2; i++) {
        p[i] = i;
    }
    for (let i = 0; i < tableSize / 2 - 1; i++) {
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for (let i = 256; i < tableSize; i++) {
        p[i] = p[i - 256];
    }
    return p;
}

class SeededRandom {
  state;
  initialSeed;
  constructor(seed = 12345) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Reset to initial seed */
  reset() {
    this.state = this.initialSeed;
  }
  /** Reset to a new seed */
  setSeed(seed) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
  /** Get initial seed */
  getSeed() {
    return this.initialSeed;
  }
  /**
   * Get next random number in [0, 1)
   * Uses mulberry32 algorithm
   */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get random integer in range [min, max] inclusive */
  int(min, max) {
    return Math.floor(this.range(min, max + 1));
  }
  /** Get random value with variance: base + random(-variance, +variance) */
  variance(base, variance) {
    return base + (this.next() - 0.5) * 2 * variance;
  }
  /** Get random boolean with given probability of true */
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  /** Get random angle in radians [0, 2) */
  angle() {
    return this.next() * Math.PI * 2;
  }
  /** Get random point in unit circle */
  inCircle() {
    const angle = this.angle();
    const r = Math.sqrt(this.next());
    return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
  }
  /** Get random point on unit sphere */
  onSphere() {
    const theta = this.angle();
    const phi = Math.acos(2 * this.next() - 1);
    return {
      x: Math.sin(phi) * Math.cos(theta),
      y: Math.sin(phi) * Math.sin(theta),
      z: Math.cos(phi)
    };
  }
}
function createDefaultCollisionConfig() {
  return {
    enabled: false,
    particleCollision: false,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: false,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: false,
    floorY: 1,
    ceilingEnabled: false,
    ceilingY: 0,
    wallsEnabled: false,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function createDefaultConnectionConfig() {
  return {
    enabled: false,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: true
  };
}
function createDefaultSystemConfig() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: false,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: createDefaultCollisionConfig()
  };
}
function createDefaultRenderOptions() {
  return {
    blendMode: "additive",
    renderTrails: false,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: false,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: false,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: createDefaultConnectionConfig(),
    spriteSmoothing: true,
    spriteOpacityByAge: true,
    emissiveEnabled: false,
    emissiveIntensity: 2,
    emissiveColor: null
  };
}
class ParticleSystem {
  particles = [];
  emitters = /* @__PURE__ */ new Map();
  gravityWells = /* @__PURE__ */ new Map();
  vortices = /* @__PURE__ */ new Map();
  modulations = [];
  config;
  boundaryMask = null;
  frameCount = 0;
  emissionAccumulators = /* @__PURE__ */ new Map();
  nextParticleId = 0;
  trailHistory = /* @__PURE__ */ new Map();
  // Audio reactivity state
  featureOverrides = /* @__PURE__ */ new Map();
  // Turbulence noise generator (seeded for determinism)
  noise2D;
  noiseTime = 0;
  // Render options cache for spatial grid
  renderOptions = createDefaultRenderOptions();
  // Sprite image cache - maps emitter ID to loaded image
  spriteCache = /* @__PURE__ */ new Map();
  // Collision spatial hash grid
  collisionGrid = /* @__PURE__ */ new Map();
  collisionGridCellSize = 50;
  // SEEDED RNG - For deterministic simulation
  // Same seed + same config + same frame = identical particle state
  rng;
  // Spline path provider for emitters with shape='spline'
  // Set by the engine integration (e.g., WeylEngine) to resolve spline paths
  splineProvider = null;
  // Current frame for spline queries
  currentFrame = 0;
  // Sequential emit state per emitter (for 'sequential' emit mode)
  sequentialEmitT = /* @__PURE__ */ new Map();
  constructor(config = {}, seed = 12345) {
    this.config = { ...createDefaultSystemConfig(), ...config };
    this.rng = new SeededRandom(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
    if (this.config.collision) {
      this.collisionGridCellSize = this.config.collision.spatialHashCellSize;
    }
  }
  /**
   * Get the RNG instance (for external access/checkpointing)
   */
  getRng() {
    return this.rng;
  }
  /**
   * Set new seed and reset RNG
   */
  setSeed(seed) {
    this.rng.setSeed(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
  }
  /**
   * Set the spline path provider callback
   * This allows emitters with shape='spline' to query spline positions
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get the current spline provider
   */
  getSplineProvider() {
    return this.splineProvider;
  }
  /**
   * Set the current frame for spline queries
   * Called by the engine before stepping the simulation
   */
  setCurrentFrame(frame) {
    this.currentFrame = frame;
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(emitterId, imageUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.spriteCache.set(emitterId, img);
        const emitter = this.emitters.get(emitterId);
        if (emitter && emitter.sprite) {
          emitter.sprite.imageData = img;
        }
        resolve();
      };
      img.onerror = reject;
      img.src = imageUrl;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(emitterId, image) {
    this.spriteCache.set(emitterId, image);
    const emitter = this.emitters.get(emitterId);
    if (emitter && emitter.sprite) {
      emitter.sprite.imageData = image;
    }
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(emitterId) {
    return this.spriteCache.get(emitterId) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, { ...config });
    this.emissionAccumulators.set(config.id, 0);
    if (config.initialBurst > 0 && config.enabled) {
      const burstCount = Math.floor(config.emissionRate * config.initialBurst * 10);
      for (let i = 0; i < burstCount; i++) {
        this.spawnParticle(config);
      }
    }
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.emissionAccumulators.delete(id);
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(config) {
    this.gravityWells.set(config.id, { ...config });
  }
  updateGravityWell(id, updates) {
    const well = this.gravityWells.get(id);
    if (well) {
      Object.assign(well, updates);
    }
  }
  removeGravityWell(id) {
    this.gravityWells.delete(id);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(config) {
    this.vortices.set(config.id, { ...config });
  }
  updateVortex(id, updates) {
    const vortex = this.vortices.get(id);
    if (vortex) {
      Object.assign(vortex, updates);
    }
  }
  removeVortex(id) {
    this.vortices.delete(id);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(mod) {
    this.modulations.push({ ...mod });
  }
  removeModulation(id) {
    const index = this.modulations.findIndex((m) => m.id === id);
    if (index >= 0) {
      this.modulations.splice(index, 1);
    }
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(mask) {
    this.boundaryMask = mask;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(param, value, emitterId) {
    const key = emitterId ? `${emitterId}:${param}` : `*:${param}`;
    this.featureOverrides.set(key, value);
  }
  getFeatureValue(param, emitterId) {
    return this.featureOverrides.get(`${emitterId}:${param}`) ?? this.featureOverrides.get(`*:${param}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(deltaTime = 1) {
    this.emitters.forEach((emitter, id) => {
      if (!emitter.enabled) return;
      const baseRate = this.getFeatureValue("emissionRate", id) ?? emitter.emissionRate;
      const particlesToEmit = baseRate * deltaTime;
      let accumulated = (this.emissionAccumulators.get(id) || 0) + particlesToEmit;
      while (accumulated >= 1 && this.particles.length < this.config.maxParticles) {
        this.spawnParticle(emitter);
        accumulated -= 1;
      }
      this.emissionAccumulators.set(id, accumulated);
    });
    const windRadians = this.config.windDirection * Math.PI / 180;
    const windX = Math.cos(windRadians) * this.config.windStrength * 1e-3;
    const windY = Math.sin(windRadians) * this.config.windStrength * 1e-3;
    const gravity = this.getFeatureValue("gravity", "*") ?? this.config.gravity;
    const windStrength = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength;
    const actualWindX = windX * (windStrength / Math.max(1, this.config.windStrength));
    const actualWindY = windY * (windStrength / Math.max(1, this.config.windStrength));
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.prevX = p.x;
      p.prevY = p.y;
      if (this.trailHistory.has(p.id)) {
        const trail = this.trailHistory.get(p.id);
        trail.unshift({ x: p.x, y: p.y });
        if (trail.length > 20) trail.pop();
      }
      p.vy += gravity * 1e-3 * deltaTime;
      p.vx += actualWindX * deltaTime;
      p.vy += actualWindY * deltaTime;
      this.gravityWells.forEach((well) => {
        if (!well.enabled) return;
        const dx = well.x - p.x;
        const dy = well.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < well.radius && dist > 1e-3) {
          let force = well.strength * 1e-4;
          switch (well.falloff) {
            case "linear":
              force *= 1 - dist / well.radius;
              break;
            case "quadratic":
              force *= Math.pow(1 - dist / well.radius, 2);
              break;
          }
          const nx = dx / dist;
          const ny = dy / dist;
          p.vx += nx * force * deltaTime;
          p.vy += ny * force * deltaTime;
        }
      });
      this.vortices.forEach((vortex) => {
        if (!vortex.enabled) return;
        const dx = vortex.x - p.x;
        const dy = vortex.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < vortex.radius && dist > 1e-3) {
          const influence = 1 - dist / vortex.radius;
          const strength = vortex.strength * 1e-4 * influence;
          const nx = dx / dist;
          const ny = dy / dist;
          const perpX = -ny;
          const perpY = nx;
          p.vx += perpX * strength * deltaTime;
          p.vy += perpY * strength * deltaTime;
          const inward = vortex.inwardPull * 1e-4 * influence;
          p.vx += nx * inward * deltaTime;
          p.vy += ny * inward * deltaTime;
        }
      });
      this.applyTurbulence(p, deltaTime);
      const frictionFactor = 1 - this.config.friction;
      p.vx *= frictionFactor;
      p.vy *= frictionFactor;
      if (p.angularVelocity !== 0) {
        p.rotation += p.angularVelocity * deltaTime;
      }
      const emitter = this.emitters.get(p.emitterId);
      if (emitter?.sprite?.alignToVelocity && (p.vx !== 0 || p.vy !== 0)) {
        p.rotation = Math.atan2(p.vy, p.vx);
      }
      if (emitter?.sprite?.isSheet && emitter.sprite.totalFrames > 1) {
        this.updateSpriteFrame(p, emitter.sprite, deltaTime);
      }
      p.x += p.vx * deltaTime;
      p.y += p.vy * deltaTime;
      if (this.boundaryMask && this.config.respectMaskBoundary) {
        this.handleBoundaryCollision(p);
      }
      this.handleCanvasBoundary(p);
      this.applyModulations(p);
      p.age += deltaTime;
      if (p.age > p.lifetime) {
        if (!p.isSubParticle) {
          this.triggerSubEmitters(p);
        }
        this.particles.splice(i, 1);
        this.trailHistory.delete(p.id);
      }
    }
    if (this.config.collision?.enabled && this.config.collision.particleCollision) {
      this.handleParticleCollisions();
    }
    if (this.config.collision?.enabled) {
      this.handleEnvironmentCollisions();
    }
    this.noiseTime += deltaTime;
    this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(p, sprite, _deltaTime) {
    const totalFrames = sprite.totalFrames;
    switch (sprite.playMode) {
      case "loop": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = framesElapsed % totalFrames;
        break;
      }
      case "once": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = Math.min(framesElapsed, totalFrames - 1);
        break;
      }
      case "pingpong": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        const cycle = Math.floor(framesElapsed / (totalFrames - 1));
        const frameInCycle = framesElapsed % (totalFrames - 1);
        p.spriteIndex = cycle % 2 === 0 ? frameInCycle : totalFrames - 1 - frameInCycle;
        break;
      }
      case "random": {
        if (this.rng.bool(0.1)) {
          p.spriteIndex = this.rng.int(0, totalFrames - 1);
        }
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const collision = this.config.collision;
    if (!collision || !collision.particleCollision) return;
    this.collisionGrid.clear();
    const cellSize = this.collisionGridCellSize / 1e3;
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      const key = `${cellX},${cellY}`;
      if (!this.collisionGrid.has(key)) {
        this.collisionGrid.set(key, []);
      }
      this.collisionGrid.get(key).push(p);
    }
    const checked = /* @__PURE__ */ new Set();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          const cell = this.collisionGrid.get(key);
          if (!cell) continue;
          for (const other of cell) {
            if (other.id <= p.id) continue;
            const pairKey = `${Math.min(p.id, other.id)}-${Math.max(p.id, other.id)}`;
            if (checked.has(pairKey)) continue;
            checked.add(pairKey);
            const radiusP = p.size / 1e3 * collision.particleCollisionRadius;
            const radiusO = other.size / 1e3 * collision.particleCollisionRadius;
            const minDist = radiusP + radiusO;
            const dx2 = other.x - p.x;
            const dy2 = other.y - p.y;
            const distSq = dx2 * dx2 + dy2 * dy2;
            if (distSq < minDist * minDist && distSq > 1e-6) {
              const dist = Math.sqrt(distSq);
              const nx = dx2 / dist;
              const ny = dy2 / dist;
              switch (collision.particleCollisionResponse) {
                case "bounce": {
                  const dvx = p.vx - other.vx;
                  const dvy = p.vy - other.vy;
                  const dvDotN = dvx * nx + dvy * ny;
                  if (dvDotN > 0) {
                    const damping = collision.particleCollisionDamping;
                    p.vx -= dvDotN * nx * damping;
                    p.vy -= dvDotN * ny * damping;
                    other.vx += dvDotN * nx * damping;
                    other.vy += dvDotN * ny * damping;
                    const overlap = minDist - dist;
                    p.x -= nx * overlap * 0.5;
                    p.y -= ny * overlap * 0.5;
                    other.x += nx * overlap * 0.5;
                    other.y += ny * overlap * 0.5;
                  }
                  break;
                }
                case "absorb": {
                  if (p.size > other.size) {
                    p.size += other.size * 0.1;
                    other.age = other.lifetime + 1;
                  } else {
                    other.size += p.size * 0.1;
                    p.age = p.lifetime + 1;
                  }
                  break;
                }
                case "explode": {
                  p.age = p.lifetime + 1;
                  other.age = other.lifetime + 1;
                  break;
                }
              }
              p.collisionCount++;
              other.collisionCount++;
            }
          }
        }
      }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const collision = this.config.collision;
    if (!collision?.enabled) return;
    const bounciness = collision.bounciness;
    const friction = collision.friction;
    for (const p of this.particles) {
      if (collision.floorEnabled && p.y > collision.floorY) {
        p.y = collision.floorY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.ceilingEnabled && p.y < collision.ceilingY) {
        p.y = collision.ceilingY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.wallsEnabled) {
        if (p.x < 0) {
          p.x = 0;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
      }
    }
  }
  spawnParticle(emitter) {
    if (this.particles.length >= this.config.maxParticles) return;
    const spawnPos = this.getEmitterSpawnPosition(emitter);
    const baseDirection = spawnPos.direction !== void 0 ? spawnPos.direction : emitter.direction;
    const spreadRad = emitter.spread * Math.PI / 180;
    const baseRad = baseDirection * Math.PI / 180;
    const angle = baseRad + (this.rng.next() - 0.5) * spreadRad;
    const speed = this.rng.variance(emitter.speed, emitter.speedVariance);
    const speedNormalized = speed * 1e-3;
    const size = Math.max(1, this.rng.variance(emitter.size, emitter.sizeVariance));
    const lifetime = Math.max(1, this.rng.variance(emitter.particleLifetime, emitter.lifetimeVariance));
    let rotation = 0;
    let angularVelocity = 0;
    const sprite = emitter.sprite;
    if (sprite && sprite.rotationEnabled) {
      rotation = this.rng.angle();
      const rotSpeed = sprite.rotationSpeed * (Math.PI / 180);
      const rotVariance = sprite.rotationSpeedVariance * (Math.PI / 180);
      angularVelocity = this.rng.variance(rotSpeed, rotVariance);
    }
    if (sprite && sprite.alignToVelocity) {
      rotation = angle;
    }
    let spriteIndex = 0;
    if (sprite && sprite.isSheet && sprite.playMode === "random") {
      spriteIndex = this.rng.int(0, sprite.totalFrames - 1);
    }
    const particle = {
      id: this.nextParticleId++,
      x: spawnPos.x,
      y: spawnPos.y,
      prevX: spawnPos.x,
      prevY: spawnPos.y,
      vx: Math.cos(angle) * speedNormalized,
      vy: Math.sin(angle) * speedNormalized,
      age: 0,
      lifetime,
      size,
      baseSize: size,
      color: [...emitter.color, 255],
      baseColor: [...emitter.color, 255],
      emitterId: emitter.id,
      isSubParticle: false,
      rotation,
      angularVelocity,
      spriteIndex,
      collisionCount: 0
    };
    this.particles.push(particle);
    this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   * Returns position and optionally a direction override for spline emission
   */
  getEmitterSpawnPosition(emitter) {
    const shape = emitter.shape || "point";
    switch (shape) {
      case "point":
        return { x: emitter.x, y: emitter.y };
      case "line": {
        const t = this.rng.next();
        const halfWidth = emitter.shapeWidth / 2;
        const dirRad = emitter.direction * Math.PI / 180;
        const perpX = -Math.sin(dirRad);
        const perpY = Math.cos(dirRad);
        return {
          x: emitter.x + perpX * (t - 0.5) * halfWidth * 2,
          y: emitter.y + perpY * (t - 0.5) * halfWidth * 2
        };
      }
      case "circle": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const angle = this.rng.angle();
          return {
            x: emitter.x + Math.cos(angle) * radius,
            y: emitter.y + Math.sin(angle) * radius
          };
        } else {
          const angle = this.rng.angle();
          const r = radius * Math.sqrt(this.rng.next());
          return {
            x: emitter.x + Math.cos(angle) * r,
            y: emitter.y + Math.sin(angle) * r
          };
        }
      }
      case "ring": {
        const innerR = emitter.shapeInnerRadius;
        const outerR = emitter.shapeRadius;
        const angle = this.rng.angle();
        const r = Math.sqrt(this.rng.next() * (outerR * outerR - innerR * innerR) + innerR * innerR);
        return {
          x: emitter.x + Math.cos(angle) * r,
          y: emitter.y + Math.sin(angle) * r
        };
      }
      case "box": {
        const halfW = emitter.shapeWidth / 2;
        const halfH = emitter.shapeHeight / 2;
        if (emitter.emitFromEdge) {
          const perimeter = 2 * (emitter.shapeWidth + emitter.shapeHeight);
          const t = this.rng.next() * perimeter;
          if (t < emitter.shapeWidth) {
            return { x: emitter.x - halfW + t, y: emitter.y - halfH };
          } else if (t < emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW, y: emitter.y - halfH + (t - emitter.shapeWidth) };
          } else if (t < 2 * emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW - (t - emitter.shapeWidth - emitter.shapeHeight), y: emitter.y + halfH };
          } else {
            return { x: emitter.x - halfW, y: emitter.y + halfH - (t - 2 * emitter.shapeWidth - emitter.shapeHeight) };
          }
        } else {
          return {
            x: emitter.x + (this.rng.next() - 0.5) * emitter.shapeWidth,
            y: emitter.y + (this.rng.next() - 0.5) * emitter.shapeHeight
          };
        }
      }
      case "sphere": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const theta = this.rng.angle();
          const phi = Math.acos(2 * this.rng.next() - 1);
          return {
            x: emitter.x + Math.sin(phi) * Math.cos(theta) * radius,
            y: emitter.y + Math.sin(phi) * Math.sin(theta) * radius
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let x, y, z;
          do {
            x = (this.rng.next() - 0.5) * 2;
            y = (this.rng.next() - 0.5) * 2;
            z = (this.rng.next() - 0.5) * 2;
          } while (x * x + y * y + z * z > 1);
          return {
            x: emitter.x + x * radius,
            y: emitter.y + y * radius
          };
        }
      }
      case "spline": {
        return this.getSplineEmitPosition(emitter);
      }
      default:
        return { x: emitter.x, y: emitter.y };
    }
  }
  /**
   * Get emission position along a spline path
   * Returns position and optionally modifies emission direction
   * DETERMINISM: Uses seeded RNG (this.rng) for random positions
   */
  getSplineEmitPosition(emitter) {
    const splinePath = emitter.splinePath;
    if (!splinePath || !this.splineProvider) {
      return { x: emitter.x, y: emitter.y };
    }
    let t;
    switch (splinePath.emitMode) {
      case "start":
        t = splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "end":
        t = 1 - splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "random":
        t = this.rng.next();
        break;
      case "uniform":
        const interval = Math.max(0.01, splinePath.parameter);
        const numSlots = Math.ceil(1 / interval);
        const slot = this.rng.int(0, numSlots - 1);
        t = slot * interval;
        break;
      case "sequential":
        const currentT = this.sequentialEmitT.get(emitter.id) ?? 0;
        t = currentT;
        const speed = Math.max(1e-3, splinePath.parameter);
        let nextT = currentT + speed;
        if (nextT > 1) nextT = nextT - 1;
        this.sequentialEmitT.set(emitter.id, nextT);
        break;
      default:
        t = this.rng.next();
    }
    t = Math.max(0, Math.min(1, t));
    const result = this.splineProvider(splinePath.layerId, t, this.currentFrame);
    if (!result) {
      return { x: emitter.x, y: emitter.y };
    }
    let x = result.point.x;
    let y = result.point.y;
    if (splinePath.offset !== 0) {
      const tangentLength = Math.sqrt(result.tangent.x ** 2 + result.tangent.y ** 2);
      if (tangentLength > 1e-4) {
        const perpX = -result.tangent.y / tangentLength;
        const perpY = result.tangent.x / tangentLength;
        x += perpX * splinePath.offset;
        y += perpY * splinePath.offset;
      }
    }
    let direction;
    if (splinePath.alignToPath) {
      const tangentAngle = Math.atan2(result.tangent.y, result.tangent.x) * (180 / Math.PI);
      if (splinePath.bidirectional && this.rng.bool(0.5)) {
        direction = tangentAngle + 180;
      } else {
        direction = tangentAngle;
      }
      direction += 90;
    }
    return { x, y, direction };
  }
  handleBoundaryCollision(p) {
    if (!this.boundaryMask) return;
    const px = Math.floor(p.x * this.boundaryMask.width);
    const py = Math.floor(p.y * this.boundaryMask.height);
    if (px < 0 || px >= this.boundaryMask.width || py < 0 || py >= this.boundaryMask.height) {
      return;
    }
    const idx = (py * this.boundaryMask.width + px) * 4;
    const maskValue = this.boundaryMask.data[idx];
    if (maskValue < 128) {
      switch (this.config.boundaryBehavior) {
        case "bounce":
          p.vx *= -0.8;
          p.vy *= -0.8;
          p.x = p.prevX;
          p.y = p.prevY;
          break;
        case "kill":
          p.age = p.lifetime + 1;
          break;
        case "wrap":
          p.x = this.rng.next();
          p.y = this.rng.next();
          break;
      }
    }
  }
  handleCanvasBoundary(p) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        if (p.x < 0) {
          p.x = 0;
          p.vx *= -0.8;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx *= -0.8;
        }
        if (p.y < 0) {
          p.y = 0;
          p.vy *= -0.8;
        }
        if (p.y > 1) {
          p.y = 1;
          p.vy *= -0.8;
        }
        break;
      case "kill":
        if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1) {
          p.age = p.lifetime + 1;
        }
        break;
      case "wrap":
        if (p.x < 0) p.x += 1;
        if (p.x > 1) p.x -= 1;
        if (p.y < 0) p.y += 1;
        if (p.y > 1) p.y -= 1;
        break;
    }
  }
  applyModulations(p) {
    const lifeRatio = p.age / p.lifetime;
    for (const mod of this.modulations) {
      if (mod.emitterId !== "*" && mod.emitterId !== p.emitterId) continue;
      const easingKey = mod.easing;
      const easing = EASING_PRESETS[easingKey] || EASING_PRESETS.linear;
      const easedRatio = applyEasing$1(lifeRatio, easing);
      const value = mod.startValue + (mod.endValue - mod.startValue) * easedRatio;
      switch (mod.property) {
        case "size":
          p.size = p.baseSize * value;
          break;
        case "speed":
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (currentSpeed > 1e-4) {
            const scale = value / Math.max(1e-4, currentSpeed * 1e3);
            p.vx *= scale;
            p.vy *= scale;
          }
          break;
        case "opacity":
          p.color[3] = Math.max(0, Math.min(255, p.baseColor[3] * value));
          break;
        case "colorR":
          p.color[0] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorG":
          p.color[1] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorB":
          p.color[2] = Math.max(0, Math.min(255, value * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(p, deltaTime) {
    const turbFields = this.config.turbulenceFields || [];
    for (const turb of turbFields) {
      if (!turb.enabled) continue;
      const nx = p.x * turb.scale * 1e3;
      const ny = p.y * turb.scale * 1e3;
      const nt = this.noiseTime * turb.evolutionSpeed;
      const angle = this.noise2D(nx + nt, ny + nt) * Math.PI * 2;
      const force = turb.strength * 1e-5;
      p.vx += Math.cos(angle) * force * deltaTime;
      p.vy += Math.sin(angle) * force * deltaTime;
    }
  }
  addTurbulence(config) {
    if (!this.config.turbulenceFields) this.config.turbulenceFields = [];
    this.config.turbulenceFields.push(config);
  }
  updateTurbulence(id, updates) {
    const turb = this.config.turbulenceFields?.find((t) => t.id === id);
    if (turb) Object.assign(turb, updates);
  }
  removeTurbulence(id) {
    if (this.config.turbulenceFields) {
      this.config.turbulenceFields = this.config.turbulenceFields.filter((t) => t.id !== id);
    }
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  /**
   * Trigger sub-emitters when a particle dies
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   */
  triggerSubEmitters(deadParticle) {
    const subEmitters = this.config.subEmitters || [];
    for (const sub of subEmitters) {
      if (!sub.enabled) continue;
      if (sub.parentEmitterId !== "*" && sub.parentEmitterId !== deadParticle.emitterId) continue;
      for (let i = 0; i < sub.spawnCount; i++) {
        const angle = (this.rng.next() - 0.5) * sub.spread * Math.PI / 180;
        const baseAngle = Math.atan2(deadParticle.vy, deadParticle.vx);
        const emitAngle = baseAngle + angle;
        const inheritedSpeed = Math.sqrt(deadParticle.vx ** 2 + deadParticle.vy ** 2) * sub.inheritVelocity;
        const totalSpeed = sub.speed * 1e-3 + inheritedSpeed;
        const particle = {
          id: this.nextParticleId++,
          x: deadParticle.x,
          y: deadParticle.y,
          prevX: deadParticle.x,
          prevY: deadParticle.y,
          vx: Math.cos(emitAngle) * totalSpeed + deadParticle.vx * sub.inheritVelocity,
          vy: Math.sin(emitAngle) * totalSpeed + deadParticle.vy * sub.inheritVelocity,
          age: 0,
          lifetime: sub.lifetime * (1 + (this.rng.next() - 0.5) * 0.2),
          size: sub.size * (1 + (this.rng.next() - 0.5) * sub.sizeVariance / sub.size),
          baseSize: sub.size,
          color: [...sub.color, 255],
          baseColor: [...sub.color, 255],
          emitterId: sub.id,
          isSubParticle: true,
          rotation: deadParticle.rotation,
          // Inherit parent rotation
          angularVelocity: 0,
          spriteIndex: 0,
          collisionCount: 0
        };
        this.particles.push(particle);
        this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
      }
    }
  }
  addSubEmitter(config) {
    if (!this.config.subEmitters) this.config.subEmitters = [];
    this.config.subEmitters.push(config);
  }
  updateSubEmitter(id, updates) {
    const sub = this.config.subEmitters?.find((s) => s.id === id);
    if (sub) Object.assign(sub, updates);
  }
  removeSubEmitter(id) {
    if (this.config.subEmitters) {
      this.config.subEmitters = this.config.subEmitters.filter((s) => s.id !== id);
    }
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(emitterId, count) {
    const emitter = this.emitters.get(emitterId);
    if (!emitter || !emitter.enabled) return;
    const burstCount = count ?? emitter.burstCount ?? 20;
    for (let i = 0; i < burstCount; i++) {
      this.spawnParticle(emitter);
    }
  }
  triggerAllBursts() {
    for (const emitter of this.emitters.values()) {
      if (emitter.burstOnBeat && emitter.enabled) {
        this.triggerBurst(emitter.id);
      }
    }
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    const cellSize = this.renderOptions.connections?.maxDistance || 100;
    const cells = /* @__PURE__ */ new Map();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x * 1e3 / cellSize);
      const cellY = Math.floor(p.y * 1e3 / cellSize);
      const key = `${cellX},${cellY}`;
      if (!cells.has(key)) cells.set(key, []);
      cells.get(key).push(p);
    }
    return { cellSize, cells };
  }
  getNeighborParticles(p, grid) {
    const cellX = Math.floor(p.x * 1e3 / grid.cellSize);
    const cellY = Math.floor(p.y * 1e3 / grid.cellSize);
    const neighbors = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cellX + dx},${cellY + dy}`;
        const cell = grid.cells.get(key);
        if (cell) neighbors.push(...cell);
      }
    }
    return neighbors;
  }
  renderConnections(ctx, width, height) {
    const config = this.renderOptions.connections;
    if (!config?.enabled || this.particles.length < 2) return;
    const grid = this.buildSpatialGrid();
    const maxDist = config.maxDistance / 1e3;
    const maxDistSq = maxDist * maxDist;
    ctx.lineWidth = config.lineWidth;
    for (const p of this.particles) {
      const neighbors = this.getNeighborParticles(p, grid);
      let connectionCount = 0;
      for (const other of neighbors) {
        if (other.id <= p.id) continue;
        if (connectionCount >= config.maxConnections) break;
        const dx = other.x - p.x;
        const dy = other.y - p.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < maxDistSq) {
          const dist = Math.sqrt(distSq);
          let opacity = config.lineOpacity;
          if (config.fadeByDistance) {
            opacity *= 1 - dist / maxDist;
          }
          const r = Math.round((p.color[0] + other.color[0]) / 2);
          const g = Math.round((p.color[1] + other.color[1]) / 2);
          const b = Math.round((p.color[2] + other.color[2]) / 2);
          ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
          ctx.beginPath();
          ctx.moveTo(p.x * width, p.y * height);
          ctx.lineTo(other.x * width, other.y * height);
          ctx.stroke();
          connectionCount++;
        }
      }
    }
  }
  reset() {
    this.particles = [];
    this.frameCount = 0;
    this.trailHistory.clear();
    this.emissionAccumulators.forEach((_, key) => {
      this.emissionAccumulators.set(key, 0);
    });
    this.nextParticleId = 0;
    this.sequentialEmitT.clear();
    this.currentFrame = 0;
  }
  /**
   * Restore particles from serialized state (for checkpoint restoration)
   * DETERMINISM: Restores exact particle positions for scrub-safe simulation
   *
   * @param particleStates - Array of serialized particle states from a checkpoint
   * @param frameCount - The frame number being restored to
   */
  restoreParticles(particleStates, frameCount) {
    this.particles = [];
    this.trailHistory.clear();
    let maxId = 0;
    for (const state of particleStates) {
      const particle = {
        id: state.id,
        x: state.x,
        y: state.y,
        prevX: state.x,
        // Previous position set to current (no trail initially)
        prevY: state.y,
        vx: state.vx,
        vy: state.vy,
        age: state.age,
        lifetime: state.lifetime,
        size: state.size,
        baseSize: state.size,
        // Base size set to current
        color: [...state.color],
        baseColor: [...state.color],
        emitterId: state.emitterId,
        isSubParticle: false,
        rotation: state.rotation,
        angularVelocity: 0,
        // Default angular velocity
        spriteIndex: 0,
        collisionCount: 0
        // Reset collision count on restore
      };
      this.particles.push(particle);
      maxId = Math.max(maxId, state.id);
    }
    this.nextParticleId = maxId + 1;
    this.frameCount = frameCount;
  }
  warmup() {
    for (let i = 0; i < this.config.warmupPeriod; i++) {
      this.step(1);
    }
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(ctx, width, height, options = createDefaultRenderOptions()) {
    this.renderOptions = options;
    ctx.save();
    switch (options.blendMode) {
      case "additive":
        ctx.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        ctx.globalCompositeOperation = "multiply";
        break;
      case "screen":
        ctx.globalCompositeOperation = "screen";
        break;
      default:
        ctx.globalCompositeOperation = "source-over";
    }
    this.renderConnections(ctx, width, height);
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size;
      if (options.renderTrails) {
        const trail = this.trailHistory.get(p.id);
        if (trail && trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          const trailLen = Math.min(trail.length, options.trailLength);
          for (let i = 0; i < trailLen; i++) {
            const tp = trail[i];
            const opacity = p.color[3] * Math.pow(options.trailOpacityFalloff, i + 1);
            ctx.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${opacity / 255})`;
            ctx.lineWidth = size * Math.pow(options.trailOpacityFalloff, i);
            ctx.lineTo(tp.x * width, tp.y * height);
          }
          ctx.stroke();
        }
      }
      if (options.glowEnabled) {
        ctx.shadowBlur = options.glowRadius;
        ctx.shadowColor = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${options.glowIntensity})`;
      } else {
        ctx.shadowBlur = 0;
      }
      if (options.motionBlur && (p.vx !== 0 || p.vy !== 0)) {
        this.renderParticleWithMotionBlur(ctx, p, x, y, size, width, height, options);
      } else {
        this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
      }
    }
    ctx.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(ctx, p, x, y, size, _width, _height, options) {
    const velocityMag = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
    if (velocityMag < 1e-4) {
      this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape);
      return;
    }
    const stretchFactor = options.motionBlurStrength * velocityMag * 500;
    const samples = Math.min(options.motionBlurSamples, 16);
    const dirX = p.vx / velocityMag;
    const dirY = p.vy / velocityMag;
    const stretchDistance = Math.min(stretchFactor * size, size * 10);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      const sampleOpacity = (1 - t * 0.8) / samples;
      const sampleX = x - dirX * stretchDistance * t;
      const sampleY = y - dirY * stretchDistance * t;
      const sampleSize = size * (1 - t * 0.3);
      const alpha = p.color[3] / 255 * sampleOpacity * samples;
      ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${Math.min(1, alpha)})`;
      this.renderParticleShape(ctx, sampleX, sampleY, sampleSize, null, options.particleShape, p, options);
    }
    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.color[3] / 255})`;
    this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(ctx, x, y, size, color, shape, particle, options) {
    if (color) {
      ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
    }
    if (shape === "sprite" && particle) {
      this.renderSprite(ctx, x, y, size, particle, options);
      return;
    }
    const hasRotation = particle && particle.rotation !== 0;
    if (hasRotation && particle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(particle.rotation);
      this.drawShapeAtOrigin(ctx, size, shape);
      ctx.restore();
    } else {
      switch (shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          break;
        case "star":
          this.drawStar(ctx, x, y, 5, size / 2, size / 4);
          ctx.fill();
          break;
      }
    }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(ctx, size, shape) {
    switch (shape) {
      case "circle":
        ctx.beginPath();
        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case "square":
        ctx.fillRect(-size / 2, -size / 2, size, size);
        break;
      case "triangle":
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(-size / 2, size / 2);
        ctx.lineTo(size / 2, size / 2);
        ctx.closePath();
        ctx.fill();
        break;
      case "star":
        this.drawStar(ctx, 0, 0, 5, size / 2, size / 4);
        ctx.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(ctx, x, y, size, particle, options) {
    const emitter = this.emitters.get(particle.emitterId);
    if (!emitter?.sprite?.enabled) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    const sprite = emitter.sprite;
    const image = sprite.imageData || this.spriteCache.get(particle.emitterId);
    if (!image) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    ctx.save();
    ctx.imageSmoothingEnabled = options?.spriteSmoothing ?? true;
    let alpha = particle.color[3] / 255;
    if (options?.spriteOpacityByAge) {
      const lifeRatio = particle.age / particle.lifetime;
      if (lifeRatio > 0.8) {
        alpha *= 1 - (lifeRatio - 0.8) / 0.2;
      }
    }
    ctx.globalAlpha = alpha;
    let sx = 0;
    let sy = 0;
    let sw = image.width;
    let sh = image.height;
    if (sprite.isSheet && sprite.columns > 1 || sprite.rows > 1) {
      const frameWidth = image.width / sprite.columns;
      const frameHeight = image.height / sprite.rows;
      const col = particle.spriteIndex % sprite.columns;
      const row = Math.floor(particle.spriteIndex / sprite.columns) % sprite.rows;
      sx = col * frameWidth;
      sy = row * frameHeight;
      sw = frameWidth;
      sh = frameHeight;
    }
    ctx.translate(x, y);
    if (particle.rotation !== 0) {
      ctx.rotate(particle.rotation);
    }
    const halfSize = size / 2;
    ctx.drawImage(
      image,
      sx,
      sy,
      sw,
      sh,
      // Source rectangle
      -halfSize,
      -halfSize,
      size,
      size
      // Destination rectangle
    );
    ctx.restore();
  }
  drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    ctx.beginPath();
    let rotation = -Math.PI / 2;
    for (let i = 0; i < spikes; i++) {
      const outerX = cx + Math.cos(rotation) * outerRadius;
      const outerY = cy + Math.sin(rotation) * outerRadius;
      if (i === 0) {
        ctx.moveTo(outerX, outerY);
      } else {
        ctx.lineTo(outerX, outerY);
      }
      rotation += Math.PI / spikes;
      const innerX = cx + Math.cos(rotation) * innerRadius;
      const innerY = cy + Math.sin(rotation) * innerRadius;
      ctx.lineTo(innerX, innerY);
      rotation += Math.PI / spikes;
    }
    ctx.closePath();
  }
  renderToMask(width, height) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    const connConfig = this.renderOptions.connections;
    if (connConfig?.enabled && this.particles.length >= 2) {
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = connConfig.lineWidth * 2;
      this.renderConnections(ctx, width, height);
    }
    ctx.fillStyle = "#000000";
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
    return ctx.getImageData(0, 0, width, height);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(data) {
    const system = new ParticleSystem(data.config);
    if (data.emitters) {
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
    }
    if (data.modulations) {
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
    }
    return system;
  }
}

class SeededRNG {
  state;
  constructor(seed) {
    this.state = seed;
  }
  /** Reset to initial seed */
  reset(seed) {
    this.state = seed;
  }
  /** Get next random number in [0, 1) */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
}
class ParticleSimulationController {
  /** The underlying particle system (used for simulation) */
  system;
  /** Configuration (immutable after construction) */
  config;
  /** Master seed for deterministic simulation */
  seed;
  /** Seeded RNG instance */
  rng;
  /** Checkpoint interval (frames between cached states) */
  checkpointInterval;
  /** Cached checkpoints: frame  checkpoint */
  checkpoints;
  /** Last evaluated frame (for optimization) */
  lastEvaluatedFrame = -1;
  /** Last snapshot (cached for repeated access) */
  lastSnapshot = null;
  constructor(config, seed = 12345, checkpointInterval = 30) {
    this.config = { ...config };
    this.seed = seed;
    this.rng = new SeededRNG(seed);
    this.checkpointInterval = checkpointInterval;
    this.checkpoints = /* @__PURE__ */ new Map();
    this.system = new ParticleSystem(config, seed);
    this.createCheckpoint(0);
  }
  /**
   * Evaluate particle state at a specific frame
   *
   * PURE (relative to frame number): Same frame always produces same result.
   *
   * @param frame - Target frame number
   * @returns Immutable ParticleSnapshot
   */
  evaluateAtFrame(frame) {
    if (frame === this.lastEvaluatedFrame && this.lastSnapshot) {
      return this.lastSnapshot;
    }
    const checkpointFrame = this.findNearestCheckpoint(frame);
    this.restoreCheckpoint(checkpointFrame);
    const framesToSimulate = frame - checkpointFrame;
    for (let i = 0; i < framesToSimulate; i++) {
      this.deterministicStep();
      const currentFrame = checkpointFrame + i + 1;
      if (currentFrame % this.checkpointInterval === 0 && !this.checkpoints.has(currentFrame)) {
        this.createCheckpoint(currentFrame);
      }
    }
    const snapshot = this.createSnapshot(frame);
    this.lastEvaluatedFrame = frame;
    this.lastSnapshot = snapshot;
    return snapshot;
  }
  /**
   * Get the underlying particles for rendering
   * NOTE: This is a convenience method; prefer evaluateAtFrame() for determinism
   */
  getParticles() {
    return this.system.getParticles();
  }
  /**
   * Reset controller and clear all checkpoints
   */
  reset() {
    this.system.reset();
    this.rng.reset(this.seed);
    this.checkpoints.clear();
    this.lastEvaluatedFrame = -1;
    this.lastSnapshot = null;
    this.createCheckpoint(0);
  }
  /**
   * Update configuration (clears all checkpoints)
   */
  updateConfig(updates) {
    Object.assign(this.config, updates);
    this.system.setConfig(updates);
    this.reset();
  }
  /**
   * Get current seed
   */
  getSeed() {
    return this.seed;
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  /**
   * Find the frame number of the nearest checkpoint at or before target
   */
  findNearestCheckpoint(targetFrame) {
    let nearest = 0;
    for (const frame of this.checkpoints.keys()) {
      if (frame <= targetFrame && frame > nearest) {
        nearest = frame;
      }
    }
    return nearest;
  }
  /**
   * Create a checkpoint at the current state
   * DETERMINISM: Captures RNG state for exact restoration
   */
  createCheckpoint(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    const checkpoint = {
      frame,
      particles,
      emissionAccumulators: /* @__PURE__ */ new Map(),
      // Would need access to system internals
      nextParticleId: particles.length > 0 ? Math.max(...particles.map((p) => p.id)) + 1 : 0,
      noiseTime: 0,
      // Would need access to system internals
      frameCount: frame,
      // Capture RNG state from the particle system for deterministic restoration
      rngState: this.system.getRng().getState()
    };
    this.checkpoints.set(frame, checkpoint);
  }
  /**
   * Restore state from a checkpoint
   * DETERMINISM: Restores exact RNG state for reproducible continuation
   */
  restoreCheckpoint(frame) {
    const checkpoint = this.checkpoints.get(frame);
    if (!checkpoint) {
      throw new Error(`No checkpoint at frame ${frame}`);
    }
    this.system.getRng().setState(checkpoint.rngState);
    this.rng.setState(checkpoint.rngState);
    this.system.restoreParticles(checkpoint.particles, checkpoint.frame);
  }
  /**
   * Perform one deterministic simulation step
   * DETERMINISM: ParticleSystem now uses seeded RNG (mulberry32) for all randomness
   */
  deterministicStep() {
    this.system.step(1);
  }
  /**
   * Serialize a particle to immutable state
   */
  serializeParticle(p) {
    return Object.freeze({
      id: p.id,
      x: p.x,
      y: p.y,
      vx: p.vx,
      vy: p.vy,
      age: p.age,
      lifetime: p.lifetime,
      size: p.size,
      color: Object.freeze([...p.color]),
      rotation: p.rotation,
      emitterId: p.emitterId
    });
  }
  /**
   * Create an immutable snapshot of current state
   * DETERMINISM: No timestamps - only deterministic values
   */
  createSnapshot(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    return Object.freeze({
      frame,
      particles: Object.freeze(particles),
      count: particles.length,
      seed: this.seed,
      rngState: this.system.getRng().getState()
    });
  }
}
class ParticleSimulationRegistry {
  controllers = /* @__PURE__ */ new Map();
  /**
   * Get or create a controller for a layer
   */
  getController(layerId, config, seed) {
    let controller = this.controllers.get(layerId);
    if (!controller) {
      controller = new ParticleSimulationController(config, seed ?? this.generateSeed(layerId));
      this.controllers.set(layerId, controller);
    }
    return controller;
  }
  /**
   * Evaluate particles for a layer at a frame
   */
  evaluateLayer(layerId, frame, config, seed) {
    const controller = this.getController(layerId, config, seed);
    return controller.evaluateAtFrame(frame);
  }
  /**
   * Reset a specific layer's controller
   */
  resetLayer(layerId) {
    const controller = this.controllers.get(layerId);
    if (controller) {
      controller.reset();
    }
  }
  /**
   * Clear all controllers
   */
  clear() {
    this.controllers.clear();
  }
  /**
   * Generate deterministic seed from layer ID
   */
  generateSeed(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
const particleSimulationRegistry = new ParticleSimulationRegistry();

class MotionEngine {
  /**
   * Internal state: NONE
   * This class is intentionally stateless between evaluate() calls
   */
  /**
   * Evaluate complete frame state
   *
   * PURE FUNCTION: Same inputs always produce same outputs
   * NO SIDE EFFECTS: Does not mutate project, layers, or any external state
   *
   * @param frame - Absolute frame number (0-indexed)
   * @param project - The project data (read-only)
   * @param audioAnalysis - Pre-computed audio analysis (optional)
   * @param activeCameraId - ID of active camera layer (optional)
   * @returns Immutable FrameState snapshot
   */
  evaluate(frame, project, audioAnalysis, activeCameraId) {
    const composition = project.compositions[project.mainCompositionId];
    if (!composition) {
      return this.createEmptyFrameState(frame, project.composition);
    }
    const evaluatedLayers = this.evaluateLayers(frame, composition.layers);
    const evaluatedCamera = this.evaluateCamera(
      frame,
      composition.layers,
      activeCameraId ?? null
    );
    const evaluatedAudio = this.evaluateAudio(frame, audioAnalysis ?? null);
    const particleSnapshots = this.evaluateParticleLayers(frame, composition.layers);
    return Object.freeze({
      frame,
      composition: composition.settings,
      layers: Object.freeze(evaluatedLayers),
      camera: evaluatedCamera,
      audio: evaluatedAudio,
      particleSnapshots: Object.freeze(particleSnapshots)
    });
  }
  /**
   * Evaluate a single property at a given frame
   * Utility method for UI components that need individual values
   */
  evaluateProperty(property, frame) {
    return interpolateProperty(property, frame);
  }
  /**
   * Check if a layer is visible at a given frame
   */
  isLayerVisibleAtFrame(layer, frame) {
    return layer.visible && frame >= layer.inPoint && frame <= layer.outPoint;
  }
  // ============================================================================
  // PRIVATE EVALUATION METHODS
  // ============================================================================
  evaluateLayers(frame, layers) {
    const evaluated = [];
    for (const layer of layers) {
      const inRange = frame >= layer.inPoint && frame <= layer.outPoint;
      const visible = layer.visible && inRange;
      const transform = this.evaluateTransform(frame, layer.transform, layer.threeD);
      const opacity = interpolateProperty(layer.opacity, frame);
      const effects = this.evaluateEffects(frame, layer.effects);
      const properties = this.evaluateLayerProperties(frame, layer);
      evaluated.push(Object.freeze({
        id: layer.id,
        type: layer.type,
        name: layer.name,
        visible,
        inRange,
        opacity,
        transform: Object.freeze(transform),
        effects: Object.freeze(effects),
        properties: Object.freeze(properties),
        parentId: layer.parentId,
        blendMode: layer.blendMode,
        threeD: layer.threeD,
        layerRef: layer
        // Reference for static data only - NOT for evaluation
      }));
    }
    return evaluated;
  }
  evaluateTransform(frame, transform, is3D) {
    const position = interpolateProperty(transform.position, frame);
    const anchorPoint = interpolateProperty(transform.anchorPoint, frame);
    const scale = interpolateProperty(transform.scale, frame);
    const rotation = interpolateProperty(transform.rotation, frame);
    const result = {
      position: { ...position },
      anchorPoint: { ...anchorPoint },
      scale: { ...scale },
      rotation
    };
    if (is3D) {
      return {
        ...result,
        rotationX: transform.rotationX ? interpolateProperty(transform.rotationX, frame) : 0,
        rotationY: transform.rotationY ? interpolateProperty(transform.rotationY, frame) : 0,
        rotationZ: transform.rotationZ ? interpolateProperty(transform.rotationZ, frame) : rotation
      };
    }
    return result;
  }
  evaluateEffects(frame, effects) {
    return effects.map((effect) => {
      const evaluatedParams = {};
      for (const [key, param] of Object.entries(effect.parameters)) {
        if (this.isAnimatableProperty(param)) {
          evaluatedParams[key] = interpolateProperty(param, frame);
        } else {
          evaluatedParams[key] = param;
        }
      }
      return Object.freeze({
        id: effect.id,
        type: effect.effectKey,
        // Use effectKey as the effect type identifier
        enabled: effect.enabled,
        parameters: Object.freeze(evaluatedParams)
      });
    });
  }
  evaluateLayerProperties(frame, layer) {
    const evaluated = {};
    for (const prop of layer.properties) {
      evaluated[prop.name] = interpolateProperty(prop, frame);
    }
    switch (layer.type) {
      case "text":
        break;
      case "solid":
        break;
      case "depthflow":
        if (layer.data && "animatedZoom" in layer.data) {
          const data = layer.data;
          if (data.animatedZoom) {
            evaluated["zoom"] = interpolateProperty(data.animatedZoom, frame);
          }
          if (data.animatedOffsetX) {
            evaluated["offsetX"] = interpolateProperty(data.animatedOffsetX, frame);
          }
          if (data.animatedOffsetY) {
            evaluated["offsetY"] = interpolateProperty(data.animatedOffsetY, frame);
          }
          if (data.animatedRotation) {
            evaluated["rotation"] = interpolateProperty(data.animatedRotation, frame);
          }
        }
        break;
      case "particles":
        evaluated["_requiresSimulation"] = true;
        break;
    }
    return evaluated;
  }
  evaluateCamera(frame, layers, activeCameraId) {
    let cameraLayer;
    if (activeCameraId) {
      cameraLayer = layers.find(
        (l) => l.id === activeCameraId && l.type === "camera"
      );
    }
    if (!cameraLayer) {
      cameraLayer = layers.find(
        (l) => l.type === "camera" && l.visible && frame >= l.inPoint && frame <= l.outPoint
      );
    }
    if (!cameraLayer || !cameraLayer.data) {
      return null;
    }
    const cameraData = cameraLayer.data;
    const transform = this.evaluateTransform(frame, cameraLayer.transform, true);
    let position = { x: transform.position.x, y: transform.position.y, z: 0 };
    let target = { x: 0, y: 0, z: 0 };
    let fov = 50;
    let focalLength = 50;
    if (cameraData.animatedPosition) {
      const pos = interpolateProperty(cameraData.animatedPosition, frame);
      position = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    }
    if (cameraData.animatedTarget) {
      const tgt = interpolateProperty(cameraData.animatedTarget, frame);
      target = { x: tgt.x, y: tgt.y, z: tgt.z ?? 0 };
    }
    if (cameraData.animatedFov) {
      fov = interpolateProperty(cameraData.animatedFov, frame);
    }
    if (cameraData.animatedFocalLength) {
      focalLength = interpolateProperty(cameraData.animatedFocalLength, frame);
    }
    let focusDistance = cameraData.depthOfField?.focusDistance ?? 1e3;
    let aperture = cameraData.depthOfField?.aperture ?? 2.8;
    let blurLevel = cameraData.depthOfField?.blurLevel ?? 50;
    if (cameraData.animatedFocusDistance) {
      focusDistance = interpolateProperty(cameraData.animatedFocusDistance, frame);
    }
    if (cameraData.animatedAperture) {
      aperture = interpolateProperty(cameraData.animatedAperture, frame);
    }
    if (cameraData.animatedBlurLevel) {
      blurLevel = interpolateProperty(cameraData.animatedBlurLevel, frame);
    }
    return Object.freeze({
      id: cameraLayer.id,
      name: cameraLayer.name,
      position: Object.freeze(position),
      target: Object.freeze(target),
      fov,
      focalLength,
      depthOfField: Object.freeze({
        enabled: cameraData.depthOfField?.enabled ?? false,
        focusDistance,
        aperture,
        blurLevel
      })
    });
  }
  evaluateAudio(frame, analysis) {
    if (!analysis) {
      return Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      });
    }
    return Object.freeze({
      hasAudio: true,
      amplitude: getFeatureAtFrame(analysis, "amplitude", frame),
      rms: getFeatureAtFrame(analysis, "rms", frame),
      bass: getFeatureAtFrame(analysis, "bass", frame),
      mid: getFeatureAtFrame(analysis, "mid", frame),
      high: getFeatureAtFrame(analysis, "high", frame),
      spectralCentroid: getFeatureAtFrame(analysis, "spectralCentroid", frame),
      isBeat: getFeatureAtFrame(analysis, "onsets", frame) > 0.5,
      isOnset: getFeatureAtFrame(analysis, "onsets", frame) > 0,
      bpm: analysis.bpm
    });
  }
  /**
   * Evaluate particle layers through deterministic simulation
   * DETERMINISM: Uses ParticleSimulationRegistry which guarantees same frame = same result
   */
  evaluateParticleLayers(frame, layers) {
    const snapshots = {};
    for (const layer of layers) {
      if (layer.type !== "particles" || !layer.visible) continue;
      if (frame < layer.inPoint || frame > layer.outPoint) continue;
      const data = layer.data;
      if (!data?.systemConfig) continue;
      const config = this.convertToParticleSystemConfig(data);
      const relativeFrame = frame - layer.inPoint;
      const snapshot = particleSimulationRegistry.evaluateLayer(
        layer.id,
        relativeFrame,
        config
      );
      snapshots[layer.id] = snapshot;
    }
    return snapshots;
  }
  /**
   * Convert ParticleLayerData to ParticleSystemConfig
   * Maps the project-level configuration to the simulation config
   */
  convertToParticleSystemConfig(data) {
    const sys = data.systemConfig;
    return {
      maxParticles: sys.maxParticles,
      gravity: sys.gravity,
      windStrength: sys.windStrength,
      windDirection: sys.windDirection,
      warmupPeriod: sys.warmupPeriod,
      respectMaskBoundary: sys.respectMaskBoundary,
      boundaryBehavior: sys.boundaryBehavior,
      friction: sys.friction,
      turbulenceFields: sys.turbulenceFields ?? [],
      subEmitters: sys.subEmitters ?? [],
      collision: {
        enabled: false,
        particleCollision: false,
        particleCollisionRadius: 1,
        particleCollisionResponse: "bounce",
        particleCollisionDamping: 0.5,
        layerCollision: false,
        layerCollisionLayerId: null,
        layerCollisionThreshold: 0.5,
        floorEnabled: false,
        floorY: 1,
        ceilingEnabled: false,
        ceilingY: 0,
        wallsEnabled: false,
        bounciness: 0.8,
        friction: 0.1,
        spatialHashCellSize: 32
      }
    };
  }
  /**
   * Create empty frame state for missing compositions
   * DETERMINISM: No timestamps or non-deterministic values
   */
  createEmptyFrameState(frame, settings) {
    return Object.freeze({
      frame,
      composition: settings,
      layers: Object.freeze([]),
      camera: null,
      audio: Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      }),
      particleSnapshots: Object.freeze({})
    });
  }
  /**
   * Type guard to check if a value is an AnimatableProperty
   */
  isAnimatableProperty(value) {
    return typeof value === "object" && value !== null && "value" in value && "keyframes" in value && Array.isArray(value.keyframes);
  }
}
const motionEngine = new MotionEngine();

/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "170";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut$1 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID$1() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut$1[d0 & 255] + _lut$1[d0 >> 8 & 255] + _lut$1[d0 >> 16 & 255] + _lut$1[d0 >> 24 & 255] + "-" + _lut$1[d1 & 255] + _lut$1[d1 >> 8 & 255] + "-" + _lut$1[d1 >> 16 & 15 | 64] + _lut$1[d1 >> 24 & 255] + "-" + _lut$1[d2 & 63 | 128] + _lut$1[d2 >> 8 & 255] + "-" + _lut$1[d2 >> 16 & 255] + _lut$1[d2 >> 24 & 255] + _lut$1[d3 & 255] + _lut$1[d3 >> 8 & 255] + _lut$1[d3 >> 16 & 255] + _lut$1[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
}
function lerp$1(x, y, t) {
  return (1 - t) * x + t * y;
}
function damp(x, y, lambda, dt) {
  return lerp$1(x, y, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID: generateUUID$1,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp: lerp$1,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize$1,
  denormalize
};
class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function(resolve, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}
function toNormalizedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  m[2] = 0.5 * m[2] + 0.5 * m[3];
  m[6] = 0.5 * m[6] + 0.5 * m[7];
  m[10] = 0.5 * m[10] + 0.5 * m[11];
  m[14] = 0.5 * m[14] + 0.5 * m[15];
}
function toReversedProjectionMatrix(projectionMatrix) {
  const m = projectionMatrix.elements;
  const isPerspectiveMatrix = m[11] === -1;
  if (isPerspectiveMatrix) {
    m[10] = -m[10] - 1;
    m[14] = -m[14];
  } else {
    m[10] = -m[10];
    m[14] = -m[14] + 1;
  }
}
const ColorManagement = {
  enabled: true,
  workingColorSpace: LinearSRGBColorSpace,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
      color.r = SRGBToLinear(color.r);
      color.g = SRGBToLinear(color.g);
      color.b = SRGBToLinear(color.b);
    }
    if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
      color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
      color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
    }
    if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
      color.r = LinearToSRGB(color.r);
      color.g = LinearToSRGB(color.g);
      color.b = LinearToSRGB(color.b);
    }
    return color;
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return this.spaces[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return this.spaces[colorSpace].transfer;
  },
  getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
    return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
  },
  define: function(colorSpaces) {
    Object.assign(this.spaces, colorSpaces);
  },
  // Internal APIs
  _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
    return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(colorSpace) {
    return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
    return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
const D65 = [0.3127, 0.329];
const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
ColorManagement.define({
  [LinearSRGBColorSpace]: {
    primaries: REC709_PRIMARIES,
    whitePoint: D65,
    transfer: LinearTransfer,
    toXYZ: LINEAR_REC709_TO_XYZ,
    fromXYZ: XYZ_TO_LINEAR_REC709,
    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
    workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  },
  [SRGBColorSpace]: {
    primaries: REC709_PRIMARIES,
    whitePoint: D65,
    transfer: SRGBTransfer,
    toXYZ: LINEAR_REC709_TO_XYZ,
    fromXYZ: XYZ_TO_LINEAR_REC709,
    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  }
});
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID$1();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    this.w /= v.w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1
    }, options);
    const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture.clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.textures.length; i < il; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il = source.textures.length; i < il; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$3.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$3);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$3, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$3 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$4 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent) {
      _m1$3.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      child.updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
const _v40 = /* @__PURE__ */ new Vector4();
const _v41 = /* @__PURE__ */ new Vector4();
const _v42 = /* @__PURE__ */ new Vector4();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$2.subVectors(a, b);
    target.cross(_v0$2);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$2.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$2.dot(_v0$2);
    const dot01 = _v0$2.dot(_v1$3);
    const dot02 = _v0$2.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$2.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$2.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$2.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$2.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
class Color {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp$1(_hslA.h, _hslB.h, alpha);
    const s = lerp$1(_hslA.s, _hslB.s, alpha);
    const l = lerp$1(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class MeshBasicMaterial extends Material {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _tables = /* @__PURE__ */ _generateTables();
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> -e - 14;
      baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 256] = e + 15 << 10 | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= -8388609;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 511;
  return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
}
function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}
const DataUtils = {
  toHalfFloat,
  fromHalfFloat
};
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize$1(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize$1(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = denormalize(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized) y = normalize$1(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize$1(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize$1(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize$1(x, this.array);
      y = normalize$1(y, this.array);
      z = normalize$1(z, this.array);
      w = normalize$1(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$2 = 0;
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID$1();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  setIndirect(indirect) {
    this.indirect = indirect;
    return this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1$2.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateX(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateY(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateZ(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  translate(x, y, z) {
    _m1$2.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  scale(x, y, z) {
    _m1$2.makeScale(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      for (let i = 0, l = positionAttribute.count; i < l; i++) {
        const point = points[i];
        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index.count
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          index.getX(j + 0),
          index.getX(j + 1),
          index.getX(j + 2)
        );
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromBufferAttribute(normalAttribute, v);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp2.x, tmp2.y, tmp2.z, w);
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(distance, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(distance, target) {
    this.getViewBounds(distance, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(sprite) {
    _sphere$5.center.set(0, 0, 0);
    _sphere$5.radius = 0.7071067811865476;
    _sphere$5.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a, b) => a.start - b.start);
      let mergeIndex = 0;
      for (let i = 1; i < updateRanges.length; i++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  }
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList
  };
}
function WebGLBindingStates(gl, attributes) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reverseDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, 1)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    this._renderer.xr.enabled = _oldXrEnabled;
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill2 = [face, face, face, face, face, face];
      faceIndex.set(fill2, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture);
      };
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i = 0; i < morphTargetsCount; i++) {
        const morphTarget = morphTargets[i];
        const morphNormal = morphNormals[i];
        const morphColor = morphColors[i];
        const offset = width * height * 4 * i;
        for (let j = 0; j < morphTarget.count; j++) {
          const stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0) u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0) this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values) r.push(u);
    }
    return r;
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
const _m0 = /* @__PURE__ */ new Matrix3();
function getEncodingComponents(colorSpace) {
  ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);
  const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;
  switch (ColorManagement.getTransfer(colorSpace)) {
    case LinearTransfer:
      return [encodingMatrix, "LinearTransferOETF"];
    case SRGBTransfer:
      return [encodingMatrix, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space: ", colorSpace);
      return [encodingMatrix, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return [
    `vec4 ${functionName}( vec4 value ) {`,
    `	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
    "}"
  ].join("\n");
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "Cineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
const _v0$1 = /* @__PURE__ */ new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  const r = _v0$1.x.toFixed(4);
  const g = _v0$1.y.toFixed(4);
  const b = _v0$1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${g}, ${b} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code) {
    this.id = _id$1++;
    this.code = code;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const reverseDepthBuffer = renderer.state.buffers.depth.getReversed();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures)
      _programLayers.enable(0);
    if (parameters.instancing)
      _programLayers.enable(1);
    if (parameters.instancingColor)
      _programLayers.enable(2);
    if (parameters.instancingMorph)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    if (parameters.batching)
      _programLayers.enable(19);
    if (parameters.dispersion)
      _programLayers.enable(20);
    if (parameters.batchingColor)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reverseDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.decodeVideoTextureEmissive)
      _programLayers.enable(20);
    if (parameters.alphaToCoverage)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum2 = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum2 = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
const reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl, extensions) {
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let reversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(value) {
        if (reversed !== value) {
          const ext = extensions.get("EXT_clip_control");
          if (reversed) {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
          } else {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
          }
          const oldDepth = currentDepthClear;
          currentDepthClear = null;
          this.setClear(oldDepth);
        }
        reversed = value;
      },
      getReversed: function() {
        return reversed;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (reversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          if (reversed) {
            depth = 1 - depth;
          }
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
        reversed = false;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i = 0; i < count; i++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    depthBuffer.setReversed(false);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getTargetType(texture) {
    if (texture.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;
    if (texture.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;
    if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;
    return _gl.TEXTURE_2D;
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
      properties.remove(renderTarget.depthTexture);
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const attachmentProperties = properties.get(textures[i]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image.data.subarray(
                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    textureProperties.__renderTarget = renderTarget;
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const samples = getRenderTargetSamples(renderTarget);
      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    const textureProperties = properties.get(renderTarget.depthTexture);
    textureProperties.__renderTarget = renderTarget;
    if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = textureProperties.__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachmentProperties = properties.get(textures[i]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture)) {
        const targetType = getTargetType(renderTarget);
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(targetType, webglTexture);
        generateMipmap(targetType);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions) {
  function convert(p, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) return gl.HALF_FLOAT;
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  init(renderer, depthData, renderState) {
    if (this.texture === null) {
      const texture = new Texture();
      const texProps = renderer.properties.get(texture);
      texProps.__webglTexture = depthData.texture;
      if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  getMesh(cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w }
          }
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
    }
    return this.mesh;
  }
  reset() {
    this.texture = null;
    this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const depthSensing = new WebXRDepthSensing();
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
            }
          );
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    this.getDepthTexture = function() {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      if (projL[10] === -1) {
        camera.projectionMatrix.copy(cameraL2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
      } else {
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      let depthNear = camera.near;
      let depthFar = camera.far;
      if (depthSensing.texture !== null) {
        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = depthNear;
      cameraXR.far = cameraR.far = cameraL.far = depthFar;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      cameraL.layers.mask = camera.layers.mask | 2;
      cameraR.layers.mask = camera.layers.mask | 4;
      cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function() {
      return depthSensing.texture !== null;
    };
    this.getDepthSensingMesh = function() {
      return depthSensing.getMesh(cameraXR);
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
const _e1 = /* @__PURE__ */ new Euler();
const _m1 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i = 0, il = uniforms.length; i < il; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        if (hasUniformChanged(uniform, i, j, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let k = 0; k < values.length; k++) {
            const value = values[k];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    const value = uniform.value;
    const indexString = index + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i = 0, l = uniforms.length; i < l; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let k = 0, kl = values.length; k < kl; k++) {
          const value = values[k];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = false,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false,
      reverseDepthBuffer = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      if (typeof WebGLRenderingContext !== "undefined" && context instanceof WebGLRenderingContext) {
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      }
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum2 = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _currentProjectionMatrix = new Matrix4();
    const _projScreenMatrix2 = new Matrix4();
    const _vector32 = new Vector3();
    const _vector4 = new Vector4();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextName = "webgl2";
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl, extensions);
      if (capabilities.reverseDepthBuffer && reverseDepthBuffer) {
        state.buffers.depth.setReversed(true);
      }
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) {
        bits |= _gl.DEPTH_BUFFER_BIT;
      }
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get("WEBGL_multi_draw")) {
            const starts = object._multiDrawStarts;
            const counts = object._multiDrawCounts;
            const drawCount2 = object._multiDrawCount;
            const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
            const uniforms = properties.get(material).currentProgram.getUniforms();
            for (let i = 0; i < drawCount2; i++) {
              uniforms.setValue(_gl, "_gl_DrawID", i);
              renderer.render(starts[i] / bytesPerElement, counts[i]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
          return;
        }
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum2.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr.enabled === true && xr.isPresenting === true) {
        const depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      const opaqueObjects = currentRenderList.opaque;
      const transmissiveObjects = currentRenderList.transmissive;
      currentRenderState.setupLights();
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        if (transmissiveObjects.length > 0) {
          for (let i = 0, l = cameras.length; i < l; i++) {
            const camera2 = cameras[i];
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
          }
        }
        if (_renderBackground) background.render(scene);
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
        if (_renderBackground) background.render(scene);
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum2.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector4.copy(geometry.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: 4,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement.workingColorSpace
        });
      }
      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      const activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      const currentCameraViewport = camera.viewport;
      if (camera.viewport !== void 0) camera.viewport = void 0;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
        let renderTargetNeedsUpdate = false;
        for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
          const renderItem = transmissiveObjects[i];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = renderItem.material;
          const group = renderItem.group;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            const currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.batchingColor = parameters2.batchingColor;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        const reverseDepthBuffer2 = state.buffers.depth.getReversed();
        if (reverseDepthBuffer2) {
          _currentProjectionMatrix.copy(camera.projectionMatrix);
          toNormalizedProjectionMatrix(_currentProjectionMatrix);
          toReversedProjectionMatrix(_currentProjectionMatrix);
          p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
        } else {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        }
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingIdTexture");
        p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingColorTexture");
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l = groups.length; i < l; i++) {
          const group = groups[i];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        } else if (renderTarget.depthBuffer) {
          const depthTexture = renderTarget.depthTexture;
          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            }
            textures.setupDepthRenderbuffer(renderTarget);
          }
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (!capabilities.textureFormatReadable(textureFormat)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        }
        if (!capabilities.textureTypeReadable(textureType)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        }
        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          const glBuffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          _gl.flush();
          await probeAsync(_gl, sync, 4);
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
          _gl.deleteBuffer(glBuffer);
          _gl.deleteSync(sync);
          return buffer;
        } else {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }
    };
    this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
      if (texture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
        position = arguments[0] || null;
        texture = arguments[1];
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const x = position !== null ? position.x : 0;
      const y = position !== null ? position.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
        dstPosition = arguments[0] || null;
        srcTexture = arguments[1];
        dstTexture = arguments[2];
        level = arguments[3] || 0;
        srcRegion = null;
      }
      let width, height, depth2, minX, minY, minZ;
      let dstX, dstY, dstZ;
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
      } else {
        width = image.width;
        height = image.height;
        depth2 = image.depth || 1;
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        textures.setTexture2D(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
      const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
      if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
        const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < depth2; i++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, level, minZ + i);
          }
          if (srcTexture.isDepthTexture) {
            if (isDst3D) {
              _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, level, dstZ + i);
            }
            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
          } else if (isDst3D) {
            _gl.copyTexSubImage3D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);
          } else {
            _gl.copyTexSubImage2D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else {
        if (isDst3D) {
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
          } else if (dstTexture.isCompressedArrayTexture) {
            _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
          } else {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
          }
        } else {
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
          } else if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
          } else {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
          }
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps) {
        _gl.generateMipmap(glTarget);
      }
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
        srcRegion = arguments[0] || null;
        dstPosition = arguments[1] || null;
        srcTexture = arguments[2];
        dstTexture = arguments[3];
        level = arguments[4] || 0;
      }
      warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.');
      return this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
    };
    this.initRenderTarget = function(target) {
      if (properties.get(target).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorspace = ColorManagement._getDrawingBufferColorSpace(colorSpace);
    gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
class LineBasicMaterial extends Material {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vStart = /* @__PURE__ */ new Vector3();
const _vEnd = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
const _intersectPointOnRay = /* @__PURE__ */ new Vector3();
const _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i = 1, l = positionAttribute.count; i < l; i++) {
        _vStart.fromBufferAttribute(positionAttribute, i - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i);
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, l = end - 1; i < l; i += step) {
        const a = index.getX(i);
        const b = index.getX(i + 1);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const a = index.getX(end - 1);
        const b = index.getX(start);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l = end - 1; i < l; i += step) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i);
        _end.fromBufferAttribute(positionAttribute, i + 1);
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isVideoTexture = true;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isCanvasTexture = true;
    this.needsUpdate = true;
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
const tmp = /* @__PURE__ */ new Vector3();
const px = /* @__PURE__ */ new CubicPoly();
const py = /* @__PURE__ */ new CubicPoly();
const pz = /* @__PURE__ */ new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector3()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          if (radiusTop > 0 || y !== 0) {
            indices.push(a, b, d);
            groupCount += 3;
          }
          if (radiusBottom > 0 || y !== heightSegments - 1) {
            indices.push(b, c, d);
            groupCount += 3;
          }
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID$1();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode, qx = -Infinity, m;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class RawShaderMaterial extends ShaderMaterial {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
  }
}
class MeshStandardMaterial extends Material {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { "STANDARD": "" };
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshNormalMaterial extends Material {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    if (this.target !== void 0) data.object.target = this.target.uuid;
    return data;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.isInstancedBufferGeometry = true;
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now$2();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now$2();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}
function now$2() {
  return performance.now();
}
const _matrix = /* @__PURE__ */ new Matrix4();
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction) {
    this.ray.set(origin, direction);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  setFromXRController(controller) {
    _matrix.identity().extractRotation(controller.matrixWorld);
    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
    return this;
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersect(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersect(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  let propagate = true;
  if (object.layers.test(raycaster.layers)) {
    const result = object.raycast(raycaster, intersects2);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersect(children[i], raycaster, intersects2, true);
    }
  }
}
const _vector$3 = /* @__PURE__ */ new Vector3();
class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "SpotLightHelper";
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(
        Math.cos(p1),
        Math.sin(p1),
        1,
        Math.cos(p2),
        Math.sin(p2),
        1
      );
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    if (this.parent) {
      this.parent.updateWorldMatrix(true);
      this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
    } else {
      this.matrix.copy(this.light.matrixWorld);
    }
    this.matrixWorld.copy(this.light.matrixWorld);
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    super(geometry, material);
    this.light = light;
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
const _v1$1 = /* @__PURE__ */ new Vector3();
const _v2$1 = /* @__PURE__ */ new Vector3();
const _v3$3 = /* @__PURE__ */ new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "DirectionalLightHelper";
    if (size === void 0) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    _v1$1.setFromMatrixPosition(this.light.matrixWorld);
    _v2$1.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$3.subVectors(_v2$1, _v1$1);
    this.lightPlane.lookAt(_v2$1);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$1);
    this.targetLine.scale.z = _v3$3.length();
  }
}
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class Controls extends EventDispatcher {
  constructor(object, domElement = null) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.state = -1;
    this.keys = {};
    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
    this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

const easingFunctions = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (t) => t,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return c3 * t * t * t - c1 * t * t;
  },
  easeOutBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  },
  easeInOutBack: (t) => {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;
    return t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
  },
  easeOutElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  },
  easeInOutElastic: (t) => {
    const c5 = 2 * Math.PI / 4.5;
    return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (t) => 1 - easingFunctions.easeOutBounce(1 - t),
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInOutBounce: (t) => t < 0.5 ? (1 - easingFunctions.easeOutBounce(1 - 2 * t)) / 2 : (1 + easingFunctions.easeOutBounce(2 * t - 1)) / 2
};

class KeyframeEvaluator {
  // Cache for recent evaluations (cleared per frame batch)
  cache = /* @__PURE__ */ new Map();
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(property, frame) {
    const cacheKey = property.id;
    const cached = this.cache.get(cacheKey);
    if (cached && cached.frame === frame) {
      return cached.value;
    }
    let value;
    if (!property.animated || !property.keyframes || property.keyframes.length === 0) {
      value = property.value;
    } else {
      value = this.evaluateKeyframes(property.keyframes, frame, property.value);
    }
    this.cache.set(cacheKey, { frame, value });
    return value;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(keyframes, frame, defaultValue) {
    const sorted = [...keyframes].sort((a, b) => a.frame - b.frame);
    if (frame <= sorted[0].frame) {
      return sorted[0].value;
    }
    if (frame >= sorted[sorted.length - 1].frame) {
      return sorted[sorted.length - 1].value;
    }
    let prevKeyframe = sorted[0];
    let nextKeyframe = sorted[sorted.length - 1];
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i].frame <= frame && sorted[i + 1].frame > frame) {
        prevKeyframe = sorted[i];
        nextKeyframe = sorted[i + 1];
        break;
      }
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const rawT = frameDiff > 0 ? (frame - prevKeyframe.frame) / frameDiff : 0;
    const easedT = this.applyEasing(rawT, prevKeyframe.interpolation, prevKeyframe, nextKeyframe);
    return this.interpolateValue(prevKeyframe.value, nextKeyframe.value, easedT, defaultValue);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(t, interpolation, prevKeyframe, nextKeyframe) {
    switch (interpolation) {
      case "hold":
        return 0;
      case "linear":
        return t;
      case "bezier":
        return this.evaluateBezier(t, prevKeyframe, nextKeyframe);
      default:
        const easingFn = easingFunctions[interpolation];
        if (easingFn) {
          return easingFn(t);
        }
        return t;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(t, prevKeyframe, nextKeyframe) {
    const outHandle = prevKeyframe.outHandle;
    const inHandle = nextKeyframe.inHandle;
    if (!outHandle?.enabled && !inHandle?.enabled) {
      return t;
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const p0 = { x: 0, y: 0 };
    const p1 = {
      x: outHandle?.enabled ? Math.min(1, Math.max(0, outHandle.frame / frameDiff)) : 0.33,
      y: outHandle?.enabled ? outHandle.value : 0
    };
    const p2 = {
      x: inHandle?.enabled ? Math.min(1, Math.max(0, 1 + inHandle.frame / frameDiff)) : 0.67,
      y: inHandle?.enabled ? 1 + inHandle.value : 1
    };
    const p3 = { x: 1, y: 1 };
    return this.solveCubicBezier(t, p0.x, p1.x, p2.x, p3.x, p0.y, p1.y, p2.y, p3.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(x, x0, x1, x2, x3, y0, y1, y2, y3) {
    let t = x;
    const epsilon = 1e-4;
    for (let i = 0; i < 10; i++) {
      const currentX = this.cubicBezier(t, x0, x1, x2, x3);
      const diff = currentX - x;
      if (Math.abs(diff) < epsilon) {
        break;
      }
      const derivative = this.cubicBezierDerivative(t, x0, x1, x2, x3);
      if (Math.abs(derivative) < epsilon) {
        break;
      }
      t -= diff / derivative;
      t = Math.max(0, Math.min(1, t));
    }
    return this.cubicBezier(t, y0, y1, y2, y3);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(from, to, t, defaultValue) {
    if (typeof from === "number" && typeof to === "number") {
      return from + (to - from) * t;
    }
    if (this.isPositionLike(from) && this.isPositionLike(to)) {
      return this.interpolatePosition(from, to, t);
    }
    if (typeof from === "string" && typeof to === "string") {
      if (from.startsWith("#") && to.startsWith("#")) {
        return this.interpolateColor(from, to, t);
      }
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return this.interpolateArray(from, to, t);
    }
    return t < 0.5 ? from : to;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(value) {
    return value !== null && typeof value === "object" && "x" in value && "y" in value;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(from, to, t) {
    const result = {
      x: from.x + (to.x - from.x) * t,
      y: from.y + (to.y - from.y) * t
    };
    if ("z" in from || "z" in to) {
      result.z = (from.z ?? 0) + ((to.z ?? 0) - (from.z ?? 0)) * t;
    }
    return result;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(from, to, t) {
    const fromRGB = this.hexToRGB(from);
    const toRGB = this.hexToRGB(to);
    const r = Math.round(fromRGB.r + (toRGB.r - fromRGB.r) * t);
    const g = Math.round(fromRGB.g + (toRGB.g - fromRGB.g) * t);
    const b = Math.round(fromRGB.b + (toRGB.b - fromRGB.b) * t);
    return this.rgbToHex(r, g, b);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(from, to, t) {
    const length = Math.max(from.length, to.length);
    const result = [];
    for (let i = 0; i < length; i++) {
      const fromVal = from[i] ?? 0;
      const toVal = to[i] ?? 0;
      result.push(fromVal + (toVal - fromVal) * t);
    }
    return result;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(r, g, b) {
    return "#" + [r, g, b].map((x) => Math.max(0, Math.min(255, x)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}

const effectRenderers = /* @__PURE__ */ new Map();
function registerEffectRenderer(effectKey, renderer) {
  effectRenderers.set(effectKey, renderer);
}
function evaluateEffectParameters(effect, frame) {
  const evaluated = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    const animatableProp = param;
    evaluated[key] = interpolateProperty(animatableProp, frame);
  }
  return evaluated;
}
function processEffectStack(effects, inputCanvas, frame) {
  const workCanvas = document.createElement("canvas");
  workCanvas.width = inputCanvas.width;
  workCanvas.height = inputCanvas.height;
  const workCtx = workCanvas.getContext("2d");
  workCtx.drawImage(inputCanvas, 0, 0);
  let current = {
    canvas: workCanvas,
    ctx: workCtx
  };
  for (const effect of effects) {
    if (!effect.enabled) {
      continue;
    }
    const renderer = effectRenderers.get(effect.effectKey);
    if (!renderer) {
      renderLogger.warn(`No renderer registered for effect: ${effect.effectKey}`);
      continue;
    }
    const params = evaluateEffectParameters(effect, frame);
    try {
      current = renderer(current, params);
    } catch (error) {
      renderLogger.error(`Error applying effect ${effect.name}:`, error);
    }
  }
  return current;
}
function createMatchingCanvas(source) {
  const canvas = document.createElement("canvas");
  canvas.width = source.width;
  canvas.height = source.height;
  const ctx = canvas.getContext("2d");
  return { canvas, ctx };
}
function hasEnabledEffects(effects) {
  return effects.some((e) => e.enabled);
}

function renderMaskPath(ctx, path) {
  if (path.vertices.length < 2) return;
  ctx.beginPath();
  const vertices = path.vertices;
  const n = vertices.length;
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 0; i < n; i++) {
    const current = vertices[i];
    const next = vertices[(i + 1) % n];
    if (!path.closed && i === n - 1) break;
    const cp1x = current.x + current.outTangentX;
    const cp1y = current.y + current.outTangentY;
    const cp2x = next.x + next.inTangentX;
    const cp2y = next.y + next.inTangentY;
    if (cp1x === current.x && cp1y === current.y && cp2x === next.x && cp2y === next.y) {
      ctx.lineTo(next.x, next.y);
    } else {
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
    }
  }
  if (path.closed) {
    ctx.closePath();
  }
}
function calculateVertexNormal(prev, curr, next) {
  let inDx, inDy;
  if (curr.inTangentX || curr.inTangentY) {
    inDx = -curr.inTangentX;
    inDy = -curr.inTangentY;
  } else {
    inDx = curr.x - prev.x;
    inDy = curr.y - prev.y;
  }
  let outDx, outDy;
  if (curr.outTangentX || curr.outTangentY) {
    outDx = curr.outTangentX;
    outDy = curr.outTangentY;
  } else {
    outDx = next.x - curr.x;
    outDy = next.y - curr.y;
  }
  const inLen = Math.sqrt(inDx * inDx + inDy * inDy);
  if (inLen > 0) {
    inDx /= inLen;
    inDy /= inLen;
  }
  const outLen = Math.sqrt(outDx * outDx + outDy * outDy);
  if (outLen > 0) {
    outDx /= outLen;
    outDy /= outLen;
  }
  const inNx = -inDy;
  const inNy = inDx;
  const outNx = -outDy;
  const outNy = outDx;
  let nx = (inNx + outNx) / 2;
  let ny = (inNy + outNy) / 2;
  const nLen = Math.sqrt(nx * nx + ny * ny);
  if (nLen > 0) {
    nx /= nLen;
    ny /= nLen;
  } else {
    nx = inNx;
    ny = inNy;
  }
  const dot = inNx * outNx + inNy * outNy;
  const miterFactor = 1 / Math.max(0.5, (1 + dot) / 2);
  return {
    nx: nx * Math.min(miterFactor, 2),
    ny: ny * Math.min(miterFactor, 2)
  };
}
function expandMaskPath(path, expansion) {
  if (expansion === 0) return path;
  const vertices = path.vertices;
  if (vertices.length < 2) return path;
  const expandedVertices = [];
  for (let i = 0; i < vertices.length; i++) {
    const prev = vertices[(i - 1 + vertices.length) % vertices.length];
    const curr = vertices[i];
    const next = vertices[(i + 1) % vertices.length];
    const effectivePrev = !path.closed && i === 0 ? curr : prev;
    const effectiveNext = !path.closed && i === vertices.length - 1 ? curr : next;
    const { nx, ny } = calculateVertexNormal(effectivePrev, curr, effectiveNext);
    const offsetX = nx * expansion;
    const offsetY = ny * expansion;
    const handleScale = 1 + expansion / 100;
    expandedVertices.push({
      x: curr.x + offsetX,
      y: curr.y + offsetY,
      // Scale handles to maintain curve shape
      inTangentX: curr.inTangentX * handleScale,
      inTangentY: curr.inTangentY * handleScale,
      outTangentX: curr.outTangentX * handleScale,
      outTangentY: curr.outTangentY * handleScale
    });
  }
  return { ...path, vertices: expandedVertices };
}
function calculateMaskMotion(currentPath, previousPath) {
  if (!previousPath || currentPath.vertices.length !== previousPath.vertices.length) {
    return currentPath.vertices.map(() => ({
      dx: 0,
      dy: 0,
      magnitude: 0,
      angle: 0
    }));
  }
  return currentPath.vertices.map((curr, i) => {
    const prev = previousPath.vertices[i];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    return { dx, dy, magnitude, angle };
  });
}
function applyMotionAwareFeather(canvas, baseFeather, motionVectors, motionScale = 1) {
  const width = canvas.width;
  const height = canvas.height;
  let avgDx = 0;
  let avgDy = 0;
  let avgMagnitude = 0;
  for (const motion of motionVectors) {
    avgDx += motion.dx;
    avgDy += motion.dy;
    avgMagnitude += motion.magnitude;
  }
  const count = motionVectors.length || 1;
  avgDx /= count;
  avgDy /= count;
  avgMagnitude /= count;
  if (avgMagnitude < 0.5) {
    if (baseFeather > 0) {
      const ctx2 = canvas.getContext("2d");
      const blurCanvas = document.createElement("canvas");
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext("2d");
      blurCtx.filter = `blur(${baseFeather}px)`;
      blurCtx.drawImage(canvas, 0, 0);
      ctx2.clearRect(0, 0, width, height);
      ctx2.drawImage(blurCanvas, 0, 0);
    }
    return canvas;
  }
  const motionFeather = avgMagnitude * motionScale;
  const len = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
  const normDx = len > 0 ? avgDx / len : 0;
  const normDy = len > 0 ? avgDy / len : 0;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = width;
  baseCanvas.height = height;
  const baseCtx = baseCanvas.getContext("2d");
  if (baseFeather > 0) {
    baseCtx.filter = `blur(${baseFeather}px)`;
  }
  baseCtx.drawImage(canvas, 0, 0);
  const steps = Math.max(3, Math.min(15, Math.ceil(motionFeather / 2)));
  resultCtx.globalAlpha = 1 / steps;
  for (let i = 0; i < steps; i++) {
    const t = i / (steps - 1) - 0.5;
    const offsetX = normDx * motionFeather * t;
    const offsetY = normDy * motionFeather * t;
    resultCtx.drawImage(baseCanvas, offsetX, offsetY);
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, width, height);
  ctx.globalAlpha = 1;
  ctx.drawImage(resultCanvas, 0, 0);
  return canvas;
}
const previousPathCache = /* @__PURE__ */ new Map();
function getPreviousPath(maskId, currentFrame) {
  const cached = previousPathCache.get(maskId);
  if (cached && cached.frame === currentFrame - 1) {
    return cached.path;
  }
  return null;
}
function cachePath(maskId, frame, path) {
  previousPathCache.set(maskId, { frame, path });
}
function renderMask(mask, width, height, frame) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);
  if (!mask.enabled) return canvas;
  const path = interpolateProperty(mask.path, frame);
  const expansion = interpolateProperty(mask.expansion, frame);
  const opacity = interpolateProperty(mask.opacity, frame);
  const feather = interpolateProperty(mask.feather, frame);
  const expandedPath = expandMaskPath(path, expansion);
  ctx.fillStyle = "white";
  renderMaskPath(ctx, expandedPath);
  ctx.fill();
  if (opacity < 100) {
    const opacityFactor = opacity / 100;
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = Math.round(imageData.data[i] * opacityFactor);
    }
    ctx.putImageData(imageData, 0, 0);
  }
  const previousPath = getPreviousPath(mask.id, frame);
  const motionVectors = calculateMaskMotion(path, previousPath);
  cachePath(mask.id, frame, path);
  const avgMotion = motionVectors.reduce((sum, v) => sum + v.magnitude, 0) / motionVectors.length;
  if (feather > 0 || avgMotion > 1) {
    applyMotionAwareFeather(canvas, feather, motionVectors, 0.5);
  }
  if (mask.inverted) {
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = 255 - imageData.data[i];
      imageData.data[i + 1] = 255 - imageData.data[i + 1];
      imageData.data[i + 2] = 255 - imageData.data[i + 2];
    }
    ctx.putImageData(imageData, 0, 0);
  }
  return canvas;
}
function combineMasks(masks, width, height, frame) {
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const enabledMasks = masks.filter((m) => m.enabled && m.mode !== "none");
  if (enabledMasks.length === 0) {
    resultCtx.fillStyle = "white";
    resultCtx.fillRect(0, 0, width, height);
    return resultCanvas;
  }
  resultCtx.fillStyle = "black";
  resultCtx.fillRect(0, 0, width, height);
  const resultData = resultCtx.getImageData(0, 0, width, height);
  const result = resultData.data;
  for (const mask of enabledMasks) {
    const maskCanvas = renderMask(mask, width, height, frame);
    const maskCtx = maskCanvas.getContext("2d");
    const maskData = maskCtx.getImageData(0, 0, width, height);
    const maskPixels = maskData.data;
    for (let i = 0; i < result.length; i += 4) {
      const maskValue = maskPixels[i];
      switch (mask.mode) {
        case "add":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "subtract":
          result[i] = Math.max(0, result[i] - maskValue);
          result[i + 1] = Math.max(0, result[i + 1] - maskValue);
          result[i + 2] = Math.max(0, result[i + 2] - maskValue);
          break;
        case "intersect":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "lighten":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "darken":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "difference":
          result[i] = Math.abs(result[i] - maskValue);
          result[i + 1] = Math.abs(result[i + 1] - maskValue);
          result[i + 2] = Math.abs(result[i + 2] - maskValue);
          break;
      }
    }
  }
  resultCtx.putImageData(resultData, 0, 0);
  return resultCanvas;
}
function applyTrackMatte(layerCanvas, matteCanvas, matteType) {
  if (matteType === "none") return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const matteScaled = document.createElement("canvas");
  matteScaled.width = width;
  matteScaled.height = height;
  const matteScaledCtx = matteScaled.getContext("2d");
  matteScaledCtx.drawImage(matteCanvas, 0, 0, width, height);
  const matteData = matteScaledCtx.getImageData(0, 0, width, height);
  const matte = matteData.data;
  for (let i = 0; i < layer.length; i += 4) {
    let matteValue;
    switch (matteType) {
      case "alpha":
        matteValue = matte[i + 3] / 255;
        break;
      case "alpha_inverted":
        matteValue = 1 - matte[i + 3] / 255;
        break;
      case "luma":
        matteValue = (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      case "luma_inverted":
        matteValue = 1 - (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      default:
        matteValue = 1;
    }
    layer[i + 3] = Math.round(layer[i + 3] * matteValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}
function applyMasksToLayer(layerCanvas, masks, frame) {
  if (!masks || masks.length === 0) return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const combinedMask = combineMasks(masks, width, height, frame);
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const maskCtx = combinedMask.getContext("2d");
  const maskData = maskCtx.getImageData(0, 0, width, height);
  const mask = maskData.data;
  for (let i = 0; i < layer.length; i += 4) {
    const maskValue = mask[i] / 255;
    layer[i + 3] = Math.round(layer[i + 3] * maskValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}

class BaseLayer {
  /** Unique layer identifier */
  id;
  /** Layer type */
  type;
  /** The Three.js group containing this layer's content */
  group;
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /** Keyframe evaluator for animated properties */
  evaluator;
  /** Layer visibility */
  visible;
  /** Layer locked state */
  locked;
  /** In point (start frame) */
  inPoint;
  /** Out point (end frame) */
  outPoint;
  /** Layer opacity (0-100) */
  opacity;
  /** Layer transform */
  transform;
  /** 3D layer flag */
  threeD;
  /** Blend mode */
  blendMode;
  /** Parent layer ID (for parenting hierarchy) */
  parentId;
  /** Reference to parent layer (set by LayerManager) */
  parentLayer = null;
  /** Driven values override (from property drivers/expressions) */
  drivenValues = /* @__PURE__ */ new Map();
  /** Audio reactive values (from audio analysis mapping) */
  audioReactiveValues = /* @__PURE__ */ new Map();
  /** Effects stack for this layer */
  effects = [];
  /** Source canvas for effect processing (lazy initialized) */
  effectSourceCanvas = null;
  /** Flag to track if effects need processing */
  effectsDirty = false;
  // ============================================================================
  // MASK & MATTE SYSTEM
  // ============================================================================
  /** Masks applied to this layer (vector cutouts) */
  masks = [];
  /** Track matte type (uses another layer as alpha/luma source) */
  trackMatteType = "none";
  /** ID of the layer used as track matte source */
  trackMatteLayerId = null;
  /** ID of composition containing matte layer (for cross-comp mattes) */
  trackMatteCompositionId = null;
  /** Canvas of track matte layer (set externally by LayerManager) */
  trackMatteCanvas = null;
  /** Preserve transparency - only paint on existing pixels */
  preserveTransparency = false;
  constructor(layerData) {
    this.id = layerData.id;
    this.type = layerData.type;
    this.group = new Group();
    this.group.name = `layer_${this.id}`;
    this.group.userData.layerId = this.id;
    this.group.userData.layerType = this.type;
    this.evaluator = new KeyframeEvaluator();
    this.visible = layerData.visible;
    this.locked = layerData.locked;
    this.inPoint = layerData.inPoint;
    this.outPoint = layerData.outPoint;
    this.opacity = layerData.opacity;
    this.transform = layerData.transform;
    this.threeD = layerData.threeD ?? false;
    this.blendMode = layerData.blendMode ?? "normal";
    this.parentId = layerData.parentId ?? null;
    this.effects = layerData.effects ?? [];
    this.masks = layerData.masks ?? [];
    this.trackMatteType = layerData.trackMatteType ?? "none";
    this.trackMatteLayerId = layerData.trackMatteLayerId ?? null;
    this.trackMatteCompositionId = layerData.trackMatteCompositionId ?? null;
    this.preserveTransparency = layerData.preserveTransparency ?? false;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    if (this.blendMode !== "normal") {
      this.applyBlendMode(this.blendMode);
    }
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(frame) {
    const inRange = frame >= this.inPoint && frame <= this.outPoint;
    this.group.visible = this.visible && inRange;
    if (!this.group.visible) {
      return;
    }
    let baseOpacity = this.evaluator.evaluate(this.opacity, frame);
    baseOpacity = this.getDrivenOrBase("opacity", baseOpacity);
    const opacityValue = this.applyAudioModulation(baseOpacity, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(opacityValue);
    this.evaluateTransform(frame);
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(frame) {
    const basePosition = this.evaluator.evaluate(this.transform.position, frame);
    let posX = this.getDrivenOrBase("transform.position.x", basePosition.x);
    let posY = this.getDrivenOrBase("transform.position.y", basePosition.y);
    const posZ = this.getDrivenOrBase("transform.position.z", basePosition.z ?? 0);
    posX = this.applyAudioModulation(posX, "layer.x", "add");
    posY = this.applyAudioModulation(posY, "layer.y", "add");
    const position = { x: posX, y: posY, z: posZ };
    const baseScale = this.evaluator.evaluate(this.transform.scale, frame);
    let scaleX = this.getDrivenOrBase("transform.scale.x", baseScale.x ?? 100);
    let scaleY = this.getDrivenOrBase("transform.scale.y", baseScale.y ?? 100);
    const scaleZ = this.getDrivenOrBase("transform.scale.z", baseScale.z ?? 100);
    const audioScaleMod = this.getAudioReactiveValue("layer.scale");
    if (audioScaleMod !== 0) {
      const scaleFactor = 0.5 + audioScaleMod;
      scaleX *= scaleFactor;
      scaleY *= scaleFactor;
    }
    const scale = { x: scaleX, y: scaleY, z: scaleZ };
    const baseAnchor = this.evaluator.evaluate(this.transform.anchorPoint, frame);
    const anchorPoint = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", baseAnchor.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", baseAnchor.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", baseAnchor.z ?? 0)
    };
    let rotation = 0;
    let rotationX = 0;
    let rotationY = 0;
    if (this.threeD) {
      const baseRotX = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, frame) : 0;
      rotationX = this.getDrivenOrBase("transform.rotationX", baseRotX);
      const baseRotY = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, frame) : 0;
      rotationY = this.getDrivenOrBase("transform.rotationY", baseRotY);
      const baseRotZ = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, frame) : 0;
      rotation = this.getDrivenOrBase("transform.rotationZ", baseRotZ);
    } else {
      const baseRotation = this.evaluator.evaluate(this.transform.rotation, frame);
      rotation = this.getDrivenOrBase("transform.rotation", baseRotation);
    }
    const audioRotMod = this.getAudioReactiveValue("layer.rotation");
    if (audioRotMod !== 0) {
      rotation += audioRotMod * 360;
    }
    this.applyTransform({
      position: {
        x: position.x,
        y: position.y,
        z: position.z
      },
      rotation: {
        x: rotationX,
        y: rotationY,
        z: rotation
      },
      scale: {
        x: scale.x / 100,
        y: scale.y / 100,
        z: scale.z / 100
      },
      anchorPoint: {
        x: anchorPoint.x,
        y: anchorPoint.y,
        z: anchorPoint.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(transform) {
    const { position, rotation, scale, anchorPoint } = transform;
    this.group.position.set(
      position.x - anchorPoint.x,
      -(position.y - anchorPoint.y),
      // Negate for screen coords
      position.z - anchorPoint.z
    );
    this.group.rotation.set(
      MathUtils.degToRad(rotation.x),
      MathUtils.degToRad(rotation.y),
      MathUtils.degToRad(-rotation.z)
    );
    this.group.scale.set(scale.x, scale.y, scale.z);
    this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        if ("opacity" in material) {
          material.opacity = normalizedOpacity;
          material.transparent = normalizedOpacity < 1;
          material.needsUpdate = true;
        }
      }
    });
  }
  // ============================================================================
  // EVALUATED STATE APPLICATION (NEW - SINGLE SOURCE OF TRUTH)
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer visual state.
   * All values are already computed - layers only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * @param state - Pre-evaluated layer state from MotionEngine
   */
  applyEvaluatedState(state) {
    this.group.visible = state.visible;
    if (!state.visible) {
      return;
    }
    const opacity = this.getDrivenOrBase("opacity", state.opacity);
    this.applyOpacity(opacity);
    const transform = state.transform;
    this.applyTransform({
      position: {
        x: this.getDrivenOrBase("transform.position.x", transform.position.x),
        y: this.getDrivenOrBase("transform.position.y", transform.position.y),
        z: this.getDrivenOrBase("transform.position.z", transform.position.z ?? 0)
      },
      rotation: {
        x: this.getDrivenOrBase("transform.rotationX", transform.rotationX ?? 0),
        y: this.getDrivenOrBase("transform.rotationY", transform.rotationY ?? 0),
        z: this.getDrivenOrBase("transform.rotation", transform.rotation)
      },
      scale: {
        x: this.getDrivenOrBase("transform.scale.x", transform.scale.x ?? 100) / 100,
        y: this.getDrivenOrBase("transform.scale.y", transform.scale.y ?? 100) / 100,
        z: this.getDrivenOrBase("transform.scale.z", transform.scale.z ?? 100) / 100
      },
      anchorPoint: {
        x: this.getDrivenOrBase("transform.anchorPoint.x", transform.anchorPoint.x),
        y: this.getDrivenOrBase("transform.anchorPoint.y", transform.anchorPoint.y),
        z: this.getDrivenOrBase("transform.anchorPoint.z", transform.anchorPoint.z ?? 0)
      }
    });
    this.onApplyEvaluatedState(state);
  }
  /**
   * Override in subclasses for type-specific state application
   * Default implementation calls legacy onEvaluateFrame for compatibility
   */
  onApplyEvaluatedState(state) {
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(properties) {
    if (properties.visible !== void 0) {
      this.visible = properties.visible;
      this.group.visible = this.visible;
    }
    if (properties.locked !== void 0) {
      this.locked = properties.locked;
    }
    if (properties.inPoint !== void 0) {
      this.inPoint = properties.inPoint;
    }
    if (properties.outPoint !== void 0) {
      this.outPoint = properties.outPoint;
    }
    if (properties.opacity !== void 0) {
      this.opacity = properties.opacity;
    }
    if (properties.transform !== void 0) {
      this.transform = properties.transform;
    }
    if (properties.threeD !== void 0) {
      this.threeD = properties.threeD;
    }
    if (properties.blendMode !== void 0) {
      this.blendMode = properties.blendMode;
      this.applyBlendMode(this.blendMode);
    }
    if (properties.effects !== void 0) {
      this.setEffects(properties.effects);
    }
    if (properties.masks !== void 0) {
      this.masks = properties.masks;
    }
    if (properties.trackMatteType !== void 0) {
      this.trackMatteType = properties.trackMatteType;
    }
    if (properties.trackMatteLayerId !== void 0) {
      this.trackMatteLayerId = properties.trackMatteLayerId;
      this.trackMatteCanvas = null;
    }
    if (properties.trackMatteCompositionId !== void 0) {
      this.trackMatteCompositionId = properties.trackMatteCompositionId;
      this.trackMatteCanvas = null;
    }
    if (properties.preserveTransparency !== void 0) {
      this.preserveTransparency = properties.preserveTransparency;
    }
    this.onUpdate(properties);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(visible) {
    this.visible = visible;
    this.group.visible = visible;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(values) {
    this.drivenValues = values;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(propertyPath, baseValue) {
    return this.drivenValues.get(propertyPath) ?? baseValue;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(values) {
    this.audioReactiveValues = values;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(target) {
    return this.audioReactiveValues.get(target) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(baseValue, target, mode = "add", range = {}) {
    const audioValue = this.getAudioReactiveValue(target);
    if (audioValue === 0) return baseValue;
    let result;
    switch (mode) {
      case "multiply":
        result = baseValue * (0.5 + audioValue);
        break;
      case "replace":
        result = audioValue;
        break;
      case "add":
      default:
        result = baseValue + audioValue * 100;
        break;
    }
    if (range.min !== void 0) result = Math.max(range.min, result);
    if (range.max !== void 0) result = Math.min(range.max, result);
    return result;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(effects) {
    this.effects = effects;
    this.effectsDirty = true;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return hasEnabledEffects(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(frame) {
    if (!this.hasEnabledEffects()) {
      return null;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    try {
      const result = processEffectStack(this.effects, sourceCanvas, frame);
      return result.canvas;
    } catch (error) {
      layerLogger.error(`Error processing effects for layer ${this.id}:`, error);
      return null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(_processedCanvas) {
  }
  // ============================================================================
  // MASK PROCESSING
  // ============================================================================
  /**
   * Check if this layer has any enabled masks
   */
  hasMasks() {
    return this.masks.length > 0 && this.masks.some((m) => m.enabled);
  }
  /**
   * Check if this layer has a track matte assigned
   */
  hasTrackMatte() {
    return this.trackMatteType !== "none" && this.trackMatteCanvas !== null;
  }
  /**
   * Set the track matte canvas (called by LayerManager when compositing)
   * @param canvas - The rendered canvas of the matte layer
   */
  setTrackMatteCanvas(canvas) {
    this.trackMatteCanvas = canvas;
  }
  /**
   * Get the track matte layer ID
   */
  getTrackMatteLayerId() {
    return this.trackMatteLayerId;
  }
  /**
   * Get the track matte composition ID (for cross-comp mattes)
   * Returns null if matte is in the same composition
   */
  getTrackMatteCompositionId() {
    return this.trackMatteCompositionId;
  }
  /**
   * Check if this layer uses a cross-composition track matte
   */
  hasCrossCompMatte() {
    return this.trackMatteCompositionId !== null && this.trackMatteLayerId !== null;
  }
  /**
   * Get the track matte type
   */
  getTrackMatteType() {
    return this.trackMatteType;
  }
  /**
   * Update masks
   */
  setMasks(masks) {
    this.masks = masks;
  }
  /**
   * Process masks and track matte on a canvas
   * @param canvas - Source canvas to apply masks to
   * @param frame - Current frame for animated masks
   * @returns Processed canvas with masks applied
   */
  processMasksAndMattes(canvas, frame) {
    let result = canvas;
    if (this.hasMasks()) {
      result = applyMasksToLayer(result, this.masks, frame);
    }
    if (this.hasTrackMatte() && this.trackMatteCanvas) {
      result = applyTrackMatte(result, this.trackMatteCanvas, this.trackMatteType);
    }
    return result;
  }
  /**
   * Called after frame evaluation to apply effects AND masks
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(frame) {
    const hasEffects = this.hasEnabledEffects();
    const hasMasks = this.hasMasks();
    const hasTrackMatte = this.hasTrackMatte();
    if (!hasEffects && !hasMasks && !hasTrackMatte) {
      return;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return;
    }
    let processedCanvas = sourceCanvas;
    if (hasEffects) {
      const effectResult = this.processEffects(frame);
      if (effectResult) {
        processedCanvas = effectResult;
      }
    }
    if (hasMasks || hasTrackMatte) {
      processedCanvas = this.processMasksAndMattes(processedCanvas, frame);
    }
    if (processedCanvas !== sourceCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Apply pre-evaluated effects from MotionEngine
   * Uses the evaluated effect parameters rather than re-evaluating
   */
  applyEvaluatedEffects(evaluatedEffects) {
    if (evaluatedEffects.length === 0 || !this.hasEnabledEffects()) {
      return;
    }
    const processedCanvas = this.processEffectsWithEvaluated(evaluatedEffects);
    if (processedCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Process effects using pre-evaluated parameters
   */
  processEffectsWithEvaluated(evaluatedEffects) {
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    let currentCanvas = sourceCanvas;
    for (const evalEffect of evaluatedEffects) {
      if (!evalEffect.enabled) continue;
      const effect = this.effects.find((e) => e.id === evalEffect.id);
      if (!effect) continue;
      const result = this.processEffectWithParams(effect, currentCanvas, evalEffect.parameters);
      if (result) {
        currentCanvas = result;
      }
    }
    return currentCanvas !== sourceCanvas ? currentCanvas : null;
  }
  /**
   * Process a single effect with pre-evaluated parameters
   */
  processEffectWithParams(effect, sourceCanvas, params) {
    return null;
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(parent) {
    if (this.parentLayer) {
      this.parentLayer.getObject().remove(this.group);
    }
    this.parentLayer = parent;
    if (parent) {
      parent.getObject().add(this.group);
    }
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(mode) {
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        this.setMaterialBlendMode(material, mode);
        material.needsUpdate = true;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(material, mode) {
    material.blending = NormalBlending;
    material.blendEquation = AddEquation;
    material.blendSrc = SrcAlphaFactor;
    material.blendDst = OneMinusSrcAlphaFactor;
    material.blendEquationAlpha = AddEquation;
    material.blendSrcAlpha = OneFactor;
    material.blendDstAlpha = OneMinusSrcAlphaFactor;
    switch (mode) {
      case "normal":
        material.blending = NormalBlending;
        break;
      case "add":
        material.blending = AdditiveBlending;
        break;
      case "multiply":
        material.blending = MultiplyBlending;
        break;
      case "screen":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "overlay":
        material.blending = MultiplyBlending;
        break;
      case "soft-light":
        material.blending = NormalBlending;
        break;
      case "hard-light":
        material.blending = MultiplyBlending;
        break;
      case "color-dodge":
        material.blending = AdditiveBlending;
        break;
      case "color-burn":
        material.blending = SubtractiveBlending;
        break;
      case "difference":
        material.blending = CustomBlending;
        material.blendEquation = SubtractEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "exclusion":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneMinusDstColorFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "darken":
        material.blending = CustomBlending;
        material.blendEquation = MinEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "lighten":
        material.blending = CustomBlending;
        material.blendEquation = MaxEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      default:
        material.blending = NormalBlending;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const box = new Box3();
    box.setFromObject(this.group);
    return box;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const box = this.getBoundingBox();
    const center = new Vector3();
    box.getCenter(center);
    return center;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry?.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else if (child.material) {
          child.material.dispose();
        }
      }
    });
    this.group.clear();
    this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}

class VideoLayer extends BaseLayer {
  resources;
  // Video elements
  videoElement = null;
  videoTexture = null;
  mesh = null;
  material = null;
  // Video data
  videoData;
  assetRef = null;
  // Metadata (populated after video loads)
  metadata = null;
  // Animation evaluator
  videoEvaluator;
  // Playback state
  lastEvaluatedFrame = -1;
  isPlaying = false;
  // Callbacks for composition auto-resize
  onMetadataLoaded;
  // Composition FPS for time calculation
  compositionFPS = 30;
  // Canvas for effect processing
  effectCanvas = null;
  effectCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.videoEvaluator = new KeyframeEvaluator();
    this.videoData = this.extractVideoData(layerData);
    this.createPlaceholderMesh();
    if (this.videoData.assetId) {
      this.loadVideo(this.videoData.assetId);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      loop: data?.loop ?? false,
      pingPong: data?.pingPong ?? false,
      startTime: data?.startTime ?? 0,
      endTime: data?.endTime,
      speed: data?.speed ?? 1,
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      frameBlending: data?.frameBlending ?? "none",
      audioEnabled: data?.audioEnabled ?? true,
      audioLevel: data?.audioLevel ?? 100,
      posterFrame: data?.posterFrame ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 3355443,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `video_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(assetId) {
    const asset = this.resources.getAsset(assetId);
    if (!asset || asset.type !== "video") {
      layerLogger.warn(`VideoLayer: Asset ${assetId} not found or not a video`);
      return;
    }
    this.assetRef = asset;
    this.videoData.assetId = assetId;
    this.videoElement = document.createElement("video");
    this.videoElement.crossOrigin = "anonymous";
    this.videoElement.playsInline = true;
    this.videoElement.muted = !this.videoData.audioEnabled;
    this.videoElement.loop = false;
    this.videoElement.preload = "auto";
    if (asset.data) {
      this.videoElement.src = asset.data;
    }
    await this.waitForMetadata();
    this.createVideoTexture();
    this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((resolve, reject) => {
      if (!this.videoElement) {
        reject(new Error("No video element"));
        return;
      }
      const onLoadedMetadata = () => {
        this.extractMetadata();
        cleanup();
        resolve();
      };
      const onError = (e) => {
        cleanup();
        reject(new Error(`Video load error: ${e}`));
      };
      const cleanup = () => {
        this.videoElement?.removeEventListener("loadedmetadata", onLoadedMetadata);
        this.videoElement?.removeEventListener("error", onError);
      };
      this.videoElement.addEventListener("loadedmetadata", onLoadedMetadata);
      this.videoElement.addEventListener("error", onError);
      this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    if (!this.videoElement) return;
    const duration = this.videoElement.duration;
    const width = this.videoElement.videoWidth;
    const height = this.videoElement.videoHeight;
    const fps = this.assetRef?.fps ?? 30;
    const frameCount = Math.ceil(duration * fps);
    this.metadata = {
      duration,
      frameCount,
      fps,
      width,
      height,
      hasAudio: this.hasAudioTrack()
    };
    if (this.assetRef) {
      this.assetRef.duration = duration;
      this.assetRef.frameCount = frameCount;
      this.assetRef.fps = fps;
      this.assetRef.hasAudio = this.metadata.hasAudio;
    }
    this.onMetadataLoaded?.(this.metadata);
    layerLogger.debug(`VideoLayer: Loaded: ${width}x${height}, ${frameCount} frames @ ${fps}fps, ${duration.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return false;
    const audioTracks = this.videoElement.audioTracks;
    if (audioTracks) {
      return audioTracks.length > 0;
    }
    return true;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    if (!this.videoElement || !this.metadata) return;
    this.videoTexture = new VideoTexture(this.videoElement);
    this.videoTexture.minFilter = LinearFilter;
    this.videoTexture.magFilter = LinearFilter;
    this.videoTexture.format = RGBAFormat;
    this.videoTexture.colorSpace = SRGBColorSpace;
    if (this.material) {
      this.material.map = this.videoTexture;
      this.material.color.setHex(16777215);
      this.material.needsUpdate = true;
    }
    this.resizeMesh(this.metadata.width, this.metadata.height);
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(compositionFrame) {
    if (!this.videoElement || !this.metadata) return;
    const videoTime = this.calculateVideoTime(compositionFrame);
    const clampedTime = Math.max(0, Math.min(videoTime, this.videoElement.duration));
    this.videoElement.currentTime = clampedTime;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(compositionFrame) {
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && this.videoData.timeRemap?.animated) {
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, compositionFrame);
    }
    const compFps = this.compositionFPS;
    const compTime = compositionFrame / compFps;
    let videoTime = compTime * this.videoData.speed;
    videoTime += this.videoData.startTime;
    const effectiveDuration = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && effectiveDuration > 0) {
      if (this.videoData.pingPong) {
        const cycles = Math.floor(videoTime / effectiveDuration);
        const phase = videoTime % effectiveDuration;
        videoTime = cycles % 2 === 0 ? phase : effectiveDuration - phase;
      } else {
        videoTime = videoTime % effectiveDuration;
      }
      videoTime += this.videoData.startTime;
    }
    return videoTime;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(level) {
    this.videoData.audioLevel = level;
    if (this.videoElement) {
      this.videoElement.volume = Math.max(0, Math.min(1, level / 100));
    }
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(enabled) {
    this.videoData.audioEnabled = enabled;
    if (this.videoElement) {
      this.videoElement.muted = !enabled;
    }
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.compositionFPS = fps;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(callback) {
    this.onMetadataLoaded = callback;
    if (this.metadata) {
      callback(this.metadata);
    }
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(loop) {
    this.videoData.loop = loop;
  }
  setPingPong(pingPong) {
    this.videoData.pingPong = pingPong;
  }
  setSpeed(speed) {
    this.videoData.speed = speed;
    if (this.videoElement) {
      this.videoElement.playbackRate = speed;
    }
  }
  setStartTime(time) {
    this.videoData.startTime = time;
  }
  setEndTime(time) {
    this.videoData.endTime = time;
  }
  setFrameBlending(mode) {
    this.videoData.frameBlending = mode;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata) {
      return null;
    }
    const width = this.metadata.width;
    const height = this.metadata.height;
    if (!this.effectCanvas || this.effectCanvas.width !== width || this.effectCanvas.height !== height) {
      this.effectCanvas = document.createElement("canvas");
      this.effectCanvas.width = width;
      this.effectCanvas.height = height;
      this.effectCanvasCtx = this.effectCanvas.getContext("2d");
    }
    if (!this.effectCanvasCtx) {
      return null;
    }
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    return this.effectCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    if (!this.material || !this.metadata) return;
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (frame === this.lastEvaluatedFrame) return;
    this.lastEvaluatedFrame = frame;
    this.seekToFrame(frame);
    if (this.videoTexture) {
      this.videoTexture.needsUpdate = true;
    }
    if (this.hasEnabledEffects()) {
      this.evaluateEffects(frame);
    } else if (this.material && this.videoTexture) {
      this.material.map = this.videoTexture;
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.videoElement) {
      const targetTime = props["timeRemap"];
      const clampedTime = Math.max(0, Math.min(targetTime, this.videoElement.duration || targetTime));
      this.videoElement.currentTime = clampedTime;
    }
    if (props["speed"] !== void 0) {
      this.videoData.speed = props["speed"];
    }
    if (props["audioLevel"] !== void 0) {
      this.setAudioLevel(props["audioLevel"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.videoData.assetId) {
        if (data.assetId) {
          this.loadVideo(data.assetId);
        } else {
          this.clearVideo();
        }
      }
      if (data.loop !== void 0) this.setLoop(data.loop);
      if (data.pingPong !== void 0) this.setPingPong(data.pingPong);
      if (data.speed !== void 0) this.setSpeed(data.speed);
      if (data.startTime !== void 0) this.setStartTime(data.startTime);
      if (data.endTime !== void 0) this.setEndTime(data.endTime);
      if (data.frameBlending !== void 0) this.setFrameBlending(data.frameBlending);
      if (data.audioEnabled !== void 0) this.setAudioEnabled(data.audioEnabled);
      if (data.audioLevel !== void 0) this.setAudioLevel(data.audioLevel);
    }
  }
  /**
   * Clear current video
   */
  clearVideo() {
    if (this.videoElement) {
      this.videoElement.pause();
      this.videoElement.src = "";
      this.videoElement = null;
    }
    if (this.videoTexture) {
      this.videoTexture.dispose();
      this.videoTexture = null;
    }
    if (this.material) {
      this.material.map = null;
      this.material.color.setHex(3355443);
    }
    this.metadata = null;
    this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo();
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
  }
}
async function extractVideoMetadata(source) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.preload = "metadata";
    const cleanup = () => {
      video.removeEventListener("loadedmetadata", onLoad);
      video.removeEventListener("error", onError);
      URL.revokeObjectURL(video.src);
    };
    const onLoad = () => {
      const metadata = {
        duration: video.duration,
        frameCount: Math.ceil(video.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: video.videoWidth,
        height: video.videoHeight,
        hasAudio: true
        // Assume true
      };
      cleanup();
      resolve(metadata);
    };
    const onError = () => {
      cleanup();
      reject(new Error("Failed to load video metadata"));
    };
    video.addEventListener("loadedmetadata", onLoad);
    video.addEventListener("error", onError);
    if (typeof source === "string") {
      video.src = source;
    } else {
      video.src = URL.createObjectURL(source);
    }
  });
}
function calculateCompositionFromVideo(metadata, targetFps = 16) {
  const width = Math.round(metadata.width / 8) * 8;
  const height = Math.round(metadata.height / 8) * 8;
  const frameCount = Math.ceil(metadata.duration * targetFps);
  return { width, height, frameCount };
}

const CAMERA_PRESETS = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function createDefaultCamera(id, compWidth, compHeight) {
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  return {
    id,
    name: "Camera 1",
    type: "two-node",
    position: { x: centerX, y: centerY, z: -1500 },
    pointOfInterest: { x: centerX, y: centerY, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: false,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: false
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function createDefaultViewportState() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function createDefaultViewOptions() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: true,
    showLayerHandles: true,
    showSafeZones: false,
    showGrid: false,
    showRulers: true,
    show3DReferenceAxes: true,
    showCompositionBounds: true,
    showFocalPlane: false
  };
}

function vec3(x, y, z) {
  return { x, y, z };
}
function addVec3(a, b) {
  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
function subVec3(a, b) {
  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
function scaleVec3(v, s) {
  return { x: v.x * s, y: v.y * s, z: v.z * s };
}
function lengthVec3(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
function normalizeVec3(v) {
  const len = lengthVec3(v);
  if (len === 0) return { x: 0, y: 0, z: 0 };
  return { x: v.x / len, y: v.y / len, z: v.z / len };
}
function crossVec3(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
  };
}
function dotVec3(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function perspectiveMat4(fovY, aspect, near, far) {
  const te = new Float32Array(16);
  const f = 1 / Math.tan(fovY / 2);
  const nf = 1 / (near - far);
  te[0] = f / aspect;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = f;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = (far + near) * nf;
  te[11] = -1;
  te[12] = 0;
  te[13] = 0;
  te[14] = 2 * far * near * nf;
  te[15] = 0;
  return { elements: te };
}
function orthographicMat4(left, right, bottom, top, near, far) {
  const te = new Float32Array(16);
  const w = 1 / (right - left);
  const h = 1 / (top - bottom);
  const p = 1 / (far - near);
  te[0] = 2 * w;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = 2 * h;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = -2 * p;
  te[11] = 0;
  te[12] = -(right + left) * w;
  te[13] = -(top + bottom) * h;
  te[14] = -10001 * p;
  te[15] = 1;
  return { elements: te };
}
function lookAtMat4(eye, target, up) {
  const te = new Float32Array(16);
  let zx = eye.x - target.x;
  let zy = eye.y - target.y;
  let zz = eye.z - target.z;
  let len = Math.sqrt(zx * zx + zy * zy + zz * zz);
  if (len === 0) {
    zz = 1;
  } else {
    len = 1 / len;
    zx *= len;
    zy *= len;
    zz *= len;
  }
  let xx = up.y * zz - up.z * zy;
  let xy = up.z * zx - up.x * zz;
  let xz = up.x * zy - up.y * zx;
  len = Math.sqrt(xx * xx + xy * xy + xz * xz);
  if (len === 0) {
    xx = 0;
    xy = 0;
    xz = 0;
  } else {
    len = 1 / len;
    xx *= len;
    xy *= len;
    xz *= len;
  }
  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;
  len = Math.sqrt(yx * yx + yy * yy + yz * yz);
  if (len === 0) {
    yx = 0;
    yy = 0;
    yz = 0;
  } else {
    len = 1 / len;
    yx *= len;
    yy *= len;
    yz *= len;
  }
  te[0] = xx;
  te[4] = xy;
  te[8] = xz;
  te[12] = -dotVec3({ x: xx, y: xy, z: xz }, eye);
  te[1] = yx;
  te[5] = yy;
  te[9] = yz;
  te[13] = -dotVec3({ x: yx, y: yy, z: yz }, eye);
  te[2] = zx;
  te[6] = zy;
  te[10] = zz;
  te[14] = -dotVec3({ x: zx, y: zy, z: zz }, eye);
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[15] = 1;
  return { elements: te };
}
function transformPoint(m, p) {
  const e = m.elements;
  const w = e[3] * p.x + e[7] * p.y + e[11] * p.z + e[15];
  return {
    x: (e[0] * p.x + e[4] * p.y + e[8] * p.z + e[12]) / w,
    y: (e[1] * p.x + e[5] * p.y + e[9] * p.z + e[13]) / w,
    z: (e[2] * p.x + e[6] * p.y + e[10] * p.z + e[14]) / w
  };
}
function focalLengthToFOV(focalLength, sensorSize) {
  return 2 * Math.atan(sensorSize / (2 * focalLength));
}
function fovToFocalLength(fov, sensorSize) {
  return sensorSize / (2 * Math.tan(fov / 2));
}

function interpolateCameraAtFrame(camera, keyframes, frame) {
  if (!keyframes || keyframes.length === 0) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  let prev = null;
  let next = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      prev = kf;
    }
    if (kf.frame >= frame && !next) {
      next = kf;
    }
  }
  if (!prev && !next) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  if (!prev) prev = next;
  if (!next) next = prev;
  const getPos = (kf) => kf?.position ?? camera.position;
  const getOri = (kf) => kf?.orientation ?? camera.orientation;
  const getFocal = (kf) => kf?.focalLength ?? camera.focalLength;
  const getZoom = (kf) => kf?.zoom ?? camera.zoom;
  const getFocusDist = (kf) => kf?.focusDistance ?? camera.depthOfField.focusDistance;
  if (prev.frame === next.frame) {
    return {
      position: getPos(prev),
      rotation: getOri(prev),
      focalLength: getFocal(prev),
      zoom: getZoom(prev),
      focusDistance: getFocusDist(prev)
    };
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevPos = getPos(prev);
  const nextPos = getPos(next);
  const prevOri = getOri(prev);
  const nextOri = getOri(next);
  return {
    position: {
      x: lerp(prevPos.x, nextPos.x, t),
      y: lerp(prevPos.y, nextPos.y, t),
      z: lerp(prevPos.z, nextPos.z, t)
    },
    rotation: {
      x: lerpAngle(prevOri.x, nextOri.x, t),
      y: lerpAngle(prevOri.y, nextOri.y, t),
      z: lerpAngle(prevOri.z, nextOri.z, t)
    },
    focalLength: lerp(getFocal(prev), getFocal(next), t),
    zoom: lerp(getZoom(prev), getZoom(next), t),
    focusDistance: lerp(getFocusDist(prev), getFocusDist(next), t)
  };
}
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return a + diff * t;
}
function computeViewMatrix(cam) {
  const { position, rotation } = cam;
  const rx = rotation.x * Math.PI / 180;
  const ry = rotation.y * Math.PI / 180;
  const rz = rotation.z * Math.PI / 180;
  const cosX = Math.cos(rx), sinX = Math.sin(rx);
  const cosY = Math.cos(ry), sinY = Math.sin(ry);
  const cosZ = Math.cos(rz), sinZ = Math.sin(rz);
  const r00 = cosY * cosZ + sinY * sinX * sinZ;
  const r01 = -cosY * sinZ + sinY * sinX * cosZ;
  const r02 = sinY * cosX;
  const r10 = cosX * sinZ;
  const r11 = cosX * cosZ;
  const r12 = -sinX;
  const r20 = -sinY * cosZ + cosY * sinX * sinZ;
  const r21 = sinY * sinZ + cosY * sinX * cosZ;
  const r22 = cosY * cosX;
  const tx = -(r00 * position.x + r10 * position.y + r20 * position.z);
  const ty = -(r01 * position.x + r11 * position.y + r21 * position.z);
  const tz = -(r02 * position.x + r12 * position.y + r22 * position.z);
  return [
    [r00, r01, r02, tx],
    [r10, r11, r12, ty],
    [r20, r21, r22, tz],
    [0, 0, 0, 1]
  ];
}
function computeProjectionMatrix(cam, aspectRatio, nearClip = 0.1, farClip = 1e3) {
  const fov = focalLengthToFOV(cam.focalLength, 36);
  const fovRad = fov * Math.PI / 180;
  const tanHalfFov = Math.tan(fovRad / 2);
  const f = 1 / tanHalfFov;
  const nf = 1 / (nearClip - farClip);
  return [
    [f / aspectRatio, 0, 0, 0],
    [0, f, 0, 0],
    [0, 0, (farClip + nearClip) * nf, 2 * farClip * nearClip * nf],
    [0, 0, -1, 0]
  ];
}
function exportToMotionCtrl(camera, keyframes, frameCount) {
  const poses = [];
  for (let frame = 0; frame < frameCount; frame++) {
    const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(interpolated);
    poses.push({
      RT: viewMatrix
    });
  }
  return { camera_poses: poses };
}
function detectMotionCtrlSVDPreset(keyframes) {
  if (!keyframes || keyframes.length < 2) return "static";
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const threshold = 50;
  if (Math.abs(deltaZ) > threshold) {
    return deltaZ < 0 ? "zoom_in" : "zoom_out";
  }
  if (Math.abs(deltaRy) > 15) {
    return deltaRy > 0 ? "rotate_cw" : "rotate_ccw";
  }
  if (Math.abs(deltaX) > threshold) {
    return deltaX > 0 ? "pan_right" : "pan_left";
  }
  if (Math.abs(deltaY) > threshold) {
    return deltaY > 0 ? "pan_down" : "pan_up";
  }
  return "static";
}
function exportToMotionCtrlSVD(camera, keyframes, frameCount) {
  const preset = detectMotionCtrlSVDPreset(keyframes);
  if (preset !== "static" && keyframes.length <= 2) {
    return { motion_camera: preset };
  }
  const motionctrlData = exportToMotionCtrl(camera, keyframes, frameCount);
  return {
    motion_camera: preset,
    camera_poses: JSON.stringify(motionctrlData.camera_poses)
  };
}
function analyzeCameraMotion(keyframes) {
  if (!keyframes || keyframes.length < 2) {
    return {
      hasPan: false,
      panMagnitude: 0,
      hasZoom: false,
      zoomMagnitude: 0,
      hasOrbit: false,
      orbitMagnitude: 0,
      hasRotation: false,
      rotationMagnitude: 0
    };
  }
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const panThreshold = 30;
  const zoomThreshold = 50;
  const orbitThreshold = 20;
  let panDirection;
  const panX = Math.abs(deltaX);
  const panY = Math.abs(deltaY);
  if (panX > panThreshold || panY > panThreshold) {
    if (panX > panY) {
      panDirection = deltaX > 0 ? "right" : "left";
    } else {
      panDirection = deltaY > 0 ? "down" : "up";
    }
  }
  let zoomDirection;
  if (Math.abs(deltaZ) > zoomThreshold) {
    zoomDirection = deltaZ < 0 ? "in" : "out";
  }
  let orbitDirection;
  if (Math.abs(deltaRy) > orbitThreshold && Math.abs(deltaX) > panThreshold) {
    orbitDirection = deltaRy > 0 ? "right" : "left";
  }
  return {
    hasPan: !!panDirection,
    panDirection,
    panMagnitude: Math.max(panX, panY),
    hasZoom: !!zoomDirection,
    zoomDirection,
    zoomMagnitude: Math.abs(deltaZ),
    hasOrbit: !!orbitDirection,
    orbitDirection,
    orbitMagnitude: Math.abs(deltaRy),
    hasRotation: Math.abs(deltaRy) > 5,
    rotationMagnitude: Math.abs(deltaRy)
  };
}
function mapToWan22FunCamera(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  let preset = "Static";
  if (motion.hasOrbit) {
    preset = motion.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  } else if (motion.hasZoom && motion.hasPan) {
    const panDir = capitalize(motion.panDirection || "up");
    const zoomDir = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    preset = `Pan ${panDir} + ${zoomDir}`;
  } else if (motion.hasZoom) {
    preset = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
  } else if (motion.hasPan) {
    preset = `Pan ${capitalize(motion.panDirection || "up")}`;
  }
  return { camera_motion: preset };
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function detectUni3CTrajectoryType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (motion.hasOrbit && motion.orbitMagnitude > 45) {
    return "orbit";
  }
  if (motion.hasPan && motion.hasZoom) {
    return "custom";
  }
  if (!motion.hasPan && !motion.hasZoom && !motion.hasOrbit) {
    return "free1";
  }
  return "custom";
}
function exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight) {
  const detectedType = detectUni3CTrajectoryType(keyframes);
  if (detectedType !== "custom") {
    return { traj_type: detectedType };
  }
  const trajectory = [];
  const baseCamera = interpolateCameraAtFrame(camera, keyframes, 0);
  for (let frame = 0; frame < frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    trajectory.push({
      zoom: cam.zoom / baseCamera.zoom,
      x_offset: (cam.position.x - baseCamera.position.x) / compWidth,
      y_offset: (cam.position.y - baseCamera.position.y) / compHeight,
      z_offset: (cam.position.z - baseCamera.position.z) / 1e3,
      pitch: cam.rotation.x,
      yaw: cam.rotation.y,
      roll: cam.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: trajectory
  };
}
function detectCameraCtrlMotionType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (!motion.hasPan && !motion.hasZoom && !motion.hasRotation) {
    return "Static";
  }
  if (motion.hasZoom) {
    return motion.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  }
  if (motion.hasPan) {
    switch (motion.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  }
  if (motion.hasRotation) {
    const first = keyframes[0];
    const last = keyframes[keyframes.length - 1];
    const firstOri = first.orientation ?? { x: 0, y: 0, z: 0 };
    const lastOri = last.orientation ?? { x: 0, y: 0, z: 0 };
    const deltaRx = lastOri.x - firstOri.x;
    const deltaRy = lastOri.y - firstOri.y;
    const deltaRz = lastOri.z - firstOri.z;
    if (Math.abs(deltaRy) > Math.abs(deltaRx) && Math.abs(deltaRy) > Math.abs(deltaRz)) {
      return deltaRy > 0 ? "Rotate Right" : "Rotate Left";
    }
    if (Math.abs(deltaRx) > Math.abs(deltaRz)) {
      return deltaRx > 0 ? "Rotate Down" : "Rotate Up";
    }
    return deltaRz > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function exportToCameraCtrl(keyframes, frameCount) {
  const motionType = detectCameraCtrlMotionType(keyframes);
  const motion = analyzeCameraMotion(keyframes);
  let speed = 0;
  if (motion.hasZoom) {
    speed = Math.min(100, motion.zoomMagnitude / 5);
  } else if (motion.hasPan) {
    speed = Math.min(100, motion.panMagnitude / 3);
  } else if (motion.hasRotation) {
    speed = Math.min(100, motion.rotationMagnitude * 2);
  }
  return {
    motion_type: motionType,
    speed: Math.round(speed),
    frame_length: frameCount
  };
}
function exportCameraMatrices(camera, keyframes, options) {
  const frames = [];
  const aspectRatio = options.width / options.height;
  for (let frame = 0; frame < options.frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(cam);
    const projMatrix = computeProjectionMatrix(cam, aspectRatio);
    frames.push({
      frame,
      timestamp: frame / options.fps,
      view_matrix: viewMatrix,
      projection_matrix: projMatrix,
      position: [cam.position.x, cam.position.y, cam.position.z],
      rotation: [cam.rotation.x, cam.rotation.y, cam.rotation.z],
      fov: focalLengthToFOV(cam.focalLength, camera.filmSize),
      focal_length: cam.focalLength,
      focus_distance: cam.focusDistance
    });
  }
  return {
    frames,
    metadata: {
      width: options.width,
      height: options.height,
      fps: options.fps,
      total_frames: options.frameCount,
      camera_type: camera.type,
      film_size: camera.filmSize
    }
  };
}
function exportCameraForTarget(target, camera, keyframes, frameCount, compWidth = 1920, compHeight = 1080, fps = 24) {
  switch (target) {
    case "motionctrl":
      return exportToMotionCtrl(camera, keyframes, frameCount);
    case "motionctrl-svd":
      return exportToMotionCtrlSVD(camera, keyframes, frameCount);
    case "wan22-fun-camera":
      return mapToWan22FunCamera(keyframes);
    case "uni3c-camera":
    case "uni3c-motion":
      return exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight);
    case "animatediff-cameractrl":
      return exportToCameraCtrl(keyframes, frameCount);
    default:
      return exportCameraMatrices(camera, keyframes, {
        frameCount,
        width: compWidth,
        height: compHeight,
        fps
      });
  }
}

let worker = null;
let currentResolve = null;
let currentReject = null;
let currentOnProgress = null;
function ensureWorker() {
  if (!worker) {
    worker = new Worker(
      new URL(/* @vite-ignore */ "/worker-audioWorker.js", import.meta.url),
      { type: "module" }
    );
    worker.onmessage = (event) => {
      const message = event.data;
      switch (message.type) {
        case "progress":
          if (currentOnProgress) {
            currentOnProgress({
              phase: message.payload.phase,
              progress: message.payload.progress,
              message: message.payload.message
            });
          }
          break;
        case "complete":
          if (currentResolve) {
            currentResolve(message.payload);
            cleanup();
          }
          break;
        case "error":
          if (currentReject) {
            currentReject(new Error(message.payload.message));
            cleanup();
          }
          break;
      }
    };
    worker.onerror = (error) => {
      console.error("[AudioWorker] Worker error:", error);
      if (currentReject) {
        currentReject(new Error(`Worker error: ${error.message}`));
        cleanup();
      }
    };
  }
  return worker;
}
function cleanup() {
  currentResolve = null;
  currentReject = null;
  currentOnProgress = null;
}
function cancelAnalysis() {
  if (worker) {
    worker.postMessage({ type: "cancel" });
  }
}
async function analyzeAudioInWorker(audioBuffer, fps, options = {}) {
  const w = ensureWorker();
  if (currentResolve) {
    throw new Error("Analysis already in progress. Cancel it first.");
  }
  const channelData = audioBuffer.getChannelData(0);
  const channelDataCopy = new Float32Array(channelData);
  return new Promise((resolve, reject) => {
    currentResolve = resolve;
    currentReject = reject;
    currentOnProgress = options.onProgress || null;
    w.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: channelDataCopy,
          sampleRate: audioBuffer.sampleRate,
          fps
        }
      },
      [channelDataCopy.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function loadAndAnalyzeAudio(file, fps, options = {}) {
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 0,
      message: "Decoding audio file..."
    });
  }
  const arrayBuffer = await file.arrayBuffer();
  const audioContext = new AudioContext();
  let buffer;
  try {
    buffer = await audioContext.decodeAudioData(arrayBuffer);
  } finally {
    await audioContext.close();
  }
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 1,
      message: "Audio decoded successfully"
    });
  }
  const analysis = await analyzeAudioInWorker(buffer, fps, options);
  return { buffer, analysis };
}

function createAnimatableProperty(name, value, type = "number", group) {
  return {
    id: `prop_${name}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name,
    type,
    value,
    animated: false,
    keyframes: [],
    group
  };
}
function createDefaultTransform() {
  return {
    position: createAnimatableProperty("position", { x: 0, y: 0 }, "position"),
    anchorPoint: createAnimatableProperty("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: createAnimatableProperty("scale", { x: 100, y: 100 }, "position"),
    rotation: createAnimatableProperty("rotation", 0, "number")
  };
}
function createEmptyProject(width, height) {
  const mainCompId = "main";
  const compositionSettings = {
    width,
    height,
    frameCount: 81,
    fps: 16,
    duration: 81 / 16,
    backgroundColor: "#000000",
    autoResizeToContent: true
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [mainCompId]: {
        id: mainCompId,
        name: "Main Comp",
        settings: compositionSettings,
        layers: [],
        currentFrame: 0,
        isPrecomp: false
      }
    },
    mainCompositionId: mainCompId,
    // Legacy alias
    composition: compositionSettings,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}

function createDefaultAudioMapping(id, feature = "amplitude", target = "particle.emissionRate") {
  return {
    id: id || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature,
    target,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: false,
    threshold: 0,
    enabled: true,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class AudioReactiveMapper {
  analysis;
  mappings = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  releaseEnvelopes = /* @__PURE__ */ new Map();
  // ATI-style release tracking
  beatToggleStates = /* @__PURE__ */ new Map();
  // For beat toggle/flip
  peakData = null;
  constructor(analysis) {
    this.analysis = analysis;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(peakData) {
    this.peakData = peakData;
  }
  /**
   * Add a new mapping
   */
  addMapping(mapping) {
    this.mappings.set(mapping.id, mapping);
    this.smoothedValues.set(mapping.id, 0);
    this.releaseEnvelopes.set(mapping.id, 0);
    this.beatToggleStates.set(mapping.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(id) {
    this.mappings.delete(id);
    this.smoothedValues.delete(id);
    this.releaseEnvelopes.delete(id);
    this.beatToggleStates.delete(id);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(id, updates) {
    const mapping = this.mappings.get(id);
    if (mapping) {
      Object.assign(mapping, updates);
    }
  }
  /**
   * Get a specific mapping
   */
  getMapping(id) {
    return this.mappings.get(id);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(layerId) {
    return Array.from(this.mappings.values()).filter(
      (m) => m.targetLayerId === layerId || m.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(target) {
    return Array.from(this.mappings.values()).filter((m) => m.target === target);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(feature, frame) {
    if (feature === "peaks") {
      if (this.peakData) {
        return isPeakAtFrame(this.peakData, frame) ? 1 : 0;
      }
      return 0;
    }
    return getFeatureAtFrame(this.analysis, feature, frame);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(mappingId, frame) {
    const mapping = this.mappings.get(mappingId);
    if (!mapping || !mapping.enabled) return 0;
    let value = this.getFeatureAtFrame(mapping.feature, frame);
    if (value < mapping.threshold) {
      value = 0;
    }
    if (mapping.amplitudeCurve !== 1) {
      value = Math.pow(value, mapping.amplitudeCurve);
    }
    const releaseEnvelope = this.releaseEnvelopes.get(mappingId) || 0;
    if (value > releaseEnvelope) {
      this.releaseEnvelopes.set(mappingId, value);
    } else {
      const decayRate = 1 - mapping.release * 0.98;
      const newEnvelope = releaseEnvelope * decayRate;
      this.releaseEnvelopes.set(mappingId, newEnvelope);
      value = Math.max(value, newEnvelope);
    }
    if (mapping.beatResponse !== "none") {
      const isBeat = this.analysis.onsets.includes(frame) && this.getFeatureAtFrame(mapping.feature, frame) > mapping.beatThreshold;
      if (isBeat) {
        const currentToggle = this.beatToggleStates.get(mappingId) || 0;
        switch (mapping.beatResponse) {
          case "flip":
            this.beatToggleStates.set(mappingId, currentToggle === 0 ? 1 : 0);
            break;
          case "pulse":
            value = 1;
            break;
          case "toggle":
            const newToggle = currentToggle === 0 ? 1 : 0;
            this.beatToggleStates.set(mappingId, newToggle);
            value = newToggle;
            break;
        }
      }
      if (mapping.beatResponse === "flip") {
        const toggle = this.beatToggleStates.get(mappingId) || 0;
        if (toggle === 1) {
          value = 1 - value;
        }
      }
    }
    value = this.applyCurve(value, mapping.curve);
    if (mapping.invert) {
      value = 1 - value;
    }
    value *= mapping.sensitivity;
    value += mapping.offset;
    value = Math.max(mapping.min, Math.min(mapping.max, value));
    const prevSmoothed = this.smoothedValues.get(mappingId) || 0;
    const smoothed = prevSmoothed * mapping.smoothing + value * (1 - mapping.smoothing);
    this.smoothedValues.set(mappingId, smoothed);
    return smoothed;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(layerId, frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      if (mapping.targetLayerId && mapping.targetLayerId !== layerId) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(value, curve) {
    const clamped = Math.max(0, Math.min(1, value));
    switch (curve) {
      case "exponential":
        return clamped * clamped;
      case "logarithmic":
        return Math.sqrt(clamped);
      case "smoothstep":
        return clamped * clamped * (3 - 2 * clamped);
      case "bounce":
        if (clamped < 0.5) {
          return 2 * clamped * clamped;
        } else {
          const t = clamped - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * t, 2));
        }
      case "linear":
      default:
        return clamped;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
    for (const mapping of this.mappings.values()) {
      this.smoothedValues.set(mapping.id, 0);
      this.releaseEnvelopes.set(mapping.id, 0);
      this.beatToggleStates.set(mapping.id, 0);
    }
  }
  /**
   * Update analysis data
   */
  setAnalysis(analysis) {
    this.analysis = analysis;
    this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear();
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(mappings) {
    this.clear();
    for (const mapping of mappings) {
      this.addMapping(mapping);
    }
  }
}
function getFeatureDisplayName(feature) {
  const names = {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  };
  return names[feature] || feature;
}
function getTargetDisplayName(target) {
  const splineMatch = target.match(/^spline\.controlPoint\.(\d+)\.(x|y|depth)$/);
  if (splineMatch) {
    const index = splineMatch[1];
    const prop = splineMatch[2] === "x" ? "X" : splineMatch[2] === "y" ? "Y" : "Depth";
    return `Spline: Control Point ${index} ${prop}`;
  }
  const names = {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  };
  return names[target] || target;
}
function getAllFeatures() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function getFeaturesByCategory() {
  return {
    "Energy": ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    "Spectral": ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    "Events": ["onsets", "peaks"],
    "Harmonic": ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function getTargetsByCategory() {
  return {
    "Particle": [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    "Depthflow": [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    "Path": ["path.position"],
    "Layer": [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
    // Note: 'Spline' targets are generated dynamically based on control point count
    // Use createSplineControlPointTargets() to get targets for a specific spline
  };
}

const DEFAULT_CONFIG$1 = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: true,
  beatThreshold: 0.05,
  motionBlur: false,
  motionBlurStrength: 0.5
};
class AudioPathAnimator {
  config;
  state;
  pathSegments = [];
  totalLength = 0;
  releaseState = 0;
  // For amplitude mode release tracking
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$1, ...config };
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(pathData) {
    this.pathSegments = this.parsePath(pathData);
    this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(pathData) {
    const segments = [];
    const commands = pathData.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let currentX = 0;
    let currentY = 0;
    for (const cmd of commands) {
      const type = cmd[0].toUpperCase();
      const nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter((n) => !isNaN(n));
      switch (type) {
        case "M":
          currentX = nums[0] || 0;
          currentY = nums[1] || 0;
          segments.push({
            type: "M",
            points: [currentX, currentY],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          segments.push({
            type: "L",
            points: [currentX, currentY, nums[0], nums[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[0];
          currentY = nums[1];
          break;
        case "C":
          segments.push({
            type: "C",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[4];
          currentY = nums[5];
          break;
        case "Q":
          segments.push({
            type: "Q",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[2];
          currentY = nums[3];
          break;
        case "Z":
          const firstMove = segments.find((s) => s.type === "M");
          if (firstMove) {
            segments.push({
              type: "L",
              points: [currentX, currentY, firstMove.points[0], firstMove.points[1]],
              length: 0,
              startT: 0,
              endT: 0
            });
          }
          break;
      }
    }
    return segments;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let totalLength = 0;
    for (const segment of this.pathSegments) {
      switch (segment.type) {
        case "M":
          segment.length = 0;
          break;
        case "L":
          segment.length = this.lineLength(segment.points);
          break;
        case "C":
          segment.length = this.bezierLength(segment.points, 3);
          break;
        case "Q":
          segment.length = this.bezierLength(segment.points, 2);
          break;
      }
      segment.startT = totalLength;
      totalLength += segment.length;
      segment.endT = totalLength;
    }
    this.totalLength = totalLength;
    if (this.totalLength > 0) {
      for (const segment of this.pathSegments) {
        segment.startT /= this.totalLength;
        segment.endT /= this.totalLength;
      }
    }
  }
  lineLength(points) {
    const dx = points[2] - points[0];
    const dy = points[3] - points[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  bezierLength(points, degree) {
    const steps = 20;
    let length = 0;
    let prevX = points[0];
    let prevY = points[1];
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const { x, y } = this.getBezierPoint(points, t, degree);
      const dx = x - prevX;
      const dy = y - prevY;
      length += Math.sqrt(dx * dx + dy * dy);
      prevX = x;
      prevY = y;
    }
    return length;
  }
  getBezierPoint(points, t, degree) {
    if (degree === 2) {
      const mt = 1 - t;
      return {
        x: mt * mt * points[0] + 2 * mt * t * points[2] + t * t * points[4],
        y: mt * mt * points[1] + 2 * mt * t * points[3] + t * t * points[5]
      };
    } else {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;
      return {
        x: mt2 * mt * points[0] + 3 * mt2 * t * points[2] + 3 * mt * t2 * points[4] + t2 * t * points[6],
        y: mt2 * mt * points[1] + 3 * mt2 * t * points[3] + 3 * mt * t2 * points[5] + t2 * t * points[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(audioValue, isBeat) {
    this.state.previousPosition = this.state.position;
    const smoothedInput = this.state.smoothedValue * this.config.smoothing + audioValue * (1 - this.config.smoothing);
    this.state.smoothedValue = smoothedInput;
    if (this.config.movementMode === "amplitude") {
      this.updateAmplitudeMode(smoothedInput);
    } else {
      this.updateAccumulateMode(smoothedInput, isBeat);
    }
    const pathPoint = this.getPositionOnPath(this.state.position);
    this.state.x = pathPoint.x;
    this.state.y = pathPoint.y;
    this.state.angle = pathPoint.angle;
    return { ...this.state };
  }
  updateAmplitudeMode(audioValue) {
    let processedValue = Math.pow(audioValue, this.config.amplitudeCurve);
    if (processedValue > this.releaseState) {
      this.releaseState = processedValue;
    } else {
      const decayRate = 1 - this.config.release * 0.95;
      this.releaseState *= decayRate;
    }
    const finalValue = Math.max(processedValue, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, finalValue * this.config.sensitivity));
  }
  updateAccumulateMode(audioValue, isBeat) {
    if (this.config.flipOnBeat && isBeat && audioValue > this.config.beatThreshold) {
      this.state.direction *= -1;
    }
    const delta = audioValue * this.config.sensitivity * 0.02 * this.state.direction;
    let newPosition = this.state.position + delta;
    if (newPosition > 1) {
      newPosition = 2 - newPosition;
      this.state.direction = -1;
    } else if (newPosition < 0) {
      newPosition = -newPosition;
      this.state.direction = 1;
    }
    this.state.position = Math.max(0, Math.min(1, newPosition));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(t) {
    t = Math.max(0, Math.min(1, t));
    if (this.pathSegments.length === 0) {
      return { x: 0, y: 0, angle: 0 };
    }
    let segment = this.pathSegments[0];
    for (const seg of this.pathSegments) {
      if (seg.type !== "M" && t >= seg.startT && t <= seg.endT) {
        segment = seg;
        break;
      }
    }
    if (segment.type === "M") {
      return { x: segment.points[0], y: segment.points[1], angle: 0 };
    }
    const segmentT = segment.endT > segment.startT ? (t - segment.startT) / (segment.endT - segment.startT) : 0;
    let x, y;
    let tangentX, tangentY;
    switch (segment.type) {
      case "L":
        x = segment.points[0] + (segment.points[2] - segment.points[0]) * segmentT;
        y = segment.points[1] + (segment.points[3] - segment.points[1]) * segmentT;
        tangentX = segment.points[2] - segment.points[0];
        tangentY = segment.points[3] - segment.points[1];
        break;
      case "Q": {
        const result = this.getBezierPoint(segment.points, segmentT, 2);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        tangentX = 2 * mt * (segment.points[2] - segment.points[0]) + 2 * segmentT * (segment.points[4] - segment.points[2]);
        tangentY = 2 * mt * (segment.points[3] - segment.points[1]) + 2 * segmentT * (segment.points[5] - segment.points[3]);
        break;
      }
      case "C": {
        const result = this.getBezierPoint(segment.points, segmentT, 3);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        const mt2 = mt * mt;
        const t2 = segmentT * segmentT;
        tangentX = 3 * mt2 * (segment.points[2] - segment.points[0]) + 6 * mt * segmentT * (segment.points[4] - segment.points[2]) + 3 * t2 * (segment.points[6] - segment.points[4]);
        tangentY = 3 * mt2 * (segment.points[3] - segment.points[1]) + 6 * mt * segmentT * (segment.points[5] - segment.points[3]) + 3 * t2 * (segment.points[7] - segment.points[5]);
        break;
      }
      default:
        x = 0;
        y = 0;
        tangentX = 1;
        tangentY = 0;
    }
    const angle = Math.atan2(tangentY, tangentX);
    return { x, y, angle };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(steps = 5) {
    if (!this.config.motionBlur) return [];
    const trail = [];
    const startT = this.state.previousPosition;
    const endT = this.state.position;
    for (let i = 0; i <= steps; i++) {
      const t = startT + (endT - startT) * (i / steps);
      const pos = this.getPositionOnPath(t);
      const opacity = i / steps * this.config.motionBlurStrength;
      trail.push({ x: pos.x, y: pos.y, opacity });
    }
    return trail;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
    this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}

function getAnimatableType(paramType) {
  switch (paramType) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const EFFECT_DEFINITIONS = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: true },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: true },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: true }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: true },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: false },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: false }
    ]
  },
  "sharpen": {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: true }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: true },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: true },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Use Legacy", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: false },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: true, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "curves": {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false }
      // Note: Actual curve control would be a custom component
    ]
  },
  "levels": {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: false },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: true },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "tint": {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  // Distort
  "transform": {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: true },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: true },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "warp": {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: false },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: false },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true }
    ]
  },
  // Generate
  "fill": {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: true },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: true },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: false },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  // Stylize
  "glow": {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: true },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: true },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: true },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: false },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: true }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: true },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: true },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: true },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: true },
      { name: "Shadow Only", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: false },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: false },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: true },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: true },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: true },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: true }
    ]
  }
};
const EFFECT_CATEGORIES = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  "distort": { label: "Distort", icon: "D", description: "Distortion effects" },
  "generate": { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  "keying": { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  "matte": { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  "perspective": { label: "Perspective", icon: "P", description: "3D perspective effects" },
  "stylize": { label: "Stylize", icon: "S", description: "Stylization effects" },
  "time": { label: "Time", icon: "T", description: "Time-based effects" },
  "transition": { label: "Transition", icon: "Tr", description: "Transition effects" },
  "utility": { label: "Utility", icon: "U", description: "Utility effects" }
};
function createEffectInstance(definitionKey) {
  const def = EFFECT_DEFINITIONS[definitionKey];
  if (!def) return null;
  const parameters = {};
  def.parameters.forEach((param, index) => {
    const paramKey = param.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    parameters[paramKey] = {
      id: `${definitionKey}-${paramKey}-${index}`,
      name: param.name,
      type: getAnimatableType(param.type),
      value: param.defaultValue,
      animated: false,
      keyframes: []
    };
  });
  return {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: definitionKey,
    name: def.name,
    category: def.category,
    enabled: true,
    expanded: true,
    parameters
  };
}
const ANIMATION_PRESETS = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];

function isSplineControlPointPath(path) {
  return path.startsWith("spline.controlPoint.");
}
function createSplineControlPointPath(index, property) {
  return `spline.controlPoint.${index}.${property}`;
}
class PropertyDriverSystem {
  drivers = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  audioAnalysis = null;
  propertyGetter = null;
  constructor() {
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(analysis) {
    this.audioAnalysis = analysis;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(getter) {
    this.propertyGetter = getter;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(driver) {
    if (driver.sourceType === "property" && driver.sourceLayerId && driver.sourceProperty) {
      if (this.wouldCreateCycle(driver)) {
        storeLogger.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency");
        return false;
      }
    }
    this.drivers.set(driver.id, driver);
    this.smoothedValues.set(driver.id, 0);
    return true;
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(newDriver) {
    if (newDriver.sourceType !== "property") return false;
    if (!newDriver.sourceLayerId || !newDriver.sourceProperty) return false;
    const visited = /* @__PURE__ */ new Set();
    const targetKey = `${newDriver.targetLayerId}:${newDriver.targetProperty}`;
    const hasCycle = (layerId, property) => {
      const key = `${layerId}:${property}`;
      if (key === targetKey) return true;
      if (visited.has(key)) return false;
      visited.add(key);
      for (const driver of this.drivers.values()) {
        if (driver.sourceType !== "property") continue;
        if (driver.targetLayerId !== layerId || driver.targetProperty !== property) continue;
        if (!driver.sourceLayerId || !driver.sourceProperty) continue;
        if (hasCycle(driver.sourceLayerId, driver.sourceProperty)) {
          return true;
        }
      }
      return false;
    };
    return hasCycle(newDriver.sourceLayerId, newDriver.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(id) {
    this.drivers.delete(id);
    this.smoothedValues.delete(id);
  }
  /**
   * Update a driver
   */
  updateDriver(id, updates) {
    const driver = this.drivers.get(id);
    if (driver) {
      Object.assign(driver, updates);
    }
  }
  /**
   * Get a driver by ID
   */
  getDriver(id) {
    return this.drivers.get(id);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(layerId) {
    return Array.from(this.drivers.values()).filter((d) => d.targetLayerId === layerId);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(layerId, property) {
    return Array.from(this.drivers.values()).filter(
      (d) => d.targetLayerId === layerId && d.targetProperty === property && d.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(driver, frame, baseValue) {
    if (!driver.enabled) return baseValue;
    let value = this.getSourceValue(driver, frame);
    if (value === null) return baseValue;
    value = this.applyTransforms(driver, value);
    return this.blendValue(baseValue, value, driver.blendMode, driver.blendAmount);
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(driver, frame) {
    switch (driver.sourceType) {
      case "property":
        return this.getPropertySourceValue(driver, frame);
      case "audio":
        return this.getAudioSourceValue(driver, frame);
      case "time":
        return frame;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(driver, frame) {
    if (!this.propertyGetter || !driver.sourceLayerId || !driver.sourceProperty) {
      return null;
    }
    return this.propertyGetter(driver.sourceLayerId, driver.sourceProperty, frame);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(driver, frame) {
    if (!this.audioAnalysis || !driver.audioFeature) {
      return null;
    }
    let value = getFeatureAtFrame(this.audioAnalysis, driver.audioFeature, frame);
    if (driver.audioThreshold !== void 0) {
      if (driver.audioAboveThreshold) {
        value = value > driver.audioThreshold ? value : 0;
      } else {
        value = value >= driver.audioThreshold ? value : 0;
      }
    }
    return value;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(driver, value) {
    for (const transform of driver.transforms) {
      value = this.applyTransform(driver.id, transform, value);
    }
    return value;
  }
  /**
   * Apply a single transform
   */
  applyTransform(driverId, transform, value) {
    switch (transform.type) {
      case "scale":
        return value * (transform.factor ?? 1);
      case "offset":
        return value + (transform.amount ?? 0);
      case "clamp":
        return Math.max(transform.min ?? -Infinity, Math.min(transform.max ?? Infinity, value));
      case "smooth": {
        const prevValue = this.smoothedValues.get(driverId) ?? value;
        const smoothing = transform.smoothing ?? 0.5;
        const smoothed = prevValue * smoothing + value * (1 - smoothing);
        this.smoothedValues.set(driverId, smoothed);
        return smoothed;
      }
      case "invert":
        return 1 - value;
      case "remap": {
        const inMin = transform.inMin ?? 0;
        const inMax = transform.inMax ?? 1;
        const outMin = transform.outMin ?? 0;
        const outMax = transform.outMax ?? 1;
        const normalized = (value - inMin) / (inMax - inMin);
        return outMin + normalized * (outMax - outMin);
      }
      case "threshold":
        return value > (transform.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const freq = transform.frequency ?? 1;
        const amp = transform.amplitude ?? 1;
        const phase = transform.phase ?? 0;
        return Math.sin((value * freq + phase) * Math.PI * 2) * amp;
      }
      default:
        return value;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(base, driven, mode, amount) {
    let result;
    switch (mode) {
      case "replace":
        result = driven;
        break;
      case "add":
        result = base + driven;
        break;
      case "multiply":
        result = base * driven;
        break;
      default:
        result = driven;
    }
    return base * (1 - amount) + result * amount;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(layerId, frame, baseValues) {
    const result = /* @__PURE__ */ new Map();
    const drivers = this.getDriversForLayer(layerId);
    for (const driver of drivers) {
      if (!driver.enabled) continue;
      const baseValue = baseValues.get(driver.targetProperty) ?? 0;
      const drivenValue = this.evaluateDriver(driver, frame, baseValue);
      const existing = result.get(driver.targetProperty);
      if (existing !== void 0) {
        result.set(driver.targetProperty, existing + drivenValue - baseValue);
      } else {
        result.set(driver.targetProperty, drivenValue);
      }
    }
    return result;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear();
    this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(drivers) {
    this.clear();
    for (const driver of drivers) {
      this.addDriver(driver);
    }
  }
}
function createPropertyDriver(targetLayerId, targetProperty, sourceType = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: true,
    targetLayerId,
    targetProperty,
    sourceType,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function createAudioDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "audio");
  driver.audioFeature = audioFeature;
  driver.audioThreshold = options.threshold ?? 0;
  driver.audioAboveThreshold = options.threshold !== void 0;
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  if (options.smoothing !== void 0 && options.smoothing > 0) {
    driver.transforms.push({ type: "smooth", smoothing: options.smoothing });
  }
  return driver;
}
function createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "property");
  driver.sourceLayerId = sourceLayerId;
  driver.sourceProperty = sourceProperty;
  driver.blendMode = options.blendMode ?? "add";
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  return driver;
}

const DEFAULT_SNAP_CONFIG = {
  enabled: true,
  snapToGrid: true,
  snapToKeyframes: true,
  snapToBeats: true,
  snapToPeaks: true,
  snapToLayerBounds: true,
  snapToPlayhead: true,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function findNearestSnap(frame, config, pixelsPerFrame, context) {
  if (!config.enabled) {
    return null;
  }
  const snapTargets = [];
  const thresholdFrames = config.threshold / pixelsPerFrame;
  if (config.snapToGrid) {
    const nearestGridFrame = Math.round(frame / config.gridInterval) * config.gridInterval;
    const gridDistance = Math.abs(frame - nearestGridFrame);
    if (gridDistance <= thresholdFrames) {
      snapTargets.push({
        frame: nearestGridFrame,
        type: "frame",
        distance: gridDistance * pixelsPerFrame
      });
    }
  }
  if (config.snapToKeyframes && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, snapTargets);
    }
  }
  if (config.snapToBeats && context.audioAnalysis?.onsets) {
    for (const onset of context.audioAnalysis.onsets) {
      const distance = Math.abs(frame - onset);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: onset,
          type: "beat",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPeaks && context.peakData?.indices) {
    for (const peakFrame of context.peakData.indices) {
      const distance = Math.abs(frame - peakFrame);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: peakFrame,
          type: "peak",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToLayerBounds && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      const inDistance = Math.abs(frame - layer.inPoint);
      const outDistance = Math.abs(frame - layer.outPoint);
      if (inDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.inPoint,
          type: "layer-in",
          distance: inDistance * pixelsPerFrame
        });
      }
      if (outDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.outPoint,
          type: "layer-out",
          distance: outDistance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPlayhead && context.currentFrame !== void 0) {
    const distance = Math.abs(frame - context.currentFrame);
    if (distance <= thresholdFrames && distance > 0) {
      snapTargets.push({
        frame: context.currentFrame,
        type: "playhead",
        distance: distance * pixelsPerFrame
      });
    }
  }
  if (snapTargets.length === 0) {
    return null;
  }
  const priority = {
    "playhead": 5,
    "beat": 4,
    "peak": 4,
    "keyframe": 3,
    "layer-in": 2,
    "layer-out": 2,
    "frame": 1
  };
  snapTargets.sort((a, b) => {
    const distDiff = a.distance - b.distance;
    if (Math.abs(distDiff) < 0.5) {
      return priority[b.type] - priority[a.type];
    }
    return distDiff;
  });
  return snapTargets[0];
}
function collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, targets) {
  const properties = [
    layer.transform.position,
    layer.transform.scale,
    layer.transform.rotation,
    layer.opacity,
    ...layer.properties
  ];
  for (const prop of properties) {
    if (!prop.animated || !prop.keyframes) continue;
    for (const kf of prop.keyframes) {
      const distance = Math.abs(frame - kf.frame);
      if (distance <= thresholdFrames) {
        if (!targets.some((t) => t.frame === kf.frame && t.type === "keyframe")) {
          targets.push({
            frame: kf.frame,
            type: "keyframe",
            distance: distance * pixelsPerFrame
          });
        }
      }
    }
  }
}
function getBeatFrames(audioAnalysis) {
  return audioAnalysis?.onsets ?? [];
}
function getPeakFrames(peakData) {
  return peakData?.indices ?? [];
}

function getApiBase() {
  return "";
}
async function segmentImage(request) {
  const response = await fetch(`${getApiBase()}/weyl/segment`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `Segmentation failed: ${response.status}`);
  }
  return response.json();
}
async function segmentByPoint(imageBase64, point, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points: [point],
    labels: [1]
    // Foreground
  });
}
async function segmentByBox(imageBase64, box, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "box",
    model,
    box
  });
}
async function segmentByMultiplePoints(imageBase64, foregroundPoints, backgroundPoints = [], model = "sam2") {
  const points = [...foregroundPoints, ...backgroundPoints];
  const labels = [
    ...foregroundPoints.map(() => 1),
    // Foreground
    ...backgroundPoints.map(() => 0)
    // Background
  ];
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points,
    labels
  });
}
async function autoSegment(imageBase64, options = {}) {
  return segmentImage({
    image: imageBase64,
    mode: "auto",
    model: options.model || "sam2",
    minArea: options.minArea || 100,
    maxMasks: options.maxMasks || 20
  });
}
function applyMaskToImage(sourceImageBase64, maskBase64, bounds) {
  return new Promise((resolve, reject) => {
    const sourceImg = new Image();
    const maskImg = new Image();
    let sourceLoaded = false;
    let maskLoaded = false;
    const checkComplete = () => {
      if (!sourceLoaded || !maskLoaded) return;
      try {
        const canvas = document.createElement("canvas");
        canvas.width = bounds.width;
        canvas.height = bounds.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = maskImg.width;
        maskCanvas.height = maskImg.height;
        const maskCtx = maskCanvas.getContext("2d");
        if (!maskCtx) {
          reject(new Error("Failed to get mask canvas context"));
          return;
        }
        maskCtx.drawImage(maskImg, 0, 0);
        const maskData = maskCtx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
        ctx.drawImage(
          sourceImg,
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
          0,
          0,
          bounds.width,
          bounds.height
        );
        const imageData = ctx.getImageData(0, 0, bounds.width, bounds.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          imageData.data[i + 3] = maskData.data[i];
        }
        ctx.putImageData(imageData, 0, 0);
        const resultBase64 = canvas.toDataURL("image/png").split(",")[1];
        resolve(resultBase64);
      } catch (err) {
        reject(err);
      }
    };
    sourceImg.onload = () => {
      sourceLoaded = true;
      checkComplete();
    };
    sourceImg.onerror = () => reject(new Error("Failed to load source image"));
    maskImg.onload = () => {
      maskLoaded = true;
      checkComplete();
    };
    maskImg.onerror = () => reject(new Error("Failed to load mask image"));
    sourceImg.src = `data:image/png;base64,${sourceImageBase64}`;
    maskImg.src = `data:image/png;base64,${maskBase64}`;
  });
}

async function estimateVRAM(adapter) {
  try {
    const device = await adapter.requestDevice();
    const maxBufferSize = device.limits.maxBufferSize;
    device.destroy();
    return Math.round(maxBufferSize * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function detectGPUTier() {
  if ("gpu" in navigator) {
    try {
      const gpu = navigator.gpu;
      const adapter = await gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (adapter) {
        let deviceName = "";
        if ("info" in adapter) {
          const info = adapter.info;
          deviceName = info?.device || info?.description || "";
        }
        if (deviceName.includes("RTX 50") || deviceName.toLowerCase().includes("blackwell") || deviceName.includes("B100") || deviceName.includes("B200")) {
          return {
            tier: "blackwell",
            vram: await estimateVRAM(adapter),
            features: ["fp4_tensor", "webgpu", "cuda_12"]
          };
        }
        return {
          tier: "webgpu",
          vram: await estimateVRAM(adapter),
          features: ["webgpu"]
        };
      }
    } catch (error) {
      engineLogger.warn("WebGPU detection failed:", error);
    }
  }
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2");
  if (gl) {
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
    engineLogger.debug("WebGL renderer:", renderer);
    return {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}

const TIER_CONFIGS = {
  blackwell: {
    maxFrames: 500,
    maxMemoryBytes: 4 * 1024 * 1024 * 1024,
    // 4GB
    compression: false,
    // Fast GPU, no need for compression
    preCacheWindow: 30
  },
  webgpu: {
    maxFrames: 200,
    maxMemoryBytes: 1 * 1024 * 1024 * 1024,
    // 1GB
    compression: true,
    preCacheWindow: 15
  },
  webgl: {
    maxFrames: 100,
    maxMemoryBytes: 512 * 1024 * 1024,
    // 512MB
    compression: true,
    preCacheWindow: 10
  },
  cpu: {
    maxFrames: 50,
    maxMemoryBytes: 256 * 1024 * 1024,
    // 256MB
    compression: true,
    preCacheWindow: 5
  }
};
const DEFAULT_CONFIG = {
  maxFrames: 100,
  maxMemoryBytes: 512 * 1024 * 1024,
  compression: true,
  compressionQuality: 0.92,
  preCacheWindow: 10,
  predictivePreCache: true
};
class FrameCache {
  cache = /* @__PURE__ */ new Map();
  accessOrder = [];
  // For LRU tracking
  config;
  currentMemory = 0;
  stats = { hits: 0, misses: 0 };
  // Pre-caching state
  preCacheQueue = [];
  isPreCaching = false;
  preCacheAbort = null;
  // Composition state tracking
  stateHashCache = /* @__PURE__ */ new Map();
  // Frame render callback (set by engine)
  renderFrame = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Initialize cache with GPU-tier-appropriate settings
   */
  async initializeForGPU() {
    const tier = await detectGPUTier();
    const tierConfig = TIER_CONFIGS[tier.tier];
    this.config = { ...this.config, ...tierConfig };
  }
  /**
   * Set the frame render callback
   * This is called to render frames for pre-caching
   */
  setRenderCallback(callback) {
    this.renderFrame = callback;
  }
  /**
   * Generate a cache key for a frame
   */
  getCacheKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Get a cached frame
   * @returns The cached frame or null if not found/invalid
   */
  get(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.updateAccessOrder(key);
    this.stats.hits++;
    if (cached.compressed) {
      return null;
    }
    return cached.data;
  }
  /**
   * Get a cached frame (async, supports compression)
   */
  async getAsync(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.updateAccessOrder(key);
    this.stats.hits++;
    if (cached.compressed) {
      return this.decompressFrame(cached);
    }
    return cached.data;
  }
  /**
   * Cache a frame
   */
  async set(frame, compositionId, imageData, stateHash) {
    const key = this.getCacheKey(frame, compositionId);
    if (this.cache.has(key)) {
      this.remove(frame, compositionId);
    }
    let data = imageData;
    let compressed = false;
    let size = imageData.width * imageData.height * 4;
    if (this.config.compression) {
      const compressedData = await this.compressFrame(imageData);
      if (compressedData.size < size * 0.7) {
        data = compressedData;
        compressed = true;
        size = compressedData.size;
      }
    }
    await this.ensureCapacity(size);
    const cachedFrame = {
      frame,
      compositionId,
      data,
      compressed,
      width: imageData.width,
      height: imageData.height,
      timestamp: Date.now(),
      size,
      stateHash
    };
    this.cache.set(key, cachedFrame);
    this.accessOrder.push(key);
    this.currentMemory += size;
  }
  /**
   * Remove a cached frame
   */
  remove(frame, compositionId) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (cached) {
      this.currentMemory -= cached.size;
      this.cache.delete(key);
      this.accessOrder = this.accessOrder.filter((k) => k !== key);
    }
  }
  /**
   * Check if a frame is cached
   */
  has(frame, compositionId) {
    return this.cache.has(this.getCacheKey(frame, compositionId));
  }
  /**
   * Clear all cached frames for a composition
   */
  clearComposition(compositionId) {
    const keysToRemove = [];
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${compositionId}:`)) {
        keysToRemove.push(key);
      }
    }
    for (const key of keysToRemove) {
      const cached = this.cache.get(key);
      if (cached) {
        this.currentMemory -= cached.size;
      }
      this.cache.delete(key);
    }
    this.accessOrder = this.accessOrder.filter((k) => !keysToRemove.includes(k));
  }
  /**
   * Clear all cached frames
   */
  clear() {
    this.cache.clear();
    this.accessOrder = [];
    this.currentMemory = 0;
    this.stats = { hits: 0, misses: 0 };
    this.abortPreCache();
  }
  /**
   * Invalidate cache for a composition (when state changes)
   */
  invalidate(compositionId, newStateHash) {
    const oldHash = this.stateHashCache.get(compositionId);
    if (oldHash !== newStateHash) {
      this.clearComposition(compositionId);
      this.stateHashCache.set(compositionId, newStateHash);
    }
  }
  /**
   * Start predictive pre-caching around the current frame
   */
  async startPreCache(currentFrame, compositionId, stateHash, direction = "both") {
    if (!this.config.predictivePreCache || !this.renderFrame) {
      return;
    }
    this.abortPreCache();
    this.preCacheAbort = new AbortController();
    const signal = this.preCacheAbort.signal;
    this.preCacheQueue = [];
    const window = this.config.preCacheWindow;
    for (let i = 1; i <= window; i++) {
      if (direction !== "backward") {
        this.preCacheQueue.push({
          frame: currentFrame + i,
          compositionId,
          priority: window - i
          // Closer frames have higher priority
        });
      }
      if (direction !== "forward") {
        this.preCacheQueue.push({
          frame: currentFrame - i,
          compositionId,
          priority: window - i
        });
      }
    }
    this.preCacheQueue.sort((a, b) => b.priority - a.priority);
    this.isPreCaching = true;
    for (const item of this.preCacheQueue) {
      if (signal.aborted) {
        break;
      }
      if (!this.has(item.frame, item.compositionId)) {
        try {
          const imageData = await this.renderFrame(item.frame);
          if (!signal.aborted) {
            await this.set(item.frame, item.compositionId, imageData, stateHash);
          }
        } catch (error) {
          console.warn(`Pre-cache failed for frame ${item.frame}:`, error);
        }
      }
    }
    this.isPreCaching = false;
  }
  /**
   * Abort any ongoing pre-cache operation
   */
  abortPreCache() {
    if (this.preCacheAbort) {
      this.preCacheAbort.abort();
      this.preCacheAbort = null;
    }
    this.preCacheQueue = [];
    this.isPreCaching = false;
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    return {
      cachedFrames: this.cache.size,
      memoryUsed: this.currentMemory,
      hitRatio: total > 0 ? this.stats.hits / total : 0,
      hits: this.stats.hits,
      misses: this.stats.misses
    };
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  updateAccessOrder(key) {
    const index = this.accessOrder.indexOf(key);
    if (index > -1) {
      this.accessOrder.splice(index, 1);
    }
    this.accessOrder.push(key);
  }
  async ensureCapacity(requiredSize) {
    while ((this.cache.size >= this.config.maxFrames || this.currentMemory + requiredSize > this.config.maxMemoryBytes) && this.accessOrder.length > 0) {
      const oldestKey = this.accessOrder.shift();
      const cached = this.cache.get(oldestKey);
      if (cached) {
        this.currentMemory -= cached.size;
        this.cache.delete(oldestKey);
      }
    }
  }
  async compressFrame(imageData) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: "image/webp",
      quality: this.config.compressionQuality
    });
  }
  async decompressFrame(cached) {
    if (!(cached.data instanceof Blob)) {
      return cached.data;
    }
    const bitmap = await createImageBitmap(cached.data);
    const canvas = new OffscreenCanvas(cached.width, cached.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bitmap, 0, 0);
    bitmap.close();
    return ctx.getImageData(0, 0, cached.width, cached.height);
  }
}
let globalFrameCache = null;
function getFrameCache() {
  if (!globalFrameCache) {
    globalFrameCache = new FrameCache();
  }
  return globalFrameCache;
}
async function initializeFrameCache() {
  const cache = getFrameCache();
  await cache.initializeForGPU();
  return cache;
}

const logger$2 = createLogger("ProjectStorage");
const API_BASE = "/weyl/compositor";
async function saveProject(project, projectId) {
  try {
    logger$2.info(`Saving project${projectId ? ` (${projectId})` : ""}...`);
    const response = await fetch(`${API_BASE}/save_project`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        project,
        project_id: projectId
      })
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project saved: ${result.project_id}`);
    } else {
      logger$2.error(`Failed to save project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error saving project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function loadProject(projectId) {
  try {
    logger$2.info(`Loading project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/load_project/${encodeURIComponent(projectId)}`);
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project loaded: ${projectId}`);
    } else {
      logger$2.error(`Failed to load project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error loading project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function listProjects() {
  try {
    logger$2.info("Listing projects...");
    const response = await fetch(`${API_BASE}/list_projects`);
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Found ${result.projects?.length || 0} projects`);
    } else {
      logger$2.error(`Failed to list projects: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error listing projects:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function deleteProject(projectId) {
  try {
    logger$2.info(`Deleting project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/delete_project/${encodeURIComponent(projectId)}`, {
      method: "DELETE"
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project deleted: ${projectId}`);
    } else {
      logger$2.error(`Failed to delete project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error deleting project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}

function deleteLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const index = layers.findIndex((l) => l.id === layerId);
  if (index === -1) return;
  layers.splice(index, 1);
  store.selectedLayerIds = store.selectedLayerIds.filter((id) => id !== layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function duplicateLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const original = layers.find((l) => l.id === layerId);
  if (!original) return null;
  const duplicate = JSON.parse(JSON.stringify(original));
  duplicate.id = crypto.randomUUID();
  duplicate.name = original.name + " Copy";
  regenerateKeyframeIds(duplicate);
  const index = layers.findIndex((l) => l.id === layerId);
  layers.splice(index, 0, duplicate);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return duplicate;
}
function copySelectedLayers(store) {
  const layers = store.getActiveCompLayers();
  const selectedLayers = layers.filter((l) => store.selectedLayerIds.includes(l.id));
  if (selectedLayers.length === 0) return;
  store.clipboard.layers = selectedLayers.map((layer) => JSON.parse(JSON.stringify(layer)));
  storeLogger.debug(`Copied ${store.clipboard.layers.length} layer(s) to clipboard`);
}
function pasteLayers(store) {
  if (store.clipboard.layers.length === 0) return [];
  const layers = store.getActiveCompLayers();
  const pastedLayers = [];
  for (const clipboardLayer of store.clipboard.layers) {
    const newLayer = JSON.parse(JSON.stringify(clipboardLayer));
    newLayer.id = crypto.randomUUID();
    newLayer.name = clipboardLayer.name + " Copy";
    regenerateKeyframeIds(newLayer);
    newLayer.parentId = null;
    layers.unshift(newLayer);
    pastedLayers.push(newLayer);
  }
  store.selectedLayerIds = pastedLayers.map((l) => l.id);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  storeLogger.debug(`Pasted ${pastedLayers.length} layer(s)`);
  return pastedLayers;
}
function cutSelectedLayers(store) {
  copySelectedLayers(store);
  const layerIds = [...store.selectedLayerIds];
  for (const id of layerIds) {
    deleteLayer(store, id);
  }
}
function updateLayer(store, layerId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  Object.assign(layer, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateLayerData(store, layerId, dataUpdates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.data) return;
  Object.assign(layer.data, dataUpdates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveLayer(store, layerId, newIndex) {
  const layers = store.getActiveCompLayers();
  const currentIndex = layers.findIndex((l) => l.id === layerId);
  if (currentIndex === -1) return;
  const [layer] = layers.splice(currentIndex, 1);
  layers.splice(newIndex, 0, layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleLayer3D(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  layer.threeD = !layer.threeD;
  if (layer.threeD) {
    const t = layer.transform;
    const pos = t.position.value;
    t.position.value = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    t.position.type = "vector3";
    const anch = t.anchorPoint.value;
    t.anchorPoint.value = { x: anch.x, y: anch.y, z: anch.z ?? 0 };
    t.anchorPoint.type = "vector3";
    const scl = t.scale.value;
    t.scale.value = { x: scl.x, y: scl.y, z: scl.z ?? 100 };
    t.scale.type = "vector3";
    if (!t.orientation) {
      t.orientation = createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3");
    }
    if (!t.rotationX) {
      t.rotationX = createAnimatableProperty("rotationX", 0, "number");
    }
    if (!t.rotationY) {
      t.rotationY = createAnimatableProperty("rotationY", 0, "number");
    }
    if (!t.rotationZ) {
      t.rotationZ = createAnimatableProperty("rotationZ", 0, "number");
      t.rotationZ.value = t.rotation.value;
    }
  } else {
    if (layer.transform.rotationZ) {
      layer.transform.rotation.value = layer.transform.rotationZ.value;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setLayerParent(store, layerId, parentId) {
  const layers = store.getActiveCompLayers();
  const layer = layers.find((l) => l.id === layerId);
  if (!layer) return;
  if (parentId === layerId) return;
  if (parentId) {
    const getDescendants = (id) => {
      const descendants2 = /* @__PURE__ */ new Set();
      const children = layers.filter((l) => l.parentId === id);
      for (const child of children) {
        descendants2.add(child.id);
        const childDescendants = getDescendants(child.id);
        childDescendants.forEach((d) => descendants2.add(d));
      }
      return descendants2;
    };
    const descendants = getDescendants(layerId);
    if (descendants.has(parentId)) {
      storeLogger.warn("Cannot set parent: would create circular reference");
      return;
    }
  }
  layer.parentId = parentId;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function addSplineControlPoint(store, layerId, point) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  splineData.controlPoints.push(point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateSplineControlPoint(store, layerId, pointId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const point = splineData.controlPoints?.find((p) => p.id === pointId);
  if (!point) return;
  Object.assign(point, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteSplineControlPoint(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) return;
  const index = splineData.controlPoints.findIndex((p) => p.id === pointId);
  if (index >= 0) {
    splineData.controlPoints.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function selectLayer(store, layerId, addToSelection = false) {
  if (addToSelection) {
    if (!store.selectedLayerIds.includes(layerId)) {
      store.selectedLayerIds.push(layerId);
    }
  } else {
    store.selectedLayerIds = [layerId];
  }
}
function deselectLayer(store, layerId) {
  store.selectedLayerIds = store.selectedLayerIds.filter((id) => id !== layerId);
}
function clearSelection(store) {
  store.selectedLayerIds = [];
}
function regenerateKeyframeIds(layer) {
  if (layer.transform) {
    for (const key of Object.keys(layer.transform)) {
      const prop = layer.transform[key];
      if (prop?.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
  if (layer.properties) {
    for (const prop of layer.properties) {
      if (prop.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
}

function findPropertyByPath(layer, propertyPath) {
  const normalizedPath = propertyPath.replace(/^transform\./, "");
  if (normalizedPath === "position") {
    return layer.transform.position;
  }
  if (normalizedPath === "scale") {
    return layer.transform.scale;
  }
  if (normalizedPath === "rotation") {
    return layer.transform.rotation;
  }
  if (normalizedPath === "anchorPoint") {
    return layer.transform.anchorPoint;
  }
  if (propertyPath === "opacity") {
    return layer.opacity;
  }
  if (normalizedPath === "rotationX" && layer.transform.rotationX) {
    return layer.transform.rotationX;
  }
  if (normalizedPath === "rotationY" && layer.transform.rotationY) {
    return layer.transform.rotationY;
  }
  if (normalizedPath === "rotationZ" && layer.transform.rotationZ) {
    return layer.transform.rotationZ;
  }
  if (normalizedPath === "orientation" && layer.transform.orientation) {
    return layer.transform.orientation;
  }
  return layer.properties.find((p) => p.name === propertyPath || p.id === propertyPath);
}
function addKeyframe(store, layerId, propertyPath, value, atFrame) {
  const comp = store.getActiveComp();
  const frame = atFrame ?? (comp?.currentFrame ?? 0);
  storeLogger.debug("addKeyframe called:", { layerId, propertyPath, value, frame });
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.debug("addKeyframe: layer not found");
    return null;
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    storeLogger.debug("addKeyframe: property not found:", propertyPath);
    return null;
  }
  property.animated = true;
  const keyframe = {
    id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    frame,
    value,
    interpolation: "linear",
    inHandle: { frame: 0, value: 0, enabled: false },
    outHandle: { frame: 0, value: 0, enabled: false },
    controlMode: "smooth"
  };
  const existingIndex = property.keyframes.findIndex((k) => k.frame === frame);
  if (existingIndex >= 0) {
    property.keyframes[existingIndex] = keyframe;
    storeLogger.debug("addKeyframe: replaced existing keyframe at frame", frame);
  } else {
    property.keyframes.push(keyframe);
    property.keyframes.sort((a, b) => a.frame - b.frame);
    storeLogger.debug("addKeyframe: added new keyframe at frame", frame, "total keyframes:", property.keyframes.length);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  return keyframe;
}
function removeKeyframe(store, layerId, propertyPath, keyframeId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const index = property.keyframes.findIndex((k) => k.id === keyframeId);
  if (index >= 0) {
    property.keyframes.splice(index, 1);
    if (property.keyframes.length === 0) {
      property.animated = false;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveKeyframe(store, layerId, propertyPath, keyframeId, newFrame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  const existingAtTarget = property.keyframes.find(
    (kf) => kf.frame === newFrame && kf.id !== keyframeId
  );
  if (existingAtTarget) {
    property.keyframes = property.keyframes.filter((kf) => kf.id !== existingAtTarget.id);
  }
  keyframe.frame = newFrame;
  property.keyframes.sort((a, b) => a.frame - b.frame);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeValue(store, layerId, propertyPath, keyframeId, newValue) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (typeof keyframe.value === "object" && keyframe.value !== null && typeof newValue === "number") {
    storeLogger.warn("setKeyframeValue: Cannot directly update vector keyframes with scalar. Use separate dimension curves.");
    return;
  }
  keyframe.value = newValue;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateKeyframe(store, layerId, propertyPath, keyframeId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (updates.frame !== void 0) {
    keyframe.frame = updates.frame;
    property.keyframes.sort((a, b) => a.frame - b.frame);
  }
  if (updates.value !== void 0) {
    keyframe.value = updates.value;
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeInterpolation(store, layerId, propertyPath, keyframeId, interpolation) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  keyframe.interpolation = interpolation;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeHandle(store, layerId, propertyPath, keyframeId, handleType, handle) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (handleType === "in") {
    keyframe.inHandle = { ...handle };
  } else {
    keyframe.outHandle = { ...handle };
  }
  if (handle.enabled && keyframe.interpolation === "linear") {
    keyframe.interpolation = "bezier";
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyValue(store, layerId, propertyPath, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.value = value;
  if (property.animated && property.keyframes.length > 0) {
    const currentFrame = store.getActiveComp()?.currentFrame ?? 0;
    const existingKf = property.keyframes.find((kf) => kf.frame === currentFrame);
    if (existingKf) {
      existingKf.value = value;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyAnimated(store, layerId, propertyPath, animated, addKeyframeCallback) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.animated = animated;
  if (animated && property.keyframes.length === 0) {
    if (addKeyframeCallback) {
      addKeyframeCallback();
    } else {
      const comp = store.getActiveComp();
      const frame = comp?.currentFrame ?? 0;
      const keyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame,
        value: property.value,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false },
        controlMode: "smooth"
      };
      property.keyframes.push(keyframe);
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}

const MAX_HISTORY_SIZE = 50;
function pushHistory(store) {
  if (store.historyIndex < store.historyStack.length - 1) {
    store.historyStack = store.historyStack.slice(0, store.historyIndex + 1);
  }
  const snapshot = JSON.parse(JSON.stringify(store.project));
  store.historyStack.push(snapshot);
  store.historyIndex = store.historyStack.length - 1;
  if (store.historyStack.length > MAX_HISTORY_SIZE) {
    store.historyStack = store.historyStack.slice(-MAX_HISTORY_SIZE);
    store.historyIndex = store.historyStack.length - 1;
  }
}
function undo(store) {
  if (store.historyIndex <= 0) return false;
  store.historyIndex--;
  store.project = JSON.parse(JSON.stringify(store.historyStack[store.historyIndex]));
  return true;
}
function redo(store) {
  if (store.historyIndex >= store.historyStack.length - 1) return false;
  store.historyIndex++;
  store.project = JSON.parse(JSON.stringify(store.historyStack[store.historyIndex]));
  return true;
}
function exportProject(store) {
  return JSON.stringify(store.project, null, 2);
}
function importProject(store, json, pushHistoryFn) {
  try {
    const project = JSON.parse(json);
    store.project = project;
    pushHistoryFn();
    return true;
  } catch (err) {
    storeLogger.error("Failed to import project:", err);
    return false;
  }
}
async function saveProjectToServer(store, projectId) {
  try {
    const result = await saveProject(store.project, projectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project saved to server:", result.project_id);
      return result.project_id;
    } else {
      storeLogger.error("Failed to save project:", result.message);
      return null;
    }
  } catch (err) {
    storeLogger.error("Error saving project to server:", err);
    return null;
  }
}
async function loadProjectFromServer(store, projectId, pushHistoryFn) {
  try {
    const result = await loadProject(projectId);
    if (result.status === "success" && result.project) {
      store.project = result.project;
      pushHistoryFn();
      store.lastSaveProjectId = projectId;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project loaded from server:", projectId);
      return true;
    } else {
      storeLogger.error("Failed to load project:", result.message);
      return false;
    }
  } catch (err) {
    storeLogger.error("Error loading project from server:", err);
    return false;
  }
}
async function listServerProjects() {
  try {
    const result = await listProjects();
    if (result.status === "success" && result.projects) {
      return result.projects;
    }
    return [];
  } catch (err) {
    storeLogger.error("Error listing projects:", err);
    return [];
  }
}
async function deleteServerProject(projectId) {
  try {
    const result = await deleteProject(projectId);
    return result.status === "success";
  } catch (err) {
    storeLogger.error("Error deleting project:", err);
    return false;
  }
}

const useCompositorStore = defineStore("compositor", {
  state: () => ({
    project: createEmptyProject(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: false,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    segmentMode: "point",
    segmentPendingMask: null,
    segmentBoxStart: null,
    segmentIsLoading: false,
    graphEditorVisible: false,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: createDefaultViewportState(),
    viewOptions: createDefaultViewOptions(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...DEFAULT_SNAP_CONFIG },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    },
    // Autosave (enabled by default, every 60 seconds)
    autosaveEnabled: true,
    autosaveIntervalMs: 6e4,
    autosaveTimerId: null,
    lastSaveTime: null,
    lastSaveProjectId: null,
    hasUnsavedChanges: false,
    // Frame cache (enabled by default)
    frameCacheEnabled: true,
    projectStateHash: ""
  }),
  getters: {
    // Active composition helper
    activeComposition: (state) => {
      return state.project.compositions[state.activeCompositionId] || null;
    },
    // Project info - now uses active composition
    hasProject: (state) => state.sourceImage !== null,
    width(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.width || 1024;
    },
    height(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.height || 1024;
    },
    frameCount(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.frameCount || 81;
    },
    fps(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.fps || 16;
    },
    duration(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.duration || 5;
    },
    // Current frame - per composition
    currentFrame(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.currentFrame || 0;
    },
    currentTime(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      if (!comp) return 0;
      return comp.currentFrame / comp.settings.fps;
    },
    // Layers - from active composition
    layers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.layers || [];
    },
    visibleLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.visible);
    },
    // Selection
    selectedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => state.selectedLayerIds.includes(l.id));
    },
    selectedLayer(state) {
      if (state.selectedLayerIds.length !== 1) return null;
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).find((l) => l.id === state.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (state) => {
      return Object.values(state.project.compositions);
    },
    openCompositions(state) {
      return state.openCompositionIds.map((id) => state.project.compositions[id]).filter(Boolean);
    },
    // Assets
    assets: (state) => state.project.assets,
    // History
    canUndo: (state) => state.historyIndex > 0,
    canRedo: (state) => state.historyIndex < state.historyStack.length - 1,
    // Camera
    activeCamera: (state) => {
      if (!state.activeCameraId) return null;
      return state.cameras.get(state.activeCameraId) || null;
    },
    allCameras: (state) => Array.from(state.cameras.values()),
    cameraLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const comp = this.project.compositions[this.activeCompositionId];
      return comp?.layers || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(name, settings, isPrecomp = false) {
      const id = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const activeComp = this.project.compositions[this.activeCompositionId];
      const defaultSettings = {
        width: settings?.width ?? activeComp?.settings.width ?? 1024,
        height: settings?.height ?? activeComp?.settings.height ?? 1024,
        frameCount: settings?.frameCount ?? activeComp?.settings.frameCount ?? 81,
        fps: settings?.fps ?? activeComp?.settings.fps ?? 16,
        duration: 0,
        backgroundColor: settings?.backgroundColor ?? "#000000",
        autoResizeToContent: settings?.autoResizeToContent ?? true
      };
      defaultSettings.duration = defaultSettings.frameCount / defaultSettings.fps;
      const composition = {
        id,
        name,
        settings: defaultSettings,
        layers: [],
        currentFrame: 0,
        isPrecomp
      };
      this.project.compositions[id] = composition;
      if (!this.openCompositionIds.includes(id)) {
        this.openCompositionIds.push(id);
      }
      this.activeCompositionId = id;
      storeLogger.debug("Created composition:", name, id);
      return composition;
    },
    /**
     * Delete a composition
     */
    deleteComposition(compId) {
      if (compId === this.project.mainCompositionId) {
        storeLogger.warn("Cannot delete main composition");
        return false;
      }
      const comp = this.project.compositions[compId];
      if (!comp) return false;
      delete this.project.compositions[compId];
      const openIdx = this.openCompositionIds.indexOf(compId);
      if (openIdx >= 0) {
        this.openCompositionIds.splice(openIdx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId;
      }
      storeLogger.debug("Deleted composition:", compId);
      return true;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Composition not found:", compId);
        return;
      }
      if (!this.openCompositionIds.includes(compId)) {
        this.openCompositionIds.push(compId);
      }
      this.selectedLayerIds = [];
      this.selectedKeyframeIds = [];
      this.activeCompositionId = compId;
      storeLogger.debug("Switched to composition:", compId);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(compId) {
      if (this.openCompositionIds.length <= 1) {
        storeLogger.warn("Cannot close the last tab");
        return;
      }
      const idx = this.openCompositionIds.indexOf(compId);
      if (idx >= 0) {
        this.openCompositionIds.splice(idx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[Math.max(0, idx - 1)];
      }
    },
    /**
     * Rename a composition
     */
    renameComposition(compId, newName) {
      const comp = this.project.compositions[compId];
      if (comp) {
        comp.name = newName;
      }
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(compId, settings) {
      const comp = this.project.compositions[compId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      Object.assign(comp.settings, settings);
      comp.settings.duration = comp.settings.frameCount / comp.settings.fps;
      if (settings.frameCount && settings.frameCount > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = settings.frameCount - 1;
          }
        }
      }
      if (compId === this.project.mainCompositionId) {
        Object.assign(this.project.composition, comp.settings);
      }
    },
    /**
     * Get a composition by ID
     */
    getComposition(compId) {
      return this.project.compositions[compId] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(name) {
      if (this.selectedLayerIds.length === 0) {
        storeLogger.warn("No layers selected for pre-compose");
        return null;
      }
      const activeComp = this.project.compositions[this.activeCompositionId];
      if (!activeComp) return null;
      const precomp = this.createComposition(
        name || "Pre-comp",
        activeComp.settings,
        true
      );
      const selectedLayers = activeComp.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      );
      const earliestIn = Math.min(...selectedLayers.map((l) => l.inPoint));
      for (const layer of selectedLayers) {
        layer.inPoint -= earliestIn;
        layer.outPoint -= earliestIn;
        const idx = activeComp.layers.indexOf(layer);
        if (idx >= 0) {
          activeComp.layers.splice(idx, 1);
        }
        precomp.layers.push(layer);
      }
      const maxOut = Math.max(...precomp.layers.map((l) => l.outPoint));
      precomp.settings.frameCount = maxOut + 1;
      precomp.settings.duration = precomp.settings.frameCount / precomp.settings.fps;
      const precompLayer = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: precomp.name,
        type: "precomp",
        visible: true,
        locked: false,
        solo: false,
        threeD: false,
        inPoint: earliestIn,
        outPoint: earliestIn + precomp.settings.frameCount - 1,
        parentId: null,
        transform: createDefaultTransform(),
        opacity: createAnimatableProperty("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: false,
        data: {
          compositionId: precomp.id,
          timeRemapEnabled: false,
          collapseTransformations: false
        }
      };
      activeComp.layers.push(precompLayer);
      this.selectedLayerIds = [];
      this.activeCompositionId = activeComp.id;
      storeLogger.debug("Pre-composed layers into:", precomp.name);
      return precomp;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(inputs) {
      this.comfyuiNodeId = inputs.node_id;
      this.sourceImage = inputs.source_image;
      this.depthMap = inputs.depth_map;
      const comp = this.project.compositions[this.activeCompositionId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = inputs.width;
      comp.settings.height = inputs.height;
      comp.settings.frameCount = inputs.frame_count;
      comp.settings.duration = inputs.frame_count / comp.settings.fps;
      this.project.composition.width = inputs.width;
      this.project.composition.height = inputs.height;
      this.project.composition.frameCount = inputs.frame_count;
      this.project.composition.duration = inputs.frame_count / this.project.composition.fps;
      if (inputs.frame_count > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = inputs.frame_count - 1;
          }
        }
      }
      if (inputs.source_image) {
        this.project.assets["source_image"] = {
          id: "source_image",
          type: "image",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.source_image
        };
      }
      if (inputs.depth_map) {
        this.project.assets["depth_map"] = {
          id: "depth_map",
          type: "depth_map",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.depth_map
        };
      }
      if (comp) comp.currentFrame = 0;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      storeLogger.debug("Loaded inputs from ComfyUI:", {
        width: inputs.width,
        height: inputs.height,
        frameCount: inputs.frame_count
      });
      this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(type, name) {
      const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let layerData = null;
      switch (type) {
        case "text":
          layerData = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: false,
            pathPerpendicularToPath: true,
            pathForceAlignment: false,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          layerData = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          layerData = {
            size: 40
          };
          break;
        case "spline":
          layerData = {
            pathData: "",
            controlPoints: [],
            closed: false,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          layerData = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: false,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: true,
              burstOnBeat: false,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: false,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: false,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: false,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: false,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: true
              }
            }
          };
          break;
        case "depthflow":
          layerData = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: false
            }
          };
          break;
        case "light":
          layerData = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: false,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          layerData = {
            cameraId: null,
            isActiveCamera: false
          };
          break;
        case "image":
          layerData = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          layerData = {
            assetId: null,
            loop: false,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let audioProps = void 0;
      if (type === "video" || type === "audio") {
        audioProps = {
          level: createAnimatableProperty("Audio Levels", 0, "number")
          // 0dB default
        };
      }
      const comp = this.getActiveComp();
      const layers = this.getActiveCompLayers();
      const layer = {
        id,
        name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
        type,
        visible: true,
        locked: false,
        solo: false,
        threeD: false,
        motionBlur: false,
        inPoint: 0,
        outPoint: (comp?.settings.frameCount || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: createAnimatableProperty("opacity", 100, "number"),
        transform: createDefaultTransform(),
        audio: audioProps,
        properties: [],
        effects: [],
        data: layerData
      };
      if (type === "camera") {
        storeLogger.warn("Use createCameraLayer() for camera layers");
      }
      layers.unshift(layer);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Delete a layer
     */
    deleteLayer(layerId) {
      deleteLayer(this, layerId);
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(layerId) {
      return duplicateLayer(this, layerId);
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      copySelectedLayers(this);
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      return pasteLayers(this);
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      cutSelectedLayers(this);
    },
    /**
     * Update layer properties
     */
    updateLayer(layerId, updates) {
      updateLayer(this, layerId, updates);
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(layerId, dataUpdates) {
      updateLayerData(this, layerId, dataUpdates);
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(layerId, point) {
      addSplineControlPoint(this, layerId, point);
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(layerId, pointId, updates) {
      updateSplineControlPoint(this, layerId, pointId, updates);
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(layerId, pointId) {
      deleteSplineControlPoint(this, layerId, pointId);
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(layerId) {
      toggleLayer3D(this, layerId);
    },
    /**
     * Reorder layers
     */
    moveLayer(layerId, newIndex) {
      moveLayer(this, layerId, newIndex);
    },
    /**
     * Selection
     */
    selectLayer(layerId, addToSelection = false) {
      selectLayer(this, layerId, addToSelection);
    },
    deselectLayer(layerId) {
      deselectLayer(this, layerId);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(layerId, parentId) {
      setLayerParent(this, layerId, parentId);
    },
    clearSelection() {
      clearSelection(this);
      this.selectedKeyframeIds = [];
      this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(propertyPath) {
      this.selectedPropertyPath = propertyPath;
    },
    // ============================================================
    // MOTION ENGINE INTEGRATION
    // ============================================================
    /**
     * Get evaluated FrameState for the current frame
     *
     * This is the CANONICAL way to get evaluated state for rendering.
     * Uses MotionEngine.evaluate() which is PURE and deterministic.
     *
     * @param frame - Optional frame override (defaults to currentFrame)
     * @returns Immutable FrameState snapshot
     */
    getFrameState(frame) {
      const comp = this.getActiveComp();
      const targetFrame = frame ?? (comp?.currentFrame ?? 0);
      return motionEngine.evaluate(
        targetFrame,
        this.project,
        this.audioAnalysis,
        this.activeCameraId
      );
    },
    // ============================================================
    // PLAYBACK CONTROLS
    // ============================================================
    /**
     * Start playback
     * NOTE: This only updates UI state (currentFrame).
     * Actual frame evaluation happens via getFrameState().
     */
    play() {
      if (this.isPlaying) return;
      const comp = this.getActiveComp();
      if (!comp) return;
      this.isPlaying = true;
      this.playbackStartTime = performance.now();
      this.playbackStartFrame = comp.currentFrame;
      this.playbackLoop();
    },
    /**
     * Pause playback
     */
    pause() {
      this.isPlaying = false;
      if (this.playbackRequestId !== null) {
        cancelAnimationFrame(this.playbackRequestId);
        this.playbackRequestId = null;
      }
    },
    /**
     * Toggle playback state
     */
    togglePlayback() {
      if (this.isPlaying) {
        this.pause();
      } else {
        this.play();
      }
    },
    /**
     * Animation loop for playback
     *
     * ARCHITECTURAL NOTE:
     * This method ONLY updates the UI state (currentFrame).
     * It does NOT evaluate or render frames directly.
     * The render loop in Vue components should watch currentFrame
     * and call getFrameState()  engine.applyFrameState().
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const comp = this.getActiveComp();
      if (!comp) return;
      const elapsed = performance.now() - (this.playbackStartTime || 0);
      const fps = comp.settings.fps;
      const frameCount = comp.settings.frameCount;
      const elapsedFrames = Math.floor(elapsed / 1e3 * fps);
      let newFrame = this.playbackStartFrame + elapsedFrames;
      if (newFrame >= frameCount) {
        newFrame = 0;
        this.playbackStartFrame = 0;
        this.playbackStartTime = performance.now();
      }
      comp.currentFrame = newFrame;
      this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    /**
     * Set current frame (UI state only)
     * Components watching currentFrame should call getFrameState() to evaluate.
     */
    setFrame(frame) {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
    },
    /**
     * Advance to next frame (UI state only)
     */
    nextFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame < comp.settings.frameCount - 1) {
        comp.currentFrame++;
      }
    },
    /**
     * Go to previous frame (UI state only)
     */
    prevFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame > 0) {
        comp.currentFrame--;
      }
    },
    /**
     * Jump to first frame (UI state only)
     */
    goToStart() {
      const comp = this.getActiveComp();
      if (comp) comp.currentFrame = 0;
    },
    /**
     * Jump to last frame (UI state only)
     */
    goToEnd() {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = comp.settings.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(tool) {
      this.currentTool = tool;
      if (tool !== "segment") {
        this.clearSegmentPendingMask();
      }
    },
    /**
     * Set segmentation mode (point or box)
     */
    setSegmentMode(mode) {
      this.segmentMode = mode;
      this.clearSegmentPendingMask();
    },
    /**
     * Clear pending segmentation mask
     */
    clearSegmentPendingMask() {
      this.segmentPendingMask = null;
      this.segmentBoxStart = null;
    },
    /**
     * Set pending segmentation mask (preview before creating layer)
     */
    setSegmentPendingMask(mask) {
      this.segmentPendingMask = mask;
    },
    /**
     * Set box selection start point
     */
    setSegmentBoxStart(point) {
      this.segmentBoxStart = point;
    },
    /**
     * Set segmentation loading state
     */
    setSegmentLoading(loading) {
      this.segmentIsLoading = loading;
    },
    /**
     * Confirm pending mask and create layer from it
     */
    async confirmSegmentMask(layerName) {
      if (!this.segmentPendingMask || !this.sourceImage) {
        return null;
      }
      const layer = await this._createLayerFromMask(
        this.sourceImage,
        this.segmentPendingMask,
        layerName,
        false
      );
      this.clearSegmentPendingMask();
      return layer;
    },
    /**
     * History management
     */
    pushHistory() {
      pushHistory(this);
    },
    undo() {
      undo(this);
    },
    redo() {
      redo(this);
    },
    /**
     * Project serialization
     */
    exportProject() {
      return exportProject(this);
    },
    importProject(json) {
      importProject(this, json, () => this.pushHistory());
    },
    /**
     * Save project to server (ComfyUI backend)
     */
    async saveProjectToServer(projectId) {
      return saveProjectToServer(this, projectId);
    },
    /**
     * Load project from server (ComfyUI backend)
     */
    async loadProjectFromServer(projectId) {
      return loadProjectFromServer(this, projectId, () => this.pushHistory());
    },
    /**
     * List all projects saved on server
     */
    async listServerProjects() {
      return listServerProjects();
    },
    /**
     * Delete a project from server
     */
    async deleteServerProject(projectId) {
      return deleteServerProject(projectId);
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(property) {
      return interpolateProperty(property, this.getActiveComp()?.currentFrame ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(layerId, propertyName, value, atFrame) {
      return addKeyframe(this, layerId, propertyName, value, atFrame);
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(layerId, propertyName, keyframeId) {
      removeKeyframe(this, layerId, propertyName, keyframeId);
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(layerId, propertyPath, value) {
      setPropertyValue(this, layerId, propertyPath, value);
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(layerId, propertyPath, animated) {
      setPropertyAnimated(this, layerId, propertyPath, animated, () => {
        this.addKeyframe(layerId, propertyPath, findPropertyByPath(
          this.getActiveCompLayers().find((l) => l.id === layerId),
          propertyPath
        )?.value);
      });
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(layerId, propertyPath, keyframeId, newFrame) {
      moveKeyframe(this, layerId, propertyPath, keyframeId, newFrame);
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(layerId, propertyPath, keyframeId, newValue) {
      setKeyframeValue(this, layerId, propertyPath, keyframeId, newValue);
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(layerId, propertyPath, keyframeId, interpolation) {
      setKeyframeInterpolation(this, layerId, propertyPath, keyframeId, interpolation);
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(layerId, propertyPath, keyframeId, updates) {
      updateKeyframe(this, layerId, propertyPath, keyframeId, updates);
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(layerId, propertyPath, keyframeId, handleType, handle) {
      setKeyframeHandle(this, layerId, propertyPath, keyframeId, handleType, handle);
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(text = "Text") {
      const layer = this.createLayer("text", text.substring(0, 20));
      const textData = {
        text,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: false
      };
      layer.data = textData;
      layer.properties.push(createAnimatableProperty("Font Size", 72, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Fill Color", "#ffffff", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Color", "#000000", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Width", 0, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Path Offset", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("First Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Last Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options"));
      layer.properties.push(createAnimatableProperty("Tracking", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Line Spacing", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Offset", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Value", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Blur", { x: 0, y: 0 }, "position", "Advanced"));
      return layer;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const layer = this.createLayer("spline");
      const splineData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      layer.data = splineData;
      return layer;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const layer = this.createLayer("particles", "Particle System");
      const particleData = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20,
          // Geometric emitter shape defaults
          shape: "point",
          shapeRadius: 0.1,
          shapeWidth: 0.2,
          shapeHeight: 0.2,
          shapeDepth: 0.2,
          shapeInnerRadius: 0.05,
          emitFromEdge: false,
          emitFromVolume: false,
          // Spline path emission (null = disabled)
          splinePath: null,
          // Sprite configuration
          sprite: {
            enabled: false,
            imageUrl: null,
            imageData: null,
            isSheet: false,
            columns: 1,
            rows: 1,
            totalFrames: 1,
            frameRate: 30,
            playMode: "loop",
            billboard: true,
            rotationEnabled: false,
            rotationSpeed: 0,
            rotationSpeedVariance: 0,
            alignToVelocity: false
          }
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      layer.data = particleData;
      return layer;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(layerId, config) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters.push(config);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(layerId, emitterId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      const emitter = data.emitters.find((e) => e.id === emitterId);
      if (emitter) {
        Object.assign(emitter, updates);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(layerId, emitterId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters = data.emitters.filter((e) => e.id !== emitterId);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(sourceLayerId = "", depthLayerId = "") {
      const layer = this.createLayer("depthflow", "Depthflow");
      const depthflowData = {
        sourceLayerId,
        depthLayerId,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        },
        animatedZoom: createAnimatableProperty("zoom", 1, "number"),
        animatedOffsetX: createAnimatableProperty("offsetX", 0, "number"),
        animatedOffsetY: createAnimatableProperty("offsetY", 0, "number"),
        animatedRotation: createAnimatableProperty("rotation", 0, "number"),
        animatedDepthScale: createAnimatableProperty("depthScale", 1, "number")
      };
      layer.data = depthflowData;
      return layer;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "depthflow") return;
      const data = layer.data;
      Object.assign(data.config, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(file, autoResizeComposition = true) {
      let videoUrl;
      try {
        videoUrl = URL.createObjectURL(file);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let metadata;
      try {
        metadata = await extractVideoMetadata(videoUrl);
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        throw new Error(`Failed to load video metadata: ${error.message}`);
      }
      const assetId = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const asset = {
        id: assetId,
        type: "video",
        source: "file",
        width: metadata.width,
        height: metadata.height,
        data: videoUrl,
        // Video-specific metadata
        duration: metadata.duration,
        frameCount: metadata.frameCount,
        fps: metadata.fps,
        hasAudio: metadata.hasAudio
      };
      this.project.assets[assetId] = asset;
      if (autoResizeComposition) {
        const compSettings = calculateCompositionFromVideo(metadata, this.project.composition.fps);
        storeLogger.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: compSettings.width,
          newHeight: compSettings.height,
          newFrameCount: compSettings.frameCount,
          videoDuration: metadata.duration
        });
        this.project.composition.width = compSettings.width;
        this.project.composition.height = compSettings.height;
        this.project.composition.frameCount = compSettings.frameCount;
        this.project.composition.duration = compSettings.frameCount / this.project.composition.fps;
      }
      const layer = this.createLayer("video", file.name.replace(/\.[^.]+$/, ""));
      const videoData = {
        assetId,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: metadata.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      layer.data = videoData;
      if (!autoResizeComposition) {
        const videoFrameCount = Math.ceil(metadata.duration * this.project.composition.fps);
        layer.outPoint = Math.min(videoFrameCount - 1, this.project.composition.frameCount - 1);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Created video layer:", {
        layerId: layer.id,
        assetId,
        dimensions: `${metadata.width}x${metadata.height}`,
        duration: `${metadata.duration.toFixed(2)}s`,
        frameCount: metadata.frameCount,
        hasAudio: metadata.hasAudio
      });
      return layer;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(layerId, metadata) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const videoData = layer.data;
      if (!videoData.assetId) return;
      const asset = this.project.assets[videoData.assetId];
      if (asset) {
        asset.width = metadata.width;
        asset.height = metadata.height;
        asset.duration = metadata.duration;
        asset.frameCount = metadata.frameCount;
        asset.fps = metadata.fps;
        asset.hasAudio = metadata.hasAudio;
      }
      storeLogger.debug("Video metadata loaded:", { layerId, metadata });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(width, height, frameCount) {
      const comp = this.getActiveComp();
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = width;
      comp.settings.height = height;
      this.project.composition.width = width;
      this.project.composition.height = height;
      if (frameCount !== void 0) {
        comp.settings.frameCount = frameCount;
        comp.settings.duration = frameCount / comp.settings.fps;
        this.project.composition.frameCount = frameCount;
        this.project.composition.duration = frameCount / this.project.composition.fps;
        if (frameCount > oldFrameCount) {
          for (const layer of comp.layers) {
            if (layer.outPoint === oldFrameCount - 1) {
              layer.outPoint = frameCount - 1;
            }
          }
        }
      }
      if (comp.currentFrame >= comp.settings.frameCount) {
        comp.currentFrame = comp.settings.frameCount - 1;
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Composition resized:", {
        width,
        height,
        frameCount: comp.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(compositionId, name) {
      const layer = this.createLayer("precomp", name || "Precomp");
      const precompData = {
        compositionId,
        timeRemapEnabled: false,
        timeRemap: void 0,
        collapseTransformations: false,
        overrideFrameRate: false,
        frameRate: void 0
      };
      layer.data = precompData;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "precomp") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // SEGMENTATION  LAYER PIPELINE (Vision Model Integration)
    // ============================================================
    /**
     * Segment source image by clicking a point and create a layer from the result.
     * This is the primary entry point for the Vision  Layer pipeline used by
     * Time-to-Move and other diffusion model integrations.
     *
     * @param point - Click coordinates in image space
     * @param options - Additional options
     * @returns Promise resolving to the created layer, or null if failed
     */
    async segmentToLayerByPoint(point, options = {}) {
      const sourceImage = this.sourceImage;
      if (!sourceImage) {
        storeLogger.error("No source image available for segmentation");
        return null;
      }
      try {
        const result = await segmentByPoint(sourceImage, point, options.model || "sam2");
        if (result.status !== "success" || !result.masks || result.masks.length === 0) {
          storeLogger.error("Segmentation failed:", result.message);
          return null;
        }
        const mask = result.masks[0];
        return this._createLayerFromMask(sourceImage, mask, options.layerName, options.positionAtCenter);
      } catch (err) {
        storeLogger.error("Segmentation error:", err);
        return null;
      }
    },
    /**
     * Segment source image by box selection and create a layer from the result.
     *
     * @param box - Selection box [x1, y1, x2, y2] in image space
     * @param options - Additional options
     * @returns Promise resolving to the created layer, or null if failed
     */
    async segmentToLayerByBox(box, options = {}) {
      const sourceImage = this.sourceImage;
      if (!sourceImage) {
        storeLogger.error("No source image available for segmentation");
        return null;
      }
      try {
        const result = await segmentByBox(sourceImage, box, options.model || "sam2");
        if (result.status !== "success" || !result.masks || result.masks.length === 0) {
          storeLogger.error("Segmentation failed:", result.message);
          return null;
        }
        const mask = result.masks[0];
        return this._createLayerFromMask(sourceImage, mask, options.layerName, options.positionAtCenter);
      } catch (err) {
        storeLogger.error("Segmentation error:", err);
        return null;
      }
    },
    /**
     * Segment source image with multiple positive/negative points.
     *
     * @param foregroundPoints - Points to include in selection
     * @param backgroundPoints - Points to exclude from selection
     * @param options - Additional options
     */
    async segmentToLayerByMultiplePoints(foregroundPoints, backgroundPoints = [], options = {}) {
      const sourceImage = this.sourceImage;
      if (!sourceImage) {
        storeLogger.error("No source image available for segmentation");
        return null;
      }
      try {
        const result = await segmentByMultiplePoints(
          sourceImage,
          foregroundPoints,
          backgroundPoints,
          options.model || "sam2"
        );
        if (result.status !== "success" || !result.masks || result.masks.length === 0) {
          storeLogger.error("Segmentation failed:", result.message);
          return null;
        }
        const mask = result.masks[0];
        return this._createLayerFromMask(sourceImage, mask, options.layerName, options.positionAtCenter);
      } catch (err) {
        storeLogger.error("Segmentation error:", err);
        return null;
      }
    },
    /**
     * Auto-segment all objects in the source image and create layers.
     *
     * @param options - Segmentation options
     * @returns Promise resolving to array of created layers
     */
    async autoSegmentToLayers(options = {}) {
      const sourceImage = this.sourceImage;
      if (!sourceImage) {
        storeLogger.error("No source image available for segmentation");
        return [];
      }
      try {
        const result = await autoSegment(sourceImage, {
          model: options.model || "sam2",
          minArea: options.minArea || 1e3,
          maxMasks: options.maxMasks || 10
        });
        if (result.status !== "success" || !result.masks || result.masks.length === 0) {
          storeLogger.error("Auto-segmentation failed:", result.message);
          return [];
        }
        const layers = [];
        const prefix = options.namePrefix || "Segment";
        for (let i = 0; i < result.masks.length; i++) {
          const mask = result.masks[i];
          const layer = await this._createLayerFromMask(
            sourceImage,
            mask,
            `${prefix} ${i + 1}`,
            false
            // Don't center - preserve original position
          );
          if (layer) {
            layers.push(layer);
          }
        }
        return layers;
      } catch (err) {
        storeLogger.error("Auto-segmentation error:", err);
        return [];
      }
    },
    /**
     * Internal: Create an image layer from a segmentation mask
     */
    async _createLayerFromMask(sourceImageBase64, mask, name, positionAtCenter = false) {
      try {
        const maskedImageBase64 = await applyMaskToImage(
          sourceImageBase64,
          mask.mask,
          mask.bounds
        );
        const assetId = `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const asset = {
          id: assetId,
          type: "image",
          source: "generated",
          width: mask.bounds.width,
          height: mask.bounds.height,
          data: maskedImageBase64
        };
        this.project.assets[assetId] = asset;
        const layer = this.createLayer("image", name || "Segmented");
        const imageData = {
          assetId,
          fit: "none",
          // Don't scale - use original size
          sourceType: "segmented"
        };
        layer.data = imageData;
        if (positionAtCenter) {
          layer.transform.position.value = {
            x: this.project.composition.width / 2,
            y: this.project.composition.height / 2
          };
        } else {
          layer.transform.position.value = {
            x: mask.bounds.x + mask.bounds.width / 2,
            y: mask.bounds.y + mask.bounds.height / 2
          };
        }
        layer.transform.anchorPoint.value = {
          x: mask.bounds.width / 2,
          y: mask.bounds.height / 2
        };
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
        this.pushHistory();
        storeLogger.info(`Created segmented layer: ${layer.name} (${mask.bounds.width}x${mask.bounds.height})`);
        return layer;
      } catch (err) {
        storeLogger.error("Failed to create layer from mask:", err);
        return null;
      }
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(layerId, effectKey) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return;
      const effect = createEffectInstance(effectKey);
      if (!effect) return;
      if (!layer.effects) {
        layer.effects = [];
      }
      layer.effects.push(effect);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(layerId, effectId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return;
      const index = layer.effects.findIndex((e) => e.id === effectId);
      if (index >= 0) {
        layer.effects.splice(index, 1);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
        this.pushHistory();
      }
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(layerId, effectId, paramKey, value) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return;
      const effect = layer.effects.find((e) => e.id === effectId);
      if (!effect || !effect.parameters[paramKey]) return;
      effect.parameters[paramKey].value = value;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(layerId, effectId, paramKey, animated) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return;
      const effect = layer.effects.find((e) => e.id === effectId);
      if (!effect || !effect.parameters[paramKey]) return;
      const param = effect.parameters[paramKey];
      param.animated = animated;
      if (animated && (!param.keyframes || param.keyframes.length === 0)) {
        param.keyframes = [{
          id: `kf_${Date.now()}`,
          frame: this.currentFrame,
          value: param.value,
          interpolation: "linear",
          inHandle: { frame: -5, value: 0, enabled: false },
          outHandle: { frame: 5, value: 0, enabled: false },
          controlMode: "smooth"
        }];
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(layerId, effectId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return;
      const effect = layer.effects.find((e) => e.id === effectId);
      if (!effect) return;
      effect.enabled = !effect.enabled;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(layerId, fromIndex, toIndex) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return;
      if (fromIndex < 0 || fromIndex >= layer.effects.length) return;
      if (toIndex < 0 || toIndex >= layer.effects.length) return;
      const [effect] = layer.effects.splice(fromIndex, 1);
      layer.effects.splice(toIndex, 0, effect);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(layerId, effectId, paramKey, frame) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || !layer.effects) return null;
      const effect = layer.effects.find((e) => e.id === effectId);
      if (!effect || !effect.parameters[paramKey]) return null;
      const param = effect.parameters[paramKey];
      const targetFrame = frame ?? (this.getActiveComp()?.currentFrame ?? 0);
      if (param.animated && param.keyframes.length > 0) {
        return interpolateProperty(param, targetFrame);
      }
      return param.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(name) {
      const comp = this.getActiveComp();
      const layers = this.getActiveCompLayers();
      const cameraId = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const cameraName = name || `Camera ${this.cameras.size + 1}`;
      const camera = createDefaultCamera(
        cameraId,
        comp?.settings.width || 1024,
        comp?.settings.height || 1024
      );
      camera.name = cameraName;
      this.cameras.set(cameraId, camera);
      if (!this.activeCameraId) {
        this.activeCameraId = cameraId;
      }
      const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const layer = {
        id: layerId,
        name: cameraName,
        type: "camera",
        visible: true,
        locked: false,
        solo: false,
        threeD: true,
        // Cameras are always 3D
        motionBlur: false,
        inPoint: 0,
        outPoint: (comp?.settings.frameCount || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: createAnimatableProperty("opacity", 100, "number"),
        transform: createDefaultTransform(),
        properties: [],
        effects: [],
        data: {
          cameraId,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === cameraId
        }
      };
      layers.unshift(layer);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      this.selectLayer(layerId);
      return { camera, layer };
    },
    /**
     * Get a camera by ID
     */
    getCamera(cameraId) {
      return this.cameras.get(cameraId) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(cameraId, updates) {
      const camera = this.cameras.get(cameraId);
      if (!camera) return;
      Object.assign(camera, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set the active camera
     */
    setActiveCamera(cameraId) {
      if (!this.cameras.has(cameraId)) return;
      this.activeCameraId = cameraId;
      const layers = this.getActiveCompLayers();
      for (const layer of layers) {
        if (layer.type === "camera" && layer.data) {
          const cameraData = layer.data;
          cameraData.isActiveCamera = cameraData.cameraId === cameraId;
        }
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(cameraId) {
      const layers = this.getActiveCompLayers();
      const layerIndex = layers.findIndex(
        (l) => l.type === "camera" && l.data?.cameraId === cameraId
      );
      if (layerIndex !== -1) {
        const layerId = layers[layerIndex].id;
        layers.splice(layerIndex, 1);
        this.selectedLayerIds = this.selectedLayerIds.filter((id) => id !== layerId);
      }
      this.cameras.delete(cameraId);
      if (this.activeCameraId === cameraId) {
        const remaining = Array.from(this.cameras.keys());
        this.activeCameraId = remaining.length > 0 ? remaining[0] : null;
        if (this.activeCameraId) {
          this.setActiveCamera(this.activeCameraId);
        }
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(cameraId) {
      return this.cameraKeyframes.get(cameraId) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(cameraId, keyframe) {
      let keyframes = this.cameraKeyframes.get(cameraId);
      if (!keyframes) {
        keyframes = [];
        this.cameraKeyframes.set(cameraId, keyframes);
      }
      const existingIndex = keyframes.findIndex((k) => k.frame === keyframe.frame);
      if (existingIndex >= 0) {
        keyframes[existingIndex] = keyframe;
      } else {
        keyframes.push(keyframe);
        keyframes.sort((a, b) => a.frame - b.frame);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(cameraId, frame) {
      const keyframes = this.cameraKeyframes.get(cameraId);
      if (!keyframes) return;
      const index = keyframes.findIndex((k) => k.frame === frame);
      if (index >= 0) {
        keyframes.splice(index, 1);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(cameraId, frame) {
      const camera = this.cameras.get(cameraId);
      if (!camera) return null;
      const keyframes = this.cameraKeyframes.get(cameraId);
      if (!keyframes || keyframes.length === 0) {
        return camera;
      }
      const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
      return {
        ...camera,
        position: interpolated.position,
        orientation: interpolated.rotation,
        focalLength: interpolated.focalLength,
        zoom: interpolated.zoom,
        depthOfField: {
          ...camera.depthOfField,
          focusDistance: interpolated.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(frame) {
      if (!this.activeCameraId) return null;
      return this.getCameraAtFrame(this.activeCameraId, frame ?? this.currentFrame);
    },
    /**
     * Update viewport state
     */
    updateViewportState(updates) {
      Object.assign(this.viewportState, updates);
    },
    /**
     * Update view options
     */
    updateViewOptions(updates) {
      Object.assign(this.viewOptions, updates);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(file) {
      this.audioFile = file;
      this.audioBuffer = null;
      this.audioAnalysis = null;
      this.audioLoadingState = "decoding";
      this.audioLoadingProgress = 0;
      this.audioLoadingPhase = "Preparing...";
      this.audioLoadingError = null;
      try {
        const result = await loadAndAnalyzeAudio(
          file,
          this.project.composition.fps,
          {
            onProgress: (progress) => {
              if (progress.phase === "decoding") {
                this.audioLoadingState = "decoding";
              } else {
                this.audioLoadingState = "analyzing";
              }
              this.audioLoadingProgress = progress.progress;
              this.audioLoadingPhase = progress.message;
            }
          }
        );
        this.audioBuffer = result.buffer;
        this.audioAnalysis = result.analysis;
        this.audioLoadingState = "complete";
        this.audioLoadingProgress = 1;
        this.audioLoadingPhase = "Complete";
        this.initializeAudioReactiveMapper();
        if (this.propertyDriverSystem && this.audioAnalysis) {
          this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
        }
        storeLogger.debug("Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (error) {
        storeLogger.error("Failed to load audio:", error);
        this.audioFile = null;
        this.audioBuffer = null;
        this.audioAnalysis = null;
        this.audioReactiveMapper = null;
        this.audioLoadingState = "error";
        this.audioLoadingError = error.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      cancelAnalysis();
      this.audioLoadingState = "idle";
      this.audioLoadingProgress = 0;
      this.audioLoadingPhase = "";
      this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad();
      this.audioFile = null;
      this.audioBuffer = null;
      this.audioAnalysis = null;
      this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(feature, frame) {
      if (!this.audioAnalysis) return 0;
      return getFeatureAtFrame(this.audioAnalysis, feature, frame ?? (this.getActiveComp()?.currentFrame ?? 0));
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(layerId, mapping) {
      const existing = this.audioMappings.get(layerId) || [];
      existing.push(mapping);
      this.audioMappings.set(layerId, existing);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(layerId, index) {
      const mappings = this.audioMappings.get(layerId);
      if (mappings) {
        mappings.splice(index, 1);
        if (mappings.length === 0) {
          this.audioMappings.delete(layerId);
        }
      }
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(layerId) {
      return this.audioMappings.get(layerId) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(peakData) {
      this.peakData = peakData;
      if (this.audioReactiveMapper) {
        this.audioReactiveMapper.setPeakData(peakData);
      }
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(config) {
      if (!this.audioAnalysis) return null;
      const weights = this.audioAnalysis.amplitudeEnvelope;
      const peakData = detectPeaks(weights, config);
      this.peakData = peakData;
      if (this.audioReactiveMapper) {
        this.audioReactiveMapper.setPeakData(peakData);
      }
      return peakData;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(mapping) {
      this.audioReactiveMappings.push(mapping);
      if (this.audioReactiveMapper) {
        this.audioReactiveMapper.addMapping(mapping);
      }
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(mappingId) {
      const index = this.audioReactiveMappings.findIndex((m) => m.id === mappingId);
      if (index >= 0) {
        this.audioReactiveMappings.splice(index, 1);
      }
      if (this.audioReactiveMapper) {
        this.audioReactiveMapper.removeMapping(mappingId);
      }
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(mappingId, updates) {
      const mapping = this.audioReactiveMappings.find((m) => m.id === mappingId);
      if (mapping) {
        Object.assign(mapping, updates);
      }
      if (this.audioReactiveMapper) {
        this.audioReactiveMapper.updateMapping(mappingId, updates);
      }
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(mappingId, frame) {
      if (!this.audioReactiveMapper) return 0;
      return this.audioReactiveMapper.getValueAtFrame(mappingId, frame);
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(frame) {
      if (!this.audioReactiveMapper) return /* @__PURE__ */ new Map();
      return this.audioReactiveMapper.getAllValuesAtFrame(frame ?? (this.getActiveComp()?.currentFrame ?? 0));
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(layerId) {
      return this.audioReactiveMappings.filter(
        (m) => m.enabled && (m.targetLayerId === layerId || m.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(layerId, frame) {
      if (!this.audioReactiveMapper) return /* @__PURE__ */ new Map();
      return this.audioReactiveMapper.getValuesForLayerAtFrame(layerId, frame);
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      if (!this.audioAnalysis) return false;
      return isBeatAtFrame(this.audioAnalysis, this.getActiveComp()?.currentFrame ?? 0);
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(frame, pixelsPerFrame, selectedLayerId) {
      return findNearestSnap(frame, this.snapConfig, pixelsPerFrame, {
        layers: this.layers,
        selectedLayerId,
        currentFrame: this.getActiveComp()?.currentFrame ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return getBeatFrames(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return getPeakFrames(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(config) {
      this.snapConfig = { ...this.snapConfig, ...config };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(type) {
      const typeMap = {
        "grid": "snapToGrid",
        "keyframes": "snapToKeyframes",
        "beats": "snapToBeats",
        "peaks": "snapToPeaks",
        "layerBounds": "snapToLayerBounds",
        "playhead": "snapToPlayhead"
      };
      const key = typeMap[type];
      if (key && typeof this.snapConfig[key] === "boolean") {
        this.snapConfig[key] = !this.snapConfig[key];
      }
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(layerId, config = {}) {
      const animator = new AudioPathAnimator(config);
      this.pathAnimators.set(layerId, animator);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(layerId, pathData) {
      const animator = this.pathAnimators.get(layerId);
      if (animator) {
        animator.setPath(pathData);
      }
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(layerId, config) {
      const animator = this.pathAnimators.get(layerId);
      if (animator) {
        animator.setConfig(config);
      }
    },
    /**
     * Remove path animator
     */
    removePathAnimator(layerId) {
      this.pathAnimators.delete(layerId);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(layerId) {
      return this.pathAnimators.get(layerId);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      if (!this.audioAnalysis) return;
      const frame = this.getActiveComp()?.currentFrame ?? 0;
      const amplitude = getFeatureAtFrame(this.audioAnalysis, "amplitude", frame);
      const isBeat = isBeatAtFrame(this.audioAnalysis, frame);
      for (const [_layerId, animator] of this.pathAnimators) {
        animator.update(amplitude, isBeat);
      }
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const animator of this.pathAnimators.values()) {
        animator.reset();
      }
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (!this.audioAnalysis) return;
      this.audioReactiveMapper = new AudioReactiveMapper(this.audioAnalysis);
      for (const mapping of this.audioReactiveMappings) {
        this.audioReactiveMapper.addMapping(mapping);
      }
      if (this.peakData) {
        this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new PropertyDriverSystem();
      this.propertyDriverSystem.setPropertyGetter((layerId, propertyPath, frame) => {
        return this.getPropertyValueAtFrame(layerId, propertyPath, frame);
      });
      if (this.audioAnalysis) {
        this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      }
      for (const driver of this.propertyDrivers) {
        this.propertyDriverSystem.addDriver(driver);
      }
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(layerId, propertyPath, frame) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return null;
      const parts = propertyPath.split(".");
      if (parts[0] === "transform") {
        const t = layer.transform;
        if (parts[1] === "position") {
          const pos = interpolateProperty(t.position, frame);
          if (parts[2] === "x") return pos.x;
          if (parts[2] === "y") return pos.y;
          if (parts[2] === "z") return pos.z ?? 0;
        }
        if (parts[1] === "anchorPoint") {
          const anchor = interpolateProperty(t.anchorPoint, frame);
          if (parts[2] === "x") return anchor.x;
          if (parts[2] === "y") return anchor.y;
          if (parts[2] === "z") return anchor.z ?? 0;
        }
        if (parts[1] === "scale") {
          const scale = interpolateProperty(t.scale, frame);
          if (parts[2] === "x") return scale.x;
          if (parts[2] === "y") return scale.y;
          if (parts[2] === "z") return scale.z ?? 100;
        }
        if (parts[1] === "rotation") {
          return interpolateProperty(t.rotation, frame);
        }
        if (parts[1] === "rotationX" && t.rotationX) {
          return interpolateProperty(t.rotationX, frame);
        }
        if (parts[1] === "rotationY" && t.rotationY) {
          return interpolateProperty(t.rotationY, frame);
        }
        if (parts[1] === "rotationZ" && t.rotationZ) {
          return interpolateProperty(t.rotationZ, frame);
        }
      }
      if (parts[0] === "opacity") {
        return interpolateProperty(layer.opacity, frame);
      }
      return null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(layerId) {
      if (!this.propertyDriverSystem) {
        return /* @__PURE__ */ new Map();
      }
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return /* @__PURE__ */ new Map();
      const baseValues = /* @__PURE__ */ new Map();
      const frame = this.getActiveComp()?.currentFrame ?? 0;
      const pos = interpolateProperty(layer.transform.position, frame);
      baseValues.set("transform.position.x", pos.x);
      baseValues.set("transform.position.y", pos.y);
      baseValues.set("transform.position.z", pos.z ?? 0);
      const anchor = interpolateProperty(layer.transform.anchorPoint, frame);
      baseValues.set("transform.anchorPoint.x", anchor.x);
      baseValues.set("transform.anchorPoint.y", anchor.y);
      baseValues.set("transform.anchorPoint.z", anchor.z ?? 0);
      const scale = interpolateProperty(layer.transform.scale, frame);
      baseValues.set("transform.scale.x", scale.x);
      baseValues.set("transform.scale.y", scale.y);
      baseValues.set("transform.scale.z", scale.z ?? 100);
      baseValues.set("transform.rotation", interpolateProperty(layer.transform.rotation, frame));
      if (layer.transform.rotationX) {
        baseValues.set("transform.rotationX", interpolateProperty(layer.transform.rotationX, frame));
      }
      if (layer.transform.rotationY) {
        baseValues.set("transform.rotationY", interpolateProperty(layer.transform.rotationY, frame));
      }
      if (layer.transform.rotationZ) {
        baseValues.set("transform.rotationZ", interpolateProperty(layer.transform.rotationZ, frame));
      }
      baseValues.set("opacity", interpolateProperty(layer.opacity, frame));
      return this.propertyDriverSystem.evaluateLayerDrivers(layerId, frame, baseValues);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(driver) {
      if (this.propertyDriverSystem) {
        const added = this.propertyDriverSystem.addDriver(driver);
        if (!added) {
          storeLogger.warn("Cannot add property driver: would create circular dependency");
          return false;
        }
      }
      this.propertyDrivers.push(driver);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return true;
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
      const driver = createAudioDriver(targetLayerId, targetProperty, audioFeature, options);
      this.addPropertyDriver(driver);
      return driver;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
      const driver = createPropertyLink(
        targetLayerId,
        targetProperty,
        sourceLayerId,
        sourceProperty,
        options
      );
      const success = this.addPropertyDriver(driver);
      if (!success) {
        return null;
      }
      return driver;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(driverId) {
      const index = this.propertyDrivers.findIndex((d) => d.id === driverId);
      if (index >= 0) {
        this.propertyDrivers.splice(index, 1);
      }
      if (this.propertyDriverSystem) {
        this.propertyDriverSystem.removeDriver(driverId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(driverId, updates) {
      const driver = this.propertyDrivers.find((d) => d.id === driverId);
      if (driver) {
        Object.assign(driver, updates);
      }
      if (this.propertyDriverSystem) {
        this.propertyDriverSystem.updateDriver(driverId, updates);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(layerId) {
      return this.propertyDrivers.filter((d) => d.targetLayerId === layerId);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(driverId) {
      const driver = this.propertyDrivers.find((d) => d.id === driverId);
      if (driver) {
        driver.enabled = !driver.enabled;
        if (this.propertyDriverSystem) {
          this.propertyDriverSystem.updateDriver(driverId, { enabled: driver.enabled });
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    // ============================================================
    // PARTICLE SIMULATION ACTIONS
    // ============================================================
    /**
     * Reset a particle layer's simulation
     * Called when particle configuration changes
     */
    resetParticleSimulation(layerId) {
      particleSimulationRegistry.resetLayer(layerId);
      storeLogger.debug("Reset particle simulation for layer:", layerId);
    },
    /**
     * Clear all particle simulations
     * Called on project load/new
     */
    clearAllParticleSimulations() {
      particleSimulationRegistry.clear();
      storeLogger.debug("Cleared all particle simulations");
    },
    /**
     * Get particle snapshot for a layer at a specific frame
     * Evaluates the frame state to get the deterministic snapshot
     */
    getParticleSnapshot(layerId, frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots[layerId] ?? null;
    },
    /**
     * Get all particle snapshots from current frame
     */
    getAllParticleSnapshots(frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots;
    },
    // ============================================================
    // AUTOSAVE ACTIONS
    // ============================================================
    /**
     * Enable autosave with optional interval
     * @param intervalMs - Autosave interval in milliseconds (default: 60000)
     */
    enableAutosave(intervalMs) {
      if (intervalMs) {
        this.autosaveIntervalMs = intervalMs;
      }
      this.autosaveEnabled = true;
      this.startAutosaveTimer();
      storeLogger.info("Autosave enabled, interval:", this.autosaveIntervalMs, "ms");
    },
    /**
     * Disable autosave
     */
    disableAutosave() {
      this.autosaveEnabled = false;
      this.stopAutosaveTimer();
      storeLogger.info("Autosave disabled");
    },
    /**
     * Start the autosave timer
     */
    startAutosaveTimer() {
      this.stopAutosaveTimer();
      if (!this.autosaveEnabled) return;
      this.autosaveTimerId = window.setInterval(() => {
        if (this.hasUnsavedChanges) {
          this.performAutosave();
        }
      }, this.autosaveIntervalMs);
    },
    /**
     * Stop the autosave timer
     */
    stopAutosaveTimer() {
      if (this.autosaveTimerId !== null) {
        clearInterval(this.autosaveTimerId);
        this.autosaveTimerId = null;
      }
    },
    /**
     * Perform an autosave
     */
    async performAutosave() {
      if (!this.hasUnsavedChanges) return;
      try {
        const existingProjectId = this.lastSaveProjectId || void 0;
        const result = await saveProject(this.project, existingProjectId);
        if (result.status === "success" && result.project_id) {
          this.lastSaveProjectId = result.project_id;
          this.lastSaveTime = Date.now();
          this.hasUnsavedChanges = false;
          storeLogger.info("Autosaved project:", result.project_id);
        } else {
          storeLogger.error("Autosave failed:", result.message);
        }
      } catch (error) {
        storeLogger.error("Autosave failed:", error);
      }
    },
    /**
     * Mark the project as having unsaved changes
     * Called automatically when project state changes
     */
    markUnsavedChanges() {
      this.hasUnsavedChanges = true;
      this.invalidateFrameCache();
    },
    /**
     * Manual save to backend
     */
    async saveProjectToBackend() {
      try {
        const result = await saveProject(this.project, this.lastSaveProjectId || void 0);
        if (result.status === "success" && result.project_id) {
          this.lastSaveProjectId = result.project_id;
          this.lastSaveTime = Date.now();
          this.hasUnsavedChanges = false;
          storeLogger.info("Saved project:", result.project_id);
          return result.project_id;
        } else {
          throw new Error(result.message || "Save failed");
        }
      } catch (error) {
        storeLogger.error("Save failed:", error);
        throw error;
      }
    },
    /**
     * Load project from backend
     */
    async loadProjectFromBackend(projectId) {
      try {
        const result = await loadProject(projectId);
        if (result.status === "success" && result.project) {
          this.project = result.project;
          this.pushHistory();
          this.lastSaveProjectId = projectId;
          this.lastSaveTime = Date.now();
          this.hasUnsavedChanges = false;
          storeLogger.info("Loaded project:", projectId);
        } else {
          throw new Error(result.message || "Load failed");
        }
      } catch (error) {
        storeLogger.error("Load failed:", error);
        throw error;
      }
    },
    /**
     * List available projects from backend
     */
    async listSavedProjects() {
      try {
        const result = await listProjects();
        if (result.status === "success" && result.projects) {
          return result.projects;
        } else {
          storeLogger.error("List projects failed:", result.message);
          return [];
        }
      } catch (error) {
        storeLogger.error("List projects failed:", error);
        return [];
      }
    },
    // ============================================================
    // FRAME CACHE ACTIONS
    // ============================================================
    /**
     * Initialize the frame cache
     * Should be called on app startup
     */
    async initializeFrameCache() {
      if (this.frameCacheEnabled) {
        await initializeFrameCache();
        storeLogger.info("Frame cache initialized");
      }
    },
    /**
     * Enable or disable frame caching
     */
    setFrameCacheEnabled(enabled) {
      this.frameCacheEnabled = enabled;
      if (!enabled) {
        this.clearFrameCache();
      }
      storeLogger.info("Frame cache", enabled ? "enabled" : "disabled");
    },
    /**
     * Get frame from cache or null if not cached
     */
    getCachedFrame(frame) {
      if (!this.frameCacheEnabled) return null;
      const cache = getFrameCache();
      return cache.get(frame, this.activeCompositionId, this.projectStateHash);
    },
    /**
     * Cache a rendered frame
     */
    async cacheFrame(frame, imageData) {
      if (!this.frameCacheEnabled) return;
      const cache = getFrameCache();
      await cache.set(frame, this.activeCompositionId, imageData, this.projectStateHash);
    },
    /**
     * Check if a frame is cached
     */
    isFrameCached(frame) {
      if (!this.frameCacheEnabled) return false;
      const cache = getFrameCache();
      return cache.has(frame, this.activeCompositionId);
    },
    /**
     * Start pre-caching frames around current position
     */
    async startPreCache(currentFrame, direction = "both") {
      if (!this.frameCacheEnabled) return;
      const cache = getFrameCache();
      await cache.startPreCache(currentFrame, this.activeCompositionId, this.projectStateHash, direction);
    },
    /**
     * Invalidate frame cache (called when project changes)
     */
    invalidateFrameCache() {
      this.projectStateHash = this.computeProjectHash();
      const cache = getFrameCache();
      cache.invalidate(this.activeCompositionId, this.projectStateHash);
    },
    /**
     * Clear all cached frames
     */
    clearFrameCache() {
      const cache = getFrameCache();
      cache.clear();
      storeLogger.info("Frame cache cleared");
    },
    /**
     * Get frame cache statistics
     */
    getFrameCacheStats() {
      const cache = getFrameCache();
      return cache.getStats();
    },
    /**
     * Compute a hash of the project state for cache invalidation
     * Uses a simplified hash of key state that affects rendering
     */
    computeProjectHash() {
      const comp = this.project.compositions[this.activeCompositionId];
      if (!comp) return "";
      const fingerprint = {
        layerCount: comp.layers.length,
        layerIds: comp.layers.map((l) => l.id).join(","),
        modified: this.project.meta.modified,
        settings: comp.settings
      };
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash.toString(16);
    }
  }
});

const _hoisted_1$x = { class: "project-panel" };
const _hoisted_2$w = { class: "panel-header" };
const _hoisted_3$u = { class: "header-actions" };
const _hoisted_4$t = { class: "dropdown-container" };
const _hoisted_5$t = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_6$t = {
  key: 0,
  class: "search-bar"
};
const _hoisted_7$t = { class: "panel-content" };
const _hoisted_8$r = { class: "folder-tree" };
const _hoisted_9$q = ["onClick", "onDblclick"];
const _hoisted_10$q = ["onClick"];
const _hoisted_11$p = { class: "folder-name" };
const _hoisted_12$n = { class: "item-count" };
const _hoisted_13$m = {
  key: 0,
  class: "folder-contents"
};
const _hoisted_14$l = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_15$l = { class: "item-icon" };
const _hoisted_16$l = { class: "item-name" };
const _hoisted_17$l = { class: "item-info" };
const _hoisted_18$l = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_19$j = { class: "item-icon" };
const _hoisted_20$j = { class: "item-name" };
const _hoisted_21$i = { class: "item-info" };
const _hoisted_22$h = {
  key: 0,
  class: "empty-state"
};
const _hoisted_23$h = {
  key: 1,
  class: "panel-footer"
};
const _hoisted_24$f = { class: "item-details" };
const _hoisted_25$f = { class: "detail-label" };
const _hoisted_26$f = { class: "detail-info" };
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const fileInputRef = ref(null);
    const showSearch = ref(false);
    const showNewMenu = ref(false);
    const searchQuery = ref("");
    const selectedItem = ref(null);
    const expandedFolders = ref(["compositions", "footage"]);
    const folders = ref([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]);
    const items = ref([]);
    const filteredFolders = computed(() => {
      if (!searchQuery.value) return folders.value;
      const query = searchQuery.value.toLowerCase();
      return folders.value.map((folder) => ({
        ...folder,
        items: folder.items.filter(
          (item) => item.name.toLowerCase().includes(query)
        )
      })).filter((folder) => folder.items.length > 0 || folder.name.toLowerCase().includes(query));
    });
    const filteredRootItems = computed(() => {
      if (!searchQuery.value) return items.value;
      const query = searchQuery.value.toLowerCase();
      return items.value.filter(
        (item) => item.name.toLowerCase().includes(query)
      );
    });
    const selectedItemDetails = computed(() => {
      if (!selectedItem.value) return null;
      for (const folder of folders.value) {
        const item2 = folder.items.find((i) => i.id === selectedItem.value);
        if (item2) {
          return {
            name: item2.name,
            info: getItemInfo(item2)
          };
        }
      }
      const item = items.value.find((i) => i.id === selectedItem.value);
      if (item) {
        return {
          name: item.name,
          info: getItemInfo(item)
        };
      }
      return null;
    });
    function toggleFolder(folderId) {
      const index = expandedFolders.value.indexOf(folderId);
      if (index >= 0) {
        expandedFolders.value.splice(index, 1);
      } else {
        expandedFolders.value.push(folderId);
      }
    }
    function selectItem(itemId) {
      selectedItem.value = itemId;
    }
    function openItem(item) {
      if (item.type === "composition") {
        console.log("Opening composition:", item.name);
      }
    }
    function createNewComposition() {
      showNewMenu.value = false;
      emit("openCompositionSettings");
    }
    function createNewSolid() {
      showNewMenu.value = false;
      const layer = store.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", layer.id);
    }
    function createNewText() {
      showNewMenu.value = false;
      const layer = store.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", layer.id);
    }
    function createNewNull() {
      showNewMenu.value = false;
      const layer = store.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", layer.id);
    }
    function createNewSpline() {
      showNewMenu.value = false;
      const layer = store.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", layer.id);
    }
    function triggerFileImport() {
      fileInputRef.value?.click();
    }
    async function handleFileImport(event) {
      const input = event.target;
      const files = input.files;
      if (!files || files.length === 0) return;
      for (const file of Array.from(files)) {
        const type = getFileType(file);
        const newItem = {
          id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: file.name,
          type
        };
        if (type === "audio") {
          store.loadAudio(file);
        } else if (file.type.startsWith("video/")) {
          try {
            const layer = await store.createVideoLayer(file, true);
            newItem.id = layer.id;
            newItem.width = store.width;
            newItem.height = store.height;
            newItem.duration = store.frameCount;
            newItem.fps = store.fps;
            console.log("[ProjectPanel] Video layer created:", layer.id, layer.name);
          } catch (error) {
            console.error("[ProjectPanel] Failed to import video:", error);
            continue;
          }
        } else if (file.type.startsWith("image/")) {
          const imageUrl = URL.createObjectURL(file);
          const assetId = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          store.project.assets[assetId] = {
            id: assetId,
            type: "image",
            source: "file",
            width: 0,
            // Will be updated when image loads
            height: 0,
            data: imageUrl
          };
          const layer = store.createLayer("image", file.name.replace(/\.[^.]+$/, ""));
          layer.data = { assetId };
          newItem.id = layer.id;
        }
        const folder = folders.value.find((f) => f.id === "footage");
        if (folder) {
          folder.items.push(newItem);
        } else {
          items.value.push(newItem);
        }
        console.log("[ProjectPanel] Imported:", file.name, type);
      }
      input.value = "";
    }
    function getFileType(file) {
      const mime = file.type;
      if (mime.startsWith("audio/")) return "audio";
      if (mime.startsWith("video/")) return "footage";
      if (mime.startsWith("image/")) return "footage";
      return "footage";
    }
    function getItemIcon(type) {
      const icons = {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      };
      return icons[type] || "";
    }
    function getItemInfo(item) {
      if (item.type === "composition" || item.type === "footage") {
        const parts = [];
        if (item.width && item.height) {
          parts.push(`${item.width}${item.height}`);
        }
        if (item.fps) {
          parts.push(`${item.fps}fps`);
        }
        if (item.duration) {
          const seconds = item.duration / (item.fps || 30);
          parts.push(`${seconds.toFixed(1)}s`);
        }
        return parts.join("  ");
      }
      return "";
    }
    function onDragStart(item, event) {
      event.dataTransfer?.setData("application/project-item", JSON.stringify(item));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", _hoisted_2$w, [
          _cache[3] || (_cache[3] = createBaseVNode("span", { class: "panel-title" }, "Project", -1)),
          createBaseVNode("div", _hoisted_3$u, [
            createBaseVNode("button", {
              onClick: triggerFileImport,
              title: "Import File (Ctrl+I)"
            }, ""),
            createBaseVNode("div", _hoisted_4$t, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => showNewMenu.value = !showNewMenu.value),
                title: "New Item"
              }, "+"),
              showNewMenu.value ? (openBlock(), createElementBlock("div", _hoisted_5$t, [
                createBaseVNode("button", { onClick: createNewComposition }, " New Composition"),
                createBaseVNode("button", { onClick: createNewSolid }, " New Solid"),
                createBaseVNode("button", { onClick: createNewText }, "T New Text"),
                createBaseVNode("button", { onClick: createNewNull }, " New Null"),
                createBaseVNode("button", { onClick: createNewSpline }, " New Spline")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showSearch.value = !showSearch.value),
              title: "Search"
            }, "")
          ])
        ]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          multiple: "",
          accept: "image/*,video/*,audio/*,.json",
          style: { "display": "none" },
          onChange: handleFileImport
        }, null, 544),
        showSearch.value ? (openBlock(), createElementBlock("div", _hoisted_6$t, [
          withDirectives(createBaseVNode("input", {
            type: "text",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchQuery.value = $event),
            placeholder: "Search project...",
            class: "search-input"
          }, null, 512), [
            [vModelText, searchQuery.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_7$t, [
          createBaseVNode("div", _hoisted_8$r, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredFolders.value, (folder) => {
              return openBlock(), createElementBlock("div", {
                key: folder.id,
                class: "folder-item"
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["folder-header", { selected: selectedItem.value === folder.id }]),
                  onClick: ($event) => selectItem(folder.id),
                  onDblclick: ($event) => toggleFolder(folder.id)
                }, [
                  createBaseVNode("span", {
                    class: "expand-icon",
                    onClick: withModifiers(($event) => toggleFolder(folder.id), ["stop"])
                  }, toDisplayString(expandedFolders.value.includes(folder.id) ? "" : ""), 9, _hoisted_10$q),
                  _cache[4] || (_cache[4] = createBaseVNode("span", { class: "folder-icon" }, "", -1)),
                  createBaseVNode("span", _hoisted_11$p, toDisplayString(folder.name), 1),
                  createBaseVNode("span", _hoisted_12$n, toDisplayString(folder.items.length), 1)
                ], 42, _hoisted_9$q),
                expandedFolders.value.includes(folder.id) ? (openBlock(), createElementBlock("div", _hoisted_13$m, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(folder.items, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.id,
                      class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                      onClick: ($event) => selectItem(item.id),
                      onDblclick: ($event) => openItem(item),
                      draggable: "true",
                      onDragstart: ($event) => onDragStart(item, $event)
                    }, [
                      createBaseVNode("span", _hoisted_15$l, toDisplayString(getItemIcon(item.type)), 1),
                      createBaseVNode("span", _hoisted_16$l, toDisplayString(item.name), 1),
                      createBaseVNode("span", _hoisted_17$l, toDisplayString(getItemInfo(item)), 1)
                    ], 42, _hoisted_14$l);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredRootItems.value, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.id,
                class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                onClick: ($event) => selectItem(item.id),
                onDblclick: ($event) => openItem(item),
                draggable: "true",
                onDragstart: ($event) => onDragStart(item, $event)
              }, [
                createBaseVNode("span", _hoisted_19$j, toDisplayString(getItemIcon(item.type)), 1),
                createBaseVNode("span", _hoisted_20$j, toDisplayString(item.name), 1),
                createBaseVNode("span", _hoisted_21$i, toDisplayString(getItemInfo(item)), 1)
              ], 42, _hoisted_18$l);
            }), 128))
          ]),
          items.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_22$h, [..._cache[5] || (_cache[5] = [
            createBaseVNode("p", null, "No items in project", -1),
            createBaseVNode("p", { class: "hint" }, "Import footage or create compositions", -1)
          ])])) : createCommentVNode("", true)
        ]),
        selectedItemDetails.value ? (openBlock(), createElementBlock("div", _hoisted_23$h, [
          createBaseVNode("div", _hoisted_24$f, [
            createBaseVNode("span", _hoisted_25$f, toDisplayString(selectedItemDetails.value.name), 1),
            createBaseVNode("span", _hoisted_26$f, toDisplayString(selectedItemDetails.value.info), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const ProjectPanel = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-8f208c83"]]);

const _hoisted_1$w = { class: "effects-panel" };
const _hoisted_2$v = { class: "panel-header" };
const _hoisted_3$t = { class: "header-actions" };
const _hoisted_4$s = { class: "panel-content" };
const _hoisted_5$s = { class: "tabs" };
const _hoisted_6$s = {
  key: 0,
  class: "effects-list"
};
const _hoisted_7$s = ["onClick"];
const _hoisted_8$q = { class: "expand-icon" };
const _hoisted_9$p = { class: "category-icon" };
const _hoisted_10$p = { class: "category-name" };
const _hoisted_11$o = { class: "effect-count" };
const _hoisted_12$m = {
  key: 0,
  class: "category-effects"
};
const _hoisted_13$l = ["onDblclick", "onDragstart"];
const _hoisted_14$k = { class: "effect-name" };
const _hoisted_15$k = ["onClick", "title"];
const _hoisted_16$k = {
  key: 1,
  class: "presets-list"
};
const _hoisted_17$k = ["onClick"];
const _hoisted_18$k = { class: "expand-icon" };
const _hoisted_19$i = { class: "category-name" };
const _hoisted_20$i = { class: "preset-count" };
const _hoisted_21$h = {
  key: 0,
  class: "category-presets"
};
const _hoisted_22$g = ["onDblclick", "onDragstart"];
const _hoisted_23$g = { class: "preset-info" };
const _hoisted_24$e = { class: "preset-name" };
const _hoisted_25$e = { class: "preset-description" };
const _hoisted_26$e = {
  key: 2,
  class: "favorites-list"
};
const _hoisted_27$d = {
  key: 0,
  class: "empty-favorites"
};
const _hoisted_28$d = ["onDblclick", "onDragstart"];
const _hoisted_29$d = { class: "category-badge" };
const _hoisted_30$d = { class: "effect-name" };
const _hoisted_31$a = ["onClick"];
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "EffectsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const activeTab = ref("effects");
    const searchQuery = ref("");
    const expandedCategories = ref(["blur-sharpen", "color-correction"]);
    const expandedPresetCategories = ref(["Fade", "Scale"]);
    const favorites = ref([]);
    onMounted(() => {
      const saved = localStorage.getItem("effect-favorites");
      if (saved) {
        try {
          favorites.value = JSON.parse(saved);
        } catch {
          favorites.value = [];
        }
      }
    });
    function saveFavorites() {
      localStorage.setItem("effect-favorites", JSON.stringify(favorites.value));
    }
    const allEffects = computed(() => {
      return Object.entries(EFFECT_DEFINITIONS).map(([key, def]) => ({
        key,
        name: def.name,
        category: def.category,
        description: def.description
      }));
    });
    const filteredCategories = computed(() => {
      const query = searchQuery.value.toLowerCase();
      return Object.entries(EFFECT_CATEGORIES).map(([key, cat]) => {
        const effects = allEffects.value.filter((e) => {
          if (e.category !== key) return false;
          if (query && !e.name.toLowerCase().includes(query)) return false;
          return true;
        });
        return {
          key,
          label: cat.label,
          icon: cat.icon,
          effects
        };
      }).filter((cat) => cat.effects.length > 0);
    });
    const groupedPresets = computed(() => {
      const query = searchQuery.value.toLowerCase();
      const groups = {};
      for (const preset of ANIMATION_PRESETS) {
        if (query && !preset.name.toLowerCase().includes(query)) continue;
        if (!groups[preset.category]) {
          groups[preset.category] = [];
        }
        groups[preset.category].push(preset);
      }
      return Object.entries(groups).map(([category, presets]) => ({
        category,
        presets
      }));
    });
    const favoriteEffects = computed(() => {
      return allEffects.value.filter((e) => favorites.value.includes(e.key));
    });
    function toggleCategory(category) {
      const index = expandedCategories.value.indexOf(category);
      if (index >= 0) {
        expandedCategories.value.splice(index, 1);
      } else {
        expandedCategories.value.push(category);
      }
    }
    function togglePresetCategory(category) {
      const index = expandedPresetCategories.value.indexOf(category);
      if (index >= 0) {
        expandedPresetCategories.value.splice(index, 1);
      } else {
        expandedPresetCategories.value.push(category);
      }
    }
    function toggleFavorite(effectKey) {
      const index = favorites.value.indexOf(effectKey);
      if (index >= 0) {
        favorites.value.splice(index, 1);
      } else {
        favorites.value.push(effectKey);
      }
      saveFavorites();
    }
    function getCategoryIcon(category) {
      return EFFECT_CATEGORIES[category]?.icon || "?";
    }
    function applyEffect(effectKey) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) {
        console.warn("No layer selected to apply effect");
        return;
      }
      store.addEffectToLayer(selectedLayer.id, effectKey);
    }
    function applyPreset(preset) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const startFrame = selectedLayer.inPoint;
      const endFrame = selectedLayer.outPoint;
      const duration = endFrame - startFrame;
      for (const propDef of preset.keyframes) {
        for (const kf of propDef.keyframes) {
          const frame = Math.round(startFrame + kf.time * duration);
          store.addKeyframe(selectedLayer.id, propDef.property, kf.value, frame);
        }
      }
    }
    function onDragStart(effectKey, event) {
      event.dataTransfer?.setData("application/effect", effectKey);
    }
    function onDragPreset(preset, event) {
      event.dataTransfer?.setData("application/preset", JSON.stringify(preset));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("div", _hoisted_2$v, [
          _cache[4] || (_cache[4] = createBaseVNode("span", { class: "panel-title" }, "Effects & Presets", -1)),
          createBaseVNode("div", _hoisted_3$t, [
            withDirectives(createBaseVNode("input", {
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              placeholder: "Search...",
              class: "search-input"
            }, null, 512), [
              [vModelText, searchQuery.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$s, [
          createBaseVNode("div", _hoisted_5$s, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "effects" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "effects")
            }, " Effects ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "presets" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "presets")
            }, " Presets ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "favorites" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "favorites")
            }, " Favorites ", 2)
          ]),
          activeTab.value === "effects" ? (openBlock(), createElementBlock("div", _hoisted_6$s, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
              return openBlock(), createElementBlock("div", {
                key: category.key,
                class: "effect-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => toggleCategory(category.key)
                }, [
                  createBaseVNode("span", _hoisted_8$q, toDisplayString(expandedCategories.value.includes(category.key) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_9$p, toDisplayString(category.icon), 1),
                  createBaseVNode("span", _hoisted_10$p, toDisplayString(category.label), 1),
                  createBaseVNode("span", _hoisted_11$o, toDisplayString(category.effects.length), 1)
                ], 8, _hoisted_7$s),
                expandedCategories.value.includes(category.key) ? (openBlock(), createElementBlock("div", _hoisted_12$m, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.effects, (effect) => {
                    return openBlock(), createElementBlock("div", {
                      key: effect.key,
                      class: normalizeClass(["effect-item", { favorite: favorites.value.includes(effect.key) }]),
                      onDblclick: ($event) => applyEffect(effect.key),
                      onDragstart: ($event) => onDragStart(effect.key, $event),
                      draggable: "true"
                    }, [
                      createBaseVNode("span", _hoisted_14$k, toDisplayString(effect.name), 1),
                      createBaseVNode("button", {
                        class: "favorite-btn",
                        onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"]),
                        title: favorites.value.includes(effect.key) ? "Remove from favorites" : "Add to favorites"
                      }, toDisplayString(favorites.value.includes(effect.key) ? "" : ""), 9, _hoisted_15$k)
                    ], 42, _hoisted_13$l);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "presets" ? (openBlock(), createElementBlock("div", _hoisted_16$k, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedPresets.value, (group) => {
              return openBlock(), createElementBlock("div", {
                key: group.category,
                class: "preset-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => togglePresetCategory(group.category)
                }, [
                  createBaseVNode("span", _hoisted_18$k, toDisplayString(expandedPresetCategories.value.includes(group.category) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_19$i, toDisplayString(group.category), 1),
                  createBaseVNode("span", _hoisted_20$i, toDisplayString(group.presets.length), 1)
                ], 8, _hoisted_17$k),
                expandedPresetCategories.value.includes(group.category) ? (openBlock(), createElementBlock("div", _hoisted_21$h, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(group.presets, (preset) => {
                    return openBlock(), createElementBlock("div", {
                      key: preset.id,
                      class: "preset-item",
                      onDblclick: ($event) => applyPreset(preset),
                      onDragstart: ($event) => onDragPreset(preset, $event),
                      draggable: "true"
                    }, [
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "preset-preview" }, [
                        createBaseVNode("span", { class: "preview-icon" }, "")
                      ], -1)),
                      createBaseVNode("div", _hoisted_23$g, [
                        createBaseVNode("span", _hoisted_24$e, toDisplayString(preset.name), 1),
                        createBaseVNode("span", _hoisted_25$e, toDisplayString(preset.description), 1)
                      ])
                    ], 40, _hoisted_22$g);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "favorites" ? (openBlock(), createElementBlock("div", _hoisted_26$e, [
            favoriteEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_27$d, [..._cache[6] || (_cache[6] = [
              createBaseVNode("p", null, "No favorites yet", -1),
              createBaseVNode("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
            ])])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(favoriteEffects.value, (effect) => {
              return openBlock(), createElementBlock("div", {
                key: effect.key,
                class: "effect-item",
                onDblclick: ($event) => applyEffect(effect.key),
                onDragstart: ($event) => onDragStart(effect.key, $event),
                draggable: "true"
              }, [
                createBaseVNode("span", _hoisted_29$d, toDisplayString(getCategoryIcon(effect.category)), 1),
                createBaseVNode("span", _hoisted_30$d, toDisplayString(effect.name), 1),
                createBaseVNode("button", {
                  class: "favorite-btn active",
                  onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"])
                }, "  ", 8, _hoisted_31$a)
              ], 40, _hoisted_28$d);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "panel-footer" }, [
          createBaseVNode("span", { class: "info-text" }, "Double-click or drag to apply")
        ], -1))
      ]);
    };
  }
});

const EffectsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-5e081b38"]]);

const _hoisted_1$v = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$u = {
  key: 1,
  class: "scrub-unit"
};
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -Infinity },
    max: { default: Infinity },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const isScrubbing = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const defaultValue = computed(() => props.default ?? props.modelValue);
    const showReset = computed(() => props.default !== void 0);
    const displayValue = computed(() => {
      if (Number.isInteger(props.modelValue) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      let multiplier = props.sensitivity;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX * props.step * multiplier * 0.5;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onKeyDown(e) {
      if (props.disabled) return;
      let delta = 0;
      if (e.key === "ArrowUp") delta = props.step;
      else if (e.key === "ArrowDown") delta = -props.step;
      if (delta !== 0) {
        e.preventDefault();
        if (e.shiftKey) delta *= 10;
        if (e.ctrlKey || e.metaKey) delta *= 0.1;
        emit("update:modelValue", round(clamp(props.modelValue + delta)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    function reset() {
      if (props.default !== void 0) {
        emit("update:modelValue", props.default);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["scrubable-number", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["scrub-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("input", {
          type: "number",
          class: "scrub-input",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onKeydown: onKeyDown,
          onBlur
        }, null, 40, _hoisted_1$v),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$u, toDisplayString(__props.unit), 1)) : createCommentVNode("", true),
        showReset.value && __props.modelValue !== defaultValue.value ? (openBlock(), createElementBlock("button", {
          key: 2,
          class: "reset-btn",
          onClick: reset,
          title: "Reset to default"
        }, [..._cache[0] || (_cache[0] = [
          createBaseVNode("i", { class: "pi pi-refresh" }, null, -1)
        ])])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const ScrubableNumber = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-dcc786e6"]]);

const _hoisted_1$u = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$t = {
  key: 2,
  class: "slider-unit"
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: true },
    gradient: {},
    disabled: { type: Boolean, default: false },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const trackRef = ref(null);
    const isScrubbing = ref(false);
    const isDragging = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const fillPercent = computed(() => {
      const range = props.max - props.min;
      if (range === 0) return 0;
      return (props.modelValue - props.min) / range * 100;
    });
    const displayValue = computed(() => {
      if (Number.isInteger(props.step) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      const range = props.max - props.min;
      let multiplier = 1;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX / 200 * range * multiplier;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onTrackClick(e) {
      if (props.disabled || !trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + percent * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function startThumbDrag(_e) {
      if (props.disabled) return;
      isDragging.value = true;
      document.addEventListener("mousemove", onThumbDrag);
      document.addEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onThumbDrag(e) {
      if (!trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + Math.max(0, Math.min(1, percent)) * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function stopThumbDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onThumbDrag);
      document.removeEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slider-input", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["slider-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "slider-track",
          ref_key: "trackRef",
          ref: trackRef,
          onMousedown: onTrackClick
        }, [
          createBaseVNode("div", {
            class: "slider-fill",
            style: normalizeStyle({ width: fillPercent.value + "%", background: __props.gradient || void 0 })
          }, null, 4),
          createBaseVNode("div", {
            class: "slider-thumb",
            style: normalizeStyle({ left: fillPercent.value + "%" }),
            onMousedown: withModifiers(startThumbDrag, ["stop"])
          }, null, 36)
        ], 544),
        __props.showValue ? (openBlock(), createElementBlock("input", {
          key: 1,
          type: "number",
          class: "slider-value",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onBlur
        }, null, 40, _hoisted_1$u)) : createCommentVNode("", true),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$t, toDisplayString(__props.unit), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const SliderInput = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-9dd40416"]]);

const _hoisted_1$t = { class: "dial-marks" };
const _hoisted_2$s = {
  key: 0,
  class: "angle-value"
};
const _hoisted_3$s = ["value", "disabled"];
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const dialRef = ref(null);
    const isDragging = ref(false);
    const displayValue = computed(() => {
      return Math.round(props.modelValue * 10) / 10;
    });
    function normalizeAngle(angle) {
      return (angle % 360 + 360) % 360;
    }
    function startDrag(e) {
      if (props.disabled) return;
      isDragging.value = true;
      updateAngle(e);
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      updateAngle(e);
    }
    function updateAngle(e) {
      if (!dialRef.value) return;
      const rect = dialRef.value.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      let angle = Math.atan2(deltaX, -deltaY) * (180 / Math.PI);
      angle = normalizeAngle(angle);
      if (e.shiftKey) {
        angle = Math.round(angle / 45) * 45;
      }
      emit("update:modelValue", angle);
    }
    function stopDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mouseup", stopDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", normalizeAngle(value));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["angle-dial", { disabled: __props.disabled }])
      }, [
        createBaseVNode("div", {
          class: "dial",
          ref_key: "dialRef",
          ref: dialRef,
          style: normalizeStyle({ width: __props.size + "px", height: __props.size + "px" }),
          onMousedown: startDrag
        }, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "dial-ring" }, null, -1)),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "dial-center" }, null, -1)),
          createBaseVNode("div", {
            class: "dial-indicator",
            style: normalizeStyle({ transform: `rotate(${__props.modelValue}deg)` })
          }, null, 4),
          createBaseVNode("div", _hoisted_1$t, [
            (openBlock(), createElementBlock(Fragment, null, renderList(8, (i) => {
              return createBaseVNode("div", {
                class: "dial-mark",
                key: i,
                style: normalizeStyle({ transform: `rotate(${i * 45}deg)` })
              }, null, 4);
            }), 64))
          ])
        ], 36),
        __props.showValue ? (openBlock(), createElementBlock("div", _hoisted_2$s, [
          createBaseVNode("input", {
            type: "number",
            class: "angle-input",
            value: displayValue.value,
            disabled: __props.disabled,
            onInput,
            onBlur
          }, null, 40, _hoisted_3$s),
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "angle-unit" }, "", -1))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const AngleDial = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-04a5caf6"]]);

function hsvToRgb(h, s, v) {
  h = (h % 360 + 360) % 360;
  const c = v * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = v - c;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (d !== 0) {
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, v];
}
function hslToRgb$1(h, s, l) {
  h = (h % 360 + 360) % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsl$1(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, l];
}
function hexToRgb(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length === 6 || hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
      return [r, g, b];
    }
  }
  return null;
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "ff";
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  if (hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = parseInt(hex.slice(6, 8), 16) / 255;
    if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
      return [r, g, b, a];
    }
  }
  return null;
}
function rgbToHex(r, g, b) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function rgbaToHex(r, g, b, a) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}${toHex(a * 255)}`;
}
const STANDARD_SWATCHES = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
];

const _hoisted_1$s = {
  key: 0,
  class: "checkerboard"
};
const _hoisted_2$r = ["value"];
const _hoisted_3$r = { class: "mode-tabs" };
const _hoisted_4$r = ["onClick"];
const _hoisted_5$r = {
  key: 1,
  class: "rgb-sliders"
};
const _hoisted_6$r = { class: "color-slider" };
const _hoisted_7$r = ["value"];
const _hoisted_8$p = { class: "color-slider" };
const _hoisted_9$o = ["value"];
const _hoisted_10$o = { class: "color-slider" };
const _hoisted_11$n = ["value"];
const _hoisted_12$l = {
  key: 2,
  class: "hsl-sliders"
};
const _hoisted_13$k = { class: "color-slider" };
const _hoisted_14$j = ["value"];
const _hoisted_15$j = { class: "color-slider" };
const _hoisted_16$j = ["value"];
const _hoisted_17$j = { class: "color-slider" };
const _hoisted_18$j = ["value"];
const _hoisted_19$h = {
  key: 3,
  class: "alpha-slider"
};
const _hoisted_20$h = ["value"];
const _hoisted_21$g = { class: "swatches-section" };
const _hoisted_22$f = { class: "swatches-grid" };
const _hoisted_23$f = ["onClick"];
const _hoisted_24$d = {
  key: 4,
  class: "recent-section"
};
const _hoisted_25$d = { class: "swatches-grid" };
const _hoisted_26$d = ["onClick"];
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: false },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const modes = ["hsv", "rgb", "hsl"];
    const containerRef = ref(null);
    const panelRef = ref(null);
    const svSquareRef = ref(null);
    const hueSliderRef = ref(null);
    const alphaSliderRef = ref(null);
    const isOpen = ref(false);
    const currentMode = ref("hsv");
    const alphaValue = ref(1);
    const recentColors = ref([]);
    const rgb = ref([255, 255, 255]);
    const hsv = ref([0, 0, 1]);
    const hsl = ref([0, 0, 1]);
    const allSwatches = computed(() => props.swatches || STANDARD_SWATCHES);
    const panelStyle = computed(() => {
      if (!containerRef.value || !props.teleport) return {};
      const rect = containerRef.value.getBoundingClientRect();
      return {
        top: `${rect.bottom + 4}px`,
        left: `${rect.left}px`
      };
    });
    function updateFromHex(hex) {
      const parsed = hexToRgb(hex);
      if (parsed) {
        rgb.value = parsed;
        hsv.value = rgbToHsv(parsed[0], parsed[1], parsed[2]);
        hsl.value = rgbToHsl$1(parsed[0], parsed[1], parsed[2]);
      }
    }
    function emitColor() {
      const hex = rgbToHex(rgb.value[0], rgb.value[1], rgb.value[2]);
      emit("update:modelValue", hex);
    }
    function togglePicker() {
      isOpen.value = !isOpen.value;
    }
    function closePicker() {
      if (isOpen.value) {
        isOpen.value = false;
        addToRecent(props.modelValue);
      }
    }
    function addToRecent(color) {
      const index = recentColors.value.indexOf(color);
      if (index !== -1) {
        recentColors.value.splice(index, 1);
      }
      recentColors.value.unshift(color);
      if (recentColors.value.length > props.recentCount) {
        recentColors.value.pop();
      }
    }
    function selectSwatch(color) {
      emit("update:modelValue", color);
    }
    let isDraggingSV = false;
    function startSVDrag(e) {
      isDraggingSV = true;
      updateSV(e);
      document.addEventListener("mousemove", onSVDrag);
      document.addEventListener("mouseup", stopSVDrag);
    }
    function onSVDrag(e) {
      if (isDraggingSV) updateSV(e);
    }
    function updateSV(e) {
      if (!svSquareRef.value) return;
      const rect = svSquareRef.value.getBoundingClientRect();
      const s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
      hsv.value = [hsv.value[0], s, v];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopSVDrag() {
      isDraggingSV = false;
      document.removeEventListener("mousemove", onSVDrag);
      document.removeEventListener("mouseup", stopSVDrag);
    }
    let isDraggingHue = false;
    function startHueDrag(e) {
      isDraggingHue = true;
      updateHue(e);
      document.addEventListener("mousemove", onHueDrag);
      document.addEventListener("mouseup", stopHueDrag);
    }
    function onHueDrag(e) {
      if (isDraggingHue) updateHue(e);
    }
    function updateHue(e) {
      if (!hueSliderRef.value) return;
      const rect = hueSliderRef.value.getBoundingClientRect();
      const h = Math.max(0, Math.min(360, (e.clientX - rect.left) / rect.width * 360));
      hsv.value = [h, hsv.value[1], hsv.value[2]];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopHueDrag() {
      isDraggingHue = false;
      document.removeEventListener("mousemove", onHueDrag);
      document.removeEventListener("mouseup", stopHueDrag);
    }
    let draggingSlider = null;
    let sliderRect = null;
    function startSliderDrag(slider, e) {
      draggingSlider = slider;
      const track = e.target.closest(".slider-track");
      if (track) {
        sliderRect = track.getBoundingClientRect();
        updateSlider(e);
        document.addEventListener("mousemove", onSliderDrag);
        document.addEventListener("mouseup", stopSliderDrag);
      }
    }
    function onSliderDrag(e) {
      if (draggingSlider) updateSlider(e);
    }
    function updateSlider(e) {
      if (!sliderRect || !draggingSlider) return;
      const percent = Math.max(0, Math.min(1, (e.clientX - sliderRect.left) / sliderRect.width));
      switch (draggingSlider) {
        case "r":
          rgb.value = [Math.round(percent * 255), rgb.value[1], rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "g":
          rgb.value = [rgb.value[0], Math.round(percent * 255), rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "b":
          rgb.value = [rgb.value[0], rgb.value[1], Math.round(percent * 255)];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "h":
          hsl.value = [percent * 360, hsl.value[1], hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "s":
          hsl.value = [hsl.value[0], percent, hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "l":
          hsl.value = [hsl.value[0], hsl.value[1], percent];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
      }
      emitColor();
    }
    function stopSliderDrag() {
      draggingSlider = null;
      sliderRect = null;
      document.removeEventListener("mousemove", onSliderDrag);
      document.removeEventListener("mouseup", stopSliderDrag);
    }
    let isDraggingAlpha = false;
    function startAlphaDrag(e) {
      isDraggingAlpha = true;
      updateAlpha(e);
      document.addEventListener("mousemove", onAlphaDrag);
      document.addEventListener("mouseup", stopAlphaDrag);
    }
    function onAlphaDrag(e) {
      if (isDraggingAlpha) updateAlpha(e);
    }
    function updateAlpha(e) {
      if (!alphaSliderRef.value) return;
      const rect = alphaSliderRef.value.getBoundingClientRect();
      alphaValue.value = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    }
    function stopAlphaDrag() {
      isDraggingAlpha = false;
      document.removeEventListener("mousemove", onAlphaDrag);
      document.removeEventListener("mouseup", stopAlphaDrag);
    }
    function onHexInput(e) {
      const input = e.target;
      let value = input.value.trim();
      if (!value.startsWith("#")) {
        value = "#" + value;
      }
      if (/^#[0-9a-f]{6}$/i.test(value)) {
        emit("update:modelValue", value.toLowerCase());
      }
    }
    function onHexBlur(e) {
      const input = e.target;
      input.value = props.modelValue;
    }
    function onRgbInput(index, e) {
      const input = e.target;
      const value = Math.max(0, Math.min(255, parseInt(input.value) || 0));
      const newRgb = [...rgb.value];
      newRgb[index] = value;
      rgb.value = newRgb;
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onHslInput(index, e) {
      const input = e.target;
      let value = parseFloat(input.value) || 0;
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
        hsl.value = [value, hsl.value[1], hsl.value[2]];
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
        if (index === 1) hsl.value = [hsl.value[0], value, hsl.value[2]];
        else hsl.value = [hsl.value[0], hsl.value[1], value];
      }
      rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onAlphaInput(e) {
      const input = e.target;
      alphaValue.value = Math.max(0, Math.min(100, parseInt(input.value) || 0)) / 100;
    }
    function onClickOutside(e) {
      if (containerRef.value && !containerRef.value.contains(e.target) && panelRef.value && !panelRef.value.contains(e.target)) {
        closePicker();
      }
    }
    watch(() => props.modelValue, (newVal) => {
      updateFromHex(newVal);
    }, { immediate: true });
    onMounted(() => {
      document.addEventListener("mousedown", onClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("mousedown", onClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "color-picker",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("button", {
          class: "color-swatch",
          style: normalizeStyle({ backgroundColor: __props.modelValue }),
          onClick: togglePicker
        }, [
          __props.alpha ? (openBlock(), createElementBlock("span", _hoisted_1$s)) : createCommentVNode("", true)
        ], 4),
        createBaseVNode("input", {
          type: "text",
          class: "hex-input",
          value: __props.modelValue,
          onInput: onHexInput,
          onBlur: onHexBlur,
          onKeydown: _cache[0] || (_cache[0] = withKeys(($event) => $event.target.blur(), ["enter"]))
        }, null, 40, _hoisted_2$r),
        (openBlock(), createBlock(Teleport, {
          to: "body",
          disabled: !__props.teleport
        }, [
          isOpen.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "picker-panel",
            style: normalizeStyle(panelStyle.value),
            ref_key: "panelRef",
            ref: panelRef
          }, [
            createBaseVNode("div", _hoisted_3$r, [
              (openBlock(), createElementBlock(Fragment, null, renderList(modes, (mode) => {
                return createBaseVNode("button", {
                  key: mode,
                  class: normalizeClass({ active: currentMode.value === mode }),
                  onClick: ($event) => currentMode.value = mode
                }, toDisplayString(mode.toUpperCase()), 11, _hoisted_4$r);
              }), 64))
            ]),
            currentMode.value === "hsv" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: "sv-square",
                style: normalizeStyle({ backgroundColor: `hsl(${hsv.value[0]}, 100%, 50%)` }),
                onMousedown: startSVDrag,
                ref_key: "svSquareRef",
                ref: svSquareRef
              }, [
                _cache[13] || (_cache[13] = createBaseVNode("div", { class: "sv-white" }, null, -1)),
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "sv-black" }, null, -1)),
                createBaseVNode("div", {
                  class: "sv-cursor",
                  style: normalizeStyle({ left: hsv.value[1] * 100 + "%", top: (1 - hsv.value[2]) * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("div", {
                class: "hue-slider",
                onMousedown: startHueDrag,
                ref_key: "hueSliderRef",
                ref: hueSliderRef
              }, [
                createBaseVNode("div", {
                  class: "hue-cursor",
                  style: normalizeStyle({ left: hsv.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 544)
            ], 64)) : currentMode.value === "rgb" ? (openBlock(), createElementBlock("div", _hoisted_5$r, [
              createBaseVNode("div", _hoisted_6$r, [
                _cache[15] || (_cache[15] = createBaseVNode("label", null, "R", -1)),
                createBaseVNode("div", {
                  class: "slider-track r-track",
                  onMousedown: _cache[1] || (_cache[1] = ($event) => startSliderDrag("r", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[0] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[0],
                  min: "0",
                  max: "255",
                  onInput: _cache[2] || (_cache[2] = ($event) => onRgbInput(0, $event))
                }, null, 40, _hoisted_7$r)
              ]),
              createBaseVNode("div", _hoisted_8$p, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "G", -1)),
                createBaseVNode("div", {
                  class: "slider-track g-track",
                  onMousedown: _cache[3] || (_cache[3] = ($event) => startSliderDrag("g", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[1] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[1],
                  min: "0",
                  max: "255",
                  onInput: _cache[4] || (_cache[4] = ($event) => onRgbInput(1, $event))
                }, null, 40, _hoisted_9$o)
              ]),
              createBaseVNode("div", _hoisted_10$o, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "B", -1)),
                createBaseVNode("div", {
                  class: "slider-track b-track",
                  onMousedown: _cache[5] || (_cache[5] = ($event) => startSliderDrag("b", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[2] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[2],
                  min: "0",
                  max: "255",
                  onInput: _cache[6] || (_cache[6] = ($event) => onRgbInput(2, $event))
                }, null, 40, _hoisted_11$n)
              ])
            ])) : currentMode.value === "hsl" ? (openBlock(), createElementBlock("div", _hoisted_12$l, [
              createBaseVNode("div", _hoisted_13$k, [
                _cache[18] || (_cache[18] = createBaseVNode("label", null, "H", -1)),
                createBaseVNode("div", {
                  class: "slider-track hue-track",
                  onMousedown: _cache[7] || (_cache[7] = ($event) => startSliderDrag("h", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[0] / 360 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[0]),
                  min: "0",
                  max: "360",
                  onInput: _cache[8] || (_cache[8] = ($event) => onHslInput(0, $event))
                }, null, 40, _hoisted_14$j)
              ]),
              createBaseVNode("div", _hoisted_15$j, [
                _cache[19] || (_cache[19] = createBaseVNode("label", null, "S", -1)),
                createBaseVNode("div", {
                  class: "slider-track sat-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[9] || (_cache[9] = ($event) => startSliderDrag("s", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[1] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[1] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[10] || (_cache[10] = ($event) => onHslInput(1, $event))
                }, null, 40, _hoisted_16$j)
              ]),
              createBaseVNode("div", _hoisted_17$j, [
                _cache[20] || (_cache[20] = createBaseVNode("label", null, "L", -1)),
                createBaseVNode("div", {
                  class: "slider-track light-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[11] || (_cache[11] = ($event) => startSliderDrag("l", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[2] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[2] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[12] || (_cache[12] = ($event) => onHslInput(2, $event))
                }, null, 40, _hoisted_18$j)
              ])
            ])) : createCommentVNode("", true),
            __props.alpha ? (openBlock(), createElementBlock("div", _hoisted_19$h, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "A", -1)),
              createBaseVNode("div", {
                class: "slider-track alpha-track",
                style: normalizeStyle({ "--color": __props.modelValue }),
                onMousedown: startAlphaDrag,
                ref_key: "alphaSliderRef",
                ref: alphaSliderRef
              }, [
                createBaseVNode("div", {
                  class: "slider-cursor",
                  style: normalizeStyle({ left: alphaValue.value * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("input", {
                type: "number",
                value: Math.round(alphaValue.value * 100),
                min: "0",
                max: "100",
                onInput: onAlphaInput
              }, null, 40, _hoisted_20$h)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_21$g, [
              _cache[22] || (_cache[22] = createBaseVNode("div", { class: "swatches-label" }, "Swatches", -1)),
              createBaseVNode("div", _hoisted_22$f, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allSwatches.value, (swatch) => {
                  return openBlock(), createElementBlock("button", {
                    key: swatch,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: swatch }),
                    onClick: ($event) => selectSwatch(swatch)
                  }, null, 12, _hoisted_23$f);
                }), 128))
              ])
            ]),
            recentColors.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_24$d, [
              _cache[23] || (_cache[23] = createBaseVNode("div", { class: "swatches-label" }, "Recent", -1)),
              createBaseVNode("div", _hoisted_25$d, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(recentColors.value, (color) => {
                  return openBlock(), createElementBlock("button", {
                    key: color,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: color }),
                    onClick: ($event) => selectSwatch(color)
                  }, null, 12, _hoisted_26$d);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ], 8, ["disabled"]))
      ], 512);
    };
  }
});

const ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-05165efb"]]);

const _hoisted_1$r = { class: "effect-controls" };
const _hoisted_2$q = { class: "panel-header" };
const _hoisted_3$q = { class: "header-row" };
const _hoisted_4$q = {
  key: 0,
  class: "layer-badge"
};
const _hoisted_5$q = { class: "layer-type-icon" };
const _hoisted_6$q = ["disabled"];
const _hoisted_7$q = {
  key: 0,
  class: "effect-menu"
};
const _hoisted_8$o = { class: "category-label" };
const _hoisted_9$n = { class: "cat-icon" };
const _hoisted_10$n = { class: "category-items" };
const _hoisted_11$m = ["onClick"];
const _hoisted_12$k = { class: "panel-content" };
const _hoisted_13$j = {
  key: 0,
  class: "empty-state"
};
const _hoisted_14$i = {
  key: 1,
  class: "empty-state"
};
const _hoisted_15$i = {
  key: 2,
  class: "effects-list"
};
const _hoisted_16$i = ["onClick"];
const _hoisted_17$i = { class: "header-left" };
const _hoisted_18$i = { class: "arrow" };
const _hoisted_19$g = ["onClick"];
const _hoisted_20$g = { class: "effect-name" };
const _hoisted_21$f = { class: "header-right" };
const _hoisted_22$e = ["onClick"];
const _hoisted_23$e = {
  key: 0,
  class: "effect-params"
};
const _hoisted_24$c = { class: "param-header" };
const _hoisted_25$c = ["title"];
const _hoisted_26$c = ["onClick"];
const _hoisted_27$c = { class: "param-control" };
const _hoisted_28$c = {
  key: 0,
  class: "control-group"
};
const _hoisted_29$c = {
  key: 1,
  class: "control-group"
};
const _hoisted_30$c = {
  key: 2,
  class: "control-group point-group"
};
const _hoisted_31$9 = ["checked", "onChange"];
const _hoisted_32$9 = ["value", "onChange"];
const _hoisted_33$9 = ["value"];
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "EffectControlsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const showAddMenu = ref(false);
    const menuRef = ref(null);
    const layer = computed(() => store.selectedLayer);
    const categories = EFFECT_CATEGORIES;
    function getEffectsByCategory(cat) {
      return Object.entries(EFFECT_DEFINITIONS).filter(([_, def]) => def.category === cat).map(([key, def]) => ({ key, ...def }));
    }
    function getParamDef(effectKey, paramKey) {
      const def = EFFECT_DEFINITIONS[effectKey];
      return def?.parameters.find((p) => formatParamKey(p.name) === paramKey);
    }
    function formatParamKey(name) {
      return name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function hasRange(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def && (def.min !== void 0 || def.max !== void 0);
    }
    function isCheckbox(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "checkbox";
    }
    function isAngleParam(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "angle";
    }
    function getParamOptions(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.options || [];
    }
    function getLayerIcon(type) {
      const icons = {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      };
      return icons[type] || "";
    }
    function addEffect(key) {
      if (layer.value) {
        store.addEffectToLayer(layer.value.id, key);
        showAddMenu.value = false;
      }
    }
    function removeEffect(effect) {
      if (layer.value) store.removeEffectFromLayer(layer.value.id, effect.id);
    }
    function toggleEffect(effect) {
      if (layer.value) store.toggleEffect(layer.value.id, effect.id);
    }
    function toggleExpand(effect) {
      effect.expanded = !effect.expanded;
    }
    function updateParam(effectId, paramKey, value) {
      if (layer.value) store.updateEffectParameter(layer.value.id, effectId, paramKey, value);
    }
    function updatePoint(effectId, paramKey, axis, val) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      if (!effect) return;
      const current = effect.parameters[paramKey].value;
      const newValue = { ...current, [axis]: val };
      store.updateEffectParameter(layer.value.id, effectId, paramKey, newValue);
    }
    function formatColor(val) {
      if (typeof val === "string") return val;
      return rgbaToHex(val.r, val.g, val.b, val.a ?? 1);
    }
    function updateColor(effectId, paramKey, hex) {
      const rgba = hexToRgba(hex);
      if (rgba && layer.value) {
        const val = { r: rgba[0], g: rgba[1], b: rgba[2], a: rgba[3] };
        store.updateEffectParameter(layer.value.id, effectId, paramKey, val);
      }
    }
    function toggleParamAnim(effectId, paramKey) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      const param = effect?.parameters[paramKey];
      if (param) {
        store.setEffectParamAnimated(layer.value.id, effectId, paramKey, !param.animated);
      }
    }
    function onClickOutside(e) {
      if (menuRef.value && !menuRef.value.contains(e.target)) {
        showAddMenu.value = false;
      }
    }
    onMounted(() => window.addEventListener("mousedown", onClickOutside));
    onUnmounted(() => window.removeEventListener("mousedown", onClickOutside));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        createBaseVNode("div", _hoisted_2$q, [
          createBaseVNode("div", _hoisted_3$q, [
            _cache[1] || (_cache[1] = createBaseVNode("h3", null, "Effect Controls", -1)),
            layer.value ? (openBlock(), createElementBlock("div", _hoisted_4$q, [
              createBaseVNode("span", _hoisted_5$q, toDisplayString(getLayerIcon(layer.value.type)), 1),
              createTextVNode(" " + toDisplayString(layer.value.name), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: "add-effect-wrapper",
            ref_key: "menuRef",
            ref: menuRef
          }, [
            createBaseVNode("button", {
              class: "add-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => showAddMenu.value = !showAddMenu.value),
              disabled: !layer.value
            }, [..._cache[2] || (_cache[2] = [
              createBaseVNode("span", { class: "icon" }, "+", -1),
              createTextVNode(" Add Effect ", -1)
            ])], 8, _hoisted_6$q),
            showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_7$q, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(categories), (catInfo, catKey) => {
                return openBlock(), createElementBlock("div", {
                  key: catKey,
                  class: "effect-category"
                }, [
                  createBaseVNode("div", _hoisted_8$o, [
                    createBaseVNode("span", _hoisted_9$n, toDisplayString(catInfo.icon), 1),
                    createTextVNode(" " + toDisplayString(catInfo.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_10$n, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getEffectsByCategory(catKey), (def) => {
                      return openBlock(), createElementBlock("button", {
                        key: def.key,
                        onClick: ($event) => addEffect(def.key)
                      }, toDisplayString(def.name), 9, _hoisted_11$m);
                    }), 128))
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 512)
        ]),
        createBaseVNode("div", _hoisted_12$k, [
          !layer.value ? (openBlock(), createElementBlock("div", _hoisted_13$j, " Select a layer to edit effects ")) : !layer.value.effects || layer.value.effects.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_14$i, " No effects applied ")) : (openBlock(), createElementBlock("div", _hoisted_15$i, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(layer.value.effects, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: normalizeClass(["effect-item", { collapsed: !effect.expanded }])
              }, [
                createBaseVNode("div", {
                  class: "effect-header",
                  onClick: ($event) => toggleExpand(effect)
                }, [
                  createBaseVNode("div", _hoisted_17$i, [
                    createBaseVNode("span", _hoisted_18$i, toDisplayString(effect.expanded ? "" : ""), 1),
                    createBaseVNode("button", {
                      class: "icon-btn",
                      onClick: withModifiers(($event) => toggleEffect(effect), ["stop"])
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(["fx-icon", { disabled: !effect.enabled }])
                      }, "fx", 2)
                    ], 8, _hoisted_19$g),
                    createBaseVNode("span", _hoisted_20$g, toDisplayString(effect.name), 1)
                  ]),
                  createBaseVNode("div", _hoisted_21$f, [
                    createBaseVNode("button", {
                      class: "icon-btn delete",
                      onClick: withModifiers(($event) => removeEffect(effect), ["stop"]),
                      title: "Remove Effect"
                    }, "", 8, _hoisted_22$e)
                  ])
                ], 8, _hoisted_16$i),
                effect.expanded ? (openBlock(), createElementBlock("div", _hoisted_23$e, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(effect.parameters, (param, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: "param-row"
                    }, [
                      createBaseVNode("div", _hoisted_24$c, [
                        createBaseVNode("span", {
                          class: "param-name",
                          title: String(key)
                        }, toDisplayString(param.name), 9, _hoisted_25$c),
                        createBaseVNode("button", {
                          class: normalizeClass(["stopwatch", { active: param.animated }]),
                          onClick: ($event) => toggleParamAnim(effect.id, String(key)),
                          title: "Toggle Animation"
                        }, "", 10, _hoisted_26$c)
                      ]),
                      createBaseVNode("div", _hoisted_27$c, [
                        param.type === "number" && isAngleParam(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("div", _hoisted_28$c, [
                          createVNode(AngleDial, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            size: 32,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            unit: ""
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "number" ? (openBlock(), createElementBlock("div", _hoisted_29$c, [
                          hasRange(effect.effectKey, String(key)) ? (openBlock(), createBlock(SliderInput, {
                            key: 0,
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            min: getParamDef(effect.effectKey, String(key))?.min ?? 0,
                            max: getParamDef(effect.effectKey, String(key))?.max ?? 100,
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 1,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : createCommentVNode("", true),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 0.1
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                        ])) : param.type === "position" ? (openBlock(), createElementBlock("div", _hoisted_30$c, [
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.x,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "x", v),
                            label: "X"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.y,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "y", v),
                            label: "Y"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "color" ? (openBlock(), createBlock(ColorPicker, {
                          key: 3,
                          modelValue: formatColor(param.value),
                          "onUpdate:modelValue": (v) => updateColor(effect.id, String(key), v),
                          alpha: true
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])) : param.type === "enum" && isCheckbox(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("input", {
                          key: 4,
                          type: "checkbox",
                          checked: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.checked)
                        }, null, 40, _hoisted_31$9)) : param.type === "enum" ? (openBlock(), createElementBlock("select", {
                          key: 5,
                          value: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.value),
                          class: "param-select"
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(getParamOptions(effect.effectKey, String(key)), (opt) => {
                            return openBlock(), createElementBlock("option", {
                              key: opt.value,
                              value: opt.value
                            }, toDisplayString(opt.label), 9, _hoisted_33$9);
                          }), 128))
                        ], 40, _hoisted_32$9)) : createCommentVNode("", true)
                      ])
                    ]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]))
        ])
      ]);
    };
  }
});

const EffectControlsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-8ac57c6b"]]);

const fontLogger = createLogger("Font");
const WEB_SAFE_FONTS = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
];
const GOOGLE_FONTS = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class FontService {
  systemFonts = [];
  loadedGoogleFonts = /* @__PURE__ */ new Set();
  initialized = false;
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    if (this.initialized) return;
    if ("queryLocalFonts" in window) {
      await this.loadSystemFonts();
    }
    this.initialized = true;
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const fonts = await window.queryLocalFonts();
      const familyMap = /* @__PURE__ */ new Map();
      for (const font of fonts) {
        if (!familyMap.has(font.family) || font.style === "Regular") {
          familyMap.set(font.family, {
            family: font.family,
            fullName: font.fullName,
            style: font.style,
            source: "system"
          });
        }
      }
      this.systemFonts = Array.from(familyMap.values()).sort((a, b) => a.family.localeCompare(b.family));
      fontLogger.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (error) {
      if (error.name === "NotAllowedError") {
        fontLogger.info("User denied font access permission");
      } else {
        fontLogger.error("Error loading system fonts:", error);
      }
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const categories = [];
    if (this.systemFonts.length > 0) {
      categories.push({
        name: "System Fonts",
        fonts: this.systemFonts
      });
    }
    categories.push({
      name: "Web Safe",
      fonts: WEB_SAFE_FONTS
    });
    categories.push({
      name: "Google Fonts",
      fonts: GOOGLE_FONTS.map((family) => ({
        family,
        fullName: family,
        style: "normal",
        source: "google"
      }))
    });
    return categories;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const families = /* @__PURE__ */ new Set();
    WEB_SAFE_FONTS.forEach((f) => families.add(f.family));
    GOOGLE_FONTS.forEach((f) => families.add(f));
    this.systemFonts.forEach((f) => families.add(f.family));
    return Array.from(families).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(family, weights = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(family)) return;
    const weightsStr = weights.join(";");
    const url = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(family)}:wght@${weightsStr}&display=swap`;
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = url;
    document.head.appendChild(link);
    try {
      await document.fonts.load(`400 16px "${family}"`);
      this.loadedGoogleFonts.add(family);
      fontLogger.debug(`Loaded Google Font: ${family}`);
    } catch (error) {
      fontLogger.error(`Failed to load Google Font: ${family}`, error);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(family) {
    if (WEB_SAFE_FONTS.some((f) => f.family === family)) {
      return true;
    }
    if (GOOGLE_FONTS.includes(family)) {
      await this.loadGoogleFont(family);
      return true;
    }
    if (this.systemFonts.some((f) => f.family === family)) {
      return true;
    }
    return this.isFontAvailable(family);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(family) {
    const testString = "mmmmmmmmmmlli";
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = "72px monospace";
    const fallbackWidth = ctx.measureText(testString).width;
    ctx.font = `72px "${family}", monospace`;
    const testWidth = ctx.measureText(testString).width;
    return fallbackWidth !== testWidth;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return WEB_SAFE_FONTS;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return GOOGLE_FONTS;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    if (!("queryLocalFonts" in window)) {
      fontLogger.info("Local Font Access API not available");
      return false;
    }
    await this.loadSystemFonts();
    return this.systemFonts.length > 0;
  }
}
const fontService = new FontService();

const _hoisted_1$q = { class: "text-properties" };
const _hoisted_2$p = { class: "prop-section" };
const _hoisted_3$p = ["value"];
const _hoisted_4$p = { class: "prop-section" };
const _hoisted_5$p = { class: "row font-row" };
const _hoisted_6$p = ["value"];
const _hoisted_7$p = ["label"];
const _hoisted_8$n = ["value"];
const _hoisted_9$m = { class: "style-toggles" };
const _hoisted_10$m = {
  key: 0,
  class: "row"
};
const _hoisted_11$l = ["disabled"];
const _hoisted_12$j = { class: "row" };
const _hoisted_13$i = { class: "row color-row" };
const _hoisted_14$h = { class: "color-item" };
const _hoisted_15$h = ["value"];
const _hoisted_16$h = { class: "color-item" };
const _hoisted_17$h = ["value"];
const _hoisted_18$h = { class: "row" };
const _hoisted_19$f = { class: "row" };
const _hoisted_20$f = { class: "align-buttons" };
const _hoisted_21$e = { class: "prop-section" };
const _hoisted_22$d = { class: "row" };
const _hoisted_23$d = { class: "vec2" };
const _hoisted_24$b = { class: "row" };
const _hoisted_25$b = { class: "vec2" };
const _hoisted_26$b = { class: "row" };
const _hoisted_27$b = { class: "vec2" };
const _hoisted_28$b = { class: "row" };
const _hoisted_29$b = { class: "row" };
const _hoisted_30$b = { class: "prop-section" };
const _hoisted_31$8 = { class: "row" };
const _hoisted_32$8 = ["value"];
const _hoisted_33$8 = ["value"];
const _hoisted_34$8 = { class: "row" };
const _hoisted_35$8 = { class: "row" };
const _hoisted_36$8 = { class: "row" };
const _hoisted_37$8 = { class: "row checkbox-row" };
const _hoisted_38$7 = ["checked"];
const _hoisted_39$7 = { class: "row checkbox-row" };
const _hoisted_40$6 = ["checked"];
const _hoisted_41$6 = { class: "row checkbox-row" };
const _hoisted_42$5 = ["checked"];
const _hoisted_43$5 = { class: "prop-section" };
const _hoisted_44$5 = { class: "row" };
const _hoisted_45$5 = { class: "row" };
const _hoisted_46$5 = { class: "row" };
const _hoisted_47$5 = { class: "prop-section checkbox" };
const _hoisted_48$5 = ["checked"];
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const fontCategories = ref([]);
    const hasSystemFonts = ref(false);
    const loadingFonts = ref(false);
    onMounted(async () => {
      await fontService.initialize();
      fontCategories.value = fontService.getFontCategories();
      hasSystemFonts.value = fontService.hasSystemFonts();
    });
    async function requestFontAccess() {
      loadingFonts.value = true;
      try {
        const success = await fontService.requestSystemFontAccess();
        if (success) {
          fontCategories.value = fontService.getFontCategories();
          hasSystemFonts.value = true;
        }
      } finally {
        loadingFonts.value = false;
      }
    }
    const textData = computed(() => props.layer.data);
    const transform = computed(() => props.layer.transform);
    const splineLayers = computed(() => store.layers.filter((l) => l.type === "spline"));
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const p = getProperty(name);
      return p ? p.value : null;
    }
    function updateText(val) {
      store.setPropertyValue(props.layer.id, "Source Text", val);
      store.updateLayerData(props.layer.id, { text: val });
      emit("update");
    }
    function updateData(key, val) {
      store.updateLayerData(props.layer.id, { [key]: val });
      const map = {
        "fill": "Fill Color",
        "stroke": "Stroke Color",
        "fontSize": "Font Size",
        "strokeWidth": "Stroke Width"
      };
      if (map[key]) {
        store.setPropertyValue(props.layer.id, map[key], val);
      }
      emit("update");
    }
    function updateAnimatable(name, val) {
      store.setPropertyValue(props.layer.id, name, val);
      const keyMap = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        "Tracking": "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      if (keyMap[name]) {
        store.updateLayerData(props.layer.id, { [keyMap[name]]: val });
      }
      emit("update");
    }
    function isPropertyAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function toggleKeyframe(name) {
      const prop = getProperty(name);
      if (!prop) return;
      const currentFrame = store.currentFrame;
      const existingKf = prop.keyframes?.find((kf) => kf.frame === currentFrame);
      if (existingKf) {
        store.removeKeyframe(props.layer.id, name, existingKf.id);
      } else {
        store.addKeyframe(props.layer.id, name, prop.value, currentFrame);
      }
      emit("update");
    }
    function updateTransform(propName, axis, val) {
      const prop = transform.value[propName];
      let newValue;
      if (axis) {
        newValue = { ...prop.value, [axis]: val };
      } else {
        newValue = val;
      }
      store.setPropertyValue(props.layer.id, `transform.${propName}`, newValue);
      emit("update");
    }
    function updateOpacity(val) {
      store.setPropertyValue(props.layer.id, "opacity", val);
      emit("update");
    }
    function toggleBold() {
      updateData("fontWeight", textData.value.fontWeight === "bold" ? "400" : "bold");
    }
    function toggleItalic() {
      updateData("fontStyle", textData.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function handleFontChange(family) {
      await fontService.ensureFont(family);
      updateData("fontFamily", family);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$p, [
          _cache[29] || (_cache[29] = createBaseVNode("div", { class: "section-title" }, "Source Text", -1)),
          createBaseVNode("textarea", {
            value: textData.value.text,
            onInput: _cache[0] || (_cache[0] = (e) => updateText(e.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, _hoisted_3$p)
        ]),
        createBaseVNode("div", _hoisted_4$p, [
          _cache[35] || (_cache[35] = createBaseVNode("div", { class: "section-title" }, "Character", -1)),
          createBaseVNode("div", _hoisted_5$p, [
            createBaseVNode("select", {
              value: textData.value.fontFamily,
              onChange: _cache[1] || (_cache[1] = (e) => handleFontChange(e.target.value)),
              class: "font-select"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(fontCategories.value, (category) => {
                return openBlock(), createElementBlock("optgroup", {
                  key: category.name,
                  label: category.name
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.fonts, (font) => {
                    return openBlock(), createElementBlock("option", {
                      key: font.family,
                      value: font.family
                    }, toDisplayString(font.family), 9, _hoisted_8$n);
                  }), 128))
                ], 8, _hoisted_7$p);
              }), 128))
            ], 40, _hoisted_6$p),
            createBaseVNode("div", _hoisted_9$m, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontWeight === "bold" }),
                onClick: toggleBold
              }, "B", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontStyle === "italic" }),
                onClick: toggleItalic
              }, "I", 2)
            ])
          ]),
          !hasSystemFonts.value ? (openBlock(), createElementBlock("div", _hoisted_10$m, [
            createBaseVNode("button", {
              class: "font-access-btn",
              onClick: requestFontAccess,
              disabled: loadingFonts.value
            }, toDisplayString(loadingFonts.value ? "Loading..." : "+ Load System Fonts"), 9, _hoisted_11$l)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$j, [
            _cache[30] || (_cache[30] = createBaseVNode("label", null, "Size", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Font Size") || textData.value.fontSize,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("Font Size", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_13$i, [
            createBaseVNode("div", _hoisted_14$h, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.fill,
                onInput: _cache[3] || (_cache[3] = (e) => updateData("fill", e.target.value))
              }, null, 40, _hoisted_15$h),
              _cache[31] || (_cache[31] = createBaseVNode("span", null, "Fill", -1))
            ]),
            createBaseVNode("div", _hoisted_16$h, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.stroke || "#000000",
                onInput: _cache[4] || (_cache[4] = (e) => updateData("stroke", e.target.value))
              }, null, 40, _hoisted_17$h),
              _cache[32] || (_cache[32] = createBaseVNode("span", null, "Stroke", -1))
            ])
          ]),
          createBaseVNode("div", _hoisted_18$h, [
            _cache[33] || (_cache[33] = createBaseVNode("label", null, "Stroke Width", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Stroke Width") || textData.value.strokeWidth || 0,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_19$f, [
            _cache[34] || (_cache[34] = createBaseVNode("label", null, "Alignment", -1)),
            createBaseVNode("div", _hoisted_20$f, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "left" }),
                onClick: _cache[6] || (_cache[6] = ($event) => updateData("textAlign", "left"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "center" }),
                onClick: _cache[7] || (_cache[7] = ($event) => updateData("textAlign", "center"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "right" }),
                onClick: _cache[8] || (_cache[8] = ($event) => updateData("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_21$e, [
          _cache[41] || (_cache[41] = createBaseVNode("div", { class: "section-title" }, "Transform", -1)),
          createBaseVNode("div", _hoisted_22$d, [
            _cache[36] || (_cache[36] = createBaseVNode("label", null, "Position", -1)),
            createBaseVNode("div", _hoisted_23$d, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.x,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateTransform("position", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.y,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateTransform("position", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_24$b, [
            _cache[37] || (_cache[37] = createBaseVNode("label", null, "Anchor Pt", -1)),
            createBaseVNode("div", _hoisted_25$b, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.x,
                "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateTransform("anchorPoint", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.y,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateTransform("anchorPoint", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_26$b, [
            _cache[38] || (_cache[38] = createBaseVNode("label", null, "Scale %", -1)),
            createBaseVNode("div", _hoisted_27$b, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.x,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateTransform("scale", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.y,
                "onUpdate:modelValue": _cache[14] || (_cache[14] = (v) => updateTransform("scale", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_28$b, [
            _cache[39] || (_cache[39] = createBaseVNode("label", null, "Rotation", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: transform.value.rotation.value,
              "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateTransform("rotation", null, v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_29$b, [
            _cache[40] || (_cache[40] = createBaseVNode("label", null, "Opacity", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: __props.layer.opacity?.value ?? 100,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updateOpacity(v)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_30$b, [
          _cache[50] || (_cache[50] = createBaseVNode("div", { class: "section-title" }, "Path Options", -1)),
          createBaseVNode("div", _hoisted_31$8, [
            _cache[43] || (_cache[43] = createBaseVNode("label", null, "Path", -1)),
            createBaseVNode("select", {
              value: textData.value.pathLayerId || "",
              onChange: _cache[17] || (_cache[17] = (e) => updateData("pathLayerId", e.target.value || null)),
              class: "full-select"
            }, [
              _cache[42] || (_cache[42] = createBaseVNode("option", { value: "" }, "None", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (l) => {
                return openBlock(), createElementBlock("option", {
                  key: l.id,
                  value: l.id
                }, toDisplayString(l.name), 9, _hoisted_33$8);
              }), 128))
            ], 40, _hoisted_32$8)
          ]),
          textData.value.pathLayerId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_34$8, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Path Offset %", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Offset") ?? textData.value.pathOffset ?? 0,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Path Offset", v)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isPropertyAnimated("Path Offset") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_35$8, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "First Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("First Margin") ?? textData.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateAnimatable("First Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_36$8, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Last Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Last Margin") ?? textData.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Last Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$8, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathReversed,
                  onChange: _cache[22] || (_cache[22] = ($event) => updateData("pathReversed", !textData.value.pathReversed))
                }, null, 40, _hoisted_38$7),
                _cache[47] || (_cache[47] = createTextVNode(" Reverse Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_39$7, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathPerpendicularToPath ?? true,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateData("pathPerpendicularToPath", !textData.value.pathPerpendicularToPath))
                }, null, 40, _hoisted_40$6),
                _cache[48] || (_cache[48] = createTextVNode(" Perpendicular to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_41$6, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathForceAlignment,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateData("pathForceAlignment", !textData.value.pathForceAlignment))
                }, null, 40, _hoisted_42$5),
                _cache[49] || (_cache[49] = createTextVNode(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_43$5, [
          _cache[54] || (_cache[54] = createBaseVNode("div", { class: "section-title" }, "Advanced", -1)),
          createBaseVNode("div", _hoisted_44$5, [
            _cache[51] || (_cache[51] = createBaseVNode("label", null, "Tracking", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Tracking") || textData.value.tracking || 0,
              "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Tracking", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_45$5, [
            _cache[52] || (_cache[52] = createBaseVNode("label", null, "Line Spacing", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Line Spacing") || textData.value.lineSpacing || 0,
              "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateAnimatable("Line Spacing", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_46$5, [
            _cache[53] || (_cache[53] = createBaseVNode("label", null, "Char Offset", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Character Offset") || textData.value.characterOffset || 0,
              "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateAnimatable("Character Offset", v)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_47$5, [
          createBaseVNode("label", null, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: textData.value.perCharacter3D,
              onChange: _cache[28] || (_cache[28] = ($event) => updateData("perCharacter3D", !textData.value.perCharacter3D))
            }, null, 40, _hoisted_48$5),
            _cache[55] || (_cache[55] = createTextVNode(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
});

const TextProperties = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-947c42b2"]]);

const _hoisted_1$p = { class: "particle-properties" };
const _hoisted_2$o = { class: "property-section" };
const _hoisted_3$o = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$o = { class: "property-row" };
const _hoisted_5$o = ["value"];
const _hoisted_6$o = { class: "value-display" };
const _hoisted_7$o = { class: "property-row" };
const _hoisted_8$m = ["value"];
const _hoisted_9$l = { class: "value-display" };
const _hoisted_10$l = { class: "property-row" };
const _hoisted_11$k = ["value"];
const _hoisted_12$i = { class: "value-display" };
const _hoisted_13$h = { class: "property-row" };
const _hoisted_14$g = ["value"];
const _hoisted_15$g = { class: "value-display" };
const _hoisted_16$g = { class: "property-row" };
const _hoisted_17$g = ["value"];
const _hoisted_18$g = { class: "value-display" };
const _hoisted_19$e = { class: "property-row" };
const _hoisted_20$e = ["value"];
const _hoisted_21$d = { class: "property-section" };
const _hoisted_22$c = {
  key: 0,
  class: "section-content"
};
const _hoisted_23$c = ["onClick"];
const _hoisted_24$a = ["value", "onInput"];
const _hoisted_25$a = { class: "enabled-toggle" };
const _hoisted_26$a = ["checked", "onChange"];
const _hoisted_27$a = ["onClick"];
const _hoisted_28$a = {
  key: 0,
  class: "emitter-content"
};
const _hoisted_29$a = { class: "property-row" };
const _hoisted_30$a = ["value", "onInput"];
const _hoisted_31$7 = { class: "value-display" };
const _hoisted_32$7 = { class: "property-row" };
const _hoisted_33$7 = ["value", "onInput"];
const _hoisted_34$7 = { class: "value-display" };
const _hoisted_35$7 = { class: "property-row" };
const _hoisted_36$7 = ["value", "onInput"];
const _hoisted_37$7 = { class: "value-display" };
const _hoisted_38$6 = { class: "property-row" };
const _hoisted_39$6 = ["value", "onInput"];
const _hoisted_40$5 = { class: "value-display" };
const _hoisted_41$5 = { class: "property-row" };
const _hoisted_42$4 = ["value", "onInput"];
const _hoisted_43$4 = { class: "value-display" };
const _hoisted_44$4 = { class: "property-row" };
const _hoisted_45$4 = ["value", "onInput"];
const _hoisted_46$4 = { class: "value-display" };
const _hoisted_47$4 = { class: "property-row" };
const _hoisted_48$4 = ["value", "onInput"];
const _hoisted_49$4 = { class: "value-display" };
const _hoisted_50$3 = { class: "property-row" };
const _hoisted_51$3 = ["value", "onInput"];
const _hoisted_52$3 = { class: "value-display" };
const _hoisted_53$3 = { class: "property-row" };
const _hoisted_54$3 = ["value", "onInput"];
const _hoisted_55$3 = { class: "property-row" };
const _hoisted_56$3 = ["value", "onInput"];
const _hoisted_57$3 = { class: "value-display" };
const _hoisted_58$3 = { class: "property-row" };
const _hoisted_59$3 = ["value", "onInput"];
const _hoisted_60$3 = { class: "value-display" };
const _hoisted_61$3 = { class: "property-row" };
const _hoisted_62$3 = ["value", "onInput"];
const _hoisted_63$2 = { class: "value-display" };
const _hoisted_64$2 = { class: "property-row checkbox-row" };
const _hoisted_65$2 = ["checked", "onChange"];
const _hoisted_66$2 = {
  key: 0,
  class: "property-row"
};
const _hoisted_67$2 = ["value", "onInput"];
const _hoisted_68$2 = { class: "value-display" };
const _hoisted_69$2 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_70$2 = { class: "property-section" };
const _hoisted_71$2 = {
  key: 0,
  class: "section-content"
};
const _hoisted_72$2 = { class: "force-tabs" };
const _hoisted_73$2 = {
  key: 0,
  class: "force-list"
};
const _hoisted_74$2 = { class: "force-header" };
const _hoisted_75$2 = ["value", "onInput"];
const _hoisted_76$2 = { class: "enabled-toggle" };
const _hoisted_77$2 = ["checked", "onChange"];
const _hoisted_78$2 = ["onClick"];
const _hoisted_79$1 = { class: "property-row" };
const _hoisted_80$1 = ["value", "onInput"];
const _hoisted_81$1 = { class: "value-display" };
const _hoisted_82$1 = { class: "property-row" };
const _hoisted_83$1 = ["value", "onInput"];
const _hoisted_84$1 = { class: "value-display" };
const _hoisted_85$1 = { class: "property-row" };
const _hoisted_86$1 = ["value", "onInput"];
const _hoisted_87$1 = { class: "value-display" };
const _hoisted_88$1 = { class: "property-row" };
const _hoisted_89$1 = ["value", "onInput"];
const _hoisted_90$1 = { class: "value-display" };
const _hoisted_91$1 = { class: "property-row" };
const _hoisted_92$1 = ["value", "onChange"];
const _hoisted_93$1 = {
  key: 1,
  class: "force-list"
};
const _hoisted_94$1 = { class: "force-header" };
const _hoisted_95 = ["value", "onInput"];
const _hoisted_96 = { class: "enabled-toggle" };
const _hoisted_97 = ["checked", "onChange"];
const _hoisted_98 = ["onClick"];
const _hoisted_99 = { class: "property-row" };
const _hoisted_100 = ["value", "onInput"];
const _hoisted_101 = { class: "value-display" };
const _hoisted_102 = { class: "property-row" };
const _hoisted_103 = ["value", "onInput"];
const _hoisted_104 = { class: "value-display" };
const _hoisted_105 = { class: "property-row" };
const _hoisted_106 = ["value", "onInput"];
const _hoisted_107 = { class: "value-display" };
const _hoisted_108 = { class: "property-row" };
const _hoisted_109 = ["value", "onInput"];
const _hoisted_110 = { class: "value-display" };
const _hoisted_111 = { class: "property-row" };
const _hoisted_112 = ["value", "onInput"];
const _hoisted_113 = { class: "value-display" };
const _hoisted_114 = { class: "property-row" };
const _hoisted_115 = ["value", "onInput"];
const _hoisted_116 = { class: "value-display" };
const _hoisted_117 = { class: "property-section" };
const _hoisted_118 = {
  key: 0,
  class: "section-content"
};
const _hoisted_119 = { class: "force-header" };
const _hoisted_120 = { class: "enabled-toggle" };
const _hoisted_121 = ["checked", "onChange"];
const _hoisted_122 = ["onClick"];
const _hoisted_123 = { class: "property-row" };
const _hoisted_124 = ["value", "onInput"];
const _hoisted_125 = { class: "value-display" };
const _hoisted_126 = { class: "property-row" };
const _hoisted_127 = ["value", "onInput"];
const _hoisted_128 = { class: "value-display" };
const _hoisted_129 = { class: "property-row" };
const _hoisted_130 = ["value", "onInput"];
const _hoisted_131 = { class: "value-display" };
const _hoisted_132 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_133 = { class: "property-section" };
const _hoisted_134 = {
  key: 0,
  class: "section-content"
};
const _hoisted_135 = { class: "force-header" };
const _hoisted_136 = ["value", "onChange"];
const _hoisted_137 = ["value"];
const _hoisted_138 = { class: "enabled-toggle" };
const _hoisted_139 = ["checked", "onChange"];
const _hoisted_140 = ["onClick"];
const _hoisted_141 = { class: "property-row" };
const _hoisted_142 = ["value", "onChange"];
const _hoisted_143 = { class: "property-row" };
const _hoisted_144 = ["value", "onInput"];
const _hoisted_145 = { class: "value-display" };
const _hoisted_146 = { class: "property-row" };
const _hoisted_147 = ["value", "onInput"];
const _hoisted_148 = { class: "value-display" };
const _hoisted_149 = { class: "property-row" };
const _hoisted_150 = ["value", "onInput"];
const _hoisted_151 = { class: "value-display" };
const _hoisted_152 = { class: "property-row" };
const _hoisted_153 = ["value", "onInput"];
const _hoisted_154 = { class: "value-display" };
const _hoisted_155 = { class: "property-row" };
const _hoisted_156 = ["value", "onInput"];
const _hoisted_157 = { class: "value-display" };
const _hoisted_158 = { class: "property-row" };
const _hoisted_159 = ["value", "onInput"];
const _hoisted_160 = { class: "value-display" };
const _hoisted_161 = { class: "property-row" };
const _hoisted_162 = ["value", "onInput"];
const _hoisted_163 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_164 = { class: "property-section" };
const _hoisted_165 = {
  key: 0,
  class: "section-content"
};
const _hoisted_166 = { class: "modulation-header" };
const _hoisted_167 = ["value", "onChange"];
const _hoisted_168 = ["value"];
const _hoisted_169 = ["onClick"];
const _hoisted_170 = { class: "property-row" };
const _hoisted_171 = ["value", "onChange"];
const _hoisted_172 = { class: "property-row" };
const _hoisted_173 = ["value", "onInput"];
const _hoisted_174 = { class: "property-row" };
const _hoisted_175 = ["value", "onInput"];
const _hoisted_176 = { class: "property-row" };
const _hoisted_177 = ["value", "onChange"];
const _hoisted_178 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_179 = { class: "property-section" };
const _hoisted_180 = {
  key: 0,
  class: "section-content"
};
const _hoisted_181 = { class: "property-row" };
const _hoisted_182 = ["value"];
const _hoisted_183 = { class: "property-row" };
const _hoisted_184 = ["value"];
const _hoisted_185 = { class: "property-row checkbox-row" };
const _hoisted_186 = ["checked"];
const _hoisted_187 = {
  key: 0,
  class: "property-row"
};
const _hoisted_188 = ["value"];
const _hoisted_189 = { class: "value-display" };
const _hoisted_190 = { class: "property-row checkbox-row" };
const _hoisted_191 = ["checked"];
const _hoisted_192 = {
  key: 1,
  class: "property-row"
};
const _hoisted_193 = ["value"];
const _hoisted_194 = { class: "value-display" };
const _hoisted_195 = {
  key: 2,
  class: "property-row"
};
const _hoisted_196 = ["value"];
const _hoisted_197 = { class: "value-display" };
const _hoisted_198 = { class: "property-row checkbox-row" };
const _hoisted_199 = ["checked"];
const _hoisted_200 = {
  key: 3,
  class: "property-row"
};
const _hoisted_201 = ["value"];
const _hoisted_202 = { class: "value-display" };
const _hoisted_203 = {
  key: 4,
  class: "property-row"
};
const _hoisted_204 = ["value"];
const _hoisted_205 = { class: "value-display" };
const _hoisted_206 = {
  key: 5,
  class: "property-row"
};
const _hoisted_207 = ["value"];
const _hoisted_208 = { class: "value-display" };
const _hoisted_209 = {
  key: 6,
  class: "property-row"
};
const _hoisted_210 = ["value"];
const _hoisted_211 = { class: "value-display" };
const _hoisted_212 = {
  key: 7,
  class: "property-row checkbox-row"
};
const _hoisted_213 = ["checked"];
const _hoisted_214 = { class: "particle-count" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const expandedSections = ref(/* @__PURE__ */ new Set(["system", "emitters"]));
    const expandedEmitters = ref(/* @__PURE__ */ new Set());
    const forceTab = ref("wells");
    const layerData = computed(() => {
      const data = props.layer.data;
      return data || {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
    });
    const systemConfig = computed(() => layerData.value.systemConfig);
    const emitters = computed(() => layerData.value.emitters);
    const gravityWells = computed(() => layerData.value.gravityWells);
    const vortices = computed(() => layerData.value.vortices);
    const modulations = computed(() => layerData.value.modulations);
    const renderOptions = computed(() => layerData.value.renderOptions);
    const turbulenceFields = computed(() => layerData.value.turbulenceFields || []);
    const subEmitters = computed(() => layerData.value.subEmitters || []);
    const connections = computed(() => renderOptions.value.connections || {
      enabled: false,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: true
    });
    const particleCount = computed(() => props.particleCount);
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleEmitter(id) {
      if (expandedEmitters.value.has(id)) {
        expandedEmitters.value.delete(id);
      } else {
        expandedEmitters.value.add(id);
      }
    }
    function updateSystemConfig(key, value) {
      emit("update", {
        systemConfig: { ...systemConfig.value, [key]: value }
      });
    }
    function updateEmitter(id, key, value) {
      const updated = emitters.value.map(
        (e) => e.id === id ? { ...e, [key]: value } : e
      );
      emit("update", { emitters: updated });
    }
    function updateEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateEmitter(id, "color", rgb);
    }
    function addEmitter() {
      const newEmitter = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${emitters.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: true,
        burstOnBeat: false,
        burstCount: 20
      };
      emit("update", { emitters: [...emitters.value, newEmitter] });
      expandedEmitters.value.add(newEmitter.id);
    }
    function removeEmitter(id) {
      emit("update", { emitters: emitters.value.filter((e) => e.id !== id) });
    }
    function updateGravityWell(id, key, value) {
      const updated = gravityWells.value.map(
        (w) => w.id === id ? { ...w, [key]: value } : w
      );
      emit("update", { gravityWells: updated });
    }
    function addGravityWell() {
      const newWell = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${gravityWells.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: true
      };
      emit("update", { gravityWells: [...gravityWells.value, newWell] });
    }
    function removeGravityWell(id) {
      emit("update", { gravityWells: gravityWells.value.filter((w) => w.id !== id) });
    }
    function updateVortex(id, key, value) {
      const updated = vortices.value.map(
        (v) => v.id === id ? { ...v, [key]: value } : v
      );
      emit("update", { vortices: updated });
    }
    function addVortex() {
      const newVortex = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${vortices.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: true
      };
      emit("update", { vortices: [...vortices.value, newVortex] });
    }
    function removeVortex(id) {
      emit("update", { vortices: vortices.value.filter((v) => v.id !== id) });
    }
    function updateModulation(id, key, value) {
      const updated = modulations.value.map(
        (m) => m.id === id ? { ...m, [key]: value } : m
      );
      emit("update", { modulations: updated });
    }
    function addModulation() {
      const newMod = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      emit("update", { modulations: [...modulations.value, newMod] });
    }
    function removeModulation(id) {
      emit("update", { modulations: modulations.value.filter((m) => m.id !== id) });
    }
    function updateRenderOption(key, value) {
      emit("update", {
        renderOptions: { ...renderOptions.value, [key]: value }
      });
    }
    function updateConnection(key, value) {
      emit("update", {
        renderOptions: {
          ...renderOptions.value,
          connections: { ...connections.value, [key]: value }
        }
      });
    }
    function updateTurbulence(id, key, value) {
      const updated = turbulenceFields.value.map(
        (t) => t.id === id ? { ...t, [key]: value } : t
      );
      emit("update", { turbulenceFields: updated });
    }
    function addTurbulence() {
      const newTurb = {
        id: `turb_${Date.now()}`,
        enabled: true,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      emit("update", { turbulenceFields: [...turbulenceFields.value, newTurb] });
    }
    function removeTurbulence(id) {
      emit("update", { turbulenceFields: turbulenceFields.value.filter((t) => t.id !== id) });
    }
    function updateSubEmitter(id, key, value) {
      const updated = subEmitters.value.map(
        (s) => s.id === id ? { ...s, [key]: value } : s
      );
      emit("update", { subEmitters: updated });
    }
    function updateSubEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateSubEmitter(id, "color", rgb);
    }
    function addSubEmitter() {
      const newSub = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: true
      };
      emit("update", { subEmitters: [...subEmitters.value, newSub] });
    }
    function removeSubEmitter(id) {
      emit("update", { subEmitters: subEmitters.value.filter((s) => s.id !== id) });
    }
    function rgbToHex(rgb) {
      return "#" + rgb.map((c) => c.toString(16).padStart(2, "0")).join("");
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        createBaseVNode("div", _hoisted_2$o, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("system"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[30] || (_cache[30] = createBaseVNode("span", null, "System Settings", -1))
          ]),
          expandedSections.value.has("system") ? (openBlock(), createElementBlock("div", _hoisted_3$o, [
            createBaseVNode("div", _hoisted_4$o, [
              _cache[31] || (_cache[31] = createBaseVNode("label", null, "Max Particles", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.maxParticles,
                min: "100",
                max: "50000",
                step: "100",
                onInput: _cache[1] || (_cache[1] = ($event) => updateSystemConfig("maxParticles", Number($event.target.value)))
              }, null, 40, _hoisted_5$o),
              createBaseVNode("span", _hoisted_6$o, toDisplayString(systemConfig.value.maxParticles), 1)
            ]),
            createBaseVNode("div", _hoisted_7$o, [
              _cache[32] || (_cache[32] = createBaseVNode("label", null, "Gravity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.gravity,
                min: "-1000",
                max: "1000",
                step: "10",
                onInput: _cache[2] || (_cache[2] = ($event) => updateSystemConfig("gravity", Number($event.target.value)))
              }, null, 40, _hoisted_8$m),
              createBaseVNode("span", _hoisted_9$l, toDisplayString(systemConfig.value.gravity), 1)
            ]),
            createBaseVNode("div", _hoisted_10$l, [
              _cache[33] || (_cache[33] = createBaseVNode("label", null, "Wind Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windStrength,
                min: "0",
                max: "1000",
                step: "10",
                onInput: _cache[3] || (_cache[3] = ($event) => updateSystemConfig("windStrength", Number($event.target.value)))
              }, null, 40, _hoisted_11$k),
              createBaseVNode("span", _hoisted_12$i, toDisplayString(systemConfig.value.windStrength), 1)
            ]),
            createBaseVNode("div", _hoisted_13$h, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Wind Direction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windDirection,
                min: "0",
                max: "360",
                step: "5",
                onInput: _cache[4] || (_cache[4] = ($event) => updateSystemConfig("windDirection", Number($event.target.value)))
              }, null, 40, _hoisted_14$g),
              createBaseVNode("span", _hoisted_15$g, toDisplayString(systemConfig.value.windDirection) + "", 1)
            ]),
            createBaseVNode("div", _hoisted_16$g, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Friction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.friction,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[5] || (_cache[5] = ($event) => updateSystemConfig("friction", Number($event.target.value)))
              }, null, 40, _hoisted_17$g),
              createBaseVNode("span", _hoisted_18$g, toDisplayString(systemConfig.value.friction.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_19$e, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Boundary", -1)),
              createBaseVNode("select", {
                value: systemConfig.value.boundaryBehavior,
                onChange: _cache[6] || (_cache[6] = ($event) => updateSystemConfig("boundaryBehavior", $event.target.value))
              }, [..._cache[36] || (_cache[36] = [
                createBaseVNode("option", { value: "kill" }, "Kill", -1),
                createBaseVNode("option", { value: "bounce" }, "Bounce", -1),
                createBaseVNode("option", { value: "wrap" }, "Wrap", -1)
              ])], 40, _hoisted_20$e)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_21$d, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("emitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[39] || (_cache[39] = createBaseVNode("span", null, "Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addEmitter, ["stop"]),
              title: "Add Emitter"
            }, [..._cache[38] || (_cache[38] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("emitters") ? (openBlock(), createElementBlock("div", _hoisted_22$c, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (emitter) => {
              return openBlock(), createElementBlock("div", {
                key: emitter.id,
                class: "emitter-item"
              }, [
                createBaseVNode("div", {
                  class: "emitter-header",
                  onClick: ($event) => toggleEmitter(emitter.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedEmitters.value.has(emitter.id) ? "pi-chevron-down" : "pi-chevron-right"])
                  }, null, 2),
                  createBaseVNode("input", {
                    type: "text",
                    value: emitter.name,
                    onInput: ($event) => updateEmitter(emitter.id, "name", $event.target.value),
                    onClick: _cache[8] || (_cache[8] = withModifiers(() => {
                    }, ["stop"])),
                    class: "emitter-name"
                  }, null, 40, _hoisted_24$a),
                  createBaseVNode("label", _hoisted_25$a, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: emitter.enabled,
                      onChange: ($event) => updateEmitter(emitter.id, "enabled", $event.target.checked),
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 40, _hoisted_26$a)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: withModifiers(($event) => removeEmitter(emitter.id), ["stop"]),
                    title: "Remove"
                  }, [..._cache[40] || (_cache[40] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_27$a)
                ], 8, _hoisted_23$c),
                expandedEmitters.value.has(emitter.id) ? (openBlock(), createElementBlock("div", _hoisted_28$a, [
                  createBaseVNode("div", _hoisted_29$a, [
                    _cache[41] || (_cache[41] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_30$a),
                    createBaseVNode("span", _hoisted_31$7, toDisplayString(emitter.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$7, [
                    _cache[42] || (_cache[42] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_33$7),
                    createBaseVNode("span", _hoisted_34$7, toDisplayString(emitter.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$7, [
                    _cache[43] || (_cache[43] = createBaseVNode("label", null, "Direction", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.direction,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "direction", Number($event.target.value))
                    }, null, 40, _hoisted_36$7),
                    createBaseVNode("span", _hoisted_37$7, toDisplayString(emitter.direction) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$6, [
                    _cache[44] || (_cache[44] = createBaseVNode("label", null, "Spread", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.spread,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "spread", Number($event.target.value))
                    }, null, 40, _hoisted_39$6),
                    createBaseVNode("span", _hoisted_40$5, toDisplayString(emitter.spread) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_41$5, [
                    _cache[45] || (_cache[45] = createBaseVNode("label", null, "Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speed,
                      min: "1",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speed", Number($event.target.value))
                    }, null, 40, _hoisted_42$4),
                    createBaseVNode("span", _hoisted_43$4, toDisplayString(emitter.speed), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$4, [
                    _cache[46] || (_cache[46] = createBaseVNode("label", null, "Speed Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speedVariance,
                      min: "0",
                      max: "500",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speedVariance", Number($event.target.value))
                    }, null, 40, _hoisted_45$4),
                    createBaseVNode("span", _hoisted_46$4, toDisplayString(emitter.speedVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$4, [
                    _cache[47] || (_cache[47] = createBaseVNode("label", null, "Size", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.size,
                      min: "1",
                      max: "400",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "size", Number($event.target.value))
                    }, null, 40, _hoisted_48$4),
                    createBaseVNode("span", _hoisted_49$4, toDisplayString(emitter.size) + "px", 1)
                  ]),
                  createBaseVNode("div", _hoisted_50$3, [
                    _cache[48] || (_cache[48] = createBaseVNode("label", null, "Size Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.sizeVariance,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "sizeVariance", Number($event.target.value))
                    }, null, 40, _hoisted_51$3),
                    createBaseVNode("span", _hoisted_52$3, toDisplayString(emitter.sizeVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_53$3, [
                    _cache[49] || (_cache[49] = createBaseVNode("label", null, "Color", -1)),
                    createBaseVNode("input", {
                      type: "color",
                      value: rgbToHex(emitter.color),
                      onInput: ($event) => updateEmitterColor(emitter.id, $event.target.value)
                    }, null, 40, _hoisted_54$3)
                  ]),
                  createBaseVNode("div", _hoisted_55$3, [
                    _cache[50] || (_cache[50] = createBaseVNode("label", null, "Emission Rate", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.emissionRate,
                      min: "0.1",
                      max: "100",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "emissionRate", Number($event.target.value))
                    }, null, 40, _hoisted_56$3),
                    createBaseVNode("span", _hoisted_57$3, toDisplayString(emitter.emissionRate.toFixed(1)) + "/s", 1)
                  ]),
                  createBaseVNode("div", _hoisted_58$3, [
                    _cache[51] || (_cache[51] = createBaseVNode("label", null, "Lifetime", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.particleLifetime,
                      min: "1",
                      max: "300",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "particleLifetime", Number($event.target.value))
                    }, null, 40, _hoisted_59$3),
                    createBaseVNode("span", _hoisted_60$3, toDisplayString(emitter.particleLifetime) + "f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_61$3, [
                    _cache[52] || (_cache[52] = createBaseVNode("label", null, "Initial Burst", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.initialBurst,
                      min: "0",
                      max: "1",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "initialBurst", Number($event.target.value))
                    }, null, 40, _hoisted_62$3),
                    createBaseVNode("span", _hoisted_63$2, toDisplayString((emitter.initialBurst * 100).toFixed(0)) + "%", 1)
                  ]),
                  createBaseVNode("div", _hoisted_64$2, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.burstOnBeat,
                        onChange: ($event) => updateEmitter(emitter.id, "burstOnBeat", $event.target.checked)
                      }, null, 40, _hoisted_65$2),
                      _cache[53] || (_cache[53] = createTextVNode(" Burst on Beat ", -1))
                    ])
                  ]),
                  emitter.burstOnBeat ? (openBlock(), createElementBlock("div", _hoisted_66$2, [
                    _cache[54] || (_cache[54] = createBaseVNode("label", null, "Burst Count", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.burstCount,
                      min: "1",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "burstCount", Number($event.target.value))
                    }, null, 40, _hoisted_67$2),
                    createBaseVNode("span", _hoisted_68$2, toDisplayString(emitter.burstCount), 1)
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            emitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_69$2, " No emitters. Click + to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_70$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("forces"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[55] || (_cache[55] = createBaseVNode("span", null, "Force Fields", -1))
          ]),
          expandedSections.value.has("forces") ? (openBlock(), createElementBlock("div", _hoisted_71$2, [
            createBaseVNode("div", _hoisted_72$2, [
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "wells" }),
                onClick: _cache[11] || (_cache[11] = ($event) => forceTab.value = "wells")
              }, " Gravity Wells ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "vortices" }),
                onClick: _cache[12] || (_cache[12] = ($event) => forceTab.value = "vortices")
              }, " Vortices ", 2)
            ]),
            forceTab.value === "wells" ? (openBlock(), createElementBlock("div", _hoisted_73$2, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addGravityWell
              }, [..._cache[56] || (_cache[56] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Gravity Well ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(gravityWells.value, (well) => {
                return openBlock(), createElementBlock("div", {
                  key: well.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_74$2, [
                    createBaseVNode("input", {
                      type: "text",
                      value: well.name,
                      onInput: ($event) => updateGravityWell(well.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_75$2),
                    createBaseVNode("label", _hoisted_76$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: well.enabled,
                        onChange: ($event) => updateGravityWell(well.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_77$2)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeGravityWell(well.id)
                    }, [..._cache[57] || (_cache[57] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_78$2)
                  ]),
                  createBaseVNode("div", _hoisted_79$1, [
                    _cache[58] || (_cache[58] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_80$1),
                    createBaseVNode("span", _hoisted_81$1, toDisplayString(well.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_82$1, [
                    _cache[59] || (_cache[59] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_83$1),
                    createBaseVNode("span", _hoisted_84$1, toDisplayString(well.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_85$1, [
                    _cache[60] || (_cache[60] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.strength,
                      min: "-1000",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateGravityWell(well.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_86$1),
                    createBaseVNode("span", _hoisted_87$1, toDisplayString(well.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_88$1, [
                    _cache[61] || (_cache[61] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_89$1),
                    createBaseVNode("span", _hoisted_90$1, toDisplayString(well.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_91$1, [
                    _cache[63] || (_cache[63] = createBaseVNode("label", null, "Falloff", -1)),
                    createBaseVNode("select", {
                      value: well.falloff,
                      onChange: ($event) => updateGravityWell(well.id, "falloff", $event.target.value)
                    }, [..._cache[62] || (_cache[62] = [
                      createBaseVNode("option", { value: "linear" }, "Linear", -1),
                      createBaseVNode("option", { value: "quadratic" }, "Quadratic", -1),
                      createBaseVNode("option", { value: "constant" }, "Constant", -1)
                    ])], 40, _hoisted_92$1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            forceTab.value === "vortices" ? (openBlock(), createElementBlock("div", _hoisted_93$1, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addVortex
              }, [..._cache[64] || (_cache[64] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Vortex ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(vortices.value, (vortex) => {
                return openBlock(), createElementBlock("div", {
                  key: vortex.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_94$1, [
                    createBaseVNode("input", {
                      type: "text",
                      value: vortex.name,
                      onInput: ($event) => updateVortex(vortex.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_95),
                    createBaseVNode("label", _hoisted_96, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: vortex.enabled,
                        onChange: ($event) => updateVortex(vortex.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_97)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeVortex(vortex.id)
                    }, [..._cache[65] || (_cache[65] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_98)
                  ]),
                  createBaseVNode("div", _hoisted_99, [
                    _cache[66] || (_cache[66] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_100),
                    createBaseVNode("span", _hoisted_101, toDisplayString(vortex.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_102, [
                    _cache[67] || (_cache[67] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_103),
                    createBaseVNode("span", _hoisted_104, toDisplayString(vortex.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_105, [
                    _cache[68] || (_cache[68] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.strength,
                      min: "0",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateVortex(vortex.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_106),
                    createBaseVNode("span", _hoisted_107, toDisplayString(vortex.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_108, [
                    _cache[69] || (_cache[69] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_109),
                    createBaseVNode("span", _hoisted_110, toDisplayString(vortex.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_111, [
                    _cache[70] || (_cache[70] = createBaseVNode("label", null, "Rotation Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.rotationSpeed,
                      min: "0",
                      max: "50",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "rotationSpeed", Number($event.target.value))
                    }, null, 40, _hoisted_112),
                    createBaseVNode("span", _hoisted_113, toDisplayString(vortex.rotationSpeed) + "/f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_114, [
                    _cache[71] || (_cache[71] = createBaseVNode("label", null, "Inward Pull", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.inwardPull,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "inwardPull", Number($event.target.value))
                    }, null, 40, _hoisted_115),
                    createBaseVNode("span", _hoisted_116, toDisplayString(vortex.inwardPull), 1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_117, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("turbulence"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[73] || (_cache[73] = createBaseVNode("span", null, "Turbulence", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addTurbulence, ["stop"]),
              title: "Add Turbulence Field"
            }, [..._cache[72] || (_cache[72] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("turbulence") ? (openBlock(), createElementBlock("div", _hoisted_118, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(turbulenceFields.value, (turb) => {
              return openBlock(), createElementBlock("div", {
                key: turb.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_119, [
                  _cache[75] || (_cache[75] = createBaseVNode("span", { class: "force-label" }, "Turbulence Field", -1)),
                  createBaseVNode("label", _hoisted_120, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: turb.enabled,
                      onChange: ($event) => updateTurbulence(turb.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_121)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeTurbulence(turb.id)
                  }, [..._cache[74] || (_cache[74] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_122)
                ]),
                createBaseVNode("div", _hoisted_123, [
                  _cache[76] || (_cache[76] = createBaseVNode("label", null, "Scale", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.scale,
                    min: "0.001",
                    max: "0.02",
                    step: "0.001",
                    onInput: ($event) => updateTurbulence(turb.id, "scale", Number($event.target.value))
                  }, null, 40, _hoisted_124),
                  createBaseVNode("span", _hoisted_125, toDisplayString(turb.scale.toFixed(3)), 1)
                ]),
                createBaseVNode("div", _hoisted_126, [
                  _cache[77] || (_cache[77] = createBaseVNode("label", null, "Strength", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.strength,
                    min: "0",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateTurbulence(turb.id, "strength", Number($event.target.value))
                  }, null, 40, _hoisted_127),
                  createBaseVNode("span", _hoisted_128, toDisplayString(turb.strength), 1)
                ]),
                createBaseVNode("div", _hoisted_129, [
                  _cache[78] || (_cache[78] = createBaseVNode("label", null, "Evolution", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.evolutionSpeed,
                    min: "0",
                    max: "1",
                    step: "0.01",
                    onInput: ($event) => updateTurbulence(turb.id, "evolutionSpeed", Number($event.target.value))
                  }, null, 40, _hoisted_130),
                  createBaseVNode("span", _hoisted_131, toDisplayString(turb.evolutionSpeed.toFixed(2)), 1)
                ])
              ]);
            }), 128)),
            turbulenceFields.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_132, " No turbulence fields. Add one for organic particle motion. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_133, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("subEmitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[80] || (_cache[80] = createBaseVNode("span", null, "Sub-Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addSubEmitter, ["stop"]),
              title: "Add Sub-Emitter"
            }, [..._cache[79] || (_cache[79] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("subEmitters") ? (openBlock(), createElementBlock("div", _hoisted_134, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(subEmitters.value, (sub) => {
              return openBlock(), createElementBlock("div", {
                key: sub.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_135, [
                  createBaseVNode("select", {
                    value: sub.parentEmitterId,
                    onChange: ($event) => updateSubEmitter(sub.id, "parentEmitterId", $event.target.value),
                    class: "sub-emitter-parent"
                  }, [
                    _cache[81] || (_cache[81] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_137);
                    }), 128))
                  ], 40, _hoisted_136),
                  createBaseVNode("label", _hoisted_138, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: sub.enabled,
                      onChange: ($event) => updateSubEmitter(sub.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_139)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeSubEmitter(sub.id)
                  }, [..._cache[82] || (_cache[82] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_140)
                ]),
                createBaseVNode("div", _hoisted_141, [
                  _cache[84] || (_cache[84] = createBaseVNode("label", null, "Trigger", -1)),
                  createBaseVNode("select", {
                    value: sub.trigger,
                    onChange: ($event) => updateSubEmitter(sub.id, "trigger", $event.target.value)
                  }, [..._cache[83] || (_cache[83] = [
                    createBaseVNode("option", { value: "death" }, "On Death", -1)
                  ])], 40, _hoisted_142)
                ]),
                createBaseVNode("div", _hoisted_143, [
                  _cache[85] || (_cache[85] = createBaseVNode("label", null, "Spawn Count", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spawnCount,
                    min: "1",
                    max: "10",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "spawnCount", Number($event.target.value))
                  }, null, 40, _hoisted_144),
                  createBaseVNode("span", _hoisted_145, toDisplayString(sub.spawnCount), 1)
                ]),
                createBaseVNode("div", _hoisted_146, [
                  _cache[86] || (_cache[86] = createBaseVNode("label", null, "Inherit Velocity", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.inheritVelocity,
                    min: "0",
                    max: "1",
                    step: "0.1",
                    onInput: ($event) => updateSubEmitter(sub.id, "inheritVelocity", Number($event.target.value))
                  }, null, 40, _hoisted_147),
                  createBaseVNode("span", _hoisted_148, toDisplayString((sub.inheritVelocity * 100).toFixed(0)) + "%", 1)
                ]),
                createBaseVNode("div", _hoisted_149, [
                  _cache[87] || (_cache[87] = createBaseVNode("label", null, "Size", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.size,
                    min: "1",
                    max: "100",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "size", Number($event.target.value))
                  }, null, 40, _hoisted_150),
                  createBaseVNode("span", _hoisted_151, toDisplayString(sub.size) + "px", 1)
                ]),
                createBaseVNode("div", _hoisted_152, [
                  _cache[88] || (_cache[88] = createBaseVNode("label", null, "Lifetime", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.lifetime,
                    min: "1",
                    max: "120",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "lifetime", Number($event.target.value))
                  }, null, 40, _hoisted_153),
                  createBaseVNode("span", _hoisted_154, toDisplayString(sub.lifetime) + "f", 1)
                ]),
                createBaseVNode("div", _hoisted_155, [
                  _cache[89] || (_cache[89] = createBaseVNode("label", null, "Speed", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.speed,
                    min: "1",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateSubEmitter(sub.id, "speed", Number($event.target.value))
                  }, null, 40, _hoisted_156),
                  createBaseVNode("span", _hoisted_157, toDisplayString(sub.speed), 1)
                ]),
                createBaseVNode("div", _hoisted_158, [
                  _cache[90] || (_cache[90] = createBaseVNode("label", null, "Spread", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spread,
                    min: "0",
                    max: "360",
                    step: "5",
                    onInput: ($event) => updateSubEmitter(sub.id, "spread", Number($event.target.value))
                  }, null, 40, _hoisted_159),
                  createBaseVNode("span", _hoisted_160, toDisplayString(sub.spread) + "", 1)
                ]),
                createBaseVNode("div", _hoisted_161, [
                  _cache[91] || (_cache[91] = createBaseVNode("label", null, "Color", -1)),
                  createBaseVNode("input", {
                    type: "color",
                    value: rgbToHex(sub.color),
                    onInput: ($event) => updateSubEmitterColor(sub.id, $event.target.value)
                  }, null, 40, _hoisted_162)
                ])
              ]);
            }), 128)),
            subEmitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_163, " No sub-emitters. Add one for particle death effects. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_164, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[15] || (_cache[15] = ($event) => toggleSection("modulations"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[93] || (_cache[93] = createBaseVNode("span", null, "Modulations", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addModulation, ["stop"]),
              title: "Add Modulation"
            }, [..._cache[92] || (_cache[92] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("modulations") ? (openBlock(), createElementBlock("div", _hoisted_165, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(modulations.value, (mod) => {
              return openBlock(), createElementBlock("div", {
                key: mod.id,
                class: "modulation-item"
              }, [
                createBaseVNode("div", _hoisted_166, [
                  createBaseVNode("select", {
                    value: mod.emitterId,
                    onChange: ($event) => updateModulation(mod.id, "emitterId", $event.target.value)
                  }, [
                    _cache[94] || (_cache[94] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_168);
                    }), 128))
                  ], 40, _hoisted_167),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeModulation(mod.id)
                  }, [..._cache[95] || (_cache[95] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_169)
                ]),
                createBaseVNode("div", _hoisted_170, [
                  _cache[97] || (_cache[97] = createBaseVNode("label", null, "Property", -1)),
                  createBaseVNode("select", {
                    value: mod.property,
                    onChange: ($event) => updateModulation(mod.id, "property", $event.target.value)
                  }, [..._cache[96] || (_cache[96] = [
                    createStaticVNode('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
                  ])], 40, _hoisted_171)
                ]),
                createBaseVNode("div", _hoisted_172, [
                  _cache[98] || (_cache[98] = createBaseVNode("label", null, "Start Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.startValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "startValue", Number($event.target.value))
                  }, null, 40, _hoisted_173)
                ]),
                createBaseVNode("div", _hoisted_174, [
                  _cache[99] || (_cache[99] = createBaseVNode("label", null, "End Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.endValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "endValue", Number($event.target.value))
                  }, null, 40, _hoisted_175)
                ]),
                createBaseVNode("div", _hoisted_176, [
                  _cache[101] || (_cache[101] = createBaseVNode("label", null, "Easing", -1)),
                  createBaseVNode("select", {
                    value: mod.easing,
                    onChange: ($event) => updateModulation(mod.id, "easing", $event.target.value)
                  }, [..._cache[100] || (_cache[100] = [
                    createStaticVNode('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
                  ])], 40, _hoisted_177)
                ])
              ]);
            }), 128)),
            modulations.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_178, " No modulations. Add one to animate particle properties over lifetime. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_179, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[16] || (_cache[16] = ($event) => toggleSection("render"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[102] || (_cache[102] = createBaseVNode("span", null, "Render Options", -1))
          ]),
          expandedSections.value.has("render") ? (openBlock(), createElementBlock("div", _hoisted_180, [
            createBaseVNode("div", _hoisted_181, [
              _cache[104] || (_cache[104] = createBaseVNode("label", null, "Blend Mode", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.blendMode,
                onChange: _cache[17] || (_cache[17] = ($event) => updateRenderOption("blendMode", $event.target.value))
              }, [..._cache[103] || (_cache[103] = [
                createBaseVNode("option", { value: "normal" }, "Normal", -1),
                createBaseVNode("option", { value: "additive" }, "Additive", -1),
                createBaseVNode("option", { value: "multiply" }, "Multiply", -1),
                createBaseVNode("option", { value: "screen" }, "Screen", -1)
              ])], 40, _hoisted_182)
            ]),
            createBaseVNode("div", _hoisted_183, [
              _cache[106] || (_cache[106] = createBaseVNode("label", null, "Shape", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.particleShape,
                onChange: _cache[18] || (_cache[18] = ($event) => updateRenderOption("particleShape", $event.target.value))
              }, [..._cache[105] || (_cache[105] = [
                createBaseVNode("option", { value: "circle" }, "Circle", -1),
                createBaseVNode("option", { value: "square" }, "Square", -1),
                createBaseVNode("option", { value: "triangle" }, "Triangle", -1),
                createBaseVNode("option", { value: "star" }, "Star", -1)
              ])], 40, _hoisted_184)
            ]),
            createBaseVNode("div", _hoisted_185, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.renderTrails,
                  onChange: _cache[19] || (_cache[19] = ($event) => updateRenderOption("renderTrails", $event.target.checked))
                }, null, 40, _hoisted_186),
                _cache[107] || (_cache[107] = createTextVNode(" Render Trails ", -1))
              ])
            ]),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_187, [
              _cache[108] || (_cache[108] = createBaseVNode("label", null, "Trail Length", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailLength,
                min: "1",
                max: "20",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateRenderOption("trailLength", Number($event.target.value)))
              }, null, 40, _hoisted_188),
              createBaseVNode("span", _hoisted_189, toDisplayString(renderOptions.value.trailLength), 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_190, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.glowEnabled,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateRenderOption("glowEnabled", $event.target.checked))
                }, null, 40, _hoisted_191),
                _cache[109] || (_cache[109] = createTextVNode(" Enable Glow ", -1))
              ])
            ]),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_192, [
              _cache[110] || (_cache[110] = createBaseVNode("label", null, "Glow Radius", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowRadius,
                min: "1",
                max: "50",
                step: "1",
                onInput: _cache[22] || (_cache[22] = ($event) => updateRenderOption("glowRadius", Number($event.target.value)))
              }, null, 40, _hoisted_193),
              createBaseVNode("span", _hoisted_194, toDisplayString(renderOptions.value.glowRadius) + "px", 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_195, [
              _cache[111] || (_cache[111] = createBaseVNode("label", null, "Glow Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowIntensity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[23] || (_cache[23] = ($event) => updateRenderOption("glowIntensity", Number($event.target.value)))
              }, null, 40, _hoisted_196),
              createBaseVNode("span", _hoisted_197, toDisplayString(renderOptions.value.glowIntensity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            _cache[118] || (_cache[118] = createBaseVNode("div", { class: "subsection-divider" }, "Particle Connections", -1)),
            createBaseVNode("div", _hoisted_198, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.enabled,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConnection("enabled", $event.target.checked))
                }, null, 40, _hoisted_199),
                _cache[112] || (_cache[112] = createTextVNode(" Enable Connections ", -1))
              ])
            ]),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_200, [
              _cache[113] || (_cache[113] = createBaseVNode("label", null, "Max Distance", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxDistance,
                min: "10",
                max: "300",
                step: "10",
                onInput: _cache[25] || (_cache[25] = ($event) => updateConnection("maxDistance", Number($event.target.value)))
              }, null, 40, _hoisted_201),
              createBaseVNode("span", _hoisted_202, toDisplayString(connections.value.maxDistance) + "px", 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_203, [
              _cache[114] || (_cache[114] = createBaseVNode("label", null, "Max Connections", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxConnections,
                min: "1",
                max: "5",
                step: "1",
                onInput: _cache[26] || (_cache[26] = ($event) => updateConnection("maxConnections", Number($event.target.value)))
              }, null, 40, _hoisted_204),
              createBaseVNode("span", _hoisted_205, toDisplayString(connections.value.maxConnections), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_206, [
              _cache[115] || (_cache[115] = createBaseVNode("label", null, "Line Width", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineWidth,
                min: "0.5",
                max: "3",
                step: "0.1",
                onInput: _cache[27] || (_cache[27] = ($event) => updateConnection("lineWidth", Number($event.target.value)))
              }, null, 40, _hoisted_207),
              createBaseVNode("span", _hoisted_208, toDisplayString(connections.value.lineWidth.toFixed(1)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_209, [
              _cache[116] || (_cache[116] = createBaseVNode("label", null, "Line Opacity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineOpacity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[28] || (_cache[28] = ($event) => updateConnection("lineOpacity", Number($event.target.value)))
              }, null, 40, _hoisted_210),
              createBaseVNode("span", _hoisted_211, toDisplayString(connections.value.lineOpacity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_212, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.fadeByDistance,
                  onChange: _cache[29] || (_cache[29] = ($event) => updateConnection("fadeByDistance", $event.target.checked))
                }, null, 40, _hoisted_213),
                _cache[117] || (_cache[117] = createTextVNode(" Fade by Distance ", -1))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_214, [
          _cache[119] || (_cache[119] = createBaseVNode("i", { class: "pi pi-circle-fill" }, null, -1)),
          createBaseVNode("span", null, toDisplayString(particleCount.value) + " particles", 1)
        ])
      ]);
    };
  }
});

const ParticleProperties = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-60b9bdc8"]]);

const _hoisted_1$o = ["title"];
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const hasKeyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return false;
      return props.property.keyframes.some((k) => k.frame === store.currentFrame);
    });
    const keyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return null;
      return props.property.keyframes.find((k) => k.frame === store.currentFrame) || null;
    });
    const iconClass = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "pi-circle-fill";
      }
      if (props.property.animated) {
        return "pi-circle";
      }
      return "pi-stopwatch";
    });
    const buttonTitle = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "Remove keyframe at current frame";
      }
      if (props.property.animated) {
        return "Add keyframe at current frame";
      }
      return "Enable animation (add keyframe)";
    });
    function toggleKeyframe() {
      if (hasKeyframeAtCurrentFrame.value) {
        removeKeyframe();
      } else {
        addKeyframe();
      }
    }
    function addKeyframe() {
      const defaultHandle = { frame: 0, value: 0, enabled: false };
      const newKeyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: store.currentFrame,
        value: props.property.value,
        interpolation: "linear",
        inHandle: { ...defaultHandle },
        outHandle: { ...defaultHandle },
        controlMode: "smooth"
      };
      if (!props.property.animated) {
        props.property.animated = true;
        emit("animationToggled", true);
      }
      props.property.keyframes.push(newKeyframe);
      props.property.keyframes.sort((a, b) => a.frame - b.frame);
      emit("keyframeAdded", newKeyframe);
    }
    function removeKeyframe() {
      const keyframe = keyframeAtCurrentFrame.value;
      if (!keyframe) return;
      const index = props.property.keyframes.findIndex((k) => k.id === keyframe.id);
      if (index >= 0) {
        props.property.keyframes.splice(index, 1);
        emit("keyframeRemoved", keyframe.id);
      }
      if (props.property.keyframes.length === 0) {
        props.property.animated = false;
        emit("animationToggled", false);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["keyframe-toggle", {
          animated: __props.property.animated,
          "has-keyframe": hasKeyframeAtCurrentFrame.value
        }]),
        onClick: toggleKeyframe,
        title: buttonTitle.value
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["pi", iconClass.value])
        }, null, 2)
      ], 10, _hoisted_1$o);
    };
  }
});

const KeyframeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-b9271c8f"]]);

const _hoisted_1$n = { class: "depthflow-properties" };
const _hoisted_2$n = { class: "property-section" };
const _hoisted_3$n = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$n = { class: "property-row" };
const _hoisted_5$n = ["value"];
const _hoisted_6$n = ["value"];
const _hoisted_7$n = { class: "property-row" };
const _hoisted_8$l = ["value"];
const _hoisted_9$k = ["value"];
const _hoisted_10$k = { class: "property-section" };
const _hoisted_11$j = {
  key: 0,
  class: "section-content"
};
const _hoisted_12$h = { class: "preset-grid" };
const _hoisted_13$g = ["onClick"];
const _hoisted_14$f = {
  key: 0,
  class: "property-row"
};
const _hoisted_15$f = ["value"];
const _hoisted_16$f = { class: "value-display" };
const _hoisted_17$f = { class: "property-section" };
const _hoisted_18$f = {
  key: 0,
  class: "section-content"
};
const _hoisted_19$d = { class: "property-row" };
const _hoisted_20$d = ["value"];
const _hoisted_21$c = { class: "value-display" };
const _hoisted_22$b = { class: "property-row" };
const _hoisted_23$b = ["value"];
const _hoisted_24$9 = { class: "value-display" };
const _hoisted_25$9 = { class: "property-row" };
const _hoisted_26$9 = ["value"];
const _hoisted_27$9 = { class: "value-display" };
const _hoisted_28$9 = { class: "property-row" };
const _hoisted_29$9 = ["value"];
const _hoisted_30$9 = { class: "value-display" };
const _hoisted_31$6 = { class: "property-section" };
const _hoisted_32$6 = {
  key: 0,
  class: "section-content"
};
const _hoisted_33$6 = { class: "property-row" };
const _hoisted_34$6 = ["value"];
const _hoisted_35$6 = { class: "value-display" };
const _hoisted_36$6 = { class: "property-row" };
const _hoisted_37$6 = ["value"];
const _hoisted_38$5 = { class: "value-display" };
const _hoisted_39$5 = {
  key: 0,
  class: "property-section"
};
const _hoisted_40$4 = {
  key: 0,
  class: "section-content"
};
const _hoisted_41$4 = { class: "property-row" };
const _hoisted_42$3 = ["value"];
const _hoisted_43$3 = { class: "value-display" };
const _hoisted_44$3 = { class: "property-row" };
const _hoisted_45$3 = ["value"];
const _hoisted_46$3 = { class: "value-display" };
const _hoisted_47$3 = { class: "property-row" };
const _hoisted_48$3 = ["value"];
const _hoisted_49$3 = { class: "value-display" };
const _hoisted_50$2 = { class: "property-row" };
const _hoisted_51$2 = ["value"];
const _hoisted_52$2 = { class: "value-display" };
const _hoisted_53$2 = {
  key: 2,
  class: "property-row"
};
const _hoisted_54$2 = ["value"];
const _hoisted_55$2 = { class: "value-display" };
const _hoisted_56$2 = { class: "property-section" };
const _hoisted_57$2 = {
  key: 0,
  class: "section-content"
};
const _hoisted_58$2 = { class: "property-row" };
const _hoisted_59$2 = ["value"];
const _hoisted_60$2 = { class: "value-display" };
const _hoisted_61$2 = { class: "property-row checkbox-row" };
const _hoisted_62$2 = ["checked"];
const _hoisted_63$1 = { class: "property-section" };
const _hoisted_64$1 = {
  key: 0,
  class: "sync-badge"
};
const _hoisted_65$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_66$1 = { class: "property-row checkbox-row" };
const _hoisted_67$1 = ["checked"];
const _hoisted_68$1 = { class: "property-row" };
const _hoisted_69$1 = ["value"];
const _hoisted_70$1 = ["value"];
const _hoisted_71$1 = { class: "property-row" };
const _hoisted_72$1 = ["value"];
const _hoisted_73$1 = { class: "value-display" };
const _hoisted_74$1 = { class: "property-row" };
const _hoisted_75$1 = ["value"];
const _hoisted_76$1 = { class: "value-display" };
const _hoisted_77$1 = { class: "property-row" };
const _hoisted_78$1 = ["value"];
const _hoisted_79 = { class: "value-display" };
const _hoisted_80 = { class: "property-row" };
const _hoisted_81 = ["value"];
const _hoisted_82 = { class: "value-display" };
const _hoisted_83 = { class: "property-row checkbox-row" };
const _hoisted_84 = ["checked"];
const _hoisted_85 = { style: { "margin-left": "16px" } };
const _hoisted_86 = ["checked"];
const _hoisted_87 = { class: "property-row" };
const _hoisted_88 = ["value"];
const _hoisted_89 = { class: "value-display" };
const _hoisted_90 = { class: "property-section" };
const _hoisted_91 = {
  key: 0,
  class: "section-content"
};
const _hoisted_92 = { class: "preview-container" };
const _hoisted_93 = { class: "preview-controls" };
const _hoisted_94 = { class: "frame-indicator" };
const previewSize = 200;
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const DEFAULT_CAMERA_SYNC_CONFIG = {
      sensitivityX: 0.5,
      sensitivityY: 0.5,
      sensitivityZ: 1e-3,
      sensitivityRotation: 1,
      baseZoom: 1,
      invertX: false,
      invertY: false,
      zoomClamp: { min: 0.5, max: 3 },
      offsetClamp: { min: -1, max: 1 }
    };
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const previewCanvas = ref(null);
    const isPreviewPlaying = ref(false);
    const previewFrame = ref(0);
    const previewAnimationId = ref(null);
    const expandedSections = ref(/* @__PURE__ */ new Set(["source", "preset", "camera"]));
    const presetIntensity = ref(1);
    const presets = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ];
    const config = computed(() => {
      const data = props.layer.data;
      return data || {
        sourceLayerId: "",
        depthLayerId: "",
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        }
      };
    });
    const depthflowConfig = computed(() => config.value.config);
    const totalFrames = computed(() => store.frameCount);
    const imageLayers = computed(
      () => store.layers.filter((l) => l.type === "image" || l.type === "generated")
    );
    const depthLayers = computed(
      () => store.layers.filter((l) => l.type === "depth" || l.type === "generated")
    );
    const cameraLayers = computed(
      () => store.layers.filter((l) => l.type === "camera")
    );
    const cameraSyncConfig = computed(() => {
      return config.value.cameraSyncConfig ?? DEFAULT_CAMERA_SYNC_CONFIG;
    });
    const isOrbitPreset = computed(
      () => ["circle_cw", "circle_ccw"].includes(depthflowConfig.value.preset)
    );
    const isSwingPreset = computed(
      () => ["horizontal_swing", "vertical_swing"].includes(depthflowConfig.value.preset)
    );
    const isDollyPreset = computed(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(depthflowConfig.value.preset)
    );
    const showPresetSettings = computed(
      () => isOrbitPreset.value || isSwingPreset.value || isDollyPreset.value
    );
    const presetSettingsTitle = computed(() => {
      if (isOrbitPreset.value) return "Orbit Settings";
      if (isSwingPreset.value) return "Swing Settings";
      if (isDollyPreset.value) return "Dolly Zoom Settings";
      return "Preset Settings";
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function updateConfig(key, value) {
      emit("update", { [key]: value });
    }
    function updateDepthflowConfig(key, value) {
      emit("update", {
        config: { ...depthflowConfig.value, [key]: value }
      });
    }
    function selectPreset(preset) {
      updateDepthflowConfig("preset", preset);
    }
    function updateCameraSyncConfig(key, value) {
      emit("update", {
        cameraSyncConfig: { ...cameraSyncConfig.value, [key]: value }
      });
    }
    function updatePresetIntensity(intensity) {
      presetIntensity.value = intensity;
      if (isOrbitPreset.value) {
        updateDepthflowConfig("orbitRadius", 0.1 * intensity);
      } else if (isSwingPreset.value) {
        updateDepthflowConfig("swingAmplitude", 0.1 * intensity);
      } else {
        updateDepthflowConfig("depthScale", 1 * intensity);
      }
    }
    function togglePreview() {
      isPreviewPlaying.value = !isPreviewPlaying.value;
      if (isPreviewPlaying.value) {
        playPreview();
      } else {
        if (previewAnimationId.value !== null) {
          cancelAnimationFrame(previewAnimationId.value);
          previewAnimationId.value = null;
        }
      }
    }
    function playPreview() {
      if (!isPreviewPlaying.value) return;
      previewFrame.value = (previewFrame.value + 1) % totalFrames.value;
      renderPreview();
      previewAnimationId.value = requestAnimationFrame(() => {
        setTimeout(playPreview, 1e3 / store.fps);
      });
    }
    function renderPreview() {
      const canvas = previewCanvas.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, previewSize, previewSize);
      ctx.fillStyle = "#333";
      ctx.fillRect(10, 10, previewSize - 20, previewSize - 20);
      ctx.fillStyle = "#666";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Depthflow Preview", previewSize / 2, previewSize / 2);
      ctx.fillText(`Frame ${previewFrame.value}`, previewSize / 2, previewSize / 2 + 16);
    }
    onMounted(() => {
      renderPreview();
    });
    onUnmounted(() => {
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        createBaseVNode("div", _hoisted_2$n, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("source"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Source Selection", -1))
          ]),
          expandedSections.value.has("source") ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
            createBaseVNode("div", _hoisted_4$n, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Source Layer", -1)),
              createBaseVNode("select", {
                value: config.value.sourceLayerId,
                onChange: _cache[1] || (_cache[1] = ($event) => updateConfig("sourceLayerId", $event.target.value))
              }, [
                _cache[34] || (_cache[34] = createBaseVNode("option", { value: "" }, "Select source...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_6$n);
                }), 128))
              ], 40, _hoisted_5$n)
            ]),
            createBaseVNode("div", _hoisted_7$n, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Depth Layer", -1)),
              createBaseVNode("select", {
                value: config.value.depthLayerId,
                onChange: _cache[2] || (_cache[2] = ($event) => updateConfig("depthLayerId", $event.target.value))
              }, [
                _cache[36] || (_cache[36] = createBaseVNode("option", { value: "" }, "Select depth map...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(depthLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_9$k);
                }), 128))
              ], 40, _hoisted_8$l)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_10$k, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[3] || (_cache[3] = ($event) => toggleSection("preset"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[38] || (_cache[38] = createBaseVNode("span", null, "Motion Preset", -1))
          ]),
          expandedSections.value.has("preset") ? (openBlock(), createElementBlock("div", _hoisted_11$j, [
            createBaseVNode("div", _hoisted_12$h, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.value,
                  class: normalizeClass(["preset-btn", { active: depthflowConfig.value.preset === preset.value }]),
                  onClick: ($event) => selectPreset(preset.value)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(preset.icon)
                  }, null, 2),
                  createBaseVNode("span", null, toDisplayString(preset.label), 1)
                ], 10, _hoisted_13$g);
              }), 64))
            ]),
            depthflowConfig.value.preset !== "static" ? (openBlock(), createElementBlock("div", _hoisted_14$f, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: presetIntensity.value,
                min: "0.1",
                max: "2",
                step: "0.1",
                onInput: _cache[4] || (_cache[4] = ($event) => updatePresetIntensity(Number($event.target.value)))
              }, null, 40, _hoisted_15$f),
              createBaseVNode("span", _hoisted_16$f, toDisplayString(presetIntensity.value.toFixed(1)) + "x", 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_17$f, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("camera"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[40] || (_cache[40] = createBaseVNode("span", null, "Camera Controls", -1))
          ]),
          expandedSections.value.has("camera") ? (openBlock(), createElementBlock("div", _hoisted_18$f, [
            createBaseVNode("div", _hoisted_19$d, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Zoom", -1)),
              config.value.animatedZoom ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedZoom,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.zoom,
                min: "0.5",
                max: "2",
                step: "0.01",
                onInput: _cache[6] || (_cache[6] = ($event) => updateDepthflowConfig("zoom", Number($event.target.value)))
              }, null, 40, _hoisted_20$d),
              createBaseVNode("span", _hoisted_21$c, toDisplayString(depthflowConfig.value.zoom.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_22$b, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Offset X", -1)),
              config.value.animatedOffsetX ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetX,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetX,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[7] || (_cache[7] = ($event) => updateDepthflowConfig("offsetX", Number($event.target.value)))
              }, null, 40, _hoisted_23$b),
              createBaseVNode("span", _hoisted_24$9, toDisplayString(depthflowConfig.value.offsetX.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_25$9, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Offset Y", -1)),
              config.value.animatedOffsetY ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetY,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetY,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[8] || (_cache[8] = ($event) => updateDepthflowConfig("offsetY", Number($event.target.value)))
              }, null, 40, _hoisted_26$9),
              createBaseVNode("span", _hoisted_27$9, toDisplayString(depthflowConfig.value.offsetY.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_28$9, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Rotation", -1)),
              config.value.animatedRotation ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedRotation,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.rotation,
                min: "-180",
                max: "180",
                step: "1",
                onInput: _cache[9] || (_cache[9] = ($event) => updateDepthflowConfig("rotation", Number($event.target.value)))
              }, null, 40, _hoisted_29$9),
              createBaseVNode("span", _hoisted_30$9, toDisplayString(depthflowConfig.value.rotation) + "", 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_31$6, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("depth"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[45] || (_cache[45] = createBaseVNode("span", null, "Depth Settings", -1))
          ]),
          expandedSections.value.has("depth") ? (openBlock(), createElementBlock("div", _hoisted_32$6, [
            createBaseVNode("div", _hoisted_33$6, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Depth Scale", -1)),
              config.value.animatedDepthScale ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedDepthScale,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.depthScale,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: _cache[11] || (_cache[11] = ($event) => updateDepthflowConfig("depthScale", Number($event.target.value)))
              }, null, 40, _hoisted_34$6),
              createBaseVNode("span", _hoisted_35$6, toDisplayString(depthflowConfig.value.depthScale.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_36$6, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Focus Depth", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.focusDepth,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[12] || (_cache[12] = ($event) => updateDepthflowConfig("focusDepth", Number($event.target.value)))
              }, null, 40, _hoisted_37$6),
              createBaseVNode("span", _hoisted_38$5, toDisplayString(depthflowConfig.value.focusDepth.toFixed(2)), 1)
            ]),
            _cache[48] || (_cache[48] = createBaseVNode("div", { class: "depth-hint" }, [
              createTextVNode(" Objects at focus depth stay stationary."),
              createBaseVNode("br"),
              createTextVNode(" Closer objects move more, distant objects move less. ")
            ], -1))
          ])) : createCommentVNode("", true)
        ]),
        showPresetSettings.value ? (openBlock(), createElementBlock("div", _hoisted_39$5, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("presetSettings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            createBaseVNode("span", null, toDisplayString(presetSettingsTitle.value), 1)
          ]),
          expandedSections.value.has("presetSettings") ? (openBlock(), createElementBlock("div", _hoisted_40$4, [
            isOrbitPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_41$4, [
                _cache[49] || (_cache[49] = createBaseVNode("label", null, "Orbit Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitRadius,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[14] || (_cache[14] = ($event) => updateDepthflowConfig("orbitRadius", Number($event.target.value)))
                }, null, 40, _hoisted_42$3),
                createBaseVNode("span", _hoisted_43$3, toDisplayString(depthflowConfig.value.orbitRadius.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_44$3, [
                _cache[50] || (_cache[50] = createBaseVNode("label", null, "Orbit Speed", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitSpeed,
                  min: "1",
                  max: "720",
                  step: "1",
                  onInput: _cache[15] || (_cache[15] = ($event) => updateDepthflowConfig("orbitSpeed", Number($event.target.value)))
                }, null, 40, _hoisted_45$3),
                createBaseVNode("span", _hoisted_46$3, toDisplayString(depthflowConfig.value.orbitSpeed) + "", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isSwingPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_47$3, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Amplitude", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingAmplitude,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[16] || (_cache[16] = ($event) => updateDepthflowConfig("swingAmplitude", Number($event.target.value)))
                }, null, 40, _hoisted_48$3),
                createBaseVNode("span", _hoisted_49$3, toDisplayString(depthflowConfig.value.swingAmplitude.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_50$2, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Frequency", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingFrequency,
                  min: "0.1",
                  max: "5",
                  step: "0.1",
                  onInput: _cache[17] || (_cache[17] = ($event) => updateDepthflowConfig("swingFrequency", Number($event.target.value)))
                }, null, 40, _hoisted_51$2),
                createBaseVNode("span", _hoisted_52$2, toDisplayString(depthflowConfig.value.swingFrequency.toFixed(1)) + " Hz", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isDollyPreset.value ? (openBlock(), createElementBlock("div", _hoisted_53$2, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Dolly Rate", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.dollyZoom,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[18] || (_cache[18] = ($event) => updateDepthflowConfig("dollyZoom", Number($event.target.value)))
              }, null, 40, _hoisted_54$2),
              createBaseVNode("span", _hoisted_55$2, toDisplayString(depthflowConfig.value.dollyZoom.toFixed(2)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_56$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[19] || (_cache[19] = ($event) => toggleSection("quality"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[54] || (_cache[54] = createBaseVNode("span", null, "Quality", -1))
          ]),
          expandedSections.value.has("quality") ? (openBlock(), createElementBlock("div", _hoisted_57$2, [
            createBaseVNode("div", _hoisted_58$2, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Edge Dilation", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.edgeDilation,
                min: "0",
                max: "50",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateDepthflowConfig("edgeDilation", Number($event.target.value)))
              }, null, 40, _hoisted_59$2),
              createBaseVNode("span", _hoisted_60$2, toDisplayString(depthflowConfig.value.edgeDilation) + "px", 1)
            ]),
            createBaseVNode("div", _hoisted_61$2, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: depthflowConfig.value.inpaintEdges,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateDepthflowConfig("inpaintEdges", $event.target.checked))
                }, null, 40, _hoisted_62$2),
                _cache[56] || (_cache[56] = createTextVNode(" Inpaint Edges ", -1))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_63$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[22] || (_cache[22] = ($event) => toggleSection("cameraSync"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("cameraSync") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[57] || (_cache[57] = createBaseVNode("span", null, "Camera Sync", -1)),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock("span", _hoisted_64$1, "Active")) : createCommentVNode("", true)
          ]),
          expandedSections.value.has("cameraSync") ? (openBlock(), createElementBlock("div", _hoisted_65$1, [
            createBaseVNode("div", _hoisted_66$1, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: config.value.cameraSyncEnabled ?? false,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateConfig("cameraSyncEnabled", $event.target.checked))
                }, null, 40, _hoisted_67$1),
                _cache[58] || (_cache[58] = createTextVNode(" Enable Camera Sync ", -1))
              ])
            ]),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_68$1, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Camera Layer", -1)),
                createBaseVNode("select", {
                  value: config.value.cameraSyncLayerId ?? "",
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConfig("cameraSyncLayerId", $event.target.value))
                }, [
                  _cache[59] || (_cache[59] = createBaseVNode("option", { value: "" }, "Select camera...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(cameraLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_70$1);
                  }), 128))
                ], 40, _hoisted_69$1)
              ]),
              _cache[68] || (_cache[68] = createBaseVNode("div", { class: "sync-hint" }, " Camera movement will drive parallax. Adjust sensitivity below. ", -1)),
              createBaseVNode("div", _hoisted_71$1, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "X Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityX,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[25] || (_cache[25] = ($event) => updateCameraSyncConfig("sensitivityX", Number($event.target.value)))
                }, null, 40, _hoisted_72$1),
                createBaseVNode("span", _hoisted_73$1, toDisplayString(cameraSyncConfig.value.sensitivityX.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_74$1, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Y Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityY,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[26] || (_cache[26] = ($event) => updateCameraSyncConfig("sensitivityY", Number($event.target.value)))
                }, null, 40, _hoisted_75$1),
                createBaseVNode("span", _hoisted_76$1, toDisplayString(cameraSyncConfig.value.sensitivityY.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_77$1, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Z Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityZ * 1e3,
                  min: "0",
                  max: "10",
                  step: "0.1",
                  onInput: _cache[27] || (_cache[27] = ($event) => updateCameraSyncConfig("sensitivityZ", Number($event.target.value) / 1e3))
                }, null, 40, _hoisted_78$1),
                createBaseVNode("span", _hoisted_79, toDisplayString((cameraSyncConfig.value.sensitivityZ * 1e3).toFixed(1)), 1)
              ]),
              createBaseVNode("div", _hoisted_80, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "Rotation Sens.", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityRotation,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[28] || (_cache[28] = ($event) => updateCameraSyncConfig("sensitivityRotation", Number($event.target.value)))
                }, null, 40, _hoisted_81),
                createBaseVNode("span", _hoisted_82, toDisplayString(cameraSyncConfig.value.sensitivityRotation.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_83, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertX,
                    onChange: _cache[29] || (_cache[29] = ($event) => updateCameraSyncConfig("invertX", $event.target.checked))
                  }, null, 40, _hoisted_84),
                  _cache[65] || (_cache[65] = createTextVNode(" Invert X ", -1))
                ]),
                createBaseVNode("label", _hoisted_85, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertY,
                    onChange: _cache[30] || (_cache[30] = ($event) => updateCameraSyncConfig("invertY", $event.target.checked))
                  }, null, 40, _hoisted_86),
                  _cache[66] || (_cache[66] = createTextVNode(" Invert Y ", -1))
                ])
              ]),
              createBaseVNode("div", _hoisted_87, [
                _cache[67] || (_cache[67] = createBaseVNode("label", null, "Base Zoom", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.baseZoom,
                  min: "0.5",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[31] || (_cache[31] = ($event) => updateCameraSyncConfig("baseZoom", Number($event.target.value)))
                }, null, 40, _hoisted_88),
                createBaseVNode("span", _hoisted_89, toDisplayString(cameraSyncConfig.value.baseZoom.toFixed(2)), 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_90, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[32] || (_cache[32] = ($event) => toggleSection("preview"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[69] || (_cache[69] = createBaseVNode("span", null, "Preview", -1))
          ]),
          expandedSections.value.has("preview") ? (openBlock(), createElementBlock("div", _hoisted_91, [
            createBaseVNode("div", _hoisted_92, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                class: "preview-canvas",
                width: previewSize,
                height: previewSize
              }, null, 512)
            ]),
            createBaseVNode("div", _hoisted_93, [
              createBaseVNode("button", {
                class: normalizeClass(["preview-btn", { active: isPreviewPlaying.value }]),
                onClick: togglePreview
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(isPreviewPlaying.value ? "pi pi-pause" : "pi pi-play")
                }, null, 2),
                createTextVNode(" " + toDisplayString(isPreviewPlaying.value ? "Pause" : "Play"), 1)
              ], 2),
              createBaseVNode("span", _hoisted_94, " Frame " + toDisplayString(previewFrame.value) + " / " + toDisplayString(totalFrames.value - 1), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const DepthflowProperties = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-fe3d8389"]]);

const _hoisted_1$m = { class: "light-properties" };
const _hoisted_2$m = { class: "property-section" };
const _hoisted_3$m = { class: "section-content" };
const _hoisted_4$m = { class: "property-row" };
const _hoisted_5$m = ["value"];
const _hoisted_6$m = { class: "property-group" };
const _hoisted_7$m = { class: "property-group" };
const _hoisted_8$k = { class: "control-row" };
const _hoisted_9$j = { class: "property-group" };
const _hoisted_10$j = { class: "control-row" };
const _hoisted_11$i = { class: "property-group" };
const _hoisted_12$g = {
  key: 1,
  class: "property-row"
};
const _hoisted_13$f = ["value"];
const _hoisted_14$e = {
  key: 2,
  class: "property-group"
};
const _hoisted_15$e = {
  key: 3,
  class: "property-group"
};
const _hoisted_16$e = { class: "property-group checkbox-row" };
const _hoisted_17$e = ["checked"];
const _hoisted_18$e = { class: "property-group" };
const _hoisted_19$c = { class: "property-group" };
const _hoisted_20$c = {
  key: 5,
  class: "note"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const lightData = computed(() => {
      return props.layer.data || {
        lightType: "spot",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0,
        coneAngle: 90,
        coneFeather: 50
      };
    });
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...lightData.value, [key]: value }
      });
      emit("update");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$m, [
          _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-header" }, "Light Settings", -1)),
          createBaseVNode("div", _hoisted_3$m, [
            createBaseVNode("div", _hoisted_4$m, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Type", -1)),
              createBaseVNode("select", {
                value: lightData.value.lightType,
                onChange: _cache[0] || (_cache[0] = ($event) => update("lightType", $event.target.value)),
                class: "type-select"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("option", { value: "parallel" }, "Parallel", -1),
                createBaseVNode("option", { value: "spot" }, "Spot", -1),
                createBaseVNode("option", { value: "point" }, "Point", -1),
                createBaseVNode("option", { value: "ambient" }, "Ambient", -1)
              ])], 40, _hoisted_5$m)
            ]),
            createBaseVNode("div", _hoisted_6$m, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: lightData.value.color,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => update("color", v))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$m, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("div", _hoisted_8$k, [
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.intensity,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => update("intensity", v)),
                  min: 0,
                  max: 500,
                  step: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ]),
            lightData.value.lightType === "spot" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_9$j, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "Cone Angle", -1)),
                createBaseVNode("div", _hoisted_10$j, [
                  createVNode(unref(AngleDial), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => update("coneAngle", v)),
                    size: 32
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => update("coneAngle", v)),
                    unit: ""
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11$i, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "Cone Feather", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.coneFeather ?? 50,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => update("coneFeather", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_12$g, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Falloff", -1)),
              createBaseVNode("select", {
                value: lightData.value.falloff,
                onChange: _cache[6] || (_cache[6] = ($event) => update("falloff", $event.target.value)),
                class: "type-select"
              }, [..._cache[18] || (_cache[18] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "smooth" }, "Smooth", -1),
                createBaseVNode("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
              ])], 40, _hoisted_13$f)
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" && lightData.value.lightType !== "parallel" ? (openBlock(), createElementBlock("div", _hoisted_14$e, [
              _cache[20] || (_cache[20] = createBaseVNode("label", null, "Radius", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.radius,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => update("radius", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_15$e, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Falloff Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.falloffDistance ?? 500,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => update("falloffDistance", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_16$e, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: lightData.value.castShadows,
                  onChange: _cache[9] || (_cache[9] = ($event) => update("castShadows", $event.target.checked))
                }, null, 40, _hoisted_17$e),
                _cache[22] || (_cache[22] = createTextVNode(" Casts Shadows ", -1))
              ])
            ]),
            lightData.value.castShadows ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
              createBaseVNode("div", _hoisted_18$e, [
                _cache[23] || (_cache[23] = createBaseVNode("label", null, "Shadow Darkness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.shadowDarkness ?? 100,
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => update("shadowDarkness", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$c, [
                _cache[24] || (_cache[24] = createBaseVNode("label", null, "Shadow Diffusion", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: lightData.value.shadowDiffusion ?? 0,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => update("shadowDiffusion", v)),
                  min: 0,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.castShadows ? (openBlock(), createElementBlock("div", _hoisted_20$c, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const LightProperties = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-7bf0f1bf"]]);

const _hoisted_1$l = { class: "shape-properties" };
const _hoisted_2$l = { class: "property-section" };
const _hoisted_3$l = { class: "section-content" };
const _hoisted_4$l = { class: "property-group" };
const _hoisted_5$l = { class: "group-header" };
const _hoisted_6$l = ["checked"];
const _hoisted_7$l = {
  key: 0,
  class: "control-row"
};
const _hoisted_8$j = { class: "property-group" };
const _hoisted_9$i = { class: "group-header" };
const _hoisted_10$i = ["checked"];
const _hoisted_11$h = {
  key: 0,
  class: "stroke-controls"
};
const _hoisted_12$f = { class: "control-row" };
const _hoisted_13$e = { class: "property-row" };
const _hoisted_14$d = { class: "property-row" };
const _hoisted_15$d = { class: "icon-toggle-group" };
const _hoisted_16$d = { class: "property-group" };
const _hoisted_17$d = { class: "control-row checkbox-row" };
const _hoisted_18$d = ["checked"];
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const shapeData = computed(() => {
      return props.layer.data || {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#ffffff",
        strokeWidth: 2,
        fill: ""
      };
    });
    const hasFill = computed(() => !!shapeData.value.fill && shapeData.value.fill !== "transparent");
    const hasStroke = computed(() => !!shapeData.value.stroke && shapeData.value.strokeWidth > 0);
    const strokeCap = computed(() => shapeData.value.strokeLineCap || "round");
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...shapeData.value, [key]: value }
      });
      emit("update");
    }
    function toggleFill(e) {
      const checked = e.target.checked;
      update("fill", checked ? "#ffffff" : "");
    }
    function toggleStroke(e) {
      const checked = e.target.checked;
      if (checked) {
        update("stroke", "#ffffff");
        update("strokeWidth", 2);
      } else {
        update("strokeWidth", 0);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", _hoisted_2$l, [
          _cache[13] || (_cache[13] = createBaseVNode("div", { class: "section-header" }, "Shape Appearance", -1)),
          createBaseVNode("div", _hoisted_3$l, [
            createBaseVNode("div", _hoisted_4$l, [
              createBaseVNode("div", _hoisted_5$l, [
                _cache[7] || (_cache[7] = createBaseVNode("label", null, "Fill", -1)),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: hasFill.value,
                  onChange: toggleFill
                }, null, 40, _hoisted_6$l)
              ]),
              hasFill.value ? (openBlock(), createElementBlock("div", _hoisted_7$l, [
                createVNode(unref(ColorPicker), {
                  modelValue: shapeData.value.fill || "#ffffff",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => update("fill", v)),
                  alpha: true
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$j, [
              createBaseVNode("div", _hoisted_9$i, [
                _cache[8] || (_cache[8] = createBaseVNode("label", null, "Stroke", -1)),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: hasStroke.value,
                  onChange: toggleStroke
                }, null, 40, _hoisted_10$i)
              ]),
              hasStroke.value ? (openBlock(), createElementBlock("div", _hoisted_11$h, [
                createBaseVNode("div", _hoisted_12$f, [
                  createVNode(unref(ColorPicker), {
                    modelValue: shapeData.value.stroke || "#ffffff",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => update("stroke", v)),
                    alpha: true
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_13$e, [
                  _cache[9] || (_cache[9] = createBaseVNode("label", { class: "sub-label" }, "Width", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: shapeData.value.strokeWidth || 0,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => update("strokeWidth", v)),
                    min: 0,
                    max: 500,
                    unit: "px"
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_14$d, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", { class: "sub-label" }, "Cap", -1)),
                  createBaseVNode("div", _hoisted_15$d, [
                    createBaseVNode("button", {
                      class: normalizeClass({ active: strokeCap.value === "butt" }),
                      onClick: _cache[3] || (_cache[3] = ($event) => update("strokeLineCap", "butt")),
                      title: "Butt Cap"
                    }, "I", 2),
                    createBaseVNode("button", {
                      class: normalizeClass({ active: strokeCap.value === "round" }),
                      onClick: _cache[4] || (_cache[4] = ($event) => update("strokeLineCap", "round")),
                      title: "Round Cap"
                    }, "C", 2),
                    createBaseVNode("button", {
                      class: normalizeClass({ active: strokeCap.value === "square" }),
                      onClick: _cache[5] || (_cache[5] = ($event) => update("strokeLineCap", "square")),
                      title: "Square Cap"
                    }, "H", 2)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_16$d, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Path", -1)),
              createBaseVNode("div", _hoisted_17$d, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: shapeData.value.closed,
                    onChange: _cache[6] || (_cache[6] = ($event) => update("closed", $event.target.checked))
                  }, null, 40, _hoisted_18$d),
                  _cache[11] || (_cache[11] = createTextVNode(" Closed Path ", -1))
                ])
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const ShapeProperties = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-e2af8c92"]]);

const _hoisted_1$k = { class: "video-properties" };
const _hoisted_2$k = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$k = { class: "section-content info-grid" };
const _hoisted_4$k = { class: "info-row" };
const _hoisted_5$k = { class: "info-value" };
const _hoisted_6$k = { class: "info-row" };
const _hoisted_7$k = { class: "info-value" };
const _hoisted_8$i = { class: "info-row" };
const _hoisted_9$h = { class: "info-value" };
const _hoisted_10$h = { class: "info-row" };
const _hoisted_11$g = { class: "info-value" };
const _hoisted_12$e = { class: "property-section" };
const _hoisted_13$d = { class: "section-content" };
const _hoisted_14$c = { class: "property-row" };
const _hoisted_15$c = { class: "property-row" };
const _hoisted_16$c = { class: "property-row" };
const _hoisted_17$c = { class: "checkbox-group" };
const _hoisted_18$c = { class: "checkbox-row" };
const _hoisted_19$b = ["checked"];
const _hoisted_20$b = { class: "checkbox-row" };
const _hoisted_21$b = ["checked"];
const _hoisted_22$a = { class: "property-section" };
const _hoisted_23$a = { class: "section-header" };
const _hoisted_24$8 = { class: "header-toggle" };
const _hoisted_25$8 = ["checked"];
const _hoisted_26$8 = {
  key: 0,
  class: "section-content"
};
const _hoisted_27$8 = { class: "property-row" };
const _hoisted_28$8 = { class: "control-with-keyframe" };
const _hoisted_29$8 = { class: "property-section" };
const _hoisted_30$8 = { class: "section-content" };
const _hoisted_31$5 = { class: "property-row" };
const _hoisted_32$5 = ["value"];
const _hoisted_33$5 = {
  key: 1,
  class: "property-section"
};
const _hoisted_34$5 = { class: "section-content" };
const _hoisted_35$5 = { class: "checkbox-group" };
const _hoisted_36$5 = { class: "checkbox-row" };
const _hoisted_37$5 = ["checked"];
const _hoisted_38$4 = {
  key: 0,
  class: "property-row"
};
const _hoisted_39$4 = { class: "control-with-keyframe" };
const _hoisted_40$3 = {
  key: 1,
  class: "property-row"
};
const _hoisted_41$3 = {
  key: 2,
  class: "waveform-container"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const videoData = computed(() => {
      return props.layer.data || {
        assetId: null,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: true,
        audioLevel: 100,
        posterFrame: 0
      };
    });
    const assetInfo = computed(() => {
      const assetId = videoData.value.assetId;
      if (!assetId) return null;
      return store.assets[assetId] || null;
    });
    const audioLevel = computed(() => {
      return props.layer.audio?.level;
    });
    const timeRemapValue = computed(() => {
      if (!videoData.value.timeRemap) return 0;
      return videoData.value.timeRemap.value;
    });
    function formatDuration(seconds) {
      if (!seconds) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = Math.floor(seconds % 1 * (assetInfo.value?.fps || 30));
      return `${mins}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
    }
    function updateSpeed(val) {
      store.updateVideoLayerData(props.layer.id, { speed: val });
      emit("update");
    }
    function updateStartTime(val) {
      store.updateVideoLayerData(props.layer.id, { startTime: val });
      emit("update");
    }
    function updateEndTime(val) {
      store.updateVideoLayerData(props.layer.id, { endTime: val });
      emit("update");
    }
    function updateLoop(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { loop: target.checked });
      emit("update");
    }
    function updatePingPong(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { pingPong: target.checked });
      emit("update");
    }
    function toggleTimeRemap(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { timeRemapEnabled: target.checked });
      emit("update");
    }
    function updateTimeRemap(val) {
      const data = props.layer.data;
      if (data.timeRemap) {
        data.timeRemap.value = val;
      }
      emit("update");
    }
    function updateFrameBlending(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { frameBlending: target.value });
      emit("update");
    }
    function updateAudioEnabled(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { audioEnabled: target.checked });
      emit("update");
    }
    function updateAudioLevel(val) {
      store.updateVideoLayerData(props.layer.id, { audioLevel: val });
      emit("update");
    }
    function updateLevel(val) {
      if (props.layer.audio?.level) {
        props.layer.audio.level.value = val;
        emit("update");
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        assetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$k, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "section-header" }, "Video Info", -1)),
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("div", _hoisted_4$k, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_5$k, toDisplayString(assetInfo.value.width) + "  " + toDisplayString(assetInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_6$k, [
              _cache[1] || (_cache[1] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_7$k, toDisplayString(formatDuration(assetInfo.value.duration)), 1)
            ]),
            createBaseVNode("div", _hoisted_8$i, [
              _cache[2] || (_cache[2] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_9$h, toDisplayString(assetInfo.value.fps?.toFixed(2) || "?") + " fps", 1)
            ]),
            createBaseVNode("div", _hoisted_10$h, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "info-label" }, "Has Audio", -1)),
              createBaseVNode("span", _hoisted_11$g, toDisplayString(assetInfo.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_12$e, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, "Playback", -1)),
          createBaseVNode("div", _hoisted_13$d, [
            createBaseVNode("div", _hoisted_14$c, [
              _cache[5] || (_cache[5] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.speed,
                "onUpdate:modelValue": updateSpeed,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$c, [
              _cache[6] || (_cache[6] = createBaseVNode("label", null, "Start Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.startTime,
                "onUpdate:modelValue": updateStartTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_16$c, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "End Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.endTime || assetInfo.value?.duration || 0,
                "onUpdate:modelValue": updateEndTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_17$c, [
              createBaseVNode("label", _hoisted_18$c, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.loop,
                  onChange: updateLoop
                }, null, 40, _hoisted_19$b),
                _cache[8] || (_cache[8] = createBaseVNode("span", null, "Loop", -1))
              ]),
              createBaseVNode("label", _hoisted_20$b, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.pingPong,
                  onChange: updatePingPong
                }, null, 40, _hoisted_21$b),
                _cache[9] || (_cache[9] = createBaseVNode("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_22$a, [
          createBaseVNode("div", _hoisted_23$a, [
            _cache[11] || (_cache[11] = createBaseVNode("span", null, "Time Remap", -1)),
            createBaseVNode("label", _hoisted_24$8, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: videoData.value.timeRemapEnabled,
                onChange: toggleTimeRemap
              }, null, 40, _hoisted_25$8)
            ])
          ]),
          videoData.value.timeRemapEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$8, [
            createBaseVNode("div", _hoisted_27$8, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Remap Time", -1)),
              createBaseVNode("div", _hoisted_28$8, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: timeRemapValue.value,
                  "onUpdate:modelValue": updateTimeRemap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                videoData.value.timeRemap ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: videoData.value.timeRemap,
                  layerId: __props.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[13] || (_cache[13] = createBaseVNode("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_29$8, [
          _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-header" }, "Frame Blending", -1)),
          createBaseVNode("div", _hoisted_30$8, [
            createBaseVNode("div", _hoisted_31$5, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Mode", -1)),
              createBaseVNode("select", {
                value: videoData.value.frameBlending,
                onChange: updateFrameBlending,
                class: "select-input"
              }, [..._cache[14] || (_cache[14] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "frame-mix" }, "Frame Mix", -1),
                createBaseVNode("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, _hoisted_32$5)
            ])
          ])
        ]),
        assetInfo.value?.hasAudio !== false ? (openBlock(), createElementBlock("div", _hoisted_33$5, [
          _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, "Audio", -1)),
          createBaseVNode("div", _hoisted_34$5, [
            createBaseVNode("div", _hoisted_35$5, [
              createBaseVNode("label", _hoisted_36$5, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.audioEnabled,
                  onChange: updateAudioEnabled
                }, null, 40, _hoisted_37$5),
                _cache[17] || (_cache[17] = createBaseVNode("span", null, "Audio Enabled", -1))
              ])
            ]),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_38$4, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Level", -1)),
              createBaseVNode("div", _hoisted_39$4, [
                audioLevel.value ? (openBlock(), createBlock(unref(ScrubableNumber), {
                  key: 0,
                  modelValue: audioLevel.value.value,
                  "onUpdate:modelValue": updateLevel,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                audioLevel.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 1,
                  property: audioLevel.value,
                  layerId: __props.layer.id
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_40$3, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Volume", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.audioLevel,
                "onUpdate:modelValue": updateAudioLevel,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_41$3, [..._cache[20] || (_cache[20] = [
              createBaseVNode("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VideoProperties = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-5f46759a"]]);

const _hoisted_1$j = ["title"];
const _hoisted_2$j = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
};
const _hoisted_3$j = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_4$j = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_5$j = ["x1", "y1", "x2", "y2"];
const _hoisted_6$j = ["cx", "cy"];
const _hoisted_7$j = { class: "drop-label" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const containerRef = ref(null);
    const isDragging = ref(false);
    const dragStart = ref({ x: 0, y: 0 });
    const dragEnd = ref({ x: 0, y: 0 });
    const currentDropTarget = ref(null);
    const hasLink = computed(() => !!props.linkedTo);
    const linkTargetName = computed(() => {
      if (!props.linkedTo) return "";
      return `${props.linkedTo.layerId}.${props.linkedTo.property}`;
    });
    const lineStyle = computed(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    }));
    const dropTargetStyle = computed(() => {
      if (!currentDropTarget.value) return {};
      const rect = currentDropTarget.value.rect;
      return {
        position: "fixed",
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        zIndex: 9999
      };
    });
    function findDropTargets() {
      const targets = [];
      const elements = document.querySelectorAll("[data-pickwhip-target]");
      elements.forEach((el) => {
        const htmlEl = el;
        const layerId = htmlEl.dataset.pickwhipLayerId;
        const property = htmlEl.dataset.pickwhipTarget;
        const label = htmlEl.dataset.pickwhipLabel || property;
        if (layerId === props.layerId && property === props.property) {
          return;
        }
        if (layerId && property) {
          targets.push({
            layerId,
            property,
            label,
            element: htmlEl,
            rect: htmlEl.getBoundingClientRect()
          });
        }
      });
      return targets;
    }
    function findTargetAtPosition(x, y, targets) {
      for (const target of targets) {
        const rect = target.rect;
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return target;
        }
      }
      return null;
    }
    let dropTargets = [];
    function startDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      const rect = containerRef.value?.getBoundingClientRect();
      if (rect) {
        dragStart.value = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      } else {
        dragStart.value = { x: clientX, y: clientY };
      }
      dragEnd.value = { x: clientX, y: clientY };
      isDragging.value = true;
      dropTargets = findDropTargets();
      window.addEventListener("mousemove", onDrag);
      window.addEventListener("mouseup", endDrag);
      window.addEventListener("touchmove", onDrag);
      window.addEventListener("touchend", endDrag);
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      dragEnd.value = { x: clientX, y: clientY };
      dropTargets.forEach((t) => {
        t.rect = t.element.getBoundingClientRect();
      });
      currentDropTarget.value = findTargetAtPosition(clientX, clientY, dropTargets);
    }
    function endDrag(e) {
      if (!isDragging.value) return;
      const clientX = "changedTouches" in e ? e.changedTouches[0].clientX : e.clientX;
      const clientY = "changedTouches" in e ? e.changedTouches[0].clientY : e.clientY;
      const target = findTargetAtPosition(clientX, clientY, dropTargets);
      if (target) {
        emit("link", { layerId: target.layerId, property: target.property });
      }
      isDragging.value = false;
      currentDropTarget.value = null;
      dropTargets = [];
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    }
    function clearLink() {
      emit("unlink");
    }
    onUnmounted(() => {
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "pickwhip-container",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["pickwhip-handle", { dragging: isDragging.value, linked: hasLink.value }]),
          onMousedown: startDrag,
          onTouchstart: withModifiers(startDrag, ["prevent"]),
          title: hasLink.value ? `Linked to: ${linkTargetName.value}` : "Drag to link property"
        }, [
          (openBlock(), createElementBlock("svg", _hoisted_2$j, [
            _cache[0] || (_cache[0] = createBaseVNode("circle", {
              cx: "8",
              cy: "8",
              r: "3",
              fill: "currentColor"
            }, null, -1)),
            !hasLink.value ? (openBlock(), createElementBlock("path", _hoisted_3$j)) : (openBlock(), createElementBlock("path", _hoisted_4$j))
          ]))
        ], 42, _hoisted_1$j),
        hasLink.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "clear-link-btn",
          onClick: clearLink,
          title: "Remove link"
        }, "  ")) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "pickwhip-line",
            style: normalizeStyle(lineStyle.value)
          }, [
            createBaseVNode("line", {
              x1: dragStart.value.x,
              y1: dragStart.value.y,
              x2: dragEnd.value.x,
              y2: dragEnd.value.y,
              stroke: "#4a90d9",
              "stroke-width": "2",
              "stroke-dasharray": "4 2"
            }, null, 8, _hoisted_5$j),
            createBaseVNode("circle", {
              cx: dragEnd.value.x,
              cy: dragEnd.value.y,
              r: "6",
              fill: "#4a90d9",
              stroke: "#fff",
              "stroke-width": "1"
            }, null, 8, _hoisted_6$j)
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value && currentDropTarget.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "drop-target-highlight",
            style: normalizeStyle(dropTargetStyle.value)
          }, [
            createBaseVNode("span", _hoisted_7$j, toDisplayString(currentDropTarget.value.label), 1)
          ], 4)) : createCommentVNode("", true)
        ]))
      ], 512);
    };
  }
});

const Pickwhip = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-da1938e3"]]);

const _hoisted_1$i = {
  key: 0,
  class: "driver-list"
};
const _hoisted_2$i = { class: "expand-icon" };
const _hoisted_3$i = { class: "count" };
const _hoisted_4$i = {
  key: 0,
  class: "driver-items"
};
const _hoisted_5$i = { class: "driver-header" };
const _hoisted_6$i = ["onClick"];
const _hoisted_7$i = { class: "driver-info" };
const _hoisted_8$h = { class: "target" };
const _hoisted_9$g = {
  key: 0,
  class: "source"
};
const _hoisted_10$g = {
  key: 1,
  class: "source audio"
};
const _hoisted_11$f = {
  key: 2,
  class: "source time"
};
const _hoisted_12$d = ["onClick"];
const _hoisted_13$c = {
  key: 0,
  class: "driver-transforms"
};
const _hoisted_14$b = ["title"];
const _hoisted_15$b = {
  key: 1,
  class: "add-driver-section"
};
const _hoisted_16$b = {
  key: 0,
  class: "add-menu"
};
const _hoisted_17$b = { class: "menu-section" };
const _hoisted_18$b = { class: "menu-section" };
const _hoisted_19$a = { class: "menu-section" };
const _hoisted_20$a = { class: "menu-section" };
const _hoisted_21$a = { class: "menu-actions" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(__props) {
    const props = __props;
    const store = useCompositorStore();
    const expanded = ref(true);
    const showAddMenu = ref(false);
    const newDriver = ref({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    });
    const drivers = computed(() => {
      return store.getDriversForLayer(props.layerId);
    });
    function formatProperty(prop) {
      if (!prop) return "?";
      const names = {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        "opacity": "Opacity"
      };
      return names[prop] || prop;
    }
    function getSourceLayerName(layerId) {
      if (!layerId) return "?";
      const layer = store.layers.find((l) => l.id === layerId);
      return layer?.name || layerId.slice(0, 8);
    }
    function formatTransform(t) {
      switch (t.type) {
        case "scale":
          return `Scale: ${t.factor}`;
        case "offset":
          return `Offset: ${t.amount}`;
        case "clamp":
          return `Clamp: ${t.min}-${t.max}`;
        case "smooth":
          return `Smooth: ${t.smoothing}`;
        case "threshold":
          return `Threshold: ${t.threshold}`;
        default:
          return t.type;
      }
    }
    function toggleDriver(driverId) {
      store.togglePropertyDriver(driverId);
    }
    function removeDriver(driverId) {
      store.removePropertyDriver(driverId);
    }
    function createAudioDriver() {
      store.createAudioPropertyDriver(
        props.layerId,
        newDriver.value.targetProperty,
        newDriver.value.audioFeature,
        {
          scale: newDriver.value.scale,
          threshold: newDriver.value.threshold > 0 ? newDriver.value.threshold : void 0
        }
      );
      showAddMenu.value = false;
    }
    return (_ctx, _cache) => {
      return drivers.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", {
          class: "driver-list-header",
          onClick: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
        }, [
          createBaseVNode("span", _hoisted_2$i, toDisplayString(expanded.value ? "" : ""), 1),
          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "title" }, "Property Drivers", -1)),
          createBaseVNode("span", _hoisted_3$i, "(" + toDisplayString(drivers.value.length) + ")", 1)
        ]),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_4$i, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(drivers.value, (driver) => {
            return openBlock(), createElementBlock("div", {
              key: driver.id,
              class: normalizeClass(["driver-item", { disabled: !driver.enabled }])
            }, [
              createBaseVNode("div", _hoisted_5$i, [
                createBaseVNode("button", {
                  class: normalizeClass(["toggle-btn", { active: driver.enabled }]),
                  onClick: ($event) => toggleDriver(driver.id),
                  title: "Toggle driver"
                }, "  ", 10, _hoisted_6$i),
                createBaseVNode("div", _hoisted_7$i, [
                  createBaseVNode("span", _hoisted_8$h, toDisplayString(formatProperty(driver.targetProperty)), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "arrow" }, "", -1)),
                  driver.sourceType === "property" ? (openBlock(), createElementBlock("span", _hoisted_9$g, toDisplayString(getSourceLayerName(driver.sourceLayerId)) + "." + toDisplayString(formatProperty(driver.sourceProperty)), 1)) : driver.sourceType === "audio" ? (openBlock(), createElementBlock("span", _hoisted_10$g, "  " + toDisplayString(driver.audioFeature), 1)) : driver.sourceType === "time" ? (openBlock(), createElementBlock("span", _hoisted_11$f, "  Time ")) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: "remove-btn",
                  onClick: ($event) => removeDriver(driver.id),
                  title: "Remove driver"
                }, "  ", 8, _hoisted_12$d)
              ]),
              driver.transforms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$c, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(driver.transforms, (t, i) => {
                  return openBlock(), createElementBlock("span", {
                    key: i,
                    class: "transform-chip",
                    title: formatTransform(t)
                  }, toDisplayString(t.type), 9, _hoisted_14$b);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_15$b, [
          createBaseVNode("button", {
            class: "add-driver-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => showAddMenu.value = !showAddMenu.value)
          }, " + Add Audio Driver "),
          showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_16$b, [
            createBaseVNode("div", _hoisted_17$b, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Audio Feature:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newDriver.value.audioFeature = $event)
              }, [..._cache[9] || (_cache[9] = [
                createStaticVNode('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
              ])], 512), [
                [vModelSelect, newDriver.value.audioFeature]
              ])
            ]),
            createBaseVNode("div", _hoisted_18$b, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Target Property:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newDriver.value.targetProperty = $event)
              }, [..._cache[11] || (_cache[11] = [
                createStaticVNode('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
              ])], 512), [
                [vModelSelect, newDriver.value.targetProperty]
              ])
            ]),
            createBaseVNode("div", _hoisted_19$a, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Scale:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newDriver.value.scale = $event),
                step: "10"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.scale,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_20$a, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Threshold:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newDriver.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.threshold,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_21$a, [
              createBaseVNode("button", { onClick: createAudioDriver }, "Create"),
              createBaseVNode("button", {
                onClick: _cache[6] || (_cache[6] = ($event) => showAddMenu.value = false)
              }, "Cancel")
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});

const DriverList = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-d3107912"]]);

const _hoisted_1$h = { class: "properties-panel" };
const _hoisted_2$h = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$h = { class: "property-section" };
const _hoisted_4$h = { class: "property-row" };
const _hoisted_5$h = { class: "property-section" };
const _hoisted_6$h = { class: "property-row" };
const _hoisted_7$h = ["value"];
const _hoisted_8$g = ["value"];
const _hoisted_9$f = { class: "property-section" };
const _hoisted_10$f = { class: "expand-icon" };
const _hoisted_11$e = {
  key: 0,
  class: "section-content"
};
const _hoisted_12$c = ["data-pickwhip-layer-id"];
const _hoisted_13$b = { class: "multi-value" };
const _hoisted_14$a = { class: "multi-value" };
const _hoisted_15$a = { class: "property-row" };
const _hoisted_16$a = { class: "multi-value orientation-row" };
const _hoisted_17$a = { class: "property-row" };
const _hoisted_18$a = { class: "single-value" };
const _hoisted_19$9 = { class: "property-row" };
const _hoisted_20$9 = { class: "single-value" };
const _hoisted_21$9 = { class: "property-row" };
const _hoisted_22$9 = { class: "single-value" };
const _hoisted_23$9 = { class: "single-value" };
const _hoisted_24$7 = { class: "property-row" };
const _hoisted_25$7 = { class: "multi-value" };
const _hoisted_26$7 = { class: "single-value" };
const _hoisted_27$7 = { class: "property-section" };
const _hoisted_28$7 = { class: "property-row" };
const _hoisted_29$7 = ["value"];
const _hoisted_30$7 = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "PropertiesPanel",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(["transform"]);
    const scaleLocked = ref(true);
    const layerName = ref("");
    const transform = ref({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    });
    const blendMode = ref("normal");
    const keyframes = ref([]);
    const blendModes = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ];
    const selectedLayer = computed(() => store.selectedLayer);
    const availableParents = computed(() => {
      if (!selectedLayer.value) return [];
      const selfId = selectedLayer.value.id;
      const getDescendantIds = (layerId) => {
        const children = store.layers.filter((l) => l.parentId === layerId);
        let ids = children.map((c) => c.id);
        for (const child of children) {
          ids = ids.concat(getDescendantIds(child.id));
        }
        return ids;
      };
      const descendantIds = new Set(getDescendantIds(selfId));
      return store.layers.filter(
        (l) => l.id !== selfId && !descendantIds.has(l.id) && l.type !== "camera"
        // Camera layers shouldn't be parents
      );
    });
    const layerPropertiesComponent = computed(() => {
      if (!selectedLayer.value) return null;
      switch (selectedLayer.value.type) {
        case "text":
          return markRaw(TextProperties);
        case "particles":
          return markRaw(ParticleProperties);
        case "depthflow":
          return markRaw(DepthflowProperties);
        case "light":
          return markRaw(LightProperties);
        case "spline":
          return markRaw(ShapeProperties);
        case "video":
          return markRaw(VideoProperties);
        default:
          return null;
      }
    });
    watch(selectedLayer, (layer) => {
      if (layer) {
        layerName.value = layer.name;
        const t = layer.transform;
        transform.value = {
          position: {
            x: t?.position?.value?.x || 0,
            y: t?.position?.value?.y || 0,
            z: t?.position?.value?.z || 0
          },
          scale: { x: t?.scale?.value?.x || 100, y: t?.scale?.value?.y || 100 },
          rotation: t?.rotation?.value || 0,
          anchorPoint: { x: t?.anchorPoint?.value?.x || 0, y: t?.anchorPoint?.value?.y || 0 },
          opacity: layer.opacity?.value || 100,
          // 3D properties
          orientationX: t?.orientation?.value?.x || 0,
          orientationY: t?.orientation?.value?.y || 0,
          orientationZ: t?.orientation?.value?.z || 0,
          rotationX: t?.rotationX?.value || 0,
          rotationY: t?.rotationY?.value || 0,
          rotationZ: t?.rotationZ?.value || 0
        };
        blendMode.value = layer.blendMode || "normal";
      }
    }, { immediate: true });
    watch(() => transform.value.scale.x, (newX, oldX) => {
      if (scaleLocked.value && newX !== oldX) {
        const ratio = newX / oldX;
        transform.value.scale.y = Math.round(transform.value.scale.y * ratio * 10) / 10;
      }
    });
    function toggleSection(section) {
      const index = expandedSections.value.indexOf(section);
      if (index >= 0) {
        expandedSections.value.splice(index, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function updateLayerName() {
      if (selectedLayer.value && layerName.value) {
        selectedLayer.value.name = layerName.value;
      }
    }
    function updateTransform() {
      if (!selectedLayer.value) return;
      const t = selectedLayer.value.transform;
      const v = transform.value;
      if (t?.position) {
        t.position.value = { x: v.position.x, y: v.position.y, z: v.position.z };
      }
      if (t?.scale) {
        t.scale.value = { x: v.scale.x, y: v.scale.y };
      }
      if (t?.rotation) {
        t.rotation.value = v.rotation;
      }
      if (t?.anchorPoint) {
        t.anchorPoint.value = { x: v.anchorPoint.x, y: v.anchorPoint.y };
      }
      if (selectedLayer.value.opacity) {
        selectedLayer.value.opacity.value = v.opacity;
      }
      if (selectedLayer.value.threeD) {
        if (t?.orientation) {
          t.orientation.value = { x: v.orientationX, y: v.orientationY, z: v.orientationZ };
        }
        if (t?.rotationX) t.rotationX.value = v.rotationX;
        if (t?.rotationY) t.rotationY.value = v.rotationY;
        if (t?.rotationZ) t.rotationZ.value = v.rotationZ;
      }
      onLayerUpdate();
    }
    function updateBlendMode() {
      if (selectedLayer.value) {
        selectedLayer.value.blendMode = blendMode.value;
      }
    }
    function hasKeyframe(property) {
      return keyframes.value.includes(property);
    }
    function toggleKeyframe(property) {
      const index = keyframes.value.indexOf(property);
      if (index >= 0) {
        keyframes.value.splice(index, 1);
      } else {
        keyframes.value.push(property);
        console.log(`Added keyframe for ${property} at frame ${store.currentFrame}`);
      }
    }
    function onLayerUpdate(dataUpdates) {
      if (!selectedLayer.value) return;
      if (dataUpdates && Object.keys(dataUpdates).length > 0) {
        store.updateLayerData(selectedLayer.value.id, dataUpdates);
      } else {
        store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    function updateParent(event) {
      if (!selectedLayer.value) return;
      const parentId = event.target.value || null;
      store.setLayerParent(selectedLayer.value.id, parentId);
    }
    function getDriverForProperty(property) {
      if (!selectedLayer.value) return null;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === property && d.sourceType === "property");
      if (driver && driver.sourceLayerId && driver.sourceProperty) {
        return {
          layerId: driver.sourceLayerId,
          property: driver.sourceProperty
        };
      }
      return null;
    }
    function onPickwhipLink(targetProperty, source) {
      if (!selectedLayer.value) return;
      store.createPropertyLink(
        selectedLayer.value.id,
        targetProperty,
        source.layerId,
        source.property,
        { blendMode: "add" }
      );
      console.log(`[PropertiesPanel] Linked ${selectedLayer.value.id}.${targetProperty} <- ${source.layerId}.${source.property}`);
    }
    function onPickwhipUnlink(targetProperty) {
      if (!selectedLayer.value) return;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === targetProperty && d.sourceType === "property");
      if (driver) {
        store.removePropertyDriver(driver.id);
        console.log(`[PropertiesPanel] Unlinked ${selectedLayer.value.id}.${targetProperty}`);
      }
    }
    function hasDriver(property) {
      if (!selectedLayer.value) return false;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      return drivers.some((d) => d.targetProperty === property && d.enabled);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        _cache[49] || (_cache[49] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        selectedLayer.value ? (openBlock(), createElementBlock("div", _hoisted_2$h, [
          createBaseVNode("div", _hoisted_3$h, [
            createBaseVNode("div", _hoisted_4$h, [
              withDirectives(createBaseVNode("input", {
                type: "text",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => layerName.value = $event),
                class: "layer-name-input",
                onBlur: updateLayerName,
                onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => $event.target.blur(), ["enter"]))
              }, null, 544), [
                [vModelText, layerName.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_5$h, [
            createBaseVNode("div", _hoisted_6$h, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Parent", -1)),
              createBaseVNode("select", {
                class: "parent-select",
                value: selectedLayer.value?.parentId || "",
                onChange: updateParent
              }, [
                _cache[36] || (_cache[36] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_8$g);
                }), 128))
              ], 40, _hoisted_7$h)
            ])
          ]),
          createBaseVNode("div", _hoisted_9$f, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[2] || (_cache[2] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_10$f, toDisplayString(expandedSections.value.includes("transform") ? "" : ""), 1),
              _cache[38] || (_cache[38] = createBaseVNode("span", { class: "section-title" }, "Transform", -1))
            ]),
            expandedSections.value.includes("transform") ? (openBlock(), createElementBlock("div", _hoisted_11$e, [
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.position.x") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.position.x",
                  linkedTo: getDriverForProperty("transform.position.x"),
                  onLink: _cache[3] || (_cache[3] = (target) => onPickwhipLink("transform.position.x", target)),
                  onUnlink: _cache[4] || (_cache[4] = () => onPickwhipUnlink("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                createBaseVNode("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": selectedLayer.value?.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, _hoisted_12$c),
                createBaseVNode("div", _hoisted_13$b, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.x,
                    "onUpdate:modelValue": [
                      _cache[5] || (_cache[5] = ($event) => transform.value.position.x = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.y,
                    "onUpdate:modelValue": [
                      _cache[6] || (_cache[6] = ($event) => transform.value.position.y = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.position.z,
                    "onUpdate:modelValue": [
                      _cache[7] || (_cache[7] = ($event) => transform.value.position.z = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("position") }]),
                  onClick: _cache[8] || (_cache[8] = ($event) => toggleKeyframe("position"))
                }, "", 2)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.scale.x") || hasDriver("transform.scale.y") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.scale.x",
                  linkedTo: getDriverForProperty("transform.scale.x"),
                  onLink: _cache[9] || (_cache[9] = (target) => onPickwhipLink("transform.scale.x", target)),
                  onUnlink: _cache[10] || (_cache[10] = () => onPickwhipUnlink("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[39] || (_cache[39] = createBaseVNode("label", null, "Scale", -1)),
                createBaseVNode("div", _hoisted_14$a, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.x,
                    "onUpdate:modelValue": [
                      _cache[11] || (_cache[11] = ($event) => transform.value.scale.x = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  createBaseVNode("button", {
                    class: normalizeClass(["link-btn", { active: scaleLocked.value }]),
                    onClick: _cache[12] || (_cache[12] = ($event) => scaleLocked.value = !scaleLocked.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.y,
                    "onUpdate:modelValue": [
                      _cache[13] || (_cache[13] = ($event) => transform.value.scale.y = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("scale") }]),
                  onClick: _cache[14] || (_cache[14] = ($event) => toggleKeyframe("scale"))
                }, "", 2)
              ], 2),
              selectedLayer.value?.threeD ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_15$a, [
                  _cache[40] || (_cache[40] = createBaseVNode("label", null, "Orientation", -1)),
                  createBaseVNode("div", _hoisted_16$a, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationX,
                      "onUpdate:modelValue": [
                        _cache[15] || (_cache[15] = ($event) => transform.value.orientationX = $event),
                        updateTransform
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationY,
                      "onUpdate:modelValue": [
                        _cache[16] || (_cache[16] = ($event) => transform.value.orientationY = $event),
                        updateTransform
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationZ,
                      "onUpdate:modelValue": [
                        _cache[17] || (_cache[17] = ($event) => transform.value.orientationZ = $event),
                        updateTransform
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_17$a, [
                  _cache[41] || (_cache[41] = createBaseVNode("label", null, "X Rotation", -1)),
                  createBaseVNode("div", _hoisted_18$a, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationX,
                      "onUpdate:modelValue": [
                        _cache[18] || (_cache[18] = ($event) => transform.value.rotationX = $event),
                        updateTransform
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationX") }]),
                    onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("rotationX"))
                  }, "", 2)
                ]),
                createBaseVNode("div", _hoisted_19$9, [
                  _cache[42] || (_cache[42] = createBaseVNode("label", null, "Y Rotation", -1)),
                  createBaseVNode("div", _hoisted_20$9, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationY,
                      "onUpdate:modelValue": [
                        _cache[20] || (_cache[20] = ($event) => transform.value.rotationY = $event),
                        updateTransform
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationY") }]),
                    onClick: _cache[21] || (_cache[21] = ($event) => toggleKeyframe("rotationY"))
                  }, "", 2)
                ]),
                createBaseVNode("div", _hoisted_21$9, [
                  _cache[43] || (_cache[43] = createBaseVNode("label", null, "Z Rotation", -1)),
                  createBaseVNode("div", _hoisted_22$9, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationZ,
                      "onUpdate:modelValue": [
                        _cache[22] || (_cache[22] = ($event) => transform.value.rotationZ = $event),
                        updateTransform
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationZ") }]),
                    onClick: _cache[23] || (_cache[23] = ($event) => toggleKeyframe("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.rotation") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.rotation",
                  linkedTo: getDriverForProperty("transform.rotation"),
                  onLink: _cache[24] || (_cache[24] = (target) => onPickwhipLink("transform.rotation", target)),
                  onUnlink: _cache[25] || (_cache[25] = () => onPickwhipUnlink("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[44] || (_cache[44] = createBaseVNode("label", null, "Rotation", -1)),
                createBaseVNode("div", _hoisted_23$9, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.rotation,
                    "onUpdate:modelValue": [
                      _cache[26] || (_cache[26] = ($event) => transform.value.rotation = $event),
                      updateTransform
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotation") }]),
                  onClick: _cache[27] || (_cache[27] = ($event) => toggleKeyframe("rotation"))
                }, "", 2)
              ], 2)),
              createBaseVNode("div", _hoisted_24$7, [
                _cache[45] || (_cache[45] = createBaseVNode("label", null, "Anchor Point", -1)),
                createBaseVNode("div", _hoisted_25$7, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      _cache[28] || (_cache[28] = ($event) => transform.value.anchorPoint.x = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      _cache[29] || (_cache[29] = ($event) => transform.value.anchorPoint.y = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("anchorPoint") }]),
                  onClick: _cache[30] || (_cache[30] = ($event) => toggleKeyframe("anchorPoint"))
                }, "", 2)
              ]),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("opacity") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "opacity",
                  linkedTo: getDriverForProperty("opacity"),
                  onLink: _cache[31] || (_cache[31] = (target) => onPickwhipLink("opacity", target)),
                  onUnlink: _cache[32] || (_cache[32] = () => onPickwhipUnlink("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[46] || (_cache[46] = createBaseVNode("label", null, "Opacity", -1)),
                createBaseVNode("div", _hoisted_26$7, [
                  createVNode(unref(SliderInput), {
                    modelValue: transform.value.opacity,
                    "onUpdate:modelValue": [
                      _cache[33] || (_cache[33] = ($event) => transform.value.opacity = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("opacity") }]),
                  onClick: _cache[34] || (_cache[34] = ($event) => toggleKeyframe("opacity"))
                }, "", 2)
              ], 2)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_27$7, [
            createBaseVNode("div", _hoisted_28$7, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Blend Mode", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[35] || (_cache[35] = ($event) => blendMode.value = $event),
                class: "blend-select",
                onChange: updateBlendMode
              }, [
                (openBlock(), createElementBlock(Fragment, null, renderList(blendModes, (mode) => {
                  return createBaseVNode("option", {
                    key: mode.value,
                    value: mode.value
                  }, toDisplayString(mode.label), 9, _hoisted_29$7);
                }), 64))
              ], 544), [
                [vModelSelect, blendMode.value]
              ])
            ])
          ]),
          layerPropertiesComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(layerPropertiesComponent.value), {
            key: 0,
            layer: selectedLayer.value,
            onUpdate: onLayerUpdate
          }, null, 40, ["layer"])) : createCommentVNode("", true),
          selectedLayer.value ? (openBlock(), createBlock(DriverList, {
            key: 1,
            layerId: selectedLayer.value.id
          }, null, 8, ["layerId"])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_30$7, [..._cache[48] || (_cache[48] = [
          createBaseVNode("p", null, "No layer selected", -1),
          createBaseVNode("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
});

const PropertiesPanel = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-a5a9c7d6"]]);

const DEFAULT_TRAJECTORY = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: false
};
const TRAJECTORY_PRESETS = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function applyEasing(t, easing) {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t;
    case "ease-out":
      return 1 - (1 - t) * (1 - t);
    case "ease-in-out":
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    case "bounce":
      if (t < 0.5) {
        return 8 * t * t * t * t;
      }
      const f = t - 1;
      return 1 - 8 * f * f * f * f;
    default:
      return t;
  }
}
function getTrajectoryPosition(config, t) {
  const easedT = applyEasing(t, config.easing);
  const { center, baseDistance, amplitude, loops, startPhase, type } = config;
  let position = { x: center.x, y: center.y, z: center.z - baseDistance };
  let target = { ...center };
  switch (type) {
    case "orbit":
    case "orbit_reverse": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI * Math.sign(amplitude);
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const maxAngle = Math.abs(amplitude) * Math.PI;
      const angle = Math.sin(easedT * Math.PI) * maxAngle;
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "dolly_in": {
      const distance = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "dolly_out": {
      const distance = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const panAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x + Math.sin(panAngle) * baseDistance,
        y: center.y,
        z: center.z + Math.cos(panAngle) * baseDistance - baseDistance
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const tiltAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x,
        y: center.y + Math.sin(tiltAngle) * baseDistance,
        z: center.z
      };
      break;
    }
    case "circle": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.cos(angle) * radius * 0.5,
        // Elliptical
        z: center.z - baseDistance + Math.cos(angle) * radius * 0.3
      };
      break;
    }
    case "figure8": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.sin(angle * 2) * radius * 0.3,
        z: center.z - baseDistance
      };
      break;
    }
    case "spiral_in": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "spiral_out": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      position = {
        x: center.x,
        y: center.y + easedT * amplitude,
        z: center.z - baseDistance
      };
      target = {
        x: center.x,
        y: center.y + easedT * amplitude * 0.5,
        // Target moves less
        z: center.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      position = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z - baseDistance
      };
      target = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const arcAngle = easedT * amplitude * 2 * Math.PI;
      position = {
        x: center.x + Math.sin(arcAngle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(arcAngle) * baseDistance
      };
      break;
    }
  }
  return { position, target };
}
function generateTrajectoryKeyframes(config, startFrame = 0, keyframeInterval = 5) {
  const positionKeyframes = [];
  const poiKeyframes = [];
  const zoomKeyframes = [];
  const numKeyframes = Math.ceil(config.duration / keyframeInterval) + 1;
  for (let i = 0; i < numKeyframes; i++) {
    const frame = startFrame + Math.min(i * keyframeInterval, config.duration);
    const t = Math.min(i * keyframeInterval, config.duration) / config.duration;
    const { position, target } = getTrajectoryPosition(config, t);
    positionKeyframes.push({
      frame,
      position,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    poiKeyframes.push({
      frame,
      pointOfInterest: target,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    if (config.type === "zoom_in" || config.type === "zoom_out") {
      const easedT = applyEasing(t, config.easing);
      const zoomMultiplier = config.type === "zoom_in" ? 1 + easedT * Math.abs(config.amplitude) : 1 - easedT * Math.abs(config.amplitude);
      zoomKeyframes.push({
        frame,
        zoom: 1778 * zoomMultiplier,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: positionKeyframes,
    pointOfInterest: poiKeyframes,
    zoom: zoomKeyframes.length > 0 ? zoomKeyframes : void 0
  };
}
function getTrajectoryDescription(type) {
  const descriptions = {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  };
  return descriptions[type] || "Unknown trajectory";
}
function getTrajectoryCategory(type) {
  const categories = {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  };
  return categories[type] || "Other";
}
function getTrajectoryTypesByCategory() {
  const types = Object.keys(TRAJECTORY_PRESETS);
  const grouped = {};
  for (const type of types) {
    const category = getTrajectoryCategory(type);
    if (!grouped[category]) {
      grouped[category] = [];
    }
    grouped[category].push(type);
  }
  return grouped;
}

const _hoisted_1$g = { class: "camera-properties" };
const _hoisted_2$g = { class: "panel-header" };
const _hoisted_3$g = { class: "camera-name" };
const _hoisted_4$g = {
  key: 0,
  class: "properties-content"
};
const _hoisted_5$g = { class: "property-section" };
const _hoisted_6$g = { class: "property-row" };
const _hoisted_7$g = ["value"];
const _hoisted_8$f = { class: "property-section" };
const _hoisted_9$e = { class: "toggle-icon" };
const _hoisted_10$e = { class: "section-content" };
const _hoisted_11$d = { class: "property-group" };
const _hoisted_12$b = { class: "xyz-inputs" };
const _hoisted_13$a = {
  key: 0,
  class: "property-group"
};
const _hoisted_14$9 = { class: "xyz-inputs" };
const _hoisted_15$9 = { class: "property-group" };
const _hoisted_16$9 = { class: "xyz-inputs" };
const _hoisted_17$9 = { class: "property-group" };
const _hoisted_18$9 = { class: "property-group" };
const _hoisted_19$8 = { class: "property-group" };
const _hoisted_20$8 = { class: "property-section" };
const _hoisted_21$8 = { class: "toggle-icon" };
const _hoisted_22$8 = { class: "section-content" };
const _hoisted_23$8 = { class: "preset-row" };
const _hoisted_24$6 = ["onClick"];
const _hoisted_25$6 = { class: "property-group" };
const _hoisted_26$6 = { class: "property-group" };
const _hoisted_27$6 = { class: "property-group" };
const _hoisted_28$6 = { class: "property-group" };
const _hoisted_29$6 = ["value"];
const _hoisted_30$6 = { class: "property-section" };
const _hoisted_31$4 = { class: "toggle-icon" };
const _hoisted_32$4 = { class: "section-content" };
const _hoisted_33$4 = { class: "property-group checkbox-group" };
const _hoisted_34$4 = ["checked"];
const _hoisted_35$4 = { class: "property-group" };
const _hoisted_36$4 = { class: "property-group" };
const _hoisted_37$4 = { class: "property-group" };
const _hoisted_38$3 = { class: "property-group checkbox-group" };
const _hoisted_39$3 = ["checked"];
const _hoisted_40$2 = { class: "property-section" };
const _hoisted_41$2 = { class: "toggle-icon" };
const _hoisted_42$2 = { class: "section-content" };
const _hoisted_43$2 = { class: "property-group" };
const _hoisted_44$2 = { class: "property-group" };
const _hoisted_45$2 = { class: "property-group" };
const _hoisted_46$2 = { class: "property-group" };
const _hoisted_47$2 = { class: "property-group" };
const _hoisted_48$2 = { class: "property-section" };
const _hoisted_49$2 = { class: "toggle-icon" };
const _hoisted_50$1 = { class: "section-content" };
const _hoisted_51$1 = { class: "property-group" };
const _hoisted_52$1 = { class: "property-group" };
const _hoisted_53$1 = { class: "property-group" };
const _hoisted_54$1 = { class: "property-section" };
const _hoisted_55$1 = { class: "toggle-icon" };
const _hoisted_56$1 = { class: "section-content" };
const _hoisted_57$1 = { class: "property-group" };
const _hoisted_58$1 = ["value"];
const _hoisted_59$1 = { class: "property-section" };
const _hoisted_60$1 = { class: "toggle-icon" };
const _hoisted_61$1 = { class: "section-content" };
const _hoisted_62$1 = { class: "property-group" };
const _hoisted_63 = { class: "property-group" };
const _hoisted_64 = { class: "property-section" };
const _hoisted_65 = { class: "toggle-icon" };
const _hoisted_66 = { class: "section-content" };
const _hoisted_67 = { class: "property-group" };
const _hoisted_68 = ["label"];
const _hoisted_69 = ["value"];
const _hoisted_70 = { class: "trajectory-description" };
const _hoisted_71 = { class: "property-group" };
const _hoisted_72 = { class: "property-group" };
const _hoisted_73 = {
  key: 0,
  class: "property-group"
};
const _hoisted_74 = { class: "property-group" };
const _hoisted_75 = { class: "property-group checkbox-group" };
const _hoisted_76 = { class: "property-group" };
const _hoisted_77 = { class: "property-group" };
const _hoisted_78 = {
  key: 1,
  class: "no-camera"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "camera" && selectedLayer.data) {
        const cameraData = selectedLayer.data;
        return store.getCamera(cameraData.cameraId);
      }
      return store.activeCamera;
    });
    const expandedSections = reactive({
      transform: true,
      lens: true,
      dof: false,
      iris: false,
      highlight: false,
      autoOrient: false,
      clipping: false,
      trajectory: false
    });
    const trajectoryConfig = reactive({
      ...DEFAULT_TRAJECTORY
    });
    const trajectoryTypesByCategory = computed(() => getTrajectoryTypesByCategory());
    const trajectoryDescription = computed(() => getTrajectoryDescription(trajectoryConfig.type));
    const isOrbitalTrajectory = computed(() => {
      const orbitalTypes = ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"];
      return orbitalTypes.includes(trajectoryConfig.type);
    });
    function formatTrajectoryName(type) {
      return type.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    }
    const previewAnimationId = ref(null);
    function previewTrajectory() {
      if (!camera.value) return;
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
      const startTime = performance.now();
      const duration = trajectoryConfig.duration / 30 * 1e3;
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
        )
      };
      function animate() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const { position, target } = getTrajectoryPosition(config, t);
        store.updateCamera(camera.value.id, {
          position,
          pointOfInterest: target
        });
        if (t < 1) {
          previewAnimationId.value = requestAnimationFrame(animate);
        } else {
          previewAnimationId.value = null;
        }
      }
      animate();
    }
    function applyTrajectory() {
      if (!camera.value) return;
      const baseDistance = Math.sqrt(
        Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
      );
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance
      };
      const keyframes = generateTrajectoryKeyframes(config, store.currentFrame);
      for (const kf of keyframes.position) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          position: kf.position,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      for (const kf of keyframes.pointOfInterest) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          pointOfInterest: kf.pointOfInterest,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      if (keyframes.zoom) {
        for (const kf of keyframes.zoom) {
          store.addCameraKeyframe(camera.value.id, {
            frame: kf.frame,
            zoom: kf.zoom,
            temporalInterpolation: kf.temporalInterpolation
          });
        }
      }
      console.log(`Applied ${keyframes.position.length} camera trajectory keyframes`);
    }
    function toggleSection(section) {
      expandedSections[section] = !expandedSections[section];
    }
    function updateProperty(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, { [key]: value });
    }
    function updatePosition(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        position: { ...camera.value.position, [axis]: value }
      });
    }
    function updatePOI(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        pointOfInterest: { ...camera.value.pointOfInterest, [axis]: value }
      });
    }
    function updateOrientation(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        orientation: { ...camera.value.orientation, [axis]: value }
      });
    }
    function updateFocalLength(value) {
      if (!camera.value) return;
      const angleOfView = focalLengthToFOV(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        focalLength: value,
        angleOfView
      });
    }
    function updateAngleOfView(value) {
      if (!camera.value) return;
      const focalLength = fovToFocalLength(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        angleOfView: value,
        focalLength
      });
    }
    function updateDOF(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        depthOfField: { ...camera.value.depthOfField, [key]: value }
      });
    }
    function updateIris(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        iris: { ...camera.value.iris, [key]: value }
      });
    }
    function updateHighlight(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        highlight: { ...camera.value.highlight, [key]: value }
      });
    }
    function applyPreset(preset) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        focalLength: preset.focalLength,
        angleOfView: preset.angleOfView,
        zoom: preset.zoom
      });
    }
    function createCamera() {
      store.createCameraLayer();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$g, [
          _cache[47] || (_cache[47] = createBaseVNode("span", { class: "panel-title" }, "Camera", -1)),
          createBaseVNode("span", _hoisted_3$g, toDisplayString(camera.value?.name ?? "No Camera"), 1)
        ]),
        camera.value ? (openBlock(), createElementBlock("div", _hoisted_4$g, [
          createBaseVNode("div", _hoisted_5$g, [
            _cache[49] || (_cache[49] = createBaseVNode("div", { class: "section-header" }, "Type", -1)),
            createBaseVNode("div", _hoisted_6$g, [
              createBaseVNode("select", {
                value: camera.value.type,
                onChange: _cache[0] || (_cache[0] = ($event) => updateProperty("type", $event.target.value)),
                class: "type-select"
              }, [..._cache[48] || (_cache[48] = [
                createBaseVNode("option", { value: "one-node" }, "One-Node Camera", -1),
                createBaseVNode("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, _hoisted_7$g)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$f, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_9$e, toDisplayString(expandedSections.transform ? "" : ""), 1),
              _cache[50] || (_cache[50] = createTextVNode(" Transform ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_10$e, [
              createBaseVNode("div", _hoisted_11$d, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_12$b, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updatePosition("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updatePosition("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.z,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updatePosition("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              camera.value.type === "two-node" ? (openBlock(), createElementBlock("div", _hoisted_13$a, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Point of Interest", -1)),
                createBaseVNode("div", _hoisted_14$9, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updatePOI("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updatePOI("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.z,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => updatePOI("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_15$9, [
                _cache[53] || (_cache[53] = createBaseVNode("label", null, "Orientation", -1)),
                createBaseVNode("div", _hoisted_16$9, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.x,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateOrientation("x", v)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.y,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateOrientation("y", v)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.z,
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateOrientation("z", v)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$9, [
                _cache[54] || (_cache[54] = createBaseVNode("label", null, "X Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.xRotation,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateProperty("xRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_18$9, [
                _cache[55] || (_cache[55] = createBaseVNode("label", null, "Y Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.yRotation,
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateProperty("yRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$8, [
                _cache[56] || (_cache[56] = createBaseVNode("label", null, "Z Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.zRotation,
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateProperty("zRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.transform]
            ])
          ]),
          createBaseVNode("div", _hoisted_20$8, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("lens"))
            }, [
              createBaseVNode("span", _hoisted_21$8, toDisplayString(expandedSections.lens ? "" : ""), 1),
              _cache[57] || (_cache[57] = createTextVNode(" Lens ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_22$8, [
              createBaseVNode("div", _hoisted_23$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(CAMERA_PRESETS), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.name,
                    class: normalizeClass({ active: Math.abs(camera.value.focalLength - preset.focalLength) < 0.5 }),
                    onClick: ($event) => applyPreset(preset)
                  }, toDisplayString(preset.name), 11, _hoisted_24$6);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_25$6, [
                _cache[58] || (_cache[58] = createBaseVNode("label", null, "Focal Length", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.focalLength,
                  "onUpdate:modelValue": updateFocalLength,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_26$6, [
                _cache[59] || (_cache[59] = createBaseVNode("label", null, "Angle of View", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.angleOfView,
                  "onUpdate:modelValue": updateAngleOfView,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_27$6, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Film Size", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.filmSize,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateProperty("filmSize", v)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_28$6, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Measure Film Size", -1)),
                createBaseVNode("select", {
                  value: camera.value.measureFilmSize,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateProperty("measureFilmSize", $event.target.value))
                }, [..._cache[61] || (_cache[61] = [
                  createBaseVNode("option", { value: "horizontal" }, "Horizontal", -1),
                  createBaseVNode("option", { value: "vertical" }, "Vertical", -1),
                  createBaseVNode("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, _hoisted_29$6)
              ])
            ], 512), [
              [vShow, expandedSections.lens]
            ])
          ]),
          createBaseVNode("div", _hoisted_30$6, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[17] || (_cache[17] = ($event) => toggleSection("dof"))
            }, [
              createBaseVNode("span", _hoisted_31$4, toDisplayString(expandedSections.dof ? "" : ""), 1),
              _cache[63] || (_cache[63] = createTextVNode(" Depth of Field ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_32$4, [
              createBaseVNode("div", _hoisted_33$4, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: camera.value.depthOfField.enabled,
                    onChange: _cache[18] || (_cache[18] = ($event) => updateDOF("enabled", $event.target.checked))
                  }, null, 40, _hoisted_34$4),
                  _cache[64] || (_cache[64] = createTextVNode(" Enable DOF ", -1))
                ])
              ]),
              camera.value.depthOfField.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_35$4, [
                  _cache[65] || (_cache[65] = createBaseVNode("label", null, "Focus Distance", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updateDOF("focusDistance", v)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_36$4, [
                  _cache[66] || (_cache[66] = createBaseVNode("label", null, "f-Stop", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.fStop,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateDOF("fStop", v)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_37$4, [
                  _cache[67] || (_cache[67] = createBaseVNode("label", null, "Blur Level", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: camera.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateDOF("blurLevel", v)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_38$3, [
                  createBaseVNode("label", null, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: camera.value.depthOfField.lockToZoom,
                      onChange: _cache[22] || (_cache[22] = ($event) => updateDOF("lockToZoom", $event.target.checked))
                    }, null, 40, _hoisted_39$3),
                    _cache[68] || (_cache[68] = createTextVNode(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : createCommentVNode("", true)
            ], 512), [
              [vShow, expandedSections.dof]
            ])
          ]),
          createBaseVNode("div", _hoisted_40$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[23] || (_cache[23] = ($event) => toggleSection("iris"))
            }, [
              createBaseVNode("span", _hoisted_41$2, toDisplayString(expandedSections.iris ? "" : ""), 1),
              _cache[69] || (_cache[69] = createTextVNode(" Iris ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_42$2, [
              createBaseVNode("div", _hoisted_43$2, [
                createBaseVNode("label", null, "Shape (" + toDisplayString(Math.round(camera.value.iris.shape)) + "-gon)", 1),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.shape,
                  "onUpdate:modelValue": _cache[24] || (_cache[24] = (v) => updateIris("shape", v)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_44$2, [
                _cache[70] || (_cache[70] = createBaseVNode("label", null, "Rotation", -1)),
                createVNode(unref(AngleDial), {
                  modelValue: camera.value.iris.rotation,
                  "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateIris("rotation", v)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_45$2, [
                _cache[71] || (_cache[71] = createBaseVNode("label", null, "Roundness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.roundness,
                  "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateIris("roundness", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_46$2, [
                _cache[72] || (_cache[72] = createBaseVNode("label", null, "Aspect Ratio", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.aspectRatio,
                  "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateIris("aspectRatio", v)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_47$2, [
                _cache[73] || (_cache[73] = createBaseVNode("label", null, "Diffraction Fringe", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.diffractionFringe,
                  "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateIris("diffractionFringe", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.iris]
            ])
          ]),
          createBaseVNode("div", _hoisted_48$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("highlight"))
            }, [
              createBaseVNode("span", _hoisted_49$2, toDisplayString(expandedSections.highlight ? "" : ""), 1),
              _cache[74] || (_cache[74] = createTextVNode(" Highlight ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_50$1, [
              createBaseVNode("div", _hoisted_51$1, [
                _cache[75] || (_cache[75] = createBaseVNode("label", null, "Gain", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.gain,
                  "onUpdate:modelValue": _cache[30] || (_cache[30] = (v) => updateHighlight("gain", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_52$1, [
                _cache[76] || (_cache[76] = createBaseVNode("label", null, "Threshold", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.threshold,
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateHighlight("threshold", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_53$1, [
                _cache[77] || (_cache[77] = createBaseVNode("label", null, "Saturation", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.saturation,
                  "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateHighlight("saturation", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.highlight]
            ])
          ]),
          createBaseVNode("div", _hoisted_54$1, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[33] || (_cache[33] = ($event) => toggleSection("autoOrient"))
            }, [
              createBaseVNode("span", _hoisted_55$1, toDisplayString(expandedSections.autoOrient ? "" : ""), 1),
              _cache[78] || (_cache[78] = createTextVNode(" Auto-Orient ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_56$1, [
              createBaseVNode("div", _hoisted_57$1, [
                createBaseVNode("select", {
                  value: camera.value.autoOrient,
                  onChange: _cache[34] || (_cache[34] = ($event) => updateProperty("autoOrient", $event.target.value))
                }, [..._cache[79] || (_cache[79] = [
                  createBaseVNode("option", { value: "off" }, "Off", -1),
                  createBaseVNode("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  createBaseVNode("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, _hoisted_58$1)
              ])
            ], 512), [
              [vShow, expandedSections.autoOrient]
            ])
          ]),
          createBaseVNode("div", _hoisted_59$1, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[35] || (_cache[35] = ($event) => toggleSection("clipping"))
            }, [
              createBaseVNode("span", _hoisted_60$1, toDisplayString(expandedSections.clipping ? "" : ""), 1),
              _cache[80] || (_cache[80] = createTextVNode(" Clipping ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_61$1, [
              createBaseVNode("div", _hoisted_62$1, [
                _cache[81] || (_cache[81] = createBaseVNode("label", null, "Near Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.nearClip,
                  "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateProperty("nearClip", v)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_63, [
                _cache[82] || (_cache[82] = createBaseVNode("label", null, "Far Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.farClip,
                  "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateProperty("farClip", v)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.clipping]
            ])
          ]),
          createBaseVNode("div", _hoisted_64, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[38] || (_cache[38] = ($event) => toggleSection("trajectory"))
            }, [
              createBaseVNode("span", _hoisted_65, toDisplayString(expandedSections.trajectory ? "" : ""), 1),
              _cache[83] || (_cache[83] = createTextVNode(" Trajectory ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_66, [
              createBaseVNode("div", _hoisted_67, [
                _cache[84] || (_cache[84] = createBaseVNode("label", null, "Motion Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[39] || (_cache[39] = ($event) => trajectoryConfig.type = $event),
                  class: "trajectory-select"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(trajectoryTypesByCategory.value, (types, category) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: category,
                      label: category
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(types, (type) => {
                        return openBlock(), createElementBlock("option", {
                          key: type,
                          value: type
                        }, toDisplayString(formatTrajectoryName(type)), 9, _hoisted_69);
                      }), 128))
                    ], 8, _hoisted_68);
                  }), 128))
                ], 512), [
                  [vModelSelect, trajectoryConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_70, toDisplayString(trajectoryDescription.value), 1),
              createBaseVNode("div", _hoisted_71, [
                _cache[85] || (_cache[85] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.duration,
                  "onUpdate:modelValue": _cache[40] || (_cache[40] = (v) => trajectoryConfig.duration = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_72, [
                _cache[86] || (_cache[86] = createBaseVNode("label", null, "Amplitude", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: Math.abs(trajectoryConfig.amplitude),
                  "onUpdate:modelValue": _cache[41] || (_cache[41] = (v) => trajectoryConfig.amplitude = v * Math.sign(trajectoryConfig.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              isOrbitalTrajectory.value ? (openBlock(), createElementBlock("div", _hoisted_73, [
                _cache[87] || (_cache[87] = createBaseVNode("label", null, "Loops", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.loops,
                  "onUpdate:modelValue": _cache[42] || (_cache[42] = (v) => trajectoryConfig.loops = v),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_74, [
                _cache[89] || (_cache[89] = createBaseVNode("label", null, "Easing", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => trajectoryConfig.easing = $event)
                }, [..._cache[88] || (_cache[88] = [
                  createStaticVNode('<option value="linear" data-v-e0e3fe0b>Linear</option><option value="ease-in" data-v-e0e3fe0b>Ease In</option><option value="ease-out" data-v-e0e3fe0b>Ease Out</option><option value="ease-in-out" data-v-e0e3fe0b>Ease In-Out</option><option value="bounce" data-v-e0e3fe0b>Bounce</option>', 5)
                ])], 512), [
                  [vModelSelect, trajectoryConfig.easing]
                ])
              ]),
              createBaseVNode("div", _hoisted_75, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => trajectoryConfig.audioReactive = $event)
                  }, null, 512), [
                    [vModelCheckbox, trajectoryConfig.audioReactive]
                  ]),
                  _cache[90] || (_cache[90] = createTextVNode(" Audio Reactive ", -1))
                ])
              ]),
              trajectoryConfig.audioReactive ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_76, [
                  _cache[92] || (_cache[92] = createBaseVNode("label", null, "Audio Feature", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[45] || (_cache[45] = ($event) => trajectoryConfig.audioFeature = $event)
                  }, [..._cache[91] || (_cache[91] = [
                    createStaticVNode('<option value="amplitude" data-v-e0e3fe0b>Amplitude</option><option value="bass" data-v-e0e3fe0b>Bass</option><option value="mid" data-v-e0e3fe0b>Mid</option><option value="high" data-v-e0e3fe0b>High</option><option value="onsets" data-v-e0e3fe0b>Onsets</option>', 5)
                  ])], 512), [
                    [vModelSelect, trajectoryConfig.audioFeature]
                  ])
                ]),
                createBaseVNode("div", _hoisted_77, [
                  _cache[93] || (_cache[93] = createBaseVNode("label", null, "Sensitivity", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: trajectoryConfig.audioSensitivity ?? 1,
                    "onUpdate:modelValue": _cache[46] || (_cache[46] = (v) => trajectoryConfig.audioSensitivity = v),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("div", { class: "trajectory-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewTrajectory
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyTrajectory
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.trajectory]
            ])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_78, [
          _cache[94] || (_cache[94] = createBaseVNode("p", null, "No camera selected", -1)),
          createBaseVNode("button", { onClick: createCamera }, "Create Camera")
        ]))
      ]);
    };
  }
});

const CameraProperties = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-e0e3fe0b"]]);

const _hoisted_1$f = { class: "audio-properties" };
const _hoisted_2$f = { class: "property-section" };
const _hoisted_3$f = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$f = { class: "property-row" };
const _hoisted_5$f = { class: "value-display" };
const _hoisted_6$f = { class: "property-row" };
const _hoisted_7$f = { class: "value-display" };
const _hoisted_8$e = { class: "property-row" };
const _hoisted_9$d = { class: "value-display" };
const _hoisted_10$d = { class: "property-row" };
const _hoisted_11$c = {
  key: 0,
  class: "peak-count"
};
const _hoisted_12$a = { class: "property-section" };
const _hoisted_13$9 = { class: "mapping-count" };
const _hoisted_14$8 = {
  key: 0,
  class: "section-content"
};
const _hoisted_15$8 = { class: "mapping-header" };
const _hoisted_16$8 = { class: "mapping-enabled" };
const _hoisted_17$8 = ["onUpdate:modelValue"];
const _hoisted_18$8 = { class: "mapping-name" };
const _hoisted_19$7 = ["onClick"];
const _hoisted_20$7 = {
  key: 0,
  class: "mapping-details"
};
const _hoisted_21$7 = { class: "property-row" };
const _hoisted_22$7 = ["onUpdate:modelValue"];
const _hoisted_23$7 = ["label"];
const _hoisted_24$5 = ["value"];
const _hoisted_25$5 = { class: "property-row" };
const _hoisted_26$5 = ["onUpdate:modelValue"];
const _hoisted_27$5 = ["label"];
const _hoisted_28$5 = ["value"];
const _hoisted_29$5 = { class: "property-row" };
const _hoisted_30$5 = ["onUpdate:modelValue"];
const _hoisted_31$3 = { class: "value-display" };
const _hoisted_32$3 = { class: "property-row" };
const _hoisted_33$3 = ["onUpdate:modelValue"];
const _hoisted_34$3 = { class: "value-display" };
const _hoisted_35$3 = { class: "property-row" };
const _hoisted_36$3 = ["onUpdate:modelValue"];
const _hoisted_37$3 = { class: "value-display" };
const _hoisted_38$2 = { class: "property-row" };
const _hoisted_39$2 = ["onUpdate:modelValue"];
const _hoisted_40$1 = ["onUpdate:modelValue"];
const _hoisted_41$1 = { class: "property-row" };
const _hoisted_42$1 = ["onUpdate:modelValue"];
const _hoisted_43$1 = { class: "value-display" };
const _hoisted_44$1 = { class: "property-row" };
const _hoisted_45$1 = ["onUpdate:modelValue"];
const _hoisted_46$1 = { class: "value-display" };
const _hoisted_47$1 = { class: "property-row" };
const _hoisted_48$1 = ["onUpdate:modelValue"];
const _hoisted_49$1 = { class: "property-row" };
const _hoisted_50 = ["onUpdate:modelValue"];
const _hoisted_51 = {
  key: 0,
  class: "property-row"
};
const _hoisted_52 = ["onUpdate:modelValue"];
const _hoisted_53 = { class: "value-display" };
const _hoisted_54 = { class: "property-row checkbox-row" };
const _hoisted_55 = ["onUpdate:modelValue"];
const _hoisted_56 = ["onClick"];
const _hoisted_57 = { class: "property-section" };
const _hoisted_58 = {
  key: 0,
  class: "section-content"
};
const _hoisted_59 = { class: "property-row" };
const _hoisted_60 = ["value"];
const _hoisted_61 = { class: "visualizer-canvas-container" };
const _hoisted_62 = { class: "visualizer-value" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "AudioProperties",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(/* @__PURE__ */ new Set(["peaks", "mappings"]));
    const expandedMappings = ref(/* @__PURE__ */ new Set());
    const peakConfig = ref({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    });
    const peakData = ref(null);
    const mappings = ref([]);
    const visualizerFeature = ref("amplitude");
    const visualizerCanvas = ref(null);
    const allFeatures = computed(() => getAllFeatures());
    const featuresByCategory = computed(() => getFeaturesByCategory());
    const targetsByCategory = computed(() => getTargetsByCategory());
    const playheadPosition = computed(
      () => store.currentFrame / store.frameCount * 100
    );
    const currentFeatureValue = computed(() => {
      if (!store.audioAnalysis) return 0;
      return getFeatureAtFrame(store.audioAnalysis, visualizerFeature.value, store.currentFrame);
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleMappingExpanded(id) {
      if (expandedMappings.value.has(id)) {
        expandedMappings.value.delete(id);
      } else {
        expandedMappings.value.add(id);
      }
    }
    function detectPeaks$1() {
      if (!store.audioAnalysis) return;
      const weights = store.audioAnalysis.amplitudeEnvelope;
      peakData.value = detectPeaks(weights, peakConfig.value);
      store.setPeakData(peakData.value);
    }
    function addMapping() {
      const mapping = createDefaultAudioMapping();
      mappings.value.push(mapping);
      expandedMappings.value.add(mapping.id);
      store.addAudioMapping(mapping);
    }
    function removeMapping(id) {
      const index = mappings.value.findIndex((m) => m.id === id);
      if (index >= 0) {
        mappings.value.splice(index, 1);
        expandedMappings.value.delete(id);
        store.removeAudioMapping(id);
      }
    }
    function drawVisualizer() {
      const canvas = visualizerCanvas.value;
      if (!canvas || !store.audioAnalysis) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, width, height);
      let featureData = [];
      const analysis = store.audioAnalysis;
      switch (visualizerFeature.value) {
        case "amplitude":
          featureData = analysis.amplitudeEnvelope;
          break;
        case "rms":
          featureData = analysis.rmsEnergy;
          break;
        case "spectralCentroid":
          featureData = analysis.spectralCentroid;
          break;
        case "bass":
          featureData = analysis.frequencyBands.bass;
          break;
        case "mid":
          featureData = analysis.frequencyBands.mid;
          break;
        case "high":
          featureData = analysis.frequencyBands.high;
          break;
        case "sub":
          featureData = analysis.frequencyBands.sub;
          break;
        case "lowMid":
          featureData = analysis.frequencyBands.lowMid;
          break;
        case "highMid":
          featureData = analysis.frequencyBands.highMid;
          break;
        case "spectralFlux":
          featureData = analysis.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          featureData = analysis.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          featureData = analysis.spectralRolloff || [];
          break;
        case "spectralFlatness":
          featureData = analysis.spectralFlatness || [];
          break;
        case "chromaEnergy":
          featureData = analysis.chromaFeatures?.chromaEnergy || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if (analysis.chromaFeatures?.chroma) {
            const pitchIndex = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(visualizerFeature.value);
            featureData = analysis.chromaFeatures.chroma.map((frame) => frame[pitchIndex] || 0);
          }
          break;
        case "onsets":
          featureData = new Array(analysis.frameCount).fill(0);
          for (const onset of analysis.onsets) {
            if (onset < featureData.length) featureData[onset] = 1;
          }
          break;
        case "peaks":
          if (peakData.value) {
            featureData = new Array(analysis.frameCount).fill(0);
            for (const peakIndex of peakData.value.indices) {
              if (peakIndex < featureData.length) featureData[peakIndex] = 1;
            }
          }
          break;
      }
      if (featureData.length === 0) return;
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < featureData.length; i++) {
        const x = i / featureData.length * width;
        const y = height - featureData[i] * height * 0.9 - 5;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      if (peakData.value && visualizerFeature.value !== "peaks") {
        ctx.fillStyle = "#ff6b6b";
        for (const peakIndex of peakData.value.indices) {
          const x = peakIndex / featureData.length * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.strokeStyle = "rgba(255, 107, 107, 0.3)";
          ctx.stroke();
        }
      }
    }
    watch(
      () => [store.audioAnalysis, visualizerFeature.value, peakData.value],
      () => {
        drawVisualizer();
      }
    );
    watch(
      mappings,
      (newMappings) => {
        for (const mapping of newMappings) {
          store.updateAudioMapping(mapping.id, mapping);
        }
      },
      { deep: true }
    );
    onMounted(() => {
      drawVisualizer();
      const existingMappings = store.getAudioMappings();
      if (existingMappings.length > 0) {
        mappings.value = [...existingMappings];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("div", _hoisted_2$f, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("peaks"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[7] || (_cache[7] = createBaseVNode("span", null, "Peak Detection", -1))
          ]),
          expandedSections.value.has("peaks") ? (openBlock(), createElementBlock("div", _hoisted_3$f, [
            createBaseVNode("div", _hoisted_4$f, [
              _cache[8] || (_cache[8] = createBaseVNode("label", null, "Threshold", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => peakConfig.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.01"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.threshold,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_5$f, toDisplayString(peakConfig.value.threshold.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_6$f, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Min Peak Distance", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => peakConfig.value.minPeaksDistance = $event),
                min: "1",
                max: "60",
                step: "1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.minPeaksDistance,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_7$f, toDisplayString(peakConfig.value.minPeaksDistance) + " frames", 1)
            ]),
            createBaseVNode("div", _hoisted_8$e, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Multiply", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => peakConfig.value.multiply = $event),
                min: "0.1",
                max: "5",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.multiply,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$d, toDisplayString(peakConfig.value.multiply.toFixed(1)) + "x", 1)
            ]),
            createBaseVNode("div", _hoisted_10$d, [
              createBaseVNode("button", {
                class: "action-btn",
                onClick: detectPeaks$1
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("i", { class: "pi pi-bolt" }, null, -1),
                createTextVNode(" Detect Peaks ", -1)
              ])]),
              peakData.value ? (openBlock(), createElementBlock("span", _hoisted_11$c, toDisplayString(peakData.value.count) + " peaks found ", 1)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_12$a, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[4] || (_cache[4] = ($event) => toggleSection("mappings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[12] || (_cache[12] = createBaseVNode("span", null, "Audio Mappings", -1)),
            createBaseVNode("span", _hoisted_13$9, toDisplayString(mappings.value.length), 1)
          ]),
          expandedSections.value.has("mappings") ? (openBlock(), createElementBlock("div", _hoisted_14$8, [
            createBaseVNode("button", {
              class: "action-btn add-mapping-btn",
              onClick: addMapping
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
              createTextVNode(" Add Mapping ", -1)
            ])]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(mappings.value, (mapping) => {
              return openBlock(), createElementBlock("div", {
                key: mapping.id,
                class: "mapping-item"
              }, [
                createBaseVNode("div", _hoisted_15$8, [
                  createBaseVNode("label", _hoisted_16$8, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ($event) => mapping.enabled = $event
                    }, null, 8, _hoisted_17$8), [
                      [vModelCheckbox, mapping.enabled]
                    ])
                  ]),
                  createBaseVNode("span", _hoisted_18$8, toDisplayString(unref(getFeatureDisplayName)(mapping.feature)) + "  " + toDisplayString(unref(getTargetDisplayName)(mapping.target)), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: ($event) => removeMapping(mapping.id)
                  }, [..._cache[14] || (_cache[14] = [
                    createBaseVNode("i", { class: "pi pi-times" }, null, -1)
                  ])], 8, _hoisted_19$7)
                ]),
                expandedMappings.value.has(mapping.id) ? (openBlock(), createElementBlock("div", _hoisted_20$7, [
                  createBaseVNode("div", _hoisted_21$7, [
                    _cache[15] || (_cache[15] = createBaseVNode("label", null, "Feature", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.feature = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(featuresByCategory.value, (feats, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(feats, (feat) => {
                            return openBlock(), createElementBlock("option", {
                              key: feat,
                              value: feat
                            }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_24$5);
                          }), 128))
                        ], 8, _hoisted_23$7);
                      }), 128))
                    ], 8, _hoisted_22$7), [
                      [vModelSelect, mapping.feature]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_25$5, [
                    _cache[16] || (_cache[16] = createBaseVNode("label", null, "Target", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.target = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targetsByCategory.value, (targets, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                            return openBlock(), createElementBlock("option", {
                              key: target,
                              value: target
                            }, toDisplayString(unref(getTargetDisplayName)(target)), 9, _hoisted_28$5);
                          }), 128))
                        ], 8, _hoisted_27$5);
                      }), 128))
                    ], 8, _hoisted_26$5), [
                      [vModelSelect, mapping.target]
                    ])
                  ]),
                  _cache[30] || (_cache[30] = createBaseVNode("div", { class: "subsection-header" }, "Basic Controls", -1)),
                  createBaseVNode("div", _hoisted_29$5, [
                    _cache[17] || (_cache[17] = createBaseVNode("label", null, "Sensitivity", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.sensitivity = $event,
                      min: "0.1",
                      max: "5",
                      step: "0.1"
                    }, null, 8, _hoisted_30$5), [
                      [
                        vModelText,
                        mapping.sensitivity,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_31$3, toDisplayString(mapping.sensitivity.toFixed(1)) + "x", 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$3, [
                    _cache[18] || (_cache[18] = createBaseVNode("label", null, "Threshold", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.threshold = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_33$3), [
                      [
                        vModelText,
                        mapping.threshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_34$3, toDisplayString(mapping.threshold.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$3, [
                    _cache[19] || (_cache[19] = createBaseVNode("label", null, "Smoothing", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.smoothing = $event,
                      min: "0",
                      max: "0.99",
                      step: "0.01"
                    }, null, 8, _hoisted_36$3), [
                      [
                        vModelText,
                        mapping.smoothing,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_37$3, toDisplayString(mapping.smoothing.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$2, [
                    _cache[20] || (_cache[20] = createBaseVNode("label", null, "Min/Max", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.min = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_39$2), [
                      [
                        vModelText,
                        mapping.min,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "separator" }, "-", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.max = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_40$1), [
                      [
                        vModelText,
                        mapping.max,
                        void 0,
                        { number: true }
                      ]
                    ])
                  ]),
                  _cache[31] || (_cache[31] = createBaseVNode("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                  createBaseVNode("div", _hoisted_41$1, [
                    _cache[22] || (_cache[22] = createBaseVNode("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.amplitudeCurve = $event,
                      min: "0.1",
                      max: "4",
                      step: "0.1"
                    }, null, 8, _hoisted_42$1), [
                      [
                        vModelText,
                        mapping.amplitudeCurve,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_43$1, toDisplayString(mapping.amplitudeCurve?.toFixed(1) || "1.0"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$1, [
                    _cache[23] || (_cache[23] = createBaseVNode("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.release = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_45$1), [
                      [
                        vModelText,
                        mapping.release,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_46$1, toDisplayString(mapping.release?.toFixed(2) || "0.50"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$1, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", null, "Curve", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.curve = $event,
                      class: "curve-select"
                    }, [..._cache[24] || (_cache[24] = [
                      createStaticVNode('<option value="linear" data-v-0611c34c>Linear</option><option value="exponential" data-v-0611c34c>Exponential</option><option value="logarithmic" data-v-0611c34c>Logarithmic</option><option value="smoothstep" data-v-0611c34c>Smoothstep</option><option value="bounce" data-v-0611c34c>Bounce</option>', 5)
                    ])], 8, _hoisted_48$1), [
                      [vModelSelect, mapping.curve]
                    ])
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("div", { class: "subsection-header" }, "Beat Response", -1)),
                  createBaseVNode("div", _hoisted_49$1, [
                    _cache[27] || (_cache[27] = createBaseVNode("label", null, "On Beat", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.beatResponse = $event,
                      class: "beat-select"
                    }, [..._cache[26] || (_cache[26] = [
                      createBaseVNode("option", { value: "none" }, "None", -1),
                      createBaseVNode("option", { value: "flip" }, "Flip (reverse direction)", -1),
                      createBaseVNode("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                      createBaseVNode("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                    ])], 8, _hoisted_50), [
                      [vModelSelect, mapping.beatResponse]
                    ])
                  ]),
                  mapping.beatResponse !== "none" ? (openBlock(), createElementBlock("div", _hoisted_51, [
                    _cache[28] || (_cache[28] = createBaseVNode("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.beatThreshold = $event,
                      min: "0.01",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_52), [
                      [
                        vModelText,
                        mapping.beatThreshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_53, toDisplayString(mapping.beatThreshold?.toFixed(2) || "0.50"), 1)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_54, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": ($event) => mapping.invert = $event
                      }, null, 8, _hoisted_55), [
                        [vModelCheckbox, mapping.invert]
                      ]),
                      _cache[29] || (_cache[29] = createTextVNode(" Invert Output ", -1))
                    ])
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  class: "expand-btn",
                  onClick: ($event) => toggleMappingExpanded(mapping.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedMappings.value.has(mapping.id) ? "pi-chevron-up" : "pi-chevron-down"])
                  }, null, 2)
                ], 8, _hoisted_56)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_57, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("visualizer"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Feature Visualizer", -1))
          ]),
          expandedSections.value.has("visualizer") ? (openBlock(), createElementBlock("div", _hoisted_58, [
            createBaseVNode("div", _hoisted_59, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Feature", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => visualizerFeature.value = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allFeatures.value, (feat) => {
                  return openBlock(), createElementBlock("option", {
                    key: feat,
                    value: feat
                  }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_60);
                }), 128))
              ], 512), [
                [vModelSelect, visualizerFeature.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_61, [
              createBaseVNode("canvas", {
                ref_key: "visualizerCanvas",
                ref: visualizerCanvas,
                class: "visualizer-canvas",
                width: "240",
                height: "60"
              }, null, 512),
              createBaseVNode("div", {
                class: "visualizer-playhead",
                style: normalizeStyle({ left: `${playheadPosition.value}%` })
              }, null, 4)
            ]),
            createBaseVNode("div", _hoisted_62, " Current: " + toDisplayString(currentFeatureValue.value.toFixed(3)), 1)
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AudioProperties = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-0611c34c"]]);

const _hoisted_1$e = { class: "audio-panel" };
const _hoisted_2$e = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$e = { class: "audio-info" };
const _hoisted_4$e = { class: "file-info" };
const _hoisted_5$e = { class: "file-details" };
const _hoisted_6$e = { class: "file-name" };
const _hoisted_7$e = { class: "file-meta" };
const _hoisted_8$d = { class: "control-section" };
const _hoisted_9$c = { class: "control-row" };
const _hoisted_10$c = { class: "waveform-section" };
const _hoisted_11$b = { class: "waveform-display" };
const _hoisted_12$9 = { class: "linker-section" };
const _hoisted_13$8 = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "AudioPanel",
  setup(__props) {
    const store = useCompositorStore();
    const audioFileInput = ref(null);
    const waveformCanvas = ref(null);
    const masterVolume = ref(100);
    const isMuted = ref(false);
    const hasAudio = computed(() => !!store.audioBuffer);
    const audioFileName = computed(() => store.audioFile?.name || "Unknown");
    const audioSampleRate = computed(() => store.audioBuffer ? `${(store.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "");
    const audioDuration = computed(() => {
      if (!store.audioBuffer) return "0:00";
      const m = Math.floor(store.audioBuffer.duration / 60);
      const s = Math.floor(store.audioBuffer.duration % 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    });
    function loadAudioFile() {
      audioFileInput.value?.click();
    }
    async function handleAudioFileSelected(e) {
      const input = e.target;
      if (input.files?.length) await store.loadAudio(input.files[0]);
      input.value = "";
    }
    function removeAudio() {
      store.clearAudio();
    }
    function toggleMute() {
      isMuted.value = !isMuted.value;
    }
    function drawWaveform() {
      if (!waveformCanvas.value || !store.audioBuffer) return;
      const canvas = waveformCanvas.value;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 60 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      const data = store.audioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / rect.width);
      const amp = 30;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, rect.width, 60);
      ctx.beginPath();
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1;
      for (let i = 0; i < rect.width; i++) {
        let min = 1;
        let max = -1;
        for (let j = 0; j < step; j++) {
          const datum = data[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.stroke();
      const px = store.currentFrame / store.frameCount * rect.width;
      ctx.fillStyle = "#fff";
      ctx.fillRect(px, 0, 1, 60);
    }
    watch(() => [store.audioBuffer, store.currentFrame], drawWaveform);
    onMounted(() => {
      if (hasAudio.value) {
        setTimeout(drawWaveform, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        createBaseVNode("div", { class: "panel-header" }, [
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "panel-title" }, "Audio Source", -1)),
          createBaseVNode("div", { class: "header-actions" }, [
            createBaseVNode("button", {
              onClick: loadAudioFile,
              title: "Load Audio"
            }, [..._cache[1] || (_cache[1] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ])
        ]),
        hasAudio.value ? (openBlock(), createElementBlock("div", _hoisted_2$e, [
          createBaseVNode("div", _hoisted_3$e, [
            createBaseVNode("div", _hoisted_4$e, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "file-icon" }, "", -1)),
              createBaseVNode("div", _hoisted_5$e, [
                createBaseVNode("span", _hoisted_6$e, toDisplayString(audioFileName.value), 1),
                createBaseVNode("span", _hoisted_7$e, toDisplayString(audioDuration.value) + "  " + toDisplayString(audioSampleRate.value), 1)
              ]),
              createBaseVNode("button", {
                class: "remove-btn",
                onClick: removeAudio,
                title: "Remove Audio"
              }, "")
            ])
          ]),
          createBaseVNode("div", _hoisted_8$d, [
            createBaseVNode("div", _hoisted_9$c, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Master Vol", -1)),
              createVNode(unref(SliderInput), {
                modelValue: masterVolume.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => masterVolume.value = $event),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["mute-btn", { active: isMuted.value }]),
                onClick: toggleMute,
                title: "Mute"
              }, toDisplayString(isMuted.value ? "" : ""), 3)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$c, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Waveform")
            ], -1)),
            createBaseVNode("div", _hoisted_11$b, [
              createBaseVNode("canvas", {
                ref_key: "waveformCanvas",
                ref: waveformCanvas,
                class: "waveform-canvas"
              }, null, 512)
            ])
          ]),
          createBaseVNode("div", _hoisted_12$9, [
            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "linker-header" }, "Audio Linker", -1)),
            createVNode(AudioProperties)
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_13$8, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "empty-icon" }, "", -1)),
          _cache[8] || (_cache[8] = createBaseVNode("p", null, "No audio loaded", -1)),
          createBaseVNode("button", {
            class: "load-btn",
            onClick: loadAudioFile
          }, "Load Audio File"),
          _cache[9] || (_cache[9] = createBaseVNode("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
        ])),
        createBaseVNode("input", {
          ref_key: "audioFileInput",
          ref: audioFileInput,
          type: "file",
          accept: "audio/*",
          style: { "display": "none" },
          onChange: handleAudioFileSelected
        }, null, 544)
      ]);
    };
  }
});

const AudioPanel = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-66384e06"]]);

const CAMERA_BODY_SIZE = 40;
const CAMERA_LENS_LENGTH = 30;
function generateCameraBody(camera) {
  const lines = [];
  const color = "#ffcc00";
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const halfSize = CAMERA_BODY_SIZE / 2;
  const bodyBack = addVec3(pos, scaleVec3(forward, -CAMERA_BODY_SIZE));
  const corners = [];
  for (let z = 0; z < 2; z++) {
    const zOffset = z === 0 ? pos : bodyBack;
    for (let x = -1; x <= 1; x += 2) {
      for (let y = -1; y <= 1; y += 2) {
        corners.push(addVec3(
          addVec3(zOffset, scaleVec3(right, x * halfSize)),
          scaleVec3(up, y * halfSize)
        ));
      }
    }
  }
  lines.push({ start: corners[0], end: corners[1], color });
  lines.push({ start: corners[1], end: corners[3], color });
  lines.push({ start: corners[3], end: corners[2], color });
  lines.push({ start: corners[2], end: corners[0], color });
  lines.push({ start: corners[4], end: corners[5], color });
  lines.push({ start: corners[5], end: corners[7], color });
  lines.push({ start: corners[7], end: corners[6], color });
  lines.push({ start: corners[6], end: corners[4], color });
  lines.push({ start: corners[0], end: corners[4], color });
  lines.push({ start: corners[1], end: corners[5], color });
  lines.push({ start: corners[2], end: corners[6], color });
  lines.push({ start: corners[3], end: corners[7], color });
  const lensEnd = addVec3(pos, scaleVec3(forward, CAMERA_LENS_LENGTH));
  const lensPoints = 8;
  for (let i = 0; i < lensPoints; i++) {
    const angle = i / lensPoints * Math.PI * 2;
    const nextAngle = (i + 1) / lensPoints * Math.PI * 2;
    const p1 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(angle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(angle) * halfSize * 0.5)
    );
    const p2 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(nextAngle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(nextAngle) * halfSize * 0.5)
    );
    lines.push({ start: p1, end: p2, color });
    lines.push({ start: p1, end: lensEnd, color });
  }
  return lines;
}
function generateFrustum(camera, compWidth, compHeight, maxDistance = 2e3) {
  const lines = [];
  const color = "#7c9cff";
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  const aspect = compWidth / compHeight;
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const near = camera.nearClip;
  const far = Math.min(camera.farClip, maxDistance);
  const nearHalfHeight = near * Math.tan(fovY * Math.PI / 360);
  const nearHalfWidth = nearHalfHeight * aspect;
  const farHalfHeight = far * Math.tan(fovY * Math.PI / 360);
  const farHalfWidth = farHalfHeight * aspect;
  const nearCenter = addVec3(pos, scaleVec3(forward, near));
  const nearCorners = [
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, -nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, -nearHalfHeight))
  ];
  const farCenter = addVec3(pos, scaleVec3(forward, far));
  const farCorners = [
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, -farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, -farHalfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: nearCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: farCorners[i], end: farCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: farCorners[i], color });
  }
  return lines;
}
function generateCompositionBounds(compWidth, compHeight) {
  const color = "#00ff88";
  const corners = [
    vec3(0, 0, 0),
    vec3(compWidth, 0, 0),
    vec3(compWidth, compHeight, 0),
    vec3(0, compHeight, 0)
  ];
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  lines.push({ start: corners[0], end: corners[2], color: "#005533" });
  lines.push({ start: corners[1], end: corners[3], color: "#005533" });
  return lines;
}
function generatePOILine(camera) {
  if (camera.type !== "two-node") {
    return null;
  }
  return {
    start: camera.position,
    end: camera.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function generateFocalPlane(camera, compWidth, compHeight) {
  if (!camera.depthOfField.enabled) {
    return [];
  }
  const color = "#ff00ff";
  const lines = [];
  const pos = camera.position;
  const focusDist = camera.depthOfField.focusDistance;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const center = addVec3(pos, scaleVec3(forward, focusDist));
  const halfWidth = compWidth / 4;
  const halfHeight = compHeight / 4;
  const corners = [
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, -halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, -halfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  return lines;
}
function generateCameraVisualization(camera, compWidth, compHeight, showFrustum = true, showBounds = true, showFocalPlane = false) {
  return {
    body: generateCameraBody(camera),
    frustum: showFrustum ? generateFrustum(camera, compWidth, compHeight) : [],
    compositionBounds: showBounds ? generateCompositionBounds(compWidth, compHeight) : [],
    poiLine: generatePOILine(camera),
    focalPlane: showFocalPlane ? generateFocalPlane(camera, compWidth, compHeight) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function getCameraViewMatrices(camera, compWidth, compHeight) {
  const aspect = compWidth / compHeight;
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  let target;
  if (camera.type === "two-node") {
    target = camera.pointOfInterest;
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    const forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
    target = addVec3(camera.position, scaleVec3(forward, 1e3));
  }
  const view = lookAtMat4(camera.position, target, vec3(0, -1, 0));
  const projection = perspectiveMat4(fovY, aspect, camera.nearClip, camera.farClip);
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function getOrthoViewMatrices(viewType, compWidth, compHeight, customView) {
  const aspect = compWidth / compHeight;
  let view;
  let size = 1e3;
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  switch (viewType) {
    case "front":
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "back":
      view = lookAtMat4(
        vec3(centerX, centerY, 2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "left":
      view = lookAtMat4(
        vec3(-2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "right":
      view = lookAtMat4(
        vec3(centerX + 2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "top":
      view = lookAtMat4(
        vec3(centerX, -2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, 1)
      );
      break;
    case "bottom":
      view = lookAtMat4(
        vec3(centerX, centerY + 2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (customView) {
        const phi = customView.orbitPhi * Math.PI / 180;
        const theta = customView.orbitTheta * Math.PI / 180;
        const dist = customView.orbitDistance;
        const eye = vec3(
          customView.orbitCenter.x + dist * Math.sin(phi) * Math.sin(theta),
          customView.orbitCenter.y + dist * Math.cos(phi),
          customView.orbitCenter.z + dist * Math.sin(phi) * Math.cos(theta)
        );
        view = lookAtMat4(
          eye,
          customView.orbitCenter,
          vec3(0, -1, 0)
        );
        size = 1e3 / customView.orthoZoom;
      } else {
        view = lookAtMat4(
          vec3(centerX, centerY, -2e3),
          vec3(centerX, centerY, 0),
          vec3(0, -1, 0)
        );
      }
      break;
    default:
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
  }
  const projection = orthographicMat4(
    -size * aspect,
    size * aspect,
    -size,
    size,
    1,
    1e4
  );
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function multiplyMat4Local(a, b) {
  const ae = a.elements;
  const be = b.elements;
  const result = new Float32Array(16);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      let sum = 0;
      for (let i = 0; i < 4; i++) {
        sum += ae[row + i * 4] * be[i + col * 4];
      }
      result[row + col * 4] = sum;
    }
  }
  return { elements: result };
}
function projectToScreen(point, viewProjection, screenWidth, screenHeight) {
  const transformed = transformPoint(viewProjection, point);
  const vp = viewProjection.elements;
  const w = point.x * vp[3] + point.y * vp[7] + point.z * vp[11] + vp[15];
  if (w <= 0) {
    return { x: 0, y: 0, z: transformed.z, visible: false };
  }
  const x = (transformed.x / w * 0.5 + 0.5) * screenWidth;
  const y = (-transformed.y / w * 0.5 + 0.5) * screenHeight;
  return {
    x,
    y,
    z: transformed.z / w,
    visible: true
  };
}
function generate3DAxes(center, length = 100) {
  return [
    { start: center, end: addVec3(center, vec3(length, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: center, end: addVec3(center, vec3(0, length, 0)), color: "#00ff00" },
    // Y - Green
    { start: center, end: addVec3(center, vec3(0, 0, length)), color: "#0000ff" }
    // Z - Blue
  ];
}
function generateGrid(compWidth, compHeight, spacing = 100) {
  const lines = [];
  const color = "#333333";
  const centerColor = "#444444";
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  const extent = Math.max(compWidth, compHeight);
  for (let x = -extent; x <= extent + compWidth; x += spacing) {
    const isCenter = Math.abs(x - centerX) < spacing / 2;
    lines.push({
      start: vec3(x, -extent, 0),
      end: vec3(x, extent + compHeight, 0),
      color: isCenter ? centerColor : color
    });
  }
  for (let y = -extent; y <= extent + compHeight; y += spacing) {
    const isCenter = Math.abs(y - centerY) < spacing / 2;
    lines.push({
      start: vec3(-extent, y, 0),
      end: vec3(extent + compWidth, y, 0),
      color: isCenter ? centerColor : color
    });
  }
  return lines;
}

const _hoisted_1$d = ["onClick"];
const _hoisted_2$d = { class: "view-header" };
const _hoisted_3$d = ["value", "onChange"];
const _hoisted_4$d = { class: "view-tools" };
const _hoisted_5$d = ["onClick"];
const _hoisted_6$d = ["onMousedown", "onWheel"];
const _hoisted_7$d = { class: "view-info" };
const _hoisted_8$c = { class: "view-name" };
const _hoisted_9$b = {
  key: 0,
  class: "view-coords"
};
const _hoisted_10$b = { class: "layout-controls" };
const _hoisted_11$a = ["onClick", "title"];
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "ViewportRenderer",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => store.activeCamera);
    const compWidth = computed(() => store.width);
    const compHeight = computed(() => store.height);
    const viewportState = computed(() => store.viewportState);
    const viewOptions = computed(() => store.viewOptions);
    const layers = computed(() => {
      return store.layers.filter((l) => l.type !== "camera").map((l) => ({
        id: l.id,
        name: l.name,
        position: {
          x: l.transform.position.value.x,
          y: l.transform.position.value.y,
          z: 0
          // 2D layers at z=0
        },
        selected: store.selectedLayerIds.includes(l.id)
      }));
    });
    const canvasRefs = ref([null, null, null, null]);
    const contexts = ref([null, null, null, null]);
    const isDragging = ref(false);
    const dragStartPos = ref({ x: 0, y: 0 });
    const dragViewIndex = ref(0);
    const dragButton = ref(0);
    const layoutOptions = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ];
    const layout = computed(() => viewportState.value.layout);
    const activeViewIndex = computed(() => viewportState.value.activeViewIndex);
    const customViews = computed(() => viewportState.value.customViews);
    const activeViews = computed(() => {
      switch (viewportState.value.layout) {
        case "1-view":
          return [viewportState.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return viewportState.value.views.slice(0, 2);
        case "4-view":
          return viewportState.value.views.slice(0, 4);
        default:
          return [viewportState.value.views[0]];
      }
    });
    function setCanvasRef(el, index) {
      canvasRefs.value[index] = el;
      if (el) {
        contexts.value[index] = el.getContext("2d");
      }
    }
    function isCustomView(viewType) {
      return viewType.startsWith("custom-");
    }
    function getViewDisplayName(viewType) {
      const names = {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        "front": "Front",
        "back": "Back",
        "left": "Left",
        "right": "Right",
        "top": "Top",
        "bottom": "Bottom"
      };
      return names[viewType];
    }
    function setActiveView(index) {
      store.updateViewportState({
        activeViewIndex: index
      });
    }
    function updateViewType(index, viewType) {
      const newViews = [...viewportState.value.views];
      newViews[index] = viewType;
      store.updateViewportState({
        views: newViews
      });
    }
    function setLayout(newLayout) {
      const defaultFourViews = ["active-camera", "top", "front", "right"];
      let newViews = [...viewportState.value.views];
      while (newViews.length < 4) {
        newViews.push(defaultFourViews[newViews.length] || "front");
      }
      store.updateViewportState({
        layout: newLayout,
        views: newViews,
        activeViewIndex: Math.min(viewportState.value.activeViewIndex, getViewCount(newLayout) - 1)
      });
    }
    function getViewCount(layout2) {
      switch (layout2) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function resetCustomView(viewType) {
      const defaultView = {
        orbitCenter: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      store.updateViewportState({
        customViews: {
          ...viewportState.value.customViews,
          [viewType]: defaultView
        }
      });
    }
    function onCanvasMouseDown(e, viewIndex) {
      isDragging.value = true;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      dragViewIndex.value = viewIndex;
      dragButton.value = e.button;
      document.addEventListener("mousemove", onCanvasMouseMove);
      document.addEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasMouseMove(e) {
      if (!isDragging.value) return;
      const dx = e.clientX - dragStartPos.value.x;
      const dy = e.clientY - dragStartPos.value.y;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      const viewType = activeViews.value[dragViewIndex.value];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        if (dragButton.value === 0) {
          const newTheta = customView.orbitTheta + dx * 0.5;
          const newPhi = Math.max(1, Math.min(179, customView.orbitPhi + dy * 0.5));
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orbitTheta: newTheta,
                orbitPhi: newPhi
              }
            }
          });
        } else if (dragButton.value === 1 || dragButton.value === 2) {
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orthoOffset: {
                  x: customView.orthoOffset.x + dx,
                  y: customView.orthoOffset.y + dy
                }
              }
            }
          });
        }
      }
    }
    function onCanvasMouseUp() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onCanvasMouseMove);
      document.removeEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasWheel(e, viewIndex) {
      e.preventDefault();
      const viewType = activeViews.value[viewIndex];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [viewType]: {
              ...customView,
              orbitDistance: customView.orbitDistance * zoomFactor
            }
          }
        });
      }
    }
    function render() {
      activeViews.value.forEach((viewType, index) => {
        const canvas = canvasRefs.value[index];
        const ctx = contexts.value[index];
        if (!canvas || !ctx) return;
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, rect.width, rect.height);
        let matrices;
        if (viewType === "active-camera" && camera.value) {
          matrices = getCameraViewMatrices(camera.value, compWidth.value, compHeight.value);
        } else if (isCustomView(viewType)) {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value, customViews.value[viewType]);
        } else {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value);
        }
        const lines = [];
        if (viewOptions.value.showGrid) {
          lines.push(...generateGrid(compWidth.value, compHeight.value));
        }
        if (viewOptions.value.show3DReferenceAxes) {
          lines.push(...generate3DAxes(vec3(compWidth.value / 2, compHeight.value / 2, 0)));
        }
        if (viewOptions.value.showCompositionBounds) {
          const viz = generateCameraVisualization(
            camera.value ?? createDummyCamera(),
            compWidth.value,
            compHeight.value,
            false,
            true,
            false
          );
          lines.push(...viz.compositionBounds);
        }
        if (viewType !== "active-camera" && camera.value) {
          const showWireframe = viewOptions.value.cameraWireframes === "always" || viewOptions.value.cameraWireframes === "selected";
          if (showWireframe) {
            const viz = generateCameraVisualization(
              camera.value,
              compWidth.value,
              compHeight.value,
              true,
              false,
              viewOptions.value.showFocalPlane
            );
            lines.push(...viz.body);
            lines.push(...viz.frustum);
            lines.push(...viz.focalPlane);
            if (viz.poiLine) {
              lines.push(viz.poiLine);
            }
          }
        }
        for (const line of lines) {
          const start = projectToScreen(line.start, matrices.viewProjection, rect.width, rect.height);
          const end = projectToScreen(line.end, matrices.viewProjection, rect.width, rect.height);
          if (!start.visible && !end.visible) continue;
          ctx.beginPath();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 1;
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
        if (viewOptions.value.showLayerHandles) {
          for (const layer of layers.value) {
            const pos = projectToScreen(layer.position, matrices.viewProjection, rect.width, rect.height);
            if (!pos.visible) continue;
            ctx.beginPath();
            ctx.fillStyle = layer.selected ? "#ffcc00" : "#888888";
            ctx.arc(pos.x, pos.y, layer.selected ? 6 : 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "10px sans-serif";
            ctx.fillText(layer.name, pos.x + 8, pos.y + 4);
          }
        }
      });
    }
    function createDummyCamera() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: compWidth.value / 2, y: compHeight.value / 2, z: -1500 },
        pointOfInterest: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: false,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let animationId;
    function animate() {
      render();
      animationId = requestAnimationFrame(animate);
    }
    function onKeyDown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA" || document.activeElement?.tagName === "SELECT") {
        return;
      }
      const activeView = activeViews.value[activeViewIndex.value];
      switch (e.code) {
        case "Numpad1":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "back");
          } else {
            updateViewType(activeViewIndex.value, "front");
          }
          e.preventDefault();
          break;
        case "Numpad3":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "left");
          } else {
            updateViewType(activeViewIndex.value, "right");
          }
          e.preventDefault();
          break;
        case "Numpad7":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "bottom");
          } else {
            updateViewType(activeViewIndex.value, "top");
          }
          e.preventDefault();
          break;
        case "Numpad0":
          updateViewType(activeViewIndex.value, "active-camera");
          e.preventDefault();
          break;
        case "Numpad5":
          if (!isCustomView(activeView)) {
            const targetView = "custom-1";
            let theta = 0;
            let phi = 90;
            switch (activeView) {
              case "front":
                theta = 0;
                phi = 90;
                break;
              case "back":
                theta = 180;
                phi = 90;
                break;
              case "left":
                theta = -90;
                phi = 90;
                break;
              case "right":
                theta = 90;
                phi = 90;
                break;
              case "top":
                theta = 0;
                phi = 1;
                break;
              case "bottom":
                theta = 0;
                phi = 179;
                break;
              default:
                theta = 45;
                phi = 60;
            }
            store.updateViewportState({
              customViews: {
                ...viewportState.value.customViews,
                [targetView]: {
                  ...viewportState.value.customViews[targetView],
                  orbitTheta: theta,
                  orbitPhi: phi
                }
              }
            });
            updateViewType(activeViewIndex.value, targetView);
          } else {
            const theta = customViews.value[activeView].orbitTheta % 360;
            const phi = customViews.value[activeView].orbitPhi;
            let closestView = "front";
            if (phi < 30) {
              closestView = "top";
            } else if (phi > 150) {
              closestView = "bottom";
            } else {
              const normalizedTheta = (theta % 360 + 360) % 360;
              if (normalizedTheta >= 315 || normalizedTheta < 45) {
                closestView = "front";
              } else if (normalizedTheta >= 45 && normalizedTheta < 135) {
                closestView = "right";
              } else if (normalizedTheta >= 135 && normalizedTheta < 225) {
                closestView = "back";
              } else {
                closestView = "left";
              }
            }
            updateViewType(activeViewIndex.value, closestView);
          }
          e.preventDefault();
          break;
        case "NumpadDecimal":
        case "Period":
          focusOnSelectedLayer();
          e.preventDefault();
          break;
        case "Home":
          if (isCustomView(activeView)) {
            resetCustomView(activeView);
          }
          e.preventDefault();
          break;
        case "KeyG":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showGrid: !viewOptions.value.showGrid
            });
            e.preventDefault();
          }
          break;
        case "KeyH":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showLayerHandles: !viewOptions.value.showLayerHandles
            });
            e.preventDefault();
          }
          break;
        case "KeyC":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            store.updateViewOptions({
              showCompositionBounds: !viewOptions.value.showCompositionBounds
            });
            e.preventDefault();
          }
          break;
        case "KeyA":
          if (!e.ctrlKey && !e.metaKey && e.shiftKey) {
            store.updateViewOptions({
              show3DReferenceAxes: !viewOptions.value.show3DReferenceAxes
            });
            e.preventDefault();
          }
          break;
      }
    }
    function focusOnSelectedLayer() {
      const selectedLayer = store.layers.find((l) => store.selectedLayerIds.includes(l.id));
      if (!selectedLayer) return;
      const pos = selectedLayer.transform.position.value;
      const width = 100;
      const height = 100;
      const activeView = activeViews.value[activeViewIndex.value];
      if (isCustomView(activeView)) {
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [activeView]: {
              ...customViews.value[activeView],
              orbitCenter: { x: pos.x + width / 2, y: pos.y + height / 2, z: 0 },
              orbitDistance: Math.max(width, height) * 3
              // Zoom to fit
            }
          }
        });
      }
    }
    onMounted(() => {
      animate();
      window.addEventListener("keydown", onKeyDown);
    });
    onUnmounted(() => {
      cancelAnimationFrame(animationId);
      window.removeEventListener("keydown", onKeyDown);
    });
    watch([camera, viewportState, viewOptions, layers], () => {
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["viewport-renderer", [`layout-${layout.value}`]])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(activeViews.value, (viewType, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass(["view-panel", { active: index === activeViewIndex.value }]),
            onClick: ($event) => setActiveView(index)
          }, [
            createBaseVNode("div", _hoisted_2$d, [
              createBaseVNode("select", {
                value: viewType,
                onChange: ($event) => updateViewType(index, $event.target.value),
                class: "view-select"
              }, [..._cache[1] || (_cache[1] = [
                createStaticVNode('<option value="active-camera" data-v-84bae3ba>Active Camera</option><option value="custom-1" data-v-84bae3ba>Custom View 1</option><option value="custom-2" data-v-84bae3ba>Custom View 2</option><option value="custom-3" data-v-84bae3ba>Custom View 3</option><option value="front" data-v-84bae3ba>Front</option><option value="back" data-v-84bae3ba>Back</option><option value="left" data-v-84bae3ba>Left</option><option value="right" data-v-84bae3ba>Right</option><option value="top" data-v-84bae3ba>Top</option><option value="bottom" data-v-84bae3ba>Bottom</option>', 10)
              ])], 40, _hoisted_3$d),
              createBaseVNode("div", _hoisted_4$d, [
                isCustomView(viewType) ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: withModifiers(($event) => resetCustomView(viewType), ["stop"]),
                  title: "Reset View"
                }, [..._cache[2] || (_cache[2] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])], 8, _hoisted_5$d)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("canvas", {
              ref_for: true,
              ref: (el) => setCanvasRef(el, index),
              class: "view-canvas",
              onMousedown: ($event) => onCanvasMouseDown($event, index),
              onWheel: ($event) => onCanvasWheel($event, index),
              onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, null, 40, _hoisted_6$d),
            createBaseVNode("div", _hoisted_7$d, [
              createBaseVNode("span", _hoisted_8$c, toDisplayString(getViewDisplayName(viewType)), 1),
              isCustomView(viewType) ? (openBlock(), createElementBlock("span", _hoisted_9$b, " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitTheta ?? 0)) + " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitPhi ?? 0)) + " ", 1)) : createCommentVNode("", true)
            ])
          ], 10, _hoisted_1$d);
        }), 128)),
        createBaseVNode("div", _hoisted_10$b, [
          (openBlock(), createElementBlock(Fragment, null, renderList(layoutOptions, (layoutOption) => {
            return createBaseVNode("button", {
              key: layoutOption.value,
              class: normalizeClass({ active: layout.value === layoutOption.value }),
              onClick: ($event) => setLayout(layoutOption.value),
              title: layoutOption.label
            }, toDisplayString(layoutOption.icon), 11, _hoisted_11$a);
          }), 64))
        ])
      ], 2);
    };
  }
});

const ViewportRenderer = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-84bae3ba"]]);

const _raycaster = new Raycaster();

const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
	X: new Vector3( 1, 0, 0 ),
	Y: new Vector3( 0, 1, 0 ),
	Z: new Vector3( 0, 0, 1 )
};

const _changeEvent = { type: 'change' };
const _mouseDownEvent = { type: 'mouseDown', mode: null };
const _mouseUpEvent = { type: 'mouseUp', mode: null };
const _objectChangeEvent = { type: 'objectChange' };

class TransformControls extends Controls {

	constructor( camera, domElement = null ) {

		super( undefined, domElement );

		const root = new TransformControlsRoot( this );
		this._root = root;

		const gizmo = new TransformControlsGizmo();
		this._gizmo = gizmo;
		root.add( gizmo );

		const plane = new TransformControlsPlane();
		this._plane = plane;
		root.add( plane );

		const scope = this;

		// Defined getter, setter and store for a property
		function defineProperty( propName, defaultValue ) {

			let propValue = defaultValue;

			Object.defineProperty( scope, propName, {

				get: function () {

					return propValue !== undefined ? propValue : defaultValue;

				},

				set: function ( value ) {

					if ( propValue !== value ) {

						propValue = value;
						plane[ propName ] = value;
						gizmo[ propName ] = value;

						scope.dispatchEvent( { type: propName + '-changed', value: value } );
						scope.dispatchEvent( _changeEvent );

					}

				}

			} );

			scope[ propName ] = defaultValue;
			plane[ propName ] = defaultValue;
			gizmo[ propName ] = defaultValue;

		}

		// Define properties with getters/setter
		// Setting the defined property will automatically trigger change event
		// Defined properties are passed down to gizmo and plane

		defineProperty( 'camera', camera );
		defineProperty( 'object', undefined );
		defineProperty( 'enabled', true );
		defineProperty( 'axis', null );
		defineProperty( 'mode', 'translate' );
		defineProperty( 'translationSnap', null );
		defineProperty( 'rotationSnap', null );
		defineProperty( 'scaleSnap', null );
		defineProperty( 'space', 'world' );
		defineProperty( 'size', 1 );
		defineProperty( 'dragging', false );
		defineProperty( 'showX', true );
		defineProperty( 'showY', true );
		defineProperty( 'showZ', true );
		defineProperty( 'minX', - Infinity );
		defineProperty( 'maxX', Infinity );
		defineProperty( 'minY', - Infinity );
		defineProperty( 'maxY', Infinity );
		defineProperty( 'minZ', - Infinity );
		defineProperty( 'maxZ', Infinity );

		// Reusable utility variables

		const worldPosition = new Vector3();
		const worldPositionStart = new Vector3();
		const worldQuaternion = new Quaternion();
		const worldQuaternionStart = new Quaternion();
		const cameraPosition = new Vector3();
		const cameraQuaternion = new Quaternion();
		const pointStart = new Vector3();
		const pointEnd = new Vector3();
		const rotationAxis = new Vector3();
		const rotationAngle = 0;
		const eye = new Vector3();

		// TODO: remove properties unused in plane and gizmo

		defineProperty( 'worldPosition', worldPosition );
		defineProperty( 'worldPositionStart', worldPositionStart );
		defineProperty( 'worldQuaternion', worldQuaternion );
		defineProperty( 'worldQuaternionStart', worldQuaternionStart );
		defineProperty( 'cameraPosition', cameraPosition );
		defineProperty( 'cameraQuaternion', cameraQuaternion );
		defineProperty( 'pointStart', pointStart );
		defineProperty( 'pointEnd', pointEnd );
		defineProperty( 'rotationAxis', rotationAxis );
		defineProperty( 'rotationAngle', rotationAngle );
		defineProperty( 'eye', eye );

		this._offset = new Vector3();
		this._startNorm = new Vector3();
		this._endNorm = new Vector3();
		this._cameraScale = new Vector3();

		this._parentPosition = new Vector3();
		this._parentQuaternion = new Quaternion();
		this._parentQuaternionInv = new Quaternion();
		this._parentScale = new Vector3();

		this._worldScaleStart = new Vector3();
		this._worldQuaternionInv = new Quaternion();
		this._worldScale = new Vector3();

		this._positionStart = new Vector3();
		this._quaternionStart = new Quaternion();
		this._scaleStart = new Vector3();

		this._getPointer = getPointer.bind( this );
		this._onPointerDown = onPointerDown.bind( this );
		this._onPointerHover = onPointerHover.bind( this );
		this._onPointerMove = onPointerMove.bind( this );
		this._onPointerUp = onPointerUp.bind( this );

		if ( domElement !== null ) {

			this.connect();

		}

	}

	connect() {

		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.addEventListener( 'pointermove', this._onPointerHover );
		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

		this.domElement.style.touchAction = 'none'; // disable touch scroll

	}

	disconnect() {

		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.removeEventListener( 'pointermove', this._onPointerHover );
		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

		this.domElement.style.touchAction = 'auto';

	}

	getHelper() {

		return this._root;

	}

	pointerHover( pointer ) {

		if ( this.object === undefined || this.dragging === true ) return;

		if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );

		const intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster );

		if ( intersect ) {

			this.axis = intersect.object.name;

		} else {

			this.axis = null;

		}

	}

	pointerDown( pointer ) {

		if ( this.object === undefined || this.dragging === true || ( pointer != null && pointer.button !== 0 ) ) return;

		if ( this.axis !== null ) {

			if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );

			const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );

			if ( planeIntersect ) {

				this.object.updateMatrixWorld();
				this.object.parent.updateMatrixWorld();

				this._positionStart.copy( this.object.position );
				this._quaternionStart.copy( this.object.quaternion );
				this._scaleStart.copy( this.object.scale );

				this.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart );

				this.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart );

			}

			this.dragging = true;
			_mouseDownEvent.mode = this.mode;
			this.dispatchEvent( _mouseDownEvent );

		}

	}

	pointerMove( pointer ) {

		const axis = this.axis;
		const mode = this.mode;
		const object = this.object;
		let space = this.space;

		if ( mode === 'scale' ) {

			space = 'local';

		} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {

			space = 'world';

		}

		if ( object === undefined || axis === null || this.dragging === false || ( pointer !== null && pointer.button !== -1 ) ) return;

		if ( pointer !== null ) _raycaster.setFromCamera( pointer, this.camera );

		const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );

		if ( ! planeIntersect ) return;

		this.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart );

		if ( mode === 'translate' ) {

			// Apply translate

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._worldQuaternionInv );

			}

			if ( axis.indexOf( 'X' ) === -1 ) this._offset.x = 0;
			if ( axis.indexOf( 'Y' ) === -1 ) this._offset.y = 0;
			if ( axis.indexOf( 'Z' ) === -1 ) this._offset.z = 0;

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale );

			} else {

				this._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale );

			}

			object.position.copy( this._offset ).add( this._positionStart );

			// Apply translation snap

			if ( this.translationSnap ) {

				if ( space === 'local' ) {

					object.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() );

					if ( axis.search( 'X' ) !== -1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== -1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== -1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					object.position.applyQuaternion( this._quaternionStart );

				}

				if ( space === 'world' ) {

					if ( object.parent ) {

						object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

					if ( axis.search( 'X' ) !== -1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== -1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== -1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					if ( object.parent ) {

						object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

				}

			}

			object.position.x = Math.max( this.minX, Math.min( this.maxX, object.position.x ) );
			object.position.y = Math.max( this.minY, Math.min( this.maxY, object.position.y ) );
			object.position.z = Math.max( this.minZ, Math.min( this.maxZ, object.position.z ) );

		} else if ( mode === 'scale' ) {

			if ( axis.search( 'XYZ' ) !== -1 ) {

				let d = this.pointEnd.length() / this.pointStart.length();

				if ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= -1;

				_tempVector2.set( d, d, d );

			} else {

				_tempVector.copy( this.pointStart );
				_tempVector2.copy( this.pointEnd );

				_tempVector.applyQuaternion( this._worldQuaternionInv );
				_tempVector2.applyQuaternion( this._worldQuaternionInv );

				_tempVector2.divide( _tempVector );

				if ( axis.search( 'X' ) === -1 ) {

					_tempVector2.x = 1;

				}

				if ( axis.search( 'Y' ) === -1 ) {

					_tempVector2.y = 1;

				}

				if ( axis.search( 'Z' ) === -1 ) {

					_tempVector2.z = 1;

				}

			}

			// Apply scale

			object.scale.copy( this._scaleStart ).multiply( _tempVector2 );

			if ( this.scaleSnap ) {

				if ( axis.search( 'X' ) !== -1 ) {

					object.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Y' ) !== -1 ) {

					object.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Z' ) !== -1 ) {

					object.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

			}

		} else if ( mode === 'rotate' ) {

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			const ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );

			let _inPlaneRotation = false;

			if ( axis === 'XYZE' ) {

				this.rotationAxis.copy( this._offset ).cross( this.eye ).normalize();
				this.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;

			} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {

				this.rotationAxis.copy( _unit[ axis ] );

				_tempVector.copy( _unit[ axis ] );

				if ( space === 'local' ) {

					_tempVector.applyQuaternion( this.worldQuaternion );

				}

				_tempVector.cross( this.eye );

				// When _tempVector is 0 after cross with this.eye the vectors are parallel and should use in-plane rotation logic.
				if ( _tempVector.length() === 0 ) {

					_inPlaneRotation = true;

				} else {

					this.rotationAngle = this._offset.dot( _tempVector.normalize() ) * ROTATION_SPEED;

				}


			}

			if ( axis === 'E' || _inPlaneRotation ) {

				this.rotationAxis.copy( this.eye );
				this.rotationAngle = this.pointEnd.angleTo( this.pointStart );

				this._startNorm.copy( this.pointStart ).normalize();
				this._endNorm.copy( this.pointEnd ).normalize();

				this.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : -1 );

			}

			// Apply rotation snap

			if ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap;

			// Apply rotate
			if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {

				object.quaternion.copy( this._quaternionStart );
				object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize();

			} else {

				this.rotationAxis.applyQuaternion( this._parentQuaternionInv );
				object.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) );
				object.quaternion.multiply( this._quaternionStart ).normalize();

			}

		}

		this.dispatchEvent( _changeEvent );
		this.dispatchEvent( _objectChangeEvent );

	}

	pointerUp( pointer ) {

		if ( pointer !== null && pointer.button !== 0 ) return;

		if ( this.dragging && ( this.axis !== null ) ) {

			_mouseUpEvent.mode = this.mode;
			this.dispatchEvent( _mouseUpEvent );

		}

		this.dragging = false;
		this.axis = null;

	}

	dispose() {

		this.disconnect();

		this._root.dispose();

	}

	// Set current object
	attach( object ) {

		this.object = object;
		this._root.visible = true;

		return this;

	}

	// Detach from object
	detach() {

		this.object = undefined;
		this.axis = null;

		this._root.visible = false;

		return this;

	}

	reset() {

		if ( ! this.enabled ) return;

		if ( this.dragging ) {

			this.object.position.copy( this._positionStart );
			this.object.quaternion.copy( this._quaternionStart );
			this.object.scale.copy( this._scaleStart );

			this.dispatchEvent( _changeEvent );
			this.dispatchEvent( _objectChangeEvent );

			this.pointStart.copy( this.pointEnd );

		}

	}

	getRaycaster() {

		return _raycaster;

	}

	// TODO: deprecate

	getMode() {

		return this.mode;

	}

	setMode( mode ) {

		this.mode = mode;

	}

	setTranslationSnap( translationSnap ) {

		this.translationSnap = translationSnap;

	}

	setRotationSnap( rotationSnap ) {

		this.rotationSnap = rotationSnap;

	}

	setScaleSnap( scaleSnap ) {

		this.scaleSnap = scaleSnap;

	}

	setSize( size ) {

		this.size = size;

	}

	setSpace( space ) {

		this.space = space;

	}

}

// mouse / touch event handlers

function getPointer( event ) {

	if ( this.domElement.ownerDocument.pointerLockElement ) {

		return {
			x: 0,
			y: 0,
			button: event.button
		};

	} else {

		const rect = this.domElement.getBoundingClientRect();

		return {
			x: ( event.clientX - rect.left ) / rect.width * 2 - 1,
			y: - ( event.clientY - rect.top ) / rect.height * 2 + 1,
			button: event.button
		};

	}

}

function onPointerHover( event ) {

	if ( ! this.enabled ) return;

	switch ( event.pointerType ) {

		case 'mouse':
		case 'pen':
			this.pointerHover( this._getPointer( event ) );
			break;

	}

}

function onPointerDown( event ) {

	if ( ! this.enabled ) return;

	if ( ! document.pointerLockElement ) {

		this.domElement.setPointerCapture( event.pointerId );

	}

	this.domElement.addEventListener( 'pointermove', this._onPointerMove );

	this.pointerHover( this._getPointer( event ) );
	this.pointerDown( this._getPointer( event ) );

}

function onPointerMove( event ) {

	if ( ! this.enabled ) return;

	this.pointerMove( this._getPointer( event ) );

}

function onPointerUp( event ) {

	if ( ! this.enabled ) return;

	this.domElement.releasePointerCapture( event.pointerId );

	this.domElement.removeEventListener( 'pointermove', this._onPointerMove );

	this.pointerUp( this._getPointer( event ) );

}

function intersectObjectWithRay( object, raycaster, includeInvisible ) {

	const allIntersections = raycaster.intersectObject( object, true );

	for ( let i = 0; i < allIntersections.length; i ++ ) {

		if ( allIntersections[ i ].object.visible || includeInvisible ) {

			return allIntersections[ i ];

		}

	}

	return false;

}

//

// Reusable utility variables

const _tempEuler = new Euler();
const _alignVector = new Vector3( 0, 1, 0 );
const _zeroVector = new Vector3( 0, 0, 0 );
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();

const _unitX = new Vector3( 1, 0, 0 );
const _unitY = new Vector3( 0, 1, 0 );
const _unitZ = new Vector3( 0, 0, 1 );

const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();

class TransformControlsRoot extends Object3D {

	constructor( controls ) {

		super();

		this.isTransformControlsRoot = true;

		this.controls = controls;
		this.visible = false;

	}

	// updateMatrixWorld updates key transformation variables
	updateMatrixWorld( force ) {

		const controls = this.controls;

		if ( controls.object !== undefined ) {

			controls.object.updateMatrixWorld();

			if ( controls.object.parent === null ) {

				console.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );

			} else {

				controls.object.parent.matrixWorld.decompose( controls._parentPosition, controls._parentQuaternion, controls._parentScale );

			}

			controls.object.matrixWorld.decompose( controls.worldPosition, controls.worldQuaternion, controls._worldScale );

			controls._parentQuaternionInv.copy( controls._parentQuaternion ).invert();
			controls._worldQuaternionInv.copy( controls.worldQuaternion ).invert();

		}

		controls.camera.updateMatrixWorld();
		controls.camera.matrixWorld.decompose( controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale );

		if ( controls.camera.isOrthographicCamera ) {

			controls.camera.getWorldDirection( controls.eye ).negate();

		} else {

			controls.eye.copy( controls.cameraPosition ).sub( controls.worldPosition ).normalize();

		}

		super.updateMatrixWorld( force );

	}

	dispose() {

		this.traverse( function ( child ) {

			if ( child.geometry ) child.geometry.dispose();
			if ( child.material ) child.material.dispose();

		} );

	}

}

class TransformControlsGizmo extends Object3D {

	constructor() {

		super();

		this.isTransformControlsGizmo = true;

		this.type = 'TransformControlsGizmo';

		// shared materials

		const gizmoMaterial = new MeshBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		const gizmoLineMaterial = new LineBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		// Make unique material for each axis/color

		const matInvisible = gizmoMaterial.clone();
		matInvisible.opacity = 0.15;

		const matHelper = gizmoLineMaterial.clone();
		matHelper.opacity = 0.5;

		const matRed = gizmoMaterial.clone();
		matRed.color.setHex( 0xff0000 );

		const matGreen = gizmoMaterial.clone();
		matGreen.color.setHex( 0x00ff00 );

		const matBlue = gizmoMaterial.clone();
		matBlue.color.setHex( 0x0000ff );

		const matRedTransparent = gizmoMaterial.clone();
		matRedTransparent.color.setHex( 0xff0000 );
		matRedTransparent.opacity = 0.5;

		const matGreenTransparent = gizmoMaterial.clone();
		matGreenTransparent.color.setHex( 0x00ff00 );
		matGreenTransparent.opacity = 0.5;

		const matBlueTransparent = gizmoMaterial.clone();
		matBlueTransparent.color.setHex( 0x0000ff );
		matBlueTransparent.opacity = 0.5;

		const matWhiteTransparent = gizmoMaterial.clone();
		matWhiteTransparent.opacity = 0.25;

		const matYellowTransparent = gizmoMaterial.clone();
		matYellowTransparent.color.setHex( 0xffff00 );
		matYellowTransparent.opacity = 0.25;

		const matYellow = gizmoMaterial.clone();
		matYellow.color.setHex( 0xffff00 );

		const matGray = gizmoMaterial.clone();
		matGray.color.setHex( 0x787878 );

		// reusable geometry

		const arrowGeometry = new CylinderGeometry( 0, 0.04, 0.1, 12 );
		arrowGeometry.translate( 0, 0.05, 0 );

		const scaleHandleGeometry = new BoxGeometry( 0.08, 0.08, 0.08 );
		scaleHandleGeometry.translate( 0, 0.04, 0 );

		const lineGeometry = new BufferGeometry();
		lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0,	1, 0, 0 ], 3 ) );

		const lineGeometry2 = new CylinderGeometry( 0.0075, 0.0075, 0.5, 3 );
		lineGeometry2.translate( 0, 0.25, 0 );

		function CircleGeometry( radius, arc ) {

			const geometry = new TorusGeometry( radius, 0.0075, 3, 64, arc * Math.PI * 2 );
			geometry.rotateY( Math.PI / 2 );
			geometry.rotateX( Math.PI / 2 );
			return geometry;

		}

		// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

		function TranslateHelperGeometry() {

			const geometry = new BufferGeometry();

			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );

			return geometry;

		}

		// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

		const gizmoTranslate = {
			X: [
				[ new Mesh( arrowGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( arrowGeometry, matRed ), [ -0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( arrowGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( arrowGeometry, matGreen ), [ 0, -0.5, 0 ], [ Math.PI, 0, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ]
			],
			Z: [
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, -0.5 ], [ - Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), null, [ Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent.clone() ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const pickerTranslate = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ -0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, -0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, -0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const helperTranslate = {
			START: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			END: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			DELTA: [
				[ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]
			],
			X: [
				[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const gizmoRotate = {
			XYZE: [
				[ new Mesh( CircleGeometry( 0.5, 1 ), matGray ), null, [ 0, Math.PI / 2, 0 ]]
			],
			X: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matRed ) ]
			],
			Y: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matGreen ), null, [ 0, 0, - Math.PI / 2 ]]
			],
			Z: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matBlue ), null, [ 0, Math.PI / 2, 0 ]]
			],
			E: [
				[ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]]
			]
		};

		const helperRotate = {
			AXIS: [
				[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const pickerRotate = {
			XYZE: [
				[ new Mesh( new SphereGeometry( 0.25, 10, 8 ), matInvisible ) ]
			],
			X: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
			],
			Z: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
			],
			E: [
				[ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ]
			]
		};

		const gizmoScale = {
			X: [
				[ new Mesh( scaleHandleGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( scaleHandleGeometry, matRed ), [ -0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ],
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, -0.5, 0 ], [ 0, 0, Math.PI ]],
			],
			Z: [
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, -0.5 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.1, 0.1, 0.1 ), matWhiteTransparent.clone() ) ],
			]
		};

		const pickerScale = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ -0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, -0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, -0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]],
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 0 ]],
			]
		};

		const helperScale = {
			X: [
				[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		// Creates an Object3D with gizmos described in custom hierarchy definition.

		function setupGizmo( gizmoMap ) {

			const gizmo = new Object3D();

			for ( const name in gizmoMap ) {

				for ( let i = gizmoMap[ name ].length; i --; ) {

					const object = gizmoMap[ name ][ i ][ 0 ].clone();
					const position = gizmoMap[ name ][ i ][ 1 ];
					const rotation = gizmoMap[ name ][ i ][ 2 ];
					const scale = gizmoMap[ name ][ i ][ 3 ];
					const tag = gizmoMap[ name ][ i ][ 4 ];

					// name and tag properties are essential for picking and updating logic.
					object.name = name;
					object.tag = tag;

					if ( position ) {

						object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );

					}

					if ( rotation ) {

						object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );

					}

					if ( scale ) {

						object.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );

					}

					object.updateMatrix();

					const tempGeometry = object.geometry.clone();
					tempGeometry.applyMatrix4( object.matrix );
					object.geometry = tempGeometry;
					object.renderOrder = Infinity;

					object.position.set( 0, 0, 0 );
					object.rotation.set( 0, 0, 0 );
					object.scale.set( 1, 1, 1 );

					gizmo.add( object );

				}

			}

			return gizmo;

		}

		// Gizmo creation

		this.gizmo = {};
		this.picker = {};
		this.helper = {};

		this.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );
		this.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );
		this.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );
		this.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );
		this.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );
		this.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );
		this.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );
		this.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );
		this.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );

		// Pickers should be hidden always

		this.picker[ 'translate' ].visible = false;
		this.picker[ 'rotate' ].visible = false;
		this.picker[ 'scale' ].visible = false;

	}

	// updateMatrixWorld will update transformations and appearance of individual handles

	updateMatrixWorld( force ) {

		const space = ( this.mode === 'scale' ) ? 'local' : this.space; // scale always oriented to local rotation

		const quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion;

		// Show only gizmos for current transform mode

		this.gizmo[ 'translate' ].visible = this.mode === 'translate';
		this.gizmo[ 'rotate' ].visible = this.mode === 'rotate';
		this.gizmo[ 'scale' ].visible = this.mode === 'scale';

		this.helper[ 'translate' ].visible = this.mode === 'translate';
		this.helper[ 'rotate' ].visible = this.mode === 'rotate';
		this.helper[ 'scale' ].visible = this.mode === 'scale';


		let handles = [];
		handles = handles.concat( this.picker[ this.mode ].children );
		handles = handles.concat( this.gizmo[ this.mode ].children );
		handles = handles.concat( this.helper[ this.mode ].children );

		for ( let i = 0; i < handles.length; i ++ ) {

			const handle = handles[ i ];

			// hide aligned to camera

			handle.visible = true;
			handle.rotation.set( 0, 0, 0 );
			handle.position.copy( this.worldPosition );

			let factor;

			if ( this.camera.isOrthographicCamera ) {

				factor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom;

			} else {

				factor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 );

			}

			handle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 4 );

			// TODO: simplify helpers and consider decoupling from gizmo

			if ( handle.tag === 'helper' ) {

				handle.visible = false;

				if ( handle.name === 'AXIS' ) {

					handle.visible = !! this.axis;

					if ( this.axis === 'X' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Y' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Z' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'XYZE' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						_alignVector.copy( this.rotationAxis );
						handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) );
						handle.quaternion.multiply( _tempQuaternion );
						handle.visible = this.dragging;

					}

					if ( this.axis === 'E' ) {

						handle.visible = false;

					}


				} else if ( handle.name === 'START' ) {

					handle.position.copy( this.worldPositionStart );
					handle.visible = this.dragging;

				} else if ( handle.name === 'END' ) {

					handle.position.copy( this.worldPosition );
					handle.visible = this.dragging;

				} else if ( handle.name === 'DELTA' ) {

					handle.position.copy( this.worldPositionStart );
					handle.quaternion.copy( this.worldQuaternionStart );
					_tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( -1 );
					_tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );
					handle.scale.copy( _tempVector );
					handle.visible = this.dragging;

				} else {

					handle.quaternion.copy( quaternion );

					if ( this.dragging ) {

						handle.position.copy( this.worldPositionStart );

					} else {

						handle.position.copy( this.worldPosition );

					}

					if ( this.axis ) {

						handle.visible = this.axis.search( handle.name ) !== -1;

					}

				}

				// If updating helper, skip rest of the loop
				continue;

			}

			// Align handles to current local or world rotation

			handle.quaternion.copy( quaternion );

			if ( this.mode === 'translate' || this.mode === 'scale' ) {

				// Hide translate and scale axis facing the camera

				const AXIS_HIDE_THRESHOLD = 0.99;
				const PLANE_HIDE_THRESHOLD = 0.2;

				if ( handle.name === 'X' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Y' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Z' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XY' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'YZ' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XZ' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

			} else if ( this.mode === 'rotate' ) {

				// Align handles to current local or world rotation

				_tempQuaternion2.copy( quaternion );
				_alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() );

				if ( handle.name.search( 'E' ) !== -1 ) {

					handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) );

				}

				if ( handle.name === 'X' ) {

					_tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Y' ) {

					_tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Z' ) {

					_tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

			}

			// Hide disabled axes
			handle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === -1 || this.showX );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === -1 || this.showY );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === -1 || this.showZ );
			handle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === -1 || ( this.showX && this.showY && this.showZ ) );

			// highlight selected axis

			handle.material._color = handle.material._color || handle.material.color.clone();
			handle.material._opacity = handle.material._opacity || handle.material.opacity;

			handle.material.color.copy( handle.material._color );
			handle.material.opacity = handle.material._opacity;

			if ( this.enabled && this.axis ) {

				if ( handle.name === this.axis ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				} else if ( this.axis.split( '' ).some( function ( a ) {

					return handle.name === a;

				} ) ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				}

			}

		}

		super.updateMatrixWorld( force );

	}

}

//

class TransformControlsPlane extends Mesh {

	constructor() {

		super(
			new PlaneGeometry( 100000, 100000, 2, 2 ),
			new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } )
		);

		this.isTransformControlsPlane = true;

		this.type = 'TransformControlsPlane';

	}

	updateMatrixWorld( force ) {

		let space = this.space;

		this.position.copy( this.worldPosition );

		if ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation

		_v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v2.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );

		// Align the plane for current transform mode, axis and space.

		_alignVector.copy( _v2 );

		switch ( this.mode ) {

			case 'translate':
			case 'scale':
				switch ( this.axis ) {

					case 'X':
						_alignVector.copy( this.eye ).cross( _v1 );
						_dirVector.copy( _v1 ).cross( _alignVector );
						break;
					case 'Y':
						_alignVector.copy( this.eye ).cross( _v2 );
						_dirVector.copy( _v2 ).cross( _alignVector );
						break;
					case 'Z':
						_alignVector.copy( this.eye ).cross( _v3 );
						_dirVector.copy( _v3 ).cross( _alignVector );
						break;
					case 'XY':
						_dirVector.copy( _v3 );
						break;
					case 'YZ':
						_dirVector.copy( _v1 );
						break;
					case 'XZ':
						_alignVector.copy( _v3 );
						_dirVector.copy( _v2 );
						break;
					case 'XYZ':
					case 'E':
						_dirVector.set( 0, 0, 0 );
						break;

				}

				break;
			case 'rotate':
			default:
				// special case for rotate
				_dirVector.set( 0, 0, 0 );

		}

		if ( _dirVector.length() === 0 ) {

			// If in rotate mode, make the plane parallel to camera
			this.quaternion.copy( this.cameraQuaternion );

		} else {

			_tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector );

			this.quaternion.setFromRotationMatrix( _tempMatrix );

		}

		super.updateMatrixWorld( force );

	}

}

class SceneManager {
  /** The main Three.js scene */
  scene;
  /** Group for composition layers (rendered content) */
  compositionGroup;
  /** Group for UI overlay elements */
  overlayGroup;
  /** Group for debug helpers */
  debugGroup;
  /** Composition bounds frame */
  compositionBounds = null;
  /** Composition dimensions */
  compositionWidth = 1920;
  compositionHeight = 1080;
  /** O(1) layer lookup map - optimization for frequent ID-based lookups */
  layerLookupMap = /* @__PURE__ */ new Map();
  /** Track Z positions to avoid unnecessary sorting */
  zPositionCache = /* @__PURE__ */ new Map();
  needsZSort = false;
  constructor(backgroundColor = null) {
    this.scene = new Scene();
    this.scene.name = "WeylScene";
    if (backgroundColor) {
      this.scene.background = new Color(backgroundColor);
    } else {
      this.scene.background = null;
    }
    this.compositionGroup = new Group();
    this.compositionGroup.name = "composition";
    this.scene.add(this.compositionGroup);
    this.overlayGroup = new Group();
    this.overlayGroup.name = "overlay";
    this.overlayGroup.renderOrder = 1e3;
    this.scene.add(this.overlayGroup);
    this.debugGroup = new Group();
    this.debugGroup.name = "debug";
    this.debugGroup.visible = false;
    this.scene.add(this.debugGroup);
    this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const ambient = new AmbientLight(16777215, 0.6);
    ambient.name = "ambientLight";
    this.scene.add(ambient);
    const keyLight = new DirectionalLight(16777215, 0.8);
    keyLight.name = "keyLight";
    keyLight.position.set(1e3, -1e3, 2e3);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    this.scene.add(keyLight);
    const fillLight = new DirectionalLight(16777215, 0.3);
    fillLight.name = "fillLight";
    fillLight.position.set(-500, 500, 1e3);
    this.scene.add(fillLight);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(object) {
    this.compositionGroup.add(object);
    this.markNeedsZSort();
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.set(layerId, object);
    }
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(object) {
    this.compositionGroup.remove(object);
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.delete(layerId);
    }
    this.zPositionCache.delete(object);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let hasChanges = false;
      for (const child of this.compositionGroup.children) {
        const cachedZ = this.zPositionCache.get(child);
        const currentZ = child.position.z || 0;
        if (cachedZ === void 0 || cachedZ !== currentZ) {
          hasChanges = true;
          break;
        }
      }
      if (!hasChanges) {
        return;
      }
    }
    this.compositionGroup.children.sort((a, b) => {
      return (a.position.z || 0) - (b.position.z || 0);
    });
    for (const child of this.compositionGroup.children) {
      this.zPositionCache.set(child, child.position.z || 0);
    }
    this.needsZSort = false;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = true;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(object) {
    this.overlayGroup.add(object);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(object) {
    this.overlayGroup.remove(object);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    while (this.overlayGroup.children.length > 0) {
      const child = this.overlayGroup.children[0];
      this.overlayGroup.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(object) {
    this.scene.add(object);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(object) {
    this.scene.remove(object);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(visible) {
    this.debugGroup.visible = visible;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(size = 500) {
    const existing = this.debugGroup.getObjectByName("axisHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new AxesHelper(size);
    helper.name = "axisHelper";
    this.debugGroup.add(helper);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(size = 2e3, divisions = 40) {
    const existing = this.debugGroup.getObjectByName("gridHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new GridHelper(size, divisions, 4473924, 2236962);
    helper.name = "gridHelper";
    helper.rotation.x = Math.PI / 2;
    this.debugGroup.add(helper);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(color) {
    if (color) {
      this.scene.background = new Color(color);
    } else {
      this.scene.background = null;
    }
  }
  /**
   * Get current background color
   */
  getBackground() {
    if (this.scene.background instanceof Color) {
      return "#" + this.scene.background.getHexString();
    }
    return null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(width, height) {
    this.compositionWidth = width;
    this.compositionHeight = height;
    this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    if (this.compositionBounds) {
      this.overlayGroup.remove(this.compositionBounds);
      this.compositionBounds.geometry.dispose();
      this.compositionBounds.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const points = [
      new Vector3(0, 0, 0),
      new Vector3(w, 0, 0),
      new Vector3(w, -h, 0),
      new Vector3(0, -h, 0)
    ];
    const geometry = new BufferGeometry().setFromPoints(points);
    const material = new LineBasicMaterial({
      color: 4886745,
      linewidth: 2,
      depthTest: false
    });
    this.compositionBounds = new LineLoop(geometry, material);
    this.compositionBounds.name = "compositionBounds";
    this.compositionBounds.renderOrder = 998;
    this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(visible) {
    if (this.compositionBounds) {
      this.compositionBounds.visible = visible;
    }
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(raycaster) {
    return raycaster.intersectObjects(this.compositionGroup.children, true);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(layerId) {
    return this.layerLookupMap.get(layerId) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(object) {
    if (object instanceof Mesh) {
      object.geometry?.dispose();
      if (Array.isArray(object.material)) {
        object.material.forEach((m) => {
          this.disposeMaterial(m);
        });
      } else if (object.material) {
        this.disposeMaterial(object.material);
      }
    }
    while (object.children.length > 0) {
      const child = object.children[0];
      object.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(material) {
    const mat = material;
    mat.map?.dispose();
    mat.normalMap?.dispose();
    mat.roughnessMap?.dispose();
    mat.metalnessMap?.dispose();
    mat.aoMap?.dispose();
    mat.emissiveMap?.dispose();
    mat.alphaMap?.dispose();
    mat.envMap?.dispose();
    material.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    while (this.compositionGroup.children.length > 0) {
      const child = this.compositionGroup.children[0];
      this.compositionGroup.remove(child);
      this.disposeObject(child);
    }
    this.layerLookupMap.clear();
    this.zPositionCache.clear();
    this.clearOverlay();
    while (this.debugGroup.children.length > 0) {
      const child = this.debugGroup.children[0];
      this.debugGroup.remove(child);
      this.disposeObject(child);
    }
    this.scene.clear();
  }
}

/**
 * Full-screen textured quad shader
 */

const CopyShader = {

	name: 'CopyShader',

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`

};

class Pass {
  constructor() {
    this.isPass = true;
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class FullscreenTriangleGeometry extends BufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
}
const _geometry = new FullscreenTriangleGeometry();
class FullScreenQuad {
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}

class ShaderPass extends Pass {

	constructor( shader, textureID ) {

		super();

		this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

		if ( shader instanceof ShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils.clone( shader.uniforms );

			this.material = new ShaderMaterial( {

				name: ( shader.name !== undefined ) ? shader.name : 'unspecified',
				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new FullScreenQuad( this.material );

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.fsQuad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this.fsQuad.render( renderer );

		}

	}

	dispose() {

		this.material.dispose();

		this.fsQuad.dispose();

	}

}

class MaskPass extends Pass {

	constructor( scene, camera ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		let writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );
		state.buffers.stencil.setLocked( true );

		// draw into the stencil buffer

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		renderer.setRenderTarget( writeBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		// unlock color and depth buffer and make them writable for subsequent rendering/clearing

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		state.buffers.color.setMask( true );
		state.buffers.depth.setMask( true );

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked( false );
		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
		state.buffers.stencil.setLocked( true );

	}

}

class ClearMaskPass extends Pass {

	constructor() {

		super();

		this.needsSwap = false;

	}

	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		renderer.state.buffers.stencil.setLocked( false );
		renderer.state.buffers.stencil.setTest( false );

	}

}

class EffectComposer {

	constructor( renderer, renderTarget ) {

		this.renderer = renderer;

		this._pixelRatio = renderer.getPixelRatio();

		if ( renderTarget === undefined ) {

			const size = renderer.getSize( new Vector2() );
			this._width = size.width;
			this._height = size.height;

			renderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );
			renderTarget.texture.name = 'EffectComposer.rt1';

		} else {

			this._width = renderTarget.width;
			this._height = renderTarget.height;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		this.copyPass = new ShaderPass( CopyShader );
		this.copyPass.material.blending = NoBlending;

		this.clock = new Clock();

	}

	swapBuffers() {

		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	}

	addPass( pass ) {

		this.passes.push( pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	insertPass( pass, index ) {

		this.passes.splice( index, 0, pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	removePass( pass ) {

		const index = this.passes.indexOf( pass );

		if ( index !== -1 ) {

			this.passes.splice( index, 1 );

		}

	}

	isLastEnabledPass( passIndex ) {

		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

			if ( this.passes[ i ].enabled ) {

				return false;

			}

		}

		return true;

	}

	render( deltaTime ) {

		// deltaTime value is in seconds

		if ( deltaTime === undefined ) {

			deltaTime = this.clock.getDelta();

		}

		const currentRenderTarget = this.renderer.getRenderTarget();

		let maskActive = false;

		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

			const pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( MaskPass !== undefined ) {

				if ( pass instanceof MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

		this.renderer.setRenderTarget( currentRenderTarget );

	}

	reset( renderTarget ) {

		if ( renderTarget === undefined ) {

			const size = this.renderer.getSize( new Vector2() );
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	}

	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

		for ( let i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

		}

	}

	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	dispose() {

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();

		this.copyPass.dispose();

	}

}

class RenderPass extends Pass {

	constructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {

		super();

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = clearAlpha;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;
		this._oldClearColor = new Color();

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		let oldClearAlpha, oldOverrideMaterial;

		if ( this.overrideMaterial !== null ) {

			oldOverrideMaterial = this.scene.overrideMaterial;

			this.scene.overrideMaterial = this.overrideMaterial;

		}

		if ( this.clearColor !== null ) {

			renderer.getClearColor( this._oldClearColor );
			renderer.setClearColor( this.clearColor, renderer.getClearAlpha() );

		}

		if ( this.clearAlpha !== null ) {

			oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearAlpha( this.clearAlpha );

		}

		if ( this.clearDepth == true ) {

			renderer.clearDepth();

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

		if ( this.clear === true ) {

			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		renderer.render( this.scene, this.camera );

		// restore

		if ( this.clearColor !== null ) {

			renderer.setClearColor( this._oldClearColor );

		}

		if ( this.clearAlpha !== null ) {

			renderer.setClearAlpha( oldClearAlpha );

		}

		if ( this.overrideMaterial !== null ) {

			this.scene.overrideMaterial = oldOverrideMaterial;

		}

		renderer.autoClear = oldAutoClear;

	}

}

const OutputShader = {

	name: 'OutputShader',

	uniforms: {

		'tDiffuse': { value: null },
		'toneMappingExposure': { value: 1 }

	},

	vertexShader: /* glsl */`
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`

};

class OutputPass extends Pass {

	constructor() {

		super();

		//

		const shader = OutputShader;

		this.uniforms = UniformsUtils.clone( shader.uniforms );

		this.material = new RawShaderMaterial( {
			name: shader.name,
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader
		} );

		this.fsQuad = new FullScreenQuad( this.material );

		// internal cache

		this._outputColorSpace = null;
		this._toneMapping = null;

	}

	render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive */ ) {

		this.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
		this.uniforms[ 'toneMappingExposure' ].value = renderer.toneMappingExposure;

		// rebuild defines if required

		if ( this._outputColorSpace !== renderer.outputColorSpace || this._toneMapping !== renderer.toneMapping ) {

			this._outputColorSpace = renderer.outputColorSpace;
			this._toneMapping = renderer.toneMapping;

			this.material.defines = {};

			if ( ColorManagement.getTransfer( this._outputColorSpace ) === SRGBTransfer ) this.material.defines.SRGB_TRANSFER = '';

			if ( this._toneMapping === LinearToneMapping ) this.material.defines.LINEAR_TONE_MAPPING = '';
			else if ( this._toneMapping === ReinhardToneMapping ) this.material.defines.REINHARD_TONE_MAPPING = '';
			else if ( this._toneMapping === CineonToneMapping ) this.material.defines.CINEON_TONE_MAPPING = '';
			else if ( this._toneMapping === ACESFilmicToneMapping ) this.material.defines.ACES_FILMIC_TONE_MAPPING = '';
			else if ( this._toneMapping === AgXToneMapping ) this.material.defines.AGX_TONE_MAPPING = '';
			else if ( this._toneMapping === NeutralToneMapping ) this.material.defines.NEUTRAL_TONE_MAPPING = '';

			this.material.needsUpdate = true;

		}

		//

		if ( this.renderToScreen === true ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this.fsQuad.render( renderer );

		}

	}

	dispose() {

		this.material.dispose();
		this.fsQuad.dispose();

	}

}

/**
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

const BokehShader = {

	defines: {
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1,
	},

	uniforms: {

		'tColor': { value: null },
		'tDepth': { value: null },
		'focus': { value: 1.0 },
		'aspect': { value: 1.0 },
		'aperture': { value: 0.025 },
		'maxblur': { value: 0.01 },
		'nearClip': { value: 1.0 },
		'farClip': { value: 1000.0 },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`

};

class BokehPass extends Pass {
  constructor(scene, camera, params) {
    super();
    this.scene = scene;
    this.camera = camera;
    const focus = params.focus !== void 0 ? params.focus : 1;
    const aperture = params.aperture !== void 0 ? params.aperture : 0.025;
    const maxblur = params.maxblur !== void 0 ? params.maxblur : 1;
    this.renderTargetDepth = new WebGLRenderTarget(1, 1, {
      // will be resized later
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this.renderTargetDepth.texture.name = "BokehPass.depth";
    this.materialDepth = new MeshDepthMaterial();
    this.materialDepth.depthPacking = RGBADepthPacking;
    this.materialDepth.blending = NoBlending;
    const bokehShader = BokehShader;
    const bokehUniforms = UniformsUtils.clone(bokehShader.uniforms);
    bokehUniforms["tDepth"].value = this.renderTargetDepth.texture;
    bokehUniforms["focus"].value = focus;
    bokehUniforms["aspect"].value = camera.aspect;
    bokehUniforms["aperture"].value = aperture;
    bokehUniforms["maxblur"].value = maxblur;
    bokehUniforms["nearClip"].value = camera.near;
    bokehUniforms["farClip"].value = camera.far;
    this.materialBokeh = new ShaderMaterial({
      defines: Object.assign({}, bokehShader.defines),
      uniforms: bokehUniforms,
      vertexShader: bokehShader.vertexShader,
      fragmentShader: bokehShader.fragmentShader
    });
    this.uniforms = bokehUniforms;
    this.fsQuad = new FullScreenQuad(this.materialBokeh);
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    this.scene.overrideMaterial = this.materialDepth;
    renderer.getClearColor(this._oldClearColor);
    const oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(16777215);
    renderer.setClearAlpha(1);
    renderer.setRenderTarget(this.renderTargetDepth);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.uniforms["tColor"].value = readBuffer.texture;
    this.uniforms["nearClip"].value = this.camera.near;
    this.uniforms["farClip"].value = this.camera.far;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.scene.overrideMaterial = null;
    renderer.setClearColor(this._oldClearColor);
    renderer.setClearAlpha(oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  setSize(width, height) {
    this.materialBokeh.uniforms["aspect"].value = width / height;
    this.renderTargetDepth.setSize(width, height);
  }
  dispose() {
    this.renderTargetDepth.dispose();
    this.materialDepth.dispose();
    this.materialBokeh.dispose();
    this.fsQuad.dispose();
  }
}

// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com
//
// Added 4D noise

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
class SimplexNoise {

	constructor( r = Math ) {

		this.grad3 = [[ 1, 1, 0 ], [ -1, 1, 0 ], [ 1, -1, 0 ], [ -1, -1, 0 ],
			[ 1, 0, 1 ], [ -1, 0, 1 ], [ 1, 0, -1 ], [ -1, 0, -1 ],
			[ 0, 1, 1 ], [ 0, -1, 1 ], [ 0, 1, -1 ], [ 0, -1, -1 ]];

		this.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, -1 ], [ 0, 1, -1, 1 ], [ 0, 1, -1, -1 ],
			[ 0, -1, 1, 1 ], [ 0, -1, 1, -1 ], [ 0, -1, -1, 1 ], [ 0, -1, -1, -1 ],
			[ 1, 0, 1, 1 ], [ 1, 0, 1, -1 ], [ 1, 0, -1, 1 ], [ 1, 0, -1, -1 ],
			[ -1, 0, 1, 1 ], [ -1, 0, 1, -1 ], [ -1, 0, -1, 1 ], [ -1, 0, -1, -1 ],
			[ 1, 1, 0, 1 ], [ 1, 1, 0, -1 ], [ 1, -1, 0, 1 ], [ 1, -1, 0, -1 ],
			[ -1, 1, 0, 1 ], [ -1, 1, 0, -1 ], [ -1, -1, 0, 1 ], [ -1, -1, 0, -1 ],
			[ 1, 1, 1, 0 ], [ 1, 1, -1, 0 ], [ 1, -1, 1, 0 ], [ 1, -1, -1, 0 ],
			[ -1, 1, 1, 0 ], [ -1, 1, -1, 0 ], [ -1, -1, 1, 0 ], [ -1, -1, -1, 0 ]];

		this.p = [];

		for ( let i = 0; i < 256; i ++ ) {

			this.p[ i ] = Math.floor( r.random() * 256 );

		}

		// To remove the need for index wrapping, double the permutation table length
		this.perm = [];

		for ( let i = 0; i < 512; i ++ ) {

			this.perm[ i ] = this.p[ i & 255 ];

		}

		// A lookup table to traverse the simplex around a given point in 4D.
		// Details can be found where this table is used, in the 4D noise method.
		this.simplex = [
			[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],
			[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],
			[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],
			[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];

	}

	dot( g, x, y ) {

		return g[ 0 ] * x + g[ 1 ] * y;

	}

	dot3( g, x, y, z ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;

	}

	dot4( g, x, y, z, w ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;

	}

	noise( xin, yin ) {

		let n0; // Noise contributions from the three corners
		let n1;
		let n2;
		// Skew the input space to determine which simplex cell we're in
		const F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );
		const s = ( xin + yin ) * F2; // Hairy factor for 2D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;
		const t = ( i + j ) * G2;
		const X0 = i - t; // Unskew the cell origin back to (x,y) space
		const Y0 = j - t;
		const x0 = xin - X0; // The x,y distances from the cell origin
		const y0 = yin - Y0;

		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		let i1; // Offsets for second (middle) corner of simplex in (i,j) coords

		let j1;
		if ( x0 > y0 ) {

			i1 = 1; j1 = 0;

			// lower triangle, XY order: (0,0)->(1,0)->(1,1)

		}	else {

			i1 = 0; j1 = 1;

		} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		const y1 = y0 - j1 + G2;
		const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		const y2 = y0 - 1.0 + 2.0 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;
		const gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;
		// Calculate the contribution from the three corners
		let t0 = 0.5 - x0 * x0 - y0 * y0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient

		}

		let t1 = 0.5 - x1 * x1 - y1 * y1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );

		}

		let t2 = 0.5 - x2 * x2 - y2 * y2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70.0 * ( n0 + n1 + n2 );

	}

	// 3D simplex noise
	noise3d( xin, yin, zin ) {

		let n0; // Noise contributions from the four corners
		let n1;
		let n2;
		let n3;
		// Skew the input space to determine which simplex cell we're in
		const F3 = 1.0 / 3.0;
		const s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const k = Math.floor( zin + s );
		const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		const t = ( i + j + k ) * G3;
		const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		const Y0 = j - t;
		const Z0 = k - t;
		const x0 = xin - X0; // The x,y,z distances from the cell origin
		const y0 = yin - Y0;
		const z0 = zin - Z0;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		let i1; // Offsets for second corner of simplex in (i,j,k) coords

		let j1;
		let k1;
		let i2; // Offsets for third corner of simplex in (i,j,k) coords
		let j2;
		let k2;
		if ( x0 >= y0 ) {

			if ( y0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

				// X Y Z order

			} else if ( x0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;

				// X Z Y order

			} else {

				i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;

			} // Z X Y order

		} else { // x0<y0

			if ( y0 < z0 ) {

				i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;

				// Z Y X order

			} else if ( x0 < z0 ) {

				i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;

				// Y Z X order

			} else {

				i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

			} // Y X Z order

		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		const y1 = y0 - j1 + G3;
		const z1 = z0 - k1 + G3;
		const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		const y2 = y0 - j2 + 2.0 * G3;
		const z2 = z0 - k2 + 2.0 * G3;
		const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		const y3 = y0 - 1.0 + 3.0 * G3;
		const z3 = z0 - 1.0 + 3.0 * G3;
		// Work out the hashed gradient indices of the four simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;
		const gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;
		const gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;
		// Calculate the contribution from the four corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * ( n0 + n1 + n2 + n3 );

	}

	// 4D simplex noise
	noise4d( x, y, z, w ) {

		// For faster and easier lookups
		const grad4 = this.grad4;
		const simplex = this.simplex;
		const perm = this.perm;

		// The skewing and unskewing factors are hairy again for the 4D case
		const F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;
		const G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;
		let n0; // Noise contributions from the five corners
		let n1;
		let n2;
		let n3;
		let n4;
		// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		const s = ( x + y + z + w ) * F4; // Factor for 4D skewing
		const i = Math.floor( x + s );
		const j = Math.floor( y + s );
		const k = Math.floor( z + s );
		const l = Math.floor( w + s );
		const t = ( i + j + k + l ) * G4; // Factor for 4D unskewing
		const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		const Y0 = j - t;
		const Z0 = k - t;
		const W0 = l - t;
		const x0 = x - X0; // The x,y,z,w distances from the cell origin
		const y0 = y - Y0;
		const z0 = z - Z0;
		const w0 = w - W0;

		// For the 4D case, the simplex is a 4D shape I won't even try to describe.
		// To find out which of the 24 possible simplices we're in, we need to
		// determine the magnitude ordering of x0, y0, z0 and w0.
		// The method below is a good way of finding the ordering of x,y,z,w and
		// then find the correct traversal order for the simplex were in.
		// First, six pair-wise comparisons are performed between each possible pair
		// of the four coordinates, and the results are used to add up binary bits
		// for an integer index.
		const c1 = ( x0 > y0 ) ? 32 : 0;
		const c2 = ( x0 > z0 ) ? 16 : 0;
		const c3 = ( y0 > z0 ) ? 8 : 0;
		const c4 = ( x0 > w0 ) ? 4 : 0;
		const c5 = ( y0 > w0 ) ? 2 : 0;
		const c6 = ( z0 > w0 ) ? 1 : 0;
		const c = c1 + c2 + c3 + c4 + c5 + c6;

		// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
		// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
		// impossible. Only the 24 indices which have non-zero entries make any sense.
		// We use a thresholding to set the coordinates in turn from the largest magnitude.
		// The number 3 in the "simplex" array is at the position of the largest coordinate.
		const i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;
		const j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;
		const k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;
		const l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;
		// The number 2 in the "simplex" array is at the second largest coordinate.
		const i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;
		const j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;
		const k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;
		const l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;
		// The number 1 in the "simplex" array is at the second smallest coordinate.
		const i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;
		const j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;
		const k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;
		const l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;
		// The fifth corner has all coordinate offsets = 1, so no need to look that up.
		const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		const y1 = y0 - j1 + G4;
		const z1 = z0 - k1 + G4;
		const w1 = w0 - l1 + G4;
		const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		const y2 = y0 - j2 + 2.0 * G4;
		const z2 = z0 - k2 + 2.0 * G4;
		const w2 = w0 - l2 + 2.0 * G4;
		const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		const y3 = y0 - j3 + 3.0 * G4;
		const z3 = z0 - k3 + 3.0 * G4;
		const w3 = w0 - l3 + 3.0 * G4;
		const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		const y4 = y0 - 1.0 + 4.0 * G4;
		const z4 = z0 - 1.0 + 4.0 * G4;
		const w4 = w0 - 1.0 + 4.0 * G4;
		// Work out the hashed gradient indices of the five simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const ll = l & 255;
		const gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;
		const gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;
		const gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;
		const gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;
		const gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;
		// Calculate the contribution from the five corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );

		}

		let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if ( t4 < 0 ) n4 = 0.0;
		else {

			t4 *= t4;
			n4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );

		}

		// Sum up and scale the result to cover the range [-1,1]
		return 27.0 * ( n0 + n1 + n2 + n3 + n4 );

	}

}

/**
 * References:
 * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
 * https://learnopengl.com/Advanced-Lighting/SSAO
 * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl
 */

const SSAOShader = {

	defines: {
		'PERSPECTIVE_CAMERA': 1,
		'KERNEL_SIZE': 32
	},

	uniforms: {

		'tNormal': { value: null },
		'tDepth': { value: null },
		'tNoise': { value: null },
		'kernel': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },
		'resolution': { value: new Vector2() },
		'cameraProjectionMatrix': { value: new Matrix4() },
		'cameraInverseProjectionMatrix': { value: new Matrix4() },
		'kernelRadius': { value: 8 },
		'minDistance': { value: 0.005 },
		'maxDistance': { value: 0.05 },

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`
		uniform highp sampler2D tNormal;
		uniform highp sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );

			if ( depth == 1.0 ) {

				gl_FragColor = vec4( 1.0 ); // don't influence background
				
			} else {

				float viewZ = getViewZ( depth );

				vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
				vec3 viewNormal = getViewNormal( vUv );

				vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
				vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

				// compute matrix used to reorient a kernel vector

				vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
				vec3 bitangent = cross( viewNormal, tangent );
				mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

				float occlusion = 0.0;

				for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

					vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
					vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

					vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
					samplePointNDC /= samplePointNDC.w;

					vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

					float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
					float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
					float delta = sampleDepth - realDepth;

					if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

						occlusion += 1.0;

					}

				}

				occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

				gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

			}

		}`

};

const SSAODepthShader = {

	defines: {
		'PERSPECTIVE_CAMERA': 1
	},

	uniforms: {

		'tDepth': { value: null },
		'cameraNear': { value: null },
		'cameraFar': { value: null },

	},

	vertexShader:

		`varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

		`uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`

};

const SSAOBlurShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2() }

	},

	vertexShader:

		`varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

		`uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`

};

class SSAOPass extends Pass {

	constructor( scene, camera, width, height, kernelSize = 32 ) {

		super();

		this.width = ( width !== undefined ) ? width : 512;
		this.height = ( height !== undefined ) ? height : 512;

		this.clear = true;
		this.needsSwap = false;

		this.camera = camera;
		this.scene = scene;

		this.kernelRadius = 8;
		this.kernel = [];
		this.noiseTexture = null;
		this.output = 0;

		this.minDistance = 0.005;
		this.maxDistance = 0.1;

		this._visibilityCache = new Map();

		//

		this.generateSampleKernel( kernelSize );
		this.generateRandomKernelRotations();

		// depth texture

		const depthTexture = new DepthTexture();
		depthTexture.format = DepthStencilFormat;
		depthTexture.type = UnsignedInt248Type;

		// normal render target with depth buffer

		this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {
			minFilter: NearestFilter,
			magFilter: NearestFilter,
			type: HalfFloatType,
			depthTexture: depthTexture
		} );

		// ssao render target

		this.ssaoRenderTarget = new WebGLRenderTarget( this.width, this.height, { type: HalfFloatType } );

		this.blurRenderTarget = this.ssaoRenderTarget.clone();

		// ssao material

		this.ssaoMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAOShader.defines ),
			uniforms: UniformsUtils.clone( SSAOShader.uniforms ),
			vertexShader: SSAOShader.vertexShader,
			fragmentShader: SSAOShader.fragmentShader,
			blending: NoBlending
		} );

		this.ssaoMaterial.defines[ 'KERNEL_SIZE' ] = kernelSize;

		this.ssaoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
		this.ssaoMaterial.uniforms[ 'tDepth' ].value = this.normalRenderTarget.depthTexture;
		this.ssaoMaterial.uniforms[ 'tNoise' ].value = this.noiseTexture;
		this.ssaoMaterial.uniforms[ 'kernel' ].value = this.kernel;
		this.ssaoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.ssaoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
		this.ssaoMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );
		this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		// normal material

		this.normalMaterial = new MeshNormalMaterial();
		this.normalMaterial.blending = NoBlending;

		// blur material

		this.blurMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAOBlurShader.defines ),
			uniforms: UniformsUtils.clone( SSAOBlurShader.uniforms ),
			vertexShader: SSAOBlurShader.vertexShader,
			fragmentShader: SSAOBlurShader.fragmentShader
		} );
		this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
		this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );

		// material for rendering the depth

		this.depthRenderMaterial = new ShaderMaterial( {
			defines: Object.assign( {}, SSAODepthShader.defines ),
			uniforms: UniformsUtils.clone( SSAODepthShader.uniforms ),
			vertexShader: SSAODepthShader.vertexShader,
			fragmentShader: SSAODepthShader.fragmentShader,
			blending: NoBlending
		} );
		this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.normalRenderTarget.depthTexture;
		this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
		this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

		// material for rendering the content of a render target

		this.copyMaterial = new ShaderMaterial( {
			uniforms: UniformsUtils.clone( CopyShader.uniforms ),
			vertexShader: CopyShader.vertexShader,
			fragmentShader: CopyShader.fragmentShader,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			blendSrc: DstColorFactor,
			blendDst: ZeroFactor,
			blendEquation: AddEquation,
			blendSrcAlpha: DstAlphaFactor,
			blendDstAlpha: ZeroFactor,
			blendEquationAlpha: AddEquation
		} );

		this.fsQuad = new FullScreenQuad( null );

		this.originalClearColor = new Color();

	}

	dispose() {

		// dispose render targets

		this.normalRenderTarget.dispose();
		this.ssaoRenderTarget.dispose();
		this.blurRenderTarget.dispose();

		// dispose materials

		this.normalMaterial.dispose();
		this.blurMaterial.dispose();
		this.copyMaterial.dispose();
		this.depthRenderMaterial.dispose();

		// dipsose full screen quad

		this.fsQuad.dispose();

	}

	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		// render normals and depth (honor only meshes, points and lines do not contribute to SSAO)

		this.overrideVisibility();
		this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );
		this.restoreVisibility();

		// render SSAO

		this.ssaoMaterial.uniforms[ 'kernelRadius' ].value = this.kernelRadius;
		this.ssaoMaterial.uniforms[ 'minDistance' ].value = this.minDistance;
		this.ssaoMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;
		this.renderPass( renderer, this.ssaoMaterial, this.ssaoRenderTarget );

		// render blur

		this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );

		// output result to screen

		switch ( this.output ) {

			case SSAOPass.OUTPUT.SSAO:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );

				break;

			case SSAOPass.OUTPUT.Blur:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );

				break;

			case SSAOPass.OUTPUT.Depth:

				this.renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : readBuffer );

				break;

			case SSAOPass.OUTPUT.Normal:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
				this.copyMaterial.blending = NoBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );

				break;

			case SSAOPass.OUTPUT.Default:

				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
				this.copyMaterial.blending = CustomBlending;
				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : readBuffer );

				break;

			default:
				console.warn( 'THREE.SSAOPass: Unknown output type.' );

		}

	}

	renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

		// save original state
		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );

		// setup pass state
		renderer.autoClear = false;
		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.fsQuad.material = passMaterial;
		this.fsQuad.render( renderer );

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

		renderer.getClearColor( this.originalClearColor );
		const originalClearAlpha = renderer.getClearAlpha();
		const originalAutoClear = renderer.autoClear;

		renderer.setRenderTarget( renderTarget );
		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;

		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

			renderer.setClearColor( clearColor );
			renderer.setClearAlpha( clearAlpha || 0.0 );
			renderer.clear();

		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render( this.scene, this.camera );
		this.scene.overrideMaterial = null;

		// restore original state

		renderer.autoClear = originalAutoClear;
		renderer.setClearColor( this.originalClearColor );
		renderer.setClearAlpha( originalClearAlpha );

	}

	setSize( width, height ) {

		this.width = width;
		this.height = height;

		this.ssaoRenderTarget.setSize( width, height );
		this.normalRenderTarget.setSize( width, height );
		this.blurRenderTarget.setSize( width, height );

		this.ssaoMaterial.uniforms[ 'resolution' ].value.set( width, height );
		this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
		this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.copy( this.camera.projectionMatrixInverse );

		this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );

	}

	generateSampleKernel( kernelSize ) {

		const kernel = this.kernel;

		for ( let i = 0; i < kernelSize; i ++ ) {

			const sample = new Vector3();
			sample.x = ( Math.random() * 2 ) - 1;
			sample.y = ( Math.random() * 2 ) - 1;
			sample.z = Math.random();

			sample.normalize();

			let scale = i / kernelSize;
			scale = MathUtils.lerp( 0.1, 1, scale * scale );
			sample.multiplyScalar( scale );

			kernel.push( sample );

		}

	}

	generateRandomKernelRotations() {

		const width = 4, height = 4;

		const simplex = new SimplexNoise();

		const size = width * height;
		const data = new Float32Array( size );

		for ( let i = 0; i < size; i ++ ) {

			const x = ( Math.random() * 2 ) - 1;
			const y = ( Math.random() * 2 ) - 1;
			const z = 0;

			data[ i ] = simplex.noise3d( x, y, z );

		}

		this.noiseTexture = new DataTexture( data, width, height, RedFormat, FloatType );
		this.noiseTexture.wrapS = RepeatWrapping;
		this.noiseTexture.wrapT = RepeatWrapping;
		this.noiseTexture.needsUpdate = true;

	}

	overrideVisibility() {

		const scene = this.scene;
		const cache = this._visibilityCache;

		scene.traverse( function ( object ) {

			cache.set( object, object.visible );

			if ( object.isPoints || object.isLine ) object.visible = false;

		} );

	}

	restoreVisibility() {

		const scene = this.scene;
		const cache = this._visibilityCache;

		scene.traverse( function ( object ) {

			const visible = cache.get( object );
			object.visible = visible;

		} );

		cache.clear();

	}

}

SSAOPass.OUTPUT = {
	'Default': 0,
	'SSAO': 1,
	'Blur': 2,
	'Depth': 3,
	'Normal': 4
};

/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

const LuminosityHighPassShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'luminosityThreshold': { value: 1.0 },
		'smoothWidth': { value: 1.0 },
		'defaultColor': { value: new Color( 0x000000 ) },
		'defaultOpacity': { value: 0.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`

};

/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
class UnrealBloomPass extends Pass {

	constructor( resolution, strength, radius, threshold ) {

		super();

		this.strength = ( strength !== undefined ) ? strength : 1;
		this.radius = radius;
		this.threshold = threshold;
		this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );

		// create color only once here, reuse it later inside the render function
		this.clearColor = new Color( 0, 0, 0 );

		// render targets
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;
		let resx = Math.round( this.resolution.x / 2 );
		let resy = Math.round( this.resolution.y / 2 );

		this.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );
		this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
		this.renderTargetBright.texture.generateMipmaps = false;

		for ( let i = 0; i < this.nMips; i ++ ) {

			const renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );

			renderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;
			renderTargetHorizontal.texture.generateMipmaps = false;

			this.renderTargetsHorizontal.push( renderTargetHorizontal );

			const renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );

			renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
			renderTargetVertical.texture.generateMipmaps = false;

			this.renderTargetsVertical.push( renderTargetVertical );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// luminosity high pass material

		const highPassShader = LuminosityHighPassShader;
		this.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );

		this.highPassUniforms[ 'luminosityThreshold' ].value = threshold;
		this.highPassUniforms[ 'smoothWidth' ].value = 0.01;

		this.materialHighPassFilter = new ShaderMaterial( {
			uniforms: this.highPassUniforms,
			vertexShader: highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader
		} );

		// gaussian blur materials

		this.separableBlurMaterials = [];
		const kernelSizeArray = [ 3, 5, 7, 9, 11 ];
		resx = Math.round( this.resolution.x / 2 );
		resy = Math.round( this.resolution.y / 2 );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );

			this.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );

			resx = Math.round( resx / 2 );

			resy = Math.round( resy / 2 );

		}

		// composite material

		this.compositeMaterial = this.getCompositeMaterial( this.nMips );
		this.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;
		this.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;
		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;

		const bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];
		this.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;
		this.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		// blend material

		const copyShader = CopyShader;

		this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );

		this.blendMaterial = new ShaderMaterial( {
			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		} );

		this.enabled = true;
		this.needsSwap = false;

		this._oldClearColor = new Color();
		this.oldClearAlpha = 1;

		this.basic = new MeshBasicMaterial();

		this.fsQuad = new FullScreenQuad( null );

	}

	dispose() {

		for ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {

			this.renderTargetsHorizontal[ i ].dispose();

		}

		for ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {

			this.renderTargetsVertical[ i ].dispose();

		}

		this.renderTargetBright.dispose();

		//

		for ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {

			this.separableBlurMaterials[ i ].dispose();

		}

		this.compositeMaterial.dispose();
		this.blendMaterial.dispose();
		this.basic.dispose();

		//

		this.fsQuad.dispose();

	}

	setSize( width, height ) {

		let resx = Math.round( width / 2 );
		let resy = Math.round( height / 2 );

		this.renderTargetBright.setSize( resx, resy );

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.renderTargetsHorizontal[ i ].setSize( resx, resy );
			this.renderTargetsVertical[ i ].setSize( resx, resy );

			this.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );

			resx = Math.round( resx / 2 );
			resy = Math.round( resy / 2 );

		}

	}

	render( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

		renderer.getClearColor( this._oldClearColor );
		this.oldClearAlpha = renderer.getClearAlpha();
		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( this.clearColor, 0 );

		if ( maskActive ) renderer.state.buffers.stencil.setTest( false );

		// Render input to screen

		if ( this.renderToScreen ) {

			this.fsQuad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.setRenderTarget( null );
			renderer.clear();
			this.fsQuad.render( renderer );

		}

		// 1. Extract Bright Areas

		this.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;
		this.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;
		this.fsQuad.material = this.materialHighPassFilter;

		renderer.setRenderTarget( this.renderTargetBright );
		renderer.clear();
		this.fsQuad.render( renderer );

		// 2. Blur All the mips progressively

		let inputRenderTarget = this.renderTargetBright;

		for ( let i = 0; i < this.nMips; i ++ ) {

			this.fsQuad.material = this.separableBlurMaterials[ i ];

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;
			renderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			this.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;
			this.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;
			renderer.setRenderTarget( this.renderTargetsVertical[ i ] );
			renderer.clear();
			this.fsQuad.render( renderer );

			inputRenderTarget = this.renderTargetsVertical[ i ];

		}

		// Composite All the mips

		this.fsQuad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;
		this.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;
		this.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;

		renderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );
		renderer.clear();
		this.fsQuad.render( renderer );

		// Blend it additively over the input texture

		this.fsQuad.material = this.blendMaterial;
		this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;

		if ( maskActive ) renderer.state.buffers.stencil.setTest( true );

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this.fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( readBuffer );
			this.fsQuad.render( renderer );

		}

		// Restore renderer settings

		renderer.setClearColor( this._oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	}

	getSeperableBlurMaterial( kernelRadius ) {

		const coefficients = [];

		for ( let i = 0; i < kernelRadius; i ++ ) {

			coefficients.push( 0.39894 * Math.exp( -0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );

		}

		return new ShaderMaterial( {

			defines: {
				'KERNEL_RADIUS': kernelRadius
			},

			uniforms: {
				'colorTexture': { value: null },
				'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size
				'direction': { value: new Vector2( 0.5, 0.5 ) },
				'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
		} );

	}

	getCompositeMaterial( nMips ) {

		return new ShaderMaterial( {

			defines: {
				'NUM_MIPS': nMips
			},

			uniforms: {
				'blurTexture1': { value: null },
				'blurTexture2': { value: null },
				'blurTexture3': { value: null },
				'blurTexture4': { value: null },
				'blurTexture5': { value: null },
				'bloomStrength': { value: 1.0 },
				'bloomFactors': { value: null },
				'bloomTintColors': { value: null },
				'bloomRadius': { value: 0.0 }
			},

			vertexShader:
				`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,

			fragmentShader:
				`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
		} );

	}

}

UnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );
UnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );

function createDefaultMotionBlurSettings() {
  return {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16,
    pixelBlurLength: 50,
    vectorDetail: 50,
    direction: 0,
    blurLength: 10,
    radialMode: "zoom",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    adaptiveThreshold: 2,
    motionBlurQuality: "normal",
    useGPU: true
  };
}
class MotionBlurProcessor {
  settings;
  frameBuffer = [];
  maxBufferSize = 5;
  // Cached canvases for compositing
  workCanvas;
  workCtx;
  outputCanvas;
  outputCtx;
  constructor(width, height, settings) {
    this.settings = { ...createDefaultMotionBlurSettings(), ...settings };
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
  }
  // ============================================================================
  // SETTINGS
  // ============================================================================
  setSettings(settings) {
    this.settings = { ...this.settings, ...settings };
  }
  getSettings() {
    return { ...this.settings };
  }
  resize(width, height) {
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
    this.frameBuffer = [];
  }
  // ============================================================================
  // VELOCITY CALCULATION
  // ============================================================================
  /**
   * Calculate velocity from transform changes between frames
   */
  calculateVelocity(prevTransform, currTransform, deltaTime = 1) {
    return {
      x: (currTransform.x - prevTransform.x) / deltaTime,
      y: (currTransform.y - prevTransform.y) / deltaTime,
      rotation: (currTransform.rotation - prevTransform.rotation) / deltaTime,
      scale: (currTransform.scaleX - prevTransform.scaleX + (currTransform.scaleY - prevTransform.scaleY)) / 2 / deltaTime
    };
  }
  /**
   * Get velocity magnitude
   */
  getVelocityMagnitude(velocity) {
    return Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
  }
  // ============================================================================
  // BLUR APPLICATION
  // ============================================================================
  /**
   * Apply motion blur to a canvas based on current settings
   */
  applyMotionBlur(sourceCanvas, velocity, frame) {
    if (!this.settings.enabled || this.settings.type === "none") {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    this.addFrameToBuffer(sourceCanvas, velocity, frame);
    switch (this.settings.type) {
      case "standard":
        return this.applyStandardBlur(sourceCanvas, velocity);
      case "pixel":
        return this.applyPixelMotionBlur(sourceCanvas);
      case "directional":
        return this.applyDirectionalBlur(sourceCanvas);
      case "radial":
        return this.applyRadialBlur(sourceCanvas);
      case "vector":
        return this.applyVectorBlur(sourceCanvas, velocity);
      case "adaptive":
        return this.applyAdaptiveBlur(sourceCanvas, velocity);
      default:
        this.outputCtx.drawImage(sourceCanvas, 0, 0);
        return this.outputCanvas;
    }
  }
  /**
   * Add frame to circular buffer
   */
  addFrameToBuffer(canvas, velocity, frame) {
    const cloned = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = cloned.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    this.frameBuffer.push({
      canvas: cloned,
      velocity,
      timestamp: frame
    });
    while (this.frameBuffer.length > this.maxBufferSize) {
      this.frameBuffer.shift();
    }
  }
  // ============================================================================
  // STANDARD MOTION BLUR (Shutter-based)
  // ============================================================================
  /**
   * Standard After Effects motion blur using shutter angle
   * Simulates camera shutter open during frame exposure
   */
  applyStandardBlur(sourceCanvas, velocity) {
    const { shutterAngle, shutterPhase} = this.settings;
    const exposureRatio = shutterAngle / 360;
    const phaseOffset = shutterPhase / 360;
    const blurDistX = velocity.x * exposureRatio;
    const blurDistY = velocity.y * exposureRatio;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5 + phaseOffset;
      const offsetX = blurDistX * t;
      const offsetY = blurDistY * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // PIXEL MOTION BLUR
  // ============================================================================
  /**
   * Pixel Motion Blur - analyzes motion between frames
   * Creates blur based on pixel movement vectors
   */
  applyPixelMotionBlur(sourceCanvas) {
    if (this.frameBuffer.length < 2) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    const { pixelBlurLength, vectorDetail } = this.settings;
    const blurStrength = pixelBlurLength / 100;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const frameCount = Math.min(this.frameBuffer.length, Math.ceil(vectorDetail / 20) + 2);
    const alpha = 1 / frameCount;
    this.outputCtx.globalAlpha = alpha;
    for (let i = this.frameBuffer.length - frameCount; i < this.frameBuffer.length; i++) {
      if (i >= 0) {
        const frame = this.frameBuffer[i];
        const timeOffset = (this.frameBuffer.length - 1 - i) * blurStrength;
        this.outputCtx.save();
        this.outputCtx.translate(
          -frame.velocity.x * timeOffset * 0.5,
          -frame.velocity.y * timeOffset * 0.5
        );
        this.outputCtx.drawImage(frame.canvas, 0, 0);
        this.outputCtx.restore();
      }
    }
    this.outputCtx.globalAlpha = 0.5;
    this.outputCtx.drawImage(sourceCanvas, 0, 0);
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // DIRECTIONAL BLUR
  // ============================================================================
  /**
   * Directional blur - blur in a specific direction
   * Independent of actual motion
   */
  applyDirectionalBlur(sourceCanvas) {
    const { direction, blurLength } = this.settings;
    const angleRad = direction * Math.PI / 180;
    const dx = Math.cos(angleRad) * blurLength;
    const dy = Math.sin(angleRad) * blurLength;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      const offsetX = dx * t;
      const offsetY = dy * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // RADIAL BLUR
  // ============================================================================
  /**
   * Radial blur - zoom or spin blur from center point
   */
  applyRadialBlur(sourceCanvas) {
    const { radialMode, radialAmount, radialCenterX, radialCenterY } = this.settings;
    const centerX = this.outputCanvas.width * radialCenterX;
    const centerY = this.outputCanvas.height * radialCenterY;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    const amount = radialAmount / 100;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      if (radialMode === "spin") {
        const angle = t * amount * 0.2;
        this.outputCtx.rotate(angle);
      } else {
        const scale = 1 + t * amount * 0.1;
        this.outputCtx.scale(scale, scale);
      }
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // VECTOR MOTION BLUR
  // ============================================================================
  /**
   * Vector-based motion blur using velocity data
   * More accurate than pixel-based for known motion
   */
  applyVectorBlur(sourceCanvas, velocity) {
    const { shutterAngle, vectorDetail } = this.settings;
    const exposureRatio = shutterAngle / 360;
    const blurX = velocity.x * exposureRatio;
    const blurY = velocity.y * exposureRatio;
    const blurRotation = velocity.rotation * exposureRatio * 0.01;
    const blurScale = velocity.scale * exposureRatio * 1e-3;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = Math.ceil(vectorDetail / 100 * this.getSampleCount());
    const alpha = 1 / samples;
    const centerX = this.outputCanvas.width / 2;
    const centerY = this.outputCanvas.height / 2;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      this.outputCtx.translate(blurX * t, blurY * t);
      this.outputCtx.rotate(blurRotation * t);
      this.outputCtx.scale(1 + blurScale * t, 1 + blurScale * t);
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // ADAPTIVE BLUR
  // ============================================================================
  /**
   * Adaptive blur - automatically selects blur type based on motion
   */
  applyAdaptiveBlur(sourceCanvas, velocity) {
    const magnitude = this.getVelocityMagnitude(velocity);
    if (magnitude < this.settings.adaptiveThreshold) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    if (Math.abs(velocity.rotation) > magnitude * 0.5) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "spin";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.rotation) * 2);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    if (Math.abs(velocity.scale) > 0.1) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "zoom";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.scale) * 500);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    return this.applyVectorBlur(sourceCanvas, velocity);
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  /**
   * Get sample count based on quality setting
   */
  getSampleCount() {
    const base = this.settings.samplesPerFrame;
    switch (this.settings.motionBlurQuality) {
      case "draft":
        return Math.max(4, Math.floor(base / 2));
      case "high":
        return Math.min(64, base * 2);
      default:
        return base;
    }
  }
  /**
   * Clear frame buffer (call when seeking or starting new playback)
   */
  clearBuffer() {
    this.frameBuffer = [];
  }
  /**
   * Get motion blur intensity suggestion based on frame rate
   */
  static suggestSettings(fps) {
    const baseAngle = 180;
    const fpsRatio = 24 / fps;
    return {
      shutterAngle: Math.min(360, baseAngle * fpsRatio),
      samplesPerFrame: fps >= 60 ? 8 : fps >= 30 ? 12 : 16
    };
  }
}
const MOTION_BLUR_PRESETS = {
  // Film Standards
  "film_24fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_cinematic": {
    type: "standard",
    shutterAngle: 172.8,
    // 1/48s at 24fps
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_smooth": {
    type: "standard",
    shutterAngle: 270,
    shutterPhase: -90,
    samplesPerFrame: 24
  },
  // Video Standards
  "video_30fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 12
  },
  "video_60fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 8
  },
  // Stylized
  "action_crisp": {
    type: "standard",
    shutterAngle: 90,
    shutterPhase: -45,
    samplesPerFrame: 8
  },
  "dreamy": {
    type: "standard",
    shutterAngle: 360,
    shutterPhase: -180,
    samplesPerFrame: 32
  },
  "staccato": {
    type: "standard",
    shutterAngle: 45,
    shutterPhase: -22.5,
    samplesPerFrame: 4
  },
  // Directional Effects
  "speed_horizontal": {
    type: "directional",
    direction: 0,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "speed_vertical": {
    type: "directional",
    direction: 90,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "diagonal_streak": {
    type: "directional",
    direction: 45,
    blurLength: 30,
    samplesPerFrame: 24
  },
  // Radial Effects
  "zoom_impact": {
    type: "radial",
    radialMode: "zoom",
    radialAmount: 75,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  "spin_vortex": {
    type: "radial",
    radialMode: "spin",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  // Advanced
  "pixel_smooth": {
    type: "pixel",
    pixelBlurLength: 60,
    vectorDetail: 70,
    samplesPerFrame: 16
  },
  "vector_accurate": {
    type: "vector",
    shutterAngle: 180,
    vectorDetail: 90,
    samplesPerFrame: 24
  },
  "adaptive_auto": {
    type: "adaptive",
    shutterAngle: 180,
    adaptiveThreshold: 3,
    samplesPerFrame: 16
  }
};

class RenderPipeline {
  renderer;
  composer;
  scene;
  camera;
  // Render targets
  colorTarget;
  depthTarget;
  // Frame capture
  captureCanvas;
  captureCtx;
  // Depth capture material
  depthMaterial;
  // Normal material for normal pass
  normalMaterial;
  // Dimensions
  width;
  height;
  pixelRatio;
  // Render mode
  renderMode = "color";
  // DOF pass
  bokehPass = null;
  dofConfig = {
    enabled: false,
    focusDistance: 500,
    aperture: 0.025,
    maxBlur: 0.01
  };
  // SSAO pass
  ssaoPass = null;
  ssaoConfig = {
    enabled: false,
    kernelRadius: 8,
    minDistance: 5e-3,
    maxDistance: 0.1,
    intensity: 1,
    output: "default"
  };
  // Bloom pass (for emissive objects and lights)
  bloomPass = null;
  bloomConfig = {
    enabled: false,
    strength: 1.5,
    radius: 0.4,
    threshold: 0.85
  };
  // Motion blur processor (canvas-based, applied post-render)
  motionBlurProcessor;
  motionBlurConfig = {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  };
  previousFrameTransform = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1
  };
  constructor(config, scene, camera) {
    this.scene = scene;
    this.camera = camera;
    this.width = config.width;
    this.height = config.height;
    this.pixelRatio = config.pixelRatio ?? Math.min(window.devicePixelRatio, 2);
    this.renderer = new WebGLRenderer({
      canvas: config.canvas,
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      preserveDrawingBuffer: true,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: false,
      depth: true
    });
    this.renderer.setPixelRatio(this.pixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.renderer.toneMapping = ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1;
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer = new EffectComposer(this.renderer, this.colorTarget);
    this.setupDefaultPasses();
    this.captureCanvas = new OffscreenCanvas(scaledWidth, scaledHeight);
    this.captureCtx = this.captureCanvas.getContext("2d");
    this.depthMaterial = this.createDepthMaterial();
    this.normalMaterial = new MeshNormalMaterial();
    this.motionBlurProcessor = new MotionBlurProcessor(scaledWidth, scaledHeight);
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(width, height) {
    return new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      type: HalfFloatType,
      colorSpace: SRGBColorSpace,
      depthBuffer: true,
      stencilBuffer: false,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      depthBuffer: true,
      stencilBuffer: false
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = FloatType;
    return target;
  }
  createDepthMaterial() {
    return new ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: false,
      depthTest: false
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const renderPass = new RenderPass(this.scene.scene, this.camera.camera);
    this.composer.addPass(renderPass);
    const outputPass = new OutputPass();
    this.composer.addPass(outputPass);
  }
  /**
   * Add a post-processing pass
   */
  addPass(pass) {
    const outputIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "OutputPass"
    );
    if (outputIndex > -1) {
      this.composer.insertPass(pass, outputIndex);
    } else {
      this.composer.addPass(pass);
    }
  }
  /**
   * Remove a post-processing pass
   */
  removePass(pass) {
    this.composer.removePass(pass);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(config) {
    this.dofConfig = { ...this.dofConfig, ...config };
    if (this.dofConfig.enabled) {
      if (!this.bokehPass) {
        this.createBokehPass();
      }
      this.updateBokehPass();
    } else {
      if (this.bokehPass) {
        this.composer.removePass(this.bokehPass);
        this.bokehPass = null;
      }
    }
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    this.bokehPass = new BokehPass(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    );
    this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const uniforms = this.bokehPass.uniforms;
    if (uniforms) {
      uniforms.focus.value = this.dofConfig.focusDistance;
      uniforms.aperture.value = this.dofConfig.aperture;
      uniforms.maxblur.value = this.dofConfig.maxBlur;
    }
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(distance) {
    this.setDOF({ focusDistance: distance });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(aperture) {
    this.setDOF({ aperture });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(enabled) {
    this.setDOF({ enabled });
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   */
  setSSAO(config) {
    this.ssaoConfig = { ...this.ssaoConfig, ...config };
    if (this.ssaoConfig.enabled) {
      if (!this.ssaoPass) {
        this.createSSAOPass();
      }
      this.updateSSAOPass();
    } else {
      if (this.ssaoPass) {
        this.composer.removePass(this.ssaoPass);
        this.ssaoPass = null;
      }
    }
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return { ...this.ssaoConfig };
  }
  /**
   * Create the SSAO pass
   */
  createSSAOPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.ssaoPass = new SSAOPass(
      this.scene.scene,
      this.camera.camera,
      scaledWidth,
      scaledHeight
    );
    const renderPassIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "RenderPass"
    );
    if (renderPassIndex > -1) {
      this.composer.insertPass(this.ssaoPass, renderPassIndex + 1);
    } else {
      this.addPass(this.ssaoPass);
    }
  }
  /**
   * Update SSAO pass parameters
   */
  updateSSAOPass() {
    if (!this.ssaoPass) return;
    this.ssaoPass.kernelRadius = this.ssaoConfig.kernelRadius;
    this.ssaoPass.minDistance = this.ssaoConfig.minDistance;
    this.ssaoPass.maxDistance = this.ssaoConfig.maxDistance;
    const outputMap = {
      "default": SSAOPass.OUTPUT.Default,
      "ssao": SSAOPass.OUTPUT.SSAO,
      "blur": SSAOPass.OUTPUT.Blur,
      "depth": SSAOPass.OUTPUT.Depth,
      "normal": SSAOPass.OUTPUT.Normal
    };
    this.ssaoPass.output = outputMap[this.ssaoConfig.output];
  }
  /**
   * Enable/disable SSAO (convenience method)
   */
  setSSAOEnabled(enabled) {
    this.setSSAO({ enabled });
  }
  /**
   * Set SSAO intensity (convenience method)
   */
  setSSAOIntensity(intensity) {
    this.setSSAO({ intensity });
  }
  /**
   * Set SSAO kernel radius (convenience method)
   */
  setSSAORadius(radius) {
    this.setSSAO({ kernelRadius: radius });
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, particles) glow
   */
  setBloom(config) {
    this.bloomConfig = { ...this.bloomConfig, ...config };
    if (this.bloomConfig.enabled) {
      if (!this.bloomPass) {
        this.createBloomPass();
      }
      this.updateBloomPass();
    } else {
      if (this.bloomPass) {
        this.composer.removePass(this.bloomPass);
        this.bloomPass = null;
      }
    }
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return { ...this.bloomConfig };
  }
  /**
   * Create the bloom pass
   */
  createBloomPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.bloomPass = new UnrealBloomPass(
      new Vector2(scaledWidth, scaledHeight),
      this.bloomConfig.strength,
      this.bloomConfig.radius,
      this.bloomConfig.threshold
    );
    const ssaoIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "SSAOPass"
    );
    if (ssaoIndex > -1) {
      this.composer.insertPass(this.bloomPass, ssaoIndex + 1);
    } else {
      const renderIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "RenderPass"
      );
      if (renderIndex > -1) {
        this.composer.insertPass(this.bloomPass, renderIndex + 1);
      } else {
        this.addPass(this.bloomPass);
      }
    }
  }
  /**
   * Update bloom pass parameters
   */
  updateBloomPass() {
    if (!this.bloomPass) return;
    this.bloomPass.strength = this.bloomConfig.strength;
    this.bloomPass.radius = this.bloomConfig.radius;
    this.bloomPass.threshold = this.bloomConfig.threshold;
  }
  /**
   * Enable/disable bloom (convenience method)
   */
  setBloomEnabled(enabled) {
    this.setBloom({ enabled });
  }
  /**
   * Set bloom intensity (convenience method)
   */
  setBloomStrength(strength) {
    this.setBloom({ strength });
  }
  /**
   * Set bloom threshold (convenience method)
   */
  setBloomThreshold(threshold) {
    this.setBloom({ threshold });
  }
  // ============================================================================
  // MOTION BLUR CONFIGURATION
  // ============================================================================
  /**
   * Configure motion blur
   */
  setMotionBlur(config) {
    this.motionBlurConfig = { ...this.motionBlurConfig, ...config };
    this.motionBlurProcessor.setSettings({
      enabled: this.motionBlurConfig.enabled,
      type: this.motionBlurConfig.type,
      shutterAngle: this.motionBlurConfig.shutterAngle,
      shutterPhase: this.motionBlurConfig.shutterPhase,
      samplesPerFrame: this.motionBlurConfig.samplesPerFrame
    });
  }
  /**
   * Enable/disable motion blur
   */
  setMotionBlurEnabled(enabled) {
    this.setMotionBlur({ enabled });
  }
  /**
   * Set motion blur type
   */
  setMotionBlurType(type) {
    this.setMotionBlur({ type });
  }
  /**
   * Set shutter angle (0-720, 180 = standard film)
   */
  setMotionBlurShutterAngle(shutterAngle) {
    this.setMotionBlur({ shutterAngle });
  }
  /**
   * Apply a motion blur preset by name
   */
  setMotionBlurPreset(presetName) {
    const preset = MOTION_BLUR_PRESETS[presetName];
    if (preset) {
      this.setMotionBlur({
        enabled: true,
        type: preset.type || "standard",
        shutterAngle: preset.shutterAngle || 180,
        shutterPhase: preset.shutterPhase || -90,
        samplesPerFrame: preset.samplesPerFrame || 16,
        preset: presetName
      });
    }
  }
  /**
   * Get current motion blur configuration
   */
  getMotionBlurConfig() {
    return { ...this.motionBlurConfig };
  }
  /**
   * Get the motion blur processor (for advanced use)
   */
  getMotionBlurProcessor() {
    return this.motionBlurProcessor;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ();
    this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.render(this.scene.scene, this.camera.camera);
    this.renderer.setRenderTarget(prevTarget);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    if (mode === "depth" || mode === "normal") {
      this.scene.scene.overrideMaterial = mode === "depth" ? this.depthMaterial : this.normalMaterial;
    } else {
      this.scene.scene.overrideMaterial = null;
    }
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    const buffer = new Uint8Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const flipped = new Uint8ClampedArray(buffer.length);
    const rowSize = width * 4;
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * rowSize;
      const dstRow = y * rowSize;
      flipped.set(buffer.subarray(srcRow, srcRow + rowSize), dstRow);
    }
    return new ImageData(flipped, width, height);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const buffer = new Float32Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const depth = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      depth[i] = buffer[i * 4];
    }
    const flipped = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width;
      const dstRow = y * width;
      flipped.set(depth.subarray(srcRow, srcRow + width), dstRow);
    }
    return flipped;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(width, height) {
    this.width = width;
    this.height = height;
    const scaledWidth = Math.floor(width * this.pixelRatio);
    const scaledHeight = Math.floor(height * this.pixelRatio);
    this.renderer.setSize(width, height);
    this.composer.setSize(scaledWidth, scaledHeight);
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer.renderTarget1.dispose();
    this.composer.renderTarget2.dispose();
    this.composer.renderTarget1 = this.colorTarget.clone();
    this.composer.renderTarget2 = this.colorTarget.clone();
    this.captureCanvas.width = scaledWidth;
    this.captureCanvas.height = scaledHeight;
    if (this.bokehPass && this.dofConfig.enabled) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
      this.createBokehPass();
    }
    if (this.ssaoPass && this.ssaoConfig.enabled) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
      this.createSSAOPass();
      this.updateSSAOPass();
    }
    if (this.bloomPass && this.bloomConfig.enabled) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
      this.createBloomPass();
      this.updateBloomPass();
    }
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // PRECOMP RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of render targets for precomps (keyed by compositionId) */
  precompTargets = /* @__PURE__ */ new Map();
  /**
   * Create or get a render target for a precomp composition
   */
  getPrecompRenderTarget(compositionId, width, height) {
    const key = `${compositionId}_${width}_${height}`;
    let target = this.precompTargets.get(key);
    if (!target) {
      target = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        type: UnsignedByteType,
        colorSpace: SRGBColorSpace,
        depthBuffer: true,
        stencilBuffer: false
      });
      this.precompTargets.set(key, target);
    }
    return target;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for precomp rendering
   */
  renderSceneToTexture(scene, camera, target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.clear();
    this.renderer.render(scene, camera);
    this.renderer.setRenderTarget(prevTarget);
    return target.texture;
  }
  /**
   * Dispose a precomp render target
   */
  disposePrecompTarget(compositionId) {
    for (const [key, target] of this.precompTargets.entries()) {
      if (key.startsWith(compositionId + "_")) {
        target.dispose();
        this.precompTargets.delete(key);
      }
    }
  }
  /**
   * Dispose all precomp render targets
   */
  disposeAllPrecompTargets() {
    for (const target of this.precompTargets.values()) {
      target.dispose();
    }
    this.precompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    if (this.bokehPass) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
    }
    if (this.ssaoPass) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
    }
    if (this.bloomPass) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
    }
    this.disposeAllPrecompTargets();
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.depthMaterial.dispose();
    this.normalMaterial.dispose();
    this.composer.dispose();
    this.renderer.dispose();
  }
}

class ImageLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  texture = null;
  /** Resource manager for texture loading */
  resources;
  /** Image dimensions */
  imageWidth = 100;
  imageHeight = 100;
  /** Source URL or asset ID */
  sourceUrl = null;
  /** Original (unprocessed) texture for effects source */
  originalTexture = null;
  /** Canvas for rendering texture to 2D for effect processing */
  textureCanvas = null;
  textureCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `image_${this.id}`;
    this.group.add(this.mesh);
    const imageData = this.extractImageData(layerData);
    if (imageData.source) {
      this.loadImage(imageData.source);
    }
    this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(layerData) {
    const data = layerData.data;
    return {
      source: data?.source ?? data?.url ?? data?.assetId ?? null,
      width: data?.width ?? 100,
      height: data?.height ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(url) {
    this.sourceUrl = url;
    try {
      const texture = await this.resources.loadTexture(url, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      });
      this.setTexture(texture);
    } catch (error) {
      layerLogger.error(`ImageLayer: Failed to load image: ${url}`, error);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(texture) {
    this.texture = texture;
    this.originalTexture = texture;
    this.material.map = texture;
    this.material.needsUpdate = true;
    if (texture.image) {
      this.imageWidth = texture.image.width || texture.image.videoWidth || 100;
      this.imageHeight = texture.image.height || texture.image.videoHeight || 100;
      this.updateMeshSize();
      this.textureCanvas = null;
      this.textureCanvasCtx = null;
      this.effectsDirty = true;
    }
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(imageData) {
    const texture = this.resources.createTextureFromImageData(
      imageData,
      `layer_${this.id}_imagedata`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(canvas) {
    const texture = this.resources.createTextureFromCanvas(
      canvas,
      `layer_${this.id}_canvas`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(this.imageWidth, this.imageHeight);
    this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(width, height) {
    this.imageWidth = width;
    this.imageHeight = height;
    this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(color) {
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215);
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.originalTexture?.image) {
      return null;
    }
    const image = this.originalTexture.image;
    if (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.width = this.imageWidth;
      this.textureCanvas.height = this.imageHeight;
      this.textureCanvasCtx = this.textureCanvas.getContext("2d");
    }
    if (!this.textureCanvasCtx) {
      return null;
    }
    this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight);
    this.textureCanvasCtx.drawImage(image, 0, 0, this.imageWidth, this.imageHeight);
    return this.textureCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.texture = processedTexture;
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    this.evaluateEffects(frame);
  }
  onApplyEvaluatedState(state) {
    if (state.properties["tint"] !== void 0) {
      this.setTint(state.properties["tint"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.source || data?.url || data?.assetId) {
      const newSource = data.source ?? data.url ?? data.assetId;
      if (newSource !== this.sourceUrl) {
        this.loadImage(newSource);
      }
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data.width ?? this.imageWidth,
        data.height ?? this.imageHeight
      );
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class SolidLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  /** Solid color */
  color;
  /** Solid dimensions */
  width;
  height;
  /** Animated color property */
  animatedColor;
  constructor(layerData) {
    super(layerData);
    const solidData = this.extractSolidData(layerData);
    this.color = solidData.color;
    this.width = solidData.width;
    this.height = solidData.height;
    this.animatedColor = solidData.animatedColor;
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new MeshBasicMaterial({
      color: this.color,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `solid_${this.id}`;
    this.group.add(this.mesh);
    this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(layerData) {
    const data = layerData.data;
    return {
      color: data?.color ?? "#808080",
      width: data?.width ?? 1920,
      height: data?.height ?? 1080,
      animatedColor: data?.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(color) {
    this.color = color;
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.animatedColor, frame);
      this.material.color.set(color);
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    if (state.properties["color"] !== void 0) {
      this.material.color.set(state.properties["color"]);
      this.material.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.color !== void 0) {
      this.setColor(data.color);
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data?.width ?? this.width,
        data?.height ?? this.height
      );
    }
    if (data?.animatedColor !== void 0) {
      this.animatedColor = data.animatedColor;
    }
    if (data === void 0 && properties.labelColor !== void 0) {
      this.setColor(properties.labelColor);
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class NullLayer extends BaseLayer {
  /** Visual indicator (crosshair) for editor visibility */
  indicator = null;
  /** Whether to show the null indicator */
  showIndicator;
  /** Indicator size */
  indicatorSize;
  constructor(layerData, showIndicator = true) {
    super(layerData);
    this.showIndicator = showIndicator;
    this.indicatorSize = 50;
    if (this.showIndicator) {
      this.createIndicator();
    }
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Group();
    this.indicator.name = `null_indicator_${this.id}`;
    const size = this.indicatorSize;
    const color = 16737792;
    const material = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const hPoints = [
      new Vector3(-size / 2, 0, 0),
      new Vector3(size / 2, 0, 0)
    ];
    const hGeometry = new BufferGeometry().setFromPoints(hPoints);
    const hLine = new Line(hGeometry, material);
    this.indicator.add(hLine);
    const vPoints = [
      new Vector3(0, -size / 2, 0),
      new Vector3(0, size / 2, 0)
    ];
    const vGeometry = new BufferGeometry().setFromPoints(vPoints);
    const vLine = new Line(vGeometry, material);
    this.indicator.add(vLine);
    if (this.threeD) {
      const zPoints = [
        new Vector3(0, 0, -size / 2),
        new Vector3(0, 0, size / 2)
      ];
      const zGeometry = new BufferGeometry().setFromPoints(zPoints);
      const zLine = new Line(zGeometry, material);
      this.indicator.add(zLine);
    }
    const centerGeometry = new CircleGeometry(3, 16);
    const centerMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false,
      side: DoubleSide
    });
    const centerPoint = new Mesh(centerGeometry, centerMaterial);
    this.indicator.add(centerPoint);
    this.group.add(this.indicator);
    this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(visible) {
    if (this.indicator) {
      this.indicator.visible = visible;
    }
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(size) {
    if (size === this.indicatorSize) return;
    this.indicatorSize = size;
    if (this.indicator) {
      this.group.remove(this.indicator);
      this.disposeIndicator();
      this.createIndicator();
    }
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    if (!this.indicator) return;
    this.indicator.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
      if (child instanceof Mesh) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.indicator.clear();
    this.indicator = null;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(_frame) {
  }
  onApplyEvaluatedState(_state) {
  }
  onUpdate(properties) {
    if (properties.threeD !== void 0 && properties.threeD !== this.threeD) {
      this.threeD = properties.threeD;
      if (this.indicator && this.showIndicator) {
        this.group.remove(this.indicator);
        this.disposeIndicator();
        this.createIndicator();
      }
    }
  }
  onDispose() {
    this.disposeIndicator();
  }
}

function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0) dependencies = [];
    var init = ref.init;
    if (init === void 0) init = function() {
    };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0) getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init = rehydrate("<" + name + ">.init", init);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init === "function") {
        value = init.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(function(dep) {
      if (dep) {
        dep = dep.onMainThread || dep;
        if (dep._getInitResult) {
          dep = dep._getInitResult();
        }
      }
      return dep;
    }) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  var onMainThread = defineMainThreadModule(options);
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (!supportsWorkers()) {
      return onMainThread.apply(void 0, args);
    }
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  moduleFunc.onMainThread = onMainThread;
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  return new Promise(function(resolve, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function(response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId,
      action,
      data
    });
  });
}

function SDFGenerator() {
var exports$1 = (function (exports$1) {

  /**
   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]
   */
  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {
    var t2 = 1 - t;
    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;
    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;
  }

  /**
   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]
   */
  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {
    var t2 = 1 - t;
    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;
    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;
  }

  /**
   * Parse a path string into its constituent line/curve commands, invoking a callback for each.
   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
   * @param {function(
   *   command: 'L'|'Q'|'C',
   *   startX: number,
   *   startY: number,
   *   endX: number,
   *   endY: number,
   *   ctrl1X?: number,
   *   ctrl1Y?: number,
   *   ctrl2X?: number,
   *   ctrl2Y?: number
   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the
   *                      command identifier (only L/Q/C commands) and its numeric arguments.
   */
  function forEachPathCommand(pathString, commandCallback) {
    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
    var match, firstX, firstY, prevX, prevY;
    while ((match = segmentRE.exec(pathString))) {
      var args = match[2]
        .replace(/^\s*|\s*$/g, '')
        .split(/[,\s]+/)
        .map(function (v) { return parseFloat(v); });
      switch (match[1]) {
        case 'M':
          prevX = firstX = args[0];
          prevY = firstY = args[1];
          break
        case 'L':
          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands
            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));
          }
          break
        case 'Q': {
          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);
          break
        }
        case 'C': {
          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);
          break
        }
        case 'Z':
          if (prevX !== firstX || prevY !== firstY) {
            commandCallback('L', prevX, prevY, firstX, firstY);
          }
          break
      }
    }
  }

  /**
   * Convert a path string to a series of straight line segments
   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z
   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback
   *        function that will be called once for every line segment
   * @param {number} [curvePoints] - How many straight line segments to use when approximating a
   *        bezier curve in the path. Defaults to 16.
   */
  function pathToLineSegments (pathString, segmentCallback, curvePoints) {
    if ( curvePoints === void 0 ) curvePoints = 16;

    var tempPoint = { x: 0, y: 0 };
    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
      switch (command) {
        case 'L':
          segmentCallback(startX, startY, endX, endY);
          break
        case 'Q': {
          var prevCurveX = startX;
          var prevCurveY = startY;
          for (var i = 1; i < curvePoints; i++) {
            pointOnQuadraticBezier(
              startX, startY,
              ctrl1X, ctrl1Y,
              endX, endY,
              i / (curvePoints - 1),
              tempPoint
            );
            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
            prevCurveX = tempPoint.x;
            prevCurveY = tempPoint.y;
          }
          break
        }
        case 'C': {
          var prevCurveX$1 = startX;
          var prevCurveY$1 = startY;
          for (var i$1 = 1; i$1 < curvePoints; i$1++) {
            pointOnCubicBezier(
              startX, startY,
              ctrl1X, ctrl1Y,
              ctrl2X, ctrl2Y,
              endX, endY,
              i$1 / (curvePoints - 1),
              tempPoint
            );
            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
            prevCurveX$1 = tempPoint.x;
            prevCurveY$1 = tempPoint.y;
          }
          break
        }
      }
    });
  }

  var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";

  var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";

  var cache = new WeakMap();

  var glContextParams = {
    premultipliedAlpha: false,
    preserveDrawingBuffer: true,
    antialias: false,
    depth: false,
  };

  /**
   * This is a little helper library for WebGL. It assists with state management for a GL context.
   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.
   *
   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap
   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback
   */
  function withWebGLContext (glOrCanvas, callback) {
    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;
    var wrapper = cache.get(gl);
    if (!wrapper) {
      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
      var extensions = {};
      var programs = {};
      var textures = {};
      var textureUnit = -1;
      var framebufferStack = [];

      gl.canvas.addEventListener('webglcontextlost', function (e) {
        handleContextLoss();
        e.preventDefault();
      }, false);

      function getExtension (name) {
        var ext = extensions[name];
        if (!ext) {
          ext = extensions[name] = gl.getExtension(name);
          if (!ext) {
            throw new Error((name + " not supported"))
          }
        }
        return ext
      }

      function compileShader (src, type) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
        // if (!status && !gl.isContextLost()) {
        //   throw new Error(gl.getShaderInfoLog(shader).trim())
        // }
        return shader
      }

      function withProgram (name, vert, frag, func) {
        if (!programs[name]) {
          var attributes = {};
          var uniforms = {};
          var program = gl.createProgram();
          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
          gl.linkProgram(program);

          programs[name] = {
            program: program,
            transaction: function transaction (func) {
              gl.useProgram(program);
              func({
                setUniform: function setUniform (type, name) {
                  var values = [], len = arguments.length - 2;
                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));
                  gl[("uniform" + type)].apply(gl, [ uniformLoc ].concat( values ));
                },

                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {
                  var attr = attributes[name];
                  if (!attr) {
                    attr = attributes[name] = {
                      buf: gl.createBuffer(), // TODO should we destroy our buffers?
                      loc: gl.getAttribLocation(program, name),
                      data: null
                    };
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                  gl.enableVertexAttribArray(attr.loc);
                  if (isWebGL2) {
                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                  } else {
                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                  }
                  if (data !== attr.data) {
                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                    attr.data = data;
                  }
                }
              });
            }
          };
        }

        programs[name].transaction(func);
      }

      function withTexture (name, func) {
        textureUnit++;
        try {
          gl.activeTexture(gl.TEXTURE0 + textureUnit);
          var texture = textures[name];
          if (!texture) {
            texture = textures[name] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          }
          gl.bindTexture(gl.TEXTURE_2D, texture);
          func(texture, textureUnit);
        } finally {
          textureUnit--;
        }
      }

      function withTextureFramebuffer (texture, textureUnit, func) {
        var framebuffer = gl.createFramebuffer();
        framebufferStack.push(framebuffer);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        try {
          func(framebuffer);
        } finally {
          gl.deleteFramebuffer(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
        }
      }

      function handleContextLoss () {
        extensions = {};
        programs = {};
        textures = {};
        textureUnit = -1;
        framebufferStack.length = 0;
      }

      cache.set(gl, wrapper = {
        gl: gl,
        isWebGL2: isWebGL2,
        getExtension: getExtension,
        withProgram: withProgram,
        withTexture: withTexture,
        withTextureFramebuffer: withTextureFramebuffer,
        handleContextLoss: handleContextLoss,
      });
    }
    callback(wrapper);
  }


  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {
    if ( channels === void 0 ) channels = 15;
    if ( framebuffer === void 0 ) framebuffer = null;

    withWebGLContext(glOrCanvas, function (ref) {
      var gl = ref.gl;
      var withProgram = ref.withProgram;
      var withTexture = ref.withTexture;

      withTexture('copy', function (tex, texUnit) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {
          var setUniform = ref.setUniform;
          var setAttribute = ref.setAttribute;

          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
          setUniform('1i', 'image', texUnit);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
          gl.disable(gl.BLEND);
          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
          gl.viewport(x, y, width, height);
          gl.scissor(x, y, width, height);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        });
      });
    });
  }

  /**
   * Resizing a canvas clears its contents; this utility copies the previous contents over.
   * @param canvas
   * @param newWidth
   * @param newHeight
   */
  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {
    var width = canvas.width;
    var height = canvas.height;
    withWebGLContext(canvas, function (ref) {
      var gl = ref.gl;

      var data = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
      canvas.width = newWidth;
      canvas.height = newHeight;
      renderImageData(gl, data, 0, 0, width, height);
    });
  }

  var webglUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    withWebGLContext: withWebGLContext,
    renderImageData: renderImageData,
    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing
  });

  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;

    var textureData = new Uint8Array(sdfWidth * sdfHeight);

    var viewBoxWidth = viewBox[2] - viewBox[0];
    var viewBoxHeight = viewBox[3] - viewBox[1];

    // Decompose all paths into straight line segments and add them to an index
    var segments = [];
    pathToLineSegments(path, function (x1, y1, x2, y2) {
      segments.push({
        x1: x1, y1: y1, x2: x2, y2: y2,
        minX: Math.min(x1, x2),
        minY: Math.min(y1, y2),
        maxX: Math.max(x1, x2),
        maxY: Math.max(y1, y2)
      });
    });

    // Sort segments by maxX, this will let us short-circuit some loops below
    segments.sort(function (a, b) { return a.maxX - b.maxX; });

    // For each target SDF texel, find the distance from its center to its nearest line segment,
    // map that distance to an alpha value, and write that alpha to the texel
    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
        var signedDist = findNearestSignedDistance(
          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
        );

        // Use an exponential scale to ensure the texels very near the glyph path have adequate
        // precision, while allowing the distance field to cover the entire texture, given that
        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam
        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;
        if (signedDist < 0) {
          alpha = 1 - alpha;
        }

        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp
        textureData[sdfY * sdfWidth + sdfX] = alpha;
      }
    }

    return textureData

    /**
     * For a given x/y, search the index for the closest line segment and return
     * its signed distance. Negative = inside, positive = outside, zero = on edge
     * @param x
     * @param y
     * @returns {number}
     */
    function findNearestSignedDistance (x, y) {
      var closestDistSq = Infinity;
      var closestDist = Infinity;

      for (var i = segments.length; i--;) {
        var seg = segments[i];
        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit
        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);
          if (distSq < closestDistSq) {
            closestDistSq = distSq;
            closestDist = Math.sqrt(closestDistSq);
          }
        }
      }

      // Flip to negative distance if inside the poly
      if (isPointInPoly(x, y)) {
        closestDist = -closestDist;
      }
      return closestDist
    }

    /**
     * Determine whether the given point lies inside or outside the glyph. Uses a simple
     * winding-number ray casting algorithm using a ray pointing east from the point.
     */
    function isPointInPoly (x, y) {
      var winding = 0;
      for (var i = segments.length; i--;) {
        var seg = segments[i];
        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit
        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);
        if (intersects) {
          winding += seg.y1 < seg.y2 ? 1 : -1;
        }
      }
      return winding !== 0
    }
  }

  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( channel === void 0 ) channel = 0;

    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
  }

  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( channel === void 0 ) channel = 0;

    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
    // Expand single-channel data to rbga
    var rgbaData = new Uint8Array(data.length * 4);
    for (var i = 0; i < data.length; i++) {
      rgbaData[i * 4 + channel] = data[i];
    }
    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);
  }

  /**
   * Find the absolute distance from a point to a line segment at closest approach
   */
  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {
    var ldx = lineX1 - lineX0;
    var ldy = lineY1 - lineY0;
    var lengthSq = ldx * ldx + ldy * ldy;
    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
    var dx = x - (lineX0 + t * ldx);
    var dy = y - (lineY0 + t * ldy);
    return dx * dx + dy * dy
  }

  var javascript = /*#__PURE__*/Object.freeze({
    __proto__: null,
    generate: generate$2,
    generateIntoCanvas: generateIntoCanvas$2,
    generateIntoFramebuffer: generateIntoFramebuffer$1
  });

  var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";

  var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";

  var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";

  // Single triangle covering viewport
  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);

  var implicitContext = null;
  var isTestingSupport = false;
  var NULL_OBJECT = {};
  var supportByCanvas = new WeakMap(); // canvas -> bool

  function validateSupport (glOrCanvas) {
    if (!isTestingSupport && !isSupported(glOrCanvas)) {
      throw new Error('WebGL generation not supported')
    }
  }

  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( glOrCanvas === void 0 ) glOrCanvas = null;

    if (!glOrCanvas) {
      glOrCanvas = implicitContext;
      if (!glOrCanvas) {
        var canvas = typeof OffscreenCanvas === 'function'
          ? new OffscreenCanvas(1, 1)
          : typeof document !== 'undefined'
            ? document.createElement('canvas')
            : null;
        if (!canvas) {
          throw new Error('OffscreenCanvas or DOM canvas not supported')
        }
        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });
      }
    }

    validateSupport(glOrCanvas);

    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari

    // Render into a background texture framebuffer
    withWebGLContext(glOrCanvas, function (ref) {
      var gl = ref.gl;
      var withTexture = ref.withTexture;
      var withTextureFramebuffer = ref.withTextureFramebuffer;

      withTexture('readable', function (texture, textureUnit) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {
          generateIntoFramebuffer(
            sdfWidth,
            sdfHeight,
            path,
            viewBox,
            maxDistance,
            sdfExponent,
            gl,
            framebuffer,
            0,
            0,
            0 // red channel
          );
          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
        });
      });
    });

    // Throw away all but the red channel
    var data = new Uint8Array(sdfWidth * sdfHeight);
    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {
      data[j++] = rgbaData[i];
    }

    return data
  }

  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( channel === void 0 ) channel = 0;

    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
  }

  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( channel === void 0 ) channel = 0;

    // Verify support
    validateSupport(glOrCanvas);

    // Compute path segments
    var lineSegmentCoords = [];
    pathToLineSegments(path, function (x1, y1, x2, y2) {
      lineSegmentCoords.push(x1, y1, x2, y2);
    });
    lineSegmentCoords = new Float32Array(lineSegmentCoords);

    withWebGLContext(glOrCanvas, function (ref) {
      var gl = ref.gl;
      var isWebGL2 = ref.isWebGL2;
      var getExtension = ref.getExtension;
      var withProgram = ref.withProgram;
      var withTexture = ref.withTexture;
      var withTextureFramebuffer = ref.withTextureFramebuffer;
      var handleContextLoss = ref.handleContextLoss;

      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {
        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
          gl.texImage2D(
            gl.TEXTURE_2D, 0, gl.RGBA,
            intermediateTexture._lastWidth = sdfWidth,
            intermediateTexture._lastHeight = sdfHeight,
            0, gl.RGBA, gl.UNSIGNED_BYTE, null
          );
        }

        // Unsigned distance pass
        withProgram('main', mainVertex, mainFragment, function (ref) {
          var setAttribute = ref.setAttribute;
          var setUniform = ref.setUniform;

          // Init extensions
          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');
          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');

          // Init/update attributes
          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);

          // Init/update uniforms
          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));
          setUniform('1f', 'uMaxDistance', maxDistance);
          setUniform('1f', 'uExponent', sdfExponent);

          // Render initial unsigned distance / winding number info to a texture
          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {
            gl.enable(gl.BLEND);
            gl.colorMask(true, true, true, true);
            gl.viewport(0, 0, sdfWidth, sdfHeight);
            gl.scissor(0, 0, sdfWidth, sdfHeight);
            gl.blendFunc(gl.ONE, gl.ONE);
            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a "winding number".
            // Alpha holds the closest (MAX) unsigned distance.
            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
            gl.clear(gl.COLOR_BUFFER_BIT);
            if (isWebGL2) {
              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
            } else {
              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
            }
            // Debug
            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)
            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)
            // console.log('intermediate texture data: ', debug)
          });
        });

        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.
        withProgram('post', viewportQuadVertex, postFragment, function (program) {
          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);
          program.setUniform('1i', 'tex', intermediateTextureUnit);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.disable(gl.BLEND);
          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
          gl.viewport(x, y, sdfWidth, sdfHeight);
          gl.scissor(x, y, sdfWidth, sdfHeight);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        });
      });

      // Handle context loss occurring during any of the above calls
      if (gl.isContextLost()) {
        handleContextLoss();
        throw new Error('webgl context lost')
      }
    });
  }

  function isSupported (glOrCanvas) {
    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);
    var supported = supportByCanvas.get(key);
    if (supported === undefined) {
      isTestingSupport = true;
      var failReason = null;
      try {
        // Since we can't detect all failure modes up front, let's just do a trial run of a
        // simple path and compare what we get back to the correct expected result. This will
        // also serve to prime the shader compilation.
        var expectedResult = [
          97, 106, 97, 61,
          99, 137, 118, 80,
          80, 118, 137, 99,
          61, 97, 106, 97
        ];
        var testResult = generate$1(
          4,
          4,
          'M8,8L16,8L24,24L16,24Z',
          [0, 0, 32, 32],
          24,
          1,
          glOrCanvas
        );
        supported = testResult && expectedResult.length === testResult.length &&
          testResult.every(function (val, i) { return val === expectedResult[i]; });
        if (!supported) {
          failReason = 'bad trial run results';
          console.info(expectedResult, testResult);
        }
      } catch (err) {
        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?
        supported = false;
        failReason = err.message;
      }
      if (failReason) {
        console.warn('WebGL SDF generation not supported:', failReason);
      }
      isTestingSupport = false;
      supportByCanvas.set(key, supported);
    }
    return supported
  }

  var webgl = /*#__PURE__*/Object.freeze({
    __proto__: null,
    generate: generate$1,
    generateIntoCanvas: generateIntoCanvas$1,
    generateIntoFramebuffer: generateIntoFramebuffer,
    isSupported: isSupported
  });

  /**
   * Generate an SDF texture image for a 2D path.
   *
   * @param {number} sdfWidth - width of the SDF output image in pixels.
   * @param {number} sdfHeight - height of the SDF output image in pixels.
   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
   *        to half the maximum viewBox dimension.
   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
   *        will give greater precision nearer the glyph's path.
   * @return {Uint8Array}
   */
  function generate(
    sdfWidth,
    sdfHeight,
    path,
    viewBox,
    maxDistance,
    sdfExponent
  ) {
    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
    if ( sdfExponent === void 0 ) sdfExponent = 1;

    try {
      return generate$1.apply(webgl, arguments)
    } catch(e) {
      console.info('WebGL SDF generation failed, falling back to JS', e);
      return generate$2.apply(javascript, arguments)
    }
  }

  /**
   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position
   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels
   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.
   *
   * @param {number} sdfWidth - width of the SDF output image in pixels.
   * @param {number} sdfHeight - height of the SDF output image in pixels.
   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.
   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.
   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults
   *        to half the maximum viewBox dimension.
   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents
   *        will give greater precision nearer the glyph's path.
   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.
   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results
   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.
   * @param {number} x - the x position at which to render the SDF.
   * @param {number} y - the y position at which to render the SDF.
   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.
   * @return {Uint8Array}
   */
  function generateIntoCanvas(
    sdfWidth,
    sdfHeight,
    path,
    viewBox,
    maxDistance,
    sdfExponent,
    canvas,
    x,
    y,
    channel
  ) {
    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
    if ( sdfExponent === void 0 ) sdfExponent = 1;
    if ( x === void 0 ) x = 0;
    if ( y === void 0 ) y = 0;
    if ( channel === void 0 ) channel = 0;

    try {
      return generateIntoCanvas$1.apply(webgl, arguments)
    } catch(e) {
      console.info('WebGL SDF generation failed, falling back to JS', e);
      return generateIntoCanvas$2.apply(javascript, arguments)
    }
  }

  exports$1.forEachPathCommand = forEachPathCommand;
  exports$1.generate = generate;
  exports$1.generateIntoCanvas = generateIntoCanvas;
  exports$1.javascript = javascript;
  exports$1.pathToLineSegments = pathToLineSegments;
  exports$1.webgl = webgl;
  exports$1.webglUtils = webglUtils;

  Object.defineProperty(exports$1, '__esModule', { value: true });

  return exports$1;

}({}));
return exports$1
}

function bidiFactory() {
var bidi = (function (exports$1) {

  // Bidi character types data, auto generated
  var DATA = {
    "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
    "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
    "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
    "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
    "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
    "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
    "B": "a,3,f+2,2v,690",
    "S": "9,2,k",
    "WS": "c,k,4f4,1vk+a,u,1j,335",
    "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
    "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
    "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
    "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
    "LRO": "6ct",
    "RLO": "6cu",
    "LRE": "6cq",
    "RLE": "6cr",
    "PDF": "6cs",
    "LRI": "6ee",
    "RLI": "6ef",
    "FSI": "6eg",
    "PDI": "6eh"
  };

  var TYPES = {};
  var TYPES_TO_NAMES = {};
  TYPES.L = 1; //L is the default
  TYPES_TO_NAMES[1] = 'L';
  Object.keys(DATA).forEach(function (type, i) {
    TYPES[type] = 1 << (i + 1);
    TYPES_TO_NAMES[TYPES[type]] = type;
  });
  Object.freeze(TYPES);

  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;

  var map = null;

  function parseData () {
    if (!map) {
      //const start = performance.now()
      map = new Map();
      var loop = function ( type ) {
        if (DATA.hasOwnProperty(type)) {
          var lastCode = 0;
          DATA[type].split(',').forEach(function (range) {
            var ref = range.split('+');
            var skip = ref[0];
            var step = ref[1];
            skip = parseInt(skip, 36);
            step = step ? parseInt(step, 36) : 0;
            map.set(lastCode += skip, TYPES[type]);
            for (var i = 0; i < step; i++) {
              map.set(++lastCode, TYPES[type]);
            }
          });
        }
      };

      for (var type in DATA) loop( type );
      //console.log(`char types parsed in ${performance.now() - start}ms`)
    }
  }

  /**
   * @param {string} char
   * @return {number}
   */
  function getBidiCharType (char) {
    parseData();
    return map.get(char.codePointAt(0)) || TYPES.L
  }

  function getBidiCharTypeName(char) {
    return TYPES_TO_NAMES[getBidiCharType(char)]
  }

  // Bidi bracket pairs data, auto generated
  var data$1 = {
    "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
    "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
  };

  /**
   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or
   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object
   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.
   * @param {string} encodedString
   * @param {boolean} includeReverse - true if you want reverseMap in the output
   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}
   */
  function parseCharacterMap (encodedString, includeReverse) {
    var radix = 36;
    var lastCode = 0;
    var map = new Map();
    var reverseMap = includeReverse && new Map();
    var prevPair;
    encodedString.split(',').forEach(function visit(entry) {
      if (entry.indexOf('+') !== -1) {
        for (var i = +entry; i--;) {
          visit(prevPair);
        }
      } else {
        prevPair = entry;
        var ref = entry.split('>');
        var a = ref[0];
        var b = ref[1];
        a = String.fromCodePoint(lastCode += parseInt(a, radix));
        b = String.fromCodePoint(lastCode += parseInt(b, radix));
        map.set(a, b);
        includeReverse && reverseMap.set(b, a);
      }
    });
    return { map: map, reverseMap: reverseMap }
  }

  var openToClose, closeToOpen, canonical;

  function parse$1 () {
    if (!openToClose) {
      //const start = performance.now()
      var ref = parseCharacterMap(data$1.pairs, true);
      var map = ref.map;
      var reverseMap = ref.reverseMap;
      openToClose = map;
      closeToOpen = reverseMap;
      canonical = parseCharacterMap(data$1.canonical, false).map;
      //console.log(`brackets parsed in ${performance.now() - start}ms`)
    }
  }

  function openingToClosingBracket (char) {
    parse$1();
    return openToClose.get(char) || null
  }

  function closingToOpeningBracket (char) {
    parse$1();
    return closeToOpen.get(char) || null
  }

  function getCanonicalBracket (char) {
    parse$1();
    return canonical.get(char) || null
  }

  // Local type aliases
  var TYPE_L = TYPES.L;
  var TYPE_R = TYPES.R;
  var TYPE_EN = TYPES.EN;
  var TYPE_ES = TYPES.ES;
  var TYPE_ET = TYPES.ET;
  var TYPE_AN = TYPES.AN;
  var TYPE_CS = TYPES.CS;
  var TYPE_B = TYPES.B;
  var TYPE_S = TYPES.S;
  var TYPE_ON = TYPES.ON;
  var TYPE_BN = TYPES.BN;
  var TYPE_NSM = TYPES.NSM;
  var TYPE_AL = TYPES.AL;
  var TYPE_LRO = TYPES.LRO;
  var TYPE_RLO = TYPES.RLO;
  var TYPE_LRE = TYPES.LRE;
  var TYPE_RLE = TYPES.RLE;
  var TYPE_PDF = TYPES.PDF;
  var TYPE_LRI = TYPES.LRI;
  var TYPE_RLI = TYPES.RLI;
  var TYPE_FSI = TYPES.FSI;
  var TYPE_PDI = TYPES.PDI;

  /**
   * @typedef {object} GetEmbeddingLevelsResult
   * @property {{start, end, level}[]} paragraphs
   * @property {Uint8Array} levels
   */

  /**
   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels
   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved
   * base embedding level.
   *
   * @param {string} string - The input string
   * @param {"ltr"|"rtl"|"auto"} [baseDirection] - Use "ltr" or "rtl" to force a base paragraph direction,
   *        otherwise a direction will be chosen automatically from each paragraph's contents.
   * @return {GetEmbeddingLevelsResult}
   */
  function getEmbeddingLevels (string, baseDirection) {
    var MAX_DEPTH = 125;

    // Start by mapping all characters to their unicode type, as a bitmask integer
    var charTypes = new Uint32Array(string.length);
    for (var i = 0; i < string.length; i++) {
      charTypes[i] = getBidiCharType(string[i]);
    }

    var charTypeCounts = new Map(); //will be cleared at start of each paragraph
    function changeCharType(i, type) {
      var oldType = charTypes[i];
      charTypes[i] = type;
      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
      if (oldType & NEUTRAL_ISOLATE_TYPES) {
        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
      }
      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);
      if (type & NEUTRAL_ISOLATE_TYPES) {
        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
      }
    }

    var embedLevels = new Uint8Array(string.length);
    var isolationPairs = new Map(); //init->pdi and pdi->init

    // === 3.3.1 The Paragraph Level ===
    // 3.3.1 P1: Split the text into paragraphs
    var paragraphs = []; // [{start, end, level}, ...]
    var paragraph = null;
    for (var i$1 = 0; i$1 < string.length; i$1++) {
      if (!paragraph) {
        paragraphs.push(paragraph = {
          start: i$1,
          end: string.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)
        });
      }
      if (charTypes[i$1] & TYPE_B) {
        paragraph.end = i$1;
        paragraph = null;
      }
    }

    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };
    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };

    // Everything from here on will operate per paragraph.
    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
      paragraph = paragraphs[paraIdx];
      var statusStack = [{
        _level: paragraph.level,
        _override: 0, //0=neutral, 1=L, 2=R
        _isolate: 0 //bool
      }];
      var stackTop = (void 0);
      var overflowIsolateCount = 0;
      var overflowEmbeddingCount = 0;
      var validIsolateCount = 0;
      charTypeCounts.clear();

      // === 3.3.2 Explicit Levels and Directions ===
      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
        var charType = charTypes[i$2];
        stackTop = statusStack[statusStack.length - 1];

        // Set initial counts
        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
        if (charType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }

        // Explicit Embeddings: 3.3.2 X2 - X3
        if (charType & FORMATTING_TYPES) { //prefilter all formatters
          if (charType & (TYPE_RLE | TYPE_LRE)) {
            embedLevels[i$2] = stackTop._level; // 5.2
            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
              statusStack.push({
                _level: level,
                _override: 0,
                _isolate: 0
              });
            } else if (!overflowIsolateCount) {
              overflowEmbeddingCount++;
            }
          }

          // Explicit Overrides: 3.3.2 X4 - X5
          else if (charType & (TYPE_RLO | TYPE_LRO)) {
            embedLevels[i$2] = stackTop._level; // 5.2
            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
              statusStack.push({
                _level: level$1,
                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,
                _isolate: 0
              });
            } else if (!overflowIsolateCount) {
              overflowEmbeddingCount++;
            }
          }

          // Isolates: 3.3.2 X5a - X5c
          else if (charType & ISOLATE_INIT_TYPES) {
            // X5c - FSI becomes either RLI or LRI
            if (charType & TYPE_FSI) {
              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
            }

            embedLevels[i$2] = stackTop._level;
            if (stackTop._override) {
              changeCharType(i$2, stackTop._override);
            }
            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
              validIsolateCount++;
              statusStack.push({
                _level: level$2,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: i$2
              });
            } else {
              overflowIsolateCount++;
            }
          }

          // Terminating Isolates: 3.3.2 X6a
          else if (charType & TYPE_PDI) {
            if (overflowIsolateCount > 0) {
              overflowIsolateCount--;
            } else if (validIsolateCount > 0) {
              overflowEmbeddingCount = 0;
              while (!statusStack[statusStack.length - 1]._isolate) {
                statusStack.pop();
              }
              // Add to isolation pairs bidirectional mapping:
              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
              if (isolInitIndex != null) {
                isolationPairs.set(isolInitIndex, i$2);
                isolationPairs.set(i$2, isolInitIndex);
              }
              statusStack.pop();
              validIsolateCount--;
            }
            stackTop = statusStack[statusStack.length - 1];
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override) {
              changeCharType(i$2, stackTop._override);
            }
          }


          // Terminating Embeddings and Overrides: 3.3.2 X7
          else if (charType & TYPE_PDF) {
            if (overflowIsolateCount === 0) {
              if (overflowEmbeddingCount > 0) {
                overflowEmbeddingCount--;
              } else if (!stackTop._isolate && statusStack.length > 1) {
                statusStack.pop();
                stackTop = statusStack[statusStack.length - 1];
              }
            }
            embedLevels[i$2] = stackTop._level; // 5.2
          }

          // End of Paragraph: 3.3.2 X8
          else if (charType & TYPE_B) {
            embedLevels[i$2] = paragraph.level;
          }
        }

        // Non-formatting characters: 3.3.2 X6
        else {
          embedLevels[i$2] = stackTop._level;
          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage
          if (stackTop._override && charType !== TYPE_BN) {
            changeCharType(i$2, stackTop._override);
          }
        }
      }

      // === 3.3.3 Preparations for Implicit Processing ===

      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9
      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to
      // easily ignore them all from here on out.

      // 3.3.3 X10
      // Compute the set of isolating run sequences as specified by BD13
      var levelRuns = [];
      var currentRun = null;
      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
        var charType$1 = charTypes[i$3];
        if (!(charType$1 & BN_LIKE_TYPES)) {
          var lvl = embedLevels[i$3];
          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
          var isPDI = charType$1 === TYPE_PDI;
          if (currentRun && lvl === currentRun._level) {
            currentRun._end = i$3;
            currentRun._endsWithIsolInit = isIsolInit;
          } else {
            levelRuns.push(currentRun = {
              _start: i$3,
              _end: i$3,
              _level: lvl,
              _startsWithPDI: isPDI,
              _endsWithIsolInit: isIsolInit
            });
          }
        }
      }
      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]
      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
        var run = levelRuns[runIdx];
        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {
          var seqRuns = [currentRun = run];
          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {
            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
              if (levelRuns[i$4]._start === pdiIndex) {
                seqRuns.push(currentRun = levelRuns[i$4]);
                break
              }
            }
          }
          // build flat list of indices across all runs:
          var seqIndices = [];
          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
            var run$1 = seqRuns[i$5];
            for (var j = run$1._start; j <= run$1._end; j++) {
              seqIndices.push(j);
            }
          }
          // determine the sos/eos types:
          var firstLevel = embedLevels[seqIndices[0]];
          var prevLevel = paragraph.level;
          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2
              prevLevel = embedLevels[i$6];
              break
            }
          }
          var lastIndex = seqIndices[seqIndices.length - 1];
          var lastLevel = embedLevels[lastIndex];
          var nextLevel = paragraph.level;
          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2
                nextLevel = embedLevels[i$7];
                break
              }
            }
          }
          isolatingRunSeqs.push({
            _seqIndices: seqIndices,
            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
          });
        }
      }

      // The next steps are done per isolating run sequence
      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
        var ref = isolatingRunSeqs[seqIdx];
        var seqIndices$1 = ref._seqIndices;
        var sosType = ref._sosType;
        var eosType = ref._eosType;
        /**
         * All the level runs in an isolating run sequence have the same embedding level.
         * 
         * DO NOT change any `embedLevels[i]` within the current scope.
         */
        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;

        // === 3.3.4 Resolving Weak Types ===

        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose
        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its
        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.
        if (charTypeCounts.get(TYPE_NSM)) {
          for (var si = 0; si < seqIndices$1.length; si++) {
            var i$8 = seqIndices$1[si];
            if (charTypes[i$8] & TYPE_NSM) {
              var prevType = sosType;
              for (var sj = si - 1; sj >= 0; sj--) {
                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN
                  prevType = charTypes[seqIndices$1[sj]];
                  break
                }
              }
              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);
            }
          }
        }

        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)
        // is found. If an AL is found, change the type of the European number to Arabic number.
        if (charTypeCounts.get(TYPE_EN)) {
          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
            var i$9 = seqIndices$1[si$1];
            if (charTypes[i$9] & TYPE_EN) {
              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                if (prevCharType & STRONG_TYPES) {
                  if (prevCharType === TYPE_AL) {
                    changeCharType(i$9, TYPE_AN);
                  }
                  break
                }
              }
            }
          }
        }

        // W3. Change all ALs to R
        if (charTypeCounts.get(TYPE_AL)) {
          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
            var i$10 = seqIndices$1[si$2];
            if (charTypes[i$10] & TYPE_AL) {
              changeCharType(i$10, TYPE_R);
            }
          }
        }

        // W4. A single European separator between two European numbers changes to a European number. A single common
        // separator between two numbers of the same type changes to that type.
        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
            var i$11 = seqIndices$1[si$3];
            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
              var prevType$1 = 0, nextType = 0;
              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                prevType$1 = charTypes[seqIndices$1[sj$2]];
                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2
                  break
                }
              }
              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                nextType = charTypes[seqIndices$1[sj$3]];
                if (!(nextType & BN_LIKE_TYPES)) { //5.2
                  break
                }
              }
              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {
                changeCharType(i$11, prevType$1);
              }
            }
          }
        }

        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.
        if (charTypeCounts.get(TYPE_EN)) {
          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
            var i$12 = seqIndices$1[si$4];
            if (charTypes[i$12] & TYPE_EN) {
              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {
                changeCharType(seqIndices$1[sj$4], TYPE_EN);
              }
              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {
                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                  changeCharType(seqIndices$1[si$4], TYPE_EN);
                }
              }
            }
          }
        }

        // W6. Otherwise, separators and terminators change to Other Neutral.
        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
            var i$13 = seqIndices$1[si$5];
            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
              changeCharType(i$13, TYPE_ON);
              // 5.2 transform adjacent BNs too:
              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {
                changeCharType(seqIndices$1[sj$5], TYPE_ON);
              }
              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {
                changeCharType(seqIndices$1[sj$6], TYPE_ON);
              }
            }
          }
        }

        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)
        // is found. If an L is found, then change the type of the European number to L.
        // NOTE: implemented in single forward pass for efficiency
        if (charTypeCounts.get(TYPE_EN)) {
          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
            var i$14 = seqIndices$1[si$6];
            var type = charTypes[i$14];
            if (type & TYPE_EN) {
              if (prevStrongType === TYPE_L) {
                changeCharType(i$14, TYPE_L);
              }
            } else if (type & STRONG_TYPES) {
              prevStrongType = type;
            }
          }
        }

        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===

        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text
          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional
          // types EN and AN are treated as R.
          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);
          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;

          // * Identify the bracket pairs in the current isolating run sequence according to BD16.
          var bracketPairs = [];
          {
            var openerStack = [];
            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
              // NOTE: for any potential bracket character we also test that it still carries a NI
              // type, as that may have been changed earlier. This doesn't seem to be explicitly
              // called out in the spec, but is required for passage of certain tests.
              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                var char = string[seqIndices$1[si$7]];
                var oppositeBracket = (void 0);
                // Opening bracket
                if (openingToClosingBracket(char) !== null) {
                  if (openerStack.length < 63) {
                    openerStack.push({ char: char, seqIndex: si$7 });
                  } else {
                    break
                  }
                }
                // Closing bracket
                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                    var stackChar = openerStack[stackIdx].char;
                    if (stackChar === oppositeBracket ||
                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||
                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char
                    ) {
                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                      openerStack.length = stackIdx; //pop the matching bracket and all following
                      break
                    }
                  }
                }
              }
            }
            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });
          }
          // * For each bracket-pair element in the list of pairs of text positions
          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
            var ref$1 = bracketPairs[pairIdx];
            var openSeqIdx = ref$1[0];
            var closeSeqIdx = ref$1[1];
            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.
            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both
            // brackets in the pair to match the embedding direction.
            var foundStrongType = false;
            var useStrongType = 0;
            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
              var i$15 = seqIndices$1[si$8];
              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                foundStrongType = true;
                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
                if (lr === embedDirection) {
                  useStrongType = lr;
                  break
                }
              }
            }
            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test
            // for an established context with a preceding strong type by checking backwards before the opening paired
            // bracket until the first strong type (L, R, or sos) is found.
            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so
            //    set the type for both brackets in the pair to that direction.
            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.
            if (foundStrongType && !useStrongType) {
              useStrongType = sosType;
              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                var i$16 = seqIndices$1[si$9];
                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
                  if (lr$1 !== embedDirection) {
                    useStrongType = lr$1;
                  } else {
                    useStrongType = embedDirection;
                  }
                  break
                }
              }
            }
            if (useStrongType) {
              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
              // * Any number of characters that had original bidirectional character type NSM prior to the application
              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match
              // the type of their preceding bracket.
              if (useStrongType !== embedDirection) {
                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                      charTypes[seqIndices$1[si$10]] = useStrongType;
                    }
                    break
                  }
                }
              }
              if (useStrongType !== embedDirection) {
                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                      charTypes[seqIndices$1[si$11]] = useStrongType;
                    }
                    break
                  }
                }
              }
            }
          }

          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the
          // same direction.
          // N2. Any remaining NIs take the embedding direction.
          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
              var niRunStart = si$12, niRunEnd = si$12;
              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L
              for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs
                } else {
                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
                  break
                }
              }
              var nextType$1 = eosType;
              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                  niRunEnd = si2$1;
                } else {
                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;
                  break
                }
              }
              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
              }
              si$12 = niRunEnd;
            }
          }
        }
      }

      // === 3.3.6 Resolving Implicit Levels ===

      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
        var level$3 = embedLevels[i$17];
        var type$1 = charTypes[i$17];
        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.
        if (level$3 & 1) {
          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
            embedLevels[i$17]++;
          }
        }
          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level
        // and those of type AN or EN go up two levels.
        else {
          if (type$1 & TYPE_R) {
            embedLevels[i$17]++;
          } else if (type$1 & (TYPE_AN | TYPE_EN)) {
            embedLevels[i$17] += 2;
          }
        }

        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,
        // and otherwise to the base level.
        if (type$1 & BN_LIKE_TYPES) {
          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
        }

        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or
        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.
        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.
        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {
            embedLevels[j$1] = paragraph.level;
          }
        }
      }
    }

    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters
    // according to section 3.4 Reordering Resolved Levels
    return {
      levels: embedLevels,
      paragraphs: paragraphs
    }

    function determineAutoEmbedLevel (start, isFSI) {
      // 3.3.1 P2 - P3
      for (var i = start; i < string.length; i++) {
        var charType = charTypes[i];
        if (charType & (TYPE_R | TYPE_AL)) {
          return 1
        }
        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {
          return 0
        }
        if (charType & ISOLATE_INIT_TYPES) {
          var pdi = indexOfMatchingPDI(i);
          i = pdi === -1 ? string.length : pdi;
        }
      }
      return 0
    }

    function indexOfMatchingPDI (isolateStart) {
      // 3.1.2 BD9
      var isolationLevel = 1;
      for (var i = isolateStart + 1; i < string.length; i++) {
        var charType = charTypes[i];
        if (charType & TYPE_B) {
          break
        }
        if (charType & TYPE_PDI) {
          if (--isolationLevel === 0) {
            return i
          }
        } else if (charType & ISOLATE_INIT_TYPES) {
          isolationLevel++;
        }
      }
      return -1
    }
  }

  // Bidi mirrored chars data, auto generated
  var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";

  var mirrorMap;

  function parse () {
    if (!mirrorMap) {
      //const start = performance.now()
      var ref = parseCharacterMap(data, true);
      var map = ref.map;
      var reverseMap = ref.reverseMap;
      // Combine both maps into one
      reverseMap.forEach(function (value, key) {
        map.set(key, value);
      });
      mirrorMap = map;
      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)
    }
  }

  function getMirroredCharacter (char) {
    parse();
    return mirrorMap.get(char) || null
  }

  /**
   * Given a string and its resolved embedding levels, build a map of indices to replacement chars
   * for any characters in right-to-left segments that have defined mirrored characters.
   * @param string
   * @param embeddingLevels
   * @param [start]
   * @param [end]
   * @return {Map<number, string>}
   */
  function getMirroredCharactersMap(string, embeddingLevels, start, end) {
    var strLen = string.length;
    start = Math.max(0, start == null ? 0 : +start);
    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

    var map = new Map();
    for (var i = start; i <= end; i++) {
      if (embeddingLevels[i] & 1) { //only odd (rtl) levels
        var mirror = getMirroredCharacter(string[i]);
        if (mirror !== null) {
          map.set(i, mirror);
        }
      }
    }
    return map
  }

  /**
   * Given a start and end denoting a single line within a string, and a set of precalculated
   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.
   * @param {string} string - the full input string
   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels
   * @param {number} [start] - first character in a subset of the full string
   * @param {number} [end] - last character in a subset of the full string
   * @return {number[][]} - the list of start/end segments that should be flipped, in order.
   */
  function getReorderSegments(string, embeddingLevelsResult, start, end) {
    var strLen = string.length;
    start = Math.max(0, start == null ? 0 : +start);
    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);

    var segments = [];
    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {
      var lineStart = Math.max(start, paragraph.start);
      var lineEnd = Math.min(end, paragraph.end);
      if (lineStart < lineEnd) {
        // Local slice for mutation
        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);

        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the
        // end of the line to the paragraph level.
        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {
          lineLevels[i] = paragraph.level;
        }

        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels
        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.
        var maxLevel = paragraph.level;
        var minOddLevel = Infinity;
        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
          var level = lineLevels[i$1];
          if (level > maxLevel) { maxLevel = level; }
          if (level < minOddLevel) { minOddLevel = level | 1; }
        }
        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
            if (lineLevels[i$2] >= lvl) {
              var segStart = i$2;
              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                i$2++;
              }
              if (i$2 > segStart) {
                segments.push([segStart + lineStart, i$2 + lineStart]);
              }
            }
          }
        }
      }
    });
    return segments
  }

  /**
   * @param {string} string
   * @param {GetEmbeddingLevelsResult} embedLevelsResult
   * @param {number} [start]
   * @param {number} [end]
   * @return {string} the new string with bidi segments reordered
   */
  function getReorderedString(string, embedLevelsResult, start, end) {
    var indices = getReorderedIndices(string, embedLevelsResult, start, end);
    var chars = [].concat( string );
    indices.forEach(function (charIndex, i) {
      chars[i] = (
        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null
      ) || string[charIndex];
    });
    return chars.join('')
  }

  /**
   * @param {string} string
   * @param {GetEmbeddingLevelsResult} embedLevelsResult
   * @param {number} [start]
   * @param {number} [end]
   * @return {number[]} an array with character indices in their new bidi order
   */
  function getReorderedIndices(string, embedLevelsResult, start, end) {
    var segments = getReorderSegments(string, embedLevelsResult, start, end);
    // Fill an array with indices
    var indices = [];
    for (var i = 0; i < string.length; i++) {
      indices[i] = i;
    }
    // Reverse each segment in order
    segments.forEach(function (ref) {
      var start = ref[0];
      var end = ref[1];

      var slice = indices.slice(start, end + 1);
      for (var i = slice.length; i--;) {
        indices[end - i] = slice[i];
      }
    });
    return indices
  }

  exports$1.closingToOpeningBracket = closingToOpeningBracket;
  exports$1.getBidiCharType = getBidiCharType;
  exports$1.getBidiCharTypeName = getBidiCharTypeName;
  exports$1.getCanonicalBracket = getCanonicalBracket;
  exports$1.getEmbeddingLevels = getEmbeddingLevels;
  exports$1.getMirroredCharacter = getMirroredCharacter;
  exports$1.getMirroredCharactersMap = getMirroredCharactersMap;
  exports$1.getReorderSegments = getReorderSegments;
  exports$1.getReorderedIndices = getReorderedIndices;
  exports$1.getReorderedString = getReorderedString;
  exports$1.openingToClosingBracket = openingToClosingBracket;

  Object.defineProperty(exports$1, '__esModule', { value: true });

  return exports$1;

}({}));
return bidi}

const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
const assign$1 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
const epoch = Date.now();
const CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
const SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
let materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign$1(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived = Object.create(base, descriptor);
    Object.defineProperty(derived, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived, "id", { value: materialInstanceId++ });
    derived.uuid = generateUUID();
    derived.uniforms = assign$1({}, base.uniforms, options.uniforms);
    derived.defines = assign$1({}, base.defines, options.defines);
    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived.extensions = assign$1({}, base.extensions, options.extensions);
    derived._listeners = void 0;
    return derived;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    type: {
      get: () => baseMaterial.type,
      set: (value) => {
        baseMaterial.type = value;
      }
    },
    isDerivedFrom: {
      writable: true,
      configurable: true,
      value: function(testMaterial) {
        const base = this.baseMaterial;
        return testMaterial === base || base.isDerivedMaterial && base.isDerivedFrom(testMaterial) || false;
      }
    },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign$1(this.extensions, source.extensions);
          assign$1(this.defines, source.defines);
          assign$1(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial) _depthMaterial.dispose();
        if (_distanceMaterial) _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material, { vertexShader, fragmentShader }, options, key) {
  let {
    vertexDefs: vertexDefs2,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform: vertexTransform2,
    fragmentDefs: fragmentDefs2,
    fragmentMainIntro: fragmentMainIntro2,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs2 = vertexDefs2 || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs2 = fragmentDefs2 || "";
  fragmentMainIntro2 = fragmentMainIntro2 || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform2 || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader = fragmentShader.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader = expandShaderIncludes(fragmentShader);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader, fragmentShader });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs2 = code + vertexDefs2;
    fragmentDefs2 = code + fragmentDefs2;
  }
  if (vertexTransform2) {
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs2 = `${vertexDefs2}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform2}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
    if (!(material.map && material.map.channel > 0)) {
      vertexShader = vertexShader.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
    }
  }
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs2, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs2, fragmentMainIntro2, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
let _idCtr = 0;
const optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}

/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t2 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t2.readASCII(a2, 0, 4)) {
        var n = 4;
        t2.readUshort(a2, n), n += 2, t2.readUshort(a2, n), n += 2;
        var o = t2.readUint(a2, n);
        n += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t2.readUint(a2, n);
          n += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t2) {
      var a2 = e._bin, n = t2;
      a2.readFixed(r2, t2), t2 += 4;
      var o = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n }, h = {}, d = 0; d < o; d++) {
        var f = a2.readASCII(r2, t2, 4);
        t2 += 4, a2.readUint(r2, t2), t2 += 4;
        var u = a2.readUint(r2, t2);
        t2 += 4;
        var l = a2.readUint(r2, t2);
        t2 += 4, h[f] = { offset: u, length: l };
      }
      for (d = 0; d < s.length; d++) {
        var v = s[d];
        h[v] && (i[v.trim()] = e[v.trim()].parse(r2, h[v].offset, h[v].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t2, a2) {
      for (var n = e._bin, o = n.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n.readASCII(r2, s, 4);
        s += 4, n.readUint(r2, s), s += 4;
        var d = n.readUint(r2, s);
        if (s += 4, n.readUint(r2, s), s += 4, h == t2) return d;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t2) {
      return e._bin.readShort(r2, t2) / 16384;
    }, readInt: function(r2, t2) {
      return e._bin._view(r2).getInt32(t2);
    }, readInt8: function(r2, t2) {
      return e._bin._view(r2).getInt8(t2);
    }, readShort: function(r2, t2) {
      return e._bin._view(r2).getInt16(t2);
    }, readUshort: function(r2, t2) {
      return e._bin._view(r2).getUint16(t2);
    }, readUshorts: function(r2, t2, a2) {
      for (var n = [], o = 0; o < a2; o++) n.push(e._bin.readUshort(r2, t2 + 2 * o));
      return n;
    }, readUint: function(r2, t2) {
      return e._bin._view(r2).getUint32(t2);
    }, readUint64: function(r2, t2) {
      return 4294967296 * e._bin.readUint(r2, t2) + e._bin.readUint(r2, t2 + 4);
    }, readASCII: function(r2, e2, t2) {
      for (var a2 = "", n = 0; n < t2; n++) a2 += String.fromCharCode(r2[e2 + n]);
      return a2;
    }, readUnicode: function(r2, e2, t2) {
      for (var a2 = "", n = 0; n < t2; n++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t2, a2) {
      var n = e._bin._tdec;
      return n && 0 == t2 && a2 == r2.length ? n.decode(r2) : e._bin.readASCII(r2, t2, a2);
    }, readBytes: function(r2, e2, t2) {
      for (var a2 = [], n = 0; n < t2; n++) a2.push(r2[e2 + n]);
      return a2;
    }, readASCIIArray: function(r2, e2, t2) {
      for (var a2 = [], n = 0; n < t2; n++) a2.push(String.fromCharCode(r2[e2 + n]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t2, a2, n, o) {
      var s = e._bin, i = {}, h = t2;
      s.readFixed(r2, t2), t2 += 4;
      var d = s.readUshort(r2, t2);
      t2 += 2;
      var f = s.readUshort(r2, t2);
      t2 += 2;
      var u = s.readUshort(r2, t2);
      return t2 += 2, i.scriptList = e._lctf.readScriptList(r2, h + d), i.featureList = e._lctf.readFeatureList(r2, h + f), i.lookupList = e._lctf.readLookupList(r2, h + u, o), i;
    }, e._lctf.readLookupList = function(r2, t2, a2) {
      var n = e._bin, o = t2, s = [], i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = e._lctf.readLookupTable(r2, o + d, a2);
        s.push(f);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t2, a2) {
      var n = e._bin, o = t2, s = { tabs: [] };
      s.ltype = n.readUshort(r2, t2), t2 += 2, s.flag = n.readUshort(r2, t2), t2 += 2;
      var i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = s.ltype, d = 0; d < i; d++) {
        var f = n.readUshort(r2, t2);
        t2 += 2;
        var u = a2(r2, h, o + f, s);
        s.tabs.push(u);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t2 = 0; t2 < 32; t2++) 0 != (r2 >>> t2 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t2) {
      var a2 = e._bin, n = [], o = a2.readUshort(r2, t2);
      if (t2 += 2, 1 == o) {
        var s = a2.readUshort(r2, t2);
        t2 += 2;
        var i = a2.readUshort(r2, t2);
        t2 += 2;
        for (var h = 0; h < i; h++) n.push(s + h), n.push(s + h), n.push(a2.readUshort(r2, t2)), t2 += 2;
      }
      if (2 == o) {
        var d = a2.readUshort(r2, t2);
        t2 += 2;
        for (h = 0; h < d; h++) n.push(a2.readUshort(r2, t2)), t2 += 2, n.push(a2.readUshort(r2, t2)), t2 += 2, n.push(a2.readUshort(r2, t2)), t2 += 2;
      }
      return n;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t2 = 0; t2 < r2.length; t2 += 3) {
        var a2 = r2[t2], n = r2[t2 + 1];
        if (a2 <= e2 && e2 <= n) return t2;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.fmt = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      return t2 += 2, 1 == n.fmt && (n.tab = a2.readUshorts(r2, t2, o)), 2 == n.fmt && (n.tab = a2.readUshorts(r2, t2, 3 * o)), n;
    }, e._lctf.coverageIndex = function(r2, t2) {
      var a2 = r2.tab;
      if (1 == r2.fmt) return a2.indexOf(t2);
      if (2 == r2.fmt) {
        var n = e._lctf.getInterval(a2, t2);
        if (-1 != n) return a2[n + 2] + (t2 - a2[n]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var d = a2.readUshort(r2, t2);
        t2 += 2;
        var f = e._lctf.readFeatureTable(r2, n + d);
        f.tag = h.trim(), o.push(f);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2, s > 0 && (o.featureParams = n + s);
      var i = a2.readUshort(r2, t2);
      t2 += 2, o.tab = [];
      for (var h = 0; h < i; h++) o.tab.push(a2.readUshort(r2, t2 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var d = a2.readUshort(r2, t2);
        t2 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n + d);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {}, s = a2.readUshort(r2, t2);
      t2 += 2, s > 0 && (o.default = e._lctf.readLangSysTable(r2, n + s));
      var i = a2.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        var d = a2.readASCII(r2, t2, 4);
        t2 += 4;
        var f = a2.readUshort(r2, t2);
        t2 += 2, o[d.trim()] = e._lctf.readLangSysTable(r2, n + f);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t2) {
      var a2 = e._bin, n = {};
      a2.readUshort(r2, t2), t2 += 2, n.reqFeature = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      return t2 += 2, n.features = a2.readUshorts(r2, t2, o), n;
    }, e.CFF = {}, e.CFF.parse = function(r2, t2, a2) {
      var n = e._bin;
      (r2 = new Uint8Array(r2.buffer, t2, a2))[t2 = 0], r2[++t2], r2[++t2], r2[++t2], t2++;
      var o = [];
      t2 = e.CFF.readIndex(r2, t2, o);
      for (var s = [], i = 0; i < o.length - 1; i++) s.push(n.readASCII(r2, t2 + o[i], o[i + 1] - o[i]));
      t2 += o[o.length - 1];
      var h = [];
      t2 = e.CFF.readIndex(r2, t2, h);
      var d = [];
      for (i = 0; i < h.length - 1; i++) d.push(e.CFF.readDict(r2, t2 + h[i], t2 + h[i + 1]));
      t2 += h[h.length - 1];
      var f = d[0], u = [];
      t2 = e.CFF.readIndex(r2, t2, u);
      var l = [];
      for (i = 0; i < u.length - 1; i++) l.push(n.readASCII(r2, t2 + u[i], u[i + 1] - u[i]));
      if (t2 += u[u.length - 1], e.CFF.readSubrs(r2, t2, f), f.CharStrings) {
        t2 = f.CharStrings;
        u = [];
        t2 = e.CFF.readIndex(r2, t2, u);
        var v = [];
        for (i = 0; i < u.length - 1; i++) v.push(n.readBytes(r2, t2 + u[i], u[i + 1] - u[i]));
        f.CharStrings = v;
      }
      if (f.ROS) {
        t2 = f.FDArray;
        var c = [];
        t2 = e.CFF.readIndex(r2, t2, c), f.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p = e.CFF.readDict(r2, t2 + c[i], t2 + c[i + 1]);
          e.CFF._readFDict(r2, p, l), f.FDArray.push(p);
        }
        t2 += c[c.length - 1], t2 = f.FDSelect, f.FDSelect = [];
        var U = r2[t2];
        if (t2++, 3 != U) throw U;
        var g = n.readUshort(r2, t2);
        t2 += 2;
        for (i = 0; i < g + 1; i++) f.FDSelect.push(n.readUshort(r2, t2), r2[t2 + 2]), t2 += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(r2, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(r2, f.charset, f.CharStrings.length)), e.CFF._readFDict(r2, f, l), f;
    }, e.CFF._readFDict = function(r2, t2, a2) {
      var n;
      for (var o in t2.Private && (n = t2.Private[1], t2.Private = e.CFF.readDict(r2, n, n + t2.Private[0]), t2.Private.Subrs && e.CFF.readSubrs(r2, n + t2.Private.Subrs, t2.Private)), t2) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t2[o] = a2[t2[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t2, a2) {
      var n = e._bin, o = [];
      t2 = e.CFF.readIndex(r2, t2, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++) a2.Subrs.push(n.readBytes(r2, t2 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t2 = 0; t2 < r2.charset.length; t2++) if (r2.charset[t2] == e2) return t2;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t2) {
      return t2 < 0 || t2 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t2]);
    }, e.CFF.readEncoding = function(r2, t2, a2) {
      var n = [".notdef"], o = r2[t2];
      if (t2++, 0 != o) throw "error: unknown encoding format: " + o;
      var s = r2[t2];
      t2++;
      for (var i = 0; i < s; i++) n.push(r2[t2 + i]);
      return n;
    }, e.CFF.readCharset = function(r2, t2, a2) {
      var n = e._bin, o = [".notdef"], s = r2[t2];
      if (t2++, 0 == s) for (var i = 0; i < a2; i++) {
        var h = n.readUshort(r2, t2);
        t2 += 2, o.push(h);
      }
      else {
        if (1 != s && 2 != s) throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n.readUshort(r2, t2);
          t2 += 2;
          var d = 0;
          1 == s ? (d = r2[t2], t2++) : (d = n.readUshort(r2, t2), t2 += 2);
          for (i = 0; i <= d; i++) o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t2, a2) {
      var n = e._bin, o = n.readUshort(r2, t2) + 1, s = r2[t2 += 2];
      if (t2++, 1 == s) for (var i = 0; i < o; i++) a2.push(r2[t2 + i]);
      else if (2 == s) for (i = 0; i < o; i++) a2.push(n.readUshort(r2, t2 + 2 * i));
      else if (3 == s) for (i = 0; i < o; i++) a2.push(16777215 & n.readUint(r2, t2 + 3 * i - 1));
      else if (1 != o) throw "unsupported offset size: " + s + ", count: " + o;
      return (t2 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t2, a2) {
      var n = e._bin, o = r2[t2], s = r2[t2 + 1];
      var i = 1, h = null, d = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (d = n.readShort(r2, t2 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (d = o - 139, i = 1), 247 <= o && o <= 250 && (d = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (d = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (d = n.readInt(r2, t2 + 1) / 65535, i = 5), a2.val = null != d ? d : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t2, a2) {
      for (var n = t2 + a2, o = e._bin, s = []; t2 < n; ) {
        var i = r2[t2], h = r2[t2 + 1];
        var d = 1, f = null, u = null;
        i <= 20 && (f = i, d = 1), 12 == i && (f = 100 * i + h, d = 2), 19 != i && 20 != i || (f = i, d = 2), 21 <= i && i <= 27 && (f = i, d = 1), 28 == i && (u = o.readShort(r2, t2 + 1), d = 3), 29 <= i && i <= 31 && (f = i, d = 1), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i && (u = o.readInt(r2, t2 + 1) / 65535, d = 5), s.push(null != u ? u : "o" + f), t2 += d;
      }
      return s;
    }, e.CFF.readDict = function(r2, t2, a2) {
      for (var n = e._bin, o = {}, s = []; t2 < a2; ) {
        var i = r2[t2], h = r2[t2 + 1];
        var d = 1, f = null, u = null;
        if (28 == i && (u = n.readShort(r2, t2 + 1), d = 3), 29 == i && (u = n.readInt(r2, t2 + 1), d = 5), 32 <= i && i <= 246 && (u = i - 139, d = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, d = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, d = 2), 255 == i) throw u = n.readInt(r2, t2 + 1) / 65535, d = 5, "unknown number";
        if (30 == i) {
          var l = [];
          for (d = 1; ; ) {
            var v = r2[t2 + d];
            d++;
            var c = v >> 4, p = 15 & v;
            if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;
          }
          for (var U = "", g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++) U += g[l[S]];
          u = parseFloat(U);
        }
        if (i <= 21) {
          if (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], d = 1, 12 == i) f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], d = 2;
        }
        null != f ? (o[f] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t2 += d;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t2, a2) {
      r2 = new Uint8Array(r2.buffer, t2, a2), t2 = 0;
      var n = e._bin, o = {};
      n.readUshort(r2, t2), t2 += 2;
      var s = n.readUshort(r2, t2);
      t2 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = n.readUshort(r2, t2);
        t2 += 2;
        var u = n.readUint(r2, t2);
        t2 += 4;
        var l = "p" + d + "e" + f, v = i.indexOf(u);
        if (-1 == v) {
          var c;
          v = o.tables.length, i.push(u);
          var p = n.readUshort(r2, u);
          0 == p ? c = e.cmap.parse0(r2, u) : 4 == p ? c = e.cmap.parse4(r2, u) : 6 == p ? c = e.cmap.parse6(r2, u) : 12 == p ? c = e.cmap.parse12(r2, u) : console.debug("unknown format: " + p, d, f, u), o.tables.push(c);
        }
        if (null != o[l]) throw "multiple tables for one platform+encoding";
        o[l] = v;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2, n.map = [];
      for (var s = 0; s < o - 6; s++) n.map.push(r2[t2 + s]);
      return n;
    }, e.cmap.parse4 = function(r2, t2) {
      var a2 = e._bin, n = t2, o = {};
      o.format = a2.readUshort(r2, t2), t2 += 2;
      var s = a2.readUshort(r2, t2);
      t2 += 2, a2.readUshort(r2, t2), t2 += 2;
      var i = a2.readUshort(r2, t2);
      t2 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t2), t2 += 2, o.entrySelector = a2.readUshort(r2, t2), t2 += 2, o.rangeShift = a2.readUshort(r2, t2), t2 += 2, o.endCount = a2.readUshorts(r2, t2, h), t2 += 2 * h, t2 += 2, o.startCount = a2.readUshorts(r2, t2, h), t2 += 2 * h, o.idDelta = [];
      for (var d = 0; d < h; d++) o.idDelta.push(a2.readShort(r2, t2)), t2 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t2, h), t2 += 2 * h, o.glyphIdArray = []; t2 < n + s; ) o.glyphIdArray.push(a2.readUshort(r2, t2)), t2 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, a2.readUshort(r2, t2), t2 += 2, n.firstCode = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2, n.glyphIdArray = [];
      for (var s = 0; s < o; s++) n.glyphIdArray.push(a2.readUshort(r2, t2)), t2 += 2;
      return n;
    }, e.cmap.parse12 = function(r2, t2) {
      var a2 = e._bin, n = {};
      n.format = a2.readUshort(r2, t2), t2 += 2, t2 += 2, a2.readUint(r2, t2), t2 += 4, a2.readUint(r2, t2), t2 += 4;
      var o = a2.readUint(r2, t2);
      t2 += 4, n.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t2 + 12 * s, h = a2.readUint(r2, i + 0), d = a2.readUint(r2, i + 4), f = a2.readUint(r2, i + 8);
        n.groups.push([h, d, f]);
      }
      return n;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t2, a2) {
      for (var n = [], o = 0; o < a2.maxp.numGlyphs; o++) n.push(null);
      return n;
    }, e.glyf._parseGlyf = function(r2, t2) {
      var a2 = e._bin, n = r2._data, o = e._tabOffset(n, "glyf", r2._offset) + r2.loca[t2];
      if (r2.loca[t2] == r2.loca[t2 + 1]) return null;
      var s = {};
      if (s.noc = a2.readShort(n, o), o += 2, s.xMin = a2.readShort(n, o), o += 2, s.yMin = a2.readShort(n, o), o += 2, s.xMax = a2.readShort(n, o), o += 2, s.yMax = a2.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++) s.endPts.push(a2.readUshort(n, o)), o += 2;
        var h = a2.readUshort(n, o);
        if (o += 2, n.length - o < h) return null;
        s.instructions = a2.readBytes(n, o, h), o += h;
        var d = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < d; i++) {
          var f = n[o];
          if (o++, s.flags.push(f), 0 != (8 & f)) {
            var u = n[o];
            o++;
            for (var l = 0; l < u; l++) s.flags.push(f), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < d; i++) {
          var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v ? (s.xs.push(c ? n[o] : -n[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < d; i++) {
          v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v ? (s.ys.push(c ? n[o] : -n[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n, o)), o += 2);
        }
        var p = 0, U = 0;
        for (i = 0; i < d; i++) p += s.xs[i], U += s.ys[i], s.xs[i] = p, s.ys[i] = U;
      } else {
        var g;
        s.parts = [];
        do {
          g = a2.readUshort(n, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n, o), o += 2, 1 & g) {
            var m = a2.readShort(n, o);
            o += 2;
            var b = a2.readShort(n, o);
            o += 2;
          } else {
            m = a2.readInt8(n, o);
            o++;
            b = a2.readInt8(n, o);
            o++;
          }
          2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a2.readF2dot14(n, o), o += 2) : 64 & g ? (S.m.a = a2.readF2dot14(n, o), o += 2, S.m.d = a2.readF2dot14(n, o), o += 2) : 128 & g && (S.m.a = a2.readF2dot14(n, o), o += 2, S.m.b = a2.readF2dot14(n, o), o += 2, S.m.c = a2.readF2dot14(n, o), o += 2, S.m.d = a2.readF2dot14(n, o), o += 2);
        } while (32 & g);
        if (256 & g) {
          var y = a2.readUshort(n, o);
          o += 2, s.instr = [];
          for (i = 0; i < y; i++) s.instr.push(n[o]), o++;
        }
      }
      return s;
    }, e.GDEF = {}, e.GDEF.parse = function(r2, t2, a2, n) {
      var o = t2;
      t2 += 4;
      var s = e._bin.readUshort(r2, t2);
      return { glyphClassDef: 0 === s ? null : e._lctf.readClassDef(r2, o + s) };
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t2, a2, n) {
      return e._lctf.parse(r2, t2, a2, n, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t2, a2, n) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t2 || 2 == t2 || 3 == t2 || 7 == t2 || 8 == t2 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t2 && 1 == i.fmt) {
        var d = o.readUshort(r2, a2);
        a2 += 2, 0 != d && (i.pos = e.GPOS.readValueRecord(r2, a2, d));
      } else if (2 == t2 && i.fmt >= 1 && i.fmt <= 2) {
        d = o.readUshort(r2, a2);
        a2 += 2;
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var u = e._lctf.numOfOnes(d), l = e._lctf.numOfOnes(f);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v; c++) {
            var p = s + o.readUshort(r2, a2);
            a2 += 2;
            var U = o.readUshort(r2, p);
            p += 2;
            for (var g = [], S = 0; S < U; S++) {
              var m = o.readUshort(r2, p);
              p += 2, 0 != d && (P = e.GPOS.readValueRecord(r2, p, d), p += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * l), g.push({ gid2: m, val1: P, val2: x });
            }
            i.pairsets.push(g);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y = o.readUshort(r2, a2);
          a2 += 2;
          var F = o.readUshort(r2, a2);
          a2 += 2;
          var C = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y), i.matrix = [];
          for (c = 0; c < F; c++) {
            var _ = [];
            for (S = 0; S < C; S++) {
              var P = null, x = null;
              0 != d && (P = e.GPOS.readValueRecord(r2, a2, d), a2 += 2 * u), 0 != f && (x = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * l), _.push({ val1: P, val2: x });
            }
            i.matrix.push(_);
          }
        }
      } else if (4 == t2 && 1 == i.fmt) i.markCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.baseCoverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.markArray = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.baseArray = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else if (6 == t2 && 1 == i.fmt) i.mark1Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2) + s), i.mark2Coverage = e._lctf.readCoverage(r2, o.readUshort(r2, a2 + 2) + s), i.markClassCount = o.readUshort(r2, a2 + 4), i.mark1Array = e.GPOS.readMarkArray(r2, o.readUshort(r2, a2 + 6) + s), i.mark2Array = e.GPOS.readBaseArray(r2, o.readUshort(r2, a2 + 8) + s, i.markClassCount);
      else {
        if (9 == t2 && 1 == i.fmt) {
          var I = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n.ltype) n.ltype = I;
          else if (n.ltype != I) throw "invalid extension substitution";
          return e.GPOS.subt(r2, n.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t2, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t2, a2) {
      var n = e._bin, o = [];
      return o.push(1 & a2 ? n.readShort(r2, t2) : 0), t2 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n.readShort(r2, t2) : 0), t2 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n.readShort(r2, t2) : 0), t2 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n.readShort(r2, t2) : 0), t2 += 8 & a2 ? 2 : 0, o;
    }, e.GPOS.readBaseArray = function(r2, t2, a2) {
      var n = e._bin, o = [], s = t2, i = n.readUshort(r2, t2);
      t2 += 2;
      for (var h = 0; h < i; h++) {
        for (var d = [], f = 0; f < a2; f++) d.push(e.GPOS.readAnchorRecord(r2, s + n.readUshort(r2, t2))), t2 += 2;
        o.push(d);
      }
      return o;
    }, e.GPOS.readMarkArray = function(r2, t2) {
      var a2 = e._bin, n = [], o = t2, s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = e.GPOS.readAnchorRecord(r2, a2.readUshort(r2, t2 + 2) + o);
        h.markClass = a2.readUshort(r2, t2), n.push(h), t2 += 4;
      }
      return n;
    }, e.GPOS.readAnchorRecord = function(r2, t2) {
      var a2 = e._bin, n = {};
      return n.fmt = a2.readUshort(r2, t2), n.x = a2.readShort(r2, t2 + 2), n.y = a2.readShort(r2, t2 + 4), n;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t2, a2, n) {
      return e._lctf.parse(r2, t2, a2, n, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t2, a2, n) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t2 && 2 != t2 && 4 != t2 && 5 != t2 && 6 != t2) return null;
      if (1 == t2 || 2 == t2 || 4 == t2 || 5 == t2 && i.fmt <= 2 || 6 == t2 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t2 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt) i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var d = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, d), a2 += 2 * i.newg.length;
        }
      } else if (2 == t2 && 1 == i.fmt) {
        d = o.readUshort(r2, a2);
        a2 += 2, i.seqs = [];
        for (var f = 0; f < d; f++) {
          var u = o.readUshort(r2, a2) + s;
          a2 += 2;
          var l = o.readUshort(r2, u);
          i.seqs.push(o.readUshorts(r2, u + 2, l));
        }
      } else if (4 == t2) {
        i.vals = [];
        d = o.readUshort(r2, a2);
        a2 += 2;
        for (f = 0; f < d; f++) {
          var v = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + v));
        }
      } else if (5 == t2 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var c = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + c), i.scset = [];
          var p = o.readUshort(r2, a2);
          a2 += 2;
          for (f = 0; f < p; f++) {
            var U = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == U ? null : e.GSUB.readSubClassSet(r2, s + U));
          }
        }
      } else if (6 == t2 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (f = 0; f < 3; f++) {
            d = o.readUshort(r2, a2);
            a2 += 2;
            for (var g = [], S = 0; S < d; S++) g.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * S)));
            a2 += 2 * d, 0 == f && (i.backCvg = g), 1 == f && (i.inptCvg = g), 2 == f && (i.ahedCvg = g);
          }
          d = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, d);
        }
      } else {
        if (7 == t2 && 1 == i.fmt) {
          var m = o.readUshort(r2, a2);
          a2 += 2;
          var b = o.readUint(r2, a2);
          if (a2 += 4, 9 == n.ltype) n.ltype = m;
          else if (n.ltype != m) throw "invalid extension substitution";
          return e.GSUB.subt(r2, n.ltype, s + b);
        }
        console.debug("unsupported GSUB table LookupType", t2, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t2) {
      var a2 = e._bin.readUshort, n = t2, o = [], s = a2(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t2);
        t2 += 2, o.push(e.GSUB.readSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t2) {
      var a2 = e._bin.readUshort, n = {}, o = a2(r2, t2), s = a2(r2, t2 += 2);
      t2 += 2, n.input = [];
      for (var i = 0; i < o - 1; i++) n.input.push(a2(r2, t2)), t2 += 2;
      return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t2, s), n;
    }, e.GSUB.readSubstLookupRecords = function(r2, t2, a2) {
      for (var n = e._bin.readUshort, o = [], s = 0; s < a2; s++) o.push(n(r2, t2), n(r2, t2 + 2)), t2 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t2);
        t2 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t2) {
      for (var a2 = e._bin, n = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t2);
        t2 += 2, 1 == s && i--, n[o[s]] = a2.readUshorts(r2, t2, i), t2 += 2 * n[o[s]].length;
      }
      i = a2.readUshort(r2, t2);
      return t2 += 2, n.subst = a2.readUshorts(r2, t2, 2 * i), t2 += 2 * n.subst.length, n;
    }, e.GSUB.readLigatureSet = function(r2, t2) {
      var a2 = e._bin, n = t2, o = [], s = a2.readUshort(r2, t2);
      t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t2);
        t2 += 2, o.push(e.GSUB.readLigature(r2, n + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t2) {
      var a2 = e._bin, n = { chain: [] };
      n.nglyph = a2.readUshort(r2, t2), t2 += 2;
      var o = a2.readUshort(r2, t2);
      t2 += 2;
      for (var s = 0; s < o - 1; s++) n.chain.push(a2.readUshort(r2, t2)), t2 += 2;
      return n;
    }, e.head = {}, e.head.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t2), t2 += 4, o.fontRevision = n.readFixed(r2, t2), t2 += 4, n.readUint(r2, t2), t2 += 4, n.readUint(r2, t2), t2 += 4, o.flags = n.readUshort(r2, t2), t2 += 2, o.unitsPerEm = n.readUshort(r2, t2), t2 += 2, o.created = n.readUint64(r2, t2), t2 += 8, o.modified = n.readUint64(r2, t2), t2 += 8, o.xMin = n.readShort(r2, t2), t2 += 2, o.yMin = n.readShort(r2, t2), t2 += 2, o.xMax = n.readShort(r2, t2), t2 += 2, o.yMax = n.readShort(r2, t2), t2 += 2, o.macStyle = n.readUshort(r2, t2), t2 += 2, o.lowestRecPPEM = n.readUshort(r2, t2), t2 += 2, o.fontDirectionHint = n.readShort(r2, t2), t2 += 2, o.indexToLocFormat = n.readShort(r2, t2), t2 += 2, o.glyphDataFormat = n.readShort(r2, t2), t2 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t2), t2 += 4, o.ascender = n.readShort(r2, t2), t2 += 2, o.descender = n.readShort(r2, t2), t2 += 2, o.lineGap = n.readShort(r2, t2), t2 += 2, o.advanceWidthMax = n.readUshort(r2, t2), t2 += 2, o.minLeftSideBearing = n.readShort(r2, t2), t2 += 2, o.minRightSideBearing = n.readShort(r2, t2), t2 += 2, o.xMaxExtent = n.readShort(r2, t2), t2 += 2, o.caretSlopeRise = n.readShort(r2, t2), t2 += 2, o.caretSlopeRun = n.readShort(r2, t2), t2 += 2, o.caretOffset = n.readShort(r2, t2), t2 += 2, t2 += 8, o.metricDataFormat = n.readShort(r2, t2), t2 += 2, o.numberOfHMetrics = n.readUshort(r2, t2), t2 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t2, a2, n) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, d = 0; d < n.maxp.numGlyphs; d++) d < n.hhea.numberOfHMetrics && (i = o.readUshort(r2, t2), t2 += 2, h = o.readShort(r2, t2), t2 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t2, a2, n) {
      var o = e._bin, s = o.readUshort(r2, t2);
      if (t2 += 2, 1 == s) return e.kern.parseV1(r2, t2 - 2, a2, n);
      var i = o.readUshort(r2, t2);
      t2 += 2;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < i; d++) {
        t2 += 2;
        a2 = o.readUshort(r2, t2);
        t2 += 2;
        var f = o.readUshort(r2, t2);
        t2 += 2;
        var u = f >>> 8;
        if (0 != (u &= 15)) throw "unknown kern table format: " + u;
        t2 = e.kern.readFormat0(r2, t2, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t2, a2, n) {
      var o = e._bin;
      o.readFixed(r2, t2), t2 += 4;
      var s = o.readUint(r2, t2);
      t2 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t2), t2 += 4;
        var d = o.readUshort(r2, t2);
        t2 += 2, o.readUshort(r2, t2), t2 += 2;
        var f = d >>> 8;
        if (0 != (f &= 15)) throw "unknown kern table format: " + f;
        t2 = e.kern.readFormat0(r2, t2, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t2, a2) {
      var n = e._bin, o = -1, s = n.readUshort(r2, t2);
      t2 += 2, n.readUshort(r2, t2), t2 += 2, n.readUshort(r2, t2), t2 += 2, n.readUshort(r2, t2), t2 += 2;
      for (var i = 0; i < s; i++) {
        var h = n.readUshort(r2, t2);
        t2 += 2;
        var d = n.readUshort(r2, t2);
        t2 += 2;
        var f = n.readShort(r2, t2);
        t2 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var u = a2.rval[a2.rval.length - 1];
        u.glyph2.push(d), u.vals.push(f), o = h;
      }
      return t2;
    }, e.loca = {}, e.loca.parse = function(r2, t2, a2, n) {
      var o = e._bin, s = [], i = n.head.indexToLocFormat, h = n.maxp.numGlyphs + 1;
      if (0 == i) for (var d = 0; d < h; d++) s.push(o.readUshort(r2, t2 + (d << 1)) << 1);
      if (1 == i) for (d = 0; d < h; d++) s.push(o.readUint(r2, t2 + (d << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t2, a2) {
      var n = e._bin, o = {}, s = n.readUint(r2, t2);
      return t2 += 4, o.numGlyphs = n.readUshort(r2, t2), t2 += 2, 65536 == s && (o.maxPoints = n.readUshort(r2, t2), t2 += 2, o.maxContours = n.readUshort(r2, t2), t2 += 2, o.maxCompositePoints = n.readUshort(r2, t2), t2 += 2, o.maxCompositeContours = n.readUshort(r2, t2), t2 += 2, o.maxZones = n.readUshort(r2, t2), t2 += 2, o.maxTwilightPoints = n.readUshort(r2, t2), t2 += 2, o.maxStorage = n.readUshort(r2, t2), t2 += 2, o.maxFunctionDefs = n.readUshort(r2, t2), t2 += 2, o.maxInstructionDefs = n.readUshort(r2, t2), t2 += 2, o.maxStackElements = n.readUshort(r2, t2), t2 += 2, o.maxSizeOfInstructions = n.readUshort(r2, t2), t2 += 2, o.maxComponentElements = n.readUshort(r2, t2), t2 += 2, o.maxComponentDepth = n.readUshort(r2, t2), t2 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      n.readUshort(r2, t2), t2 += 2;
      var s = n.readUshort(r2, t2);
      t2 += 2, n.readUshort(r2, t2);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = t2 += 2, f = 0; f < s; f++) {
        var u = n.readUshort(r2, t2);
        t2 += 2;
        var l = n.readUshort(r2, t2);
        t2 += 2;
        var v = n.readUshort(r2, t2);
        t2 += 2;
        var c = n.readUshort(r2, t2);
        t2 += 2;
        var p = n.readUshort(r2, t2);
        t2 += 2;
        var U = n.readUshort(r2, t2);
        t2 += 2;
        var g, S = h[c], m = d + 12 * s + U;
        if (0 == u) g = n.readUnicode(r2, m, p / 2);
        else if (3 == u && 0 == l) g = n.readUnicode(r2, m, p / 2);
        else if (0 == l) g = n.readASCII(r2, m, p);
        else if (1 == l) g = n.readUnicode(r2, m, p / 2);
        else if (3 == l) g = n.readUnicode(r2, m, p / 2);
        else {
          if (1 != u) throw "unknown encoding " + l + ", platformID: " + u;
          g = n.readASCII(r2, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b = "p" + u + "," + v.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g, o[b]._lang = v;
      }
      for (var y in o) if (null != o[y].postScriptName && 1033 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 0 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName && 3084 == o[y]._lang) return o[y];
      for (var y in o) if (null != o[y].postScriptName) return o[y];
      for (var y in o) {
        i = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t2, a2) {
      var n = e._bin.readUshort(r2, t2);
      t2 += 2;
      var o = {};
      if (0 == n) e["OS/2"].version0(r2, t2, o);
      else if (1 == n) e["OS/2"].version1(r2, t2, o);
      else if (2 == n || 3 == n || 4 == n) e["OS/2"].version2(r2, t2, o);
      else {
        if (5 != n) throw "unknown OS/2 table version: " + n;
        e["OS/2"].version5(r2, t2, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t2, a2) {
      var n = e._bin;
      return a2.xAvgCharWidth = n.readShort(r2, t2), t2 += 2, a2.usWeightClass = n.readUshort(r2, t2), t2 += 2, a2.usWidthClass = n.readUshort(r2, t2), t2 += 2, a2.fsType = n.readUshort(r2, t2), t2 += 2, a2.ySubscriptXSize = n.readShort(r2, t2), t2 += 2, a2.ySubscriptYSize = n.readShort(r2, t2), t2 += 2, a2.ySubscriptXOffset = n.readShort(r2, t2), t2 += 2, a2.ySubscriptYOffset = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptXSize = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptYSize = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptXOffset = n.readShort(r2, t2), t2 += 2, a2.ySuperscriptYOffset = n.readShort(r2, t2), t2 += 2, a2.yStrikeoutSize = n.readShort(r2, t2), t2 += 2, a2.yStrikeoutPosition = n.readShort(r2, t2), t2 += 2, a2.sFamilyClass = n.readShort(r2, t2), t2 += 2, a2.panose = n.readBytes(r2, t2, 10), t2 += 10, a2.ulUnicodeRange1 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange2 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange3 = n.readUint(r2, t2), t2 += 4, a2.ulUnicodeRange4 = n.readUint(r2, t2), t2 += 4, a2.achVendID = [n.readInt8(r2, t2), n.readInt8(r2, t2 + 1), n.readInt8(r2, t2 + 2), n.readInt8(r2, t2 + 3)], t2 += 4, a2.fsSelection = n.readUshort(r2, t2), t2 += 2, a2.usFirstCharIndex = n.readUshort(r2, t2), t2 += 2, a2.usLastCharIndex = n.readUshort(r2, t2), t2 += 2, a2.sTypoAscender = n.readShort(r2, t2), t2 += 2, a2.sTypoDescender = n.readShort(r2, t2), t2 += 2, a2.sTypoLineGap = n.readShort(r2, t2), t2 += 2, a2.usWinAscent = n.readUshort(r2, t2), t2 += 2, a2.usWinDescent = n.readUshort(r2, t2), t2 += 2;
    }, e["OS/2"].version1 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version0(r2, t2, a2), a2.ulCodePageRange1 = n.readUint(r2, t2), t2 += 4, a2.ulCodePageRange2 = n.readUint(r2, t2), t2 += 4;
    }, e["OS/2"].version2 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version1(r2, t2, a2), a2.sxHeight = n.readShort(r2, t2), t2 += 2, a2.sCapHeight = n.readShort(r2, t2), t2 += 2, a2.usDefault = n.readUshort(r2, t2), t2 += 2, a2.usBreak = n.readUshort(r2, t2), t2 += 2, a2.usMaxContext = n.readUshort(r2, t2), t2 += 2;
    }, e["OS/2"].version5 = function(r2, t2, a2) {
      var n = e._bin;
      return t2 = e["OS/2"].version2(r2, t2, a2), a2.usLowerOpticalPointSize = n.readUshort(r2, t2), t2 += 2, a2.usUpperOpticalPointSize = n.readUshort(r2, t2), t2 += 2;
    }, e.post = {}, e.post.parse = function(r2, t2, a2) {
      var n = e._bin, o = {};
      return o.version = n.readFixed(r2, t2), t2 += 4, o.italicAngle = n.readFixed(r2, t2), t2 += 4, o.underlinePosition = n.readShort(r2, t2), t2 += 2, o.underlineThickness = n.readShort(r2, t2), t2 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t2 = r2.cmap, a2 = -1;
      if (null != t2.p0e4 ? a2 = t2.p0e4 : null != t2.p3e1 ? a2 = t2.p3e1 : null != t2.p1e0 ? a2 = t2.p1e0 : null != t2.p0e3 && (a2 = t2.p0e3), -1 == a2) throw "no familiar platform and encoding!";
      var n = t2.tables[a2];
      if (0 == n.format) return e2 >= n.map.length ? 0 : n.map[e2];
      if (4 == n.format) {
        for (var o = -1, s = 0; s < n.endCount.length; s++) if (e2 <= n.endCount[s]) {
          o = s;
          break;
        }
        if (-1 == o) return 0;
        if (n.startCount[o] > e2) return 0;
        return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e2 - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e2 + n.idDelta[o]);
      }
      if (12 == n.format) {
        if (e2 > n.groups[n.groups.length - 1][1]) return 0;
        for (s = 0; s < n.groups.length; s++) {
          var i = n.groups[s];
          if (i[0] <= e2 && e2 <= i[1]) return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n.format;
    }, e.U.glyphToPath = function(r2, t2) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t2]) {
        var n = r2.SVG.entries[t2];
        return null == n ? a2 : ("string" == typeof n && (n = e.SVG.toPath(n), r2.SVG.entries[t2] = n), n);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t2; ) h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t2], o, s, i, a2);
      } else r2.glyf && e.U._drawGlyf(t2, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t2, a2) {
      var n = t2.glyf[r2];
      null == n && (n = t2.glyf[r2] = e.glyf._parseGlyf(t2, r2)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a2) : e.U._compoGlyph(n, t2, a2));
    }, e.U._simpleGlyph = function(r2, t2) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n; s <= o; s++) {
          var i = s == n ? o : s - 1, h = s == o ? n : s + 1, d = 1 & r2.flags[s], f = 1 & r2.flags[i], u = 1 & r2.flags[h], l = r2.xs[s], v = r2.ys[s];
          if (s == n) if (d) {
            if (!f) {
              e.U.P.moveTo(t2, l, v);
              continue;
            }
            e.U.P.moveTo(t2, r2.xs[i], r2.ys[i]);
          } else f ? e.U.P.moveTo(t2, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t2, (r2.xs[i] + l) / 2, (r2.ys[i] + v) / 2);
          d ? f && e.U.P.lineTo(t2, l, v) : u ? e.U.P.qcurveTo(t2, l, v, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t2, l, v, (l + r2.xs[h]) / 2, (v + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t2);
      }
    }, e.U._compoGlyph = function(r2, t2, a2) {
      for (var n = 0; n < r2.parts.length; n++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n];
        e.U._drawGlyf(s.glyphIndex, t2, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var d = o.crds[h], f = o.crds[h + 1];
          a2.crds.push(d * i.a + f * i.b + i.tx), a2.crds.push(d * i.c + f * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++) a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t2) {
      var a2 = e._lctf.getInterval(t2, r2);
      return -1 == a2 ? 0 : t2[a2 + 2];
    }, e.U._applySubs = function(r2, t2, a2, n) {
      for (var o = r2.length - t2 - 1, s = 0; s < a2.tabs.length; s++) if (null != a2.tabs[s]) {
        var i, h = a2.tabs[s];
        if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t2]))) {
          if (1 == a2.ltype) 1 == h.fmt ? r2[t2] = r2[t2] + h.delta : r2[t2] = h.newg[i];
          else if (4 == a2.ltype) for (var d = h.vals[i], f = 0; f < d.length; f++) {
            var u = d[f], l = u.chain.length;
            if (!(l > o)) {
              for (var v = true, c = 0, p = 0; p < l; p++) {
                for (; -1 == r2[t2 + c + (1 + p)]; ) c++;
                u.chain[p] != r2[t2 + c + (1 + p)] && (v = false);
              }
              if (v) {
                r2[t2] = u.nglyph;
                for (p = 0; p < l + c; p++) r2[t2 + p + 1] = -1;
                break;
              }
            }
          }
          else if (5 == a2.ltype && 2 == h.fmt) for (var U = e._lctf.getInterval(h.cDef, r2[t2]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++) {
            var b = S[m], y = b.input;
            if (!(y.length > o)) {
              for (v = true, p = 0; p < y.length; p++) {
                var F = e._lctf.getInterval(h.cDef, r2[t2 + 1 + p]);
                if (-1 == U && h.cDef[F + 2] != y[p]) {
                  v = false;
                  break;
                }
              }
              if (v) {
                var C = b.substLookupRecords;
                for (f = 0; f < C.length; f += 2) ;
              }
            }
          }
          else if (6 == a2.ltype && 3 == h.fmt) {
            if (!e.U._glsCovered(r2, h.backCvg, t2 - h.backCvg.length)) continue;
            if (!e.U._glsCovered(r2, h.inptCvg, t2)) continue;
            if (!e.U._glsCovered(r2, h.ahedCvg, t2 + h.inptCvg.length)) continue;
            var _ = h.lookupRec;
            for (m = 0; m < _.length; m += 2) {
              U = _[m];
              var P = n[_[m + 1]];
              e.U._applySubs(r2, t2 + U, P, n);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r2, t2, a2) {
      for (var n = 0; n < t2.length; n++) {
        if (-1 == e._lctf.coverageIndex(t2[n], r2[a2 + n])) return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t2, a2) {
      for (var n = { cmds: [], crds: [] }, o = 0, s = 0; s < t2.length; s++) {
        var i = t2[s];
        if (-1 != i) {
          for (var h = s < t2.length - 1 && -1 != t2[s + 1] ? t2[s + 1] : 0, d = e.U.glyphToPath(r2, i), f = 0; f < d.crds.length; f += 2) n.crds.push(d.crds[f] + o), n.crds.push(d.crds[f + 1]);
          a2 && n.cmds.push(a2);
          for (f = 0; f < d.cmds.length; f++) n.cmds.push(d.cmds[f]);
          a2 && n.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t2.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t2) {
      r2.cmds.push("M"), r2.crds.push(e2, t2);
    }, e.U.P.lineTo = function(r2, e2, t2) {
      r2.cmds.push("L"), r2.crds.push(e2, t2);
    }, e.U.P.curveTo = function(r2, e2, t2, a2, n, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t2, a2, n, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t2, a2, n) {
      r2.cmds.push("Q"), r2.crds.push(e2, t2, a2, n);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t2, a2, n, o) {
      for (var s = t2.stack, i = t2.nStems, h = t2.haveWidth, d = t2.width, f = t2.open, u = 0, l = t2.x, v = t2.y, c = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, C = 0, _ = { val: 0, size: 0 }; u < r2.length; ) {
        e.CFF.getCharString(r2, u, _);
        var P = _.val;
        if (u += _.size, "o1" == P || "o18" == P) s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == P || "o23" == P) {
          s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = true), f && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), f = true;
        else if ("o5" == P) for (; s.length > 0; ) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
        else if ("o6" == P || "o7" == P) for (var x = s.length, I = "o6" == P, w = 0; w < x; w++) {
          var k = s.shift();
          I ? l += k : v += k, I = !I, e.U.P.lineTo(o, l, v);
        }
        else if ("o8" == P || "o24" == P) {
          x = s.length;
          for (var G = 0; G + 6 <= x; ) c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v), G += 6;
          "o24" == P && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));
        } else {
          if ("o11" == P) break;
          if ("o1234" == P || "o1235" == P || "o1236" == P || "o1237" == P) "o1234" == P && (p = v, U = (c = l + s.shift()) + s.shift(), C = g = p + s.shift(), m = g, y = v, l = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1235" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), l = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1236" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), C = g = p + s.shift(), m = g, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v)), "o1237" == P && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), C = g + s.shift(), S = F + s.shift(), m = C + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - l) > Math.abs(y - v) ? l = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, C), e.U.P.curveTo(o, S, m, b, y, l, v));
          else if ("o14" == P) {
            if (s.length > 0 && !h && (d = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var O = s.shift(), T = s.shift(), D = s.shift(), B = s.shift(), A = e.CFF.glyphBySE(a2, D), R = e.CFF.glyphBySE(a2, B);
              e.U._drawCFF(a2.CharStrings[A], t2, a2, n, o), t2.x = O, t2.y = T, e.U._drawCFF(a2.CharStrings[R], t2, a2, n, o);
            }
            f && (e.U.P.closePath(o), f = false);
          } else if ("o19" == P || "o20" == P) {
            s.length % 2 != 0 && !h && (d = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, u += i + 7 >> 3;
          } else if ("o21" == P) s.length > 2 && !h && (d = s.shift() + n.nominalWidthX, h = true), v += s.pop(), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = true;
          else if ("o22" == P) s.length > 1 && !h && (d = s.shift() + n.nominalWidthX, h = true), l += s.pop(), f && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), f = true;
          else if ("o25" == P) {
            for (; s.length > 6; ) l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
            c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);
          } else if ("o26" == P) for (s.length % 2 && (l += s.shift()); s.length > 0; ) c = l, p = v + s.shift(), l = U = c + s.shift(), v = (g = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);
          else if ("o27" == P) for (s.length % 2 && (v += s.shift()); s.length > 0; ) p = v, U = (c = l + s.shift()) + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g, e.U.P.curveTo(o, c, p, U, g, l, v);
          else if ("o10" == P || "o29" == P) {
            var L = "o10" == P ? n : a2;
            if (0 == s.length) console.debug("error: empty stack");
            else {
              var W = s.pop(), M = L.Subrs[W + L.Bias];
              t2.x = l, t2.y = v, t2.nStems = i, t2.haveWidth = h, t2.width = d, t2.open = f, e.U._drawCFF(M, t2, a2, n, o), l = t2.x, v = t2.y, i = t2.nStems, h = t2.haveWidth, d = t2.width, f = t2.open;
            }
          } else if ("o30" == P || "o31" == P) {
            var V = s.length, E = (G = 0, "o31" == P);
            for (G += V - (x = -3 & V); G < x; ) E ? (p = v, U = (c = l + s.shift()) + s.shift(), v = (g = p + s.shift()) + s.shift(), x - G == 5 ? (l = U + s.shift(), G++) : l = U, E = false) : (c = l, p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), x - G == 5 ? (v = g + s.shift(), G++) : v = g, E = true), e.U.P.curveTo(o, c, p, U, g, l, v), G += 4;
          } else {
            if ("o" == (P + "").charAt(0)) throw console.debug("Unknown operation: " + P, r2), P;
            s.push(P);
          }
        }
      }
      t2.x = l, t2.y = v, t2.nStems = i, t2.haveWidth = h, t2.width = d, t2.open = f;
    };
    var t = e, a = { Typr: t };
    return r.Typr = t, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n = Uint16Array, t = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n(31), i2 = 0; i2 < 31; ++i2) a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t(a2[30]);
      for (i2 = 1; i2 < 30; ++i2) for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2) o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u = f(a, 2), v = u[0], s = u[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n(32768), g = 0; g < 32768; ++g) {
      var h = (43690 & g) >>> 1 | (21845 & g) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t2) {
      for (var a2 = r2.length, i2 = 0, o2 = new n(e2); i2 < a2; ++i2) ++o2[r2[i2] - 1];
      var f2, u2 = new n(e2);
      for (i2 = 0; i2 < e2; ++i2) u2[i2] = u2[i2 - 1] + o2[i2 - 1] << 1;
      {
        f2 = new n(1 << e2);
        var v2 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2) if (r2[i2]) for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g2 = u2[r2[i2] - 1]++ << l2, h2 = g2 | (1 << l2) - 1; g2 <= h2; ++g2) f2[c[g2] >>> v2] = s2;
      }
      return f2;
    }, d = new e(288);
    for (g = 0; g < 144; ++g) d[g] = 8;
    for (g = 144; g < 256; ++g) d[g] = 9;
    for (g = 256; g < 280; ++g) d[g] = 7;
    for (g = 280; g < 288; ++g) d[g] = 8;
    var m = new e(32);
    for (g = 0; g < 32; ++g) m[g] = 5;
    var b = w(d, 9), p = w(m, 5), y = function(r2) {
      for (var e2 = r2[0], n2 = 1; n2 < r2.length; ++n2) r2[n2] > e2 && (e2 = r2[n2]);
      return e2;
    }, L = function(r2, e2, n2) {
      var t2 = e2 / 8 | 0;
      return (r2[t2] | r2[t2 + 1] << 8) >> (7 & e2) & n2;
    }, U = function(r2, e2) {
      var n2 = e2 / 8 | 0;
      return (r2[n2] | r2[n2 + 1] << 8 | r2[n2 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(r2, e2, n2) {
      var t2 = new Error(e2 || k[r2]);
      if (t2.code = r2, Error.captureStackTrace && Error.captureStackTrace(t2, T), !n2) throw t2;
      return t2;
    }, O = function(r2, f2, u2) {
      var s2 = r2.length;
      if (!s2 || u2 && !u2.l && s2 < 5) return f2 || new e(0);
      var c2 = !f2 || u2, g2 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n2 = f2.length;
        if (r3 > n2) {
          var t2 = new e(Math.max(2 * n2, r3));
          t2.set(f2), f2 = t2;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A2 = u2.l, x2 = u2.d, E = u2.m, D = u2.n, M = 8 * s2;
      do {
        if (!A2) {
          u2.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V = r2[(I = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I - 3] << 8, _ = I + V;
            if (_ > s2) {
              g2 && T(0);
              break;
            }
            c2 && d2(O2 + V), f2.set(r2.subarray(I, _), O2), u2.b = O2 += V, u2.p = k2 = 8 * _;
            continue;
          }
          if (1 == S) A2 = b, x2 = p, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r2, k2, 31) + 257, z = L(r2, k2 + 10, 15) + 4, C = j + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e(C), P = new e(19), q = 0; q < z; ++q) P[o[q]] = L(r2, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B = y(P), G = (1 << B) - 1, H = w(P, B);
            for (q = 0; q < C; ) {
              var I, J = H[L(r2, k2, G)];
              if (k2 += 15 & J, (I = J >>> 4) < 16) F[q++] = I;
              else {
                var K = 0, N = 0;
                for (16 == I ? (N = 3 + L(r2, k2, 3), k2 += 2, K = F[q - 1]) : 17 == I ? (N = 3 + L(r2, k2, 7), k2 += 3) : 18 == I && (N = 11 + L(r2, k2, 127), k2 += 7); N--; ) F[q++] = K;
              }
            }
            var Q = F.subarray(0, j), R = F.subarray(j);
            E = y(Q), D = y(R), A2 = w(Q, E), x2 = w(R, D);
          } else T(1);
          if (k2 > M) {
            g2 && T(0);
            break;
          }
        }
        c2 && d2(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A2[U(r2, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g2 && T(0);
            break;
          }
          if (K || T(2), Z < 256) f2[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A2 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a[q = Z - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v[q], k2 += rr;
            }
            var er = x2[U(r2, k2) & X], nr = er >>> 4;
            er || T(3), k2 += 15 & er;
            R = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R += U(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g2 && T(0);
              break;
            }
            c2 && d2(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4) f2[O2] = f2[O2 - R], f2[O2 + 1] = f2[O2 + 1 - R], f2[O2 + 2] = f2[O2 + 2 - R], f2[O2 + 3] = f2[O2 + 3 - R];
            O2 = tr;
          }
        }
        u2.l = A2, u2.p = Y, u2.b = O2, A2 && (m2 = 1, u2.m = E, u2.d = x2, u2.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r3, a2, i2) {
        (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n ? n : r3 instanceof t ? t : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O2);
    }, A = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A, { stream: true });
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n2 = 0;
      function t2() {
        var r3 = e2.getUint16(n2);
        return n2 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n2);
        return n2 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b2, r3), b2 += 2;
      }
      function o2(r3) {
        m2.setUint32(b2, r3), b2 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t2(), reserved: t2(), totalSfntSize: a2(), majorVersion: t2(), minorVersion: t2(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; ) u2++;
      u2--;
      for (var v2 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v2, l2 = 12, c2 = [], g2 = 0; g2 < f2.numTables; g2++) c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b2 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v2), i2(u2), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n3, t3 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n3 = new Uint8Array(t3, 2), O(n3, a3);
        } else a3 = new Uint8Array(t3);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535) i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535) i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]]) continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function calcGlyphPositions(font, glyphIds) {
    const positions = new Int16Array(glyphIds.length * 3);
    let glyphIndex = 0;
    for (; glyphIndex < glyphIds.length; glyphIndex++) {
      const glyphId = glyphIds[glyphIndex];
      if (glyphId === -1) continue;
      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId];
      const gpos = font.GPOS;
      if (gpos) {
        const llist = gpos.lookupList;
        for (let i = 0; i < llist.length; i++) {
          const lookup = llist[i];
          for (let j = 0; j < lookup.tabs.length; j++) {
            const tab = lookup.tabs[j];
            if (lookup.ltype === 1) {
              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);
              if (ind !== -1 && tab.pos) {
                applyValueRecord(tab.pos, glyphIndex);
                break;
              }
            } else if (lookup.ltype === 2) {
              let adj = null;
              let prevGlyphIndex = getPrevGlyphIndex();
              if (prevGlyphIndex !== -1) {
                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);
                if (coverageIndex !== -1) {
                  if (tab.fmt === 1) {
                    const right = tab.pairsets[coverageIndex];
                    for (let k = 0; k < right.length; k++) {
                      if (right[k].gid2 === glyphId) adj = right[k];
                    }
                  } else if (tab.fmt === 2) {
                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);
                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);
                    adj = tab.matrix[c1][c2];
                  }
                  if (adj) {
                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);
                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);
                    break;
                  }
                }
              }
            } else if (lookup.ltype === 4) {
              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);
              if (markArrIndex !== -1) {
                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);
                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);
                if (baseArrIndex !== -1) {
                  const markRecord = tab.markArray[markArrIndex];
                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];
                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];
                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];
                  break;
                }
              }
            } else if (lookup.ltype === 6) {
              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);
              if (mark1ArrIndex !== -1) {
                const prevGlyphIndex = getPrevGlyphIndex();
                if (prevGlyphIndex !== -1) {
                  const prevGlyphId = glyphIds[prevGlyphIndex];
                  if (getGlyphClass(font, prevGlyphId) === 3) {
                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);
                    if (mark2ArrIndex !== -1) {
                      const mark1Record = tab.mark1Array[mark1ArrIndex];
                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];
                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];
                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (font.kern && !font.cff) {
        const prevGlyphIndex = getPrevGlyphIndex();
        if (prevGlyphIndex !== -1) {
          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);
          if (ind1 !== -1) {
            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);
            if (ind2 !== -1) {
              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];
            }
          }
        }
      }
    }
    return positions;
    function getPrevGlyphIndex(filter) {
      for (let i = glyphIndex - 1; i >= 0; i--) {
        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {
          return i;
        }
      }
      return -1;
    }
    function isBaseGlyph(glyphId) {
      return getGlyphClass(font, glyphId) === 1;
    }
    function applyValueRecord(source, gi) {
      for (let i = 0; i < 3; i++) {
        positions[gi * 3 + i] += source[i] || 0;
      }
    }
  }
  function getGlyphClass(font, glyphId) {
    const classDef = font.GDEF && font.GDEF.glyphClassDef;
    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;
  }
  function firstNum(...args) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "number") {
        return args[i];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      supportsCodePoint(code) {
        return Typr.U.codeToGlyph(typrFont, code) > 0;
      },
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let penX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIds = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        const positions = calcGlyphPositions(typrFont, glyphIds);
        glyphIds.forEach((glyphId, i) => {
          if (glyphId !== -1) {
            let glyphObj = glyphMap[glyphId];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphId);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x = crds[i2];
                  let y = crds[i2 + 1];
                  if (x < xMin) xMin = x;
                  if (y < yMin) yMin = y;
                  if (x > xMax) xMax = x;
                  if (y > yMax) yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphId] = {
                index: glyphId,
                advanceWidth: typrFont.hmtx.aWidth[glyphId],
                xMin,
                yMin,
                xMax,
                yMax,
                path
              };
            }
            callback.call(
              null,
              glyphObj,
              penX + positions[i * 3] * fontScale,
              positions[i * 3 + 1] * fontScale,
              charIndex
            );
            penX += positions[i * 3 + 2] * fontScale;
            if (letterSpacing) {
              penX += letterSpacing * fontSize;
            }
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return penX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
const workerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function unicodeFontResolverClientFactory() {
  return function(t) {
    var n = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    n.prototype.add = function(t2) {
      var n2 = t2 >> 5;
      this.buckets.set(n2, (this.buckets.get(n2) || 0) | 1 << (31 & t2));
    }, n.prototype.has = function(t2) {
      var n2 = this.buckets.get(t2 >> 5);
      return void 0 !== n2 && 0 != (n2 & 1 << (31 & t2));
    }, n.prototype.serialize = function() {
      var t2 = [];
      return this.buckets.forEach(function(n2, r2) {
        t2.push((+r2).toString(36) + ":" + n2.toString(36));
      }), t2.join(",");
    }, n.prototype.deserialize = function(t2) {
      var n2 = this;
      this.buckets.clear(), t2.split(",").forEach(function(t3) {
        var r2 = t3.split(":");
        n2.buckets.set(parseInt(r2[0], 36), parseInt(r2[1], 36));
      });
    };
    var r = Math.pow(2, 8), e = r - 1, o = ~e;
    function a(t2) {
      var n2 = function(t3) {
        return t3 & o;
      }(t2).toString(16), e2 = function(t3) {
        return (t3 & o) + r - 1;
      }(t2).toString(16);
      return "codepoint-index/plane" + (t2 >> 16) + "/" + n2 + "-" + e2 + ".json";
    }
    function i(t2, n2) {
      var r2 = t2 & e, o2 = n2.codePointAt(r2 / 6 | 0);
      return 0 != ((o2 = (o2 || 48) - 48) & 1 << r2 % 6);
    }
    function u(t2, n2) {
      var r2;
      (r2 = t2, r2.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(t3) {
        return t3.split("-").map(function(t4) {
          return parseInt(t4.trim(), 16);
        });
      })).forEach(function(t3) {
        var r3 = t3[0], e2 = t3[1];
        void 0 === e2 && (e2 = r3), n2(r3, e2);
      });
    }
    function c(t2, n2) {
      u(t2, function(t3, r2) {
        for (var e2 = t3; e2 <= r2; e2++) n2(e2);
      });
    }
    var s = {}, f = {}, l = /* @__PURE__ */ new WeakMap(), v = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function d(t2) {
      var r2 = l.get(t2);
      return r2 || (r2 = new n(), c(t2.ranges, function(t3) {
        return r2.add(t3);
      }), l.set(t2, r2)), r2;
    }
    var h, p = /* @__PURE__ */ new Map();
    function g(t2, n2, r2) {
      return t2[n2] ? n2 : t2[r2] ? r2 : function(t3) {
        for (var n3 in t3) return n3;
      }(t2);
    }
    function w(t2, n2) {
      var r2 = n2;
      if (!t2.includes(r2)) {
        r2 = 1 / 0;
        for (var e2 = 0; e2 < t2.length; e2++) Math.abs(t2[e2] - n2) < Math.abs(r2 - n2) && (r2 = t2[e2]);
      }
      return r2;
    }
    function k(t2) {
      return h || (h = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(t3) {
        h.add(t3);
      })), h.has(t2);
    }
    return t.CodePointSet = n, t.clearCache = function() {
      s = {}, f = {};
    }, t.getFontsForString = function(t2, n2) {
      void 0 === n2 && (n2 = {});
      var r2, e2 = n2.lang;
      void 0 === e2 && (e2 = /\p{Script=Hangul}/u.test(r2 = t2) ? "ko" : /\p{Script=Hiragana}|\p{Script=Katakana}/u.test(r2) ? "ja" : "en");
      var o2 = n2.category;
      void 0 === o2 && (o2 = "sans-serif");
      var u2 = n2.style;
      void 0 === u2 && (u2 = "normal");
      var c2 = n2.weight;
      void 0 === c2 && (c2 = 400);
      var l2 = (n2.dataUrl || v).replace(/\/$/g, ""), h2 = /* @__PURE__ */ new Map(), y = new Uint8Array(t2.length), b = {}, m = {}, A = new Array(t2.length), S = /* @__PURE__ */ new Map(), j = false;
      function M(t3) {
        var n3 = p.get(t3);
        return n3 || (n3 = fetch(l2 + "/" + t3).then(function(t4) {
          if (!t4.ok) throw new Error(t4.statusText);
          return t4.json().then(function(t5) {
            if (!Array.isArray(t5) || 1 !== t5[0]) throw new Error("Incorrect schema version; need 1, got " + t5[0]);
            return t5[1];
          });
        }).catch(function(n4) {
          if (l2 !== v) return j || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + l2 + '", trying default CDN. ' + n4.message), j = true), l2 = v, p.delete(t3), M(t3);
          throw n4;
        }), p.set(t3, n3)), n3;
      }
      for (var P = function(n3) {
        var r3 = t2.codePointAt(n3), e3 = a(r3);
        A[n3] = e3, s[e3] || S.has(e3) || S.set(e3, M(e3).then(function(t3) {
          s[e3] = t3;
        })), r3 > 65535 && (n3++, E = n3);
      }, E = 0; E < t2.length; E++) P(E);
      return Promise.all(S.values()).then(function() {
        S.clear();
        for (var n3 = function(n4) {
          var o3 = t2.codePointAt(n4), a2 = null, u3 = s[A[n4]], c3 = void 0;
          for (var l3 in u3) {
            var v2 = m[l3];
            if (void 0 === v2 && (v2 = m[l3] = new RegExp(l3).test(e2 || "en")), v2) {
              for (var d2 in c3 = l3, u3[l3]) if (i(o3, u3[l3][d2])) {
                a2 = d2;
                break;
              }
              break;
            }
          }
          if (!a2) {
            t: for (var h3 in u3) if (h3 !== c3) {
              for (var p2 in u3[h3]) if (i(o3, u3[h3][p2])) {
                a2 = p2;
                break t;
              }
            }
          }
          a2 || (console.debug("No font coverage for U+" + o3.toString(16)), a2 = "latin"), A[n4] = a2, f[a2] || S.has(a2) || S.set(a2, M("font-meta/" + a2 + ".json").then(function(t3) {
            f[a2] = t3;
          })), o3 > 65535 && (n4++, r3 = n4);
        }, r3 = 0; r3 < t2.length; r3++) n3(r3);
        return Promise.all(S.values());
      }).then(function() {
        for (var n3, r3 = null, e3 = 0; e3 < t2.length; e3++) {
          var a2 = t2.codePointAt(e3);
          if (r3 && (k(a2) || d(r3).has(a2))) y[e3] = y[e3 - 1];
          else {
            r3 = f[A[e3]];
            var i2 = b[r3.id];
            if (!i2) {
              var s2 = r3.typeforms, v2 = g(s2, o2, "sans-serif"), p2 = g(s2[v2], u2, "normal"), m2 = w(null === (n3 = s2[v2]) || void 0 === n3 ? void 0 : n3[p2], c2);
              i2 = b[r3.id] = l2 + "/font-files/" + r3.id + "/" + v2 + "." + p2 + "." + m2 + ".woff";
            }
            var S2 = h2.get(i2);
            null == S2 && (S2 = h2.size, h2.set(i2, S2)), y[e3] = S2;
          }
          a2 > 65535 && (e3++, y[e3] = y[e3 - 1]);
        }
        return { fontUrls: Array.from(h2.keys()), chars: y };
      });
    }, Object.defineProperty(t, "__esModule", { value: true }), t;
  }({});
}
function createFontResolver(fontParser, unicodeFontResolverClient) {
  const parsedFonts = /* @__PURE__ */ Object.create(null);
  const loadingFonts = /* @__PURE__ */ Object.create(null);
  function doLoadFont(url, callback) {
    const onError = (err) => {
      console.error(`Failure loading font ${url}`, err);
    };
    try {
      const request = new XMLHttpRequest();
      request.open("get", url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        if (request.status >= 400) {
          onError(new Error(request.statusText));
        } else if (request.status > 0) {
          try {
            const fontObj = fontParser(request.response);
            fontObj.src = url;
            callback(fontObj);
          } catch (e) {
            onError(e);
          }
        }
      };
      request.onerror = onError;
      request.send();
    } catch (err) {
      onError(err);
    }
  }
  function loadFont(fontUrl, callback) {
    let font = parsedFonts[fontUrl];
    if (font) {
      callback(font);
    } else if (loadingFonts[fontUrl]) {
      loadingFonts[fontUrl].push(callback);
    } else {
      loadingFonts[fontUrl] = [callback];
      doLoadFont(fontUrl, (fontObj) => {
        fontObj.src = fontUrl;
        parsedFonts[fontUrl] = fontObj;
        loadingFonts[fontUrl].forEach((cb) => cb(fontObj));
        delete loadingFonts[fontUrl];
      });
    }
  }
  return function(text, callback, {
    lang,
    fonts: userFonts = [],
    style = "normal",
    weight = "normal",
    unicodeFontsURL
  } = {}) {
    const charResolutions = new Uint8Array(text.length);
    const fontResolutions = [];
    if (!text.length) {
      allDone();
    }
    const fontIndices = /* @__PURE__ */ new Map();
    const fallbackRanges = [];
    if (style !== "italic") style = "normal";
    if (typeof weight !== "number") {
      weight = weight === "bold" ? 700 : 400;
    }
    if (userFonts && !Array.isArray(userFonts)) {
      userFonts = [userFonts];
    }
    userFonts = userFonts.slice().filter((def) => !def.lang || def.lang.test(lang)).reverse();
    if (userFonts.length) {
      const UNKNOWN = 0;
      const RESOLVED = 1;
      const NEEDS_FALLBACK = 2;
      let prevCharResult = UNKNOWN;
      (function resolveUserFonts(startIndex = 0) {
        for (let i = startIndex, iLen = text.length; i < iLen; i++) {
          const codePoint = text.codePointAt(i);
          if (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint) || i > 0 && /\s/.test(text[i])) {
            charResolutions[i] = charResolutions[i - 1];
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          } else {
            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {
              if (j === jLen) {
                const range = prevCharResult === NEEDS_FALLBACK ? fallbackRanges[fallbackRanges.length - 1] : fallbackRanges[fallbackRanges.length] = [i, i];
                range[1] = i;
                prevCharResult = NEEDS_FALLBACK;
              } else {
                charResolutions[i] = j;
                const { src, unicodeRange } = userFonts[j];
                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {
                  const fontObj = parsedFonts[src];
                  if (!fontObj) {
                    loadFont(src, () => {
                      resolveUserFonts(i);
                    });
                    return;
                  }
                  if (fontObj.supportsCodePoint(codePoint)) {
                    let fontIndex = fontIndices.get(fontObj);
                    if (typeof fontIndex !== "number") {
                      fontIndex = fontResolutions.length;
                      fontResolutions.push(fontObj);
                      fontIndices.set(fontObj, fontIndex);
                    }
                    charResolutions[i] = fontIndex;
                    prevCharResult = RESOLVED;
                    break;
                  }
                }
              }
            }
          }
          if (codePoint > 65535 && i + 1 < iLen) {
            charResolutions[i + 1] = charResolutions[i];
            i++;
            if (prevCharResult === NEEDS_FALLBACK) {
              fallbackRanges[fallbackRanges.length - 1][1] = i;
            }
          }
        }
        resolveFallbacks();
      })();
    } else {
      fallbackRanges.push([0, text.length - 1]);
      resolveFallbacks();
    }
    function resolveFallbacks() {
      if (fallbackRanges.length) {
        const fallbackString = fallbackRanges.map((range) => text.substring(range[0], range[1] + 1)).join("\n");
        unicodeFontResolverClient.getFontsForString(fallbackString, {
          lang: lang || void 0,
          style,
          weight,
          dataUrl: unicodeFontsURL
        }).then(({ fontUrls, chars }) => {
          const fontIndexOffset = fontResolutions.length;
          let charIdx = 0;
          fallbackRanges.forEach((range) => {
            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {
              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;
            }
            charIdx++;
          });
          let loadedCount = 0;
          fontUrls.forEach((url, i) => {
            loadFont(url, (fontObj) => {
              fontResolutions[i + fontIndexOffset] = fontObj;
              if (++loadedCount === fontUrls.length) {
                allDone();
              }
            });
          });
        });
      } else {
        allDone();
      }
    }
    function allDone() {
      callback({
        chars: charResolutions,
        fonts: fontResolutions
      });
    }
    function isCodeInRanges(code, ranges) {
      for (let k = 0; k < ranges.length; k++) {
        const [start, end = start] = ranges[k];
        if (start <= code && code <= end) {
          return true;
        }
      }
      return false;
    }
  };
}
const fontResolverWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "FontResolver",
  dependencies: [
    createFontResolver,
    workerModule,
    unicodeFontResolverClientFactory
  ],
  init(createFontResolver2, fontParser, unicodeFontResolverClientFactory2) {
    return createFontResolver2(fontParser, unicodeFontResolverClientFactory2());
  }
});
function createTypesetter(resolveFonts, bidi) {
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function calculateFontRuns({ text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL }, onDone) {
    const onResolved = ({ chars, fonts: parsedFonts }) => {
      let curRun, prevVal;
      const runs = [];
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] !== prevVal) {
          prevVal = chars[i];
          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]] });
        } else {
          curRun.end = i;
        }
      }
      onDone(runs);
    };
    if (preResolvedFonts) {
      onResolved(preResolvedFonts);
    } else {
      resolveFonts(
        text,
        onResolved,
        { lang, fonts, style, weight, unicodeFontsURL }
      );
    }
  }
  function typeset({
    text = "",
    font,
    lang,
    sdfGlyphSize = 64,
    fontSize = 400,
    fontWeight = 1,
    fontStyle = "normal",
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    metricsOnly = false,
    unicodeFontsURL,
    preResolvedFonts = null,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    calculateFontRuns({
      text,
      lang,
      style: fontStyle,
      weight: fontWeight,
      fonts: typeof font === "string" ? [{ src: font }] : font,
      unicodeFontsURL,
      preResolvedFonts
    }, (runs) => {
      timings.fontLoad = now2() - mainStart;
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphFontIndices = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const metricsByFont = /* @__PURE__ */ new Map();
      const typesetStart = now2();
      let lineXOffset = textIndent;
      let prevRunEndX = 0;
      let currentLine = new TextLine();
      const lines = [currentLine];
      runs.forEach((run) => {
        const { fontObj } = run;
        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
        let fontData2 = metricsByFont.get(fontObj);
        if (!fontData2) {
          const fontSizeMult2 = fontSize / unitsPerEm;
          const calcLineHeight = lineHeight === "normal" ? (ascender - descender + lineGap) * fontSizeMult2 : lineHeight * fontSize;
          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult2) / 2;
          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult2);
          const caretTop = (ascender + descender) / 2 * fontSizeMult2 + caretHeight / 2;
          fontData2 = {
            index: metricsByFont.size,
            src: fontObj.src,
            fontObj,
            fontSizeMult: fontSizeMult2,
            unitsPerEm,
            ascender: ascender * fontSizeMult2,
            descender: descender * fontSizeMult2,
            capHeight: capHeight * fontSizeMult2,
            xHeight: xHeight * fontSizeMult2,
            lineHeight: calcLineHeight,
            baseline: -halfLeading - ascender * fontSizeMult2,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop,
            caretBottom: caretTop - caretHeight
          };
          metricsByFont.set(fontObj, fontData2);
        }
        const { fontSizeMult } = fontData2;
        const runText = text.slice(run.start, run.end + 1);
        let prevGlyphX, prevGlyphObj;
        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {
          glyphX += prevRunEndX;
          charIndex += run.start;
          prevGlyphX = glyphX;
          prevGlyphObj = glyphObj;
          const char = text.charAt(charIndex);
          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
          const curLineCount = currentLine.count;
          let nextLine;
          if (!("isEmpty" in glyphObj)) {
            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
          }
          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
            renderableGlyphCount++;
          }
          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
              nextLine = new TextLine();
              lineXOffset = -glyphX;
            } else {
              for (let i = curLineCount; i--; ) {
                if (i === 0 && overflowWrap === "break-word") {
                  nextLine = new TextLine();
                  lineXOffset = -glyphX;
                  break;
                } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                  nextLine = currentLine.splitAt(i + 1);
                  const adjustX = nextLine.glyphAt(0).x;
                  lineXOffset -= adjustX;
                  for (let j = nextLine.count; j--; ) {
                    nextLine.glyphAt(j).x -= adjustX;
                  }
                  break;
                }
              }
            }
            if (nextLine) {
              currentLine.isSoftWrapped = true;
              currentLine = nextLine;
              lines.push(currentLine);
              maxLineWidth = maxWidth;
            }
          }
          let fly = currentLine.glyphAt(currentLine.count);
          fly.glyphObj = glyphObj;
          fly.x = glyphX + lineXOffset;
          fly.y = glyphY;
          fly.width = glyphWidth;
          fly.charIndex = charIndex;
          fly.fontData = fontData2;
          if (char === "\n") {
            currentLine = new TextLine();
            lines.push(currentLine);
            lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
          }
        });
        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;
      });
      let totalHeight = 0;
      lines.forEach((line) => {
        let isTrailingWhitespace = true;
        for (let i = line.count; i--; ) {
          const glyphInfo = line.glyphAt(i);
          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {
            line.width = glyphInfo.x + glyphInfo.width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            isTrailingWhitespace = false;
          }
          let { lineHeight: lineHeight2, capHeight, xHeight, baseline } = glyphInfo.fontData;
          if (lineHeight2 > line.lineHeight) line.lineHeight = lineHeight2;
          const baselineDiff = baseline - line.baseline;
          if (baselineDiff < 0) {
            line.baseline += baselineDiff;
            line.cap += baselineDiff;
            line.ex += baselineDiff;
          }
          line.cap = Math.max(line.cap, line.baseline + capHeight);
          line.ex = Math.max(line.ex, line.baseline + xHeight);
        }
        line.baseline -= totalHeight;
        line.cap -= totalHeight;
        line.ex -= totalHeight;
        totalHeight += line.lineHeight;
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -lines[0].baseline : anchorY === "top-cap" ? -lines[0].cap : anchorY === "top-ex" ? -lines[0].ex : anchorY === "middle" ? totalHeight / 2 : anchorY === "bottom" ? totalHeight : anchorY === "bottom-baseline" ? -lines[lines.length - 1].baseline : parsePercent(anchorY) * totalHeight;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphFontIndices = new Uint8Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 4);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g) => glyphObj = g;
            for (let i = 0; i < lineGlyphCount; i++) {
              const glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex, fontData: fontData2 } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 4 + 2] = line.baseline + fontData2.caretBottom + anchorYOffset;
                caretPositions[charIndex * 4 + 3] = line.baseline + fontData2.caretTop + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                const { fontSizeMult, src: fontSrc, index: fontIndex } = glyphInfo.fontData;
                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});
                if (!fontGlyphData[glyphId]) {
                  fontGlyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;
                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;
                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;
                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                glyphFontIndices[idx] = fontIndex;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      const fontData = [];
      metricsByFont.forEach(({ index, src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight }) => {
        fontData[index] = { src, unitsPerEm, ascender, descender, lineHeight: lineHeight2, capHeight, xHeight };
      });
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices,
        //index into fontData for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        fontData,
        //data about each font used in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        topBaseline: anchorYOffset + lines[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - totalHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset({ ...args, metricsOnly: true }, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 4];
    const ligEndX = caretPositions[ligStartIndex * 4 + 1];
    const ligBottom = caretPositions[ligStartIndex * 4 + 2];
    const ligTop = caretPositions[ligStartIndex * 4 + 3];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 4;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligBottom;
      caretPositions[startIndex + 3] = ligTop;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  TextLine.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure
  };
}
const now = () => (self.performance || Date).now();
const mainThreadGenerator = /* @__PURE__ */ SDFGenerator();
let warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
    }
  );
}
const queue = [];
const chunkTimeBudget = 5;
let timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
const generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({ timing: now() - start });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
const threadCount = 4;
const idleTimeout = 2e3;
const threads = {};
let callNum = 0;
function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now2) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now2();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now2() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i = 0; i < textureData.length; i++) {
      imageData[i * 4 + channel] = textureData[i];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);
    timing += now() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
const CONFIG = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048};
const tempColor = /* @__PURE__ */ new Color();
function now$1() {
  return (self.performance || Date).now();
}
const atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  args = assign({}, args);
  const totalStart = now$1();
  const fonts = [];
  if (args.font) {
    fonts.push({ label: "user", src: toAbsoluteURL(args.font) });
  }
  args.font = fonts;
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  const typeset = typesetInWorker ;
  typeset(args).then((result) => {
    const { glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    const fontGlyphMaps = fontData.map((font) => {
      let map = atlas.glyphsByFont.get(font.src);
      if (!map) {
        atlas.glyphsByFont.set(font.src, map = /* @__PURE__ */ new Map());
      }
      return map;
    });
    glyphIds.forEach((glyphId, i) => {
      const fontIndex = glyphFontIndices[i];
      const { src: fontSrc, unitsPerEm } = fontData[fontIndex];
      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[fontSrc][glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphMaps[fontIndex].set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      const fontSizeMult = fontSize / unitsPerEm;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function assign(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
let linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
const typesetterWorkerModule = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    createTypesetter,
    fontResolverWorkerModule,
    bidiFactory
  ],
  init(createTypesetter2, fontResolver, bidiFactory2) {
    return createTypesetter2(fontResolver, bidiFactory2());
  }
});
const typesetInWorker = /* @__PURE__ */ defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [];
    for (let p in result) {
      if (result[p] && result[p].buffer) {
        transferables.push(result[p].buffer);
      }
    }
    return transferables;
  }
});
const templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    geom = templateGeometries[detail] = new PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);
  }
  return geom;
}
const glyphBoundsAttrName = "aTroikaGlyphBounds";
const glyphIndexAttrName = "aTroikaGlyphIndex";
const glyphColorAttrName = "aTroikaGlyphColor";
class GlyphsGeometry extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);
    this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);
    this.updateAttributeData(glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i = chunks.length; i--; ) {
        count = chunks[i].end;
        let rect = chunks[i].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(attrName, newArray, itemSize) {
    const attr = this.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        this.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete this._maxInstanceCount;
        this.dispose();
      }
    } else if (attr) {
      this.deleteAttribute(attrName);
    }
  }
}
const VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
const VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
const FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
const FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader, fragmentShader }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        fragmentShader = fragmentShader.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader, fragmentShader };
    }
  });
  textMaterial.transparent = true;
  textMaterial.forceSinglePass = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
const defaultMaterial = /* @__PURE__ */ new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
const defaultStrokeColor = 8421504;
const tempMat4 = /* @__PURE__ */ new Matrix4();
const tempVec3a = /* @__PURE__ */ new Vector3();
const tempVec3b = /* @__PURE__ */ new Vector3();
const tempArray = [];
const origin = /* @__PURE__ */ new Vector3();
const defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
let getFlatRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
let getCurvedRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
const syncStartEvent = { type: "syncstart" };
const syncCompleteEvent = { type: "synccomplete" };
const SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
const COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class Text extends Mesh {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.unicodeFontsURL = null;
    this.fontSize = 0.1;
    this.fontWeight = "normal";
    this.fontStyle = "normal";
    this.lang = null;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          lang: this.lang,
          fontSize: this.fontSize || 0.1,
          fontWeight: this.fontWeight || "normal",
          fontStyle: this.fontStyle || "normal",
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF,
          unicodeFontsURL: this.unicodeFontsURL
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(baseMaterial) {
    return createTextDerivedMaterial(baseMaterial);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {
      derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.hasOutline()) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  set customDepthMaterial(m) {
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(m) {
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null) strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaEdgeOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material.color;
    } else {
      const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
      if (color !== colorObj._input || typeof color === "object") {
        colorObj.set(colorObj._input = color);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position, target = new Vector2()) {
    target.copy(position);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position, target = new Vector2()) {
    tempVec3a.copy(position);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position, uv } = geom.attributes;
      for (let i = 0; i < uv.count; i++) {
        let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
        const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
        let z = 0;
        if (curveRadius) {
          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position.setXYZ(i, x, y, z);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i = 0; i < tempArray.length; i++) {
        tempArray[i].object = this;
        intersects.push(tempArray[i]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop) => {
      this[prop] = source[prop];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
SYNCABLE_PROPS.forEach((prop) => {
  const privateKey = "_private_" + prop;
  Object.defineProperty(Text.prototype, prop, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});
new Box3();
new Color();

class ArcLengthTable {
  constructor(curve, resolution = 500) {
    this.curve = curve;
    this.build(resolution);
  }
  entries = [];
  totalLength = 0;
  build(resolution) {
    this.entries = [];
    let accumulatedLength = 0;
    let prevPoint = this.curve.getPointAt(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.getPointAt(t);
      const tangent = this.curve.getTangentAt(t);
      if (i > 0) {
        accumulatedLength += point.distanceTo(prevPoint);
      }
      this.entries.push({
        t,
        distance: accumulatedLength,
        position: point.clone(),
        tangent: tangent.clone().normalize()
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.entries.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.entries[mid].distance < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.entries[low];
    const prevEntry = this.entries[Math.max(0, low - 1)];
    if (entry.distance === prevEntry.distance) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.distance) / (entry.distance - prevEntry.distance);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    const position = this.curve.getPointAt(t);
    const tangent = this.curve.getTangentAt(t).normalize();
    const normal = new Vector3(-tangent.y, tangent.x, 0).normalize();
    return {
      position,
      tangent,
      normal,
      t,
      distance
    };
  }
}
class TextOnPathService {
  arcLengthTable = null;
  curve = null;
  /**
   * Set the path from control points
   */
  setPath(controlPoints, closed = false) {
    if (controlPoints.length < 2) {
      this.curve = null;
      this.arcLengthTable = null;
      return;
    }
    this.curve = new CurvePath();
    for (let i = 0; i < controlPoints.length - 1; i++) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (closed && controlPoints.length > 2) {
      const lastPoint = controlPoints[controlPoints.length - 1];
      const firstPoint = controlPoints[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    this.arcLengthTable = new ArcLengthTable(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(curve) {
    this.curve = curve;
    this.arcLengthTable = new ArcLengthTable(curve);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    return this.arcLengthTable?.totalLength ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(characterWidths, config, tracking = 0, fontSize = 72) {
    if (!this.arcLengthTable || characterWidths.length === 0) {
      return [];
    }
    const totalLength = this.arcLengthTable.totalLength;
    const placements = [];
    const trackingPx = tracking / 1e3 * fontSize;
    let totalTextWidth = 0;
    for (let i = 0; i < characterWidths.length; i++) {
      totalTextWidth += characterWidths[i];
      if (i < characterWidths.length - 1) {
        totalTextWidth += trackingPx;
      }
    }
    const availableLength = totalLength - config.firstMargin - config.lastMargin;
    let startDistance;
    switch (config.align) {
      case "center":
        startDistance = config.firstMargin + (availableLength - totalTextWidth) / 2;
        break;
      case "right":
        startDistance = config.firstMargin + availableLength - totalTextWidth;
        break;
      default:
        startDistance = config.firstMargin;
    }
    const offsetDistance = config.offset / 100 * availableLength;
    startDistance += offsetDistance;
    if (config.reversed) {
      startDistance = totalLength - startDistance - totalTextWidth;
    }
    let currentDistance = startDistance;
    for (let i = 0; i < characterWidths.length; i++) {
      const charWidth = characterWidths[i];
      const charCenterDistance = currentDistance + charWidth / 2;
      let actualDistance = charCenterDistance;
      let visible = true;
      if (actualDistance < 0 || actualDistance > totalLength) {
        if (config.forceAlignment) {
          actualDistance = (actualDistance % totalLength + totalLength) % totalLength;
        } else {
          visible = actualDistance >= -charWidth && actualDistance <= totalLength + charWidth;
          actualDistance = Math.max(0, Math.min(totalLength, actualDistance));
        }
      }
      const pathPoint = this.arcLengthTable.getPointAtDistance(actualDistance);
      let rotation;
      if (config.perpendicularToPath) {
        const angle = Math.atan2(pathPoint.tangent.y, pathPoint.tangent.x);
        rotation = new Euler(0, 0, config.reversed ? angle + Math.PI : angle);
      } else {
        rotation = new Euler(0, 0, 0);
      }
      placements.push({
        index: i,
        position: pathPoint.position.clone(),
        rotation,
        scale: 1,
        pathDistance: actualDistance,
        pathT: pathPoint.t,
        visible
      });
      currentDistance += charWidth + trackingPx;
    }
    return placements;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(percent) {
    if (!this.arcLengthTable) return null;
    const distance = percent / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(distance);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(count) {
    if (!this.arcLengthTable || count < 2) return [];
    const points = [];
    const spacing = this.arcLengthTable.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.arcLengthTable.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null;
    this.arcLengthTable = null;
  }
}
function createDefaultPathConfig() {
  return {
    pathLayerId: null,
    reversed: false,
    perpendicularToPath: true,
    forceAlignment: false,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}

class TextLayer extends BaseLayer {
  resources;
  // Text rendering
  textMesh;
  perCharacterGroup = null;
  characterMeshes = [];
  // Text data from layer
  textData;
  // Animatable text properties (from layer.properties)
  fontSizeProp;
  trackingProp;
  lineSpacingProp;
  fillColorProp;
  strokeColorProp;
  strokeWidthProp;
  pathOffsetProp;
  firstMarginProp;
  lastMarginProp;
  characterOffsetProp;
  // Per-character animation
  characterTransforms;
  // Path following service
  textOnPath;
  pathConfig;
  pathControlPoints = [];
  pathClosed = false;
  // Character width cache (recalculated when text/font changes)
  characterWidths = [];
  characterWidthsDirty = true;
  // Additional evaluator for text-specific properties
  textEvaluator;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.textEvaluator = new KeyframeEvaluator();
    this.textOnPath = new TextOnPathService();
    this.pathConfig = createDefaultPathConfig();
    this.textData = this.extractTextData(layerData);
    this.extractAnimatableProperties(layerData);
    this.textMesh = this.createTextMesh();
    this.group.add(this.textMesh);
    if (this.textData.perCharacter3D || this.textData.pathLayerId) {
      this.enablePerCharacter3D();
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(layerData) {
    const data = layerData.data;
    return {
      text: data?.text ?? "Text",
      fontFamily: data?.fontFamily ?? "Impact",
      fontSize: data?.fontSize ?? 72,
      fontWeight: data?.fontWeight ?? "400",
      fontStyle: data?.fontStyle ?? "normal",
      fill: data?.fill ?? "#ffffff",
      stroke: data?.stroke ?? "",
      strokeWidth: data?.strokeWidth ?? 0,
      // Character properties
      tracking: data?.tracking ?? 0,
      lineSpacing: data?.lineSpacing ?? 0,
      lineAnchor: data?.lineAnchor ?? 50,
      characterOffset: data?.characterOffset ?? 0,
      characterValue: data?.characterValue ?? 0,
      blur: data?.blur ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: data?.letterSpacing ?? data?.tracking ?? 0,
      lineHeight: data?.lineHeight ?? data?.lineSpacing ?? 1.2,
      textAlign: data?.textAlign ?? "left",
      // Path options (full AE parity)
      pathLayerId: data?.pathLayerId ?? null,
      pathReversed: data?.pathReversed ?? false,
      pathPerpendicularToPath: data?.pathPerpendicularToPath ?? true,
      pathForceAlignment: data?.pathForceAlignment ?? false,
      pathFirstMargin: data?.pathFirstMargin ?? 0,
      pathLastMargin: data?.pathLastMargin ?? 0,
      pathOffset: data?.pathOffset ?? 0,
      pathAlign: data?.pathAlign ?? "left",
      // More Options
      anchorPointGrouping: data?.anchorPointGrouping ?? "character",
      groupingAlignment: data?.groupingAlignment ?? { x: 0, y: 0 },
      fillAndStroke: data?.fillAndStroke ?? "fill-over-stroke",
      interCharacterBlending: data?.interCharacterBlending ?? "normal",
      // 3D
      perCharacter3D: data?.perCharacter3D ?? false
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(layerData) {
    if (!layerData.properties) return;
    for (const prop of layerData.properties) {
      switch (prop.name) {
        case "Font Size":
          this.fontSizeProp = prop;
          break;
        case "Tracking":
          this.trackingProp = prop;
          break;
        case "Line Spacing":
          this.lineSpacingProp = prop;
          break;
        case "Fill Color":
          this.fillColorProp = prop;
          break;
        case "Stroke Color":
          this.strokeColorProp = prop;
          break;
        case "Stroke Width":
          this.strokeWidthProp = prop;
          break;
        case "Path Offset":
          this.pathOffsetProp = prop;
          break;
        case "First Margin":
          this.firstMarginProp = prop;
          break;
        case "Last Margin":
          this.lastMarginProp = prop;
          break;
        case "Character Offset":
          this.characterOffsetProp = prop;
          break;
      }
    }
    this.syncPathConfig();
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId;
    this.pathConfig.reversed = this.textData.pathReversed;
    this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath;
    this.pathConfig.forceAlignment = this.textData.pathForceAlignment;
    this.pathConfig.firstMargin = this.textData.pathFirstMargin;
    this.pathConfig.lastMargin = this.textData.pathLastMargin;
    this.pathConfig.offset = this.textData.pathOffset;
    this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const text = new Text();
    text.text = this.textData.text;
    text.font = this.getFontUrl(this.textData.fontFamily) ?? null;
    text.fontSize = this.textData.fontSize;
    text.color = this.textData.fill;
    if (this.textData.stroke && this.textData.strokeWidth > 0) {
      text.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
      text.outlineColor = this.textData.stroke;
    }
    text.letterSpacing = (this.textData.tracking || 0) / 1e3;
    text.lineHeight = this.textData.lineHeight || 1.2;
    text.textAlign = this.textData.textAlign;
    text.anchorX = this.getAnchorX();
    text.anchorY = "middle";
    text.depthOffset = 0;
    text.renderOrder = 0;
    text.sync();
    return text;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(fontFamily) {
    const systemFonts = [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ];
    if (systemFonts.includes(fontFamily)) {
      return void 0;
    }
    const googleFonts = {
      "Roboto": "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      "Lato": "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      "Montserrat": "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      "Oswald": "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      "Poppins": "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    };
    return googleFonts[fontFamily];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(controlPoints, closed = false) {
    this.pathControlPoints = controlPoints;
    this.pathClosed = closed;
    if (controlPoints.length >= 2) {
      this.textOnPath.setPath(controlPoints, closed);
      if (!this.perCharacterGroup) {
        this.enablePerCharacter3D();
      }
      this.updatePathLayout();
    } else {
      this.textOnPath.dispose();
      this.resetPathLayout();
    }
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(curve) {
    this.textOnPath.setCurve(curve);
    if (!this.perCharacterGroup) {
      this.enablePerCharacter3D();
    }
    this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null;
    this.pathConfig.pathLayerId = null;
    this.textOnPath.dispose();
    this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup) {
      return;
    }
    this.ensureCharacterWidths();
    const placements = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(placements);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(placements) {
    for (let i = 0; i < this.characterMeshes.length && i < placements.length; i++) {
      const mesh = this.characterMeshes[i];
      const placement = placements[i];
      mesh.position.copy(placement.position);
      mesh.rotation.copy(placement.rotation);
      mesh.scale.setScalar(placement.scale);
      mesh.visible = placement.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    if (this.textData.perCharacter3D) {
      this.createCharacterMeshes();
    } else {
      this.disablePerCharacter3D();
    }
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const text = this.textData.text;
    const avgCharWidth = this.textData.fontSize * 0.6;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (`iIl1|!.,;:'"`.includes(char)) {
        this.characterWidths.push(avgCharWidth * 0.4);
      } else if ("mwMW".includes(char)) {
        this.characterWidths.push(avgCharWidth * 1.3);
      } else if (char === " ") {
        this.characterWidths.push(avgCharWidth * 0.5);
      } else {
        this.characterWidths.push(avgCharWidth);
      }
    }
    this.characterWidthsDirty = false;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    if (this.perCharacterGroup) return;
    this.textMesh.visible = false;
    this.perCharacterGroup = new Group();
    this.perCharacterGroup.name = `text_chars_${this.id}`;
    this.group.add(this.perCharacterGroup);
    this.createCharacterMeshes();
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    if (!this.perCharacterGroup) return;
    this.textMesh.visible = true;
    this.disposeCharacterMeshes();
    this.group.remove(this.perCharacterGroup);
    this.perCharacterGroup = null;
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes();
    this.characterWidthsDirty = true;
    const text = this.textData.text;
    let xOffset = 0;
    this.ensureCharacterWidths();
    const totalWidth = this.characterWidths.reduce((a, b) => a + b, 0) + (text.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let startX = 0;
    switch (this.textData.textAlign) {
      case "center":
        startX = -totalWidth / 2;
        break;
      case "right":
        startX = -totalWidth;
        break;
      default:
        startX = 0;
    }
    xOffset = startX;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charMesh = new Text();
      charMesh.text = char;
      charMesh.font = this.getFontUrl(this.textData.fontFamily) ?? null;
      charMesh.fontSize = this.textData.fontSize;
      charMesh.color = this.textData.fill;
      charMesh.anchorX = "center";
      charMesh.anchorY = "middle";
      if (this.textData.stroke && this.textData.strokeWidth > 0) {
        charMesh.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
        charMesh.outlineColor = this.textData.stroke;
      }
      const charWidth = this.characterWidths[i];
      charMesh.position.x = xOffset + charWidth / 2;
      charMesh.position.y = 0;
      charMesh.position.z = 0;
      xOffset += charWidth + this.textData.tracking / 1e3 * this.textData.fontSize;
      charMesh.sync();
      this.characterMeshes.push(charMesh);
      this.perCharacterGroup.add(charMesh);
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    for (const mesh of this.characterMeshes) {
      mesh.dispose();
      this.perCharacterGroup?.remove(mesh);
    }
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(text) {
    this.textData.text = text;
    this.textMesh.text = text;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    if (this.perCharacterGroup) {
      this.createCharacterMeshes();
    }
  }
  setFontFamily(family) {
    this.textData.fontFamily = family;
    const fontUrl = this.getFontUrl(family) ?? null;
    this.textMesh.font = fontUrl;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.font = fontUrl;
      charMesh.sync();
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setFontSize(size) {
    this.textData.fontSize = size;
    this.textMesh.fontSize = size;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.fontSize = size;
      charMesh.sync();
    }
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setFillColor(color) {
    this.textData.fill = color;
    this.textMesh.color = color;
    for (const charMesh of this.characterMeshes) {
      charMesh.color = color;
    }
  }
  setStroke(color, width) {
    this.textData.stroke = color;
    this.textData.strokeWidth = width;
    const outlineWidth = width / this.textData.fontSize;
    this.textMesh.outlineWidth = outlineWidth;
    this.textMesh.outlineColor = color;
    for (const charMesh of this.characterMeshes) {
      charMesh.outlineWidth = outlineWidth;
      charMesh.outlineColor = color;
    }
  }
  setTracking(tracking) {
    this.textData.tracking = tracking;
    this.textMesh.letterSpacing = tracking / 1e3;
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setTextAlign(align) {
    this.textData.textAlign = align;
    this.textMesh.textAlign = align;
    this.textMesh.anchorX = this.getAnchorX();
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.pathConfig.align = align;
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(offset) {
    this.textData.pathOffset = offset;
    this.pathConfig.offset = offset;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(margin) {
    this.textData.pathFirstMargin = margin;
    this.pathConfig.firstMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(margin) {
    this.textData.pathLastMargin = margin;
    this.pathConfig.lastMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set path reversed
   */
  setPathReversed(reversed) {
    this.textData.pathReversed = reversed;
    this.pathConfig.reversed = reversed;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(perpendicular) {
    this.textData.pathPerpendicularToPath = perpendicular;
    this.pathConfig.perpendicularToPath = perpendicular;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set force alignment
   */
  setForceAlignment(force) {
    this.textData.pathForceAlignment = force;
    this.pathConfig.forceAlignment = force;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setAnchorPointGrouping(grouping) {
    this.textData.anchorPointGrouping = grouping;
  }
  setFillAndStroke(order) {
    this.textData.fillAndStroke = order;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.fontSizeProp?.animated) {
      const size = this.textEvaluator.evaluate(this.fontSizeProp, frame);
      this.setFontSize(size);
    }
    if (this.trackingProp?.animated) {
      const tracking = this.textEvaluator.evaluate(this.trackingProp, frame);
      this.setTracking(tracking);
    }
    if (this.fillColorProp?.animated) {
      const color = this.textEvaluator.evaluate(this.fillColorProp, frame);
      this.setFillColor(color);
    }
    if (this.strokeColorProp?.animated && this.strokeWidthProp) {
      const color = this.textEvaluator.evaluate(this.strokeColorProp, frame);
      const width = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, frame) : this.textData.strokeWidth;
      this.setStroke(color, width);
    }
    if (this.pathOffsetProp) {
      const offset = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, frame) : this.textData.pathOffset;
      this.setPathOffset(offset);
    }
    if (this.firstMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.firstMarginProp, frame);
      this.setFirstMargin(margin);
    }
    if (this.lastMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.lastMarginProp, frame);
      this.setLastMargin(margin);
    }
    if (this.characterTransforms?.animated && this.perCharacterGroup) {
      this.applyCharacterTransforms(frame);
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["fontSize"] !== void 0) {
      this.setFontSize(props["fontSize"]);
    }
    if (props["tracking"] !== void 0) {
      this.setTracking(props["tracking"]);
    }
    if (props["fillColor"] !== void 0) {
      this.setFillColor(props["fillColor"]);
    }
    if (props["strokeColor"] !== void 0 || props["strokeWidth"] !== void 0) {
      this.setStroke(
        props["strokeColor"] ?? this.textData.stroke,
        props["strokeWidth"] ?? this.textData.strokeWidth
      );
    }
    if (props["pathOffset"] !== void 0) {
      this.setPathOffset(props["pathOffset"]);
    }
    if (props["firstMargin"] !== void 0) {
      this.setFirstMargin(props["firstMargin"]);
    }
    if (props["lastMargin"] !== void 0) {
      this.setLastMargin(props["lastMargin"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(frame) {
    if (!this.characterTransforms) return;
    const transforms = this.textEvaluator.evaluate(this.characterTransforms, frame);
    for (let i = 0; i < this.characterMeshes.length && i < transforms.length; i++) {
      const charMesh = this.characterMeshes[i];
      const t = transforms[i];
      charMesh.position.x += t.position.x;
      charMesh.position.y += t.position.y;
      charMesh.position.z += t.position.z;
      charMesh.rotation.x += MathUtils.degToRad(t.rotation.x);
      charMesh.rotation.y += MathUtils.degToRad(t.rotation.y);
      charMesh.rotation.z += MathUtils.degToRad(t.rotation.z);
      charMesh.scale.x *= t.scale.x;
      charMesh.scale.y *= t.scale.y;
      if (charMesh.material) {
        charMesh.material.opacity *= t.opacity;
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.text !== void 0) {
        this.setText(data.text);
      }
      if (data.fontFamily !== void 0) {
        this.setFontFamily(data.fontFamily);
      }
      if (data.fontSize !== void 0) {
        this.setFontSize(data.fontSize);
      }
      if (data.fill !== void 0) {
        this.setFillColor(data.fill);
      }
      if (data.stroke !== void 0 || data.strokeWidth !== void 0) {
        this.setStroke(
          data.stroke ?? this.textData.stroke,
          data.strokeWidth ?? this.textData.strokeWidth
        );
      }
      if (data.tracking !== void 0) {
        this.setTracking(data.tracking);
      }
      if (data.textAlign !== void 0) {
        this.setTextAlign(data.textAlign);
      }
      if (data.pathLayerId !== void 0) {
        this.textData.pathLayerId = data.pathLayerId;
        this.pathConfig.pathLayerId = data.pathLayerId;
      }
      if (data.pathOffset !== void 0) {
        this.setPathOffset(data.pathOffset);
      }
      if (data.pathFirstMargin !== void 0) {
        this.setFirstMargin(data.pathFirstMargin);
      }
      if (data.pathLastMargin !== void 0) {
        this.setLastMargin(data.pathLastMargin);
      }
      if (data.pathReversed !== void 0) {
        this.setPathReversed(data.pathReversed);
      }
      if (data.pathPerpendicularToPath !== void 0) {
        this.setPerpendicularToPath(data.pathPerpendicularToPath);
      }
      if (data.pathForceAlignment !== void 0) {
        this.setForceAlignment(data.pathForceAlignment);
      }
      if (data.perCharacter3D !== void 0) {
        if (data.perCharacter3D && !this.perCharacterGroup) {
          this.enablePerCharacter3D();
        } else if (!data.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup) {
          this.disablePerCharacter3D();
        }
      }
      if (data.anchorPointGrouping !== void 0) {
        this.setAnchorPointGrouping(data.anchorPointGrouping);
      }
      if (data.fillAndStroke !== void 0) {
        this.setFillAndStroke(data.fillAndStroke);
      }
    }
    if (properties.properties) {
      this.extractAnimatableProperties(properties);
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    const bounds = this.textMesh.textRenderInfo?.blockBounds;
    if (bounds) {
      return {
        width: bounds[2] - bounds[0],
        height: bounds[3] - bounds[1]
      };
    }
    return { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose();
    this.disposeCharacterMeshes();
    this.textOnPath.dispose();
    if (this.perCharacterGroup) {
      this.group.remove(this.perCharacterGroup);
    }
  }
}

class SplineLayer extends BaseLayer {
  /** The line mesh for the spline */
  lineMesh = null;
  /** The fill mesh (if closed path with fill) */
  fillMesh = null;
  /** Spline data */
  splineData;
  /** Cached curve for path calculations */
  curve = null;
  /** Animated control points (if spline is animated) */
  animatedPoints = null;
  /** Last evaluated frame for cache invalidation */
  lastEvaluatedFrame = -1;
  /** Cached evaluated points for the current frame */
  cachedEvaluatedPoints = null;
  /** Hash of last evaluated points for change detection */
  lastPointsHash = "";
  constructor(layerData) {
    super(layerData);
    this.splineData = this.extractSplineData(layerData);
    if (this.splineData.animated && this.splineData.animatedControlPoints) {
      this.animatedPoints = this.splineData.animatedControlPoints;
    }
    this.buildSpline();
    this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(layerData) {
    const data = layerData.data;
    return {
      controlPoints: data?.controlPoints ?? [],
      closed: data?.closed ?? false,
      stroke: data?.stroke ?? "#00ff00",
      strokeWidth: data?.strokeWidth ?? 2,
      fill: data?.fill ?? "",
      pathData: data?.pathData ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    this.clearMeshes();
    const points = this.splineData.controlPoints;
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const lineGeometry = new BufferGeometry().setFromPoints(curvePoints);
    const lineMaterial = new LineBasicMaterial({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: true
    });
    this.lineMesh = new Line(lineGeometry, lineMaterial);
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(curvePoints) {
    if (curvePoints.length < 3) return;
    const shape = new Shape();
    shape.moveTo(curvePoints[0].x, curvePoints[0].y);
    for (let i = 1; i < curvePoints.length; i++) {
      shape.lineTo(curvePoints[i].x, curvePoints[i].y);
    }
    shape.closePath();
    const fillGeometry = new ShapeGeometry(shape);
    const fillMaterial = new MeshBasicMaterial({
      color: this.splineData.fill,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.fillMesh = new Mesh(fillGeometry, fillMaterial);
    this.fillMesh.name = `spline_fill_${this.id}`;
    this.fillMesh.position.z = -0.1;
    this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    if (this.lineMesh) {
      this.group.remove(this.lineMesh);
      this.lineMesh.geometry.dispose();
      this.lineMesh.material.dispose();
      this.lineMesh = null;
    }
    if (this.fillMesh) {
      this.group.remove(this.fillMesh);
      this.fillMesh.geometry.dispose();
      this.fillMesh.material.dispose();
      this.fillMesh = null;
    }
    this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(t) {
    if (!this.curve) return null;
    return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(t) {
    if (!this.curve) return null;
    return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    if (!this.curve) return 0;
    return this.curve.getLength();
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(t) {
    const point = this.getPointAt(t);
    const tangent = this.getTangentAt(t);
    if (!point || !tangent) return null;
    const rotation = Math.atan2(tangent.y, tangent.x) * (180 / Math.PI);
    return { position: point, rotation };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(color) {
    this.splineData.stroke = color;
    if (this.lineMesh) {
      this.lineMesh.material.color.set(color);
    }
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(width) {
    this.splineData.strokeWidth = width;
    if (this.lineMesh) {
      this.lineMesh.material.linewidth = width;
    }
  }
  /**
   * Set fill color
   */
  setFill(color) {
    this.splineData.fill = color;
    if (this.fillMesh) {
      this.fillMesh.material.color.set(color);
    } else if (color && this.splineData.closed && this.curve) {
      const curvePoints = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(curvePoints);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(points) {
    this.splineData.controlPoints = points;
    this.animatedPoints = null;
    this.splineData.animated = false;
    this.buildSpline();
  }
  /**
   * Set animated control points
   * Enables animation mode for this spline
   */
  setAnimatedControlPoints(points) {
    this.animatedPoints = points;
    this.splineData.animatedControlPoints = points;
    this.splineData.animated = true;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
  }
  /**
   * Enable animation on this spline by converting static control points
   * to AnimatableControlPoint format
   */
  enableAnimation() {
    if (this.animatedPoints) {
      return this.animatedPoints;
    }
    const { controlPointToAnimatable } = require("@/types/project");
    const animatedPoints = this.splineData.controlPoints.map(
      (cp) => controlPointToAnimatable(cp)
    );
    this.setAnimatedControlPoints(animatedPoints);
    return animatedPoints;
  }
  /**
   * Disable animation and convert back to static control points
   */
  disableAnimation() {
    if (!this.animatedPoints) return;
    const { animatableToControlPoint } = require("@/types/project");
    this.splineData.controlPoints = this.animatedPoints.map(
      (acp) => animatableToControlPoint(acp)
    );
    this.animatedPoints = null;
    this.splineData.animatedControlPoints = void 0;
    this.splineData.animated = false;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
    this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(closed) {
    if (this.splineData.closed === closed) return;
    this.splineData.closed = closed;
    this.buildSpline();
  }
  /**
   * Check if the spline path is closed
   */
  isClosed() {
    return this.splineData.closed;
  }
  // ============================================================================
  // ANIMATED SPLINE EVALUATION
  // ============================================================================
  /**
   * Check if this spline has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   * Uses interpolateProperty from interpolation.ts
   * Driven values override interpolated values
   */
  evaluateControlPointAtFrame(acp, frame, index) {
    const interpolatedX = interpolateProperty(acp.x, frame);
    const interpolatedY = interpolateProperty(acp.y, frame);
    const interpolatedDepth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    return {
      id: acp.id,
      x: this.getDrivenControlPointValue(index, "x", interpolatedX),
      y: this.getDrivenControlPointValue(index, "y", interpolatedY),
      depth: this.getDrivenControlPointValue(index, "depth", interpolatedDepth),
      handleIn: acp.handleIn ? {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      } : null,
      handleOut: acp.handleOut ? {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      } : null,
      type: acp.type
    };
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer and other consumers
   *
   * For static splines, returns the static control points converted to EvaluatedControlPoint
   * For animated splines, interpolates all control points at the given frame
   * Driven values (from PropertyDriverSystem) override interpolated values
   *
   * DETERMINISM: Same frame + same drivers = same output (pure function)
   */
  getEvaluatedControlPoints(frame) {
    const hasDrivenValues = this.hasSplineDrivers();
    if (frame === this.lastEvaluatedFrame && this.cachedEvaluatedPoints && !hasDrivenValues) {
      return this.cachedEvaluatedPoints;
    }
    let points;
    if (this.animatedPoints && this.animatedPoints.length > 0) {
      points = this.animatedPoints.map(
        (acp, index) => this.evaluateControlPointAtFrame(acp, frame, index)
      );
    } else {
      points = this.splineData.controlPoints.map((cp, index) => ({
        id: cp.id,
        x: this.getDrivenControlPointValue(index, "x", cp.x),
        y: this.getDrivenControlPointValue(index, "y", cp.y),
        depth: this.getDrivenControlPointValue(index, "depth", cp.depth ?? 0),
        handleIn: cp.handleIn,
        handleOut: cp.handleOut,
        type: cp.type
      }));
    }
    this.lastEvaluatedFrame = frame;
    if (!hasDrivenValues) {
      this.cachedEvaluatedPoints = points;
    }
    return points;
  }
  /**
   * Check if any spline control point drivers are active
   */
  hasSplineDrivers() {
    for (const key of this.drivenValues.keys()) {
      if (isSplineControlPointPath(key)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get a driven control point value, falling back to base value
   */
  getDrivenControlPointValue(index, property, baseValue) {
    const path = createSplineControlPointPath(index, property);
    return this.getDrivenOrBase(path, baseValue);
  }
  /**
   * Compute a hash of control point positions for change detection
   * Used to avoid rebuilding geometry when positions haven't changed
   */
  computePointsHash(points) {
    return points.map(
      (p) => `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.depth.toFixed(2)}`
    ).join("|");
  }
  /**
   * Build spline geometry from evaluated control points
   * Called when control points change during animation
   */
  buildSplineFromEvaluatedPoints(points) {
    this.clearMeshes();
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth;
      const z1 = p1.depth;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth;
      const zFirst = firstPoint.depth;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const lineGeometry = new BufferGeometry().setFromPoints(curvePoints);
    const lineMaterial = new LineBasicMaterial({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: true
    });
    this.lineMesh = new Line(lineGeometry, lineMaterial);
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.isAnimated()) {
      return;
    }
    const evaluatedPoints = this.getEvaluatedControlPoints(frame);
    const pointsHash = this.computePointsHash(evaluatedPoints);
    if (pointsHash !== this.lastPointsHash) {
      this.buildSplineFromEvaluatedPoints(evaluatedPoints);
      this.lastPointsHash = pointsHash;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["controlPoints"] !== void 0) {
      const points = props["controlPoints"];
      const pointsHash = this.computePointsHash(points);
      if (pointsHash !== this.lastPointsHash) {
        this.buildSplineFromEvaluatedPoints(points);
        this.lastPointsHash = pointsHash;
      }
    }
    if (props["strokeWidth"] !== void 0) {
      this.setStrokeWidth(props["strokeWidth"]);
    }
    if (props["strokeColor"] !== void 0) {
      this.setStroke(props["strokeColor"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      let needsRebuild = false;
      if (data.animatedControlPoints !== void 0) {
        this.setAnimatedControlPoints(data.animatedControlPoints);
        needsRebuild = false;
      } else if (data.controlPoints !== void 0) {
        this.splineData.controlPoints = data.controlPoints;
        if (!data.animated) {
          this.animatedPoints = null;
          this.splineData.animated = false;
        }
        needsRebuild = true;
      }
      if (data.animated !== void 0) {
        if (data.animated && !this.animatedPoints) {
          this.enableAnimation();
          needsRebuild = false;
        } else if (!data.animated && this.animatedPoints) {
          this.disableAnimation();
          needsRebuild = false;
        }
      }
      if (data.closed !== void 0 && data.closed !== this.splineData.closed) {
        this.splineData.closed = data.closed;
        needsRebuild = true;
      }
      if (data.stroke !== void 0) {
        this.setStroke(data.stroke);
      }
      if (data.strokeWidth !== void 0) {
        this.setStrokeWidth(data.strokeWidth);
      }
      if (data.fill !== void 0) {
        this.setFill(data.fill);
      }
      if (needsRebuild) {
        this.buildSpline();
      }
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}

const PARTICLE_STRIDE = 16;
const MAX_FORCE_FIELDS = 16;
const SPATIAL_CELL_SIZE = 50;
const TF_VARYINGS = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function createDefaultEmitter(id) {
  return {
    id: id || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: true,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: false,
    beatEmissionMultiplier: 5
  };
}
function createDefaultForceField(type, id) {
  const base = {
    id: id || `force_${Date.now()}`,
    name: type.charAt(0).toUpperCase() + type.slice(1),
    type,
    enabled: true,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (type) {
    case "gravity":
      base.direction = { x: 0, y: 1, z: 0 };
      base.strength = 98;
      break;
    case "vortex":
      base.vortexAxis = { x: 0, y: 0, z: 1 };
      base.inwardForce = 20;
      break;
    case "turbulence":
      base.noiseScale = 5e-3;
      base.noiseSpeed = 0.5;
      base.noiseOctaves = 3;
      base.noiseLacunarity = 2;
      base.noiseGain = 0.5;
      break;
    case "drag":
      base.linearDrag = 0.1;
      base.quadraticDrag = 0.01;
      break;
    case "wind":
      base.windDirection = { x: 1, y: 0, z: 0 };
      base.gustStrength = 50;
      base.gustFrequency = 0.1;
      break;
    case "lorenz":
      base.lorenzSigma = 10;
      base.lorenzRho = 28;
      base.lorenzBeta = 2.667;
      break;
  }
  return base;
}
function createDefaultConfig() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: true,
      depthWrite: false,
      depthTest: true,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: false,
        receiveShadows: false,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: false,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: false,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: false,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: false,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: false,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: SPATIAL_CELL_SIZE,
    updateFrequency: 1,
    cullOffscreen: true
  };
}
class GPUParticleSystem {
  config;
  gl = null;
  renderer = null;
  // Double-buffered particle data
  particleBufferA;
  particleBufferB;
  currentBuffer = "A";
  // WebGL resources
  transformFeedbackProgram = null;
  renderProgram = null;
  vaoA = null;
  vaoB = null;
  particleVboA = null;
  particleVboB = null;
  transformFeedbackA = null;
  transformFeedbackB = null;
  // Three.js integration
  particleMesh = null;
  instancedGeometry = null;
  material = null;
  // Textures for modulation curves
  sizeOverLifetimeTexture = null;
  opacityOverLifetimeTexture = null;
  colorOverLifetimeTexture = null;
  // Emitter state
  emitters = /* @__PURE__ */ new Map();
  forceFields = /* @__PURE__ */ new Map();
  subEmitters = /* @__PURE__ */ new Map();
  // Runtime state
  state = {
    particleCount: 0,
    activeEmitters: 0,
    simulationTime: 0,
    frameCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0,
    gpuMemoryBytes: 0,
    currentAudioFeatures: /* @__PURE__ */ new Map()
  };
  // Audio reactivity
  audioFeatures = /* @__PURE__ */ new Map();
  // Spatial hash for neighbor queries (flocking)
  spatialHash = /* @__PURE__ */ new Map();
  // Event system
  eventHandlers = /* @__PURE__ */ new Map();
  // Pool of free particle indices
  freeIndices = [];
  nextParticleIndex = 0;
  // Random number generator with seed
  rng;
  constructor(config = {}) {
    this.config = { ...createDefaultConfig(), ...config };
    const bufferSize = this.config.maxParticles * PARTICLE_STRIDE;
    this.particleBufferA = new Float32Array(bufferSize);
    this.particleBufferB = new Float32Array(bufferSize);
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now());
    this.config.emitters.forEach((e) => this.addEmitter(e));
    this.config.forceFields.forEach((f) => this.addForceField(f));
    this.config.subEmitters.forEach((s) => this.addSubEmitter(s));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  // GPU physics mode flag
  useGPUPhysics = false;
  gpuPhysicsInitialized = false;
  // Force field uniform buffer for GPU physics
  forceFieldBuffer = null;
  forceFieldTexture = null;
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(renderer) {
    this.renderer = renderer;
    this.gl = renderer.getContext();
    if (!this.gl) {
      throw new Error("WebGL2 context required for GPU particle system");
    }
    this.createModulationTextures();
    this.createParticleMesh();
    this.initializeGPUPhysics();
    this.state.gpuMemoryBytes = this.config.maxParticles * PARTICLE_STRIDE * 4 * 2;
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    const tfExtension = gl.getExtension("EXT_color_buffer_float");
    if (!tfExtension) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback");
      this.useGPUPhysics = false;
      return;
    }
    try {
      this.transformFeedbackProgram = this.createTransformFeedbackProgram(gl);
      if (!this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics");
        this.useGPUPhysics = false;
        return;
      }
      this.particleVboA = gl.createBuffer();
      this.particleVboB = gl.createBuffer();
      if (!this.particleVboA || !this.particleVboB) {
        throw new Error("Failed to create particle VBOs");
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboA);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferA, gl.DYNAMIC_COPY);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboB);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferB, gl.DYNAMIC_COPY);
      this.vaoA = gl.createVertexArray();
      this.vaoB = gl.createVertexArray();
      if (!this.vaoA || !this.vaoB) {
        throw new Error("Failed to create VAOs");
      }
      this.setupParticleVAO(gl, this.vaoA, this.particleVboA);
      this.setupParticleVAO(gl, this.vaoB, this.particleVboB);
      this.transformFeedbackA = gl.createTransformFeedback();
      this.transformFeedbackB = gl.createTransformFeedback();
      if (!this.transformFeedbackA || !this.transformFeedbackB) {
        throw new Error("Failed to create transform feedback objects");
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackA);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackB);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      this.forceFieldBuffer = new Float32Array(MAX_FORCE_FIELDS * 16);
      this.forceFieldTexture = new DataTexture(
        this.forceFieldBuffer,
        MAX_FORCE_FIELDS,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        RGBAFormat,
        FloatType
      );
      this.useGPUPhysics = true;
      this.gpuPhysicsInitialized = true;
      console.log("GPU physics initialized with Transform Feedback");
    } catch (error) {
      console.warn("GPU physics initialization failed:", error);
      this.useGPUPhysics = false;
      this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(gl, vao, vbo) {
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const stride = PARTICLE_STRIDE * 4;
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 2, gl.FLOAT, false, stride, 32);
    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 2, gl.FLOAT, false, stride, 40);
    gl.enableVertexAttribArray(5);
    gl.vertexAttribPointer(5, 4, gl.FLOAT, false, stride, 48);
    gl.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(gl) {
    const vsSource = this.getTransformFeedbackVertexShader();
    const fsSource = this.getTransformFeedbackFragmentShader();
    const vs = gl.createShader(gl.VERTEX_SHADER);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    if (!vs || !fs) return null;
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback vertex shader error:", gl.getShaderInfoLog(vs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback fragment shader error:", gl.getShaderInfoLog(fs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    const program = gl.createProgram();
    if (!program) {
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.transformFeedbackVaryings(program, TF_VARYINGS, gl.INTERLEAVED_ATTRIBS);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Transform feedback program link error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.deleteShader(vs);
    gl.deleteShader(fs);
    return program;
  }
  /**
   * Get the vertex shader for transform feedback GPU physics
   */
  getTransformFeedbackVertexShader() {
    return `#version 300 es
      precision highp float;

      // Input particle attributes
      layout(location = 0) in vec3 a_position;
      layout(location = 1) in vec3 a_velocity;
      layout(location = 2) in vec2 a_life;      // age, lifetime
      layout(location = 3) in vec2 a_physical;  // mass, size
      layout(location = 4) in vec2 a_rotation;  // rotation, angularVelocity
      layout(location = 5) in vec4 a_color;

      // Output (transform feedback)
      out vec3 tf_position;
      out vec3 tf_velocity;
      out vec2 tf_life;
      out vec2 tf_physical;
      out vec2 tf_rotation;
      out vec4 tf_color;

      // Uniforms
      uniform float u_deltaTime;
      uniform float u_time;
      uniform int u_forceFieldCount;
      uniform sampler2D u_forceFields;

      // Noise functions for turbulence
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      // Calculate force from a single force field
      vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
        // Read force field data from texture
        // Row 0: position.xyz, type
        // Row 1: strength, falloffStart, falloffEnd, falloffType
        // Row 2: direction/axis.xyz, extra param
        // Row 3: extra params (noise scale, speed, etc)

        vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
        vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
        vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
        vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);

        vec3 fieldPos = row0.xyz;
        int fieldType = int(row0.w);
        float strength = row1.x;
        float falloffStart = row1.y;
        float falloffEnd = row1.z;
        int falloffType = int(row1.w);

        // Calculate distance and falloff
        vec3 toField = fieldPos - pos;
        float dist = length(toField);

        float falloff = 1.0;
        if (dist > falloffStart && falloffEnd > falloffStart) {
          float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
          if (falloffType == 1) falloff = 1.0 - t; // Linear
          else if (falloffType == 2) falloff = 1.0 - t * t; // Quadratic
          else if (falloffType == 3) falloff = exp(-t * 3.0); // Exponential
          else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t); // Smoothstep
        }

        vec3 force = vec3(0.0);
        float effectiveStrength = strength * falloff;

        // Force field types
        if (fieldType == 0) {
          // Gravity - directional
          force = row2.xyz * effectiveStrength;
        }
        else if (fieldType == 1) {
          // Point attractor
          if (dist > 0.001) {
            vec3 dir = normalize(toField);
            force = dir * effectiveStrength / max(mass, 0.1);
          }
        }
        else if (fieldType == 2) {
          // Vortex
          if (dist > 0.001) {
            vec3 axis = normalize(row2.xyz);
            vec3 tangent = normalize(cross(axis, toField));
            float inward = row2.w;
            force = tangent * effectiveStrength + normalize(toField) * inward;
          }
        }
        else if (fieldType == 3) {
          // Turbulence
          float noiseScale = row3.x;
          float noiseSpeed = row3.y;
          vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
          force.x = snoise(noisePos) * effectiveStrength;
          force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
          force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
        }
        else if (fieldType == 4) {
          // Drag
          float linearDrag = row3.x;
          float quadDrag = row3.y;
          float speed = length(vel);
          if (speed > 0.001) {
            float dragMag = linearDrag * speed + quadDrag * speed * speed;
            force = -normalize(vel) * dragMag * effectiveStrength;
          }
        }
        else if (fieldType == 5) {
          // Wind
          vec3 windDir = normalize(row2.xyz);
          float gustStrength = row3.x;
          float gustFreq = row3.y;
          float gust = sin(u_time * gustFreq) * gustStrength;
          force = windDir * (effectiveStrength + gust);
        }

        return force;
      }

      void main() {
        // Pass through dead particles unchanged
        if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
          tf_position = a_position;
          tf_velocity = a_velocity;
          tf_life = a_life;
          tf_physical = a_physical;
          tf_rotation = a_rotation;
          tf_color = a_color;
          return;
        }

        // Read particle state
        vec3 pos = a_position;
        vec3 vel = a_velocity;
        float age = a_life.x;
        float lifetime = a_life.y;
        float mass = a_physical.x;
        float size = a_physical.y;
        float rotation = a_rotation.x;
        float angularVel = a_rotation.y;

        // Accumulate forces
        vec3 totalForce = vec3(0.0);
        for (int i = 0; i < u_forceFieldCount; i++) {
          totalForce += calculateForce(i, pos, vel, mass);
        }

        // Apply acceleration (F = ma)
        vec3 acceleration = totalForce / max(mass, 0.1);
        vel += acceleration * u_deltaTime;

        // Integrate position
        pos += vel * u_deltaTime;

        // Update rotation
        rotation += angularVel * u_deltaTime;

        // Update age
        age += u_deltaTime;

        // Life ratio for modulation
        float lifeRatio = age / lifetime;

        // Apply size over lifetime (simple linear fade for now)
        // More complex curves should be done via texture lookup
        float sizeMod = 1.0 - lifeRatio * 0.5;
        size = a_physical.y * sizeMod;

        // Apply opacity over lifetime
        float opacityMod = 1.0 - lifeRatio;

        // Output
        tf_position = pos;
        tf_velocity = vel;
        tf_life = vec2(age, lifetime);
        tf_physical = vec2(mass, size);
        tf_rotation = vec2(rotation, angularVel);
        tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
      }
    `;
  }
  /**
   * Get the fragment shader for transform feedback (must exist but won't output)
   */
  getTransformFeedbackFragmentShader() {
    return `#version 300 es
      precision highp float;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(0.0);
      }
    `;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    if (this.transformFeedbackProgram) {
      gl.deleteProgram(this.transformFeedbackProgram);
      this.transformFeedbackProgram = null;
    }
    if (this.particleVboA) {
      gl.deleteBuffer(this.particleVboA);
      this.particleVboA = null;
    }
    if (this.particleVboB) {
      gl.deleteBuffer(this.particleVboB);
      this.particleVboB = null;
    }
    if (this.vaoA) {
      gl.deleteVertexArray(this.vaoA);
      this.vaoA = null;
    }
    if (this.vaoB) {
      gl.deleteVertexArray(this.vaoB);
      this.vaoB = null;
    }
    if (this.transformFeedbackA) {
      gl.deleteTransformFeedback(this.transformFeedbackA);
      this.transformFeedbackA = null;
    }
    if (this.transformFeedbackB) {
      gl.deleteTransformFeedback(this.transformFeedbackB);
      this.transformFeedbackB = null;
    }
    this.forceFieldTexture?.dispose();
    this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(enabled) {
    if (enabled && !this.gpuPhysicsInitialized) {
      this.initializeGPUPhysics();
    }
    this.useGPUPhysics = enabled && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const resolution = 256;
    const sizeData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, sizeData);
    this.sizeOverLifetimeTexture = new DataTexture(
      sizeData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.sizeOverLifetimeTexture.needsUpdate = true;
    const opacityData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, opacityData);
    this.opacityOverLifetimeTexture = new DataTexture(
      opacityData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.opacityOverLifetimeTexture.needsUpdate = true;
    const colorStops = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ];
    const colorData = new Float32Array(resolution * 4);
    for (let i = 0; i < resolution; i++) {
      const t = i / (resolution - 1);
      const color = this.sampleColorGradient(colorStops, t);
      colorData[i * 4] = color[0];
      colorData[i * 4 + 1] = color[1];
      colorData[i * 4 + 2] = color[2];
      colorData[i * 4 + 3] = color[3];
    }
    this.colorOverLifetimeTexture = new DataTexture(
      colorData,
      resolution,
      1,
      RGBAFormat,
      FloatType
    );
    this.colorOverLifetimeTexture.needsUpdate = true;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(curve, output) {
    const len = output.length;
    if (!curve) {
      output.fill(1);
      return;
    }
    for (let i = 0; i < len; i++) {
      const t = i / (len - 1);
      output[i] = this.evaluateModulationCurve(curve, t);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(curve, t) {
    switch (curve.type) {
      case "constant":
        return curve.value;
      case "linear":
        return curve.start + (curve.end - curve.start) * t;
      case "curve": {
        const points = curve.points;
        if (points.length === 0) return 1;
        if (points.length === 1) return points[0].value;
        let p0 = points[0];
        let p1 = points[points.length - 1];
        for (let i = 0; i < points.length - 1; i++) {
          if (t >= points[i].time && t <= points[i + 1].time) {
            p0 = points[i];
            p1 = points[i + 1];
            break;
          }
        }
        const localT = (t - p0.time) / (p1.time - p0.time);
        const t2 = localT * localT;
        const t3 = t2 * localT;
        const h1 = 2 * t3 - 3 * t2 + 1;
        const h2 = -2 * t3 + 3 * t2;
        const h3 = t3 - 2 * t2 + localT;
        const h4 = t3 - t2;
        return h1 * p0.value + h2 * p1.value + h3 * (p0.outTangent ?? 0) + h4 * (p1.inTangent ?? 0);
      }
      case "random":
        return curve.min + this.rng() * (curve.max - curve.min);
      case "randomCurve": {
        const min = this.evaluateModulationCurve(curve.minCurve, t);
        const max = this.evaluateModulationCurve(curve.maxCurve, t);
        return min + this.rng() * (max - min);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(stops, t) {
    if (stops.length === 0) return [1, 1, 1, 1];
    if (stops.length === 1) return stops[0].color;
    let s0 = stops[0];
    let s1 = stops[stops.length - 1];
    for (let i = 0; i < stops.length - 1; i++) {
      if (t >= stops[i].time && t <= stops[i + 1].time) {
        s0 = stops[i];
        s1 = stops[i + 1];
        break;
      }
    }
    const localT = (t - s0.time) / (s1.time - s0.time);
    return [
      s0.color[0] + (s1.color[0] - s0.color[0]) * localT,
      s0.color[1] + (s1.color[1] - s0.color[1]) * localT,
      s0.color[2] + (s1.color[2] - s0.color[2]) * localT,
      s0.color[3] + (s1.color[3] - s0.color[3]) * localT
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const quadVertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    const quadUVs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new InstancedBufferGeometry();
    this.instancedGeometry.setAttribute("position", new BufferAttribute(quadVertices, 2));
    this.instancedGeometry.setAttribute("uv", new BufferAttribute(quadUVs, 2));
    const positionAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const velocityAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const lifeAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const physicalAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const rotationAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const colorAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    positionAttr.setUsage(DynamicDrawUsage);
    velocityAttr.setUsage(DynamicDrawUsage);
    lifeAttr.setUsage(DynamicDrawUsage);
    physicalAttr.setUsage(DynamicDrawUsage);
    rotationAttr.setUsage(DynamicDrawUsage);
    colorAttr.setUsage(DynamicDrawUsage);
    this.instancedGeometry.setAttribute("i_position", positionAttr);
    this.instancedGeometry.setAttribute("i_velocity", velocityAttr);
    this.instancedGeometry.setAttribute("i_life", lifeAttr);
    this.instancedGeometry.setAttribute("i_physical", physicalAttr);
    this.instancedGeometry.setAttribute("i_rotation", rotationAttr);
    this.instancedGeometry.setAttribute("i_color", colorAttr);
    this.material = new ShaderMaterial({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: true,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    });
    this.particleMesh = new Mesh(this.instancedGeometry, this.material);
    this.particleMesh.frustumCulled = false;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, {
      ...config,
      accumulator: 0,
      velocity: new Vector3()
    });
    this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(config) {
    this.forceFields.set(config.id, config);
  }
  updateForceField(id, updates) {
    const field = this.forceFields.get(id);
    if (field) {
      Object.assign(field, updates);
    }
  }
  removeForceField(id) {
    this.forceFields.delete(id);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(config) {
    this.subEmitters.set(config.id, config);
  }
  removeSubEmitter(id) {
    this.subEmitters.delete(id);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(deltaTime) {
    const startTime = performance.now();
    const dt = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : deltaTime * this.config.timeScale;
    this.emitParticles(dt);
    if (this.useGPUPhysics && this.gl) {
      this.updatePhysicsGPU(dt);
    } else {
      this.updatePhysics(dt);
    }
    this.processSubEmitters();
    if (this.config.flocking?.enabled) {
      this.updateSpatialHash();
      this.applyFlocking(dt);
    }
    this.applyAudioModulation();
    this.updateInstanceBuffers();
    this.state.simulationTime += dt;
    this.state.frameCount++;
    this.state.updateTimeMs = performance.now() - startTime;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(dt) {
    for (const emitter of this.emitters.values()) {
      if (!emitter.enabled) continue;
      let emissionRate = emitter.emissionRate;
      const audioMod = this.getAudioModulation("emitter", emitter.id, "emissionRate");
      if (audioMod !== void 0) {
        emissionRate *= audioMod;
      }
      if (emitter.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const burstCount = Math.floor(emitter.burstCount * emitter.beatEmissionMultiplier);
        for (let i = 0; i < burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
      emitter.accumulator += emissionRate * dt;
      while (emitter.accumulator >= 1) {
        this.spawnParticle(emitter);
        emitter.accumulator -= 1;
      }
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(emitter) {
    if (this.freeIndices.length === 0) {
      let oldestIndex = 0;
      let oldestAge = 0;
      const buffer2 = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let i = 0; i < this.config.maxParticles; i++) {
        const age = buffer2[i * PARTICLE_STRIDE + 6];
        if (age > oldestAge) {
          oldestAge = age;
          oldestIndex = i;
        }
      }
      this.freeIndices.push(oldestIndex);
    }
    const index = this.freeIndices.pop();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const offset = index * PARTICLE_STRIDE;
    const pos = this.getEmitterPosition(emitter);
    const dir = this.getEmissionDirection(emitter);
    const speed = emitter.initialSpeed + (this.rng() - 0.5) * 2 * emitter.speedVariance;
    const inheritVel = emitter.velocity.clone().multiplyScalar(emitter.inheritEmitterVelocity);
    buffer[offset + 0] = pos.x;
    buffer[offset + 1] = pos.y;
    buffer[offset + 2] = pos.z;
    buffer[offset + 3] = dir.x * speed + inheritVel.x;
    buffer[offset + 4] = dir.y * speed + inheritVel.y;
    buffer[offset + 5] = dir.z * speed + inheritVel.z;
    buffer[offset + 6] = 0;
    buffer[offset + 7] = emitter.lifetime + (this.rng() - 0.5) * 2 * emitter.lifetimeVariance;
    buffer[offset + 8] = emitter.initialMass + (this.rng() - 0.5) * 2 * emitter.massVariance;
    buffer[offset + 9] = emitter.initialSize + (this.rng() - 0.5) * 2 * emitter.sizeVariance;
    buffer[offset + 10] = emitter.initialRotation + this.rng() * emitter.rotationVariance;
    buffer[offset + 11] = emitter.initialAngularVelocity + (this.rng() - 0.5) * 2 * emitter.angularVelocityVariance;
    const colorT = this.rng() * emitter.colorVariance;
    buffer[offset + 12] = emitter.colorStart[0] + (emitter.colorEnd[0] - emitter.colorStart[0]) * colorT;
    buffer[offset + 13] = emitter.colorStart[1] + (emitter.colorEnd[1] - emitter.colorStart[1]) * colorT;
    buffer[offset + 14] = emitter.colorStart[2] + (emitter.colorEnd[2] - emitter.colorStart[2]) * colorT;
    buffer[offset + 15] = emitter.colorStart[3];
    this.state.particleCount++;
    this.emit("particleBirth", { index, emitterId: emitter.id });
    return index;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(emitter) {
    const shape = emitter.shape;
    const base = new Vector3(emitter.position.x, emitter.position.y, emitter.position.z);
    switch (shape.type) {
      case "point":
        return base;
      case "circle": {
        const angle = this.rng() * Math.PI * 2;
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.sqrt(this.rng());
        }
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          0
        ));
      }
      case "sphere": {
        const theta = this.rng() * Math.PI * 2;
        const phi = Math.acos(2 * this.rng() - 1);
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.cbrt(this.rng());
        }
        return base.add(new Vector3(
          Math.sin(phi) * Math.cos(theta) * radius,
          Math.sin(phi) * Math.sin(theta) * radius,
          Math.cos(phi) * radius
        ));
      }
      case "box": {
        const size = shape.boxSize ?? { x: 100, y: 100, z: 100 };
        return base.add(new Vector3(
          (this.rng() - 0.5) * size.x,
          (this.rng() - 0.5) * size.y,
          (this.rng() - 0.5) * size.z
        ));
      }
      case "line": {
        const start = shape.lineStart ?? { x: -50, y: 0, z: 0 };
        const end = shape.lineEnd ?? { x: 50, y: 0, z: 0 };
        const t = this.rng();
        return base.add(new Vector3(
          start.x + (end.x - start.x) * t,
          start.y + (end.y - start.y) * t,
          start.z + (end.z - start.z) * t
        ));
      }
      case "cone": {
        const angle = this.rng() * Math.PI * 2;
        const t = this.rng();
        const radius = t * (shape.coneRadius ?? 50);
        const height = t * (shape.coneLength ?? 100);
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        ));
      }
      case "image": {
        if (!shape.imageData) return base;
        const { width, height, data } = shape.imageData;
        const threshold = shape.emissionThreshold ?? 0.1;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * width);
          const py = Math.floor(this.rng() * height);
          const idx = (py * width + px) * 4;
          const alpha = data[idx + 3] / 255;
          if (alpha > threshold) {
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              0
            ));
          }
        }
        return base;
      }
      case "depthEdge": {
        if (!shape.depthData || !shape.imageData) return base;
        const { width, height } = shape.imageData;
        const depthData = shape.depthData;
        const threshold = shape.emissionThreshold ?? 0.05;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * (width - 2)) + 1;
          const py = Math.floor(this.rng() * (height - 2)) + 1;
          const idx = py * width + px;
          const d = depthData[idx];
          const dLeft = depthData[idx - 1];
          const dRight = depthData[idx + 1];
          const dUp = depthData[idx - width];
          const dDown = depthData[idx + width];
          const gradX = Math.abs(dRight - dLeft);
          const gradY = Math.abs(dDown - dUp);
          const gradient = Math.sqrt(gradX * gradX + gradY * gradY);
          if (gradient > threshold) {
            const z = d * 500;
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              z
            ));
          }
        }
        return base;
      }
      default:
        return base;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(emitter) {
    const baseDir = new Vector3(
      emitter.emissionDirection.x,
      emitter.emissionDirection.y,
      emitter.emissionDirection.z
    ).normalize();
    if (emitter.emissionSpread <= 0) {
      return baseDir;
    }
    const spreadRad = emitter.emissionSpread * Math.PI / 180;
    const theta = this.rng() * Math.PI * 2;
    const phi = Math.acos(1 - this.rng() * (1 - Math.cos(spreadRad)));
    const up = Math.abs(baseDir.y) < 0.99 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0);
    const right = new Vector3().crossVectors(up, baseDir).normalize();
    const realUp = new Vector3().crossVectors(baseDir, right);
    return new Vector3().addScaledVector(baseDir, Math.cos(phi)).addScaledVector(right, Math.sin(phi) * Math.cos(theta)).addScaledVector(realUp, Math.sin(phi) * Math.sin(theta)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(dt) {
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = buffer[offset + 6];
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0 || age >= lifetime) continue;
      let px = buffer[offset + 0];
      let py = buffer[offset + 1];
      let pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      const mass = buffer[offset + 8];
      let fx = 0, fy = 0, fz = 0;
      for (const field of this.forceFields.values()) {
        if (!field.enabled) continue;
        const force = this.calculateForceField(field, px, py, pz, vx, vy, vz, mass);
        fx += force.x;
        fy += force.y;
        fz += force.z;
      }
      const ax = fx / Math.max(mass, 0.1);
      const ay = fy / Math.max(mass, 0.1);
      const az = fz / Math.max(mass, 0.1);
      vx += ax * dt;
      vy += ay * dt;
      vz += az * dt;
      px += vx * dt;
      py += vy * dt;
      pz += vz * dt;
      const lifeRatio = age / lifetime;
      const sizeMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const opacityMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const rotation = buffer[offset + 10] + buffer[offset + 11] * dt;
      buffer[offset + 0] = px;
      buffer[offset + 1] = py;
      buffer[offset + 2] = pz;
      buffer[offset + 3] = vx;
      buffer[offset + 4] = vy;
      buffer[offset + 5] = vz;
      buffer[offset + 6] = age + dt;
      buffer[offset + 9] *= sizeMod;
      buffer[offset + 10] = rotation;
      buffer[offset + 15] *= opacityMod;
      if (age + dt >= lifetime) {
        this.freeIndices.push(i);
        this.state.particleCount--;
        this.emit("particleDeath", { index: i });
      }
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(dt) {
    if (!this.gl || !this.transformFeedbackProgram) return;
    const gl = this.gl;
    this.updateForceFieldTexture();
    gl.useProgram(this.transformFeedbackProgram);
    const dtLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime");
    const timeLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_time");
    const ffCountLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount");
    const ffTexLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    gl.uniform1f(dtLoc, dt);
    gl.uniform1f(timeLoc, this.state.simulationTime);
    gl.uniform1i(ffCountLoc, Math.min(this.forceFields.size, MAX_FORCE_FIELDS));
    if (this.forceFieldTexture) {
      gl.activeTexture(gl.TEXTURE0);
      const textureProps = this.renderer?.properties.get(this.forceFieldTexture);
      const tex = textureProps?.__webglTexture;
      if (tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(ffTexLoc, 0);
      }
    }
    const readVAO = this.currentBuffer === "A" ? this.vaoA : this.vaoB;
    const writeTF = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB;
    const writeVBO = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    gl.bindVertexArray(readVAO);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, writeTF);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, this.config.maxParticles);
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    this.currentBuffer = this.currentBuffer === "A" ? "B" : "A";
    if (this.state.frameCount % 10 === 0) {
      this.readBackParticleData(writeVBO);
    }
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let fieldIndex = 0;
    for (const field of this.forceFields.values()) {
      if (fieldIndex >= MAX_FORCE_FIELDS) break;
      if (!field.enabled) continue;
      const baseOffset = fieldIndex * 16;
      this.forceFieldBuffer[baseOffset + 0] = field.position.x;
      this.forceFieldBuffer[baseOffset + 1] = field.position.y;
      this.forceFieldBuffer[baseOffset + 2] = field.position.z;
      this.forceFieldBuffer[baseOffset + 3] = this.getForceFieldTypeIndex(field.type);
      this.forceFieldBuffer[baseOffset + 4] = field.strength;
      this.forceFieldBuffer[baseOffset + 5] = field.falloffStart;
      this.forceFieldBuffer[baseOffset + 6] = field.falloffEnd;
      this.forceFieldBuffer[baseOffset + 7] = this.getFalloffTypeIndex(field.falloffType);
      this.forceFieldBuffer[baseOffset + 8] = field.direction?.x ?? field.vortexAxis?.x ?? field.windDirection?.x ?? 0;
      this.forceFieldBuffer[baseOffset + 9] = field.direction?.y ?? field.vortexAxis?.y ?? field.windDirection?.y ?? 0;
      this.forceFieldBuffer[baseOffset + 10] = field.direction?.z ?? field.vortexAxis?.z ?? field.windDirection?.z ?? 0;
      this.forceFieldBuffer[baseOffset + 11] = field.inwardForce ?? 0;
      this.forceFieldBuffer[baseOffset + 12] = field.noiseScale ?? field.linearDrag ?? field.gustStrength ?? 0;
      this.forceFieldBuffer[baseOffset + 13] = field.noiseSpeed ?? field.quadraticDrag ?? field.gustFrequency ?? 0;
      this.forceFieldBuffer[baseOffset + 14] = 0;
      this.forceFieldBuffer[baseOffset + 15] = 0;
      fieldIndex++;
    }
    this.forceFieldTexture.needsUpdate = true;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(type) {
    switch (type) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(type) {
    switch (type) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(vbo) {
    if (!this.gl || !vbo) return;
    const gl = this.gl;
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, targetBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    let activeCount = 0;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = targetBuffer[offset + 6];
      const lifetime = targetBuffer[offset + 7];
      if (lifetime > 0 && age < lifetime) {
        activeCount++;
      } else if (lifetime > 0 && age >= lifetime) {
        if (!this.freeIndices.includes(i)) {
          this.freeIndices.push(i);
          this.emit("particleDeath", { index: i });
        }
      }
    }
    this.state.particleCount = activeCount;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(field, px, py, pz, vx, vy, vz, mass) {
    const force = new Vector3();
    const dx = px - field.position.x;
    const dy = py - field.position.y;
    const dz = pz - field.position.z;
    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let falloff = 1;
    if (dist > field.falloffStart) {
      const t = Math.min((dist - field.falloffStart) / (field.falloffEnd - field.falloffStart), 1);
      switch (field.falloffType) {
        case "linear":
          falloff = 1 - t;
          break;
        case "quadratic":
          falloff = 1 - t * t;
          break;
        case "exponential":
          falloff = Math.exp(-t * 3);
          break;
        case "smoothstep":
          falloff = 1 - (3 * t * t - 2 * t * t * t);
          break;
      }
    }
    const strength = field.strength * falloff;
    switch (field.type) {
      case "gravity":
        force.set(
          (field.direction?.x ?? 0) * strength,
          (field.direction?.y ?? 1) * strength,
          (field.direction?.z ?? 0) * strength
        );
        break;
      case "point":
        if (dist > 1e-3) {
          const dir = new Vector3(-dx, -dy, -dz).normalize();
          force.copy(dir).multiplyScalar(strength / mass);
        }
        break;
      case "vortex":
        if (dist > 1e-3) {
          const axis = new Vector3(
            field.vortexAxis?.x ?? 0,
            field.vortexAxis?.y ?? 0,
            field.vortexAxis?.z ?? 1
          ).normalize();
          const toParticle = new Vector3(dx, dy, dz);
          const tangent = new Vector3().crossVectors(axis, toParticle).normalize();
          const inward = toParticle.normalize().multiplyScalar(-(field.inwardForce ?? 0));
          force.copy(tangent).multiplyScalar(strength).add(inward);
        }
        break;
      case "turbulence": {
        const scale = field.noiseScale ?? 0.01;
        const speed = field.noiseSpeed ?? 0.5;
        const time = this.state.simulationTime * speed;
        const nx = Math.sin(px * scale + time) * Math.cos(py * scale * 1.3) * strength;
        const ny = Math.sin(py * scale + time * 1.1) * Math.cos(pz * scale * 1.2) * strength;
        const nz = Math.sin(pz * scale + time * 0.9) * Math.cos(px * scale * 1.1) * strength;
        force.set(nx, ny, nz);
        break;
      }
      case "drag": {
        const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
        if (speed > 1e-3) {
          const dragMag = (field.linearDrag ?? 0.1) * speed + (field.quadraticDrag ?? 0.01) * speed * speed;
          force.set(-vx, -vy, -vz).normalize().multiplyScalar(-dragMag * strength);
        }
        break;
      }
      case "wind": {
        const windDir = new Vector3(
          field.windDirection?.x ?? 1,
          field.windDirection?.y ?? 0,
          field.windDirection?.z ?? 0
        ).normalize();
        const gust = Math.sin(this.state.simulationTime * (field.gustFrequency ?? 0.5)) * (field.gustStrength ?? 0);
        force.copy(windDir).multiplyScalar(strength + gust);
        break;
      }
      case "lorenz": {
        const sigma = field.lorenzSigma ?? 10;
        const rho = field.lorenzRho ?? 28;
        const beta = field.lorenzBeta ?? 2.667;
        force.set(
          sigma * (dy - dx),
          dx * (rho - dz) - dy,
          dx * dy - beta * dz
        ).multiplyScalar(strength * 0.01);
        break;
      }
    }
    return force;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const key = `${cellX},${cellY},${cellZ}`;
      if (!this.spatialHash.has(key)) {
        this.spatialHash.set(key, []);
      }
      this.spatialHash.get(key).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(dt) {
    const config = this.config.flocking;
    if (!config?.enabled) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const separation = new Vector3();
      const alignment = new Vector3();
      const cohesion = new Vector3();
      let separationCount = 0;
      let alignmentCount = 0;
      let cohesionCount = 0;
      for (let cx = cellX - 1; cx <= cellX + 1; cx++) {
        for (let cy = cellY - 1; cy <= cellY + 1; cy++) {
          for (let cz = cellZ - 1; cz <= cellZ + 1; cz++) {
            const neighbors = this.spatialHash.get(`${cx},${cy},${cz}`);
            if (!neighbors) continue;
            for (const j of neighbors) {
              if (j === i) continue;
              const jOffset = j * PARTICLE_STRIDE;
              const jx = buffer[jOffset + 0];
              const jy = buffer[jOffset + 1];
              const jz = buffer[jOffset + 2];
              const dx = px - jx;
              const dy = py - jy;
              const dz = pz - jz;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (dist < config.separationRadius && dist > 0) {
                separation.add(new Vector3(dx, dy, dz).divideScalar(dist));
                separationCount++;
              }
              if (dist < config.alignmentRadius) {
                alignment.add(new Vector3(
                  buffer[jOffset + 3],
                  buffer[jOffset + 4],
                  buffer[jOffset + 5]
                ));
                alignmentCount++;
              }
              if (dist < config.cohesionRadius) {
                cohesion.add(new Vector3(jx, jy, jz));
                cohesionCount++;
              }
            }
          }
        }
      }
      if (separationCount > 0) {
        separation.divideScalar(separationCount).normalize().multiplyScalar(config.separationWeight);
      }
      if (alignmentCount > 0) {
        alignment.divideScalar(alignmentCount).normalize().multiplyScalar(config.alignmentWeight);
      }
      if (cohesionCount > 0) {
        cohesion.divideScalar(cohesionCount);
        cohesion.sub(new Vector3(px, py, pz)).normalize().multiplyScalar(config.cohesionWeight);
      }
      const steering = separation.add(alignment).add(cohesion);
      if (steering.length() > config.maxForce) {
        steering.normalize().multiplyScalar(config.maxForce);
      }
      buffer[offset + 3] += steering.x * dt;
      buffer[offset + 4] += steering.y * dt;
      buffer[offset + 5] += steering.z * dt;
      const speed = Math.sqrt(
        buffer[offset + 3] ** 2 + buffer[offset + 4] ** 2 + buffer[offset + 5] ** 2
      );
      if (speed > config.maxSpeed) {
        const scale = config.maxSpeed / speed;
        buffer[offset + 3] *= scale;
        buffer[offset + 4] *= scale;
        buffer[offset + 5] *= scale;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const binding of this.config.audioBindings) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      const smoothed = featureValue;
      const t = (smoothed - binding.min) / (binding.max - binding.min);
      let output = binding.outputMin + t * (binding.outputMax - binding.outputMin);
      if (binding.curve === "exponential") {
        output = binding.outputMin + Math.pow(t, 2) * (binding.outputMax - binding.outputMin);
      } else if (binding.curve === "logarithmic") {
        output = binding.outputMin + Math.sqrt(t) * (binding.outputMax - binding.outputMin);
      }
      if (binding.target === "emitter") {
        const emitter = this.emitters.get(binding.targetId);
        if (emitter) {
          emitter[binding.parameter] = output;
        }
      } else if (binding.target === "forceField") {
        const field = this.forceFields.get(binding.targetId);
        if (field) {
          field[binding.parameter] = output;
        }
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(target, targetId, parameter) {
    for (const binding of this.config.audioBindings) {
      if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
        const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
        const t = (featureValue - binding.min) / (binding.max - binding.min);
        return binding.outputMin + t * (binding.outputMax - binding.outputMin);
      }
    }
    return void 0;
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.instancedGeometry.getAttribute("i_position");
    const velAttr = this.instancedGeometry.getAttribute("i_velocity");
    const lifeAttr = this.instancedGeometry.getAttribute("i_life");
    const physAttr = this.instancedGeometry.getAttribute("i_physical");
    const rotAttr = this.instancedGeometry.getAttribute("i_rotation");
    const colAttr = this.instancedGeometry.getAttribute("i_color");
    for (let i = 0; i < this.config.maxParticles; i++) {
      const src = i * PARTICLE_STRIDE;
      posAttr.setXYZ(i, buffer[src + 0], buffer[src + 1], buffer[src + 2]);
      velAttr.setXYZ(i, buffer[src + 3], buffer[src + 4], buffer[src + 5]);
      lifeAttr.setXY(i, buffer[src + 6], buffer[src + 7]);
      physAttr.setXY(i, buffer[src + 8], buffer[src + 9]);
      rotAttr.setXY(i, buffer[src + 10], buffer[src + 11]);
      colAttr.setXYZW(i, buffer[src + 12], buffer[src + 13], buffer[src + 14], buffer[src + 15]);
    }
    posAttr.needsUpdate = true;
    velAttr.needsUpdate = true;
    lifeAttr.needsUpdate = true;
    physAttr.needsUpdate = true;
    rotAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(feature, value) {
    this.audioFeatures.set(feature, value);
    this.state.currentAudioFeatures.set(feature, value);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1);
    requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(emitterId) {
    if (emitterId) {
      const emitter = this.emitters.get(emitterId);
      if (emitter) {
        for (let i = 0; i < emitter.burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
    } else {
      for (const emitter of this.emitters.values()) {
        if (emitter.burstOnBeat && emitter.enabled) {
          for (let i = 0; i < emitter.burstCount; i++) {
            this.spawnParticle(emitter);
          }
        }
      }
    }
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return AdditiveBlending;
      case "multiply":
        return MultiplyBlending;
      case "screen":
        return CustomBlending;
      default:
        return NormalBlending;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(event, handler) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(event).add(handler);
  }
  off(event, handler) {
    this.eventHandlers.get(event)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => handler(event));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(seed) {
    let s = seed;
    return () => {
      s = s * 1103515245 + 12345 & 2147483647;
      return s / 2147483647;
    };
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    const emitters = Array.from(this.emitters.values()).map((e) => {
      const { accumulator, velocity, ...config } = e;
      return config;
    });
    return {
      emitters,
      forceFields: Array.from(this.forceFields.values())
    };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets RNG to initial seed for reproducible simulation
   */
  reset() {
    this.particleBufferA.fill(0);
    this.particleBufferB.fill(0);
    this.freeIndices = [];
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.state.particleCount = 0;
    this.state.simulationTime = 0;
    this.state.frameCount = 0;
    this.spatialHash.clear();
    this.rng = this.createSeededRandom(this.config.randomSeed ?? 12345);
  }
  /**
   * Get the current seed
   */
  getSeed() {
    return this.config.randomSeed ?? 12345;
  }
  /**
   * Set a new seed and reset the system
   * DETERMINISM: Used to ensure layer-specific reproducible seeds
   */
  setSeed(seed) {
    this.config.randomSeed = seed;
    this.reset();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.instancedGeometry?.dispose();
    this.material?.dispose();
    this.sizeOverLifetimeTexture?.dispose();
    this.opacityOverLifetimeTexture?.dispose();
    this.colorOverLifetimeTexture?.dispose();
    this.cleanupGPUPhysics();
    this.emitters.clear();
    this.forceFields.clear();
    this.subEmitters.clear();
    this.eventHandlers.clear();
  }
}

class ParticleLayer extends BaseLayer {
  /** The GPU particle system instance */
  particleSystem;
  /** Particle system configuration */
  systemConfig;
  /** Whether the system has been initialized with a renderer */
  initialized = false;
  /** Stored renderer reference for reinitialization */
  rendererRef = null;
  /** Composition FPS for time calculation */
  fps = 60;
  /** Deterministic seed derived from layer ID */
  layerSeed;
  /** Last evaluated frame (for scrub detection) */
  lastEvaluatedFrame = -1;
  /** Performance stats */
  stats = {
    particleCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0
  };
  constructor(layerData) {
    super(layerData);
    this.layerSeed = this.generateSeedFromId(layerData.id);
    this.systemConfig = this.buildSystemConfig(layerData);
    this.systemConfig.randomSeed = this.layerSeed;
    this.particleSystem = new GPUParticleSystem(this.systemConfig);
    this.initializeBlendMode();
  }
  /**
   * Generate deterministic seed from layer ID
   * DETERMINISM: Same layer ID always produces identical seed
   */
  generateSeedFromId(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash) || 12345;
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(layerData) {
    const data = layerData.data;
    const config = createDefaultConfig();
    if (!data) {
      config.emitters = [createDefaultEmitter("default")];
      return config;
    }
    if (data.systemConfig) {
      config.maxParticles = data.systemConfig.maxParticles ?? 1e5;
      config.timeScale = 1;
      if (data.systemConfig.gravity !== 0) {
        config.forceFields.push({
          id: "global_gravity",
          name: "Gravity",
          type: "gravity",
          enabled: true,
          strength: data.systemConfig.gravity * 10,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          direction: { x: 0, y: 1, z: 0 }
        });
      }
      if (data.systemConfig.windStrength !== 0) {
        const windAngle = (data.systemConfig.windDirection ?? 0) * Math.PI / 180;
        config.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: true,
          strength: data.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(windAngle),
            y: Math.sin(windAngle),
            z: 0
          },
          gustStrength: data.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (data.systemConfig.friction > 0) {
        config.forceFields.push({
          id: "global_drag",
          name: "Friction",
          type: "drag",
          enabled: true,
          strength: 1,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          linearDrag: data.systemConfig.friction,
          quadraticDrag: data.systemConfig.friction * 0.1
        });
      }
      if (data.systemConfig.turbulenceFields) {
        for (const turbField of data.systemConfig.turbulenceFields) {
          if (turbField.enabled) {
            config.forceFields.push({
              id: turbField.id,
              name: "Turbulence",
              type: "turbulence",
              enabled: true,
              strength: turbField.strength,
              position: { x: 0, y: 0, z: 0 },
              falloffStart: 0,
              falloffEnd: 1e4,
              falloffType: "none",
              noiseScale: turbField.scale,
              noiseSpeed: turbField.evolutionSpeed,
              noiseOctaves: 3,
              noiseLacunarity: 2,
              noiseGain: 0.5
            });
          }
        }
      }
    }
    if (data.emitters) {
      for (const emitter of data.emitters) {
        if (!emitter.enabled) continue;
        const dirRad = (emitter.direction ?? 0) * Math.PI / 180;
        const gpuEmitter = {
          id: emitter.id,
          name: emitter.name,
          enabled: true,
          position: { x: emitter.x, y: emitter.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: emitter.emissionRate,
          emissionRateVariance: 0,
          burstCount: emitter.burstCount,
          burstInterval: 0,
          initialSpeed: emitter.speed,
          speedVariance: emitter.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: emitter.size,
          sizeVariance: emitter.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: emitter.particleLifetime,
          lifetimeVariance: emitter.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            1
          ],
          colorEnd: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(dirRad),
            y: Math.sin(dirRad),
            z: 0
          },
          emissionSpread: emitter.spread,
          burstOnBeat: emitter.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        config.emitters.push(gpuEmitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        if (!well.enabled) continue;
        config.forceFields.push({
          id: well.id,
          name: well.name,
          type: "point",
          enabled: true,
          strength: well.strength,
          position: { x: well.x, y: well.y, z: 0 },
          falloffStart: 0,
          falloffEnd: well.radius,
          falloffType: well.falloff === "linear" ? "linear" : well.falloff === "quadratic" ? "quadratic" : "none"
        });
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        if (!vortex.enabled) continue;
        config.forceFields.push({
          id: vortex.id,
          name: vortex.name,
          type: "vortex",
          enabled: true,
          strength: vortex.strength * vortex.rotationSpeed,
          position: { x: vortex.x, y: vortex.y, z: 0 },
          falloffStart: 0,
          falloffEnd: vortex.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: vortex.inwardPull
        });
      }
    }
    if (data.modulations) {
      const sizeModulations = data.modulations.filter((m) => m.property === "size");
      if (sizeModulations.length > 0) {
        const mod = sizeModulations[0];
        config.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
      const opacityModulations = data.modulations.filter((m) => m.property === "opacity");
      if (opacityModulations.length > 0) {
        const mod = opacityModulations[0];
        config.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
    }
    if (data.renderOptions) {
      config.render.blendMode = data.renderOptions.blendMode ?? "normal";
      config.render.motionBlur = data.renderOptions.motionBlur ?? false;
      config.render.motionBlurStrength = data.renderOptions.motionBlurStrength ?? 0.5;
      config.render.motionBlurSamples = data.renderOptions.motionBlurSamples ?? 4;
      if (data.renderOptions.renderTrails) {
        config.render.mode = "trail";
        config.render.trailLength = data.renderOptions.trailLength;
        config.render.trailWidthEnd = 1 - (data.renderOptions.trailOpacityFalloff ?? 0.8);
      }
      config.render.texture.proceduralType = data.renderOptions.particleShape === "star" ? "star" : data.renderOptions.particleShape === "square" ? "square" : "circle";
    }
    return config;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(renderer) {
    if (this.initialized) return;
    this.rendererRef = renderer;
    this.particleSystem.initialize(renderer);
    this.initialized = true;
    const mesh = this.particleSystem.getMesh();
    if (mesh) {
      this.group.add(mesh);
    }
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    if (!this.initialized) {
      this.initializeWithRenderer(renderer);
    }
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(config) {
    const emitter = createDefaultEmitter();
    if (config) {
      Object.assign(emitter, config);
    }
    this.particleSystem.addEmitter(emitter);
    return emitter.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(id, updates) {
    this.particleSystem.updateEmitter(id, updates);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(id) {
    this.particleSystem.removeEmitter(id);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(type, config) {
    const field = createDefaultForceField(type);
    if (config) {
      Object.assign(field, config);
    }
    this.particleSystem.addForceField(field);
    return field.id;
  }
  /**
   * Update a force field
   */
  updateForceField(id, updates) {
    this.particleSystem.updateForceField(id, updates);
  }
  /**
   * Remove a force field
   */
  removeForceField(id) {
    this.particleSystem.removeForceField(id);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(feature, value) {
    this.particleSystem.setAudioFeature(feature, value);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(emitterId) {
    this.particleSystem.triggerBurst(emitterId);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(deltaTime) {
    if (!this.initialized) return;
    this.particleSystem.step(deltaTime);
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets to initial state with original seed
   */
  reset() {
    this.particleSystem.reset();
    this.lastEvaluatedFrame = -1;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const isSequential = frame === this.lastEvaluatedFrame + 1;
    const needsReplay = !isSequential && frame !== this.lastEvaluatedFrame;
    if (needsReplay) {
      this.particleSystem.reset();
      const deltaTime = 1 / this.fps;
      for (let f = 0; f < frame; f++) {
        this.particleSystem.step(deltaTime);
      }
    } else if (isSequential) {
      const deltaTime = 1 / this.fps;
      this.particleSystem.step(deltaTime);
    }
    this.lastEvaluatedFrame = frame;
    this.applyAudioReactivity();
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  onApplyEvaluatedState(state) {
    this.applyAudioReactivity();
  }
  /**
   * Evaluate particles at a specific frame (scrub-safe)
   * DETERMINISM: Returns identical results regardless of evaluation order
   */
  evaluateAtFrame(frame) {
    this.particleSystem.reset();
    const deltaTime = 1 / this.fps;
    for (let f = 0; f < frame; f++) {
      this.particleSystem.step(deltaTime);
    }
    this.lastEvaluatedFrame = frame;
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const emissionRate = this.getAudioReactiveValue("particle.emissionRate");
    const speed = this.getAudioReactiveValue("particle.speed");
    const size = this.getAudioReactiveValue("particle.size");
    const gravity = this.getAudioReactiveValue("particle.gravity");
    const windStrength = this.getAudioReactiveValue("particle.windStrength");
    if (emissionRate !== 0) {
      this.particleSystem.setAudioFeature("amplitude", emissionRate);
    }
    if (speed !== 0 || size !== 0 || emissionRate !== 0) {
      const emitters = this.particleSystem.getConfig().emitters;
      for (const emitter of emitters) {
        if (speed !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSpeed: emitter.initialSpeed * (0.5 + speed)
          });
        }
        if (size !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSize: emitter.initialSize * (0.5 + size)
          });
        }
      }
    }
    if (gravity !== 0 || windStrength !== 0) {
      const forceFields = this.particleSystem.getConfig().forceFields;
      for (const field of forceFields) {
        if (field.type === "gravity" && gravity !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + gravity)
          });
        }
        if (field.type === "wind" && windStrength !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + windStrength)
          });
        }
      }
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      const oldMesh = this.particleSystem.getMesh();
      if (oldMesh) {
        this.group.remove(oldMesh);
      }
      this.systemConfig = this.buildSystemConfig({
        ...properties,
        id: this.id,
        type: "particles"
      });
      this.systemConfig.randomSeed = this.layerSeed;
      this.particleSystem.dispose();
      this.particleSystem = new GPUParticleSystem(this.systemConfig);
      this.lastEvaluatedFrame = -1;
      if (this.rendererRef) {
        this.initialized = false;
        this.initializeWithRenderer(this.rendererRef);
      }
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}

class PrecompLayer extends BaseLayer {
  // Precomp data
  precompData;
  // Render context (provided by LayerManager)
  renderContext = null;
  // Display mesh
  mesh = null;
  material = null;
  // Cached render texture
  renderTexture = null;
  // Animation evaluator for time remap
  precompEvaluator;
  // Cached composition reference
  cachedComposition = null;
  // Parent composition FPS for frame rate conversion
  parentFPS = 30;
  constructor(layerData) {
    super(layerData);
    this.precompEvaluator = new KeyframeEvaluator();
    this.precompData = this.extractPrecompData(layerData);
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(layerData) {
    const data = layerData.data;
    return {
      compositionId: data?.compositionId ?? "",
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      collapseTransformations: data?.collapseTransformations ?? false,
      overrideFrameRate: data?.overrideFrameRate ?? false,
      frameRate: data?.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 4473924,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `precomp_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(context) {
    this.renderContext = context;
    this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(fps) {
    this.parentFPS = fps;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    if (!this.renderContext || !this.precompData.compositionId) {
      return;
    }
    this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    );
    if (this.cachedComposition) {
      this.resizeMesh(
        this.cachedComposition.settings.width,
        this.cachedComposition.settings.height
      );
    }
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(parentFrame) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const remappedTime = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, parentFrame) : this.precompData.timeRemap.value;
      const fps = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(remappedTime * fps);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const parentFps = this.parentFPS;
      const childFps = this.precompData.frameRate;
      return Math.floor(parentFrame * (childFps / parentFps));
    }
    return parentFrame;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.renderContext || !this.cachedComposition) {
      return;
    }
    const nestedFrame = this.calculateNestedFrame(frame);
    const clampedFrame = Math.max(
      0,
      Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      clampedFrame
    );
    if (this.material) {
      if (this.renderTexture) {
        this.material.map = this.renderTexture;
        this.material.color.setHex(16777215);
      } else {
        this.material.map = null;
        this.material.color.setHex(4473924);
      }
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      this.precompData.timeRemap.value = props["timeRemap"];
    }
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(compositionId) {
    this.precompData.compositionId = compositionId;
    this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(enabled) {
    this.precompData.timeRemapEnabled = enabled;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(timeRemap) {
    this.precompData.timeRemap = timeRemap;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(collapse) {
    this.precompData.collapseTransformations = collapse;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(override, fps) {
    this.precompData.overrideFrameRate = override;
    this.precompData.frameRate = fps;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.compositionId !== void 0) {
        this.setComposition(data.compositionId);
      }
      if (data.timeRemapEnabled !== void 0) {
        this.setTimeRemapEnabled(data.timeRemapEnabled);
      }
      if (data.timeRemap !== void 0) {
        this.setTimeRemap(data.timeRemap);
      }
      if (data.collapseTransformations !== void 0) {
        this.setCollapseTransformations(data.collapseTransformations);
      }
      if (data.overrideFrameRate !== void 0 || data.frameRate !== void 0) {
        this.setFrameRateOverride(
          data.overrideFrameRate ?? this.precompData.overrideFrameRate,
          data.frameRate ?? this.precompData.frameRate
        );
      }
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
    this.renderTexture = null;
    this.cachedComposition = null;
  }
}

class CameraLayer extends BaseLayer {
  // Camera data reference
  cameraData;
  // Callbacks to store
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Track current frame for interpolation
  currentFrame = 0;
  // Visual wireframe (shown in editor)
  wireframe = null;
  wireframeVisible = true;
  // Frustum visualization
  frustumHelper = null;
  showFrustum = true;
  // Track last camera state for frustum updates
  lastFrustumState = null;
  // Spline provider for path following
  splineProvider = null;
  // Auto-advance parameter (for autoAdvance mode)
  autoAdvanceT = 0;
  constructor(layerData) {
    super(layerData);
    this.threeD = true;
    this.cameraData = this.extractCameraData(layerData);
    this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(layerData) {
    const data = layerData.data;
    return {
      cameraId: data?.cameraId ?? "",
      isActiveCamera: data?.isActiveCamera ?? false,
      pathFollowing: data?.pathFollowing
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
  }
  /**
   * Set the spline provider for path following
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get path following configuration
   */
  getPathFollowing() {
    return this.cameraData.pathFollowing;
  }
  /**
   * Check if path following is active
   */
  isFollowingPath() {
    return this.cameraData.pathFollowing?.enabled ?? false;
  }
  /**
   * Reset auto-advance parameter (for deterministic scrubbing)
   */
  resetAutoAdvance() {
    this.autoAdvanceT = 0;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Group();
    this.wireframe.name = `camera_wireframe_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const bodySize = 40;
    const bodyGeometry = new BoxGeometry(bodySize, bodySize * 0.6, bodySize * 0.8);
    const bodyMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    this.wireframe.add(body);
    const coneGeometry = new ConeGeometry(bodySize * 0.3, bodySize * 0.6, 8);
    const coneMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.6,
      depthTest: false
    });
    const cone = new Mesh(coneGeometry, coneMaterial);
    cone.rotation.x = Math.PI / 2;
    cone.position.z = bodySize * 0.7;
    this.wireframe.add(cone);
    const planeGeometry = new PlaneGeometry(bodySize * 0.8, bodySize * 0.5);
    const planeMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.2,
      side: DoubleSide,
      depthTest: false
    });
    const plane = new Mesh(planeGeometry, planeMaterial);
    plane.position.z = -bodySize * 0.4;
    this.wireframe.add(plane);
    const upPoints = [
      new Vector3(0, bodySize * 0.4, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(-bodySize * 0.1, bodySize * 0.55, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(bodySize * 0.1, bodySize * 0.55, 0)
    ];
    const upGeometry = new BufferGeometry().setFromPoints(upPoints);
    const upMaterial = new LineBasicMaterial({
      color: 65280,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const upLine = new Line(upGeometry, upMaterial);
    this.wireframe.add(upLine);
    this.group.add(this.wireframe);
    this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const camera = this.getCamera();
    if (!camera) return;
    this.frustumHelper = new Group();
    this.frustumHelper.name = `camera_frustum_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const near = camera.nearClip;
    const far = Math.min(camera.farClip, 2e3);
    const fov = camera.angleOfView * (Math.PI / 180);
    const aspect = 16 / 9;
    const nearHeight = 2 * Math.tan(fov / 2) * near;
    const nearWidth = nearHeight * aspect;
    const farHeight = 2 * Math.tan(fov / 2) * far;
    const farWidth = farHeight * aspect;
    const frustumMaterial = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.3,
      depthTest: false
    });
    const nearTL = new Vector3(-nearWidth / 2, nearHeight / 2, near);
    const nearTR = new Vector3(nearWidth / 2, nearHeight / 2, near);
    const nearBL = new Vector3(-nearWidth / 2, -nearHeight / 2, near);
    const nearBR = new Vector3(nearWidth / 2, -nearHeight / 2, near);
    const farTL = new Vector3(-farWidth / 2, farHeight / 2, far);
    const farTR = new Vector3(farWidth / 2, farHeight / 2, far);
    const farBL = new Vector3(-farWidth / 2, -farHeight / 2, far);
    const farBR = new Vector3(farWidth / 2, -farHeight / 2, far);
    const nearPlane = new BufferGeometry().setFromPoints([
      nearTL,
      nearTR,
      nearBR,
      nearBL,
      nearTL
    ]);
    this.frustumHelper.add(new Line(nearPlane, frustumMaterial));
    const farPlane = new BufferGeometry().setFromPoints([
      farTL,
      farTR,
      farBR,
      farBL,
      farTL
    ]);
    this.frustumHelper.add(new Line(farPlane, frustumMaterial));
    const edges = [
      [nearTL, farTL],
      [nearTR, farTR],
      [nearBL, farBL],
      [nearBR, farBR]
    ];
    for (const [start, end] of edges) {
      const edgeGeom = new BufferGeometry().setFromPoints([start, end]);
      this.frustumHelper.add(new Line(edgeGeom, frustumMaterial));
    }
    this.group.add(this.frustumHelper);
    this.frustumHelper.renderOrder = 997;
    this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        const material = child.material;
        if (material.color.getHex() === 65280) return;
        material.color.setHex(color);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    if (!this.cameraGetter || !this.cameraData.cameraId) return null;
    return this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    if (!this.cameraData.cameraId) return null;
    if (this.cameraAtFrameGetter) {
      return this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame);
    }
    return this.getCamera();
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(active) {
    this.cameraData.isActiveCamera = active;
    this.updateWireframeColor();
    if (this.frustumHelper) {
      this.group.remove(this.frustumHelper);
      this.disposeFrustum();
      this.createFrustum();
    }
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(visible) {
    this.wireframeVisible = visible;
    if (this.wireframe) {
      this.wireframe.visible = visible;
    }
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(visible) {
    this.showFrustum = visible;
    if (this.frustumHelper) {
      this.frustumHelper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return;
    const degToRad = Math.PI / 180;
    const pathFollowing = this.cameraData.pathFollowing;
    const usePathFollowing = pathFollowing?.enabled && pathFollowing.pathLayerId && this.splineProvider;
    if (usePathFollowing && pathFollowing) {
      this.applyPathFollowing(frame, pathFollowing, camera);
    } else {
      this.group.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
      );
      if (camera.type === "two-node" && camera.pointOfInterest) {
        const poi = new Vector3(
          camera.pointOfInterest.x,
          camera.pointOfInterest.y,
          camera.pointOfInterest.z
        );
        this.group.lookAt(poi);
        this.group.rotation.z += camera.zRotation * degToRad;
      } else {
        this.group.rotation.set(
          (camera.orientation.x + camera.xRotation) * degToRad,
          (camera.orientation.y + camera.yRotation) * degToRad,
          (camera.orientation.z + camera.zRotation) * degToRad,
          "YXZ"
          // Standard After Effects rotation order
        );
      }
    }
    const currentState = {
      fov: camera.angleOfView,
      near: camera.nearClip,
      far: camera.farClip
    };
    const needsFrustumUpdate = !this.lastFrustumState || this.lastFrustumState.fov !== currentState.fov || this.lastFrustumState.near !== currentState.near || this.lastFrustumState.far !== currentState.far;
    if (needsFrustumUpdate) {
      if (this.frustumHelper) {
        this.group.remove(this.frustumHelper);
        this.disposeFrustum();
      }
      this.createFrustum();
      this.lastFrustumState = currentState;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pathParameter"] !== void 0 && this.cameraData.pathFollowing?.enabled) {
      this.cameraData.pathFollowing.parameter.value = props["pathParameter"];
    }
  }
  /**
   * Apply path following to camera position and orientation
   * DETERMINISM: Uses interpolateProperty for animated parameter
   */
  applyPathFollowing(frame, pathFollowing, camera) {
    if (!this.splineProvider) return;
    let t;
    if (pathFollowing.autoAdvance) {
      t = frame * pathFollowing.autoAdvanceSpeed % 1;
    } else {
      t = interpolateProperty(pathFollowing.parameter, frame);
    }
    t = Math.max(0, Math.min(1, t));
    const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);
    if (!pathResult) {
      this.group.position.set(camera.position.x, camera.position.y, camera.position.z);
      return;
    }
    let lookTarget = null;
    if (pathFollowing.alignToPath && pathFollowing.lookAhead > 0) {
      const lookAheadT = Math.min(1, t + pathFollowing.lookAhead);
      lookTarget = this.splineProvider(pathFollowing.pathLayerId, lookAheadT, frame);
    }
    const position = new Vector3(
      pathResult.point.x,
      pathResult.point.y + pathFollowing.offsetY,
      pathResult.point.z
    );
    this.group.position.copy(position);
    if (pathFollowing.alignToPath) {
      if (lookTarget) {
        const target = new Vector3(
          lookTarget.point.x,
          lookTarget.point.y + pathFollowing.offsetY,
          lookTarget.point.z
        );
        this.group.lookAt(target);
      } else {
        const tangent = new Vector3(
          pathResult.tangent.x,
          pathResult.tangent.y,
          0
        ).normalize();
        const forward = new Vector3(0, 0, 1);
        const quaternion = new Quaternion();
        quaternion.setFromUnitVectors(forward, tangent);
        this.group.quaternion.copy(quaternion);
      }
      if (pathFollowing.bankingStrength > 0) {
        const epsilon = 0.01;
        const tBefore = Math.max(0, t - epsilon);
        const tAfter = Math.min(1, t + epsilon);
        const before = this.splineProvider(pathFollowing.pathLayerId, tBefore, frame);
        const after = this.splineProvider(pathFollowing.pathLayerId, tAfter, frame);
        if (before && after) {
          const tangent1 = new Vector2(before.tangent.x, before.tangent.y).normalize();
          const tangent2 = new Vector2(after.tangent.x, after.tangent.y).normalize();
          const cross = tangent1.x * tangent2.y - tangent1.y * tangent2.x;
          const bankAngle = cross * pathFollowing.bankingStrength * Math.PI / 4;
          this.group.rotateZ(bankAngle);
        }
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.cameraId !== void 0) {
        this.cameraData.cameraId = data.cameraId;
        if (this.frustumHelper) {
          this.group.remove(this.frustumHelper);
          this.disposeFrustum();
        }
        this.createFrustum();
      }
      if (data.isActiveCamera !== void 0) {
        this.setActiveCamera(data.isActiveCamera);
      }
      if (data.pathFollowing !== void 0) {
        this.cameraData.pathFollowing = data.pathFollowing;
        if (data.pathFollowing?.autoAdvance) {
          this.autoAdvanceT = 0;
        }
      }
    }
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return null;
    return {
      position: { ...camera.position },
      rotation: {
        x: camera.orientation.x + camera.xRotation,
        y: camera.orientation.y + camera.yRotation,
        z: camera.orientation.z + camera.zRotation
      },
      fov: camera.angleOfView,
      focalLength: camera.focalLength,
      nearClip: camera.nearClip,
      farClip: camera.farClip
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    if (!this.wireframe) return;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.wireframe.clear();
    this.wireframe = null;
  }
  disposeFrustum() {
    if (!this.frustumHelper) return;
    this.frustumHelper.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.frustumHelper.clear();
    this.frustumHelper = null;
  }
  onDispose() {
    this.disposeWireframe();
    this.disposeFrustum();
  }
}

/**
 *  This helper must be added as a child of the light
 */

class RectAreaLightHelper extends Line {

	constructor( light, color ) {

		const positions = [ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		const material = new LineBasicMaterial( { fog: false } );

		super( geometry, material );

		this.light = light;
		this.color = color; // optional hardwired color for the helper
		this.type = 'RectAreaLightHelper';

		//

		const positions2 = [ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

	}

	updateMatrixWorld() {

		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );
			this.children[ 0 ].material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			// prevent hue shift
			const c = this.material.color;
			const max = Math.max( c.r, c.g, c.b );
			if ( max > 1 ) c.multiplyScalar( 1 / max );

			this.children[ 0 ].material.color.copy( this.material.color );

		}

		// ignore world scale on light
		this.matrixWorld.extractRotation( this.light.matrixWorld ).scale( this.scale ).copyPosition( this.light.matrixWorld );

		this.children[ 0 ].matrixWorld.copy( this.matrixWorld );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

/**
 * Uniforms library for RectAreaLight shared webgl shaders
 *
 * NOTE: This is a temporary location for the BRDF approximation texture data
 *       based off of Eric Heitz's work (see citation below).  BRDF data for
 *       RectAreaLight is currently approximated using a precomputed texture
 *       of roughly 80kb in size.  The hope is to find a better way to include
 *       the large texture data before including the full RectAreaLight implementation
 *       in the main build files.
 *
 * TODO: figure out a way to compress the LTC BRDF data
 */

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

class RectAreaLightTexturesLib {

	static init() {

		// source: https://github.com/selfshadow/ltc_code/tree/master/fit/results/ltc.js

		const LTC_MAT_1 = [ 1, 0, 0, 2e-05, 1, 0, 0, 0.000503905, 1, 0, 0, 0.00201562, 1, 0, 0, 0.00453516, 1, 0, 0, 0.00806253, 1, 0, 0, 0.0125978, 1, 0, 0, 0.018141, 1, 0, 0, 0.0246924, 1, 0, 0, 0.0322525, 1, 0, 0, 0.0408213, 1, 0, 0, 0.0503999, 1, 0, 0, 0.0609894, 1, 0, 0, 0.0725906, 1, 0, 0, 0.0852058, 1, 0, 0, 0.0988363, 1, 0, 0, 0.113484, 1, 0, 0, 0.129153, 1, 0, 0, 0.145839, 1, 0, 0, 0.163548, 1, 0, 0, 0.182266, 1, 0, 0, 0.201942, 1, 0, 0, 0.222314, 1, 0, 0, 0.241906, 1, 0, 0, 0.262314, 1, 0, 0, 0.285754, 1, 0, 0, 0.310159, 1, 0, 0, 0.335426, 1, 0, 0, 0.361341, 1, 0, 0, 0.387445, 1, 0, 0, 0.412784, 1, 0, 0, 0.438197, 1, 0, 0, 0.466966, 1, 0, 0, 0.49559, 1, 0, 0, 0.523448, 1, 0, 0, 0.549938, 1, 0, 0, 0.57979, 1, 0, 0, 0.608746, 1, 0, 0, 0.636185, 1, 0, 0, 0.664748, 1, 0, 0, 0.69313, 1, 0, 0, 0.71966, 1, 0, 0, 0.747662, 1, 0, 0, 0.774023, 1, 0, 0, 0.799775, 1, 0, 0, 0.825274, 1, 0, 0, 0.849156, 1, 0, 0, 0.873248, 1, 0, 0, 0.89532, 1, 0, 0, 0.917565, 1, 0, 0, 0.937863, 1, 0, 0, 0.958139, 1, 0, 0, 0.976563, 1, 0, 0, 0.994658, 1, 0, 0, 1.0112, 1, 0, 0, 1.02712, 1, 0, 0, 1.04189, 1, 0, 0, 1.05568, 1, 0, 0, 1.06877, 1, 0, 0, 1.08058, 1, 0, 0, 1.09194, 1, 0, 0, 1.10191, 1, 0, 0, 1.11161, 1, 0, 0, 1.1199, 1, 0, 0, 1.12813, 0.999547, -4.48815e-7, 0.0224417, 1.99902e-05, 0.999495, -113079e-10, 0.0224406, 0.000503651, 0.999496, -452317e-10, 0.0224406, 0.00201461, 0.999496, -101772e-9, 0.0224406, 0.00453287, 0.999495, -180928e-9, 0.0224406, 0.00805845, 0.999497, -282702e-9, 0.0224406, 0.0125914, 0.999496, -407096e-9, 0.0224406, 0.0181319, 0.999498, -554114e-9, 0.0224406, 0.02468, 0.999499, -723768e-9, 0.0224406, 0.0322363, 0.999495, -916058e-9, 0.0224405, 0.0408009, 0.999499, -113101e-8, 0.0224408, 0.050375, 0.999494, -136863e-8, 0.0224405, 0.0609586, 0.999489, -162896e-8, 0.0224401, 0.0725537, 0.999489, -191201e-8, 0.0224414, 0.0851619, 0.999498, -221787e-8, 0.0224413, 0.0987867, 0.999492, -254642e-8, 0.0224409, 0.113426, 0.999507, -289779e-8, 0.0224417, 0.129088, 0.999494, -32716e-7, 0.0224386, 0.145767, 0.999546, -36673e-7, 0.0224424, 0.163472, 0.999543, -408166e-8, 0.0224387, 0.182182, 0.999499, -450056e-8, 0.0224338, 0.201843, 0.999503, -483661e-8, 0.0224203, 0.222198, 0.999546, -452928e-8, 0.022315, 0.241714, 0.999508, -587403e-8, 0.0224329, 0.262184, 0.999509, -638806e-8, 0.0224271, 0.285609, 0.999501, -691028e-8, 0.0224166, 0.309998, 0.999539, -741979e-8, 0.0223989, 0.335262, 0.999454, -786282e-8, 0.0223675, 0.361154, 0.999529, -811928e-8, 0.0222828, 0.387224, 0.999503, -799941e-8, 0.0221063, 0.41252, 0.999561, -952753e-8, 0.0223057, 0.438006, 0.999557, -99134e-7, 0.0222065, 0.466735, 0.999541, -0.0100935, 0.0220402, 0.495332, 0.999562, -996821e-8, 0.0218067, 0.523197, 0.999556, -0.0105031, 0.0217096, 0.550223, 0.999561, -0.0114191, 0.0217215, 0.579498, 0.999588, -0.0111818, 0.0213357, 0.608416, 0.999633, -0.0107725, 0.0208689, 0.635965, 0.999527, -0.0121671, 0.0210149, 0.664476, 0.999508, -0.0116005, 0.020431, 0.692786, 0.999568, -0.0115604, 0.0199791, 0.719709, 0.999671, -0.0121117, 0.0197415, 0.74737, 0.999688, -0.0110769, 0.0188846, 0.773692, 0.99962, -0.0122368, 0.0188452, 0.799534, 0.999823, -0.0110325, 0.0178001, 0.825046, 0.999599, -0.0114923, 0.0174221, 0.849075, 0.999619, -0.0105923, 0.0164345, 0.872999, 0.999613, -0.0105988, 0.0158227, 0.895371, 0.99964, -979861e-8, 0.0148131, 0.917364, 0.99977, -967238e-8, 0.0140721, 0.938002, 0.999726, -869175e-8, 0.0129543, 0.957917, 0.99973, -866872e-8, 0.0122329, 0.976557, 0.999773, -731956e-8, 0.0108958, 0.994459, 0.999811, -756027e-8, 0.0102715, 1.01118, 0.999862, -583732e-8, 0.00878781, 1.02701, 0.999835, -631438e-8, 0.00827529, 1.04186, 0.999871, -450785e-8, 0.00674583, 1.05569, 0.999867, -486079e-8, 0.00621041, 1.06861, 0.999939, -322072e-8, 0.00478301, 1.08064, 0.999918, -318199e-8, 0.00406395, 1.09181, 1.00003, -193348e-8, 0.00280682, 1.10207, 0.999928, -153729e-8, 0.00198741, 1.11152, 0.999933, -623666e-9, 0.000917714, 1.12009, 1, -102387e-11, 9.07581e-07, 1.12813, 0.997866, -8.96716e-7, 0.0448334, 1.99584e-05, 0.997987, -225945e-10, 0.0448389, 0.000502891, 0.997987, -903781e-10, 0.0448388, 0.00201156, 0.997985, -203351e-9, 0.0448388, 0.00452602, 0.997986, -361514e-9, 0.0448388, 0.00804629, 0.997987, -56487e-8, 0.0448389, 0.0125724, 0.997988, -813423e-9, 0.0448389, 0.0181045, 0.997984, -110718e-8, 0.0448387, 0.0246427, 0.997985, -144616e-8, 0.0448388, 0.0321875, 0.997987, -183038e-8, 0.044839, 0.0407392, 0.997983, -225987e-8, 0.0448387, 0.0502986, 0.997991, -273467e-8, 0.0448389, 0.0608667, 0.997984, -325481e-8, 0.0448384, 0.0724444, 0.998002, -382043e-8, 0.044839, 0.0850348, 0.997997, -443145e-8, 0.0448396, 0.0986372, 0.998007, -508796e-8, 0.0448397, 0.113255, 0.998008, -578985e-8, 0.04484, 0.128891, 0.998003, -653683e-8, 0.0448384, 0.145548, 0.997983, -732713e-8, 0.0448358, 0.163221, 0.997985, -815454e-8, 0.0448358, 0.181899, 0.998005, -898985e-8, 0.0448286, 0.201533, 0.998026, -964404e-8, 0.0447934, 0.221821, 0.998055, -922677e-8, 0.044611, 0.241282, 0.99804, -0.0117361, 0.0448245, 0.261791, 0.998048, -0.0127628, 0.0448159, 0.285181, 0.998088, -0.0138055, 0.0447996, 0.30954, 0.998058, -0.0148206, 0.0447669, 0.334751, 0.998099, -0.0156998, 0.044697, 0.36061, 0.998116, -0.0161976, 0.0445122, 0.386603, 0.998195, -0.015945, 0.0441711, 0.411844, 0.998168, -0.0183947, 0.0444255, 0.43773, 0.998184, -0.0197913, 0.0443809, 0.466009, 0.998251, -0.0201426, 0.0440689, 0.494574, 0.998305, -0.0198847, 0.0435632, 0.522405, 0.998273, -0.0210577, 0.043414, 0.549967, 0.998254, -0.0227901, 0.0433943, 0.578655, 0.998349, -0.0223108, 0.0426529, 0.60758, 0.99843, -0.0223088, 0.042, 0.635524, 0.998373, -0.0241141, 0.0418987, 0.663621, 0.998425, -0.0231446, 0.0408118, 0.691906, 0.998504, -0.0233684, 0.0400565, 0.719339, 0.998443, -0.0241652, 0.0394634, 0.74643, 0.99848, -0.0228715, 0.0380002, 0.773086, 0.998569, -0.023519, 0.0372322, 0.798988, 0.998619, -0.0223108, 0.0356468, 0.824249, 0.998594, -0.0223105, 0.034523, 0.848808, 0.998622, -0.0213426, 0.0328887, 0.87227, 0.998669, -0.0207912, 0.0314374, 0.895157, 0.998705, -0.0198416, 0.0296925, 0.916769, 0.998786, -0.0189168, 0.0279634, 0.937773, 0.998888, -0.0178811, 0.0261597, 0.957431, 0.99906, -0.0166845, 0.0242159, 0.976495, 0.999038, -0.0155464, 0.0222638, 0.994169, 0.999237, -0.0141349, 0.0201967, 1.01112, 0.999378, -0.0129324, 0.0181744, 1.02692, 0.999433, -0.0113192, 0.0159898, 1.04174, 0.999439, -0.0101244, 0.0140385, 1.05559, 0.999614, -837456e-8, 0.0117826, 1.06852, 0.999722, -721769e-8, 0.00983745, 1.08069, 0.999817, -554067e-8, 0.00769002, 1.09176, 0.99983, -426961e-8, 0.005782, 1.10211, 0.999964, -273904e-8, 0.00374503, 1.11152, 1.00001, -136739e-8, 0.00187176, 1.12031, 0.999946, 3.93227e-05, -28919e-9, 1.12804, 0.995847, -13435e-10, 0.0671785, 1.9916e-05, 0.995464, -338387e-10, 0.0671527, 0.000501622, 0.99547, -135355e-9, 0.0671531, 0.00200649, 0.995471, -30455e-8, 0.0671532, 0.00451461, 0.99547, -541423e-9, 0.0671531, 0.008026, 0.995471, -84598e-8, 0.0671531, 0.0125407, 0.99547, -121823e-8, 0.0671531, 0.0180589, 0.99547, -165817e-8, 0.0671531, 0.0245806, 0.995463, -216583e-8, 0.0671526, 0.0321062, 0.995468, -274127e-8, 0.0671527, 0.0406366, 0.995474, -338447e-8, 0.0671534, 0.0501717, 0.995473, -409554e-8, 0.0671533, 0.0607131, 0.995478, -487451e-8, 0.0671531, 0.0722618, 0.995476, -572148e-8, 0.0671532, 0.0848191, 0.995477, -663658e-8, 0.0671539, 0.0983882, 0.995498, -761986e-8, 0.0671541, 0.112972, 0.995509, -867094e-8, 0.0671542, 0.128568, 0.995509, -978951e-8, 0.0671531, 0.145183, 0.995503, -0.0109725, 0.0671491, 0.162808, 0.995501, -0.012211, 0.0671465, 0.181441, 0.99553, -0.0134565, 0.0671371, 0.201015, 0.99555, -0.014391, 0.0670831, 0.221206, 0.99558, -0.014351, 0.0668883, 0.240813, 0.995577, -0.0173997, 0.0671055, 0.261257, 0.995602, -0.0191111, 0.0671178, 0.284467, 0.995623, -0.0206705, 0.0670946, 0.308765, 0.995658, -0.022184, 0.0670472, 0.333905, 0.995705, -0.0234832, 0.0669417, 0.359677, 0.995719, -0.0241933, 0.0666714, 0.385554, 0.995786, -0.0243539, 0.066266, 0.410951, 0.995887, -0.0271866, 0.0664367, 0.437163, 0.995944, -0.0296012, 0.0664931, 0.464842, 0.996004, -0.0301045, 0.0660105, 0.49332, 0.996128, -0.0298311, 0.0652694, 0.521131, 0.996253, -0.0316426, 0.0650739, 0.549167, 0.996244, -0.0339043, 0.0649433, 0.57737, 0.996309, -0.033329, 0.0638926, 0.606073, 0.996417, -0.0338935, 0.0630849, 0.634527, 0.996372, -0.0353104, 0.0625083, 0.66256, 0.996542, -0.0348942, 0.0611986, 0.690516, 0.996568, -0.0351614, 0.060069, 0.718317, 0.996711, -0.0354317, 0.0588522, 0.74528, 0.996671, -0.0349513, 0.0571902, 0.772061, 0.996865, -0.0345622, 0.0555321, 0.798089, 0.996802, -0.0342566, 0.0537816, 0.823178, 0.996992, -0.0330862, 0.0516095, 0.847949, 0.996944, -0.0324666, 0.0495537, 0.871431, 0.997146, -0.0309544, 0.0470302, 0.894357, 0.997189, -0.0299372, 0.0446043, 0.916142, 0.997471, -0.0281389, 0.0418812, 0.937193, 0.997515, -0.0268702, 0.0391823, 0.957, 0.997812, -0.0247166, 0.0361338, 0.975936, 0.998027, -0.0233525, 0.0333945, 0.99391, 0.998233, -0.0209839, 0.0301917, 1.01075, 0.998481, -0.0194309, 0.027271, 1.02669, 0.998859, -0.0169728, 0.0240162, 1.04173, 0.99894, -0.0152322, 0.0210517, 1.05551, 0.999132, -0.0127497, 0.0178632, 1.06856, 0.999369, -0.0108282, 0.014787, 1.08054, 0.999549, -845886e-8, 0.0116185, 1.09185, 0.999805, -63937e-7, 0.00867209, 1.10207, 0.99985, -414582e-8, 0.00566823, 1.1117, 0.999912, -207443e-8, 0.00277562, 1.12022, 1.00001, 8.70226e-05, -53766e-9, 1.12832, 0.991943, -178672e-11, 0.0893382, 1.98384e-05, 0.991952, -450183e-10, 0.089339, 0.000499849, 0.991956, -180074e-9, 0.0893394, 0.0019994, 0.991955, -405167e-9, 0.0893393, 0.00449867, 0.991953, -720298e-9, 0.0893391, 0.00799764, 0.991955, -112548e-8, 0.0893393, 0.0124964, 0.991957, -16207e-7, 0.0893395, 0.0179951, 0.991958, -220601e-8, 0.0893396, 0.0244939, 0.991947, -288137e-8, 0.0893385, 0.0319929, 0.991962, -364693e-8, 0.0893399, 0.0404933, 0.991965, -450264e-8, 0.0893399, 0.049995, 0.99198, -544862e-8, 0.0893411, 0.0604995, 0.99197, -648491e-8, 0.0893397, 0.0720074, 0.991976, -761164e-8, 0.089341, 0.0845207, 0.99198, -882891e-8, 0.0893405, 0.0980413, 0.991982, -0.0101367, 0.0893396, 0.112571, 0.992008, -0.011535, 0.0893415, 0.128115, 0.992026, -0.0130228, 0.0893414, 0.144672, 0.992064, -0.0145966, 0.0893418, 0.162241, 0.992041, -0.0162421, 0.0893359, 0.180801, 0.992086, -0.0178888, 0.0893214, 0.200302, 0.992157, -0.0190368, 0.0892401, 0.220332, 0.992181, -0.0195584, 0.0890525, 0.240144, 0.992175, -0.0227257, 0.0892153, 0.260728, 0.99221, -0.0254195, 0.089304, 0.283473, 0.99222, -0.0274883, 0.0892703, 0.307673, 0.992317, -0.0294905, 0.0892027, 0.332729, 0.992374, -0.0311861, 0.0890577, 0.358387, 0.992505, -0.0320656, 0.0886994, 0.384102, 0.992568, -0.0329715, 0.0883198, 0.409767, 0.992675, -0.036006, 0.0883602, 0.436145, 0.992746, -0.0392897, 0.0884591, 0.463217, 0.992873, -0.0399337, 0.0878287, 0.491557, 0.992934, -0.040231, 0.0870108, 0.519516, 0.993091, -0.0422013, 0.0865857, 0.547741, 0.993259, -0.0443503, 0.0861937, 0.575792, 0.993455, -0.0446368, 0.0851187, 0.604233, 0.993497, -0.0454299, 0.0840576, 0.632925, 0.993694, -0.0463296, 0.0829671, 0.660985, 0.993718, -0.0470619, 0.0817185, 0.688714, 0.993973, -0.0468838, 0.0800294, 0.716743, 0.994207, -0.046705, 0.0781286, 0.74377, 0.994168, -0.0469698, 0.0763337, 0.77042, 0.9945, -0.0456816, 0.0738184, 0.796659, 0.994356, -0.0455518, 0.0715545, 0.821868, 0.994747, -0.0439488, 0.0686085, 0.846572, 0.994937, -0.0430056, 0.065869, 0.870435, 0.995142, -0.0413414, 0.0626446, 0.893272, 0.995451, -0.0396521, 0.05929, 0.915376, 0.995445, -0.0378453, 0.0558503, 0.936196, 0.995967, -0.0355219, 0.0520949, 0.956376, 0.996094, -0.0335146, 0.048377, 0.975327, 0.996622, -0.030682, 0.0442575, 0.993471, 0.996938, -0.0285504, 0.0404693, 1.01052, 0.997383, -0.0253399, 0.0360903, 1.02637, 0.997714, -0.0231651, 0.0322176, 1.04139, 0.998249, -0.0198138, 0.0278433, 1.05542, 0.998596, -0.0174337, 0.0238759, 1.06846, 0.998946, -0.0141349, 0.0195944, 1.08056, 0.99928, -0.0115603, 0.0156279, 1.09181, 0.999507, -839065e-8, 0.0114607, 1.10213, 0.999697, -5666e-6, 0.00763325, 1.11169, 0.999869, -269902e-8, 0.00364946, 1.12042, 1.00001, 6.23836e-05, -319288e-10, 1.12832, 0.987221, -222675e-11, 0.111332, 1.97456e-05, 0.98739, -561116e-10, 0.111351, 0.000497563, 0.987448, -224453e-9, 0.111357, 0.00199031, 0.987441, -505019e-9, 0.111357, 0.0044782, 0.987442, -897816e-9, 0.111357, 0.00796129, 0.987442, -140284e-8, 0.111357, 0.0124396, 0.987444, -202012e-8, 0.111357, 0.0179132, 0.987442, -274964e-8, 0.111357, 0.0243824, 0.987446, -359147e-8, 0.111357, 0.0318474, 0.987435, -454562e-8, 0.111356, 0.0403086, 0.987461, -561225e-8, 0.111358, 0.0497678, 0.987458, -679125e-8, 0.111358, 0.0602239, 0.987443, -80828e-7, 0.111356, 0.0716792, 0.987476, -94872e-7, 0.111358, 0.0841364, 0.98749, -0.0110044, 0.111361, 0.097597, 0.987508, -0.0126344, 0.111362, 0.112062, 0.987494, -0.0143767, 0.111357, 0.127533, 0.987526, -0.0162307, 0.111359, 0.144015, 0.987558, -0.0181912, 0.111361, 0.161502, 0.987602, -0.0202393, 0.111355, 0.179979, 0.987692, -0.022273, 0.111346, 0.199386, 0.987702, -0.0235306, 0.111215, 0.219183, 0.987789, -0.0247628, 0.111061, 0.239202, 0.987776, -0.0280668, 0.111171, 0.259957, 0.987856, -0.0316751, 0.111327, 0.282198, 0.987912, -0.0342468, 0.111282, 0.306294, 0.988, -0.0367205, 0.111198, 0.331219, 0.988055, -0.0387766, 0.110994, 0.356708, 0.988241, -0.0397722, 0.110547, 0.382234, 0.988399, -0.0416076, 0.110198, 0.408227, 0.988539, -0.0448192, 0.110137, 0.434662, 0.988661, -0.0483793, 0.110143, 0.461442, 0.988967, -0.0495895, 0.109453, 0.489318, 0.989073, -0.0506797, 0.108628, 0.517516, 0.989274, -0.0526953, 0.108003, 0.545844, 0.989528, -0.054578, 0.107255, 0.573823, 0.989709, -0.0561503, 0.106294, 0.601944, 0.989991, -0.056866, 0.104896, 0.630855, 0.990392, -0.0572914, 0.103336, 0.658925, 0.990374, -0.0586224, 0.10189, 0.686661, 0.990747, -0.0584764, 0.099783, 0.714548, 0.991041, -0.0582662, 0.0974309, 0.74186, 0.991236, -0.0584118, 0.0951678, 0.768422, 0.991585, -0.0573055, 0.0921581, 0.794817, 0.991984, -0.0564241, 0.0891167, 0.820336, 0.9921, -0.0553608, 0.085805, 0.84493, 0.992749, -0.0533816, 0.0820354, 0.868961, 0.99288, -0.0518661, 0.0782181, 0.891931, 0.993511, -0.0492492, 0.0738935, 0.914186, 0.993617, -0.0471956, 0.0696402, 0.93532, 0.99411, -0.044216, 0.0649659, 0.95543, 0.994595, -0.0416654, 0.0603177, 0.974685, 0.994976, -0.0384314, 0.0553493, 0.992807, 0.995579, -0.0353491, 0.0503942, 1.00996, 0.996069, -0.0319787, 0.0452123, 1.02606, 0.996718, -0.028472, 0.0400112, 1.04114, 0.997173, -0.0250789, 0.0349456, 1.05517, 0.997818, -0.0213326, 0.029653, 1.0683, 0.998318, -0.0178509, 0.024549, 1.0805, 0.998853, -0.0141118, 0.0194197, 1.09177, 0.999218, -0.0105914, 0.0143869, 1.1022, 0.999594, -693474e-8, 0.00943517, 1.11175, 0.99975, -340478e-8, 0.00464051, 1.12056, 1.00001, 0.000109172, -112821e-9, 1.12853, 0.983383, -266524e-11, 0.133358, 1.96534e-05, 0.981942, -671009e-10, 0.133162, 0.000494804, 0.981946, -268405e-9, 0.133163, 0.00197923, 0.981944, -603912e-9, 0.133163, 0.00445326, 0.981941, -107362e-8, 0.133162, 0.00791693, 0.981946, -167755e-8, 0.133163, 0.0123703, 0.981944, -241569e-8, 0.133162, 0.0178135, 0.981945, -328807e-8, 0.133163, 0.0242466, 0.981945, -429472e-8, 0.133162, 0.03167, 0.981955, -543573e-8, 0.133164, 0.0400846, 0.981951, -671105e-8, 0.133163, 0.0494901, 0.981968, -812092e-8, 0.133165, 0.0598886, 0.981979, -966541e-8, 0.133166, 0.0712811, 0.981996, -0.0113446, 0.133168, 0.083669, 0.982014, -0.0131585, 0.133169, 0.0970533, 0.982011, -0.0151073, 0.133167, 0.111438, 0.982062, -0.0171906, 0.133172, 0.126826, 0.9821, -0.0194067, 0.133175, 0.143215, 0.982149, -0.0217502, 0.133176, 0.160609, 0.982163, -0.0241945, 0.133173, 0.178981, 0.982247, -0.0265907, 0.133148, 0.198249, 0.982291, -0.027916, 0.132974, 0.217795, 0.982396, -0.0299663, 0.132868, 0.238042, 0.982456, -0.0334544, 0.132934, 0.258901, 0.982499, -0.0378636, 0.133137, 0.280639, 0.982617, -0.0409274, 0.133085, 0.304604, 0.98274, -0.0438523, 0.132985, 0.329376, 0.982944, -0.0462288, 0.132728, 0.354697, 0.98308, -0.0475995, 0.132228, 0.380102, 0.983391, -0.0501901, 0.131924, 0.406256, 0.983514, -0.0535899, 0.131737, 0.432735, 0.98373, -0.0571858, 0.131567, 0.459359, 0.984056, -0.0592353, 0.130932, 0.486637, 0.984234, -0.0610488, 0.130092, 0.51509, 0.984748, -0.0630758, 0.12923, 0.543461, 0.985073, -0.0647398, 0.128174, 0.571376, 0.985195, -0.0671941, 0.127133, 0.599414, 0.985734, -0.0681345, 0.125576, 0.628134, 0.986241, -0.0686089, 0.123639, 0.656399, 0.986356, -0.0698511, 0.121834, 0.684258, 0.986894, -0.0700931, 0.119454, 0.711818, 0.987382, -0.0698321, 0.116718, 0.739511, 0.988109, -0.0693975, 0.113699, 0.766267, 0.988363, -0.0689584, 0.110454, 0.792456, 0.989112, -0.0672353, 0.106602, 0.81813, 0.989241, -0.0662034, 0.10267, 0.842889, 0.990333, -0.0638938, 0.0981381, 0.867204, 0.990591, -0.0618534, 0.0935388, 0.89038, 0.991106, -0.0593117, 0.088553, 0.912576, 0.991919, -0.0562676, 0.0832187, 0.934118, 0.992111, -0.0534085, 0.0778302, 0.954254, 0.992997, -0.0495459, 0.0720453, 0.973722, 0.993317, -0.0463707, 0.0663458, 0.991949, 0.994133, -0.0421245, 0.0601883, 1.00936, 0.994705, -0.0384977, 0.0542501, 1.02559, 0.995495, -0.0340956, 0.0479862, 1.04083, 0.996206, -0.030105, 0.041887, 1.05497, 0.996971, -0.0256095, 0.0355355, 1.06824, 0.997796, -0.0213932, 0.0293655, 1.08056, 0.998272, -0.0169612, 0.0232926, 1.09182, 0.998857, -0.0126756, 0.0172786, 1.10219, 0.99939, -832486e-8, 0.0113156, 1.11192, 0.999752, -410826e-8, 0.00557892, 1.12075, 1, 0.000150957, -119101e-9, 1.12885, 0.975169, -309397e-11, 0.154669, 1.95073e-05, 0.975439, -779608e-10, 0.154712, 0.000491534, 0.975464, -311847e-9, 0.154716, 0.00196617, 0.975464, -701656e-9, 0.154716, 0.00442387, 0.975462, -12474e-7, 0.154715, 0.0078647, 0.975461, -194906e-8, 0.154715, 0.0122886, 0.975464, -280667e-8, 0.154715, 0.0176959, 0.975468, -382025e-8, 0.154716, 0.0240867, 0.975471, -498985e-8, 0.154716, 0.0314612, 0.975472, -631541e-8, 0.154717, 0.0398199, 0.975486, -779719e-8, 0.154718, 0.0491639, 0.975489, -943505e-8, 0.154718, 0.0594932, 0.975509, -0.0112295, 0.154721, 0.0708113, 0.97554, -0.0131802, 0.154724, 0.0831176, 0.975557, -0.0152876, 0.154726, 0.096415, 0.975585, -0.0175512, 0.154728, 0.110705, 0.975605, -0.0199713, 0.154729, 0.125992, 0.975645, -0.0225447, 0.154729, 0.142272, 0.975711, -0.0252649, 0.154735, 0.159549, 0.975788, -0.0280986, 0.154736, 0.177805, 0.975872, -0.0308232, 0.154704, 0.196911, 0.975968, -0.0324841, 0.154525, 0.216324, 0.976063, -0.0351281, 0.154432, 0.236628, 0.976157, -0.0388618, 0.15446, 0.257539, 0.976204, -0.0437704, 0.154665, 0.278975, 0.976358, -0.047514, 0.154652, 0.302606, 0.976571, -0.0508638, 0.154535, 0.327204, 0.976725, -0.0534995, 0.154221, 0.352276, 0.977013, -0.0555547, 0.153737, 0.377696, 0.977294, -0.0586728, 0.153403, 0.403855, 0.977602, -0.0622715, 0.15312, 0.430333, 0.977932, -0.0658166, 0.152755, 0.456855, 0.978241, -0.0689877, 0.152233, 0.483668, 0.978602, -0.0712805, 0.15132, 0.512097, 0.979234, -0.0732775, 0.150235, 0.540455, 0.97977, -0.075163, 0.148978, 0.568486, 0.979995, -0.0778026, 0.147755, 0.596524, 0.98078, -0.0791854, 0.146019, 0.624825, 0.981628, -0.0799666, 0.143906, 0.653403, 0.982067, -0.0808532, 0.141561, 0.681445, 0.98271, -0.0816024, 0.139025, 0.708918, 0.983734, -0.0812511, 0.135764, 0.736594, 0.98431, -0.0806201, 0.132152, 0.763576, 0.985071, -0.0801605, 0.12846, 0.789797, 0.98618, -0.0784208, 0.124084, 0.815804, 0.986886, -0.0766643, 0.1193, 0.840869, 0.987485, -0.0747744, 0.114236, 0.864952, 0.988431, -0.0716701, 0.108654, 0.888431, 0.988886, -0.0691609, 0.102994, 0.910963, 0.990024, -0.0654048, 0.0967278, 0.932629, 0.990401, -0.0619765, 0.090384, 0.95313, 0.991093, -0.0579296, 0.0837885, 0.972587, 0.992018, -0.0536576, 0.0770171, 0.991184, 0.992536, -0.0493719, 0.0701486, 1.00863, 0.993421, -0.0444813, 0.062953, 1.02494, 0.993928, -0.040008, 0.0560455, 1.04017, 0.994994, -0.0347982, 0.04856, 1.05463, 0.995866, -0.0301017, 0.0416152, 1.06807, 0.996916, -0.0248225, 0.0342597, 1.08039, 0.997766, -0.0199229, 0.0271668, 1.09177, 0.998479, -0.0147422, 0.0201387, 1.10235, 0.99921, -980173e-8, 0.0131944, 1.11206, 0.999652, -47426e-7, 0.00640712, 1.12104, 0.999998, 8.91673e-05, -10379e-8, 1.12906, 0.967868, -351885e-11, 0.175947, 1.93569e-05, 0.968001, -886733e-10, 0.175972, 0.000487782, 0.96801, -354697e-9, 0.175973, 0.00195115, 0.968012, -798063e-9, 0.175974, 0.00439006, 0.968011, -141879e-8, 0.175973, 0.00780461, 0.968011, -221686e-8, 0.175973, 0.0121948, 0.968016, -319231e-8, 0.175974, 0.0175607, 0.968019, -434515e-8, 0.175974, 0.0239027, 0.968018, -567538e-8, 0.175974, 0.0312208, 0.968033, -718308e-8, 0.175977, 0.0395158, 0.968049, -886836e-8, 0.175979, 0.0487885, 0.968047, -0.0107312, 0.175978, 0.0590394, 0.968072, -0.0127719, 0.175981, 0.0702705, 0.968108, -0.0149905, 0.175986, 0.0824836, 0.968112, -0.0173866, 0.175985, 0.0956783, 0.968173, -0.0199611, 0.175993, 0.109862, 0.96827, -0.0227128, 0.176008, 0.125033, 0.968292, -0.025639, 0.17601, 0.141193, 0.968339, -0.0287299, 0.176007, 0.158336, 0.968389, -0.0319399, 0.176001, 0.176441, 0.968501, -0.034941, 0.175962, 0.195359, 0.968646, -0.0370812, 0.175793, 0.214686, 0.968789, -0.0402329, 0.175708, 0.234973, 0.96886, -0.0442601, 0.1757, 0.255871, 0.969013, -0.049398, 0.175876, 0.277238, 0.969242, -0.0539932, 0.17594, 0.300326, 0.969419, -0.0577299, 0.175781, 0.324702, 0.969763, -0.0605643, 0.175432, 0.349527, 0.970093, -0.0634488, 0.174992, 0.374976, 0.970361, -0.0670589, 0.174611, 0.401097, 0.970825, -0.0708246, 0.174226, 0.427496, 0.971214, -0.0742871, 0.173684, 0.453858, 0.971622, -0.0782608, 0.173186, 0.480637, 0.972175, -0.0813151, 0.172288, 0.508655, 0.972944, -0.0832678, 0.170979, 0.536973, 0.973595, -0.0855964, 0.169573, 0.565138, 0.974345, -0.0882163, 0.168152, 0.593222, 0.975233, -0.0901671, 0.166314, 0.621201, 0.976239, -0.0912111, 0.163931, 0.649919, 0.977289, -0.0916959, 0.161106, 0.678011, 0.978076, -0.0927061, 0.158272, 0.705717, 0.979533, -0.0925562, 0.15475, 0.733228, 0.980335, -0.0918159, 0.150638, 0.760454, 0.981808, -0.0908508, 0.146201, 0.786918, 0.983061, -0.0896172, 0.141386, 0.812953, 0.984148, -0.0871588, 0.135837, 0.838281, 0.985047, -0.0850624, 0.130135, 0.862594, 0.986219, -0.0818541, 0.123882, 0.88633, 0.987043, -0.0784523, 0.117126, 0.908952, 0.988107, -0.0749601, 0.110341, 0.930744, 0.988955, -0.0703548, 0.102885, 0.951728, 0.989426, -0.0662798, 0.0954167, 0.971166, 0.990421, -0.0610834, 0.0876331, 0.989984, 0.991032, -0.0562936, 0.0797785, 1.00765, 0.992041, -0.0508154, 0.0718166, 1.02434, 0.992794, -0.0454045, 0.0637125, 1.03976, 0.993691, -0.0398194, 0.0555338, 1.05418, 0.994778, -0.0341482, 0.0473388, 1.06772, 0.995915, -0.028428, 0.0391016, 1.08028, 0.997109, -0.022642, 0.0309953, 1.09185, 0.998095, -0.0168738, 0.0230288, 1.10247, 0.998985, -0.0111274, 0.0150722, 1.11229, 0.999581, -543881e-8, 0.00740605, 1.12131, 1.00003, 0.000162239, -105549e-9, 1.12946, 0.959505, -393734e-11, 0.196876, 1.91893e-05, 0.959599, -992157e-10, 0.196895, 0.000483544, 0.959641, -396868e-9, 0.196903, 0.0019342, 0.959599, -892948e-9, 0.196895, 0.00435193, 0.959603, -158747e-8, 0.196896, 0.0077368, 0.959604, -248042e-8, 0.196896, 0.0120888, 0.959605, -357184e-8, 0.196896, 0.0174082, 0.959605, -486169e-8, 0.196896, 0.0236949, 0.959613, -635008e-8, 0.196897, 0.0309497, 0.959619, -803696e-8, 0.196898, 0.0391725, 0.959636, -992255e-8, 0.196901, 0.0483649, 0.959634, -0.0120067, 0.1969, 0.0585266, 0.959675, -0.0142898, 0.196906, 0.0696609, 0.959712, -0.0167717, 0.196911, 0.0817678, 0.959752, -0.0194524, 0.196918, 0.0948494, 0.959807, -0.0223321, 0.196925, 0.10891, 0.959828, -0.0254091, 0.196924, 0.123947, 0.959906, -0.0286815, 0.196934, 0.139968, 0.960005, -0.0321371, 0.196944, 0.156968, 0.960071, -0.0357114, 0.196936, 0.17491, 0.960237, -0.0389064, 0.196882, 0.193597, 0.960367, -0.041623, 0.196731, 0.21285, 0.960562, -0.0452655, 0.196654, 0.233075, 0.960735, -0.0496207, 0.196643, 0.253941, 0.960913, -0.0549379, 0.196774, 0.275278, 0.961121, -0.0603414, 0.196893, 0.297733, 0.96139, -0.0644244, 0.196717, 0.321877, 0.961818, -0.067556, 0.196314, 0.346476, 0.962175, -0.0712709, 0.195917, 0.371907, 0.96255, -0.0752848, 0.1955, 0.397916, 0.963164, -0.0792073, 0.195026, 0.424229, 0.963782, -0.0828225, 0.194424, 0.450637, 0.964306, -0.0873119, 0.193831, 0.477288, 0.964923, -0.0911051, 0.192973, 0.504716, 0.966048, -0.093251, 0.19151, 0.533053, 0.967024, -0.0958983, 0.190013, 0.561366, 0.968038, -0.09835, 0.188253, 0.589464, 0.969152, -0.100754, 0.186257, 0.617433, 0.970557, -0.102239, 0.183775, 0.645801, 0.972104, -0.102767, 0.180645, 0.674278, 0.973203, -0.103492, 0.177242, 0.702004, 0.975123, -0.103793, 0.17345, 0.729529, 0.97641, -0.102839, 0.168886, 0.756712, 0.978313, -0.101687, 0.163892, 0.783801, 0.980036, -0.100314, 0.158439, 0.809671, 0.981339, -0.097836, 0.152211, 0.835402, 0.982794, -0.0950006, 0.145679, 0.860081, 0.984123, -0.0920994, 0.138949, 0.883757, 0.984918, -0.0878641, 0.131283, 0.90685, 0.985999, -0.083939, 0.123464, 0.928786, 0.987151, -0.0791234, 0.115324, 0.94983, 0.987827, -0.0739332, 0.106854, 0.96962, 0.988806, -0.0688088, 0.0982691, 0.98861, 0.989588, -0.0628962, 0.0893456, 1.00667, 0.990438, -0.0573146, 0.0805392, 1.02344, 0.991506, -0.0509433, 0.0713725, 1.03933, 0.992492, -0.0448724, 0.0623732, 1.05378, 0.993663, -0.0383497, 0.0530838, 1.06747, 0.994956, -0.0319593, 0.0439512, 1.08007, 0.99634, -0.025401, 0.0347803, 1.09182, 0.99761, -0.0189687, 0.0257954, 1.1025, 0.99863, -0.0124441, 0.0169893, 1.11247, 0.99947, -614003e-8, 0.00829498, 1.12151, 1.00008, 0.000216624, -146107e-9, 1.12993, 0.950129, -434955e-11, 0.217413, 1.90081e-05, 0.950264, -10957e-8, 0.217444, 0.00047884, 0.9503, -438299e-9, 0.217451, 0.00191543, 0.950246, -986124e-9, 0.21744, 0.00430951, 0.950246, -175311e-8, 0.21744, 0.00766137, 0.950245, -273923e-8, 0.21744, 0.011971, 0.950253, -394453e-8, 0.217441, 0.0172385, 0.950258, -536897e-8, 0.217442, 0.0234641, 0.950267, -701262e-8, 0.217444, 0.030648, 0.950277, -887551e-8, 0.217446, 0.038791, 0.950284, -0.0109576, 0.217446, 0.0478931, 0.950312, -0.0132591, 0.217451, 0.0579568, 0.950334, -0.01578, 0.217454, 0.0689821, 0.950378, -0.0185204, 0.217462, 0.0809714, 0.950417, -0.0214803, 0.217467, 0.0939265, 0.950488, -0.0246594, 0.217479, 0.10785, 0.950534, -0.0280565, 0.217483, 0.122743, 0.950633, -0.0316685, 0.217498, 0.138611, 0.950698, -0.0354787, 0.217499, 0.155442, 0.950844, -0.0394003, 0.217507, 0.173208, 0.950999, -0.0426812, 0.217419, 0.191605, 0.951221, -0.0461302, 0.217317, 0.21084, 0.951412, -0.0502131, 0.217238, 0.230945, 0.951623, -0.0549183, 0.21722, 0.251745, 0.951867, -0.0604493, 0.217306, 0.273001, 0.952069, -0.0665189, 0.217466, 0.294874, 0.952459, -0.0709179, 0.217266, 0.318732, 0.952996, -0.0746112, 0.216891, 0.34318, 0.953425, -0.0789252, 0.216503, 0.36849, 0.953885, -0.0833293, 0.216042, 0.394373, 0.954617, -0.087371, 0.215469, 0.420505, 0.955429, -0.0914054, 0.214802, 0.446907, 0.956068, -0.0961671, 0.214146, 0.473522, 0.957094, -0.10048, 0.213286, 0.50052, 0.958372, -0.103248, 0.211796, 0.528715, 0.959654, -0.106033, 0.21016, 0.557065, 0.961305, -0.108384, 0.208149, 0.585286, 0.962785, -0.111122, 0.206024, 0.613334, 0.964848, -0.112981, 0.203442, 0.641334, 0.966498, -0.113717, 0.19996, 0.669955, 0.968678, -0.114121, 0.196105, 0.698094, 0.970489, -0.114524, 0.191906, 0.725643, 0.972903, -0.113792, 0.186963, 0.752856, 0.974701, -0.112406, 0.181343, 0.780013, 0.976718, -0.110685, 0.175185, 0.806268, 0.978905, -0.108468, 0.168535, 0.832073, 0.980267, -0.105061, 0.161106, 0.857149, 0.981967, -0.101675, 0.153387, 0.881145, 0.983063, -0.0974492, 0.145199, 0.904255, 0.984432, -0.0925815, 0.136527, 0.926686, 0.985734, -0.0877983, 0.127584, 0.947901, 0.986228, -0.081884, 0.118125, 0.968111, 0.98719, -0.0761208, 0.108594, 0.98719, 0.988228, -0.0698196, 0.0989996, 1.00559, 0.989046, -0.0632739, 0.0890074, 1.02246, 0.990242, -0.056522, 0.0790832, 1.03841, 0.991252, -0.0495272, 0.0689182, 1.05347, 0.992542, -0.0425373, 0.0588592, 1.06724, 0.994096, -0.0353198, 0.0486833, 1.08009, 0.995593, -0.028235, 0.0385977, 1.09177, 0.99711, -0.0209511, 0.0286457, 1.10274, 0.998263, -0.0139289, 0.0188497, 1.11262, 0.999254, -67359e-7, 0.009208, 1.12191, 0.999967, 0.000141846, -657764e-10, 1.13024, 0.935608, -474692e-11, 0.236466, 1.87817e-05, 0.93996, -11971e-8, 0.237568, 0.000473646, 0.939959, -478845e-9, 0.237567, 0.0018946, 0.939954, -10774e-7, 0.237566, 0.00426284, 0.939956, -191538e-8, 0.237566, 0.00757842, 0.939954, -299277e-8, 0.237566, 0.0118413, 0.93996, -430961e-8, 0.237567, 0.0170518, 0.939969, -586589e-8, 0.237569, 0.02321, 0.939982, -766166e-8, 0.237572, 0.0303164, 0.939987, -969686e-8, 0.237572, 0.0383711, 0.939997, -0.0119715, 0.237574, 0.0473751, 0.940031, -0.0144858, 0.237581, 0.0573298, 0.940073, -0.0172399, 0.237589, 0.0682366, 0.94012, -0.0202335, 0.237598, 0.080097, 0.940162, -0.0234663, 0.237604, 0.0929116, 0.940237, -0.0269387, 0.237615, 0.106686, 0.940328, -0.0306489, 0.237632, 0.121421, 0.940419, -0.0345917, 0.237645, 0.137115, 0.940522, -0.0387481, 0.237654, 0.153766, 0.940702, -0.0429906, 0.237661, 0.17133, 0.940871, -0.0465089, 0.237561, 0.189502, 0.941103, -0.050531, 0.23748, 0.208616, 0.941369, -0.0550657, 0.237423, 0.228595, 0.941641, -0.0601337, 0.237399, 0.249287, 0.941903, -0.0658804, 0.237443, 0.270467, 0.942224, -0.0722674, 0.237597, 0.292024, 0.942633, -0.0771788, 0.237419, 0.315272, 0.943172, -0.0815623, 0.237068, 0.339579, 0.943691, -0.0863973, 0.236682, 0.364717, 0.944382, -0.0911536, 0.236213, 0.390435, 0.945392, -0.0952967, 0.235562, 0.416425, 0.946185, -0.0998948, 0.234832, 0.442772, 0.947212, -0.104796, 0.234114, 0.469347, 0.948778, -0.10928, 0.233222, 0.496162, 0.950149, -0.113081, 0.231845, 0.523978, 0.951989, -0.115893, 0.230005, 0.552295, 0.953921, -0.11846, 0.227862, 0.580569, 0.955624, -0.12115, 0.225439, 0.608698, 0.958234, -0.123373, 0.222635, 0.636696, 0.960593, -0.124519, 0.219093, 0.665208, 0.963201, -0.124736, 0.214749, 0.693557, 0.965642, -0.125012, 0.210059, 0.721334, 0.968765, -0.124661, 0.204935, 0.748613, 0.971753, -0.122996, 0.198661, 0.776224, 0.973751, -0.120998, 0.191823, 0.802461, 0.976709, -0.118583, 0.184359, 0.828399, 0.977956, -0.115102, 0.176437, 0.853693, 0.979672, -0.111077, 0.167681, 0.877962, 0.981816, -0.10688, 0.158872, 0.901564, 0.98238, -0.101469, 0.149398, 0.924057, 0.983964, -0.0960013, 0.139436, 0.945751, 0.984933, -0.0899626, 0.12943, 0.966272, 0.985694, -0.0832973, 0.11894, 0.985741, 0.986822, -0.0767082, 0.108349, 1.00407, 0.987725, -0.0693614, 0.0976026, 1.02154, 0.98877, -0.06211, 0.086652, 1.03757, 0.990129, -0.0544143, 0.0756182, 1.05296, 0.991337, -0.046744, 0.0645753, 1.06683, 0.992978, -0.0387931, 0.0534683, 1.0798, 0.994676, -0.030973, 0.0424137, 1.09181, 0.99645, -0.0230311, 0.0314035, 1.10286, 0.997967, -0.0152065, 0.0206869, 1.11291, 0.99922, -744837e-8, 0.010155, 1.12237, 1.00002, 0.000240209, -752767e-10, 1.13089, 0.922948, -515351e-11, 0.255626, 1.86069e-05, 0.928785, -129623e-9, 0.257244, 0.000468009, 0.928761, -51849e-8, 0.257237, 0.00187202, 0.928751, -11666e-7, 0.257235, 0.00421204, 0.928751, -207395e-8, 0.257234, 0.0074881, 0.928754, -324055e-8, 0.257235, 0.0117002, 0.92876, -466639e-8, 0.257236, 0.0168486, 0.928763, -635149e-8, 0.257237, 0.0229334, 0.928774, -829584e-8, 0.257239, 0.029955, 0.928791, -0.0104995, 0.257243, 0.0379139, 0.928804, -0.0129623, 0.257245, 0.0468108, 0.928847, -0.0156846, 0.257255, 0.0566473, 0.92889, -0.0186661, 0.257263, 0.0674246, 0.928924, -0.0219067, 0.257268, 0.0791433, 0.928989, -0.0254066, 0.257282, 0.0918076, 0.92909, -0.0291651, 0.257301, 0.105419, 0.92918, -0.0331801, 0.257316, 0.119978, 0.92929, -0.0374469, 0.257332, 0.135491, 0.929453, -0.041939, 0.257357, 0.151948, 0.929586, -0.0464612, 0.257347, 0.169275, 0.929858, -0.0503426, 0.257269, 0.187257, 0.930125, -0.0548409, 0.257199, 0.206204, 0.930403, -0.0598063, 0.257149, 0.22601, 0.930726, -0.0652437, 0.257122, 0.246561, 0.931098, -0.0712376, 0.257153, 0.267618, 0.931396, -0.0777506, 0.257237, 0.288993, 0.931947, -0.0832374, 0.257124, 0.311527, 0.932579, -0.0883955, 0.25683, 0.335697, 0.933194, -0.0937037, 0.256444, 0.360634, 0.934013, -0.0987292, 0.255939, 0.386126, 0.935307, -0.103215, 0.255282, 0.412018, 0.936374, -0.108234, 0.254538, 0.438292, 0.93776, -0.113234, 0.253728, 0.464805, 0.939599, -0.118013, 0.25275, 0.491464, 0.941036, -0.122661, 0.251404, 0.518751, 0.94337, -0.125477, 0.249435, 0.547133, 0.945318, -0.128374, 0.247113, 0.575456, 0.947995, -0.130996, 0.244441, 0.60372, 0.950818, -0.133438, 0.241352, 0.63174, 0.954378, -0.135004, 0.237849, 0.659971, 0.957151, -0.135313, 0.233188, 0.688478, 0.960743, -0.13521, 0.228001, 0.716767, 0.964352, -0.135007, 0.222249, 0.744349, 0.967273, -0.133523, 0.21542, 0.771786, 0.969767, -0.131155, 0.208039, 0.798639, 0.973195, -0.128492, 0.200076, 0.824774, 0.975557, -0.125094, 0.191451, 0.850222, 0.977692, -0.120578, 0.18184, 0.874761, 0.98026, -0.115882, 0.172102, 0.898497, 0.981394, -0.110372, 0.161859, 0.921636, 0.982386, -0.10415, 0.15108, 0.943467, 0.983783, -0.0978128, 0.140407, 0.964045, 0.98422, -0.0906171, 0.129058, 0.98398, 0.985447, -0.0832921, 0.117614, 1.00276, 0.986682, -0.0754412, 0.10585, 1.02047, 0.987326, -0.0673885, 0.0940943, 1.03678, 0.988707, -0.0592565, 0.0822093, 1.05218, 0.990185, -0.050717, 0.070192, 1.06652, 0.991866, -0.0423486, 0.0582081, 1.07965, 0.993897, -0.0336118, 0.0460985, 1.09188, 0.995841, -0.0252178, 0.0342737, 1.10307, 0.997605, -0.0164893, 0.0224829, 1.11324, 0.999037, -817112e-8, 0.0110647, 1.12262, 1.00003, 0.000291686, -168673e-9, 1.13139, 0.915304, -552675e-11, 0.275999, 1.83285e-05, 0.91668, -139285e-9, 0.276414, 0.000461914, 0.916664, -55713e-8, 0.276409, 0.00184763, 0.916653, -125354e-8, 0.276406, 0.00415715, 0.916651, -222851e-8, 0.276405, 0.00739053, 0.916655, -348205e-8, 0.276406, 0.0115478, 0.916653, -501414e-8, 0.276405, 0.0166291, 0.916667, -682478e-8, 0.276409, 0.0226346, 0.91668, -891398e-8, 0.276412, 0.0295648, 0.91669, -0.0112817, 0.276413, 0.0374199, 0.916727, -0.013928, 0.276422, 0.0462016, 0.916759, -0.0168528, 0.276429, 0.0559101, 0.916793, -0.0200558, 0.276436, 0.0665466, 0.916849, -0.0235373, 0.276448, 0.0781139, 0.916964, -0.0272973, 0.276474, 0.0906156, 0.917047, -0.0313344, 0.276491, 0.104051, 0.917152, -0.0356465, 0.276511, 0.118424, 0.917286, -0.0402271, 0.276533, 0.133736, 0.917469, -0.0450408, 0.276564, 0.149978, 0.917686, -0.0497872, 0.276563, 0.167057, 0.917953, -0.0540937, 0.276493, 0.184846, 0.918228, -0.0590709, 0.276437, 0.203614, 0.918572, -0.0644277, 0.276398, 0.223212, 0.918918, -0.0702326, 0.276362, 0.243584, 0.919356, -0.076484, 0.276383, 0.264465, 0.919842, -0.0830808, 0.276434, 0.285701, 0.920451, -0.0892972, 0.276407, 0.307559, 0.921113, -0.095016, 0.276128, 0.331501, 0.921881, -0.100771, 0.275754, 0.356207, 0.923027, -0.106029, 0.275254, 0.381477, 0.924364, -0.111029, 0.274595, 0.40722, 0.925818, -0.116345, 0.273841, 0.433385, 0.92746, -0.121424, 0.272913, 0.459848, 0.929167, -0.12657, 0.271837, 0.486493, 0.931426, -0.131581, 0.270575, 0.513432, 0.934001, -0.135038, 0.268512, 0.541502, 0.936296, -0.138039, 0.266135, 0.569658, 0.939985, -0.140687, 0.263271, 0.598375, 0.943516, -0.143247, 0.260058, 0.626563, 0.94782, -0.145135, 0.256138, 0.654711, 0.951023, -0.145733, 0.251154, 0.683285, 0.955338, -0.145554, 0.245562, 0.711831, 0.959629, -0.145008, 0.239265, 0.739573, 0.963123, -0.144003, 0.232064, 0.767027, 0.966742, -0.141289, 0.224036, 0.794359, 0.969991, -0.138247, 0.215305, 0.820361, 0.973403, -0.134786, 0.206051, 0.846548, 0.975317, -0.129966, 0.195914, 0.871541, 0.977647, -0.12471, 0.185184, 0.895313, 0.980137, -0.119086, 0.174161, 0.918398, 0.981031, -0.112297, 0.162792, 0.940679, 0.982037, -0.105372, 0.150952, 0.961991, 0.983164, -0.097821, 0.138921, 0.981913, 0.983757, -0.0897245, 0.126611, 1.00109, 0.985036, -0.0815974, 0.114228, 1.01902, 0.986289, -0.0727725, 0.101389, 1.03604, 0.987329, -0.0639323, 0.0886476, 1.05149, 0.989193, -0.0548109, 0.0756837, 1.06619, 0.990716, -0.045687, 0.0627581, 1.07948, 0.992769, -0.0364315, 0.0498337, 1.09172, 0.99524, -0.0271761, 0.0370305, 1.1033, 0.997154, -0.0179609, 0.0243959, 1.11353, 0.998845, -878063e-8, 0.0119567, 1.12319, 1.00002, 0.000259038, -108146e-9, 1.13177, 0.903945, -591681e-11, 0.295126, 1.81226e-05, 0.903668, -148672e-9, 0.295037, 0.000455367, 0.903677, -594683e-9, 0.29504, 0.00182145, 0.903673, -133805e-8, 0.295039, 0.00409831, 0.903666, -237872e-8, 0.295036, 0.00728584, 0.903668, -371676e-8, 0.295037, 0.0113842, 0.903679, -535212e-8, 0.29504, 0.0163936, 0.903684, -728479e-8, 0.295041, 0.0223141, 0.903698, -951473e-8, 0.295044, 0.0291462, 0.903718, -0.0120419, 0.295049, 0.0368904, 0.903754, -0.0148664, 0.295058, 0.0455477, 0.903801, -0.017988, 0.29507, 0.0551194, 0.903851, -0.0214064, 0.295082, 0.0656058, 0.903921, -0.0251219, 0.295097, 0.0770109, 0.904002, -0.0291337, 0.295116, 0.0893354, 0.904111, -0.033441, 0.29514, 0.102583, 0.904246, -0.0380415, 0.295169, 0.116755, 0.904408, -0.0429258, 0.295202, 0.131853, 0.904637, -0.0480468, 0.295245, 0.147869, 0.904821, -0.0529208, 0.295214, 0.164658, 0.905163, -0.0577748, 0.295185, 0.182274, 0.905469, -0.0631763, 0.295143, 0.200828, 0.905851, -0.068917, 0.295112, 0.2202, 0.906322, -0.0750861, 0.295104, 0.240372, 0.906761, -0.0815855, 0.295086, 0.261082, 0.90735, -0.0882138, 0.295095, 0.282123, 0.908087, -0.095082, 0.295139, 0.303563, 0.908826, -0.101488, 0.29492, 0.327028, 0.909832, -0.107577, 0.294577, 0.351464, 0.911393, -0.113033, 0.294115, 0.376497, 0.912804, -0.118629, 0.293446, 0.402115, 0.914081, -0.124232, 0.292581, 0.428111, 0.91637, -0.129399, 0.29166, 0.454442, 0.91814, -0.134892, 0.290422, 0.481024, 0.921179, -0.140069, 0.289194, 0.507924, 0.924544, -0.144431, 0.287421, 0.535557, 0.927995, -0.147498, 0.284867, 0.563984, 0.931556, -0.150197, 0.281722, 0.5923, 0.935777, -0.152711, 0.278207, 0.620832, 0.940869, -0.154836, 0.274148, 0.649069, 0.945994, -0.155912, 0.269057, 0.677746, 0.949634, -0.155641, 0.262799, 0.706293, 0.955032, -0.154809, 0.256097, 0.734278, 0.95917, -0.153678, 0.248618, 0.761751, 0.962931, -0.151253, 0.239794, 0.789032, 0.966045, -0.147625, 0.230281, 0.815422, 0.96971, -0.143964, 0.220382, 0.841787, 0.972747, -0.139464, 0.209846, 0.867446, 0.975545, -0.133459, 0.198189, 0.892004, 0.978381, -0.127424, 0.186362, 0.915458, 0.979935, -0.120506, 0.173964, 0.937948, 0.980948, -0.11282, 0.161429, 0.959732, 0.982234, -0.104941, 0.148557, 0.980118, 0.982767, -0.0962905, 0.135508, 0.999463, 0.983544, -0.0873625, 0.122338, 1.01756, 0.984965, -0.0783447, 0.108669, 1.03492, 0.986233, -0.0684798, 0.0949911, 1.05087, 0.987796, -0.0590867, 0.0811386, 1.0656, 0.989885, -0.0489145, 0.0673099, 1.0794, 0.991821, -0.0391, 0.0535665, 1.09174, 0.99448, -0.029087, 0.0397529, 1.10341, 0.996769, -0.019114, 0.0261463, 1.11383, 0.998641, -947007e-8, 0.0128731, 1.1237, 0.999978, 0.000446316, -169093e-9, 1.13253, 0.888362, -627064e-11, 0.312578, 1.78215e-05, 0.889988, -157791e-9, 0.313148, 0.000448451, 0.889825, -631076e-9, 0.313092, 0.00179356, 0.88984, -141994e-8, 0.313097, 0.00403554, 0.889828, -25243e-7, 0.313092, 0.00717429, 0.889831, -394421e-8, 0.313093, 0.0112099, 0.889831, -567962e-8, 0.313093, 0.0161425, 0.889844, -773051e-8, 0.313096, 0.0219724, 0.889858, -0.0100968, 0.3131, 0.0286999, 0.889882, -0.0127786, 0.313106, 0.0363256, 0.889918, -0.0157757, 0.313116, 0.0448509, 0.889967, -0.0190878, 0.313129, 0.0542758, 0.89003, -0.022715, 0.313145, 0.0646032, 0.890108, -0.0266566, 0.313165, 0.0758339, 0.890218, -0.0309131, 0.313193, 0.0879729, 0.890351, -0.0354819, 0.313226, 0.101019, 0.89051, -0.0403613, 0.313263, 0.114979, 0.890672, -0.0455385, 0.313294, 0.129848, 0.890882, -0.0509444, 0.313333, 0.145616, 0.891189, -0.0559657, 0.313324, 0.162122, 0.891457, -0.0613123, 0.313281, 0.179524, 0.891856, -0.0671488, 0.313281, 0.197855, 0.892312, -0.0732732, 0.313268, 0.216991, 0.892819, -0.0797865, 0.313263, 0.236924, 0.893369, -0.0865269, 0.313247, 0.257433, 0.894045, -0.0931592, 0.313205, 0.278215, 0.894884, -0.100532, 0.313276, 0.299467, 0.895832, -0.107716, 0.313205, 0.322276, 0.897043, -0.114099, 0.312873, 0.34642, 0.898515, -0.119941, 0.312331, 0.371187, 0.900191, -0.126044, 0.311731, 0.396656, 0.90188, -0.131808, 0.310859, 0.422488, 0.904359, -0.137289, 0.309857, 0.448744, 0.906923, -0.142991, 0.308714, 0.475239, 0.910634, -0.148253, 0.307465, 0.501983, 0.914502, -0.153332, 0.305774, 0.529254, 0.919046, -0.156646, 0.303156, 0.557709, 0.923194, -0.159612, 0.299928, 0.586267, 0.928858, -0.162027, 0.296245, 0.614925, 0.934464, -0.164203, 0.291832, 0.643187, 0.939824, -0.165602, 0.286565, 0.671601, 0.944582, -0.165383, 0.280073, 0.700213, 0.949257, -0.164439, 0.272891, 0.728432, 0.954389, -0.162953, 0.264771, 0.756082, 0.958595, -0.161007, 0.255927, 0.78369, 0.962138, -0.157243, 0.245769, 0.810769, 0.966979, -0.152872, 0.235127, 0.836999, 0.969566, -0.148209, 0.22347, 0.862684, 0.972372, -0.142211, 0.211147, 0.887847, 0.975916, -0.135458, 0.198606, 0.911843, 0.978026, -0.128398, 0.185498, 0.934795, 0.979686, -0.120313, 0.17171, 0.956787, 0.980748, -0.11166, 0.158159, 0.978046, 0.981622, -0.103035, 0.144399, 0.997693, 0.982356, -0.0930328, 0.13001, 1.01642, 0.983308, -0.0834627, 0.115778, 1.03366, 0.985037, -0.0732249, 0.101327, 1.05014, 0.986493, -0.0628145, 0.086554, 1.06507, 0.988484, -0.0526556, 0.0720413, 1.07907, 0.991051, -0.0415744, 0.0571151, 1.09189, 0.993523, -0.0314275, 0.0426643, 1.10369, 0.99628, -0.0203603, 0.0279325, 1.11423, 0.998344, -0.0102446, 0.0138182, 1.12421, 0.999997, 0.00042612, -193628e-9, 1.1333, 0.871555, -660007e-11, 0.329176, 1.74749e-05, 0.875255, -166579e-9, 0.330571, 0.000441051, 0.875644, -666394e-9, 0.330718, 0.00176441, 0.875159, -149903e-8, 0.330536, 0.00396899, 0.87516, -266493e-8, 0.330536, 0.007056, 0.875158, -416393e-8, 0.330535, 0.0110251, 0.87516, -599598e-8, 0.330535, 0.0158764, 0.875163, -816108e-8, 0.330536, 0.0216101, 0.875174, -0.0106591, 0.330538, 0.0282266, 0.875199, -0.0134899, 0.330545, 0.0357266, 0.875257, -0.0166538, 0.330563, 0.0441117, 0.875304, -0.0201501, 0.330575, 0.0533821, 0.875373, -0.0239785, 0.330595, 0.0635395, 0.875464, -0.0281389, 0.330619, 0.0745872, 0.875565, -0.0326301, 0.330645, 0.0865255, 0.875691, -0.0374516, 0.330676, 0.0993599, 0.875897, -0.0425993, 0.330733, 0.113093, 0.876091, -0.0480576, 0.330776, 0.127722, 0.876353, -0.0537216, 0.330826, 0.143227, 0.876649, -0.0589807, 0.330809, 0.159462, 0.877034, -0.0647865, 0.330819, 0.176642, 0.877443, -0.0709789, 0.330817, 0.194702, 0.877956, -0.0774782, 0.330832, 0.213577, 0.878499, -0.0843175, 0.330822, 0.233246, 0.879144, -0.0912714, 0.330804, 0.253512, 0.879982, -0.0980824, 0.330766, 0.274137, 0.88097, -0.105823, 0.330864, 0.295209, 0.882051, -0.113671, 0.330896, 0.317226, 0.883397, -0.120303, 0.330545, 0.341068, 0.884987, -0.12667, 0.330068, 0.365613, 0.886789, -0.133118, 0.329418, 0.390807, 0.889311, -0.139024, 0.328683, 0.416494, 0.891995, -0.144971, 0.327729, 0.442618, 0.895106, -0.150747, 0.326521, 0.469131, 0.899527, -0.156283, 0.325229, 0.495921, 0.90504, -0.161707, 0.32378, 0.523162, 0.909875, -0.165661, 0.32122, 0.55092, 0.91561, -0.168755, 0.317942, 0.579928, 0.921225, -0.171193, 0.313983, 0.608539, 0.927308, -0.17319, 0.309636, 0.636854, 0.933077, -0.174819, 0.304262, 0.66523, 0.938766, -0.175002, 0.297563, 0.693609, 0.943667, -0.173946, 0.289613, 0.722157, 0.949033, -0.172221, 0.281227, 0.750021, 0.953765, -0.169869, 0.271545, 0.777466, 0.95804, -0.166578, 0.261034, 0.804853, 0.962302, -0.161761, 0.249434, 0.831569, 0.966544, -0.156636, 0.237484, 0.857779, 0.969372, -0.150784, 0.224395, 0.883051, 0.972486, -0.143672, 0.210786, 0.907864, 0.975853, -0.135772, 0.196556, 0.931223, 0.977975, -0.127942, 0.182307, 0.954061, 0.979122, -0.118347, 0.167607, 0.97531, 0.980719, -0.109112, 0.152739, 0.995666, 0.981223, -0.0991789, 0.137932, 1.01475, 0.98216, -0.0883553, 0.122692, 1.03253, 0.983379, -0.0780825, 0.107493, 1.04917, 0.985434, -0.0665646, 0.0917791, 1.06464, 0.987332, -0.0557714, 0.0764949, 1.07896, 0.990004, -0.0442805, 0.060721, 1.09199, 0.992975, -0.0331676, 0.0452284, 1.10393, 0.995811, -0.0219547, 0.0297934, 1.11476, 0.9982, -0.0107613, 0.0146415, 1.12484, 1.00002, 0.000248678, -14555e-8, 1.13413, 0.859519, -693595e-11, 0.347264, 1.71673e-05, 0.859843, -17503e-8, 0.347394, 0.000433219, 0.859656, -700076e-9, 0.347319, 0.00173277, 0.859671, -157517e-8, 0.347325, 0.00389875, 0.859669, -280028e-8, 0.347324, 0.00693112, 0.85967, -43754e-7, 0.347324, 0.01083, 0.859665, -630049e-8, 0.347321, 0.0155954, 0.859685, -85755e-7, 0.347328, 0.0212278, 0.859694, -0.0112003, 0.347329, 0.0277273, 0.859718, -0.0141747, 0.347336, 0.0350946, 0.85976, -0.0174988, 0.347348, 0.0433314, 0.85982, -0.0211722, 0.347366, 0.0524384, 0.859892, -0.0251941, 0.347387, 0.0624168, 0.860006, -0.0295649, 0.347422, 0.0732708, 0.860122, -0.0342825, 0.347453, 0.0849999, 0.860282, -0.0393462, 0.347499, 0.0976102, 0.860482, -0.0447513, 0.347554, 0.111104, 0.860719, -0.0504775, 0.347614, 0.125479, 0.860998, -0.0563577, 0.347666, 0.140703, 0.861322, -0.0619473, 0.347662, 0.156681, 0.861724, -0.0681277, 0.347684, 0.173597, 0.862198, -0.0746567, 0.347709, 0.191371, 0.862733, -0.0815234, 0.347727, 0.209976, 0.863371, -0.0886643, 0.347744, 0.229351, 0.86414, -0.0957908, 0.347734, 0.24934, 0.865138, -0.102912, 0.34772, 0.269797, 0.866182, -0.110924, 0.3478, 0.290654, 0.867436, -0.119223, 0.347911, 0.312074, 0.869087, -0.126197, 0.347649, 0.335438, 0.870859, -0.133145, 0.347222, 0.359732, 0.872997, -0.139869, 0.346645, 0.38467, 0.875939, -0.146089, 0.345935, 0.41019, 0.879012, -0.152334, 0.345012, 0.436218, 0.883353, -0.15821, 0.343924, 0.462641, 0.888362, -0.164097, 0.342636, 0.489449, 0.895026, -0.169528, 0.341351, 0.516629, 0.900753, -0.174408, 0.339115, 0.544109, 0.906814, -0.17751, 0.335809, 0.572857, 0.912855, -0.180101, 0.331597, 0.601554, 0.919438, -0.182116, 0.32698, 0.630198, 0.925962, -0.183494, 0.321449, 0.658404, 0.931734, -0.184159, 0.314595, 0.686625, 0.93762, -0.18304, 0.306462, 0.71531, 0.943858, -0.181323, 0.297514, 0.744272, 0.948662, -0.178683, 0.287447, 0.771462, 0.953299, -0.175379, 0.276166, 0.798593, 0.957346, -0.170395, 0.263758, 0.8256, 0.962565, -0.165042, 0.251019, 0.852575, 0.966075, -0.158655, 0.237011, 0.878316, 0.969048, -0.151707, 0.222518, 0.90329, 0.972423, -0.143271, 0.207848, 0.927745, 0.975833, -0.134824, 0.192463, 0.950859, 0.977629, -0.125444, 0.1768, 0.972947, 0.978995, -0.114949, 0.161033, 0.993263, 0.980533, -0.104936, 0.145523, 1.01337, 0.980745, -0.0935577, 0.129799, 1.03128, 0.981814, -0.0822956, 0.113486, 1.04825, 0.983943, -0.0710082, 0.0972925, 1.06405, 0.986141, -0.0587931, 0.0808138, 1.0785, 0.988878, -0.0472755, 0.0644915, 1.09204, 0.992132, -0.0349128, 0.0478128, 1.10413, 0.9953, -0.0232407, 0.031621, 1.11527, 0.998117, -0.0112713, 0.0154935, 1.12551, 1.00003, 0.000339743, -195763e-9, 1.13504, 0.845441, -729126e-11, 0.364305, 1.69208e-05, 0.843588, -183164e-9, 0.363506, 0.000425067, 0.843412, -73253e-8, 0.36343, 0.00169999, 0.843401, -164818e-8, 0.363426, 0.00382495, 0.843399, -293008e-8, 0.363425, 0.00679993, 0.843401, -457822e-8, 0.363425, 0.010625, 0.843394, -659249e-8, 0.363421, 0.0153002, 0.843398, -897282e-8, 0.363421, 0.0208258, 0.843415, -0.0117191, 0.363426, 0.0272024, 0.843438, -0.0148312, 0.363432, 0.0344305, 0.843483, -0.018309, 0.363447, 0.0425116, 0.84356, -0.0221521, 0.363472, 0.0514471, 0.843646, -0.0263597, 0.363499, 0.061238, 0.843743, -0.0309315, 0.363527, 0.0718873, 0.84388, -0.0358658, 0.363569, 0.0833969, 0.844079, -0.0411624, 0.363631, 0.0957742, 0.844279, -0.0468128, 0.363688, 0.109015, 0.844549, -0.0527923, 0.363761, 0.123124, 0.844858, -0.0588204, 0.363817, 0.138044, 0.84522, -0.0647573, 0.36383, 0.153755, 0.845669, -0.0713181, 0.363879, 0.170394, 0.846155, -0.0781697, 0.363908, 0.187861, 0.846789, -0.0853913, 0.363969, 0.206176, 0.847502, -0.0928086, 0.363999, 0.225244, 0.8484, -0.10005, 0.363997, 0.244926, 0.849461, -0.107615, 0.364008, 0.265188, 0.850562, -0.115814, 0.364055, 0.28587, 0.851962, -0.124334, 0.364179, 0.306926, 0.854326, -0.131995, 0.364233, 0.329605, 0.856295, -0.139338, 0.363856, 0.35359, 0.858857, -0.146346, 0.363347, 0.37831, 0.862428, -0.152994, 0.362807, 0.403722, 0.866203, -0.159463, 0.361963, 0.429537, 0.871629, -0.165623, 0.36112, 0.456, 0.877365, -0.171649, 0.359917, 0.482773, 0.883744, -0.177151, 0.35848, 0.509705, 0.890693, -0.182381, 0.356523, 0.537215, 0.897278, -0.186076, 0.3533, 0.565493, 0.903958, -0.188602, 0.349095, 0.594293, 0.910908, -0.190755, 0.344215, 0.623165, 0.918117, -0.192063, 0.338606, 0.651573, 0.924644, -0.192758, 0.331544, 0.679869, 0.931054, -0.192238, 0.323163, 0.708668, 0.937303, -0.190035, 0.313529, 0.737201, 0.943387, -0.187162, 0.303152, 0.764977, 0.948494, -0.183876, 0.29146, 0.792683, 0.952546, -0.178901, 0.277917, 0.819228, 0.958077, -0.173173, 0.264753, 0.846559, 0.962462, -0.16645, 0.25002, 0.872962, 0.966569, -0.159452, 0.234873, 0.898729, 0.969108, -0.15074, 0.218752, 0.923126, 0.973072, -0.141523, 0.202673, 0.947278, 0.975452, -0.132075, 0.186326, 0.969938, 0.977784, -0.121257, 0.169396, 0.991325, 0.97899, -0.110182, 0.153044, 1.01123, 0.979777, -0.0989634, 0.136485, 1.0299, 0.980865, -0.0865894, 0.119343, 1.04727, 0.982432, -0.0746115, 0.102452, 1.06341, 0.984935, -0.0621822, 0.0852423, 1.07834, 0.987776, -0.0495694, 0.0678546, 1.092, 0.99103, -0.0372386, 0.0506917, 1.1043, 0.99474, -0.0244353, 0.0333316, 1.11576, 0.997768, -0.0121448, 0.0164348, 1.12617, 1.00003, 0.00031774, -169504e-9, 1.13598, 0.825551, -756799e-11, 0.378425, 1.65099e-05, 0.82664, -190922e-9, 0.378923, 0.000416504, 0.826323, -763495e-9, 0.378779, 0.0016656, 0.826359, -171789e-8, 0.378795, 0.00374768, 0.82636, -305402e-8, 0.378795, 0.00666259, 0.826368, -477185e-8, 0.378798, 0.0104104, 0.826364, -687131e-8, 0.378795, 0.0149912, 0.826368, -935232e-8, 0.378795, 0.0204054, 0.826376, -0.0122146, 0.378797, 0.0266532, 0.826399, -0.0154581, 0.378803, 0.0337355, 0.82646, -0.0190825, 0.378824, 0.0416537, 0.826525, -0.0230873, 0.378846, 0.0504091, 0.826614, -0.0274719, 0.378876, 0.0600032, 0.82674, -0.0322355, 0.378917, 0.0704393, 0.826888, -0.0373766, 0.378964, 0.0817195, 0.827078, -0.0428936, 0.379024, 0.0938492, 0.827318, -0.0487778, 0.379099, 0.106828, 0.82764, -0.0549935, 0.379199, 0.120659, 0.827926, -0.0611058, 0.379227, 0.13526, 0.828325, -0.0675054, 0.379275, 0.150713, 0.828801, -0.0743455, 0.379332, 0.167034, 0.8294, -0.0815523, 0.379415, 0.184209, 0.830094, -0.0890779, 0.379495, 0.202203, 0.8309, -0.096736, 0.379555, 0.220945, 0.831943, -0.104135, 0.379577, 0.240306, 0.833037, -0.112106, 0.379604, 0.260317, 0.834278, -0.120554, 0.379668, 0.2808, 0.836192, -0.129128, 0.3799, 0.301654, 0.838671, -0.137541, 0.380109, 0.323502, 0.840939, -0.14523, 0.379809, 0.347176, 0.844575, -0.15248, 0.379593, 0.371706, 0.848379, -0.159607, 0.37909, 0.39688, 0.853616, -0.166267, 0.378617, 0.422702, 0.858921, -0.172698, 0.377746, 0.448919, 0.865324, -0.178823, 0.376749, 0.475661, 0.872207, -0.184542, 0.375363, 0.502599, 0.880018, -0.189836, 0.373657, 0.529914, 0.88694, -0.194294, 0.370673, 0.557683, 0.894779, -0.197022, 0.36662, 0.586848, 0.902242, -0.199108, 0.36138, 0.615831, 0.909914, -0.200398, 0.355434, 0.644478, 0.917088, -0.20094, 0.348173, 0.672905, 0.923888, -0.200671, 0.339482, 0.701327, 0.930495, -0.198773, 0.32956, 0.730101, 0.937247, -0.195394, 0.318363, 0.758383, 0.943108, -0.191956, 0.306323, 0.786539, 0.948296, -0.187227, 0.292576, 0.813637, 0.953472, -0.181165, 0.278234, 0.840793, 0.958485, -0.174119, 0.263054, 0.867712, 0.962714, -0.166564, 0.246756, 0.893635, 0.966185, -0.158181, 0.229945, 0.919028, 0.970146, -0.148275, 0.212633, 0.943413, 0.973491, -0.138157, 0.195229, 0.966627, 0.975741, -0.127574, 0.178048, 0.988817, 0.977238, -0.11554, 0.160312, 1.00924, 0.978411, -0.10364, 0.142857, 1.02845, 0.979811, -0.0913122, 0.125317, 1.04648, 0.98116, -0.0782558, 0.107627, 1.06284, 0.983543, -0.0655957, 0.0895862, 1.07798, 0.986789, -0.0520411, 0.0713756, 1.092, 0.990292, -0.0389727, 0.053228, 1.10484, 0.994187, -0.025808, 0.0351945, 1.11642, 0.997499, -0.0126071, 0.0173198, 1.12703, 0.999999, 0.000275604, -148602e-9, 1.13674, 0.81075, -78735e-10, 0.394456, 1.61829e-05, 0.808692, -198293e-9, 0.393453, 0.000407564, 0.80846, -792877e-9, 0.39334, 0.00162965, 0.808595, -178416e-8, 0.393407, 0.00366711, 0.808597, -317182e-8, 0.393408, 0.00651934, 0.808598, -495589e-8, 0.393408, 0.0101866, 0.808591, -713627e-8, 0.393403, 0.0146689, 0.808592, -971285e-8, 0.393402, 0.0199667, 0.80861, -0.0126855, 0.393407, 0.0260803, 0.808633, -0.0160538, 0.393413, 0.0330107, 0.80868, -0.0198175, 0.393429, 0.0407589, 0.808748, -0.0239758, 0.393453, 0.0493264, 0.808854, -0.0285286, 0.39349, 0.0587161, 0.808992, -0.0334748, 0.39354, 0.0689304, 0.809141, -0.0388116, 0.393588, 0.0799707, 0.809352, -0.0445375, 0.39366, 0.0918432, 0.809608, -0.0506427, 0.393742, 0.104549, 0.809915, -0.0570708, 0.393834, 0.118085, 0.810253, -0.0633526, 0.393885, 0.132377, 0.810687, -0.0700966, 0.393953, 0.147537, 0.811233, -0.0772274, 0.394047, 0.163543, 0.811865, -0.0847629, 0.394148, 0.180394, 0.812648, -0.0925663, 0.394265, 0.198051, 0.813583, -0.100416, 0.394363, 0.216443, 0.814683, -0.108119, 0.394402, 0.235502, 0.815948, -0.11644, 0.394489, 0.255242, 0.817278, -0.125036, 0.394542, 0.275441, 0.819605, -0.133655, 0.39486, 0.296094, 0.822256, -0.142682, 0.395248, 0.317309, 0.825349, -0.150756, 0.395241, 0.340516, 0.829605, -0.158392, 0.395285, 0.364819, 0.83391, -0.165801, 0.394922, 0.389736, 0.839808, -0.172677, 0.394691, 0.415409, 0.845708, -0.179448, 0.394006, 0.441546, 0.853025, -0.185746, 0.393279, 0.46832, 0.859666, -0.191684, 0.391655, 0.495302, 0.86789, -0.197146, 0.390068, 0.52262, 0.875845, -0.201904, 0.38727, 0.550336, 0.882634, -0.205023, 0.382688, 0.578825, 0.891076, -0.207098, 0.377543, 0.608103, 0.900589, -0.208474, 0.371752, 0.63723, 0.90791, -0.209068, 0.364016, 0.665769, 0.915971, -0.208655, 0.355593, 0.694428, 0.923455, -0.20729, 0.345439, 0.723224, 0.931514, -0.203821, 0.334099, 0.751925, 0.937885, -0.19986, 0.321069, 0.780249, 0.943136, -0.194993, 0.306571, 0.8077, 0.948818, -0.189132, 0.291556, 0.83497, 0.954433, -0.181617, 0.275745, 0.86188, 0.959078, -0.173595, 0.258695, 0.888562, 0.962705, -0.164855, 0.240825, 0.914008, 0.966753, -0.155129, 0.22268, 0.939145, 0.970704, -0.144241, 0.204542, 0.963393, 0.973367, -0.133188, 0.185927, 0.985983, 0.975984, -0.121146, 0.167743, 1.00704, 0.976994, -0.108366, 0.149218, 1.02715, 0.978485, -0.0956746, 0.13131, 1.0455, 0.980074, -0.0820733, 0.112513, 1.06221, 0.98225, -0.0684061, 0.0938323, 1.07782, 0.98553, -0.0549503, 0.0749508, 1.09199, 0.989529, -0.0407857, 0.055848, 1.10508, 0.993536, -0.0271978, 0.0368581, 1.11684, 0.997247, -0.0132716, 0.0181845, 1.12789, 1, 0.000431817, -198809e-9, 1.13792, 0.785886, -812608e-11, 0.405036, 1.57669e-05, 0.790388, -205278e-9, 0.407355, 0.000398297, 0.790145, -820824e-9, 0.407231, 0.00159263, 0.790135, -184681e-8, 0.407226, 0.00358336, 0.790119, -328316e-8, 0.407218, 0.00637039, 0.790126, -512988e-8, 0.40722, 0.0099539, 0.79013, -738684e-8, 0.407221, 0.0143339, 0.790135, -0.0100538, 0.407221, 0.0195107, 0.790134, -0.0131306, 0.407217, 0.0254848, 0.79016, -0.0166169, 0.407224, 0.0322572, 0.790197, -0.020512, 0.407236, 0.0398284, 0.790273, -0.0248157, 0.407263, 0.0482014, 0.790381, -0.029527, 0.407304, 0.0573777, 0.790521, -0.0346446, 0.407355, 0.0673602, 0.790704, -0.0401665, 0.40742, 0.0781522, 0.790925, -0.0460896, 0.407499, 0.0897582, 0.791195, -0.0524017, 0.407589, 0.10218, 0.791522, -0.0590121, 0.407691, 0.11541, 0.791878, -0.0654876, 0.407748, 0.12939, 0.792361, -0.0725207, 0.407849, 0.144237, 0.792942, -0.0799844, 0.407963, 0.159924, 0.79362, -0.0877896, 0.408087, 0.176425, 0.794529, -0.0958451, 0.408259, 0.193733, 0.795521, -0.103827, 0.408362, 0.211756, 0.796778, -0.111937, 0.408482, 0.230524, 0.798027, -0.120521, 0.408547, 0.249967, 0.799813, -0.129242, 0.408721, 0.269926, 0.802387, -0.138048, 0.409148, 0.290338, 0.805279, -0.147301, 0.409641, 0.311193, 0.809251, -0.155895, 0.410154, 0.333611, 0.813733, -0.163942, 0.410297, 0.357615, 0.819081, -0.171666, 0.410373, 0.382339, 0.825427, -0.178905, 0.410348, 0.407828, 0.83172, -0.185812, 0.409486, 0.434034, 0.83877, -0.192318, 0.408776, 0.460493, 0.845817, -0.198249, 0.407176, 0.487346, 0.854664, -0.204034, 0.405719, 0.514832, 0.863495, -0.208908, 0.403282, 0.542401, 0.871883, -0.212765, 0.399293, 0.570683, 0.88065, -0.214911, 0.393803, 0.599947, 0.89004, -0.216214, 0.387536, 0.62932, 0.898476, -0.216745, 0.379846, 0.658319, 0.906738, -0.216387, 0.370625, 0.687138, 0.914844, -0.215053, 0.360139, 0.71601, 0.923877, -0.212007, 0.348849, 0.745124, 0.931925, -0.207481, 0.335639, 0.773366, 0.938054, -0.202418, 0.320798, 0.801636, 0.943895, -0.196507, 0.304772, 0.829055, 0.949468, -0.189009, 0.288033, 0.856097, 0.955152, -0.180539, 0.270532, 0.88301, 0.959403, -0.171437, 0.251639, 0.909296, 0.963309, -0.161661, 0.232563, 0.934868, 0.967399, -0.150425, 0.213231, 0.959662, 0.972009, -0.138659, 0.194247, 0.98302, 0.97433, -0.126595, 0.174718, 1.00517, 0.975823, -0.113205, 0.155518, 1.02566, 0.976371, -0.0996096, 0.136709, 1.04418, 0.978705, -0.0860754, 0.117571, 1.06146, 0.981477, -0.0714438, 0.0980046, 1.07777, 0.984263, -0.0572304, 0.0782181, 1.09214, 0.988423, -0.0428875, 0.0584052, 1.10553, 0.993, -0.0282442, 0.038522, 1.11758, 0.99704, -0.0140183, 0.0190148, 1.12864, 0.999913, 0.000369494, -145203e-9, 1.13901, 0.777662, -84153e-10, 0.423844, 1.54403e-05, 0.770458, -211714e-9, 0.419915, 0.00038845, 0.770716, -846888e-9, 0.420055, 0.00155386, 0.770982, -190567e-8, 0.420202, 0.00349653, 0.770981, -338782e-8, 0.420201, 0.00621606, 0.77098, -529338e-8, 0.4202, 0.00971274, 0.770983, -762223e-8, 0.4202, 0.0139867, 0.770985, -0.0103741, 0.420198, 0.0190381, 0.770996, -0.0135489, 0.4202, 0.0248677, 0.771029, -0.0171461, 0.420212, 0.0314764, 0.771052, -0.0211647, 0.420215, 0.0388648, 0.771131, -0.0256048, 0.420245, 0.047036, 0.771235, -0.0304647, 0.420284, 0.0559911, 0.771383, -0.0357436, 0.420341, 0.0657346, 0.771591, -0.0414392, 0.420423, 0.0762694, 0.771819, -0.0475462, 0.420506, 0.0875984, 0.772123, -0.0540506, 0.420617, 0.099727, 0.772464, -0.060797, 0.42072, 0.112637, 0.772855, -0.0675393, 0.420799, 0.126313, 0.773317, -0.0748323, 0.420893, 0.140824, 0.773981, -0.0825681, 0.421058, 0.15617, 0.774746, -0.0906307, 0.421226, 0.172322, 0.77566, -0.0988982, 0.421397, 0.189253, 0.776837, -0.106994, 0.421569, 0.206912, 0.778097, -0.115528, 0.421704, 0.225359, 0.779588, -0.124317, 0.421849, 0.24447, 0.781574, -0.133139, 0.422097, 0.264156, 0.784451, -0.142179, 0.422615, 0.284318, 0.787682, -0.15165, 0.423269, 0.304902, 0.792433, -0.160771, 0.424396, 0.3265, 0.797359, -0.169166, 0.424772, 0.35014, 0.803986, -0.177149, 0.425475, 0.374768, 0.809504, -0.184745, 0.424996, 0.399928, 0.815885, -0.19173, 0.424247, 0.425796, 0.823513, -0.198525, 0.423515, 0.452287, 0.832549, -0.204709, 0.422787, 0.479321, 0.841653, -0.210447, 0.421187, 0.506718, 0.850401, -0.215501, 0.418519, 0.53432, 0.859854, -0.219752, 0.414715, 0.56242, 0.869364, -0.222305, 0.409462, 0.591558, 0.878837, -0.223744, 0.402926, 0.621074, 0.888636, -0.224065, 0.395043, 0.650538, 0.898132, -0.223742, 0.38564, 0.679538, 0.907181, -0.222308, 0.375378, 0.708674, 0.915621, -0.219837, 0.363212, 0.737714, 0.9239, -0.215233, 0.349313, 0.767014, 0.931644, -0.209592, 0.334162, 0.795133, 0.938887, -0.203644, 0.317943, 0.823228, 0.945282, -0.196349, 0.300581, 0.850822, 0.950758, -0.18742, 0.282195, 0.877594, 0.956146, -0.177879, 0.262481, 0.904564, 0.960355, -0.167643, 0.242487, 0.930741, 0.965256, -0.156671, 0.222668, 0.955868, 0.968029, -0.144123, 0.201907, 0.979869, 0.97251, -0.131305, 0.18202, 1.00291, 0.974925, -0.118335, 0.161909, 1.02392, 0.975402, -0.103714, 0.142129, 1.0433, 0.976987, -0.089415, 0.122447, 1.06089, 0.979677, -0.0748858, 0.102248, 1.07713, 0.983184, -0.0596086, 0.0814851, 1.09218, 0.987466, -0.0447671, 0.0609484, 1.10585, 0.992348, -0.0295217, 0.0401835, 1.11829, 0.996674, -0.0143917, 0.0198163, 1.12966, 1.00003, 0.000321364, -149983e-9, 1.1402, 0.757901, -869074e-11, 0.436176, 1.51011e-05, 0.751195, -217848e-9, 0.432317, 0.000378533, 0.751178, -871373e-9, 0.432307, 0.0015141, 0.751195, -196061e-8, 0.432317, 0.0034068, 0.751198, -348552e-8, 0.432318, 0.00605659, 0.751195, -544599e-8, 0.432315, 0.00946353, 0.751207, -784203e-8, 0.43232, 0.013628, 0.751213, -0.0106732, 0.43232, 0.0185499, 0.751221, -0.0139393, 0.432319, 0.0242302, 0.751244, -0.0176398, 0.432325, 0.0306694, 0.7513, -0.0217743, 0.432348, 0.0378698, 0.751358, -0.0263412, 0.432367, 0.0458321, 0.751458, -0.0313396, 0.432404, 0.0545587, 0.751608, -0.0367682, 0.432464, 0.0640543, 0.7518, -0.0426246, 0.43254, 0.0743222, 0.752065, -0.0489031, 0.432645, 0.0853668, 0.752376, -0.0555828, 0.432762, 0.0971911, 0.752715, -0.0623861, 0.432859, 0.109768, 0.753137, -0.069415, 0.432958, 0.123126, 0.753676, -0.0770039, 0.433099, 0.137308, 0.754345, -0.084971, 0.433272, 0.15229, 0.755235, -0.0932681, 0.433504, 0.168075, 0.756186, -0.10171, 0.433693, 0.184625, 0.757363, -0.110019, 0.433857, 0.201897, 0.75884, -0.11887, 0.434102, 0.220014, 0.760467, -0.127881, 0.434306, 0.238778, 0.762969, -0.136766, 0.434751, 0.258172, 0.765823, -0.14612, 0.43529, 0.278062, 0.769676, -0.15566, 0.436236, 0.298437, 0.774909, -0.165177, 0.437754, 0.319532, 0.77994, -0.17402, 0.438343, 0.342505, 0.785757, -0.182201, 0.438609, 0.366693, 0.792487, -0.190104, 0.438762, 0.391668, 0.80038, -0.197438, 0.438795, 0.417494, 0.808494, -0.204365, 0.438226, 0.443933, 0.817695, -0.210714, 0.437283, 0.470929, 0.828111, -0.216651, 0.436087, 0.498569, 0.837901, -0.221804, 0.433717, 0.526165, 0.847813, -0.226318, 0.430133, 0.554155, 0.858314, -0.229297, 0.425213, 0.582822, 0.868891, -0.230999, 0.418576, 0.612847, 0.878941, -0.231155, 0.410405, 0.642445, 0.888809, -0.230935, 0.400544, 0.672024, 0.898089, -0.229343, 0.389613, 0.701366, 0.908081, -0.226886, 0.377197, 0.730763, 0.916819, -0.222676, 0.363397, 0.759642, 0.924968, -0.216835, 0.347437, 0.788775, 0.932906, -0.210245, 0.32995, 0.817135, 0.940025, -0.202992, 0.312262, 0.844912, 0.946101, -0.19436, 0.293313, 0.872164, 0.952835, -0.184125, 0.273638, 0.899443, 0.957347, -0.173657, 0.252385, 0.926389, 0.961434, -0.162204, 0.231038, 0.951947, 0.965522, -0.14979, 0.209834, 0.976751, 0.969412, -0.136307, 0.188821, 1.00022, 0.973902, -0.122527, 0.168013, 1.02229, 0.974045, -0.108213, 0.147634, 1.04199, 0.975775, -0.0927397, 0.12705, 1.06019, 0.978383, -0.0778212, 0.106309, 1.07711, 0.98211, -0.0621216, 0.0849279, 1.09245, 0.986517, -0.0463847, 0.0633519, 1.10651, 0.991696, -0.0309353, 0.0419698, 1.11903, 0.996349, -0.0150914, 0.0206272, 1.13073, 1.00003, 0.000442449, -231396e-9, 1.14146, 0.727498, -885074e-11, 0.441528, 1.45832e-05, 0.730897, -223525e-9, 0.443589, 0.000368298, 0.730796, -893996e-9, 0.443528, 0.00147303, 0.730805, -201149e-8, 0.443533, 0.00331433, 0.730814, -357596e-8, 0.443538, 0.00589222, 0.730815, -558734e-8, 0.443538, 0.00920678, 0.730822, -804544e-8, 0.44354, 0.0132582, 0.730836, -0.0109501, 0.443545, 0.0180468, 0.730848, -0.0143008, 0.443546, 0.0235732, 0.730871, -0.0180969, 0.443552, 0.0298382, 0.730915, -0.022338, 0.443567, 0.0368438, 0.730982, -0.0270225, 0.443591, 0.044591, 0.731076, -0.0321491, 0.443627, 0.0530831, 0.731245, -0.0377166, 0.443699, 0.0623243, 0.73144, -0.0437216, 0.443777, 0.0723181, 0.7317, -0.0501576, 0.443881, 0.0830691, 0.732034, -0.0569942, 0.444014, 0.0945809, 0.732388, -0.0638756, 0.444113, 0.106825, 0.732853, -0.071203, 0.444247, 0.119859, 0.733473, -0.0790076, 0.444442, 0.13369, 0.734195, -0.0871937, 0.444645, 0.148304, 0.735069, -0.095696, 0.444877, 0.163702, 0.736169, -0.10426, 0.445133, 0.179861, 0.73747, -0.112853, 0.44537, 0.196778, 0.738991, -0.12199, 0.445651, 0.214496, 0.740865, -0.131153, 0.445958, 0.232913, 0.743637, -0.140245, 0.446548, 0.251977, 0.746797, -0.149722, 0.447246, 0.271551, 0.751517, -0.159341, 0.448656, 0.291774, 0.756156, -0.169106, 0.449866, 0.312455, 0.761519, -0.178436, 0.450919, 0.334552, 0.768295, -0.186904, 0.451776, 0.358491, 0.776613, -0.195117, 0.452832, 0.383446, 0.783966, -0.202695, 0.45249, 0.408945, 0.793542, -0.20985, 0.452587, 0.435364, 0.803192, -0.216403, 0.451852, 0.462336, 0.813892, -0.22251, 0.450708, 0.48987, 0.824968, -0.227676, 0.4486, 0.517697, 0.835859, -0.232443, 0.445156, 0.545975, 0.846825, -0.235775, 0.440351, 0.574483, 0.858085, -0.237897, 0.433641, 0.604246, 0.868825, -0.238074, 0.425354, 0.634101, 0.879638, -0.237661, 0.415383, 0.664201, 0.889966, -0.236186, 0.404136, 0.693918, 0.899479, -0.233599, 0.390917, 0.723481, 0.908769, -0.229737, 0.376352, 0.75258, 0.917966, -0.223836, 0.360372, 0.781764, 0.926304, -0.217067, 0.342551, 0.811139, 0.934626, -0.209309, 0.324238, 0.839585, 0.941841, -0.20071, 0.304484, 0.867044, 0.94789, -0.190602, 0.283607, 0.894579, 0.954196, -0.179253, 0.262205, 0.921743, 0.958383, -0.167646, 0.239847, 0.948026, 0.963119, -0.155073, 0.218078, 0.973296, 0.966941, -0.141426, 0.195899, 0.998135, 0.970836, -0.126849, 0.174121, 1.02021, 0.973301, -0.112296, 0.153052, 1.04085, 0.97448, -0.0964965, 0.131733, 1.05946, 0.977045, -0.080489, 0.10997, 1.07693, 0.980751, -0.064844, 0.0881657, 1.09254, 0.985475, -0.0481938, 0.0657987, 1.10697, 0.991089, -0.0319185, 0.0435215, 1.12004, 0.996122, -0.0158088, 0.0214779, 1.13173, 1.00001, 0.000372455, -200295e-9, 1.14291, 0.708622, -907597e-11, 0.45304, 1.41962e-05, 0.711162, -228911e-9, 0.454662, 0.000358052, 0.709812, -914446e-9, 0.453797, 0.00143034, 0.709865, -205819e-8, 0.453834, 0.00321935, 0.709864, -365894e-8, 0.453833, 0.00572331, 0.709855, -571692e-8, 0.453826, 0.00894278, 0.709862, -823201e-8, 0.453828, 0.012878, 0.709875, -0.011204, 0.453832, 0.0175295, 0.709896, -0.0146323, 0.453839, 0.0228978, 0.709925, -0.0185163, 0.453847, 0.0289839, 0.709974, -0.0228551, 0.453866, 0.0357894, 0.710045, -0.0276473, 0.453892, 0.0433161, 0.710133, -0.032891, 0.453924, 0.0515665, 0.710292, -0.0385851, 0.453992, 0.0605458, 0.710485, -0.0447254, 0.45407, 0.0702574, 0.710769, -0.0513051, 0.454192, 0.0807077, 0.711106, -0.0582733, 0.454329, 0.091896, 0.711516, -0.0652866, 0.45446, 0.103814, 0.712071, -0.0728426, 0.454653, 0.116508, 0.712676, -0.0808307, 0.45484, 0.129968, 0.713476, -0.0892216, 0.455096, 0.144206, 0.714377, -0.0979047, 0.455346, 0.159212, 0.715579, -0.106531, 0.455647, 0.174973, 0.716977, -0.115492, 0.455961, 0.191504, 0.71862, -0.124821, 0.456315, 0.208835, 0.72084, -0.134079, 0.4568, 0.226869, 0.723786, -0.143427, 0.457521, 0.245582, 0.727464, -0.153061, 0.458475, 0.264957, 0.732771, -0.162768, 0.460239, 0.284948, 0.736515, -0.172627, 0.460899, 0.30522, 0.743519, -0.182487, 0.463225, 0.326717, 0.750041, -0.191295, 0.464027, 0.350113, 0.758589, -0.199746, 0.465227, 0.374782, 0.767703, -0.207584, 0.465877, 0.400226, 0.777484, -0.214973, 0.465996, 0.426442, 0.788792, -0.221796, 0.466019, 0.453688, 0.800194, -0.228038, 0.465083, 0.481246, 0.811234, -0.233346, 0.462506, 0.509086, 0.822859, -0.238073, 0.459257, 0.537338, 0.835082, -0.241764, 0.454863, 0.566108, 0.846332, -0.244241, 0.448163, 0.595126, 0.858355, -0.244736, 0.439709, 0.625574, 0.87034, -0.244278, 0.429837, 0.65617, 0.881027, -0.24255, 0.418002, 0.686029, 0.891007, -0.239912, 0.404325, 0.716039, 0.900874, -0.236133, 0.389222, 0.745518, 0.911072, -0.230672, 0.373269, 0.775026, 0.920359, -0.22356, 0.355083, 0.804521, 0.928604, -0.215591, 0.335533, 0.834045, 0.937175, -0.206503, 0.315278, 0.861612, 0.942825, -0.196684, 0.293653, 0.889131, 0.949805, -0.185116, 0.271503, 0.916853, 0.955535, -0.172703, 0.248821, 0.943541, 0.959843, -0.159978, 0.225591, 0.970132, 0.964393, -0.146375, 0.202719, 0.994709, 0.968008, -0.131269, 0.179928, 1.0186, 0.971013, -0.11569, 0.158007, 1.03928, 0.973334, -0.1003, 0.13624, 1.05887, 0.975775, -0.0833352, 0.1138, 1.07652, 0.979579, -0.0668981, 0.0913141, 1.09297, 0.984323, -0.0500902, 0.0683051, 1.10734, 0.990351, -0.0332377, 0.0451771, 1.12084, 0.995823, -0.0161491, 0.0221705, 1.13296, 1.0001, 0.000234083, -108712e-9, 1.14441, 0.683895, -924677e-11, 0.46015, 1.37429e-05, 0.68833, -233383e-9, 0.463134, 0.000346865, 0.688368, -933547e-9, 0.463159, 0.00138748, 0.688367, -210049e-8, 0.463159, 0.00312187, 0.688369, -373415e-8, 0.463159, 0.00555004, 0.688377, -583449e-8, 0.463163, 0.00867216, 0.688386, -840128e-8, 0.463166, 0.0124884, 0.688398, -0.0114343, 0.463169, 0.0169993, 0.688418, -0.0149329, 0.463175, 0.0222054, 0.688453, -0.0188964, 0.463188, 0.028108, 0.688515, -0.0233239, 0.463214, 0.0347085, 0.68857, -0.0282136, 0.463231, 0.0420091, 0.688679, -0.033564, 0.463276, 0.0500132, 0.688854, -0.0393733, 0.463356, 0.0587255, 0.689038, -0.0456354, 0.46343, 0.0681476, 0.689321, -0.0523433, 0.463553, 0.0782897, 0.689662, -0.059412, 0.463693, 0.0891501, 0.690188, -0.0665736, 0.4639, 0.100735, 0.690755, -0.0743106, 0.464107, 0.113074, 0.691405, -0.0824722, 0.464329, 0.126161, 0.692198, -0.0910484, 0.464585, 0.140007, 0.693196, -0.0998778, 0.464893, 0.154612, 0.69454, -0.108651, 0.465285, 0.169984, 0.695921, -0.117855, 0.465596, 0.186106, 0.697749, -0.12734, 0.466056, 0.203034, 0.700375, -0.136714, 0.466771, 0.220703, 0.703395, -0.146386, 0.467579, 0.239062, 0.707904, -0.156096, 0.469067, 0.258188, 0.711673, -0.165904, 0.469851, 0.277759, 0.717489, -0.175812, 0.471815, 0.297935, 0.724051, -0.185931, 0.47389, 0.318916, 0.731965, -0.195238, 0.47587, 0.341591, 0.741151, -0.204021, 0.477523, 0.366062, 0.751416, -0.212113, 0.478881, 0.391396, 0.761848, -0.21979, 0.479226, 0.417599, 0.771886, -0.2267, 0.478495, 0.444401, 0.783998, -0.232991, 0.477622, 0.472084, 0.796523, -0.238645, 0.475833, 0.500193, 0.808851, -0.243396, 0.472568, 0.52865, 0.821191, -0.247226, 0.467857, 0.557362, 0.834261, -0.250102, 0.461871, 0.586768, 0.846762, -0.251056, 0.453543, 0.617085, 0.859867, -0.250604, 0.443494, 0.647659, 0.871948, -0.248783, 0.431711, 0.678119, 0.882967, -0.245855, 0.417911, 0.708399, 0.892826, -0.242168, 0.401993, 0.738256, 0.90332, -0.237062, 0.385371, 0.767999, 0.913633, -0.22997, 0.366837, 0.798191, 0.922774, -0.221687, 0.346372, 0.827756, 0.931371, -0.212345, 0.325682, 0.856425, 0.938929, -0.20206, 0.303665, 0.884299, 0.944821, -0.190981, 0.280786, 0.912023, 0.951792, -0.178065, 0.2573, 0.939669, 0.957712, -0.164634, 0.233448, 0.96655, 0.961912, -0.150863, 0.209504, 0.992366, 0.966382, -0.13577, 0.18597, 1.01633, 0.969588, -0.119593, 0.162905, 1.03843, 0.971777, -0.103203, 0.14053, 1.05841, 0.97433, -0.0865888, 0.117909, 1.07632, 0.978686, -0.0690829, 0.0944101, 1.09326, 0.983281, -0.0516568, 0.0705671, 1.10796, 0.989562, -0.034558, 0.0468592, 1.12182, 0.995465, -0.0167808, 0.0229846, 1.1342, 0.999991, 0.000373016, -235606e-9, 1.1459, 0.662251, -939016e-11, 0.468575, 1.32714e-05, 0.666634, -237624e-9, 0.471675, 0.000335842, 0.666411, -950385e-9, 0.471516, 0.00134321, 0.666399, -213833e-8, 0.471509, 0.00302221, 0.666386, -38014e-7, 0.471499, 0.00537283, 0.666405, -593958e-8, 0.471511, 0.00839533, 0.666406, -855253e-8, 0.471508, 0.0120898, 0.666428, -0.0116401, 0.471519, 0.0164569, 0.666444, -0.0152015, 0.471522, 0.0214971, 0.66649, -0.0192362, 0.471543, 0.027212, 0.666537, -0.0237428, 0.471558, 0.033603, 0.666617, -0.0287198, 0.471591, 0.0406728, 0.666718, -0.0341647, 0.471631, 0.0484238, 0.666889, -0.0400759, 0.47171, 0.0568621, 0.667104, -0.0464479, 0.471805, 0.0659915, 0.667374, -0.0532677, 0.471923, 0.0758178, 0.667772, -0.0603805, 0.472098, 0.0863425, 0.668371, -0.0677392, 0.472363, 0.0975917, 0.668971, -0.0756028, 0.472596, 0.109567, 0.669696, -0.0839293, 0.472869, 0.122272, 0.670481, -0.0926683, 0.473126, 0.135718, 0.6715, -0.1016, 0.473442, 0.149914, 0.672911, -0.110566, 0.47389, 0.164882, 0.674512, -0.119984, 0.474354, 0.180602, 0.67651, -0.129574, 0.474922, 0.19711, 0.679292, -0.139106, 0.475764, 0.214371, 0.682798, -0.148993, 0.476886, 0.232405, 0.686955, -0.158737, 0.478179, 0.251153, 0.691406, -0.168754, 0.479432, 0.270436, 0.697438, -0.178703, 0.481481, 0.290374, 0.704761, -0.188955, 0.484143, 0.311044, 0.713599, -0.198814, 0.487007, 0.333003, 0.723194, -0.207869, 0.488962, 0.357144, 0.732601, -0.216189, 0.489815, 0.382169, 0.744193, -0.22398, 0.490888, 0.408227, 0.754907, -0.231156, 0.490355, 0.434928, 0.767403, -0.23747, 0.489548, 0.462599, 0.78107, -0.243503, 0.488274, 0.490908, 0.793893, -0.248114, 0.484843, 0.519421, 0.807296, -0.25222, 0.4803, 0.548561, 0.820529, -0.255265, 0.474097, 0.577772, 0.833716, -0.256741, 0.466041, 0.607782, 0.848403, -0.25637, 0.456547, 0.638807, 0.860755, -0.254804, 0.443946, 0.670058, 0.874012, -0.251834, 0.430852, 0.700749, 0.885619, -0.247867, 0.414903, 0.731446, 0.896069, -0.242634, 0.397276, 0.761191, 0.906266, -0.236093, 0.378535, 0.791053, 0.916759, -0.227543, 0.358038, 0.821298, 0.92523, -0.21783, 0.335705, 0.850747, 0.93436, -0.207534, 0.313797, 0.879258, 0.941631, -0.195983, 0.289671, 0.907734, 0.947564, -0.183567, 0.265319, 0.935206, 0.953681, -0.169345, 0.240815, 0.962739, 0.960008, -0.154909, 0.216119, 0.989227, 0.964145, -0.140161, 0.192096, 1.01465, 0.968171, -0.123411, 0.167855, 1.03737, 0.969859, -0.106525, 0.144817, 1.05767, 0.972666, -0.0891023, 0.12149, 1.0761, 0.977055, -0.0718094, 0.0975306, 1.09336, 0.982527, -0.0534213, 0.0730217, 1.10878, 0.989001, -0.0355579, 0.0483366, 1.12285, 0.99512, -0.0176383, 0.023938, 1.13548, 1.00007, 0.000368831, -211581e-9, 1.14744, 0.651047, -960845e-11, 0.484101, 1.2922e-05, 0.644145, -241347e-9, 0.478968, 0.000324578, 0.64396, -965142e-9, 0.478831, 0.00129798, 0.64396, -217154e-8, 0.47883, 0.00292046, 0.643968, -386049e-8, 0.478835, 0.00519202, 0.643974, -603186e-8, 0.478838, 0.0081128, 0.643977, -86854e-7, 0.478836, 0.011683, 0.643982, -0.0118207, 0.478834, 0.0159031, 0.644024, -0.0154374, 0.478856, 0.0207743, 0.644059, -0.0195343, 0.478868, 0.0262975, 0.644122, -0.0241103, 0.478896, 0.0324747, 0.644207, -0.0291638, 0.478933, 0.039309, 0.64432, -0.0346919, 0.478981, 0.0468029, 0.644481, -0.0406919, 0.479053, 0.0549614, 0.644722, -0.047159, 0.479169, 0.0637909, 0.645013, -0.0540748, 0.479302, 0.0732974, 0.645503, -0.0612001, 0.479541, 0.0834898, 0.646117, -0.0687303, 0.479829, 0.0943873, 0.646707, -0.0767846, 0.480061, 0.105991, 0.647431, -0.0852465, 0.480343, 0.11831, 0.64831, -0.0940719, 0.48066, 0.131348, 0.649486, -0.103056, 0.481083, 0.14514, 0.650864, -0.112261, 0.481528, 0.159676, 0.652604, -0.121852, 0.482102, 0.174979, 0.654825, -0.131505, 0.482813, 0.191079, 0.657876, -0.141189, 0.483876, 0.207927, 0.661339, -0.151239, 0.48499, 0.225586, 0.665463, -0.161091, 0.486279, 0.243947, 0.670542, -0.171235, 0.487968, 0.262957, 0.677361, -0.181347, 0.49053, 0.282781, 0.685672, -0.191679, 0.493862, 0.303311, 0.694551, -0.201781, 0.49699, 0.324607, 0.703753, -0.211164, 0.498884, 0.347916, 0.713703, -0.219675, 0.500086, 0.372628, 0.725911, -0.227836, 0.501554, 0.398694, 0.73862, -0.23533, 0.502193, 0.425529, 0.752118, -0.241786, 0.501811, 0.453209, 0.76579, -0.247865, 0.500185, 0.481381, 0.779568, -0.252696, 0.497159, 0.51011, 0.793991, -0.256802, 0.492765, 0.539322, 0.808182, -0.259942, 0.486827, 0.569078, 0.821698, -0.261703, 0.478386, 0.598818, 0.836009, -0.262006, 0.468772, 0.629762, 0.849824, -0.260333, 0.456352, 0.661366, 0.863888, -0.257398, 0.442533, 0.69295, 0.876585, -0.253264, 0.426573, 0.723608, 0.888665, -0.248026, 0.408964, 0.754378, 0.899537, -0.241487, 0.389677, 0.784761, 0.9094, -0.233463, 0.368516, 0.814688, 0.920166, -0.223397, 0.346624, 0.845009, 0.928899, -0.21255, 0.322717, 0.874431, 0.937156, -0.200869, 0.298698, 0.902922, 0.943861, -0.188387, 0.273491, 0.931356, 0.949557, -0.174341, 0.247866, 0.958854, 0.955862, -0.158994, 0.222496, 0.986098, 0.961721, -0.143664, 0.197522, 1.01229, 0.965976, -0.127412, 0.17302, 1.03571, 0.968652, -0.109798, 0.148954, 1.05699, 0.971084, -0.0916787, 0.125044, 1.07587, 0.975584, -0.0739634, 0.100577, 1.09372, 0.98122, -0.055322, 0.0753666, 1.10948, 0.988253, -0.0366825, 0.0498899, 1.12394, 0.99482, -0.0180389, 0.024611, 1.13694, 1.00001, 0.000229839, -188283e-9, 1.14919, 0.613867, -964198e-11, 0.479449, 1.23452e-05, 0.621485, -244534e-9, 0.485399, 0.000313091, 0.621429, -978202e-9, 0.485353, 0.00125245, 0.62112, -220004e-8, 0.485114, 0.00281687, 0.621119, -39111e-7, 0.485112, 0.00500783, 0.621122, -611091e-8, 0.485112, 0.00782498, 0.621133, -879922e-8, 0.485117, 0.0112687, 0.621152, -0.0119756, 0.485125, 0.0153394, 0.621183, -0.0156396, 0.485139, 0.0200382, 0.621227, -0.0197898, 0.485158, 0.0253663, 0.621298, -0.0244253, 0.485192, 0.0313261, 0.621388, -0.0295441, 0.485233, 0.0379204, 0.621507, -0.0351432, 0.485286, 0.0451523, 0.621693, -0.0412198, 0.485378, 0.0530277, 0.621933, -0.0477673, 0.485495, 0.0615522, 0.622232, -0.0547574, 0.485635, 0.0707316, 0.622809, -0.0619417, 0.485943, 0.0805883, 0.623407, -0.069625, 0.486232, 0.0911267, 0.62406, -0.077796, 0.486516, 0.102354, 0.624835, -0.0863731, 0.486838, 0.114279, 0.625758, -0.095251, 0.487188, 0.126902, 0.627043, -0.104299, 0.487695, 0.140285, 0.628438, -0.113724, 0.488163, 0.154397, 0.630325, -0.123417, 0.488858, 0.169267, 0.632801, -0.133137, 0.489754, 0.184941, 0.635784, -0.143052, 0.490815, 0.20136, 0.639406, -0.153132, 0.492048, 0.218643, 0.643872, -0.163143, 0.49363, 0.236615, 0.6499, -0.17333, 0.496009, 0.255449, 0.657201, -0.183622, 0.498994, 0.275006, 0.666221, -0.194019, 0.502888, 0.295354, 0.674419, -0.204192, 0.505459, 0.316244, 0.683729, -0.21406, 0.507771, 0.33849, 0.695584, -0.222854, 0.510245, 0.363166, 0.708583, -0.231315, 0.512293, 0.389071, 0.721233, -0.238911, 0.512747, 0.415737, 0.735134, -0.245657, 0.512482, 0.443331, 0.750179, -0.251879, 0.511526, 0.471891, 0.765073, -0.256911, 0.508935, 0.500892, 0.779794, -0.261144, 0.504341, 0.530294, 0.794801, -0.264316, 0.498515, 0.560144, 0.810339, -0.266276, 0.491015, 0.590213, 0.824818, -0.266981, 0.481126, 0.620865, 0.839375, -0.265778, 0.468685, 0.652687, 0.853043, -0.262748, 0.453925, 0.684759, 0.867335, -0.258474, 0.437912, 0.716209, 0.88037, -0.253187, 0.419648, 0.747508, 0.891711, -0.246476, 0.39982, 0.77797, 0.902896, -0.238735, 0.37879, 0.808586, 0.913601, -0.22885, 0.355891, 0.838843, 0.923019, -0.217656, 0.331773, 0.869014, 0.933432, -0.205539, 0.307356, 0.898512, 0.939691, -0.192595, 0.281321, 0.9269, 0.946938, -0.178945, 0.255441, 0.955297, 0.952372, -0.163587, 0.229013, 0.983231, 0.95909, -0.147214, 0.203179, 1.00971, 0.963675, -0.13064, 0.17792, 1.03438, 0.968247, -0.113121, 0.152898, 1.05625, 0.97001, -0.0945824, 0.128712, 1.07598, 0.974458, -0.0755648, 0.103349, 1.094, 0.980168, -0.0571998, 0.0776731, 1.1104, 0.987295, -0.0377994, 0.0514445, 1.12491, 0.994432, -0.0186417, 0.025429, 1.13851, 0.999975, 0.000542714, -282356e-9, 1.15108, 0.592656, -980249e-11, 0.486018, 1.19532e-05, 0.598467, -247275e-9, 0.490781, 0.000301531, 0.597934, -988317e-9, 0.490343, 0.00120517, 0.597903, -222366e-8, 0.490319, 0.0027116, 0.597913, -395315e-8, 0.490327, 0.00482077, 0.597919, -617653e-8, 0.490329, 0.00753264, 0.597936, -889375e-8, 0.490339, 0.0108478, 0.597956, -0.0121043, 0.490347, 0.0147668, 0.597992, -0.0158073, 0.490365, 0.0192905, 0.598032, -0.0200017, 0.490382, 0.0244204, 0.598109, -0.0246865, 0.49042, 0.0301593, 0.598215, -0.0298594, 0.490474, 0.03651, 0.59833, -0.0355167, 0.490524, 0.0434757, 0.598525, -0.0416559, 0.490624, 0.0510629, 0.598778, -0.0482692, 0.490753, 0.0592781, 0.599135, -0.0553114, 0.49094, 0.0681304, 0.599802, -0.062542, 0.491328, 0.0776467, 0.600361, -0.0703638, 0.491598, 0.0878184, 0.60101, -0.0786256, 0.491882, 0.0986573, 0.601811, -0.0872962, 0.492232, 0.11018, 0.602861, -0.0962284, 0.492684, 0.1224, 0.604167, -0.10538, 0.493213, 0.135354, 0.605693, -0.114896, 0.493799, 0.149034, 0.607682, -0.124654, 0.494576, 0.163469, 0.610672, -0.13456, 0.4959, 0.178747, 0.613313, -0.144581, 0.496713, 0.194723, 0.617603, -0.154703, 0.498499, 0.211617, 0.622174, -0.16489, 0.500188, 0.229183, 0.628855, -0.175164, 0.503072, 0.247786, 0.636963, -0.185565, 0.506798, 0.267116, 0.644866, -0.195911, 0.509719, 0.28702, 0.653741, -0.206104, 0.512776, 0.307763, 0.664942, -0.216447, 0.516812, 0.329631, 0.67633, -0.22552, 0.519181, 0.353515, 0.690012, -0.234316, 0.521681, 0.379226, 0.704243, -0.242032, 0.523129, 0.405901, 0.719396, -0.249172, 0.523768, 0.433585, 0.734471, -0.255543, 0.522541, 0.462085, 0.750539, -0.260697, 0.520217, 0.491233, 0.766365, -0.26501, 0.516293, 0.521094, 0.781677, -0.268409, 0.509708, 0.551014, 0.797132, -0.270399, 0.501944, 0.581463, 0.812655, -0.271247, 0.492025, 0.612402, 0.828592, -0.270708, 0.480424, 0.643798, 0.844044, -0.268085, 0.465955, 0.67682, 0.857305, -0.263459, 0.448425, 0.708496, 0.87114, -0.258151, 0.430243, 0.74046, 0.884936, -0.251171, 0.410578, 0.771583, 0.895772, -0.243305, 0.38862, 0.802234, 0.906961, -0.234037, 0.365214, 0.833179, 0.917775, -0.222714, 0.34116, 0.86353, 0.927883, -0.210175, 0.31572, 0.893557, 0.936617, -0.196925, 0.289159, 0.922976, 0.943384, -0.182788, 0.261996, 0.951606, 0.949713, -0.167965, 0.235324, 0.979958, 0.955818, -0.151109, 0.208408, 1.00765, 0.961344, -0.133834, 0.182591, 1.03329, 0.965469, -0.115987, 0.156958, 1.0557, 0.968693, -0.09746, 0.132239, 1.07583, 0.973165, -0.0778514, 0.106195, 1.09451, 0.979387, -0.0585067, 0.0797669, 1.11137, 0.98671, -0.0390409, 0.0530263, 1.12643, 0.994093, -0.019408, 0.0263163, 1.14016, 1.00002, 0.000540029, -194487e-9, 1.15299, 0.574483, -989066e-11, 0.494533, 1.14896e-05, 0.574478, -249127e-9, 0.494528, 0.000289403, 0.574607, -996811e-9, 0.494637, 0.00115797, 0.574396, -224241e-8, 0.494458, 0.00260498, 0.574377, -398632e-8, 0.49444, 0.00463102, 0.574386, -622836e-8, 0.494445, 0.00723623, 0.574401, -89683e-7, 0.494453, 0.010421, 0.574419, -0.0122056, 0.49446, 0.0141859, 0.574459, -0.0159396, 0.494481, 0.0185322, 0.574525, -0.0201692, 0.49452, 0.0234617, 0.574587, -0.0248924, 0.494547, 0.0289762, 0.574697, -0.0301074, 0.494604, 0.0350797, 0.574853, -0.0358114, 0.494688, 0.0417767, 0.575027, -0.041999, 0.494772, 0.0490718, 0.575294, -0.0486618, 0.494915, 0.0569728, 0.575733, -0.0557148, 0.495173, 0.0654955, 0.576356, -0.0630489, 0.495537, 0.0746612, 0.576944, -0.0709285, 0.495836, 0.0844615, 0.57765, -0.0792723, 0.496177, 0.0949142, 0.578491, -0.0880167, 0.496563, 0.10603, 0.579639, -0.0969462, 0.497096, 0.117841, 0.580989, -0.10622, 0.497684, 0.130367, 0.582587, -0.115861, 0.498337, 0.143609, 0.584951, -0.125605, 0.499414, 0.157625, 0.587602, -0.135608, 0.500518, 0.172413, 0.59076, -0.145742, 0.501767, 0.187999, 0.594992, -0.155934, 0.503542, 0.20445, 0.600656, -0.166303, 0.506135, 0.221764, 0.607816, -0.176681, 0.509542, 0.24002, 0.61522, -0.187071, 0.51263, 0.258992, 0.623702, -0.197465, 0.516021, 0.278773, 0.634192, -0.207816, 0.520422, 0.299377, 0.644936, -0.218183, 0.524073, 0.320802, 0.657888, -0.2278, 0.528049, 0.34384, 0.670666, -0.236747, 0.52986, 0.36916, 0.685626, -0.24484, 0.531892, 0.395867, 0.701304, -0.252071, 0.532727, 0.423488, 0.717727, -0.258714, 0.532146, 0.452201, 0.733914, -0.264211, 0.529883, 0.481579, 0.750529, -0.26859, 0.5259, 0.511558, 0.76747, -0.272046, 0.51999, 0.542042, 0.785189, -0.274225, 0.513083, 0.572799, 0.800954, -0.275189, 0.502936, 0.603816, 0.816962, -0.274946, 0.490921, 0.635461, 0.83336, -0.272695, 0.47684, 0.6676, 0.848143, -0.268223, 0.459405, 0.70051, 0.861818, -0.262768, 0.440319, 0.732902, 0.876828, -0.255872, 0.420123, 0.765084, 0.889312, -0.247703, 0.398379, 0.796391, 0.900412, -0.238381, 0.374496, 0.827333, 0.912251, -0.227783, 0.349874, 0.858385, 0.921792, -0.214832, 0.323181, 0.888652, 0.931273, -0.200949, 0.296624, 0.917763, 0.940295, -0.186537, 0.269211, 0.947878, 0.946812, -0.171538, 0.241447, 0.977016, 0.953588, -0.155254, 0.213829, 1.00501, 0.958841, -0.137156, 0.186807, 1.03179, 0.963746, -0.118699, 0.160706, 1.05502, 0.966468, -0.0998358, 0.135504, 1.07568, 0.971178, -0.0805186, 0.109131, 1.09479, 0.97831, -0.0599348, 0.0818293, 1.1123, 0.985886, -0.0399661, 0.0545872, 1.12771, 0.994021, -0.0198682, 0.0269405, 1.14186, 1.00009, 0.000271022, -12989e-8, 1.15514, 0.538716, -990918e-11, 0.486732, 1.09675e-05, 0.550656, -250642e-9, 0.497518, 0.000277412, 0.55057, -100265e-8, 0.497441, 0.00110974, 0.550903, -225672e-8, 0.497733, 0.00249779, 0.550568, -401046e-8, 0.497438, 0.00443906, 0.550574, -626613e-8, 0.49744, 0.00693637, 0.550591, -90226e-7, 0.497449, 0.00998921, 0.550623, -0.0122795, 0.497469, 0.0135984, 0.550667, -0.0160361, 0.497495, 0.0177654, 0.550724, -0.0202908, 0.497526, 0.0224915, 0.550792, -0.0250421, 0.497557, 0.0277795, 0.550918, -0.0302878, 0.49763, 0.0336334, 0.551058, -0.0360241, 0.497701, 0.0400573, 0.551276, -0.0422473, 0.497824, 0.0470585, 0.551551, -0.0489441, 0.497977, 0.0546433, 0.552074, -0.0559596, 0.498312, 0.0628367, 0.552681, -0.0633978, 0.498679, 0.071646, 0.553324, -0.0713176, 0.499031, 0.0810746, 0.554011, -0.0797268, 0.499365, 0.091129, 0.55488, -0.0885238, 0.499779, 0.101837, 0.556171, -0.0974417, 0.500444, 0.113239, 0.557498, -0.106841, 0.501025, 0.125316, 0.559299, -0.116533, 0.501864, 0.138128, 0.561647, -0.126298, 0.502967, 0.151695, 0.564347, -0.136388, 0.504129, 0.16604, 0.567863, -0.146576, 0.505713, 0.181207, 0.572569, -0.156832, 0.507953, 0.197259, 0.578919, -0.167323, 0.511186, 0.214258, 0.585387, -0.177712, 0.514042, 0.232038, 0.593134, -0.188184, 0.517484, 0.250733, 0.603295, -0.198717, 0.522345, 0.270454, 0.613854, -0.209177, 0.526751, 0.290807, 0.626092, -0.219644, 0.531595, 0.312202, 0.637868, -0.229494, 0.534721, 0.334435, 0.652458, -0.238718, 0.538304, 0.359184, 0.666985, -0.247061, 0.539875, 0.385637, 0.683301, -0.254652, 0.541042, 0.41328, 0.69998, -0.261376, 0.540735, 0.441903, 0.717824, -0.267085, 0.539139, 0.471609, 0.734617, -0.271465, 0.534958, 0.501446, 0.753663, -0.27528, 0.53032, 0.532571, 0.770512, -0.277617, 0.522134, 0.563641, 0.787356, -0.278525, 0.51206, 0.595067, 0.806252, -0.278512, 0.50119, 0.627226, 0.822061, -0.277023, 0.486791, 0.659402, 0.838959, -0.273175, 0.470467, 0.692874, 0.85379, -0.267238, 0.450688, 0.725702, 0.868268, -0.260327, 0.429741, 0.75832, 0.881994, -0.251946, 0.407223, 0.790189, 0.893885, -0.242432, 0.383214, 0.821625, 0.905118, -0.231904, 0.357297, 0.853011, 0.916045, -0.219545, 0.330733, 0.883773, 0.927614, -0.205378, 0.303916, 0.914435, 0.936005, -0.190388, 0.275941, 0.944502, 0.944533, -0.1749, 0.247493, 0.974439, 0.950758, -0.158588, 0.218996, 1.00286, 0.957078, -0.141027, 0.191559, 1.0304, 0.962448, -0.121507, 0.164457, 1.05466, 0.964993, -0.102068, 0.138636, 1.0761, 0.970017, -0.0822598, 0.111861, 1.09541, 0.97661, -0.062033, 0.0843438, 1.11317, 0.985073, -0.0409832, 0.0558496, 1.12911, 0.993515, -0.020146, 0.0275331, 1.1438, 1.00006, 0.00027329, -107883e-9, 1.15736, 0.525324, -999341e-11, 0.498153, 1.05385e-05, 0.526513, -251605e-9, 0.499277, 0.000265329, 0.526517, -100641e-8, 0.499282, 0.0010613, 0.526588, -226466e-8, 0.499337, 0.00238823, 0.526539, -40255e-7, 0.499302, 0.00424535, 0.526547, -628954e-8, 0.499306, 0.00663364, 0.526561, -905628e-8, 0.499313, 0.00955337, 0.526593, -0.0123253, 0.499334, 0.0130054, 0.526642, -0.0160957, 0.499365, 0.0169911, 0.5267, -0.0203661, 0.499396, 0.0215122, 0.526792, -0.0251347, 0.499451, 0.0265718, 0.526904, -0.0303985, 0.499511, 0.0321732, 0.527079, -0.0361554, 0.499617, 0.0383231, 0.527285, -0.0423982, 0.499731, 0.045026, 0.527602, -0.0491121, 0.499924, 0.0522936, 0.528166, -0.0561127, 0.500306, 0.0601528, 0.52879, -0.0635988, 0.5007, 0.0686059, 0.529421, -0.071581, 0.501048, 0.0776518, 0.530144, -0.0799854, 0.501421, 0.0873148, 0.531062, -0.0888032, 0.501884, 0.0976084, 0.532374, -0.0977643, 0.50259, 0.108588, 0.533828, -0.107197, 0.50329, 0.120234, 0.53581, -0.116887, 0.504312, 0.132602, 0.538063, -0.126755, 0.505365, 0.145721, 0.5409, -0.136819, 0.506668, 0.159617, 0.544882, -0.147117, 0.508731, 0.174369, 0.550238, -0.157446, 0.511601, 0.190028, 0.556038, -0.167988, 0.514431, 0.206587, 0.563031, -0.178364, 0.517808, 0.224046, 0.571543, -0.189007, 0.521937, 0.242503, 0.582255, -0.199546, 0.527415, 0.261977, 0.59272, -0.210084, 0.531682, 0.282162, 0.605648, -0.220448, 0.537123, 0.303426, 0.61785, -0.230593, 0.540664, 0.325323, 0.632223, -0.240238, 0.544467, 0.348993, 0.648819, -0.24887, 0.547594, 0.375462, 0.665825, -0.256657, 0.54912, 0.403024, 0.683389, -0.263711, 0.549294, 0.431773, 0.701495, -0.269666, 0.547649, 0.461494, 0.719197, -0.274169, 0.543786, 0.491623, 0.737906, -0.278124, 0.538644, 0.522994, 0.756652, -0.280632, 0.531057, 0.554775, 0.775279, -0.281741, 0.521972, 0.586441, 0.792688, -0.281652, 0.509613, 0.618596, 0.811894, -0.280345, 0.496497, 0.651462, 0.827938, -0.277128, 0.47968, 0.684023, 0.844837, -0.271646, 0.460688, 0.718024, 0.859239, -0.264397, 0.438872, 0.751207, 0.874088, -0.256144, 0.41577, 0.784232, 0.887693, -0.246311, 0.391369, 0.816191, 0.899402, -0.235497, 0.365872, 0.847828, 0.910973, -0.223631, 0.338618, 0.87934, 0.92204, -0.209874, 0.310803, 0.910325, 0.930987, -0.194265, 0.281802, 0.940695, 0.94, -0.178125, 0.252836, 0.970958, 0.948018, -0.161479, 0.224239, 1.00078, 0.955141, -0.144038, 0.195857, 1.0288, 0.960513, -0.124915, 0.168487, 1.05371, 0.963964, -0.104284, 0.141495, 1.07596, 0.968713, -0.0838732, 0.114437, 1.09628, 0.975524, -0.0635579, 0.0863105, 1.11448, 0.98431, -0.042291, 0.0574774, 1.13069, 0.992916, -0.0209131, 0.0284343, 1.14568, 0.999926, 0.000743097, -379265e-9, 1.15955, 0.501042, -998428e-11, 0.498726, 1.00306e-05, 0.502992, -252112e-9, 0.500665, 0.000253283, 0.502417, -100791e-8, 0.500092, 0.00101259, 0.502965, -226919e-8, 0.500621, 0.00227978, 0.502318, -403109e-8, 0.499994, 0.00405011, 0.502333, -629832e-8, 0.500005, 0.00632868, 0.502362, -906907e-8, 0.500027, 0.00911446, 0.502369, -0.0123423, 0.500023, 0.0124078, 0.50243, -0.0161178, 0.500066, 0.016211, 0.502493, -0.0203937, 0.500103, 0.0205256, 0.502592, -0.0251684, 0.500166, 0.0253548, 0.502707, -0.0304389, 0.50023, 0.0307029, 0.502881, -0.0362015, 0.500335, 0.0365753, 0.503124, -0.0424507, 0.500488, 0.0429798, 0.503443, -0.0491582, 0.500686, 0.0499268, 0.504083, -0.0561476, 0.501155, 0.0574541, 0.504668, -0.0636846, 0.501524, 0.0655408, 0.505319, -0.0716834, 0.501904, 0.0742072, 0.50609, -0.0800925, 0.502321, 0.0834699, 0.507122, -0.0888425, 0.502896, 0.0933603, 0.508414, -0.097855, 0.503603, 0.10391, 0.509955, -0.107304, 0.504416, 0.115113, 0.512061, -0.116921, 0.505565, 0.127054, 0.514419, -0.12689, 0.506732, 0.139709, 0.517529, -0.136934, 0.508338, 0.153173, 0.522085, -0.147327, 0.510987, 0.167528, 0.526986, -0.157612, 0.513527, 0.182708, 0.533122, -0.168213, 0.516717, 0.198881, 0.540807, -0.178688, 0.520832, 0.215986, 0.550687, -0.189511, 0.52632, 0.234335, 0.560567, -0.199998, 0.531009, 0.253375, 0.571698, -0.210652, 0.535839, 0.273499, 0.584364, -0.220917, 0.541091, 0.294355, 0.599066, -0.23137, 0.546875, 0.316525, 0.614148, -0.241206, 0.551306, 0.339671, 0.631157, -0.250379, 0.555187, 0.36531, 0.647919, -0.258397, 0.556595, 0.392767, 0.666112, -0.265528, 0.556949, 0.421397, 0.686158, -0.271827, 0.556617, 0.451433, 0.704838, -0.27674, 0.552975, 0.482131, 0.723957, -0.280733, 0.547814, 0.513458, 0.74262, -0.283359, 0.53997, 0.545446, 0.762009, -0.284541, 0.530422, 0.57775, 0.781314, -0.284507, 0.518546, 0.610434, 0.799116, -0.283309, 0.504178, 0.643178, 0.817604, -0.280378, 0.48843, 0.676248, 0.83459, -0.275619, 0.469457, 0.709698, 0.850974, -0.26856, 0.447698, 0.744245, 0.866747, -0.260094, 0.424791, 0.777695, 0.881412, -0.249929, 0.399913, 0.810392, 0.8936, -0.239137, 0.37308, 0.842872, 0.905943, -0.226818, 0.345705, 0.874677, 0.916408, -0.213699, 0.31706, 0.906257, 0.927215, -0.198428, 0.288444, 0.936881, 0.935625, -0.181643, 0.258329, 0.96795, 0.944076, -0.164386, 0.228488, 0.998216, 0.951229, -0.146339, 0.199763, 1.02689, 0.958793, -0.127709, 0.172153, 1.0535, 0.963219, -0.107244, 0.144989, 1.07646, 0.967562, -0.0857764, 0.11685, 1.09675, 0.974866, -0.0645377, 0.0880571, 1.11576, 0.983353, -0.0431732, 0.0587352, 1.13227, 0.992503, -0.0218356, 0.0294181, 1.1478, 1.00003, 0.000605203, -231013e-9, 1.16207, 0.482935, -101177e-10, 0.504695, 9.68142e-06, 0.477554, -251521e-9, 0.499071, 0.000240676, 0.477904, -100683e-8, 0.499436, 0.00096342, 0.478368, -226636e-8, 0.499899, 0.0021687, 0.477977, -402719e-8, 0.499513, 0.00385384, 0.477993, -629226e-8, 0.499525, 0.0060221, 0.478011, -906011e-8, 0.499536, 0.00867289, 0.478051, -0.0123305, 0.499566, 0.0118074, 0.478089, -0.016102, 0.499587, 0.0154269, 0.478171, -0.0203736, 0.499645, 0.0195341, 0.478254, -0.025143, 0.499692, 0.0241318, 0.47839, -0.0304071, 0.499779, 0.0292247, 0.478588, -0.0361631, 0.499911, 0.0348196, 0.478812, -0.0424023, 0.500046, 0.0409231, 0.479208, -0.0490724, 0.500326, 0.047552, 0.479841, -0.0560722, 0.500805, 0.0547377, 0.480392, -0.0636125, 0.501152, 0.0624607, 0.481068, -0.0716134, 0.501561, 0.0707473, 0.481898, -0.0800062, 0.502054, 0.0796118, 0.483022, -0.0886568, 0.502728, 0.0890974, 0.484332, -0.0977553, 0.503479, 0.0992099, 0.486126, -0.107173, 0.504546, 0.10999, 0.488066, -0.11677, 0.50557, 0.121476, 0.490521, -0.126725, 0.506849, 0.133672, 0.494232, -0.136793, 0.50911, 0.146731, 0.498302, -0.147116, 0.511345, 0.160577, 0.503565, -0.157446, 0.514344, 0.175335, 0.510902, -0.168121, 0.518824, 0.191207, 0.519263, -0.178799, 0.523666, 0.208058, 0.528204, -0.189407, 0.528296, 0.225875, 0.538854, -0.200145, 0.533724, 0.244782, 0.551278, -0.210701, 0.539833, 0.264753, 0.565222, -0.221303, 0.546131, 0.285745, 0.579403, -0.231688, 0.551496, 0.307592, 0.595469, -0.241718, 0.556809, 0.330582, 0.610929, -0.250992, 0.559641, 0.354995, 0.629433, -0.259602, 0.562379, 0.382471, 0.648504, -0.267038, 0.563676, 0.411126, 0.66756, -0.273388, 0.562092, 0.440924, 0.689143, -0.278788, 0.560807, 0.472118, 0.709056, -0.282783, 0.555701, 0.503774, 0.729855, -0.285836, 0.548698, 0.536364, 0.748954, -0.287078, 0.538544, 0.56895, 0.768373, -0.287133, 0.526711, 0.601991, 0.78827, -0.285839, 0.512511, 0.635403, 0.807465, -0.283238, 0.496323, 0.668797, 0.825194, -0.27906, 0.477638, 0.702584, 0.842203, -0.272286, 0.456253, 0.736393, 0.857749, -0.263854, 0.432412, 0.77096, 0.874799, -0.253943, 0.407806, 0.80489, 0.887497, -0.24237, 0.38033, 0.83771, 0.89966, -0.230278, 0.352446, 0.870376, 0.911753, -0.21646, 0.323268, 0.902256, 0.923011, -0.202071, 0.294314, 0.933306, 0.932375, -0.185519, 0.264104, 0.965177, 0.940537, -0.167604, 0.234035, 0.996303, 0.948904, -0.149068, 0.20412, 1.0261, 0.955263, -0.129539, 0.175431, 1.05304, 0.960303, -0.109932, 0.148116, 1.07617, 0.965512, -0.0880572, 0.119693, 1.09742, 0.973466, -0.0660548, 0.0901619, 1.11721, 0.98284, -0.0439228, 0.0599875, 1.13436, 0.992216, -0.0219588, 0.0298975, 1.15006, 0.999946, 0.000119402, -208547e-10, 1.16471, 0.447827, -100414e-10, 0.491543, 9.14833e-06, 0.454778, -251257e-9, 0.499172, 0.00022891, 0.453519, -100342e-8, 0.497787, 0.000914184, 0.45357, -225776e-8, 0.497847, 0.00205701, 0.453578, -401371e-8, 0.497855, 0.00365705, 0.45357, -627107e-8, 0.497841, 0.00571453, 0.453598, -902968e-8, 0.497864, 0.00823019, 0.453627, -0.0122888, 0.497882, 0.0112049, 0.453684, -0.0160475, 0.497923, 0.0146405, 0.453764, -0.0203044, 0.49798, 0.0185394, 0.453866, -0.0250576, 0.498049, 0.0229054, 0.453996, -0.0303028, 0.49813, 0.0277424, 0.454196, -0.0360379, 0.498267, 0.0330587, 0.454457, -0.0422521, 0.498445, 0.0388613, 0.454926, -0.0488393, 0.498812, 0.0451767, 0.455525, -0.0558653, 0.499272, 0.0520153, 0.456074, -0.0633772, 0.499625, 0.0593754, 0.456752, -0.0713606, 0.500049, 0.0672751, 0.457648, -0.07971, 0.500615, 0.0757447, 0.458849, -0.0883032, 0.501399, 0.0848231, 0.46029, -0.0974095, 0.502293, 0.0945135, 0.462, -0.106729, 0.503301, 0.104848, 0.464121, -0.116354, 0.504533, 0.115884, 0.466889, -0.126214, 0.506172, 0.127652, 0.470744, -0.136324, 0.508667, 0.14024, 0.47488, -0.146595, 0.510995, 0.153673, 0.480845, -0.157027, 0.514832, 0.168053, 0.488262, -0.167658, 0.519506, 0.183508, 0.496547, -0.178343, 0.524347, 0.199948, 0.506254, -0.188916, 0.52983, 0.217503, 0.517961, -0.199975, 0.536357, 0.236272, 0.531484, -0.210624, 0.543641, 0.256096, 0.545496, -0.221227, 0.550048, 0.277085, 0.559497, -0.231568, 0.555076, 0.298615, 0.575752, -0.241698, 0.560541, 0.321547, 0.591999, -0.251172, 0.564156, 0.345602, 0.610654, -0.260178, 0.567607, 0.371851, 0.630484, -0.268094, 0.56923, 0.40076, 0.651807, -0.274661, 0.569779, 0.430801, 0.67239, -0.280331, 0.566791, 0.461939, 0.693024, -0.284501, 0.562007, 0.493854, 0.715473, -0.287852, 0.555791, 0.526992, 0.736323, -0.28929, 0.546345, 0.560102, 0.755771, -0.289405, 0.534, 0.593543, 0.775424, -0.2881, 0.519114, 0.627256, 0.795447, -0.285562, 0.502543, 0.661464, 0.815319, -0.281416, 0.484773, 0.695206, 0.831769, -0.275523, 0.463445, 0.729044, 0.849464, -0.267516, 0.440269, 0.764069, 0.866775, -0.257584, 0.415049, 0.799089, 0.881252, -0.245817, 0.388049, 0.831948, 0.894209, -0.233127, 0.35889, 0.865526, 0.906922, -0.219579, 0.329915, 0.89818, 0.919686, -0.204491, 0.300441, 0.930013, 0.929044, -0.188962, 0.269445, 0.962061, 0.938393, -0.171079, 0.238402, 0.994214, 0.94661, -0.15199, 0.208204, 1.02533, 0.953095, -0.131953, 0.178653, 1.0529, 0.958644, -0.111233, 0.150684, 1.0771, 0.963925, -0.0903098, 0.122359, 1.09855, 0.971995, -0.0680505, 0.0923342, 1.11874, 0.981658, -0.0448512, 0.0614195, 1.13635, 0.991649, -0.0221931, 0.0303582, 1.15238, 0.999985, 0.000393403, -111086e-9, 1.16772, 0.396806, -971563e-11, 0.457671, 8.42355e-06, 0.429186, -249421e-9, 0.495017, 0.00021625, 0.429324, -998052e-9, 0.495173, 0.000865322, 0.429175, -224487e-8, 0.494999, 0.00194637, 0.429129, -399041e-8, 0.494952, 0.00346004, 0.429153, -623476e-8, 0.494974, 0.00540684, 0.429168, -89773e-7, 0.494983, 0.00778714, 0.429207, -0.0122175, 0.495012, 0.0106022, 0.429257, -0.0159542, 0.495047, 0.0138535, 0.429338, -0.0201864, 0.495106, 0.0175443, 0.429431, -0.0249104, 0.495165, 0.0216774, 0.429587, -0.0301252, 0.495279, 0.0262594, 0.429796, -0.0358249, 0.495432, 0.0312968, 0.430065, -0.0419972, 0.495621, 0.0367985, 0.430588, -0.0485144, 0.496061, 0.042798, 0.43113, -0.0555028, 0.496472, 0.0492914, 0.431743, -0.0629852, 0.496904, 0.0562907, 0.432448, -0.0709256, 0.497369, 0.0638056, 0.433414, -0.0791942, 0.498032, 0.071885, 0.434638, -0.0877346, 0.498854, 0.0805517, 0.43611, -0.0968056, 0.499812, 0.0898047, 0.437859, -0.106002, 0.500891, 0.0997142, 0.440017, -0.115648, 0.502198, 0.110289, 0.443236, -0.125427, 0.504389, 0.121644, 0.44697, -0.135492, 0.506809, 0.133769, 0.451689, -0.145746, 0.509858, 0.146787, 0.45811, -0.156219, 0.514247, 0.160793, 0.465305, -0.166834, 0.518816, 0.175791, 0.474085, -0.177546, 0.524331, 0.191906, 0.484808, -0.188262, 0.53104, 0.209199, 0.49732, -0.199346, 0.538511, 0.227825, 0.509693, -0.209951, 0.544554, 0.247269, 0.524367, -0.220533, 0.551616, 0.267978, 0.539228, -0.231082, 0.557368, 0.289672, 0.55644, -0.241342, 0.563782, 0.31268, 0.574204, -0.250964, 0.568851, 0.33651, 0.593388, -0.260306, 0.57312, 0.362219, 0.613358, -0.268667, 0.574916, 0.390322, 0.634512, -0.275591, 0.575053, 0.420478, 0.65563, -0.281328, 0.572404, 0.451614, 0.678265, -0.285948, 0.568893, 0.484112, 0.70011, -0.289408, 0.561878, 0.517348, 0.723005, -0.291328, 0.55359, 0.551355, 0.743744, -0.291418, 0.541099, 0.585109, 0.763949, -0.290252, 0.526489, 0.619487, 0.784186, -0.287648, 0.509496, 0.65404, 0.804304, -0.283782, 0.491484, 0.688649, 0.823629, -0.278067, 0.470517, 0.723133, 0.84094, -0.270588, 0.44705, 0.757163, 0.857852, -0.261188, 0.421252, 0.792816, 0.874934, -0.249313, 0.394191, 0.827248, 0.888709, -0.236492, 0.365359, 0.861074, 0.902589, -0.222185, 0.336016, 0.894417, 0.914201, -0.207314, 0.30527, 0.926825, 0.925978, -0.191146, 0.274532, 0.9595, 0.93512, -0.174135, 0.243393, 0.991583, 0.943656, -0.155231, 0.212414, 1.02356, 0.951719, -0.134403, 0.182005, 1.05239, 0.957164, -0.113023, 0.153043, 1.07754, 0.962656, -0.0914493, 0.124186, 1.09984, 0.970695, -0.0694179, 0.0941654, 1.12, 0.980749, -0.0466199, 0.0629671, 1.13849, 0.991205, -0.0227032, 0.0311146, 1.15494, 0.999884, 0.000632388, -254483e-9, 1.1706, 0.379821, -957289e-11, 0.460637, 7.89337e-06, 0.405188, -247483e-9, 0.491396, 0.000204064, 0.404796, -989434e-9, 0.490914, 0.000815853, 0.40483, -222607e-8, 0.490949, 0.00183559, 0.40473, -395723e-8, 0.49084, 0.00326332, 0.404731, -618287e-8, 0.490836, 0.00509945, 0.404768, -890258e-8, 0.490871, 0.00734463, 0.404791, -0.0121156, 0.490883, 0.00999992, 0.404857, -0.0158214, 0.490938, 0.0130676, 0.404943, -0.0200178, 0.491004, 0.0165503, 0.405059, -0.0247027, 0.491093, 0.0204521, 0.405213, -0.0298729, 0.491205, 0.0247788, 0.405399, -0.0355226, 0.491333, 0.0295373, 0.405731, -0.0416352, 0.491604, 0.034741, 0.406303, -0.0480807, 0.492116, 0.0404255, 0.406814, -0.0550458, 0.492506, 0.0465732, 0.407404, -0.0624652, 0.492926, 0.0532058, 0.408149, -0.0702958, 0.493442, 0.0603442, 0.409128, -0.0784623, 0.494136, 0.0680297, 0.410408, -0.087007, 0.495054, 0.0762786, 0.411813, -0.0959639, 0.495962, 0.0851046, 0.413735, -0.105075, 0.497257, 0.0945878, 0.416137, -0.114646, 0.498882, 0.104725, 0.41934, -0.124394, 0.501132, 0.11563, 0.423326, -0.134328, 0.503883, 0.127325, 0.428419, -0.14458, 0.50747, 0.139911, 0.43484, -0.154979, 0.511964, 0.153481, 0.442641, -0.165628, 0.517328, 0.168114, 0.452511, -0.176365, 0.524258, 0.183995, 0.463473, -0.187298, 0.531248, 0.200953, 0.475564, -0.198244, 0.538367, 0.219176, 0.488664, -0.208938, 0.545175, 0.238514, 0.504073, -0.219599, 0.553227, 0.259129, 0.520832, -0.230378, 0.560653, 0.280997, 0.538455, -0.240703, 0.567523, 0.303821, 0.55709, -0.250548, 0.573287, 0.327948, 0.576646, -0.259964, 0.577795, 0.353362, 0.596705, -0.268721, 0.580077, 0.380336, 0.618053, -0.276054, 0.58018, 0.4101, 0.640303, -0.282176, 0.578747, 0.44161, 0.662365, -0.286931, 0.574294, 0.474106, 0.684542, -0.290521, 0.567035, 0.507549, 0.707984, -0.292672, 0.558687, 0.541853, 0.730913, -0.293189, 0.547606, 0.576581, 0.752948, -0.292199, 0.533471, 0.61172, 0.773452, -0.289508, 0.516395, 0.646339, 0.794715, -0.285716, 0.497873, 0.682131, 0.814251, -0.280051, 0.476845, 0.716396, 0.833057, -0.272873, 0.453449, 0.751503, 0.84959, -0.263982, 0.427857, 0.786085, 0.867022, -0.252745, 0.400335, 0.821355, 0.882277, -0.239655, 0.371304, 0.85646, 0.895375, -0.225386, 0.340397, 0.890828, 0.909347, -0.209587, 0.310005, 0.923532, 0.921885, -0.193433, 0.2796, 0.956419, 0.932127, -0.176135, 0.247276, 0.989445, 0.941869, -0.157872, 0.216186, 1.02221, 0.949735, -0.137577, 0.185602, 1.05195, 0.956617, -0.115285, 0.155767, 1.07822, 0.961974, -0.0928418, 0.126103, 1.10149, 0.96972, -0.0700592, 0.0956758, 1.12207, 0.98012, -0.0474671, 0.0643269, 1.1408, 0.990825, -0.0238113, 0.0320863, 1.1577, 0.999876, 0.000381574, -812203e-10, 1.17403, 0.367636, -961342e-11, 0.469176, 7.53287e-06, 0.380377, -244772e-9, 0.485434, 0.000191797, 0.380416, -978857e-9, 0.485475, 0.000767015, 0.380376, -220165e-8, 0.485435, 0.00172522, 0.380419, -391408e-8, 0.485487, 0.00306734, 0.380438, -611549e-8, 0.485505, 0.00479332, 0.380462, -880558e-8, 0.485525, 0.00690391, 0.380496, -0.0119837, 0.485551, 0.00940039, 0.38056, -0.0156487, 0.485605, 0.0122848, 0.38064, -0.0197988, 0.485666, 0.0155601, 0.380767, -0.0244324, 0.48577, 0.0192313, 0.380909, -0.0295444, 0.485871, 0.0233032, 0.381142, -0.0351321, 0.48606, 0.0277861, 0.381472, -0.0411535, 0.486336, 0.0326939, 0.382015, -0.0475408, 0.486833, 0.0380565, 0.382523, -0.0544395, 0.487231, 0.0438615, 0.383129, -0.061784, 0.487683, 0.0501332, 0.383952, -0.0695085, 0.488313, 0.0568996, 0.38498, -0.0775819, 0.489077, 0.0641952, 0.386331, -0.0860443, 0.490113, 0.0720324, 0.387788, -0.0948406, 0.491099, 0.0804379, 0.389808, -0.103899, 0.492566, 0.0894899, 0.39252, -0.113313, 0.494601, 0.0992098, 0.395493, -0.123007, 0.496619, 0.109641, 0.399826, -0.132859, 0.499912, 0.120919, 0.405341, -0.143077, 0.504061, 0.133107, 0.411932, -0.153465, 0.508905, 0.146263, 0.420591, -0.164108, 0.515482, 0.160544, 0.43101, -0.174893, 0.523191, 0.176123, 0.441881, -0.185839, 0.53026, 0.192757, 0.453919, -0.196633, 0.537295, 0.210535, 0.468715, -0.207611, 0.546156, 0.229886, 0.485182, -0.218517, 0.555173, 0.250543, 0.501926, -0.229249, 0.562728, 0.27221, 0.51785, -0.239481, 0.567494, 0.294892, 0.536947, -0.249395, 0.573889, 0.318987, 0.557115, -0.259, 0.578831, 0.344348, 0.577966, -0.268075, 0.582055, 0.371223, 0.599489, -0.276115, 0.583307, 0.399834, 0.62479, -0.282523, 0.583902, 0.431415, 0.647504, -0.287663, 0.57953, 0.464301, 0.670601, -0.291538, 0.573103, 0.498123, 0.693539, -0.293842, 0.563731, 0.532662, 0.717385, -0.294681, 0.553169, 0.567925, 0.741533, -0.293717, 0.539908, 0.603502, 0.762142, -0.291156, 0.521902, 0.639074, 0.783014, -0.28719, 0.502815, 0.674439, 0.805158, -0.281773, 0.482598, 0.710497, 0.823646, -0.274682, 0.458949, 0.7456, 0.841879, -0.266184, 0.433129, 0.781085, 0.859515, -0.255682, 0.406064, 0.816, 0.875335, -0.242849, 0.376509, 0.851074, 0.890147, -0.228329, 0.345502, 0.886473, 0.903144, -0.212491, 0.31428, 0.920751, 0.916618, -0.195695, 0.282994, 0.954606, 0.927953, -0.178267, 0.251091, 0.988402, 0.937414, -0.159549, 0.219107, 1.02141, 0.946823, -0.140022, 0.18896, 1.05167, 0.954651, -0.118154, 0.158667, 1.07819, 0.959955, -0.0946636, 0.128808, 1.1025, 0.96858, -0.0711792, 0.0973787, 1.12391, 0.97938, -0.0475046, 0.0650965, 1.14322, 0.990498, -0.024059, 0.0326267, 1.16077, 0.999844, -512408e-10, 0.000112444, 1.17727, 0.316912, -934977e-11, 0.425996, 6.95559e-06, 0.356423, -241372e-9, 0.479108, 0.000179562, 0.356272, -965292e-9, 0.478897, 0.00071811, 0.356262, -217182e-8, 0.478894, 0.00161574, 0.356265, -386092e-8, 0.478895, 0.00287261, 0.356278, -60324e-7, 0.478905, 0.00448907, 0.356293, -868565e-8, 0.478914, 0.00646572, 0.356346, -0.0118207, 0.478965, 0.00880438, 0.356395, -0.0154355, 0.479001, 0.0115066, 0.356484, -0.019529, 0.479075, 0.0145762, 0.356609, -0.0240991, 0.47918, 0.018018, 0.356766, -0.0291413, 0.479305, 0.0218379, 0.357009, -0.0346498, 0.479512, 0.0260454, 0.357424, -0.0405462, 0.479909, 0.0306657, 0.357899, -0.0468825, 0.480337, 0.0357054, 0.358424, -0.0536887, 0.480771, 0.0411728, 0.359041, -0.0609416, 0.481242, 0.0470841, 0.359903, -0.0685239, 0.481943, 0.0534831, 0.360932, -0.0764883, 0.482741, 0.0603795, 0.362196, -0.0848364, 0.483688, 0.0678028, 0.363847, -0.0935002, 0.484947, 0.0758086, 0.365972, -0.102471, 0.486588, 0.0844173, 0.368741, -0.111751, 0.488787, 0.0937199, 0.372146, -0.121334, 0.491405, 0.103732, 0.377114, -0.131147, 0.495604, 0.114608, 0.38226, -0.141213, 0.499436, 0.126345, 0.389609, -0.151632, 0.505334, 0.139116, 0.397925, -0.162073, 0.51168, 0.152995, 0.407824, -0.172819, 0.518876, 0.168071, 0.420014, -0.183929, 0.527639, 0.184495, 0.434266, -0.195032, 0.537588, 0.20232, 0.447352, -0.205792, 0.544379, 0.221189, 0.463726, -0.216704, 0.553422, 0.241616, 0.481406, -0.227531, 0.562074, 0.263298, 0.498707, -0.238017, 0.568227, 0.286116, 0.518039, -0.247936, 0.574473, 0.3101, 0.538277, -0.257437, 0.579191, 0.335401, 0.561166, -0.266829, 0.584807, 0.362246, 0.583189, -0.275329, 0.586476, 0.390609, 0.606024, -0.28234, 0.585578, 0.420998, 0.632419, -0.287924, 0.584496, 0.454357, 0.656128, -0.291972, 0.577766, 0.488233, 0.679953, -0.29456, 0.56875, 0.523248, 0.704654, -0.295816, 0.558388, 0.559168, 0.729016, -0.295157, 0.544826, 0.595326, 0.752062, -0.292779, 0.528273, 0.631864, 0.773138, -0.288681, 0.508482, 0.667793, 0.794869, -0.283358, 0.487341, 0.704035, 0.815101, -0.27608, 0.46354, 0.739925, 0.834212, -0.26767, 0.438672, 0.775539, 0.852368, -0.257397, 0.411239, 0.810895, 0.870207, -0.245689, 0.3829, 0.846472, 0.884063, -0.231452, 0.351496, 0.881788, 0.898284, -0.215561, 0.31895, 0.917438, 0.912964, -0.198208, 0.287367, 0.952422, 0.924666, -0.180426, 0.254487, 0.987551, 0.934429, -0.161525, 0.222226, 1.02142, 0.943485, -0.141197, 0.191143, 1.05218, 0.9521, -0.120085, 0.161112, 1.07937, 0.957876, -0.0975881, 0.130982, 1.10403, 0.966943, -0.0726842, 0.0990553, 1.12616, 0.978313, -0.0483705, 0.0662818, 1.14619, 0.990048, -0.0239072, 0.0329243, 1.16413, 0.999984, 0.000461885, -772859e-10, 1.18099, 0.321287, -935049e-11, 0.455413, 6.59662e-06, 0.332595, -237513e-9, 0.471437, 0.000167562, 0.332729, -949964e-9, 0.471618, 0.000670192, 0.332305, -213618e-8, 0.471028, 0.00150712, 0.332326, -379765e-8, 0.471055, 0.00267959, 0.332344, -593353e-8, 0.471072, 0.00418751, 0.332356, -854349e-8, 0.471077, 0.00603172, 0.332403, -0.0116268, 0.471121, 0.00821362, 0.332461, -0.0151824, 0.47117, 0.0107357, 0.332552, -0.0192088, 0.471251, 0.0136014, 0.332657, -0.0237024, 0.47133, 0.0168152, 0.332835, -0.0286615, 0.471487, 0.0203853, 0.333083, -0.0340765, 0.471708, 0.0243212, 0.333547, -0.0398563, 0.47219, 0.0286518, 0.333989, -0.0460916, 0.472587, 0.0333763, 0.334532, -0.0527897, 0.473054, 0.0385084, 0.335167, -0.0599284, 0.473568, 0.0440638, 0.33608, -0.0673514, 0.474362, 0.0500962, 0.337146, -0.0752237, 0.475231, 0.0566022, 0.338462, -0.083418, 0.476282, 0.0636272, 0.34014, -0.0919382, 0.477615, 0.0712153, 0.342341, -0.100741, 0.479404, 0.079417, 0.345088, -0.109905, 0.481618, 0.0882631, 0.349049, -0.119369, 0.485081, 0.0978851, 0.353939, -0.129033, 0.489317, 0.108336, 0.359893, -0.139038, 0.494309, 0.119698, 0.366945, -0.149411, 0.499983, 0.132024, 0.375814, -0.159843, 0.507185, 0.145558, 0.387112, -0.170664, 0.516392, 0.160433, 0.40023, -0.181897, 0.526519, 0.176648, 0.412555, -0.192785, 0.53423, 0.193922, 0.427023, -0.203663, 0.542741, 0.212662, 0.443685, -0.214695, 0.552066, 0.232944, 0.461499, -0.225561, 0.560762, 0.254495, 0.480975, -0.236257, 0.569421, 0.277531, 0.501, -0.24639, 0.576101, 0.301724, 0.521691, -0.256101, 0.581493, 0.327112, 0.543478, -0.265289, 0.585221, 0.353917, 0.566094, -0.273938, 0.587614, 0.381941, 0.589578, -0.281679, 0.587991, 0.41172, 0.614583, -0.287655, 0.585928, 0.444148, 0.641813, -0.292228, 0.582092, 0.478617, 0.666189, -0.295172, 0.57398, 0.51397, 0.690475, -0.29648, 0.561676, 0.550118, 0.715543, -0.296203, 0.548758, 0.586933, 0.740405, -0.293999, 0.532792, 0.62384, 0.762183, -0.28998, 0.512735, 0.660723, 0.786069, -0.28478, 0.492402, 0.69807, 0.806812, -0.277568, 0.469058, 0.734422, 0.826987, -0.268951, 0.443017, 0.770946, 0.844588, -0.259049, 0.415501, 0.80699, 0.863725, -0.2471, 0.387328, 0.842107, 0.879137, -0.234157, 0.356108, 0.878078, 0.894634, -0.218719, 0.324315, 0.914058, 0.909162, -0.201293, 0.291813, 0.949922, 0.92072, -0.18267, 0.258474, 0.985337, 0.93158, -0.163212, 0.225593, 1.0205, 0.941238, -0.142771, 0.193986, 1.05273, 0.949293, -0.120956, 0.163392, 1.08075, 0.956226, -0.0985743, 0.132934, 1.10559, 0.96546, -0.075118, 0.101255, 1.12823, 0.977403, -0.0497921, 0.0675441, 1.149, 0.989648, -0.0241574, 0.0334681, 1.16765, 1.00001, 0.0005762, -184807e-9, 1.18519, 0.303474, -916603e-11, 0.4542, 6.1243e-06, 0.308894, -232869e-9, 0.462306, 0.000155592, 0.309426, -931661e-9, 0.463093, 0.000622499, 0.308643, -20949e-7, 0.461933, 0.00139979, 0.308651, -37242e-7, 0.461941, 0.00248874, 0.308662, -581873e-8, 0.46195, 0.00388933, 0.308687, -837818e-8, 0.461974, 0.00560247, 0.308728, -0.0114016, 0.462011, 0.00762948, 0.308789, -0.0148884, 0.462067, 0.00997326, 0.308882, -0.0188369, 0.462151, 0.0126375, 0.309007, -0.0232436, 0.462263, 0.0156271, 0.30918, -0.0281054, 0.462417, 0.0189498, 0.309442, -0.0334065, 0.462667, 0.0226167, 0.309901, -0.0390589, 0.463162, 0.0266614, 0.310331, -0.0452042, 0.463555, 0.0310715, 0.310858, -0.0517735, 0.464019, 0.0358698, 0.311576, -0.0587359, 0.464669, 0.0410848, 0.312436, -0.0660383, 0.465406, 0.0467453, 0.313526, -0.0737266, 0.466339, 0.0528718, 0.314903, -0.0817574, 0.467504, 0.0595039, 0.316814, -0.090167, 0.469226, 0.0666888, 0.318965, -0.0987555, 0.470981, 0.0744658, 0.322077, -0.107792, 0.473814, 0.082912, 0.325947, -0.117098, 0.477241, 0.0920846, 0.331008, -0.126602, 0.48184, 0.102137, 0.337893, -0.136619, 0.488334, 0.113135, 0.345106, -0.146838, 0.494415, 0.12511, 0.355111, -0.157357, 0.503275, 0.138356, 0.365095, -0.167955, 0.510966, 0.152686, 0.378344, -0.179157, 0.521508, 0.16856, 0.391599, -0.190143, 0.530455, 0.18561, 0.407786, -0.20123, 0.541275, 0.204308, 0.425294, -0.212456, 0.551784, 0.224623, 0.444021, -0.223568, 0.561493, 0.246172, 0.463418, -0.234154, 0.569886, 0.268979, 0.484077, -0.244546, 0.577116, 0.293411, 0.505513, -0.254301, 0.582914, 0.318936, 0.527672, -0.263564, 0.587208, 0.345856, 0.550565, -0.272332, 0.589277, 0.374054, 0.573656, -0.280011, 0.588426, 0.403276, 0.59827, -0.286924, 0.587504, 0.43474, 0.624731, -0.291994, 0.583401, 0.468767, 0.652396, -0.295159, 0.576997, 0.504411, 0.67732, -0.296954, 0.565863, 0.54114, 0.703147, -0.296877, 0.552316, 0.57816, 0.728715, -0.295147, 0.536773, 0.616124, 0.752448, -0.291275, 0.51771, 0.653885, 0.775169, -0.285905, 0.496087, 0.691537, 0.799307, -0.279064, 0.474232, 0.729251, 0.819482, -0.270294, 0.447676, 0.766267, 0.837659, -0.260032, 0.419656, 0.802616, 0.856903, -0.248497, 0.391328, 0.838583, 0.873325, -0.235252, 0.360285, 0.874711, 0.889788, -0.221126, 0.329215, 0.91077, 0.904486, -0.204304, 0.296392, 0.94653, 0.917711, -0.185562, 0.262159, 0.983828, 0.928969, -0.165635, 0.229142, 1.01955, 0.939707, -0.14442, 0.19673, 1.05317, 0.948167, -0.122147, 0.165095, 1.0823, 0.955222, -0.099098, 0.13451, 1.10791, 0.964401, -0.0755332, 0.102476, 1.1312, 0.976605, -0.0513817, 0.0689667, 1.15218, 0.989085, -0.0258499, 0.034506, 1.17129, 0.999908, 0.000617773, -271268e-9, 1.18961, 0.285803, -905752e-11, 0.452348, 5.72272e-06, 0.284689, -22732e-8, 0.450581, 0.000143626, 0.285263, -910214e-9, 0.451482, 0.000575099, 0.285302, -204784e-8, 0.451553, 0.00129395, 0.285318, -364057e-8, 0.451574, 0.0023006, 0.28533, -568813e-8, 0.451585, 0.00359547, 0.285361, -819001e-8, 0.451618, 0.00517934, 0.285397, -0.0111458, 0.45165, 0.007054, 0.285447, -0.0145536, 0.451688, 0.00922167, 0.285527, -0.0184127, 0.451758, 0.0116869, 0.285688, -0.0227207, 0.451929, 0.0144555, 0.28584, -0.0274712, 0.452055, 0.0175341, 0.286136, -0.0326278, 0.452369, 0.0209406, 0.286574, -0.0381792, 0.452853, 0.0246965, 0.287012, -0.0441879, 0.453272, 0.0287996, 0.287542, -0.0506096, 0.453752, 0.033268, 0.288299, -0.0573634, 0.454488, 0.0381504, 0.289186, -0.0645458, 0.455294, 0.0434447, 0.290302, -0.0720405, 0.456301, 0.0491973, 0.291776, -0.0799046, 0.457648, 0.0554453, 0.29372, -0.088117, 0.459483, 0.0622311, 0.296052, -0.0965328, 0.461571, 0.0695992, 0.299563, -0.105409, 0.465085, 0.077658, 0.30335, -0.114553, 0.468506, 0.0864176, 0.309167, -0.123917, 0.474423, 0.0961078, 0.31529, -0.13381, 0.47995, 0.106643, 0.324163, -0.144021, 0.488592, 0.118322, 0.333272, -0.154382, 0.496461, 0.131133, 0.344224, -0.165015, 0.50562, 0.145208, 0.357733, -0.176168, 0.516719, 0.16073, 0.373046, -0.187468, 0.528513, 0.177807, 0.38788, -0.198488, 0.537713, 0.196072, 0.405133, -0.209545, 0.547999, 0.21605, 0.423845, -0.220724, 0.55759, 0.237484, 0.443777, -0.231518, 0.566246, 0.26039, 0.464824, -0.242035, 0.574326, 0.284835, 0.486635, -0.251898, 0.58037, 0.310518, 0.51012, -0.261304, 0.58568, 0.337678, 0.535301, -0.270384, 0.590197, 0.366242, 0.559193, -0.27841, 0.590569, 0.395873, 0.583544, -0.285325, 0.588161, 0.426857, 0.608834, -0.291113, 0.584249, 0.459477, 0.635753, -0.294882, 0.57763, 0.494734, 0.664367, -0.297088, 0.569479, 0.532023, 0.689688, -0.297364, 0.555064, 0.569629, 0.715732, -0.295949, 0.539522, 0.608124, 0.741307, -0.292259, 0.521613, 0.646231, 0.764949, -0.287063, 0.49969, 0.684938, 0.788599, -0.28012, 0.476747, 0.723548, 0.81048, -0.27153, 0.45116, 0.761135, 0.831372, -0.261289, 0.424101, 0.798916, 0.850092, -0.249559, 0.39443, 0.835952, 0.867777, -0.236348, 0.363849, 0.871606, 0.884632, -0.221569, 0.332477, 0.907843, 0.90047, -0.20618, 0.300667, 0.944187, 0.914524, -0.188771, 0.266552, 0.981371, 0.926892, -0.168362, 0.232349, 1.01841, 0.937951, -0.146761, 0.199359, 1.05308, 0.947236, -0.123813, 0.1675, 1.0839, 0.954367, -0.099984, 0.136166, 1.11047, 0.963907, -0.0759278, 0.103808, 1.13414, 0.976218, -0.0511367, 0.0697061, 1.15575, 0.988772, -0.0267415, 0.0352529, 1.17531, 0.999888, -520778e-9, 0.000289926, 1.19389, 0.263546, -883274e-11, 0.441896, 5.26783e-06, 0.262352, -221849e-9, 0.439889, 0.000132311, 0.262325, -886683e-9, 0.439848, 0.000528824, 0.26228, -199476e-8, 0.439765, 0.00118975, 0.262372, -354671e-8, 0.439922, 0.00211568, 0.26239, -554141e-8, 0.439941, 0.00330652, 0.262412, -797888e-8, 0.439961, 0.00476346, 0.262453, -0.0108584, 0.440002, 0.00648818, 0.262528, -0.0141788, 0.440085, 0.0084835, 0.262615, -0.017938, 0.440166, 0.0107533, 0.262744, -0.0221346, 0.440291, 0.0133044, 0.262939, -0.026762, 0.440493, 0.0161445, 0.263277, -0.0317573, 0.440889, 0.0192974, 0.26368, -0.0371832, 0.441338, 0.0227699, 0.264106, -0.0430371, 0.441753, 0.0265698, 0.264624, -0.0493035, 0.442227, 0.0307178, 0.265378, -0.0558669, 0.442985, 0.0352616, 0.266253, -0.0628718, 0.443795, 0.0401968, 0.267478, -0.0701569, 0.445008, 0.04559, 0.269062, -0.077845, 0.446599, 0.0514539, 0.270926, -0.0857941, 0.448349, 0.0578382, 0.273693, -0.0940773, 0.451221, 0.0648363, 0.276746, -0.102704, 0.454097, 0.0724389, 0.281693, -0.111735, 0.459517, 0.0808744, 0.287335, -0.121004, 0.46531, 0.0901551, 0.29448, -0.130734, 0.472605, 0.100371, 0.30257, -0.140777, 0.480251, 0.111644, 0.312465, -0.15111, 0.489444, 0.124111, 0.324856, -0.16189, 0.500919, 0.137979, 0.33774, -0.172946, 0.511317, 0.153163, 0.35255, -0.184152, 0.522684, 0.169817, 0.367786, -0.19522, 0.53248, 0.187886, 0.385474, -0.20632, 0.543326, 0.207634, 0.404976, -0.217744, 0.554109, 0.229165, 0.425203, -0.228691, 0.563395, 0.252068, 0.446704, -0.239299, 0.571565, 0.276471, 0.468951, -0.249348, 0.577935, 0.302323, 0.493487, -0.258933, 0.584309, 0.329882, 0.517861, -0.268009, 0.58773, 0.358525, 0.543309, -0.276238, 0.589612, 0.388585, 0.569704, -0.28356, 0.589294, 0.419787, 0.594871, -0.289497, 0.585137, 0.452114, 0.622555, -0.294452, 0.580356, 0.486466, 0.651167, -0.296918, 0.57185, 0.523079, 0.677332, -0.297647, 0.558428, 0.5611, 0.703718, -0.296321, 0.542232, 0.599592, 0.730262, -0.293339, 0.524541, 0.639138, 0.754304, -0.288036, 0.502691, 0.677978, 0.778051, -0.281018, 0.479212, 0.716537, 0.801557, -0.272414, 0.454071, 0.75586, 0.822559, -0.262419, 0.425952, 0.794477, 0.843051, -0.250702, 0.397313, 0.832664, 0.86232, -0.237264, 0.366534, 0.869876, 0.879044, -0.222716, 0.334816, 0.906973, 0.896362, -0.206827, 0.303143, 0.943558, 0.910342, -0.189659, 0.269699, 0.979759, 0.924119, -0.171108, 0.236411, 1.01718, 0.935374, -0.149579, 0.202224, 1.05289, 0.944295, -0.126295, 0.16989, 1.08496, 0.952227, -0.101511, 0.138089, 1.11256, 0.962041, -0.0766392, 0.105053, 1.1375, 0.97528, -0.0511967, 0.070329, 1.15983, 0.988476, -0.025463, 0.0351268, 1.17987, 0.999962, 2.86808e-05, 1.45564e-05, 1.19901, 0.227089, -841413e-11, 0.404216, 4.72707e-06, 0.239725, -215083e-9, 0.426708, 0.000120833, 0.239904, -860718e-9, 0.427028, 0.000483555, 0.239911, -193661e-8, 0.427039, 0.00108806, 0.239914, -344276e-8, 0.42704, 0.00193457, 0.239933, -537907e-8, 0.427064, 0.00302363, 0.239944, -774482e-8, 0.427065, 0.00435604, 0.239993, -0.01054, 0.427122, 0.00593398, 0.240052, -0.0137626, 0.427179, 0.00775987, 0.240148, -0.0174115, 0.427279, 0.00983854, 0.240278, -0.021484, 0.42741, 0.0121763, 0.240472, -0.0259729, 0.427618, 0.0147827, 0.240839, -0.0308131, 0.428086, 0.0176837, 0.241201, -0.0360893, 0.428482, 0.0208775, 0.241626, -0.0417723, 0.428907, 0.0243821, 0.242207, -0.0478337, 0.42952, 0.0282228, 0.24298, -0.0542199, 0.430332, 0.0324333, 0.243881, -0.0610015, 0.431222, 0.0370252, 0.245123, -0.0680874, 0.432512, 0.0420535, 0.24667, -0.0755482, 0.434088, 0.0475414, 0.248779, -0.0832873, 0.436323, 0.0535542, 0.251665, -0.0913546, 0.439509, 0.0601716, 0.255305, -0.0998489, 0.443478, 0.0674282, 0.260049, -0.108576, 0.448713, 0.0754673, 0.266192, -0.117754, 0.455524, 0.084339, 0.273158, -0.127294, 0.4627, 0.0941683, 0.282131, -0.137311, 0.472068, 0.10515, 0.293332, -0.147736, 0.483565, 0.117402, 0.304667, -0.158357, 0.493702, 0.130824, 0.317785, -0.169274, 0.504708, 0.145724, 0.333245, -0.180595, 0.517107, 0.16215, 0.349843, -0.191892, 0.528849, 0.180149, 0.367944, -0.203168, 0.540301, 0.199746, 0.387579, -0.214443, 0.551514, 0.221047, 0.408247, -0.225624, 0.560906, 0.243981, 0.43014, -0.236422, 0.56959, 0.268513, 0.452669, -0.24654, 0.576098, 0.294409, 0.476196, -0.256157, 0.580925, 0.322002, 0.501157, -0.265289, 0.584839, 0.351052, 0.527632, -0.273671, 0.587614, 0.3812, 0.555754, -0.281254, 0.589119, 0.412994, 0.581682, -0.287448, 0.585204, 0.445498, 0.608196, -0.292614, 0.579006, 0.479505, 0.635661, -0.296068, 0.571297, 0.514643, 0.664999, -0.297395, 0.560855, 0.552213, 0.691039, -0.296645, 0.544525, 0.591365, 0.7179, -0.293785, 0.526535, 0.630883, 0.744059, -0.289089, 0.50545, 0.670932, 0.76863, -0.282239, 0.482514, 0.710904, 0.793273, -0.273688, 0.457246, 0.750259, 0.814731, -0.26328, 0.428872, 0.78948, 0.835603, -0.251526, 0.399384, 0.828597, 0.85489, -0.238339, 0.368811, 0.866892, 0.872828, -0.223607, 0.336617, 0.90563, 0.889462, -0.207538, 0.303997, 0.943538, 0.904929, -0.190297, 0.270812, 0.980591, 0.919101, -0.172034, 0.237453, 1.01935, 0.930536, -0.152058, 0.204431, 1.05498, 0.941223, -0.129515, 0.172495, 1.08717, 0.94982, -0.104263, 0.140175, 1.11551, 0.960592, -0.0781944, 0.106465, 1.14098, 0.974629, -0.051688, 0.0711592, 1.16418, 0.98811, -0.0253929, 0.0354432, 1.18465, 1.00004, 0.000804378, -330876e-9, 1.20462, 0.214668, -821282e-11, 0.406619, 4.33582e-06, 0.218053, -208144e-9, 0.413025, 0.000109887, 0.217987, -832212e-9, 0.412901, 0.000439362, 0.217971, -187246e-8, 0.412876, 0.000988623, 0.217968, -332855e-8, 0.41286, 0.00175772, 0.217985, -520055e-8, 0.412882, 0.00274729, 0.218014, -748814e-8, 0.412916, 0.00395842, 0.218054, -0.0101901, 0.412957, 0.00539274, 0.218106, -0.0133057, 0.413005, 0.00705348, 0.218217, -0.0168342, 0.413139, 0.00894581, 0.218338, -0.0207707, 0.413258, 0.0110754, 0.21855, -0.0251001, 0.413509, 0.0134551, 0.218913, -0.0297861, 0.413992, 0.0161081, 0.219265, -0.0348956, 0.414383, 0.0190307, 0.219696, -0.0403909, 0.414839, 0.0222458, 0.220329, -0.0462003, 0.415567, 0.025792, 0.220989, -0.0524208, 0.41621, 0.0296637, 0.222027, -0.058948, 0.417385, 0.0339323, 0.223301, -0.0658208, 0.418779, 0.0386055, 0.224988, -0.0730347, 0.420665, 0.0437355, 0.227211, -0.0805274, 0.423198, 0.0493844, 0.230131, -0.088395, 0.426566, 0.0556135, 0.233908, -0.0966208, 0.43091, 0.0624829, 0.239092, -0.105223, 0.437148, 0.0701636, 0.245315, -0.11424, 0.444302, 0.0786949, 0.253166, -0.12368, 0.453262, 0.0882382, 0.262374, -0.133569, 0.463211, 0.0988682, 0.273145, -0.143836, 0.474271, 0.110727, 0.285512, -0.154577, 0.4863, 0.123945, 0.299512, -0.165501, 0.498817, 0.138581, 0.314287, -0.176698, 0.510341, 0.154676, 0.331083, -0.188066, 0.522583, 0.172459, 0.349615, -0.199597, 0.534879, 0.191979, 0.369318, -0.210843, 0.546083, 0.21309, 0.390377, -0.222068, 0.5562, 0.235998, 0.412411, -0.233059, 0.564704, 0.260518, 0.435715, -0.24357, 0.572314, 0.286795, 0.461196, -0.253356, 0.579395, 0.314559, 0.485587, -0.262362, 0.581985, 0.343581, 0.511908, -0.270895, 0.584347, 0.374367, 0.539798, -0.278452, 0.58505, 0.406015, 0.567974, -0.284877, 0.583344, 0.439168, 0.594303, -0.290124, 0.577348, 0.473005, 0.622951, -0.294183, 0.570751, 0.508534, 0.652404, -0.296389, 0.561541, 0.544764, 0.679291, -0.296605, 0.546426, 0.582927, 0.706437, -0.294095, 0.528599, 0.622681, 0.734485, -0.28978, 0.508676, 0.663567, 0.758841, -0.283363, 0.484768, 0.704092, 0.78537, -0.275015, 0.460434, 0.745101, 0.807315, -0.264689, 0.432166, 0.784712, 0.8271, -0.252597, 0.401807, 0.824241, 0.849191, -0.239154, 0.371458, 0.863803, 0.867046, -0.224451, 0.338873, 0.903063, 0.8852, -0.208342, 0.306175, 0.942763, 0.901771, -0.190684, 0.272759, 0.981559, 0.915958, -0.172105, 0.239306, 1.02048, 0.928046, -0.152214, 0.206071, 1.05765, 0.939961, -0.130247, 0.17367, 1.08999, 0.948711, -0.10672, 0.142201, 1.11829, 0.959305, -0.0808688, 0.108454, 1.14467, 0.973009, -0.0539145, 0.0728109, 1.16839, 0.987631, -0.0262947, 0.0360625, 1.19004, 0.999978, 0.00132758, -559424e-9, 1.21058, 0.193925, -793421e-11, 0.391974, 3.92537e-06, 0.196746, -200315e-9, 0.397675, 9.91033e-05, 0.19667, -801099e-9, 0.397521, 0.000396342, 0.196633, -180246e-8, 0.397445, 0.000891829, 0.196654, -320443e-8, 0.397482, 0.00158582, 0.196659, -500647e-8, 0.39748, 0.00247867, 0.196683, -72086e-7, 0.397506, 0.00357167, 0.196728, -981001e-8, 0.397562, 0.00486675, 0.196792, -0.0128096, 0.397633, 0.00636707, 0.19689, -0.0162055, 0.397746, 0.00807752, 0.197017, -0.0199943, 0.397884, 0.0100052, 0.19729, -0.024139, 0.39827, 0.0121691, 0.197583, -0.0286671, 0.398639, 0.0145755, 0.197927, -0.0335858, 0.399034, 0.0172355, 0.198383, -0.0388806, 0.399554, 0.0201718, 0.199002, -0.0444736, 0.400289, 0.0234194, 0.199739, -0.0504583, 0.401111, 0.026984, 0.200784, -0.056729, 0.402349, 0.0309217, 0.202075, -0.0633643, 0.403841, 0.0352496, 0.203898, -0.0703247, 0.406076, 0.0400313, 0.206199, -0.0775565, 0.408841, 0.0453282, 0.209252, -0.085184, 0.41259, 0.0511794, 0.213638, -0.0931994, 0.418288, 0.0577459, 0.21881, -0.101617, 0.424681, 0.0650508, 0.225642, -0.11052, 0.433429, 0.0732759, 0.233717, -0.119772, 0.442897, 0.0824683, 0.242823, -0.129505, 0.452888, 0.0927484, 0.254772, -0.139906, 0.466407, 0.104417, 0.266603, -0.150402, 0.477413, 0.117211, 0.28073, -0.161395, 0.490519, 0.131598, 0.295399, -0.172465, 0.50201, 0.147407, 0.312705, -0.183982, 0.515311, 0.165031, 0.331335, -0.195532, 0.52786, 0.184336, 0.351037, -0.206971, 0.5392, 0.205361, 0.372175, -0.218117, 0.54941, 0.228043, 0.394548, -0.229327, 0.558642, 0.25267, 0.419598, -0.240052, 0.567861, 0.279071, 0.443922, -0.249937, 0.573332, 0.306882, 0.471495, -0.259407, 0.58013, 0.33661, 0.496769, -0.267749, 0.580564, 0.367328, 0.524951, -0.275524, 0.581696, 0.399753, 0.55318, -0.282148, 0.579885, 0.433134, 0.581577, -0.287533, 0.575471, 0.467534, 0.609231, -0.291612, 0.567445, 0.502943, 0.637478, -0.293911, 0.557657, 0.53871, 0.667795, -0.295096, 0.546535, 0.576568, 0.694272, -0.294073, 0.529561, 0.614929, 0.722937, -0.290386, 0.510561, 0.655909, 0.749682, -0.284481, 0.487846, 0.697663, 0.774754, -0.276188, 0.462487, 0.738515, 0.799301, -0.266215, 0.43481, 0.779802, 0.820762, -0.254116, 0.404879, 0.820045, 0.843231, -0.240393, 0.374559, 0.860294, 0.861857, -0.225503, 0.341582, 0.900965, 0.880815, -0.209382, 0.308778, 0.941727, 0.89766, -0.19155, 0.275232, 0.980916, 0.912926, -0.172346, 0.240938, 1.02162, 0.926391, -0.151799, 0.207223, 1.0597, 0.938429, -0.129968, 0.17484, 1.09291, 0.947834, -0.10651, 0.142984, 1.12248, 0.958432, -0.0824098, 0.109902, 1.149, 0.972402, -0.0565242, 0.0744454, 1.1733, 0.987191, -0.028427, 0.0373794, 1.19538, 0.999975, 3.85685e-05, -4203e-8, 1.21676, 0.178114, -766075e-11, 0.385418, 3.54027e-06, 0.176074, -191966e-9, 0.381002, 8.87135e-05, 0.17601, -767549e-9, 0.380861, 0.000354715, 0.17598, -172696e-8, 0.380798, 0.000798168, 0.175994, -307012e-8, 0.380824, 0.00141928, 0.176017, -479684e-8, 0.380858, 0.00221859, 0.176019, -690648e-8, 0.380839, 0.00319714, 0.176072, -939888e-8, 0.380913, 0.0043572, 0.176131, -0.0122726, 0.380979, 0.005702, 0.176239, -0.0155264, 0.38112, 0.00723689, 0.176371, -0.0191551, 0.381272, 0.00896907, 0.176638, -0.023117, 0.381669, 0.0109194, 0.176912, -0.0274633, 0.382015, 0.0130903, 0.177279, -0.032173, 0.382476, 0.0154949, 0.17774, -0.0372219, 0.383041, 0.0181669, 0.178344, -0.0426132, 0.38378, 0.0211209, 0.179153, -0.0483309, 0.384773, 0.0243899, 0.180197, -0.0543447, 0.386076, 0.0280062, 0.181581, -0.0607122, 0.387809, 0.032004, 0.18344, -0.0673855, 0.390205, 0.036453, 0.186139, -0.0743989, 0.393944, 0.0414162, 0.189432, -0.0817731, 0.39832, 0.0469394, 0.193795, -0.0895464, 0.404188, 0.0531442, 0.199641, -0.0978264, 0.4121, 0.0601374, 0.206679, -0.106499, 0.421425, 0.0680078, 0.214865, -0.115654, 0.431504, 0.076919, 0.224406, -0.125268, 0.442526, 0.0868835, 0.235876, -0.135475, 0.455465, 0.0981875, 0.248335, -0.146023, 0.4681, 0.110759, 0.262868, -0.157016, 0.482069, 0.124885, 0.278962, -0.168245, 0.496182, 0.140645, 0.295082, -0.17958, 0.507401, 0.157838, 0.313738, -0.191227, 0.520252, 0.17695, 0.333573, -0.202718, 0.531708, 0.197817, 0.356433, -0.214424, 0.544509, 0.220785, 0.378853, -0.225492, 0.55373, 0.245306, 0.402717, -0.236236, 0.561348, 0.271593, 0.428375, -0.246568, 0.568538, 0.299776, 0.454724, -0.255941, 0.573462, 0.329433, 0.482291, -0.264511, 0.576356, 0.360598, 0.509706, -0.272129, 0.576446, 0.393204, 0.538805, -0.278979, 0.575298, 0.427227, 0.568919, -0.284528, 0.572154, 0.462157, 0.596804, -0.288801, 0.564691, 0.497997, 0.625987, -0.291334, 0.555134, 0.534467, 0.656414, -0.292722, 0.545051, 0.571736, 0.683916, -0.292185, 0.528813, 0.610158, 0.711809, -0.290043, 0.51106, 0.649061, 0.739547, -0.285246, 0.490103, 0.690081, 0.766914, -0.277647, 0.465523, 0.732554, 0.791375, -0.267603, 0.437718, 0.773982, 0.814772, -0.256109, 0.40882, 0.81609, 0.836691, -0.242281, 0.377823, 0.856849, 0.856984, -0.227155, 0.34496, 0.898363, 0.876332, -0.210395, 0.311335, 0.939471, 0.894988, -0.192612, 0.277703, 0.980799, 0.911113, -0.173236, 0.243019, 1.02215, 0.924092, -0.152258, 0.209037, 1.06139, 0.936828, -0.129575, 0.175909, 1.09635, 0.946869, -0.10594, 0.143852, 1.12707, 0.958284, -0.081318, 0.110289, 1.15419, 0.972325, -0.0556133, 0.0747232, 1.17909, 0.986878, -0.0297899, 0.0383149, 1.20163, 0.999936, -197169e-8, 0.000912402, 1.22338, 0.151174, -720365e-11, 0.351531, 3.09789e-06, 0.155594, -18279e-8, 0.361806, 7.8608e-05, 0.156099, -731569e-9, 0.362982, 0.000314615, 0.156053, -164578e-8, 0.362869, 0.000707845, 0.156093, -29261e-7, 0.362961, 0.00125884, 0.156099, -457155e-8, 0.362959, 0.00196783, 0.15612, -658224e-8, 0.362982, 0.00283622, 0.156168, -895774e-8, 0.363048, 0.00386625, 0.156221, -0.0116962, 0.363101, 0.00506109, 0.156324, -0.0147973, 0.363241, 0.00642675, 0.156476, -0.0182503, 0.363448, 0.00797175, 0.156731, -0.0220266, 0.36384, 0.00971484, 0.156994, -0.026176, 0.364179, 0.0116575, 0.157341, -0.0306701, 0.36462, 0.0138207, 0.157867, -0.0354591, 0.365364, 0.0162356, 0.15846, -0.0406141, 0.366111, 0.0189092, 0.159308, -0.0460519, 0.367248, 0.021885, 0.160426, -0.0518096, 0.368767, 0.0252004, 0.161877, -0.0578906, 0.370745, 0.0288825, 0.163995, -0.0642812, 0.373831, 0.0330139, 0.16655, -0.0710067, 0.377366, 0.0376283, 0.170237, -0.0781522, 0.382799, 0.0428493, 0.175096, -0.0857172, 0.389915, 0.0487324, 0.181069, -0.0938025, 0.398487, 0.0554214, 0.188487, -0.102363, 0.408799, 0.0630189, 0.197029, -0.111343, 0.419991, 0.071634, 0.206684, -0.120812, 0.431455, 0.0812797, 0.218698, -0.131033, 0.445746, 0.0923651, 0.230726, -0.141373, 0.457471, 0.104545, 0.245516, -0.152387, 0.472388, 0.118449, 0.261551, -0.163628, 0.486671, 0.133923, 0.277437, -0.174814, 0.49762, 0.150849, 0.296662, -0.186713, 0.51162, 0.169924, 0.31795, -0.198513, 0.525435, 0.190848, 0.339422, -0.210119, 0.536267, 0.213504, 0.362143, -0.221354, 0.545982, 0.237947, 0.387198, -0.23224, 0.555364, 0.264427, 0.412349, -0.24257, 0.561489, 0.292519, 0.439274, -0.252284, 0.566903, 0.322561, 0.466779, -0.261023, 0.569614, 0.353952, 0.496011, -0.26899, 0.571589, 0.387278, 0.524964, -0.275498, 0.570325, 0.421356, 0.556518, -0.281449, 0.568792, 0.457314, 0.584363, -0.285526, 0.560268, 0.493199, 0.614214, -0.28844, 0.55205, 0.530276, 0.645684, -0.289777, 0.541906, 0.56855, 0.673446, -0.289722, 0.526464, 0.606927, 0.701924, -0.287792, 0.509872, 0.645945, 0.73037, -0.284315, 0.490649, 0.685564, 0.757405, -0.278804, 0.467964, 0.726511, 0.784025, -0.269543, 0.441468, 0.768601, 0.808255, -0.258117, 0.41216, 0.811321, 0.830739, -0.244728, 0.380606, 0.853496, 0.851914, -0.229428, 0.348111, 0.895374, 0.872586, -0.212508, 0.314732, 0.937674, 0.891581, -0.194025, 0.280338, 0.979869, 0.907641, -0.174711, 0.245203, 1.02253, 0.922233, -0.153509, 0.21077, 1.06371, 0.935878, -0.130418, 0.177399, 1.09972, 0.946338, -0.105558, 0.144507, 1.13124, 0.957265, -0.080059, 0.110508, 1.15973, 0.971668, -0.0539766, 0.0742311, 1.18515, 0.9866, -0.0277101, 0.0375224, 1.20858, 1.00021, -515531e-9, 0.000135226, 1.23135, 0.137468, -686011e-11, 0.345041, 2.73315e-06, 0.13703, -173378e-9, 0.343936, 6.90761e-05, 0.136986, -693048e-9, 0.34383, 0.000276126, 0.136964, -155931e-8, 0.343761, 0.000621337, 0.137003, -277211e-8, 0.343863, 0.00110494, 0.137012, -433103e-8, 0.343868, 0.00172744, 0.137043, -623606e-8, 0.343916, 0.00249022, 0.13709, -84868e-7, 0.343986, 0.00339559, 0.137145, -0.0110814, 0.344045, 0.00444687, 0.137242, -0.0140187, 0.344177, 0.00565007, 0.137431, -0.0172713, 0.344491, 0.00701868, 0.137644, -0.0208605, 0.344805, 0.00856042, 0.13791, -0.024792, 0.345172, 0.0102863, 0.138295, -0.0290461, 0.345734, 0.0122185, 0.138764, -0.0335957, 0.346371, 0.0143771, 0.139415, -0.038467, 0.347298, 0.0167894, 0.140272, -0.0436176, 0.348527, 0.0194895, 0.141457, -0.0491016, 0.350276, 0.0225043, 0.14303, -0.0548764, 0.352646, 0.0258962, 0.145289, -0.0610096, 0.356206, 0.0297168, 0.148502, -0.0674777, 0.361488, 0.0340562, 0.152188, -0.074345, 0.367103, 0.0389534, 0.157359, -0.0817442, 0.375247, 0.0445541, 0.16379, -0.0896334, 0.385064, 0.0509535, 0.171376, -0.098005, 0.396082, 0.0582611, 0.179901, -0.106817, 0.407418, 0.06654, 0.189892, -0.116239, 0.420031, 0.075994, 0.201838, -0.12627, 0.434321, 0.0867239, 0.214311, -0.136701, 0.447631, 0.0987517, 0.228902, -0.147616, 0.462046, 0.112353, 0.245107, -0.158871, 0.476942, 0.127605, 0.262292, -0.170261, 0.490285, 0.144469, 0.281215, -0.182017, 0.503783, 0.163282, 0.301058, -0.193729, 0.515505, 0.183873, 0.322752, -0.205512, 0.52682, 0.206466, 0.347547, -0.217214, 0.539473, 0.231194, 0.370969, -0.227966, 0.546625, 0.257288, 0.397533, -0.238555, 0.55472, 0.285789, 0.42398, -0.248278, 0.559468, 0.315746, 0.452928, -0.257422, 0.564095, 0.347724, 0.482121, -0.265306, 0.565426, 0.380922, 0.510438, -0.272043, 0.563205, 0.415639, 0.541188, -0.277614, 0.561087, 0.451702, 0.571667, -0.281927, 0.554922, 0.48845, 0.602432, -0.285015, 0.546838, 0.526442, 0.634126, -0.286512, 0.537415, 0.564896, 0.662816, -0.286388, 0.522906, 0.604037, 0.692411, -0.284734, 0.507003, 0.643795, 0.720946, -0.281297, 0.488398, 0.68298, 0.748293, -0.276262, 0.466353, 0.723466, 0.776931, -0.269978, 0.443573, 0.764565, 0.801065, -0.260305, 0.415279, 0.805838, 0.825843, -0.247426, 0.384773, 0.849985, 0.84807, -0.232437, 0.352555, 0.893174, 0.869122, -0.215806, 0.318642, 0.936564, 0.888963, -0.197307, 0.28381, 0.980253, 0.905547, -0.177203, 0.247888, 1.02463, 0.918554, -0.155542, 0.212904, 1.06714, 0.931395, -0.131948, 0.1787, 1.10451, 0.941749, -0.106723, 0.145902, 1.13694, 0.954551, -0.0804939, 0.111193, 1.1666, 0.970279, -0.0534239, 0.0744697, 1.19249, 0.986117, -0.0257452, 0.0368788, 1.21665, 0.999938, 0.00190634, -10291e-7, 1.23981, 0.118493, -647439e-11, 0.32272, 2.3772e-06, 0.118765, -163023e-9, 0.323456, 5.98573e-05, 0.118772, -65212e-8, 0.323477, 0.000239447, 0.118843, -146741e-8, 0.323657, 0.000538881, 0.118804, -260846e-8, 0.323553, 0.00095826, 0.118826, -407576e-8, 0.323595, 0.00149845, 0.118846, -586826e-8, 0.323617, 0.00216047, 0.118886, -798578e-8, 0.32367, 0.00294679, 0.118947, -0.0104273, 0.323753, 0.00386124, 0.119055, -0.0131909, 0.323922, 0.00490999, 0.119241, -0.0162444, 0.324251, 0.00610804, 0.11944, -0.0196339, 0.324544, 0.00745805, 0.119739, -0.0233378, 0.325026, 0.00897805, 0.12011, -0.0273179, 0.325586, 0.0106895, 0.120571, -0.0316143, 0.326231, 0.0126073, 0.12124, -0.0361939, 0.327264, 0.0147654, 0.122162, -0.0410511, 0.328733, 0.0172001, 0.123378, -0.0462233, 0.330659, 0.0199375, 0.125183, -0.0517109, 0.333754, 0.0230498, 0.127832, -0.0575652, 0.338507, 0.026597, 0.130909, -0.0637441, 0.343666, 0.0306345, 0.135221, -0.0704302, 0.351063, 0.035273, 0.14082, -0.0776364, 0.360604, 0.0406137, 0.146781, -0.0852293, 0.369638, 0.0466788, 0.155121, -0.0935351, 0.3827, 0.0537628, 0.16398, -0.102234, 0.39522, 0.0617985, 0.173926, -0.111465, 0.40793, 0.07097, 0.185137, -0.121296, 0.42105, 0.0813426, 0.19826, -0.13169, 0.435735, 0.0931596, 0.212938, -0.142614, 0.450932, 0.106547, 0.229046, -0.153884, 0.465726, 0.121575, 0.246246, -0.165382, 0.479461, 0.138286, 0.264637, -0.176806, 0.492106, 0.15666, 0.284959, -0.188793, 0.504774, 0.17728, 0.308157, -0.200763, 0.518805, 0.19988, 0.330951, -0.21239, 0.528231, 0.224293, 0.3549, -0.223521, 0.536376, 0.250541, 0.381502, -0.234169, 0.544846, 0.278902, 0.409529, -0.244077, 0.551717, 0.309227, 0.437523, -0.253363, 0.55517, 0.341426, 0.467624, -0.261659, 0.557772, 0.37518, 0.497268, -0.268498, 0.556442, 0.41007, 0.528294, -0.274018, 0.553915, 0.446445, 0.559053, -0.278169, 0.549153, 0.483779, 0.589329, -0.281229, 0.539878, 0.522249, 0.622503, -0.282902, 0.53162, 0.561754, 0.652382, -0.282815, 0.518119, 0.601544, 0.681847, -0.281247, 0.502187, 0.641574, 0.712285, -0.277986, 0.484824, 0.682633, 0.740094, -0.273017, 0.463483, 0.723426, 0.768478, -0.266692, 0.441299, 0.763747, 0.794556, -0.258358, 0.415238, 0.805565, 0.819408, -0.248807, 0.386912, 0.847254, 0.843411, -0.236214, 0.356165, 0.891091, 0.862397, -0.219794, 0.320562, 0.936174, 0.883113, -0.201768, 0.285322, 0.982562, 0.90023, -0.181672, 0.249713, 1.02862, 0.915192, -0.159279, 0.214546, 1.07163, 0.928458, -0.134725, 0.180285, 1.10995, 0.94069, -0.10913, 0.147119, 1.14354, 0.953409, -0.0821315, 0.112492, 1.17372, 0.969537, -0.0542677, 0.0752014, 1.20043, 0.985612, -0.0259096, 0.0370361, 1.22528, 0.999835, 0.00298198, -151801e-8, 1.24959, 0.10097, -602574e-11, 0.300277, 2.02619e-06, 0.101577, -152164e-9, 0.302077, 5.11662e-05, 0.101572, -608889e-9, 0.302066, 0.000204751, 0.101566, -136997e-8, 0.302047, 0.000460753, 0.101592, -243557e-8, 0.302114, 0.000819497, 0.101608, -38053e-7, 0.30214, 0.00128154, 0.101627, -547906e-8, 0.30216, 0.0018483, 0.101669, -745647e-8, 0.302224, 0.00252223, 0.101732, -973615e-8, 0.302318, 0.00330716, 0.101844, -0.0123097, 0.302513, 0.00421061, 0.102025, -0.0151681, 0.30285, 0.00524481, 0.102224, -0.0183334, 0.303166, 0.0064154, 0.102515, -0.0217819, 0.303654, 0.00774063, 0.102886, -0.0255067, 0.304243, 0.0092398, 0.103395, -0.029514, 0.305089, 0.0109339, 0.104109, -0.0337912, 0.306301, 0.0128561, 0.105074, -0.0383565, 0.30798, 0.0150338, 0.10654, -0.0432132, 0.310726, 0.0175228, 0.108478, -0.0484244, 0.314351, 0.0203648, 0.111015, -0.0539339, 0.319032, 0.0236325, 0.114682, -0.0598885, 0.32605, 0.0274188, 0.11911, -0.0663375, 0.334109, 0.0317905, 0.124736, -0.0733011, 0.344013, 0.0368502, 0.131479, -0.0807744, 0.355358, 0.0427104, 0.139283, -0.0888204, 0.367614, 0.0494788, 0.148054, -0.0973394, 0.380072, 0.0572367, 0.159037, -0.10665, 0.395678, 0.0662704, 0.169794, -0.116221, 0.40795, 0.0763192, 0.18314, -0.126632, 0.423546, 0.087956, 0.197515, -0.137383, 0.438213, 0.101042, 0.213514, -0.148641, 0.453248, 0.115827, 0.23065, -0.160117, 0.46688, 0.132283, 0.249148, -0.171807, 0.479962, 0.150644, 0.270219, -0.183695, 0.494618, 0.171073, 0.292338, -0.195574, 0.506937, 0.193378, 0.314999, -0.207205, 0.516463, 0.217585, 0.340991, -0.218955, 0.528123, 0.24428, 0.367982, -0.229917, 0.537025, 0.272784, 0.39432, -0.239737, 0.541627, 0.302742, 0.423364, -0.249048, 0.546466, 0.335112, 0.453751, -0.257329, 0.549466, 0.369032, 0.48416, -0.264623, 0.549503, 0.404577, 0.515262, -0.270411, 0.547008, 0.441337, 0.547036, -0.274581, 0.542249, 0.479162, 0.576614, -0.277266, 0.533015, 0.517904, 0.611143, -0.279144, 0.525512, 0.558508, 0.640989, -0.279001, 0.51154, 0.598995, 0.671182, -0.277324, 0.495641, 0.639935, 0.700848, -0.273908, 0.477526, 0.681017, 0.729862, -0.269063, 0.457955, 0.722764, 0.758273, -0.262282, 0.434846, 0.764349, 0.784121, -0.254281, 0.409203, 0.806206, 0.809798, -0.24505, 0.382694, 0.848617, 0.834953, -0.233861, 0.354034, 0.892445, 0.856817, -0.221308, 0.321764, 0.936263, 0.877609, -0.205996, 0.288118, 0.982401, 0.897489, -0.186702, 0.253277, 1.02975, 0.913792, -0.164618, 0.217963, 1.07488, 0.92785, -0.140023, 0.183221, 1.11487, 0.940378, -0.11328, 0.149385, 1.14947, 0.95273, -0.0853958, 0.114152, 1.1807, 0.969059, -0.0568698, 0.0769845, 1.20912, 0.985574, -0.0276502, 0.0381186, 1.23498, 0.999943, 0.00239052, -126861e-8, 1.25987, 0.0852715, -560067e-11, 0.279021, 1.71162e-06, 0.0854143, -140871e-9, 0.279483, 4.30516e-05, 0.0854191, -563385e-9, 0.2795, 0.000172184, 0.0854188, -126753e-8, 0.279493, 0.000387464, 0.0854229, -225337e-8, 0.279501, 0.00068918, 0.0854443, -352086e-8, 0.279549, 0.00107803, 0.0854697, -506962e-8, 0.279591, 0.00155536, 0.0855093, -689873e-8, 0.279652, 0.00212354, 0.0855724, -900821e-8, 0.279752, 0.00278703, 0.0856991, -0.0113799, 0.280011, 0.0035551, 0.085855, -0.0140314, 0.280297, 0.00443449, 0.0860682, -0.016963, 0.280682, 0.00543636, 0.086344, -0.0201438, 0.281159, 0.0065788, 0.0867426, -0.0235999, 0.281886, 0.00787977, 0.087239, -0.0273069, 0.282745, 0.0093606, 0.0879815, -0.031269, 0.284139, 0.011056, 0.0891258, -0.035531, 0.28647, 0.0130065, 0.0906909, -0.0400947, 0.289708, 0.0152495, 0.0927624, -0.0449638, 0.293904, 0.0178454, 0.0958376, -0.0502427, 0.300471, 0.0208915, 0.0995827, -0.0559514, 0.30806, 0.0244247, 0.104526, -0.0622152, 0.317874, 0.0285721, 0.110532, -0.0690046, 0.329332, 0.0334227, 0.117385, -0.0763068, 0.341217, 0.0390466, 0.12522, -0.084184, 0.353968, 0.0455786, 0.134037, -0.0925248, 0.366797, 0.0530773, 0.144014, -0.101487, 0.380209, 0.0617424, 0.156013, -0.111273, 0.395956, 0.071777, 0.168872, -0.121431, 0.41053, 0.0830905, 0.183089, -0.132105, 0.425073, 0.0959341, 0.198763, -0.143286, 0.439833, 0.110448, 0.216159, -0.154841, 0.454507, 0.126769, 0.234859, -0.166588, 0.468368, 0.14495, 0.255879, -0.178626, 0.482846, 0.165233, 0.27677, -0.190218, 0.493489, 0.187217, 0.301184, -0.202227, 0.506549, 0.211659, 0.325852, -0.213764, 0.5158, 0.237922, 0.352824, -0.22487, 0.525442, 0.26632, 0.380882, -0.235246, 0.532487, 0.296691, 0.410137, -0.244847, 0.537703, 0.329179, 0.439787, -0.253122, 0.540361, 0.363135, 0.472291, -0.260517, 0.542734, 0.399222, 0.501856, -0.266519, 0.538826, 0.436352, 0.534816, -0.270905, 0.535152, 0.474505, 0.565069, -0.273826, 0.525979, 0.513988, 0.597154, -0.275333, 0.516394, 0.554852, 0.630473, -0.275314, 0.506206, 0.596592, 0.660574, -0.273323, 0.489769, 0.638117, 0.692015, -0.270008, 0.472578, 0.680457, 0.720647, -0.265001, 0.452134, 0.723008, 0.750528, -0.258311, 0.430344, 0.765954, 0.777568, -0.250046, 0.405624, 0.809012, 0.80387, -0.240114, 0.378339, 0.852425, 0.828439, -0.228737, 0.349877, 0.895346, 0.851472, -0.216632, 0.318968, 0.940695, 0.873906, -0.202782, 0.287489, 0.987235, 0.89467, -0.187059, 0.254394, 1.03348, 0.912281, -0.168818, 0.221294, 1.07812, 0.927358, -0.146494, 0.18675, 1.11928, 0.940385, -0.120009, 0.152322, 1.15609, 0.952672, -0.0917183, 0.117514, 1.18875, 0.968496, -0.0620321, 0.0797405, 1.21821, 0.985236, -0.0314945, 0.0402383, 1.24523, 0.99998, -575153e-9, 0.000110644, 1.27133, 0.0702429, -512222e-11, 0.255273, 1.40947e-06, 0.0702981, -128826e-9, 0.255469, 3.54488e-05, 0.0703691, -515562e-9, 0.255727, 0.000141874, 0.0703805, -116e-5, 0.255754, 0.00031929, 0.0703961, -206224e-8, 0.255813, 0.000567999, 0.0704102, -322223e-8, 0.255839, 0.00088871, 0.0704298, -463928e-8, 0.255863, 0.00128272, 0.0704759, -631375e-8, 0.255953, 0.00175283, 0.0705434, -824317e-8, 0.256079, 0.00230342, 0.0706693, -0.010412, 0.25636, 0.0029443, 0.0708189, -0.0128439, 0.256647, 0.00368031, 0.0710364, -0.0155177, 0.257084, 0.00452614, 0.0713223, -0.0184374, 0.257637, 0.00549706, 0.0717182, -0.0216002, 0.258416, 0.00661246, 0.072321, -0.0249966, 0.259699, 0.00790147, 0.0731446, -0.0286566, 0.261475, 0.0093884, 0.0743352, -0.0325888, 0.264132, 0.0111186, 0.0760676, -0.036843, 0.26815, 0.013145, 0.078454, -0.0414292, 0.273636, 0.0155251, 0.0818618, -0.0464634, 0.281653, 0.0183525, 0.0857382, -0.0519478, 0.289992, 0.0216642, 0.0908131, -0.0579836, 0.30066, 0.0255956, 0.0967512, -0.0645124, 0.312204, 0.0301954, 0.103717, -0.0716505, 0.325001, 0.0356017, 0.111596, -0.0793232, 0.338129, 0.041896, 0.120933, -0.087645, 0.352853, 0.0492447, 0.130787, -0.096492, 0.366192, 0.0576749, 0.142311, -0.105973, 0.380864, 0.0673969, 0.155344, -0.116182, 0.396575, 0.0785899, 0.169535, -0.126815, 0.411443, 0.0912377, 0.185173, -0.138015, 0.426256, 0.105607, 0.201755, -0.149325, 0.439607, 0.121551, 0.221334, -0.161207, 0.455467, 0.139608, 0.241461, -0.173162, 0.469096, 0.159591, 0.26294, -0.18504, 0.481014, 0.18156, 0.286776, -0.196881, 0.493291, 0.205781, 0.311596, -0.208311, 0.503556, 0.231819, 0.338667, -0.219671, 0.513268, 0.260274, 0.366021, -0.230451, 0.519414, 0.290862, 0.395875, -0.240131, 0.526766, 0.323196, 0.425564, -0.248566, 0.52905, 0.357071, 0.457094, -0.256195, 0.530796, 0.393262, 0.488286, -0.262331, 0.528703, 0.430797, 0.522291, -0.267141, 0.52727, 0.470231, 0.554172, -0.270411, 0.519848, 0.510477, 0.586427, -0.271986, 0.510307, 0.551594, 0.619638, -0.27192, 0.499158, 0.593849, 0.650656, -0.269817, 0.483852, 0.636314, 0.68284, -0.266267, 0.467515, 0.679679, 0.714356, -0.26113, 0.44931, 0.723884, 0.742717, -0.254067, 0.425789, 0.767245, 0.770894, -0.245652, 0.401144, 0.811819, 0.797358, -0.235554, 0.374224, 0.856315, 0.823377, -0.223896, 0.346167, 0.901077, 0.847456, -0.210865, 0.316056, 0.946502, 0.870697, -0.196574, 0.284503, 0.993711, 0.891068, -0.180814, 0.251628, 1.04134, 0.909267, -0.163314, 0.219065, 1.08609, 0.925653, -0.143304, 0.186446, 1.12702, 0.940017, -0.121322, 0.153416, 1.16371, 0.952398, -0.0973872, 0.120334, 1.19712, 0.967568, -0.0698785, 0.08352, 1.22791, 0.984772, -0.0390031, 0.0439209, 1.25672, 1.00026, -70087e-7, 0.00315668, 1.28428, 0.0556653, -459654e-11, 0.227325, 1.12556e-06, 0.0565238, -116382e-9, 0.230826, 2.84985e-05, 0.0565717, -465666e-9, 0.231026, 0.000114036, 0.0565859, -104773e-8, 0.231079, 0.000256656, 0.0565761, -186255e-8, 0.231025, 0.00045663, 0.0565913, -291002e-8, 0.231058, 0.000714664, 0.0566108, -418998e-8, 0.231085, 0.00103224, 0.0566532, -570206e-8, 0.231169, 0.00141202, 0.0567473, -743666e-8, 0.231417, 0.00186018, 0.0568567, -940298e-8, 0.231661, 0.00238264, 0.0569859, -0.0115991, 0.231895, 0.00298699, 0.0572221, -0.0140096, 0.232456, 0.00368957, 0.057519, -0.0166508, 0.233096, 0.00450303, 0.0579534, -0.01951, 0.234094, 0.00544945, 0.0585922, -0.0225991, 0.235629, 0.00655564, 0.0595647, -0.0259416, 0.238106, 0.00785724, 0.0609109, -0.0295661, 0.241557, 0.00939127, 0.0628751, -0.0335126, 0.246652, 0.0112198, 0.0656908, -0.0378604, 0.254091, 0.0134168, 0.0691347, -0.0426543, 0.262666, 0.0160374, 0.0732165, -0.0478967, 0.272029, 0.0191514, 0.0782863, -0.0536716, 0.283007, 0.0228597, 0.0843973, -0.0600683, 0.295732, 0.0272829, 0.0913598, -0.0670095, 0.308779, 0.032484, 0.0994407, -0.0745516, 0.322886, 0.0385886, 0.108189, -0.082712, 0.336408, 0.0457133, 0.118574, -0.0914927, 0.351692, 0.0539832, 0.129989, -0.100854, 0.366502, 0.0635162, 0.142722, -0.110837, 0.381675, 0.0744386, 0.156654, -0.121353, 0.3963, 0.0868483, 0.172151, -0.132414, 0.411477, 0.100963, 0.188712, -0.143809, 0.42508, 0.116795, 0.208093, -0.155765, 0.441328, 0.134715, 0.227936, -0.167608, 0.454328, 0.154396, 0.249495, -0.179579, 0.467235, 0.176179, 0.27362, -0.191488, 0.480248, 0.200193, 0.296371, -0.202618, 0.487886, 0.225775, 0.324234, -0.214133, 0.499632, 0.25441, 0.353049, -0.225212, 0.509532, 0.285077, 0.381785, -0.234875, 0.514265, 0.317047, 0.414038, -0.244205, 0.521282, 0.351874, 0.445251, -0.252145, 0.522931, 0.388279, 0.476819, -0.258433, 0.520947, 0.425825, 0.509209, -0.263411, 0.517669, 0.465104, 0.542759, -0.266732, 0.512841, 0.505741, 0.574822, -0.268263, 0.503317, 0.547611, 0.609324, -0.268489, 0.493035, 0.590953, 0.641772, -0.266941, 0.478816, 0.63488, 0.674049, -0.263297, 0.462863, 0.679072, 0.705071, -0.257618, 0.442931, 0.723487, 0.734709, -0.250625, 0.421299, 0.768708, 0.763704, -0.24179, 0.397085, 0.814375, 0.791818, -0.231115, 0.370577, 0.859907, 0.817439, -0.21922, 0.34232, 0.906715, 0.843202, -0.205658, 0.312627, 0.953943, 0.866639, -0.190563, 0.280933, 1.00185, 0.888129, -0.173978, 0.248393, 1.05105, 0.907239, -0.155485, 0.216007, 1.09704, 0.923893, -0.134782, 0.183233, 1.13857, 0.938882, -0.11249, 0.150376, 1.17539, 0.952464, -0.0890706, 0.117177, 1.20924, 0.968529, -0.0646523, 0.0813095, 1.24055, 0.984763, -0.038606, 0.0439378, 1.27018, 1.00053, -0.01238, 0.00598668, 1.29873, 0.0437928, -409594e-11, 0.204012, 8.79224e-07, 0.0440166, -103395e-9, 0.205049, 2.21946e-05, 0.0440529, -413633e-9, 0.205225, 8.87981e-05, 0.0440493, -930594e-9, 0.2052, 0.000199858, 0.0439884, -165352e-8, 0.204901, 0.000355495, 0.0440716, -25849e-7, 0.205255, 0.000556983, 0.0440968, -372222e-8, 0.205311, 0.000805326, 0.0441359, -506478e-8, 0.205391, 0.00110333, 0.0442231, -660384e-8, 0.205638, 0.00145768, 0.0443254, -835246e-8, 0.205877, 0.00187275, 0.0444832, -0.0102992, 0.20627, 0.00235938, 0.0447001, -0.0124449, 0.206796, 0.0029299, 0.0450168, -0.0147935, 0.207593, 0.0036005, 0.0454816, -0.017336, 0.208819, 0.00439246, 0.0462446, -0.0201156, 0.211036, 0.00533864, 0.0473694, -0.0231568, 0.214388, 0.00646984, 0.0490191, -0.0264941, 0.219357, 0.00783856, 0.0512776, -0.030184, 0.226061, 0.00950182, 0.0541279, -0.0342661, 0.234094, 0.0115156, 0.0578989, -0.0388539, 0.244297, 0.0139687, 0.0620835, -0.0438735, 0.254457, 0.0169015, 0.0673497, -0.04951, 0.266706, 0.0204554, 0.0731759, -0.0556263, 0.278753, 0.0246606, 0.0803937, -0.0624585, 0.29309, 0.0297126, 0.0879287, -0.0697556, 0.305856, 0.0355868, 0.0970669, -0.0778795, 0.321059, 0.0425768, 0.106508, -0.0863541, 0.333873, 0.05056, 0.11776, -0.0955935, 0.349008, 0.0598972, 0.130081, -0.105438, 0.363776, 0.0706314, 0.144454, -0.115899, 0.380112, 0.0828822, 0.1596, -0.126827, 0.394843, 0.0967611, 0.176097, -0.138161, 0.409033, 0.112381, 0.194726, -0.149904, 0.424257, 0.129952, 0.213944, -0.161675, 0.436945, 0.149333, 0.235516, -0.173659, 0.450176, 0.170892, 0.260564, -0.185963, 0.466305, 0.194984, 0.285183, -0.197582, 0.477328, 0.220805, 0.311095, -0.208697, 0.486566, 0.248694, 0.338924, -0.219519, 0.494811, 0.279015, 0.369757, -0.229766, 0.504065, 0.311725, 0.3996, -0.238879, 0.507909, 0.345844, 0.430484, -0.246802, 0.509805, 0.381749, 0.46413, -0.253924, 0.511436, 0.420251, 0.497077, -0.259319, 0.508787, 0.459957, 0.530434, -0.263297, 0.50394, 0.501356, 0.565725, -0.265619, 0.49804, 0.544252, 0.599254, -0.265842, 0.487346, 0.587856, 0.631251, -0.263978, 0.472975, 0.631969, 0.663972, -0.26043, 0.457135, 0.677471, 0.697724, -0.255358, 0.439844, 0.723744, 0.727725, -0.248308, 0.417872, 0.770653, 0.756417, -0.239181, 0.39273, 0.817357, 0.785419, -0.22814, 0.367839, 0.864221, 0.81266, -0.215681, 0.339449, 0.912701, 0.839391, -0.201623, 0.309279, 0.962419, 0.86366, -0.185624, 0.278029, 1.0122, 0.885028, -0.16797, 0.245294, 1.06186, 0.904639, -0.148336, 0.212689, 1.10934, 0.922048, -0.12637, 0.179616, 1.15063, 0.936952, -0.102928, 0.146749, 1.18885, 0.951895, -0.0785268, 0.112733, 1.22352, 0.967198, -0.0530153, 0.0760056, 1.25681, 0.984405, -0.02649, 0.0383183, 1.28762, 1.00021, 0.00070019, -20039e-8, 1.31656, 0.0325964, -355447e-11, 0.176706, 6.55682e-07, 0.0329333, -899174e-10, 0.178527, 1.65869e-05, 0.0329181, -359637e-9, 0.178453, 6.63498e-05, 0.0329085, -808991e-9, 0.178383, 0.000149332, 0.0329181, -143826e-8, 0.178394, 0.000265873, 0.0329425, -224678e-8, 0.178517, 0.000416597, 0.0329511, -323575e-8, 0.17849, 0.000603299, 0.033011, -439875e-8, 0.178695, 0.000829422, 0.0330733, -574059e-8, 0.178843, 0.00109908, 0.0331857, -725896e-8, 0.179176, 0.00141933, 0.0333445, -895289e-8, 0.179618, 0.0017999, 0.0335674, -0.0108219, 0.180238, 0.00225316, 0.033939, -0.0128687, 0.181417, 0.00279765, 0.0345239, -0.015114, 0.183395, 0.0034564, 0.0354458, -0.017596, 0.186616, 0.00425864, 0.0368313, -0.0203524, 0.191547, 0.00524936, 0.0386115, -0.0234105, 0.197508, 0.00647033, 0.0410303, -0.0268509, 0.205395, 0.00798121, 0.0442245, -0.0307481, 0.215365, 0.0098557, 0.0478659, -0.0350863, 0.225595, 0.0121417, 0.0522416, -0.0399506, 0.236946, 0.0149385, 0.0574513, -0.045357, 0.249442, 0.0183189, 0.0631208, -0.0512863, 0.261222, 0.0223644, 0.0701124, -0.0579273, 0.275418, 0.0272418, 0.0777331, -0.0650652, 0.288989, 0.0329458, 0.0862709, -0.0728813, 0.302546, 0.0396819, 0.096103, -0.081363, 0.317164, 0.04757, 0.106976, -0.0904463, 0.331733, 0.0567012, 0.119175, -0.100105, 0.34661, 0.067202, 0.132919, -0.110375, 0.362249, 0.0792588, 0.147727, -0.121115, 0.376978, 0.0928672, 0.163618, -0.132299, 0.390681, 0.108228, 0.182234, -0.143887, 0.406571, 0.125502, 0.201809, -0.155827, 0.42042, 0.144836, 0.225041, -0.168357, 0.438411, 0.166706, 0.247621, -0.18004, 0.450368, 0.189909, 0.27097, -0.191536, 0.460083, 0.215251, 0.296658, -0.203024, 0.469765, 0.243164, 0.325892, -0.214056, 0.481837, 0.273388, 0.35406, -0.224104, 0.487474, 0.305344, 0.384372, -0.233489, 0.492773, 0.339741, 0.41749, -0.241874, 0.498451, 0.376287, 0.45013, -0.248834, 0.499632, 0.414195, 0.481285, -0.254658, 0.495233, 0.454077, 0.519183, -0.259367, 0.496401, 0.496352, 0.551544, -0.261818, 0.487686, 0.538798, 0.587349, -0.262964, 0.479453, 0.583626, 0.621679, -0.262128, 0.467709, 0.629451, 0.654991, -0.258998, 0.452123, 0.67566, 0.686873, -0.254119, 0.433495, 0.723248, 0.719801, -0.246946, 0.413657, 0.771156, 0.750355, -0.237709, 0.390366, 0.81989, 0.780033, -0.226549, 0.364947, 0.868601, 0.809254, -0.214186, 0.337256, 0.920034, 0.836576, -0.199639, 0.307395, 0.971706, 0.861774, -0.183169, 0.275431, 1.02479, 0.885707, -0.165111, 0.243431, 1.07837, 0.904742, -0.144363, 0.210921, 1.12783, 0.915604, -0.121305, 0.17647, 1.17254, 0.930959, -0.0962119, 0.143106, 1.21012, 0.948404, -0.069969, 0.108112, 1.24474, 0.967012, -0.0427586, 0.0708478, 1.27718, 0.984183, -0.0147043, 0.032335, 1.3083, 0.999577, 0.0142165, -726867e-8, 1.3382, 0.0229227, -299799e-11, 0.148623, 4.62391e-07, 0.0232194, -758796e-10, 0.15054, 1.17033e-05, 0.0232315, -303636e-9, 0.15063, 4.68397e-05, 0.0232354, -683189e-9, 0.150624, 0.000105472, 0.0232092, -12136e-7, 0.150445, 0.000187744, 0.0232523, -189765e-8, 0.150679, 0.000294847, 0.0232828, -273247e-8, 0.150789, 0.000428013, 0.0233371, -371287e-8, 0.150995, 0.000591134, 0.0234015, -484794e-8, 0.15118, 0.000787642, 0.023514, -612877e-8, 0.151562, 0.00102547, 0.023679, -756125e-8, 0.152116, 0.00131351, 0.0239559, -914651e-8, 0.153162, 0.00166594, 0.0244334, -0.010904, 0.155133, 0.00210182, 0.025139, -0.0128615, 0.158035, 0.00264406, 0.0262598, -0.0150628, 0.162751, 0.00332923, 0.0277875, -0.0175532, 0.168944, 0.00419773, 0.0298472, -0.0203981, 0.176835, 0.00530034, 0.0325444, -0.023655, 0.186686, 0.00669777, 0.0355581, -0.0272982, 0.196248, 0.00842661, 0.0392841, -0.0314457, 0.207352, 0.0105854, 0.0436815, -0.0361157, 0.219279, 0.0132458, 0.0485272, -0.0412932, 0.230728, 0.0164736, 0.0541574, -0.0470337, 0.242994, 0.0203715, 0.0609479, -0.0535002, 0.257042, 0.0250953, 0.0685228, -0.0605409, 0.27102, 0.0306856, 0.0768042, -0.0680553, 0.28406, 0.037193, 0.0864844, -0.0765011, 0.299186, 0.0449795, 0.0969415, -0.0852674, 0.3132, 0.0538316, 0.108478, -0.0947333, 0.327138, 0.0641149, 0.121705, -0.10481, 0.342345, 0.0759185, 0.136743, -0.115474, 0.358472, 0.0894116, 0.152986, -0.126536, 0.374067, 0.104562, 0.170397, -0.138061, 0.388267, 0.121632, 0.191392, -0.150203, 0.406467, 0.140996, 0.211566, -0.161751, 0.418641, 0.161696, 0.233567, -0.173407, 0.430418, 0.184557, 0.257769, -0.185397, 0.44277, 0.210092, 0.28531, -0.197048, 0.457191, 0.237827, 0.311726, -0.20784, 0.464712, 0.267253, 0.340537, -0.218345, 0.472539, 0.299332, 0.372921, -0.228306, 0.482331, 0.333988, 0.402924, -0.236665, 0.484378, 0.369722, 0.434475, -0.244097, 0.484717, 0.407836, 0.469736, -0.250547, 0.487093, 0.448465, 0.505045, -0.25511, 0.485575, 0.490263, 0.540262, -0.258444, 0.481225, 0.534495, 0.576347, -0.259903, 0.473481, 0.579451, 0.608656, -0.259572, 0.4603, 0.625604, 0.646679, -0.257908, 0.450341, 0.674511, 0.679902, -0.253663, 0.431561, 0.723269, 0.714159, -0.247419, 0.412684, 0.773263, 0.745345, -0.239122, 0.389388, 0.824182, 0.778248, -0.228837, 0.365361, 0.876634, 0.807208, -0.216197, 0.337667, 0.92945, 0.835019, -0.201772, 0.307197, 0.985261, 0.860261, -0.185291, 0.274205, 1.04299, 0.877601, -0.165809, 0.240178, 1.09816, 0.898211, -0.143897, 0.207571, 1.14694, 0.915789, -0.119513, 0.174904, 1.19008, 0.931831, -0.0932919, 0.141423, 1.2297, 0.949244, -0.0656528, 0.105603, 1.26553, 0.967527, -0.0370262, 0.0679551, 1.29986, 0.984139, -730117e-8, 0.0283133, 1.33252, 0.999713, 0.0234648, -0.0121785, 1.36397, 0.0152135, -245447e-11, 0.122795, 3.04092e-07, 0.0151652, -615778e-10, 0.122399, 7.6292e-06, 0.0151181, -245948e-9, 0.122023, 3.04802e-05, 0.0151203, -553394e-9, 0.12203, 6.86634e-05, 0.015125, -983841e-9, 0.122037, 0.000122463, 0.0151427, -153774e-8, 0.12214, 0.000192706, 0.0151708, -22103e-7, 0.122237, 0.000281219, 0.0152115, -300741e-8, 0.12238, 0.000390804, 0.0152877, -392494e-8, 0.1227, 0.000526317, 0.015412, -496597e-8, 0.123244, 0.00069443, 0.0156201, -613314e-8, 0.124228, 0.00090547, 0.0159658, -744113e-8, 0.125945, 0.0011732, 0.0165674, -892546e-8, 0.129098, 0.00151888, 0.017487, -0.010627, 0.133865, 0.00197007, 0.018839, -0.0126043, 0.140682, 0.0025637, 0.020554, -0.0148814, 0.148534, 0.00333637, 0.0226727, -0.0175123, 0.157381, 0.00433738, 0.0251879, -0.0205266, 0.166685, 0.00561664, 0.0283635, -0.0240319, 0.177796, 0.00725563, 0.0318694, -0.0279432, 0.188251, 0.00928811, 0.0361044, -0.0324313, 0.200038, 0.011835, 0.0406656, -0.0373527, 0.210685, 0.0149146, 0.0463846, -0.0430132, 0.224182, 0.0187254, 0.0525696, -0.0491013, 0.23634, 0.0232283, 0.0598083, -0.0559175, 0.250013, 0.0286521, 0.0679437, -0.0633657, 0.263981, 0.0350634, 0.0771181, -0.0714602, 0.278072, 0.0425882, 0.0881273, -0.0803502, 0.29511, 0.0514487, 0.0996628, -0.0896903, 0.309976, 0.0615766, 0.112702, -0.099644, 0.325611, 0.0732139, 0.126488, -0.109829, 0.339321, 0.0862324, 0.142625, -0.120859, 0.35574, 0.101275, 0.15953, -0.131956, 0.369845, 0.117892, 0.176991, -0.143145, 0.38146, 0.136205, 0.199715, -0.155292, 0.40052, 0.157252, 0.220787, -0.167066, 0.412055, 0.179966, 0.243697, -0.178396, 0.423133, 0.204418, 0.272106, -0.190433, 0.439524, 0.232141, 0.297637, -0.201265, 0.447041, 0.261109, 0.325273, -0.211834, 0.454488, 0.292627, 0.357219, -0.221889, 0.465004, 0.326669, 0.387362, -0.230729, 0.468527, 0.362426, 0.423131, -0.23924, 0.475836, 0.401533, 0.45543, -0.246067, 0.475017, 0.441902, 0.493393, -0.251557, 0.478017, 0.484239, 0.526253, -0.255571, 0.4709, 0.528586, 0.560554, -0.257752, 0.463167, 0.574346, 0.599306, -0.258076, 0.456452, 0.621655, 0.634541, -0.256471, 0.443725, 0.670492, 0.668907, -0.253283, 0.428719, 0.721943, 0.705619, -0.247562, 0.411348, 0.772477, 0.739034, -0.240626, 0.388939, 0.8264, 0.771408, -0.231493, 0.36425, 0.881702, 0.803312, -0.220125, 0.337321, 0.9385, 0.828457, -0.206645, 0.305364, 0.997437, 0.854819, -0.190664, 0.273715, 1.05693, 0.878666, -0.171429, 0.242218, 1.11251, 0.898404, -0.149235, 0.209556, 1.16398, 0.917416, -0.12435, 0.176863, 1.21014, 0.933133, -0.0972703, 0.142775, 1.25178, 0.95066, -0.0683607, 0.106735, 1.29028, 0.968589, -0.0378724, 0.0681609, 1.32703, 0.984776, -605712e-8, 0.0273966, 1.36158, 0.99994, 0.0263276, -0.0138124, 1.3943, 0.00867437, -186005e-11, 0.0928979, 1.73682e-07, 0.00864003, -466389e-10, 0.0925237, 4.35505e-06, 0.00864593, -186594e-9, 0.0925806, 1.74322e-05, 0.00864095, -419639e-9, 0.0924903, 3.92862e-05, 0.00863851, -746272e-9, 0.0924589, 7.02598e-05, 0.00868531, -116456e-8, 0.0929, 0.000111188, 0.00869667, -167711e-8, 0.0928529, 0.000163867, 0.00874332, -228051e-8, 0.0930914, 0.00023104, 0.00882709, -297864e-8, 0.0935679, 0.00031741, 0.00898874, -377557e-8, 0.0946165, 0.000430186, 0.00929346, -469247e-8, 0.0967406, 0.000580383, 0.00978271, -575491e-8, 0.100084, 0.000783529, 0.0105746, -701514e-8, 0.105447, 0.00106304, 0.0116949, -851797e-8, 0.112494, 0.00144685, 0.0130419, -0.0102757, 0.119876, 0.00196439, 0.0148375, -0.012381, 0.129034, 0.00266433, 0.0168725, -0.01482, 0.137812, 0.00358364, 0.0193689, -0.0176563, 0.147696, 0.00478132, 0.0222691, -0.0209211, 0.157795, 0.00631721, 0.0256891, -0.0246655, 0.168431, 0.00826346, 0.0294686, -0.0288597, 0.178587, 0.0106714, 0.0340412, -0.0336441, 0.190251, 0.0136629, 0.0393918, -0.039033, 0.202999, 0.0173272, 0.0453947, -0.0450087, 0.215655, 0.0217448, 0.0521936, -0.0515461, 0.228686, 0.0269941, 0.0600279, -0.058817, 0.242838, 0.033272, 0.0692398, -0.0667228, 0.258145, 0.0406457, 0.0793832, -0.0752401, 0.273565, 0.0492239, 0.0902297, -0.0841851, 0.287735, 0.0590105, 0.102014, -0.0936479, 0.301161, 0.0702021, 0.116054, -0.103967, 0.317438, 0.0832001, 0.13191, -0.114622, 0.334166, 0.0977951, 0.148239, -0.125452, 0.348192, 0.113985, 0.165809, -0.136453, 0.361094, 0.131928, 0.184616, -0.147648, 0.373534, 0.151811, 0.207491, -0.159607, 0.39101, 0.174476, 0.230106, -0.171119, 0.402504, 0.198798, 0.257036, -0.182906, 0.418032, 0.225796, 0.281172, -0.193605, 0.425468, 0.254027, 0.312034, -0.204771, 0.440379, 0.285713, 0.340402, -0.214988, 0.445406, 0.319196, 0.370231, -0.224711, 0.44968, 0.35537, 0.407105, -0.233516, 0.460747, 0.393838, 0.439037, -0.240801, 0.460624, 0.433747, 0.47781, -0.24762, 0.465957, 0.477234, 0.510655, -0.251823, 0.460054, 0.52044, 0.550584, -0.255552, 0.459172, 0.567853, 0.585872, -0.257036, 0.450311, 0.615943, 0.620466, -0.257535, 0.437763, 0.667693, 0.660496, -0.255248, 0.426639, 0.718988, 0.695578, -0.251141, 0.409185, 0.772503, 0.732176, -0.244718, 0.39015, 0.827023, 0.760782, -0.236782, 0.362594, 0.885651, 0.79422, -0.225923, 0.33711, 0.943756, 0.824521, -0.213855, 0.308272, 1.00874, 0.854964, -0.197723, 0.278529, 1.06764, 0.878065, -0.179209, 0.246208, 1.12836, 0.899834, -0.157569, 0.21329, 1.18318, 0.918815, -0.133206, 0.181038, 1.23161, 0.934934, -0.106545, 0.146993, 1.27644, 0.952115, -0.0780574, 0.111175, 1.31842, 0.96906, -0.0478279, 0.0728553, 1.35839, 0.985178, -0.0160014, 0.032579, 1.39697, 1.00039, 0.0173126, -95256e-7, 1.43312, 0.00384146, -124311e-11, 0.0613583, 7.78271e-08, 0.00390023, -314043e-10, 0.0622919, 1.96626e-06, 0.00389971, -125622e-9, 0.0622632, 7.87379e-06, 0.00389491, -282352e-9, 0.0620659, 1.778e-05, 0.00391618, -502512e-9, 0.0624687, 3.20918e-05, 0.00392662, -784458e-9, 0.0625113, 5.15573e-05, 0.00396053, -112907e-8, 0.0628175, 7.78668e-05, 0.00401911, -153821e-8, 0.0633286, 0.000113811, 0.00414994, -20208e-7, 0.0646443, 0.00016445, 0.00441223, -260007e-8, 0.0673886, 0.000237734, 0.00484427, -33097e-7, 0.0716528, 0.000345929, 0.00549109, -418966e-8, 0.0774998, 0.000505987, 0.00636293, -527331e-8, 0.0844758, 0.000739208, 0.00746566, -660428e-8, 0.0921325, 0.00107347, 0.00876625, -818826e-8, 0.0997067, 0.00153691, 0.0103125, -0.0100811, 0.107433, 0.00217153, 0.0123309, -0.0123643, 0.117088, 0.00303427, 0.0146274, -0.0150007, 0.126438, 0.00416018, 0.0172295, -0.0180531, 0.135672, 0.00561513, 0.0204248, -0.0215962, 0.146244, 0.007478, 0.0241597, -0.0256234, 0.157481, 0.00981046, 0.0284693, -0.0302209, 0.169125, 0.0127148, 0.033445, -0.0353333, 0.181659, 0.0162453, 0.0391251, -0.0410845, 0.1944, 0.0205417, 0.0454721, -0.0473451, 0.207082, 0.0256333, 0.0530983, -0.0542858, 0.221656, 0.0317036, 0.0615356, -0.0618384, 0.236036, 0.0388319, 0.0703363, -0.0697631, 0.248398, 0.046974, 0.0810391, -0.0784757, 0.263611, 0.0565246, 0.0920144, -0.0873488, 0.275857, 0.0671724, 0.105584, -0.0973652, 0.292555, 0.0798105, 0.119506, -0.107271, 0.306333, 0.0935945, 0.134434, -0.117608, 0.318888, 0.109106, 0.153399, -0.128938, 0.337552, 0.127074, 0.171258, -0.139944, 0.349955, 0.14643, 0.191059, -0.151288, 0.361545, 0.168, 0.215069, -0.163018, 0.378421, 0.192082, 0.237838, -0.174226, 0.38879, 0.217838, 0.266965, -0.186063, 0.405857, 0.246931, 0.292827, -0.196909, 0.414146, 0.277505, 0.324352, -0.207473, 0.426955, 0.310711, 0.354427, -0.217713, 0.433429, 0.346794, 0.389854, -0.227183, 0.443966, 0.385237, 0.420749, -0.235131, 0.44471, 0.424955, 0.459597, -0.242786, 0.451729, 0.468446, 0.495316, -0.248767, 0.45072, 0.513422, 0.534903, -0.253351, 0.450924, 0.560618, 0.572369, -0.256277, 0.445266, 0.609677, 0.612383, -0.2576, 0.438798, 0.660995, 0.644037, -0.256931, 0.421693, 0.713807, 0.686749, -0.254036, 0.4109, 0.767616, 0.719814, -0.249785, 0.390151, 0.82533, 0.754719, -0.244283, 0.367847, 0.888311, 0.792022, -0.235076, 0.345013, 0.948177, 0.822404, -0.225061, 0.316193, 1.01661, 0.853084, -0.211113, 0.287013, 1.08075, 0.879871, -0.19449, 0.255424, 1.14501, 0.901655, -0.174023, 0.222879, 1.20203, 0.919957, -0.1509, 0.18989, 1.25698, 0.938412, -0.124923, 0.15606, 1.30588, 0.953471, -0.0968139, 0.120512, 1.3529, 0.970451, -0.066734, 0.0828515, 1.3986, 0.985522, -0.034734, 0.0424458, 1.44148, 1.00099, -102222e-8, 0.000678929, 1.48398, 0.000965494, -6.27338e-7, 0.0306409, 1.97672e-08, 0.00099168, -158573e-10, 0.0314638, 4.99803e-07, 0.000991068, -634012e-10, 0.031363, 2.00682e-06, 0.000974567, -14144e-8, 0.03036, 4.57312e-06, 0.000998079, -252812e-9, 0.031496, 8.60131e-06, 0.00102243, -396506e-9, 0.0319955, 1.48288e-05, 0.00107877, -577593e-9, 0.0331376, 2.49141e-05, 0.00121622, -816816e-9, 0.0359396, 4.23011e-05, 0.0014455, -113761e-8, 0.0399652, 7.24613e-05, 0.00178791, -156959e-8, 0.0450556, 0.000123929, 0.00225668, -214064e-8, 0.0508025, 0.000208531, 0.00285627, -287655e-8, 0.0568443, 0.000341969, 0.0035991, -380271e-8, 0.0630892, 0.000544158, 0.00455524, -496264e-8, 0.0702204, 0.000842423, 0.00569143, -63793e-7, 0.0773426, 0.00126704, 0.00716928, -813531e-8, 0.0860839, 0.00186642, 0.00885307, -0.0101946, 0.0944079, 0.00267014, 0.0109316, -0.0126386, 0.103951, 0.00374033, 0.0133704, -0.0154876, 0.113786, 0.0051304, 0.0161525, -0.0187317, 0.123477, 0.00688858, 0.0194267, -0.0224652, 0.133986, 0.00910557, 0.0230967, -0.0265976, 0.143979, 0.0118074, 0.0273627, -0.0312848, 0.154645, 0.0151266, 0.0323898, -0.0365949, 0.166765, 0.0191791, 0.0379225, -0.0422914, 0.177932, 0.0239236, 0.0447501, -0.0487469, 0.19167, 0.0296568, 0.0519391, -0.0556398, 0.203224, 0.0362924, 0.0599464, -0.0631646, 0.215652, 0.0440585, 0.0702427, -0.0714308, 0.232089, 0.0531619, 0.0806902, -0.0800605, 0.245258, 0.0634564, 0.0923194, -0.0892815, 0.258609, 0.0752481, 0.106938, -0.09931, 0.276654, 0.0888914, 0.121238, -0.109575, 0.289847, 0.104055, 0.138817, -0.120461, 0.307566, 0.121266, 0.15595, -0.131209, 0.320117, 0.139944, 0.178418, -0.143049, 0.339677, 0.161591, 0.197875, -0.154074, 0.349886, 0.184303, 0.224368, -0.166307, 0.369352, 0.210669, 0.252213, -0.178051, 0.386242, 0.238895, 0.277321, -0.189335, 0.395294, 0.269182, 0.310332, -0.200683, 0.412148, 0.302508, 0.338809, -0.210856, 0.418266, 0.337264, 0.372678, -0.220655, 0.428723, 0.374881, 0.405632, -0.230053, 0.433887, 0.415656, 0.442293, -0.237993, 0.439911, 0.457982, 0.477256, -0.244897, 0.440175, 0.502831, 0.515592, -0.250657, 0.441079, 0.550277, 0.550969, -0.255459, 0.435219, 0.601102, 0.592883, -0.257696, 0.432882, 0.651785, 0.629092, -0.259894, 0.421054, 0.708961, 0.672033, -0.258592, 0.41177, 0.763806, 0.709147, -0.256525, 0.395267, 0.824249, 0.745367, -0.254677, 0.375013, 0.8951, 0.784715, -0.247892, 0.353906, 0.959317, 0.818107, -0.240162, 0.327801, 1.03153, 0.847895, -0.229741, 0.298821, 1.10601, 0.879603, -0.213084, 0.269115, 1.164, 0.902605, -0.195242, 0.236606, 1.22854, 0.922788, -0.174505, 0.203442, 1.29017, 0.944831, -0.150169, 0.169594, 1.34157, 0.959656, -0.124099, 0.135909, 1.3956, 0.972399, -0.0960626, 0.0990563, 1.45128, 0.986549, -0.0657097, 0.0602348, 1.50312, 1.00013, -0.0333558, 0.0186694, 1.55364, 6.19747e-06, -1e-7, 0.00778326, 7.96756e-11, 2.37499e-08, -9.99999e-8, 2.82592e-05, 1.14596e-10, 1.00292e-06, -166369e-11, 0.000250354, 6.77492e-09, 3.50752e-06, -637769e-11, 0.000357289, 6.31655e-08, 8.26445e-06, -174689e-10, 0.000516179, 3.1851e-07, 2.42481e-05, -450868e-10, 0.0010223, 1.30577e-06, 4.55631e-05, -89044e-9, 0.00144302, 3.74587e-06, 9.71222e-05, -178311e-9, 0.00241912, 1.02584e-05, 0.000171403, -313976e-9, 0.00354938, 2.36481e-05, 0.000292747, -520026e-9, 0.00513765, 4.96014e-05, 0.000789827, -118187e-8, 0.0238621, 0.000139056, 0.00114093, -171827e-8, 0.0286691, 0.000244093, 0.00176119, -249667e-8, 0.0368565, 0.000420623, 0.0022233, -333742e-8, 0.0400469, 0.00065673, 0.00343382, -481976e-8, 0.0535751, 0.00109323, 0.00427602, -600755e-8, 0.057099, 0.00155268, 0.00461435, -737637e-8, 0.0551084, 0.00215031, 0.00695698, -971401e-8, 0.0715767, 0.00316529, 0.00867619, -0.0120943, 0.0793314, 0.00436995, 0.0106694, -0.0148202, 0.0869391, 0.0058959, 0.0140351, -0.0183501, 0.101572, 0.00798757, 0.0168939, -0.022006, 0.11018, 0.0104233, 0.020197, -0.0261568, 0.119041, 0.0134167, 0.0254702, -0.0312778, 0.135404, 0.0173009, 0.0298384, -0.0362469, 0.1437, 0.0215428, 0.035159, -0.042237, 0.15512, 0.0268882, 0.0427685, -0.0488711, 0.17128, 0.033235, 0.0494848, -0.0557997, 0.181813, 0.0404443, 0.0592394, -0.0635578, 0.198745, 0.0490043, 0.0681463, -0.071838, 0.210497, 0.0588239, 0.0804753, -0.0809297, 0.228864, 0.0702835, 0.0942205, -0.0906488, 0.247008, 0.0834012, 0.106777, -0.100216, 0.258812, 0.0975952, 0.124471, -0.110827, 0.278617, 0.114162, 0.138389, -0.121193, 0.287049, 0.131983, 0.159543, -0.13253, 0.307151, 0.152541, 0.176432, -0.143611, 0.31564, 0.174673, 0.201723, -0.15548, 0.33538, 0.199842, 0.229721, -0.167166, 0.355256, 0.227097, 0.250206, -0.178238, 0.360047, 0.256014, 0.282118, -0.189905, 0.378761, 0.28855, 0.312821, -0.201033, 0.39181, 0.323348, 0.341482, -0.211584, 0.397716, 0.360564, 0.377368, -0.221314, 0.410141, 0.400004, 0.418229, -0.230474, 0.423485, 0.442371, 0.444881, -0.239443, 0.418874, 0.488796, 0.488899, -0.245987, 0.427545, 0.535012, 0.520317, -0.253948, 0.422147, 0.589678, 0.568566, -0.256616, 0.42719, 0.637683, 0.599607, -0.26376, 0.415114, 0.703363, 0.64222, -0.268687, 0.408715, 0.771363, 0.685698, -0.2694, 0.399722, 0.83574, 0.732327, -0.266642, 0.388651, 0.897764, 0.769873, -0.267712, 0.369198, 0.983312, 0.806733, -0.263479, 0.346802, 1.06222, 0.843466, -0.254575, 0.321368, 1.13477, 0.873008, -0.242749, 0.29211, 1.20712, 0.908438, -0.22725, 0.262143, 1.27465, 0.936321, -0.207621, 0.228876, 1.33203, 0.950353, -0.187932, 0.19484, 1.40439, 0.96442, -0.165154, 0.163178, 1.4732, 0.979856, -0.139302, 0.127531, 1.53574, 0.982561, -0.11134, 0.0903457, 1.59982, 0.996389, -0.0808124, 0.0489007, 1.6577 ];

		const LTC_MAT_2 = [ 1, 0, 0, 0, 1, 7.91421e-31, 0, 0, 1, 1.04392e-24, 0, 0, 1, 3.49405e-21, 0, 0, 1, 1.09923e-18, 0, 0, 1, 9.47414e-17, 0, 0, 1, 3.59627e-15, 0, 0, 1, 7.72053e-14, 0, 0, 1, 1.08799e-12, 0, 0, 1, 1.10655e-11, 0, 0, 1, 8.65818e-11, 0, 0, 0.999998, 5.45037e-10, 0, 0, 0.999994, 2.85095e-09, 0, 0, 0.999989, 1.26931e-08, 0, 0, 0.999973, 4.89938e-08, 0, 0, 0.999947, 1.66347e-07, 0, 0, 0.999894, 5.02694e-07, 0, 0, 0.999798, 1.36532e-06, 0, 0, 0.999617, 3.35898e-06, 0, 0, 0.999234, 7.52126e-06, 0, 0, 0.998258, 1.52586e-05, 0, 0, 0.99504, 2.66207e-05, 0, 0, 0.980816, 2.36802e-05, 0, 0, 0.967553, 2.07684e-06, 0, 0, 0.966877, 4.03733e-06, 0, 0, 0.965752, 7.41174e-06, 0, 0, 0.96382, 1.27746e-05, 0, 0, 0.960306, 2.02792e-05, 0, 0, 0.953619, 2.80232e-05, 0, 0, 0.941103, 2.78816e-05, 0, 0, 0.926619, 1.60221e-05, 0, 0, 0.920983, 2.35164e-05, 0, 0, 0.912293, 3.11924e-05, 0, 0.0158731, 0.899277, 3.48118e-05, 0, 0.0476191, 0.880884, 2.6041e-05, 0, 0.0793651, 0.870399, 3.38726e-05, 0, 0.111111, 0.856138, 3.92906e-05, 0, 0.142857, 0.837436, 3.72874e-05, 0, 0.174603, 0.820973, 3.92558e-05, 0, 0.206349, 0.803583, 4.34658e-05, 0, 0.238095, 0.782168, 4.0256e-05, 0, 0.269841, 0.764107, 4.48159e-05, 0, 0.301587, 0.743092, 4.57627e-05, 0, 0.333333, 0.721626, 4.55314e-05, 0, 0.365079, 0.700375, 4.77335e-05, 0, 0.396825, 0.677334, 4.61072e-05, 0, 0.428571, 0.655702, 4.84393e-05, 0, 0.460317, 0.632059, 4.64583e-05, 0, 0.492064, 0.610125, 4.83923e-05, 0, 0.52381, 0.58653, 4.64342e-05, 0, 0.555556, 0.564508, 4.77033e-05, 0, 0.587302, 0.541405, 4.59263e-05, 0, 0.619048, 0.519556, 4.6412e-05, 0, 0.650794, 0.497292, 4.48913e-05, 0, 0.68254, 0.475898, 4.45789e-05, 0, 0.714286, 0.454722, 4.33496e-05, 0, 0.746032, 0.434042, 4.23054e-05, 0, 0.777778, 0.414126, 4.13737e-05, 0, 0.809524, 0.394387, 3.97265e-05, 0, 0.84127, 0.375841, 3.90709e-05, 0, 0.873016, 0.357219, 3.69938e-05, 0, 0.904762, 0.340084, 3.65618e-05, 0, 0.936508, 0.322714, 3.42533e-05, 0, 0.968254, 0.306974, 3.39596e-05, 0, 1, 1, 1.01524e-18, 0, 0, 1, 1.0292e-18, 0, 0, 1, 1.30908e-18, 0, 0, 1, 4.73331e-18, 0, 0, 1, 6.25319e-17, 0, 0, 1, 1.07932e-15, 0, 0, 1, 1.63779e-14, 0, 0, 1, 2.03198e-13, 0, 0, 1, 2.04717e-12, 0, 0, 0.999999, 1.68995e-11, 0, 0, 0.999998, 1.15855e-10, 0, 0, 0.999996, 6.6947e-10, 0, 0, 0.999991, 3.30863e-09, 0, 0, 0.999983, 1.41737e-08, 0, 0, 0.999968, 5.32626e-08, 0, 0, 0.99994, 1.77431e-07, 0, 0, 0.999891, 5.28835e-07, 0, 0, 0.999797, 1.42169e-06, 0, 0, 0.999617, 3.47057e-06, 0, 0, 0.999227, 7.7231e-06, 0, 0, 0.998239, 1.55753e-05, 0, 0, 0.994937, 2.68495e-05, 0, 0, 0.980225, 2.13742e-05, 0, 0, 0.967549, 2.1631e-06, 0, 0, 0.966865, 4.17989e-06, 0, 0, 0.965739, 7.63341e-06, 0, 0, 0.963794, 1.30892e-05, 0, 0, 0.960244, 2.06456e-05, 0, 0, 0.953495, 2.82016e-05, 0, 0.000148105, 0.940876, 2.71581e-05, 0, 0.002454, 0.926569, 1.64159e-05, 0, 0.00867491, 0.920905, 2.39521e-05, 0, 0.01956, 0.912169, 3.15127e-05, 0, 0.035433, 0.899095, 3.46626e-05, 0, 0.056294, 0.882209, 2.90223e-05, 0, 0.0818191, 0.870272, 3.42992e-05, 0, 0.111259, 0.855977, 3.94164e-05, 0, 0.142857, 0.837431, 3.72343e-05, 0, 0.174603, 0.820826, 3.96691e-05, 0, 0.206349, 0.803408, 4.35395e-05, 0, 0.238095, 0.782838, 4.19579e-05, 0, 0.269841, 0.763941, 4.50953e-05, 0, 0.301587, 0.742904, 4.55847e-05, 0, 0.333333, 0.721463, 4.58833e-05, 0, 0.365079, 0.700197, 4.77159e-05, 0, 0.396825, 0.677501, 4.70641e-05, 0, 0.428571, 0.655527, 4.84732e-05, 0, 0.460317, 0.6324, 4.76834e-05, 0, 0.492064, 0.609964, 4.84213e-05, 0, 0.52381, 0.586839, 4.75541e-05, 0, 0.555556, 0.564353, 4.76951e-05, 0, 0.587302, 0.541589, 4.67611e-05, 0, 0.619048, 0.519413, 4.63493e-05, 0, 0.650794, 0.497337, 4.53994e-05, 0, 0.68254, 0.475797, 4.45308e-05, 0, 0.714286, 0.454659, 4.35787e-05, 0, 0.746032, 0.434065, 4.24839e-05, 0, 0.777778, 0.414018, 4.1436e-05, 0, 0.809524, 0.39455, 4.01902e-05, 0, 0.84127, 0.375742, 3.90813e-05, 0, 0.873016, 0.357501, 3.77116e-05, 0, 0.904762, 0.339996, 3.6535e-05, 0, 0.936508, 0.323069, 3.51265e-05, 0, 0.968254, 0.306897, 3.39112e-05, 0, 1, 1, 1.0396e-15, 0, 0, 1, 1.04326e-15, 0, 0, 1, 1.10153e-15, 0, 0, 1, 1.44668e-15, 0, 0, 1, 3.4528e-15, 0, 0, 1, 1.75958e-14, 0, 0, 1, 1.2627e-13, 0, 0, 1, 9.36074e-13, 0, 0, 1, 6.45742e-12, 0, 0, 0.999998, 4.01228e-11, 0, 0, 0.999997, 2.22338e-10, 0, 0, 0.999995, 1.0967e-09, 0, 0, 0.999991, 4.82132e-09, 0, 0, 0.999981, 1.89434e-08, 0, 0, 0.999967, 6.67716e-08, 0, 0, 0.999938, 2.12066e-07, 0, 0, 0.999886, 6.0977e-07, 0, 0, 0.999792, 1.59504e-06, 0, 0, 0.999608, 3.81191e-06, 0, 0, 0.999209, 8.33727e-06, 0, 0, 0.998179, 1.65288e-05, 0, 0, 0.994605, 2.74387e-05, 0, 0, 0.979468, 1.67316e-05, 0, 0, 0.967529, 2.42877e-06, 0, 0, 0.966836, 4.61696e-06, 0, 0, 0.96569, 8.30977e-06, 0, 0, 0.963706, 1.40427e-05, 0, 2.44659e-06, 0.960063, 2.17353e-05, 0, 0.000760774, 0.953113, 2.86606e-05, 0, 0.00367261, 0.940192, 2.47691e-05, 0, 0.00940263, 0.927731, 1.95814e-05, 0, 0.018333, 0.920669, 2.52531e-05, 0, 0.0306825, 0.911799, 3.24277e-05, 0, 0.0465556, 0.89857, 3.40982e-05, 0, 0.0659521, 0.883283, 3.19622e-05, 0, 0.0887677, 0.86989, 3.5548e-05, 0, 0.114784, 0.855483, 3.97143e-05, 0, 0.143618, 0.837987, 3.91665e-05, 0, 0.174606, 0.820546, 4.11306e-05, 0, 0.206349, 0.802878, 4.36753e-05, 0, 0.238095, 0.783402, 4.44e-05, 0, 0.269841, 0.763439, 4.58726e-05, 0, 0.301587, 0.742925, 4.67097e-05, 0, 0.333333, 0.721633, 4.78887e-05, 0, 0.365079, 0.69985, 4.81251e-05, 0, 0.396825, 0.67783, 4.91811e-05, 0, 0.428571, 0.655126, 4.88199e-05, 0, 0.460318, 0.632697, 4.96025e-05, 0, 0.492064, 0.609613, 4.8829e-05, 0, 0.52381, 0.587098, 4.92754e-05, 0, 0.555556, 0.564119, 4.82625e-05, 0, 0.587302, 0.541813, 4.82807e-05, 0, 0.619048, 0.519342, 4.71552e-05, 0, 0.650794, 0.497514, 4.66765e-05, 0, 0.68254, 0.475879, 4.55582e-05, 0, 0.714286, 0.454789, 4.46007e-05, 0, 0.746032, 0.434217, 4.35382e-05, 0, 0.777778, 0.414086, 4.21753e-05, 0, 0.809524, 0.394744, 4.12093e-05, 0, 0.84127, 0.375782, 3.96634e-05, 0, 0.873016, 0.357707, 3.86419e-05, 0, 0.904762, 0.340038, 3.70345e-05, 0, 0.936508, 0.323284, 3.59725e-05, 0, 0.968254, 0.306954, 3.436e-05, 0, 1, 1, 5.99567e-14, 0, 0, 1, 6.00497e-14, 0, 0, 1, 6.14839e-14, 0, 0, 1, 6.86641e-14, 0, 0, 1, 9.72658e-14, 0, 0, 1, 2.21271e-13, 0, 0, 1, 8.33195e-13, 0, 0, 1, 4.03601e-12, 0, 0, 0.999999, 2.06001e-11, 0, 0, 0.999998, 1.01739e-10, 0, 0, 0.999997, 4.70132e-10, 0, 0, 0.999993, 2.00436e-09, 0, 0, 0.999988, 7.83682e-09, 0, 0, 0.999979, 2.80338e-08, 0, 0, 0.999962, 9.17033e-08, 0, 0, 0.999933, 2.74514e-07, 0, 0, 0.999881, 7.53201e-07, 0, 0, 0.999783, 1.89826e-06, 0, 0, 0.999594, 4.40279e-06, 0, 0, 0.999178, 9.3898e-06, 0, 0, 0.998073, 1.81265e-05, 0, 0, 0.993993, 2.80487e-05, 0, 0, 0.979982, 1.49422e-05, 0, 0, 0.968145, 3.78481e-06, 0, 0, 0.966786, 5.3771e-06, 0, 0, 0.965611, 9.47508e-06, 0, 3.88934e-05, 0.963557, 1.56616e-05, 0, 0.0009693, 0.959752, 2.35144e-05, 0, 0.00370329, 0.952461, 2.91568e-05, 0, 0.00868428, 0.940193, 2.40102e-05, 0, 0.0161889, 0.929042, 2.31235e-05, 0, 0.0263948, 0.920266, 2.73968e-05, 0, 0.0394088, 0.911178, 3.37915e-05, 0, 0.0552818, 0.897873, 3.33629e-05, 0, 0.0740138, 0.884053, 3.51405e-05, 0, 0.0955539, 0.869455, 3.78034e-05, 0, 0.119795, 0.854655, 3.99378e-05, 0, 0.14656, 0.838347, 4.19108e-05, 0, 0.175573, 0.820693, 4.40831e-05, 0, 0.206388, 0.802277, 4.45599e-05, 0, 0.238095, 0.783634, 4.72691e-05, 0, 0.269841, 0.763159, 4.76984e-05, 0, 0.301587, 0.742914, 4.91487e-05, 0, 0.333333, 0.721662, 5.02312e-05, 0, 0.365079, 0.699668, 5.02817e-05, 0, 0.396825, 0.677839, 5.1406e-05, 0, 0.428571, 0.655091, 5.11095e-05, 0, 0.460317, 0.632665, 5.16067e-05, 0, 0.492064, 0.609734, 5.12255e-05, 0, 0.52381, 0.587043, 5.10263e-05, 0, 0.555556, 0.564298, 5.0565e-05, 0, 0.587302, 0.541769, 4.97951e-05, 0, 0.619048, 0.519529, 4.92698e-05, 0, 0.650794, 0.497574, 4.82066e-05, 0, 0.68254, 0.476028, 4.73689e-05, 0, 0.714286, 0.454961, 4.61941e-05, 0, 0.746032, 0.434341, 4.50618e-05, 0, 0.777778, 0.414364, 4.38355e-05, 0, 0.809524, 0.394832, 4.24196e-05, 0, 0.84127, 0.376109, 4.12563e-05, 0, 0.873016, 0.35779, 3.96226e-05, 0, 0.904762, 0.340379, 3.84886e-05, 0, 0.936508, 0.323385, 3.68214e-05, 0, 0.968254, 0.307295, 3.56636e-05, 0, 1, 1, 1.06465e-12, 0, 0, 1, 1.06555e-12, 0, 0, 1, 1.07966e-12, 0, 0, 1, 1.14601e-12, 0, 0, 1, 1.37123e-12, 0, 0, 1, 2.1243e-12, 0, 0, 0.999999, 4.89653e-12, 0, 0, 0.999999, 1.60283e-11, 0, 0, 0.999998, 6.2269e-11, 0, 0, 0.999997, 2.51859e-10, 0, 0, 0.999996, 9.96192e-10, 0, 0, 0.999992, 3.74531e-09, 0, 0, 0.999986, 1.32022e-08, 0, 0, 0.999975, 4.33315e-08, 0, 0, 0.999959, 1.31956e-07, 0, 0, 0.999927, 3.72249e-07, 0, 0, 0.999871, 9.72461e-07, 0, 0, 0.999771, 2.35343e-06, 0, 0, 0.999572, 5.2768e-06, 0, 0, 0.999133, 1.09237e-05, 0, 0, 0.997912, 2.03675e-05, 0, 0, 0.993008, 2.79396e-05, 0, 0, 0.980645, 1.39604e-05, 0, 0, 0.970057, 6.46596e-06, 0, 0, 0.966717, 6.5089e-06, 0, 4.74145e-05, 0.965497, 1.11863e-05, 0, 0.00089544, 0.96334, 1.79857e-05, 0, 0.0032647, 0.959294, 2.59045e-05, 0, 0.0075144, 0.951519, 2.92327e-05, 0, 0.0138734, 0.940517, 2.49769e-05, 0, 0.0224952, 0.93014, 2.6803e-05, 0, 0.0334828, 0.91972, 3.03656e-05, 0, 0.0468973, 0.910294, 3.53323e-05, 0, 0.0627703, 0.897701, 3.51002e-05, 0, 0.0811019, 0.884522, 3.88104e-05, 0, 0.10186, 0.869489, 4.12932e-05, 0, 0.124985, 0.853983, 4.15781e-05, 0, 0.150372, 0.838425, 4.54066e-05, 0, 0.177868, 0.820656, 4.71624e-05, 0, 0.207245, 0.801875, 4.75243e-05, 0, 0.238143, 0.783521, 5.05621e-05, 0, 0.269841, 0.763131, 5.0721e-05, 0, 0.301587, 0.74261, 5.23293e-05, 0, 0.333333, 0.72148, 5.28699e-05, 0, 0.365079, 0.699696, 5.38677e-05, 0, 0.396825, 0.677592, 5.39255e-05, 0, 0.428571, 0.65525, 5.46367e-05, 0, 0.460317, 0.632452, 5.41348e-05, 0, 0.492064, 0.609903, 5.44976e-05, 0, 0.52381, 0.586928, 5.36201e-05, 0, 0.555556, 0.564464, 5.35185e-05, 0, 0.587302, 0.541801, 5.24949e-05, 0, 0.619048, 0.519681, 5.1812e-05, 0, 0.650794, 0.497685, 5.07687e-05, 0, 0.68254, 0.47622, 4.96243e-05, 0, 0.714286, 0.455135, 4.85714e-05, 0, 0.746032, 0.4346, 4.71847e-05, 0, 0.777778, 0.414564, 4.59294e-05, 0, 0.809524, 0.395165, 4.44705e-05, 0, 0.84127, 0.376333, 4.30772e-05, 0, 0.873016, 0.358197, 4.16229e-05, 0, 0.904762, 0.34064, 4.01019e-05, 0, 0.936508, 0.323816, 3.86623e-05, 0, 0.968254, 0.307581, 3.70933e-05, 0, 1, 1, 9.91541e-12, 0, 0, 1, 9.92077e-12, 0, 0, 1, 1.00041e-11, 0, 0, 1, 1.0385e-11, 0, 0, 1, 1.15777e-11, 0, 0, 1, 1.50215e-11, 0, 0, 0.999999, 2.54738e-11, 0, 0, 0.999999, 5.98822e-11, 0, 0, 0.999998, 1.79597e-10, 0, 0, 0.999997, 6.02367e-10, 0, 0, 0.999994, 2.06835e-09, 0, 0, 0.99999, 6.94952e-09, 0, 0, 0.999984, 2.23363e-08, 0, 0, 0.999972, 6.78578e-08, 0, 0, 0.999952, 1.93571e-07, 0, 0, 0.999919, 5.16594e-07, 0, 0, 0.99986, 1.28739e-06, 0, 0, 0.999753, 2.99298e-06, 0, 0, 0.999546, 6.48258e-06, 0, 0, 0.999074, 1.29985e-05, 0, 0, 0.997671, 2.32176e-05, 0, 0, 0.991504, 2.56701e-05, 0, 0, 0.981148, 1.31141e-05, 0, 0, 0.971965, 8.69048e-06, 0, 2.80182e-05, 0.966624, 8.08301e-06, 0, 0.000695475, 0.965344, 1.35235e-05, 0, 0.00265522, 0.963048, 2.10592e-05, 0, 0.00622975, 0.958673, 2.87473e-05, 0, 0.0116234, 0.950262, 2.81379e-05, 0, 0.018976, 0.940836, 2.71089e-05, 0, 0.0283844, 0.930996, 3.0926e-05, 0, 0.0399151, 0.919848, 3.48359e-05, 0, 0.0536063, 0.909136, 3.66092e-05, 0, 0.0694793, 0.897554, 3.84162e-05, 0, 0.0875342, 0.884691, 4.30971e-05, 0, 0.107749, 0.869414, 4.47803e-05, 0, 0.130087, 0.853462, 4.52858e-05, 0, 0.154481, 0.838187, 4.95769e-05, 0, 0.180833, 0.820381, 5.02709e-05, 0, 0.209005, 0.801844, 5.22713e-05, 0, 0.238791, 0.783061, 5.41505e-05, 0, 0.269869, 0.763205, 5.53712e-05, 0, 0.301587, 0.742362, 5.64909e-05, 0, 0.333333, 0.721393, 5.72646e-05, 0, 0.365079, 0.699676, 5.81012e-05, 0, 0.396825, 0.677395, 5.8096e-05, 0, 0.428571, 0.655208, 5.85766e-05, 0, 0.460317, 0.632451, 5.83602e-05, 0, 0.492064, 0.609839, 5.80234e-05, 0, 0.52381, 0.587093, 5.77161e-05, 0, 0.555556, 0.564467, 5.68447e-05, 0, 0.587302, 0.542043, 5.63166e-05, 0, 0.619048, 0.519826, 5.5156e-05, 0, 0.650794, 0.497952, 5.41682e-05, 0, 0.68254, 0.476477, 5.28971e-05, 0, 0.714286, 0.455412, 5.14952e-05, 0, 0.746032, 0.434926, 5.02222e-05, 0, 0.777778, 0.4149, 4.85779e-05, 0, 0.809524, 0.395552, 4.72242e-05, 0, 0.84127, 0.376712, 4.54891e-05, 0, 0.873016, 0.358622, 4.40924e-05, 0, 0.904762, 0.341048, 4.22984e-05, 0, 0.936508, 0.324262, 4.08582e-05, 0, 0.968254, 0.308013, 3.90839e-05, 0, 1, 1, 6.13913e-11, 0, 0, 1, 6.14145e-11, 0, 0, 1, 6.17708e-11, 0, 0, 1, 6.33717e-11, 0, 0, 1, 6.81648e-11, 0, 0, 1, 8.08291e-11, 0, 0, 1, 1.14608e-10, 0, 0, 0.999998, 2.10507e-10, 0, 0, 0.999997, 4.99595e-10, 0, 0, 0.999995, 1.39897e-09, 0, 0, 0.999994, 4.19818e-09, 0, 0, 0.999988, 1.27042e-08, 0, 0, 0.999979, 3.75153e-08, 0, 0, 0.999965, 1.06206e-07, 0, 0, 0.999945, 2.85381e-07, 0, 0, 0.999908, 7.23611e-07, 0, 0, 0.999846, 1.7255e-06, 0, 0, 0.999733, 3.86104e-06, 0, 0, 0.999511, 8.08493e-06, 0, 0, 0.998993, 1.56884e-05, 0, 0, 0.997326, 2.65538e-05, 0, 0, 0.989706, 2.06466e-05, 0, 0, 0.981713, 1.30756e-05, 0, 7.0005e-06, 0.973636, 1.06473e-05, 0, 0.000464797, 0.966509, 1.0194e-05, 0, 0.00201743, 0.965149, 1.65881e-05, 0, 0.00497549, 0.962669, 2.49147e-05, 0, 0.00953262, 0.95786, 3.17449e-05, 0, 0.0158211, 0.949334, 2.81045e-05, 0, 0.0239343, 0.941041, 3.03263e-05, 0, 0.0339372, 0.931575, 3.56754e-05, 0, 0.0458738, 0.920102, 3.97075e-05, 0, 0.059772, 0.908002, 3.84886e-05, 0, 0.075645, 0.897269, 4.3027e-05, 0, 0.0934929, 0.884559, 4.79925e-05, 0, 0.113302, 0.869161, 4.8246e-05, 0, 0.135045, 0.853342, 5.09505e-05, 0, 0.158678, 0.837633, 5.42846e-05, 0, 0.184136, 0.820252, 5.54139e-05, 0, 0.211325, 0.801872, 5.81412e-05, 0, 0.240113, 0.782418, 5.85535e-05, 0, 0.270306, 0.7631, 6.10923e-05, 0, 0.301594, 0.742183, 6.13678e-05, 0, 0.333333, 0.721098, 6.27275e-05, 0, 0.365079, 0.699512, 6.29413e-05, 0, 0.396825, 0.677372, 6.36351e-05, 0, 0.428571, 0.655059, 6.33555e-05, 0, 0.460317, 0.632567, 6.36513e-05, 0, 0.492064, 0.609784, 6.28965e-05, 0, 0.52381, 0.587237, 6.25546e-05, 0, 0.555556, 0.564525, 6.15825e-05, 0, 0.587302, 0.542181, 6.05048e-05, 0, 0.619048, 0.520017, 5.96329e-05, 0, 0.650794, 0.498204, 5.81516e-05, 0, 0.68254, 0.476742, 5.69186e-05, 0, 0.714286, 0.455803, 5.53833e-05, 0, 0.746032, 0.435251, 5.37807e-05, 0, 0.777778, 0.415374, 5.22025e-05, 0, 0.809524, 0.395921, 5.03421e-05, 0, 0.84127, 0.377253, 4.88211e-05, 0, 0.873016, 0.359021, 4.68234e-05, 0, 0.904762, 0.341637, 4.53269e-05, 0, 0.936508, 0.3247, 4.33014e-05, 0, 0.968254, 0.308625, 4.18007e-05, 0, 1, 1, 2.86798e-10, 0, 0, 1, 2.86877e-10, 0, 0, 1, 2.88094e-10, 0, 0, 1, 2.93506e-10, 0, 0, 1, 3.09262e-10, 0, 0, 0.999999, 3.48593e-10, 0, 0, 0.999999, 4.44582e-10, 0, 0, 0.999998, 6.88591e-10, 0, 0, 0.999996, 1.34391e-09, 0, 0, 0.999993, 3.17438e-09, 0, 0, 0.999989, 8.35609e-09, 0, 0, 0.999983, 2.28677e-08, 0, 0, 0.999974, 6.23361e-08, 0, 0, 0.999959, 1.65225e-07, 0, 0, 0.999936, 4.19983e-07, 0, 0, 0.999896, 1.01546e-06, 0, 0, 0.99983, 2.32376e-06, 0, 0, 0.999709, 5.0156e-06, 0, 0, 0.999469, 1.0167e-05, 0, 0, 0.998886, 1.90775e-05, 0, 0, 0.996819, 3.00511e-05, 0, 0, 0.988837, 1.85092e-05, 0, 1.68222e-07, 0.982178, 1.34622e-05, 0, 0.000259622, 0.975017, 1.25961e-05, 0, 0.00142595, 0.967101, 1.3507e-05, 0, 0.00382273, 0.964905, 2.05003e-05, 0, 0.00764164, 0.96218, 2.9546e-05, 0, 0.0130121, 0.956821, 3.43738e-05, 0, 0.0200253, 0.948829, 3.05063e-05, 0, 0.0287452, 0.941092, 3.46487e-05, 0, 0.039218, 0.931883, 4.12061e-05, 0, 0.0514748, 0.920211, 4.44651e-05, 0, 0.0655351, 0.907307, 4.31252e-05, 0, 0.0814082, 0.89684, 4.90382e-05, 0, 0.0990939, 0.884119, 5.3334e-05, 0, 0.118583, 0.869148, 5.4114e-05, 0, 0.139856, 0.853377, 5.78536e-05, 0, 0.162882, 0.836753, 5.92285e-05, 0, 0.187615, 0.820063, 6.22787e-05, 0, 0.213991, 0.801694, 6.45492e-05, 0, 0.241918, 0.782116, 6.5353e-05, 0, 0.271267, 0.762673, 6.74344e-05, 0, 0.301847, 0.742133, 6.82788e-05, 0, 0.333333, 0.720779, 6.91959e-05, 0, 0.365079, 0.699386, 6.96817e-05, 0, 0.396826, 0.67732, 6.99583e-05, 0, 0.428572, 0.654888, 6.98447e-05, 0, 0.460318, 0.632499, 6.94063e-05, 0, 0.492064, 0.609825, 6.91612e-05, 0, 0.52381, 0.587287, 6.81576e-05, 0, 0.555556, 0.564743, 6.74138e-05, 0, 0.587302, 0.542409, 6.61617e-05, 0, 0.619048, 0.520282, 6.47785e-05, 0, 0.650794, 0.498506, 6.33836e-05, 0, 0.68254, 0.477102, 6.15905e-05, 0, 0.714286, 0.456167, 6.01013e-05, 0, 0.746032, 0.435728, 5.81457e-05, 0, 0.777778, 0.415809, 5.64215e-05, 0, 0.809524, 0.396517, 5.44997e-05, 0, 0.84127, 0.377737, 5.25061e-05, 0, 0.873016, 0.359698, 5.06831e-05, 0, 0.904762, 0.342164, 4.8568e-05, 0, 0.936508, 0.325417, 4.67826e-05, 0, 0.968254, 0.309186, 4.46736e-05, 0, 1, 1, 1.09018e-09, 0, 0, 1, 1.0904e-09, 0, 0, 1, 1.09393e-09, 0, 0, 1, 1.1095e-09, 0, 0, 1, 1.154e-09, 0, 0, 1, 1.26089e-09, 0, 0, 0.999999, 1.5059e-09, 0, 0, 0.999997, 2.07899e-09, 0, 0, 0.999994, 3.48164e-09, 0, 0, 0.999993, 7.05728e-09, 0, 0, 0.999987, 1.63692e-08, 0, 0, 0.999981, 4.06033e-08, 0, 0, 0.999969, 1.0245e-07, 0, 0, 0.999953, 2.55023e-07, 0, 0, 0.999925, 6.1511e-07, 0, 0, 0.999881, 1.42218e-06, 0, 0, 0.99981, 3.13086e-06, 0, 0, 0.99968, 6.53119e-06, 0, 0, 0.999418, 1.2832e-05, 0, 0, 0.998748, 2.32497e-05, 0, 0, 0.996066, 3.29522e-05, 0, 0, 0.988379, 1.79613e-05, 0, 0.000108799, 0.982567, 1.43715e-05, 0, 0.000921302, 0.976097, 1.48096e-05, 0, 0.00280738, 0.968475, 1.78905e-05, 0, 0.00596622, 0.964606, 2.53921e-05, 0, 0.0105284, 0.961564, 3.48623e-05, 0, 0.0165848, 0.955517, 3.57612e-05, 0, 0.0242, 0.948381, 3.43493e-05, 0, 0.03342, 0.941095, 4.05849e-05, 0, 0.0442777, 0.931923, 4.75394e-05, 0, 0.0567958, 0.91996, 4.84328e-05, 0, 0.0709879, 0.907419, 5.02146e-05, 0, 0.086861, 0.89618, 5.61654e-05, 0, 0.104415, 0.88337, 5.87612e-05, 0, 0.123643, 0.869046, 6.18057e-05, 0, 0.144531, 0.853278, 6.57392e-05, 0, 0.167057, 0.836091, 6.6303e-05, 0, 0.191188, 0.819644, 7.04445e-05, 0, 0.216878, 0.801246, 7.14071e-05, 0, 0.244062, 0.782031, 7.40093e-05, 0, 0.272649, 0.762066, 7.4685e-05, 0, 0.302509, 0.741964, 7.66647e-05, 0, 0.333442, 0.720554, 7.66328e-05, 0, 0.365079, 0.699098, 7.77857e-05, 0, 0.396826, 0.677189, 7.74633e-05, 0, 0.428572, 0.65484, 7.76235e-05, 0, 0.460318, 0.632496, 7.70316e-05, 0, 0.492064, 0.609908, 7.62669e-05, 0, 0.52381, 0.587312, 7.53972e-05, 0, 0.555556, 0.564938, 7.39994e-05, 0, 0.587302, 0.542577, 7.28382e-05, 0, 0.619048, 0.52062, 7.1112e-05, 0, 0.650794, 0.498819, 6.94004e-05, 0, 0.68254, 0.477555, 6.75575e-05, 0, 0.714286, 0.456568, 6.53449e-05, 0, 0.746032, 0.436278, 6.36068e-05, 0, 0.777778, 0.41637, 6.13466e-05, 0, 0.809524, 0.397144, 5.94177e-05, 0, 0.84127, 0.378412, 5.70987e-05, 0, 0.873016, 0.360376, 5.50419e-05, 0, 0.904762, 0.342906, 5.27422e-05, 0, 0.936508, 0.326136, 5.06544e-05, 0, 0.968254, 0.30997, 4.84307e-05, 0, 1, 1, 3.54014e-09, 0, 0, 1, 3.54073e-09, 0, 0, 1, 3.54972e-09, 0, 0, 1, 3.58929e-09, 0, 0, 1, 3.70093e-09, 0, 0, 0.999999, 3.96194e-09, 0, 0, 0.999998, 4.53352e-09, 0, 0, 0.999997, 5.78828e-09, 0, 0, 0.999994, 8.63812e-09, 0, 0, 0.999991, 1.53622e-08, 0, 0, 0.999985, 3.16356e-08, 0, 0, 0.999977, 7.12781e-08, 0, 0, 0.999964, 1.66725e-07, 0, 0, 0.999945, 3.90501e-07, 0, 0, 0.999912, 8.95622e-07, 0, 0, 0.999866, 1.98428e-06, 0, 0, 0.999786, 4.21038e-06, 0, 0, 0.999647, 8.50239e-06, 0, 0, 0.999356, 1.62059e-05, 0, 0, 0.998563, 2.82652e-05, 0, 0, 0.994928, 3.36309e-05, 0, 2.44244e-05, 0.987999, 1.78458e-05, 0, 0.000523891, 0.982893, 1.59162e-05, 0, 0.00194729, 0.977044, 1.78056e-05, 0, 0.00451099, 0.969972, 2.30624e-05, 0, 0.00835132, 0.964237, 3.13922e-05, 0, 0.013561, 0.960791, 4.06145e-05, 0, 0.0202056, 0.954292, 3.72796e-05, 0, 0.0283321, 0.948052, 4.03199e-05, 0, 0.0379739, 0.940938, 4.79537e-05, 0, 0.0491551, 0.931689, 5.45292e-05, 0, 0.0618918, 0.91987, 5.4038e-05, 0, 0.0761941, 0.907665, 5.89909e-05, 0, 0.0920672, 0.895281, 6.42651e-05, 0, 0.109511, 0.882621, 6.59707e-05, 0, 0.12852, 0.86873, 7.09973e-05, 0, 0.149085, 0.853008, 7.42221e-05, 0, 0.171189, 0.835944, 7.61754e-05, 0, 0.194809, 0.818949, 7.97052e-05, 0, 0.21991, 0.800951, 8.12434e-05, 0, 0.246447, 0.781847, 8.38075e-05, 0, 0.274352, 0.761649, 8.4501e-05, 0, 0.303535, 0.74152, 8.60258e-05, 0, 0.333857, 0.720495, 8.66233e-05, 0, 0.365104, 0.698742, 8.68326e-05, 0, 0.396826, 0.677096, 8.7133e-05, 0, 0.428572, 0.654782, 8.63497e-05, 0, 0.460318, 0.632335, 8.60206e-05, 0, 0.492064, 0.610031, 8.49337e-05, 0, 0.52381, 0.587457, 8.38279e-05, 0, 0.555556, 0.56513, 8.2309e-05, 0, 0.587302, 0.542877, 8.03542e-05, 0, 0.619048, 0.5209, 7.86928e-05, 0, 0.650794, 0.499291, 7.65171e-05, 0, 0.68254, 0.477971, 7.44753e-05, 0, 0.714286, 0.457221, 7.2209e-05, 0, 0.746032, 0.436803, 6.97448e-05, 0, 0.777778, 0.417083, 6.75333e-05, 0, 0.809524, 0.397749, 6.48058e-05, 0, 0.84127, 0.379177, 6.25759e-05, 0, 0.873016, 0.361061, 5.98584e-05, 0, 0.904762, 0.343713, 5.75797e-05, 0, 0.936508, 0.326894, 5.49999e-05, 0, 0.968254, 0.310816, 5.27482e-05, 0, 1, 1, 1.0153e-08, 0, 0, 1, 1.01544e-08, 0, 0, 1, 1.01751e-08, 0, 0, 1, 1.02662e-08, 0, 0, 1, 1.0521e-08, 0, 0, 0.999999, 1.11049e-08, 0, 0, 0.999999, 1.23408e-08, 0, 0, 0.999996, 1.4924e-08, 0, 0, 0.999992, 2.04471e-08, 0, 0, 0.999989, 3.26539e-08, 0, 0, 0.99998, 6.03559e-08, 0, 0, 0.999971, 1.23936e-07, 0, 0, 0.999955, 2.69058e-07, 0, 0, 0.999933, 5.93604e-07, 0, 0, 0.999901, 1.29633e-06, 0, 0, 0.999847, 2.75621e-06, 0, 0, 0.999761, 5.64494e-06, 0, 0, 0.999607, 1.10485e-05, 0, 0, 0.999282, 2.04388e-05, 0, 0, 0.99831, 3.41084e-05, 0, 2.2038e-07, 0.993288, 2.94949e-05, 0, 0.000242388, 0.987855, 1.92736e-05, 0, 0.0012503, 0.983167, 1.82383e-05, 0, 0.0032745, 0.977908, 2.18633e-05, 0, 0.00646321, 0.971194, 2.90662e-05, 0, 0.0109133, 0.963867, 3.86401e-05, 0, 0.0166927, 0.95982, 4.62827e-05, 0, 0.0238494, 0.953497, 4.20705e-05, 0, 0.0324178, 0.947621, 4.77743e-05, 0, 0.0424225, 0.940611, 5.68258e-05, 0, 0.0538808, 0.931174, 6.18061e-05, 0, 0.0668047, 0.919919, 6.27098e-05, 0, 0.0812014, 0.907856, 6.94714e-05, 0, 0.0970745, 0.894509, 7.35008e-05, 0, 0.114424, 0.881954, 7.63369e-05, 0, 0.133246, 0.868309, 8.21896e-05, 0, 0.153534, 0.852511, 8.3769e-05, 0, 0.175275, 0.835821, 8.81615e-05, 0, 0.198453, 0.817981, 8.96368e-05, 0, 0.223042, 0.800504, 9.30906e-05, 0, 0.249009, 0.78141, 9.45056e-05, 0, 0.276304, 0.761427, 9.63605e-05, 0, 0.304862, 0.74094, 9.68088e-05, 0, 0.334584, 0.720233, 9.81481e-05, 0, 0.365322, 0.698592, 9.79122e-05, 0, 0.396826, 0.676763, 9.81057e-05, 0, 0.428571, 0.654808, 9.73956e-05, 0, 0.460318, 0.632326, 9.62619e-05, 0, 0.492064, 0.610049, 9.52996e-05, 0, 0.52381, 0.58763, 9.33334e-05, 0, 0.555556, 0.565261, 9.17573e-05, 0, 0.587302, 0.543244, 8.96636e-05, 0, 0.619048, 0.521273, 8.73304e-05, 0, 0.650794, 0.499818, 8.52648e-05, 0, 0.68254, 0.478536, 8.23961e-05, 0, 0.714286, 0.457826, 7.9939e-05, 0, 0.746032, 0.437549, 7.7126e-05, 0, 0.777778, 0.41776, 7.43043e-05, 0, 0.809524, 0.39863, 7.16426e-05, 0, 0.84127, 0.379954, 6.86456e-05, 0, 0.873016, 0.362025, 6.60514e-05, 0, 0.904762, 0.344581, 6.30755e-05, 0, 0.936508, 0.327909, 6.05439e-05, 0, 0.968254, 0.311736, 5.76345e-05, 0, 1, 1, 2.63344e-08, 0, 0, 1, 2.63373e-08, 0, 0, 1, 2.63815e-08, 0, 0, 1, 2.65753e-08, 0, 0, 1, 2.71132e-08, 0, 0, 0.999999, 2.83279e-08, 0, 0, 0.999997, 3.0833e-08, 0, 0, 0.999995, 3.58711e-08, 0, 0, 0.999992, 4.61266e-08, 0, 0, 0.999985, 6.7574e-08, 0, 0, 0.999977, 1.1358e-07, 0, 0, 0.999966, 2.13657e-07, 0, 0, 0.999948, 4.31151e-07, 0, 0, 0.999923, 8.96656e-07, 0, 0, 0.999884, 1.86603e-06, 0, 0, 0.999826, 3.81115e-06, 0, 0, 0.999732, 7.54184e-06, 0, 0, 0.999561, 1.43192e-05, 0, 0, 0.999191, 2.57061e-05, 0, 0, 0.997955, 4.05724e-05, 0, 7.44132e-05, 0.992228, 2.76537e-05, 0, 0.000716477, 0.987638, 2.08885e-05, 0, 0.0022524, 0.983395, 2.15226e-05, 0, 0.00484816, 0.978614, 2.70795e-05, 0, 0.00860962, 0.972389, 3.65282e-05, 0, 0.0136083, 0.964392, 4.74747e-05, 0, 0.0198941, 0.95861, 5.09141e-05, 0, 0.0275023, 0.952806, 4.8963e-05, 0, 0.0364584, 0.94712, 5.71119e-05, 0, 0.04678, 0.940104, 6.71704e-05, 0, 0.0584799, 0.930398, 6.87586e-05, 0, 0.0715665, 0.919866, 7.38161e-05, 0, 0.086045, 0.907853, 8.13235e-05, 0, 0.101918, 0.894078, 8.34582e-05, 0, 0.119186, 0.881177, 8.92093e-05, 0, 0.137845, 0.867575, 9.44548e-05, 0, 0.157891, 0.852107, 9.69607e-05, 0, 0.179316, 0.835502, 0.000101456, 0, 0.202106, 0.81756, 0.000103256, 0, 0.226243, 0.79984, 0.000106954, 0, 0.251704, 0.780998, 0.000108066, 0, 0.278451, 0.761132, 0.000110111, 0, 0.306436, 0.740429, 0.000110459, 0, 0.335586, 0.719836, 0.000111219, 0, 0.365796, 0.698467, 0.00011145, 0, 0.3969, 0.676446, 0.000110393, 0, 0.428571, 0.654635, 0.000110035, 0, 0.460318, 0.632411, 0.000108548, 0, 0.492064, 0.609986, 0.000106963, 0, 0.52381, 0.587872, 0.000105238, 0, 0.555556, 0.565528, 0.000102665, 0, 0.587302, 0.543563, 0.000100543, 0, 0.619048, 0.52176, 9.76182e-05, 0, 0.650794, 0.500188, 9.47099e-05, 0, 0.68254, 0.479204, 9.19929e-05, 0, 0.714286, 0.458413, 8.86139e-05, 0, 0.746032, 0.438314, 8.57839e-05, 0, 0.777778, 0.418573, 8.2411e-05, 0, 0.809524, 0.39947, 7.92211e-05, 0, 0.84127, 0.380892, 7.59546e-05, 0, 0.873016, 0.362953, 7.27571e-05, 0, 0.904762, 0.345601, 6.95738e-05, 0, 0.936508, 0.328895, 6.64907e-05, 0, 0.968254, 0.312808, 6.34277e-05, 0, 1, 1, 6.28647e-08, 0, 0, 1, 6.28705e-08, 0, 0, 1, 6.29587e-08, 0, 0, 1, 6.33441e-08, 0, 0, 0.999999, 6.44087e-08, 0, 0, 0.999998, 6.67856e-08, 0, 0, 0.999997, 7.15889e-08, 0, 0, 0.999995, 8.09577e-08, 0, 0, 0.999989, 9.92764e-08, 0, 0, 0.999983, 1.35834e-07, 0, 0, 0.999974, 2.10482e-07, 0, 0, 0.999959, 3.65215e-07, 0, 0, 0.999939, 6.86693e-07, 0, 0, 0.999911, 1.3472e-06, 0, 0, 0.999868, 2.6731e-06, 0, 0, 0.999804, 5.24756e-06, 0, 0, 0.9997, 1.00403e-05, 0, 0, 0.99951, 1.85019e-05, 0, 0, 0.999078, 3.22036e-05, 0, 6.20676e-06, 0.997428, 4.70002e-05, 0, 0.000341552, 0.99162, 2.87123e-05, 0, 0.00143727, 0.987479, 2.34706e-05, 0, 0.00349201, 0.983582, 2.60083e-05, 0, 0.0066242, 0.979186, 3.37927e-05, 0, 0.0109113, 0.97325, 4.54689e-05, 0, 0.0164064, 0.965221, 5.73759e-05, 0, 0.0231463, 0.957262, 5.44114e-05, 0, 0.0311571, 0.952211, 5.87006e-05, 0, 0.0404572, 0.946631, 6.92256e-05, 0, 0.0510592, 0.939391, 7.87819e-05, 0, 0.0629723, 0.929795, 7.92368e-05, 0, 0.0762025, 0.91965, 8.75075e-05, 0, 0.090753, 0.907737, 9.50903e-05, 0, 0.106626, 0.893899, 9.72963e-05, 0, 0.123822, 0.880239, 0.00010459, 0, 0.142337, 0.866562, 0.000107689, 0, 0.16217, 0.85164, 0.000113081, 0, 0.183314, 0.835021, 0.000116636, 0, 0.20576, 0.817311, 0.000120074, 0, 0.229496, 0.798845, 0.000121921, 0, 0.254502, 0.780479, 0.00012475, 0, 0.280753, 0.760694, 0.000125255, 0, 0.308212, 0.740142, 0.000126719, 0, 0.336825, 0.719248, 0.00012636, 0, 0.366517, 0.698209, 0.000126712, 0, 0.397167, 0.676398, 0.000125769, 0, 0.428578, 0.654378, 0.000124432, 0, 0.460318, 0.632484, 0.000123272, 0, 0.492064, 0.610113, 0.00012085, 0, 0.52381, 0.587931, 0.000118411, 0, 0.555556, 0.565872, 0.00011569, 0, 0.587302, 0.543814, 0.000112521, 0, 0.619048, 0.522265, 0.000109737, 0, 0.650794, 0.500835, 0.000106228, 0, 0.68254, 0.479818, 0.000102591, 0, 0.714286, 0.459258, 9.91288e-05, 0, 0.746032, 0.439061, 9.52325e-05, 0, 0.777778, 0.419552, 9.1895e-05, 0, 0.809524, 0.400399, 8.79051e-05, 0, 0.84127, 0.381976, 8.44775e-05, 0, 0.873016, 0.364009, 8.06316e-05, 0, 0.904762, 0.346761, 7.71848e-05, 0, 0.936508, 0.330049, 7.35429e-05, 0, 0.968254, 0.314018, 7.02103e-05, 0, 1, 1, 1.39968e-07, 0, 0, 1, 1.39979e-07, 0, 0, 1, 1.40145e-07, 0, 0, 1, 1.4087e-07, 0, 0, 0.999999, 1.42865e-07, 0, 0, 0.999998, 1.47279e-07, 0, 0, 0.999997, 1.56057e-07, 0, 0, 0.999992, 1.7276e-07, 0, 0, 0.999989, 2.04352e-07, 0, 0, 0.99998, 2.6494e-07, 0, 0, 0.999969, 3.83435e-07, 0, 0, 0.999953, 6.18641e-07, 0, 0, 0.999929, 1.08755e-06, 0, 0, 0.999898, 2.01497e-06, 0, 0, 0.999849, 3.81346e-06, 0, 0, 0.999778, 7.19815e-06, 0, 0, 0.999661, 1.33215e-05, 0, 0, 0.999451, 2.38313e-05, 0, 0, 0.998936, 4.01343e-05, 0, 0.000113724, 0.99662, 5.17346e-05, 0, 0.000820171, 0.991094, 3.04323e-05, 0, 0.00238143, 0.987487, 2.81757e-05, 0, 0.00493527, 0.983731, 3.20048e-05, 0, 0.00856859, 0.979647, 4.23905e-05, 0, 0.0133393, 0.973837, 5.62935e-05, 0, 0.0192863, 0.96584, 6.77442e-05, 0, 0.0264369, 0.956309, 6.23073e-05, 0, 0.03481, 0.951523, 7.04131e-05, 0, 0.0444184, 0.946003, 8.36594e-05, 0, 0.0552713, 0.938454, 9.11736e-05, 0, 0.0673749, 0.929279, 9.38264e-05, 0, 0.0807329, 0.919239, 0.000103754, 0, 0.0953479, 0.907293, 0.000109928, 0, 0.111221, 0.893936, 0.000115257, 0, 0.128352, 0.879674, 0.000122265, 0, 0.14674, 0.865668, 0.000125733, 0, 0.166382, 0.850998, 0.000132305, 0, 0.187276, 0.834498, 0.000134844, 0, 0.209413, 0.816903, 0.000139276, 0, 0.232786, 0.798235, 0.000140984, 0, 0.257382, 0.779724, 0.00014378, 0, 0.283181, 0.760251, 0.000144623, 0, 0.310156, 0.739808, 0.000145228, 0, 0.338269, 0.718762, 0.00014539, 0, 0.367461, 0.697815, 0.000144432, 0, 0.397646, 0.67631, 0.000143893, 0, 0.428685, 0.654278, 0.000141846, 0, 0.460318, 0.632347, 0.00013935, 0, 0.492064, 0.610296, 0.000137138, 0, 0.52381, 0.588039, 0.000133806, 0, 0.555556, 0.566218, 0.000130755, 0, 0.587302, 0.544346, 0.000127128, 0, 0.619048, 0.522701, 0.000123002, 0, 0.650794, 0.501542, 0.000119443, 0, 0.68254, 0.480508, 0.000115055, 0, 0.714286, 0.460092, 0.000111032, 0, 0.746032, 0.440021, 0.000106635, 0, 0.777778, 0.420446, 0.000102162, 0, 0.809524, 0.401512, 9.8184e-05, 0, 0.84127, 0.38299, 9.36497e-05, 0, 0.873016, 0.365232, 8.9813e-05, 0, 0.904762, 0.347865, 8.53073e-05, 0, 0.936508, 0.331342, 8.17068e-05, 0, 0.968254, 0.315202, 7.73818e-05, 0, 1, 1, 2.9368e-07, 0, 0, 1, 2.937e-07, 0, 0, 1, 2.93998e-07, 0, 0, 1, 2.95298e-07, 0, 0, 0.999999, 2.98865e-07, 0, 0, 0.999998, 3.067e-07, 0, 0, 0.999995, 3.22082e-07, 0, 0, 0.999992, 3.50767e-07, 0, 0, 0.999986, 4.03538e-07, 0, 0, 0.999976, 5.01372e-07, 0, 0, 0.999964, 6.8562e-07, 0, 0, 0.999945, 1.0374e-06, 0, 0, 0.999919, 1.71269e-06, 0, 0, 0.999882, 3.00175e-06, 0, 0, 0.999829, 5.42144e-06, 0, 0, 0.999749, 9.84182e-06, 0, 0, 0.99962, 1.76213e-05, 0, 0, 0.999382, 3.05995e-05, 0, 1.38418e-05, 0.998751, 4.96686e-05, 0, 0.000389844, 0.995344, 5.10733e-05, 0, 0.00150343, 0.990768, 3.45829e-05, 0, 0.00352451, 0.987464, 3.42841e-05, 0, 0.00655379, 0.983846, 3.99072e-05, 0, 0.0106554, 0.980007, 5.33219e-05, 0, 0.0158723, 0.974494, 6.96992e-05, 0, 0.0222333, 0.96622, 7.76754e-05, 0, 0.029758, 0.956273, 7.47718e-05, 0, 0.0384596, 0.950952, 8.64611e-05, 0, 0.0483473, 0.945215, 0.000100464, 0, 0.0594266, 0.937287, 0.000103729, 0, 0.0717019, 0.928649, 0.000111665, 0, 0.0851752, 0.918791, 0.00012353, 0, 0.0998479, 0.906685, 0.000127115, 0, 0.115721, 0.893706, 0.00013628, 0, 0.132794, 0.879248, 0.000142427, 0, 0.151067, 0.864685, 0.000148091, 0, 0.170538, 0.850032, 0.000153517, 0, 0.191204, 0.833853, 0.000157322, 0, 0.213063, 0.816353, 0.000161086, 0, 0.236107, 0.797834, 0.000164111, 0, 0.260329, 0.778831, 0.000165446, 0, 0.285714, 0.759756, 0.000167492, 0, 0.312243, 0.739419, 0.000166928, 0, 0.339887, 0.718491, 0.000167, 0, 0.368604, 0.697392, 0.000165674, 0, 0.398329, 0.676102, 0.000163815, 0, 0.428961, 0.654243, 0.000162003, 0, 0.460331, 0.632176, 0.000158831, 0, 0.492064, 0.610407, 0.000155463, 0, 0.52381, 0.588394, 0.000152062, 0, 0.555556, 0.56645, 0.000147665, 0, 0.587302, 0.5449, 0.00014375, 0, 0.619048, 0.523276, 0.000138905, 0, 0.650794, 0.502179, 0.000134189, 0, 0.68254, 0.481359, 0.000129392, 0, 0.714286, 0.46092, 0.000124556, 0, 0.746032, 0.441084, 0.00011957, 0, 0.777778, 0.421517, 0.000114652, 0, 0.809524, 0.402721, 0.000109688, 0, 0.84127, 0.384222, 0.000104667, 0, 0.873016, 0.366534, 9.99633e-05, 0, 0.904762, 0.349205, 9.50177e-05, 0, 0.936508, 0.332702, 9.07301e-05, 0, 0.968254, 0.316599, 8.59769e-05, 0, 1, 1, 5.85473e-07, 0, 0, 1, 5.85507e-07, 0, 0, 1, 5.8602e-07, 0, 0, 0.999999, 5.88259e-07, 0, 0, 0.999999, 5.94381e-07, 0, 0, 0.999998, 6.07754e-07, 0, 0, 0.999995, 6.33729e-07, 0, 0, 0.99999, 6.8137e-07, 0, 0, 0.999984, 7.67003e-07, 0, 0, 0.999973, 9.21212e-07, 0, 0, 0.999959, 1.20218e-06, 0, 0, 0.999936, 1.72024e-06, 0, 0, 0.999907, 2.68088e-06, 0, 0, 0.999866, 4.45512e-06, 0, 0, 0.999806, 7.68481e-06, 0, 0, 0.999716, 1.342e-05, 0, 0, 0.999576, 2.32473e-05, 0, 0, 0.9993, 3.91694e-05, 0, 0.000129917, 0.998498, 6.08429e-05, 0, 0.000845035, 0.994132, 4.89743e-05, 0, 0.00237616, 0.99031, 3.84644e-05, 0, 0.00484456, 0.987409, 4.21768e-05, 0, 0.00832472, 0.983981, 5.04854e-05, 0, 0.0128643, 0.980268, 6.71028e-05, 0, 0.0184947, 0.974875, 8.52749e-05, 0, 0.025237, 0.966063, 8.5531e-05, 0, 0.0331046, 0.956779, 9.00588e-05, 0, 0.0421067, 0.950259, 0.00010577, 0, 0.0522487, 0.944239, 0.000119458, 0, 0.0635343, 0.936341, 0.000122164, 0, 0.0759654, 0.928047, 0.000134929, 0, 0.0895434, 0.918065, 0.000145544, 0, 0.104269, 0.906267, 0.000150531, 0, 0.120142, 0.893419, 0.000161652, 0, 0.137163, 0.878758, 0.00016593, 0, 0.15533, 0.863699, 0.000174014, 0, 0.174645, 0.848876, 0.000177877, 0, 0.195106, 0.833032, 0.000184049, 0, 0.21671, 0.815557, 0.000186088, 0, 0.239454, 0.797323, 0.00019054, 0, 0.263332, 0.778124, 0.000191765, 0, 0.288336, 0.758929, 0.000192535, 0, 0.314451, 0.738979, 0.000192688, 0, 0.341658, 0.718213, 0.000191522, 0, 0.369924, 0.696947, 0.000190491, 0, 0.399202, 0.675807, 0.000187913, 0, 0.429416, 0.654147, 0.000184451, 0, 0.460447, 0.63229, 0.000181442, 0, 0.492064, 0.610499, 0.000177139, 0, 0.523809, 0.588747, 0.000172596, 0, 0.555555, 0.566783, 0.000167457, 0, 0.587301, 0.545359, 0.000162518, 0, 0.619048, 0.523984, 0.000156818, 0, 0.650794, 0.502917, 0.000151884, 0, 0.68254, 0.482294, 0.000145514, 0, 0.714286, 0.461945, 0.000140199, 0, 0.746032, 0.442133, 0.000134101, 0, 0.777778, 0.422705, 0.000128374, 0, 0.809524, 0.403916, 0.000122996, 0, 0.84127, 0.38554, 0.000116808, 0, 0.873016, 0.367909, 0.000111973, 0, 0.904762, 0.350651, 0.000105938, 0, 0.936508, 0.334208, 0.000101355, 0, 0.968254, 0.318123, 9.57629e-05, 0, 1, 1, 1.11633e-06, 0, 0, 1, 1.11639e-06, 0, 0, 1, 1.11725e-06, 0, 0, 1, 1.12096e-06, 0, 0, 0.999999, 1.1311e-06, 0, 0, 0.999997, 1.15315e-06, 0, 0, 0.999995, 1.1956e-06, 0, 0, 0.999989, 1.27239e-06, 0, 0, 0.999981, 1.40772e-06, 0, 0, 0.999969, 1.64541e-06, 0, 0, 0.999952, 2.06607e-06, 0, 0, 0.999928, 2.81783e-06, 0, 0, 0.999895, 4.16835e-06, 0, 0, 0.999848, 6.58728e-06, 0, 0, 0.999781, 1.08648e-05, 0, 0, 0.999682, 1.82579e-05, 0, 0, 0.999523, 3.06003e-05, 0, 1.59122e-05, 0.999205, 4.99862e-05, 0, 0.000391184, 0.998131, 7.3306e-05, 0, 0.00147534, 0.993334, 5.13229e-05, 0, 0.0034227, 0.99016, 4.67783e-05, 0, 0.00632232, 0.987321, 5.23413e-05, 0, 0.0102295, 0.984099, 6.4267e-05, 0, 0.0151794, 0.980432, 8.43042e-05, 0, 0.0211947, 0.974976, 0.000102819, 0, 0.0282899, 0.966429, 9.96234e-05, 0, 0.0364739, 0.957633, 0.000111074, 0, 0.0457522, 0.949422, 0.000128644, 0, 0.0561278, 0.943045, 0.000140076, 0, 0.0676023, 0.935448, 0.000146349, 0, 0.0801762, 0.927225, 0.000161854, 0, 0.0938499, 0.917033, 0.000169135, 0, 0.108623, 0.905762, 0.000179987, 0, 0.124496, 0.892879, 0.000189832, 0, 0.141469, 0.878435, 0.000195881, 0, 0.159541, 0.863114, 0.00020466, 0, 0.178713, 0.84776, 0.000209473, 0, 0.198985, 0.832084, 0.000214861, 0, 0.220355, 0.814915, 0.000217695, 0, 0.242823, 0.796711, 0.000220313, 0, 0.266385, 0.777603, 0.00022313, 0, 0.291036, 0.757991, 0.000222471, 0, 0.316767, 0.738371, 0.000222869, 0, 0.343563, 0.717872, 0.000221243, 0, 0.371402, 0.696619, 0.000218089, 0, 0.400248, 0.675379, 0.00021562, 0, 0.430047, 0.65411, 0.00021169, 0, 0.460709, 0.63241, 0.000206947, 0, 0.492079, 0.61046, 0.000201709, 0, 0.52381, 0.58903, 0.000196753, 0, 0.555556, 0.567267, 0.000189637, 0, 0.587302, 0.545886, 0.000184735, 0, 0.619048, 0.524714, 0.000177257, 0, 0.650794, 0.503789, 0.000171424, 0, 0.68254, 0.483204, 0.000164688, 0, 0.714286, 0.462976, 0.000157172, 0, 0.746032, 0.443294, 0.000151341, 0, 0.777778, 0.423988, 0.000143737, 0, 0.809524, 0.405325, 0.000138098, 0, 0.84127, 0.386981, 0.000130698, 0, 0.873016, 0.369436, 0.000125276, 0, 0.904762, 0.35219, 0.000118349, 0, 0.936508, 0.335804, 0.00011312, 0, 0.968254, 0.319749, 0.000106687, 0, 1, 1, 2.04685e-06, 0, 0, 1, 2.04694e-06, 0, 0, 1, 2.04831e-06, 0, 0, 0.999999, 2.05428e-06, 0, 0, 0.999999, 2.07056e-06, 0, 0, 0.999997, 2.10581e-06, 0, 0, 0.999993, 2.1732e-06, 0, 0, 0.999987, 2.29365e-06, 0, 0, 0.999979, 2.50243e-06, 0, 0, 0.999965, 2.86127e-06, 0, 0, 0.999947, 3.48028e-06, 0, 0, 0.999918, 4.55588e-06, 0, 0, 0.999881, 6.43303e-06, 0, 0, 0.999828, 9.70064e-06, 0, 0, 0.999753, 1.53233e-05, 0, 0, 0.999642, 2.4793e-05, 0, 0, 0.999464, 4.02032e-05, 0, 0.000122947, 0.999089, 6.35852e-05, 0, 0.000807414, 0.997567, 8.57026e-05, 0, 0.00227206, 0.992903, 5.94912e-05, 0, 0.00462812, 0.990011, 5.78515e-05, 0, 0.00794162, 0.987192, 6.5399e-05, 0, 0.0122534, 0.98418, 8.19675e-05, 0, 0.0175888, 0.980491, 0.000105514, 0, 0.0239635, 0.974779, 0.000121532, 0, 0.031387, 0.96675, 0.000119144, 0, 0.0398644, 0.958248, 0.000136125, 0, 0.0493982, 0.948884, 0.000155408, 0, 0.0599896, 0.941673, 0.000162281, 0, 0.0716382, 0.934521, 0.000176754, 0, 0.0843437, 0.926205, 0.000192873, 0, 0.0981056, 0.916089, 0.000200038, 0, 0.112923, 0.904963, 0.000213624, 0, 0.128796, 0.892089, 0.000221834, 0, 0.145725, 0.878028, 0.000232619, 0, 0.163709, 0.86249, 0.000238632, 0, 0.182749, 0.846587, 0.000247002, 0, 0.202847, 0.830988, 0.000250702, 0, 0.224001, 0.814165, 0.000255562, 0, 0.246214, 0.796135, 0.000257505, 0, 0.269482, 0.777052, 0.000258625, 0, 0.293805, 0.757201, 0.000258398, 0, 0.319176, 0.737655, 0.000256714, 0, 0.345587, 0.717477, 0.000255187, 0, 0.373021, 0.696433, 0.000251792, 0, 0.401454, 0.675084, 0.000247223, 0, 0.430844, 0.653907, 0.000242213, 0, 0.461125, 0.632561, 0.000237397, 0, 0.492187, 0.610658, 0.000229313, 0, 0.52381, 0.589322, 0.000224402, 0, 0.555556, 0.567857, 0.000216116, 0, 0.587302, 0.54652, 0.000209124, 0, 0.619048, 0.525433, 0.000201601, 0, 0.650794, 0.504679, 0.000192957, 0, 0.68254, 0.484203, 0.000186052, 0, 0.714286, 0.464203, 0.000177672, 0, 0.746032, 0.444549, 0.000170005, 0, 0.777778, 0.425346, 0.000162401, 0, 0.809524, 0.406706, 0.0001544, 0, 0.84127, 0.388576, 0.000147437, 0, 0.873016, 0.37094, 0.000139493, 0, 0.904762, 0.353996, 0.000133219, 0, 0.936508, 0.337391, 0.000125573, 0, 0.968254, 0.321648, 0.000119867, 0, 1, 1, 3.62511e-06, 0, 0, 1, 3.62525e-06, 0, 0, 1, 3.62739e-06, 0, 0, 0.999999, 3.63673e-06, 0, 0, 0.999998, 3.66214e-06, 0, 0, 0.999996, 3.71698e-06, 0, 0, 0.999992, 3.82116e-06, 0, 0, 0.999986, 4.00554e-06, 0, 0, 0.999976, 4.32058e-06, 0, 0, 0.999961, 4.85194e-06, 0, 0, 0.999938, 5.74808e-06, 0, 0, 0.999908, 7.26643e-06, 0, 0, 0.999865, 9.84707e-06, 0, 0, 0.999807, 1.42217e-05, 0, 0, 0.999723, 2.15581e-05, 0, 0, 0.999602, 3.36114e-05, 0, 1.19113e-05, 0.999398, 5.27353e-05, 0, 0.000355813, 0.998946, 8.05809e-05, 0, 0.00137768, 0.996647, 9.42908e-05, 0, 0.00322469, 0.992298, 6.68733e-05, 0, 0.00597897, 0.989802, 7.16564e-05, 0, 0.00968903, 0.987019, 8.21355e-05, 0, 0.0143845, 0.984219, 0.000104555, 0, 0.0200831, 0.980425, 0.000131245, 0, 0.0267948, 0.974241, 0.000139613, 0, 0.034525, 0.967006, 0.000145931, 0, 0.0432757, 0.95893, 0.000167153, 0, 0.0530471, 0.949157, 0.000188146, 0, 0.0638386, 0.94062, 0.000194625, 0, 0.0756487, 0.933509, 0.000213721, 0, 0.0884762, 0.925088, 0.000229616, 0, 0.10232, 0.915178, 0.000239638, 0, 0.117178, 0.904093, 0.000254814, 0, 0.133051, 0.891337, 0.000263685, 0, 0.149939, 0.877326, 0.000274789, 0, 0.167841, 0.861794, 0.000280534, 0, 0.18676, 0.845758, 0.000289534, 0, 0.206696, 0.829792, 0.000294446, 0, 0.22765, 0.813037, 0.000296877, 0, 0.249625, 0.795285, 0.000300217, 0, 0.27262, 0.776323, 0.000299826, 0, 0.296636, 0.756673, 0.000299787, 0, 0.321671, 0.736856, 0.000297867, 0, 0.347718, 0.716883, 0.000294052, 0, 0.374768, 0.696089, 0.000289462, 0, 0.402804, 0.67505, 0.000285212, 0, 0.431796, 0.653509, 0.00027653, 0, 0.461695, 0.63258, 0.000271759, 0, 0.49242, 0.61104, 0.000262811, 0, 0.523822, 0.589567, 0.000255151, 0, 0.555556, 0.568322, 0.000246434, 0, 0.587302, 0.547235, 0.000237061, 0, 0.619048, 0.52616, 0.000228343, 0, 0.650794, 0.505716, 0.000219236, 0, 0.68254, 0.485274, 0.000209595, 0, 0.714286, 0.465411, 0.000201011, 0, 0.746032, 0.445854, 0.00019109, 0, 0.777778, 0.426911, 0.000182897, 0, 0.809524, 0.408222, 0.000173569, 0, 0.84127, 0.390307, 0.000165496, 0, 0.873016, 0.372624, 0.000156799, 0, 0.904762, 0.355804, 0.00014917, 0, 0.936508, 0.33924, 0.000140907, 0, 0.968254, 0.323534, 0.000134062, 0, 1, 1, 6.22487e-06, 0, 0, 1, 6.2251e-06, 0, 0, 1, 6.22837e-06, 0, 0, 0.999999, 6.24259e-06, 0, 0, 0.999998, 6.28127e-06, 0, 0, 0.999996, 6.36451e-06, 0, 0, 0.999991, 6.5218e-06, 0, 0, 0.999984, 6.79782e-06, 0, 0, 0.999973, 7.26361e-06, 0, 0, 0.999955, 8.03644e-06, 0, 0, 0.999931, 9.31397e-06, 0, 0, 0.999896, 1.14299e-05, 0, 0, 0.999847, 1.49402e-05, 0, 0, 0.999784, 2.07461e-05, 0, 0, 0.999692, 3.02493e-05, 0, 0, 0.999554, 4.54957e-05, 0, 9.97275e-05, 0.999326, 6.90762e-05, 0, 0.000724813, 0.998757, 0.000101605, 0, 0.0020972, 0.995367, 9.58745e-05, 0, 0.00432324, 0.99209, 8.32808e-05, 0, 0.00746347, 0.989517, 8.87601e-05, 0, 0.0115534, 0.987008, 0.00010564, 0, 0.0166134, 0.98421, 0.000133179, 0, 0.0226552, 0.98021, 0.000161746, 0, 0.0296838, 0.973676, 0.000161821, 0, 0.0377016, 0.967052, 0.000178635, 0, 0.0467079, 0.959385, 0.000206765, 0, 0.0567013, 0.949461, 0.00022476, 0, 0.0676796, 0.939578, 0.00023574, 0, 0.0796403, 0.932416, 0.00025893, 0, 0.0925812, 0.923759, 0.000271228, 0, 0.106501, 0.914223, 0.000289165, 0, 0.121397, 0.902942, 0.000301156, 0, 0.13727, 0.890419, 0.000313852, 0, 0.15412, 0.876639, 0.000324408, 0, 0.171946, 0.861316, 0.00033249, 0, 0.190751, 0.84496, 0.000338497, 0, 0.210537, 0.828427, 0.000345861, 0, 0.231305, 0.811871, 0.000347863, 0, 0.253057, 0.794397, 0.000350225, 0, 0.275797, 0.775726, 0.000349915, 0, 0.299525, 0.75617, 0.000347297, 0, 0.324242, 0.736091, 0.000344232, 0, 0.349947, 0.716213, 0.000340835, 0, 0.376633, 0.695736, 0.000332369, 0, 0.404289, 0.674961, 0.000327943, 0, 0.432895, 0.653518, 0.000318533, 0, 0.462415, 0.632574, 0.000310391, 0, 0.492788, 0.61134, 0.000300755, 0, 0.523909, 0.590017, 0.000290506, 0, 0.555556, 0.568752, 0.000280446, 0, 0.587302, 0.548061, 0.000269902, 0, 0.619048, 0.52711, 0.000258815, 0, 0.650794, 0.506682, 0.000248481, 0, 0.68254, 0.486524, 0.000237141, 0, 0.714286, 0.466812, 0.000226872, 0, 0.746032, 0.44732, 0.000216037, 0, 0.777778, 0.428473, 0.000205629, 0, 0.809524, 0.409921, 0.000195691, 0, 0.84127, 0.392028, 0.000185457, 0, 0.873016, 0.374606, 0.000176436, 0, 0.904762, 0.357601, 0.000166508, 0, 0.936508, 0.341348, 0.000158385, 0, 0.968254, 0.32542, 0.000149203, 0, 1, 1, 1.03967e-05, 0, 0, 1, 1.0397e-05, 0, 0, 1, 1.04019e-05, 0, 0, 0.999999, 1.04231e-05, 0, 0, 0.999998, 1.04806e-05, 0, 0, 0.999995, 1.06042e-05, 0, 0, 0.999991, 1.08366e-05, 0, 0, 0.999982, 1.12415e-05, 0, 0, 0.999968, 1.19174e-05, 0, 0, 0.99995, 1.30227e-05, 0, 0, 0.999922, 1.48176e-05, 0, 0, 0.999884, 1.77303e-05, 0, 0, 0.99983, 2.24564e-05, 0, 0, 0.999758, 3.00966e-05, 0, 0, 0.999654, 4.23193e-05, 0, 5.49083e-06, 0.999503, 6.14848e-05, 0, 0.000296087, 0.999237, 9.03576e-05, 0, 0.00123144, 0.998491, 0.0001271, 0, 0.00295954, 0.994594, 0.000107754, 0, 0.00555829, 0.99178, 0.000103025, 0, 0.00907209, 0.989265, 0.00011154, 0, 0.0135257, 0.986998, 0.000136296, 0, 0.0189327, 0.984137, 0.000169154, 0, 0.0252993, 0.979798, 0.000196671, 0, 0.0326272, 0.97337, 0.000196678, 0, 0.0409157, 0.967239, 0.000223121, 0, 0.0501623, 0.959543, 0.000253809, 0, 0.0603638, 0.949466, 0.000265972, 0, 0.0715171, 0.939074, 0.000288372, 0, 0.0836187, 0.931118, 0.000310983, 0, 0.0966657, 0.922525, 0.000325561, 0, 0.110656, 0.912983, 0.000345725, 0, 0.125588, 0.901617, 0.0003556, 0, 0.141461, 0.889487, 0.000374012, 0, 0.158275, 0.875787, 0.000383445, 0, 0.176031, 0.860654, 0.000393972, 0, 0.19473, 0.844417, 0.000400311, 0, 0.214374, 0.82741, 0.000405004, 0, 0.234967, 0.810545, 0.000407378, 0, 0.256512, 0.793312, 0.000407351, 0, 0.279011, 0.774847, 0.000406563, 0, 0.302468, 0.755621, 0.000404903, 0, 0.326887, 0.735511, 0.000397486, 0, 0.352266, 0.715435, 0.00039357, 0, 0.378605, 0.695403, 0.000384739, 0, 0.405897, 0.674681, 0.000376108, 0, 0.43413, 0.65359, 0.000365997, 0, 0.463277, 0.632471, 0.000354957, 0, 0.493295, 0.61151, 0.000343593, 0, 0.524106, 0.59064, 0.000331841, 0, 0.555561, 0.569386, 0.000318891, 0, 0.587302, 0.548785, 0.0003072, 0, 0.619048, 0.528146, 0.00029361, 0, 0.650794, 0.507872, 0.000281709, 0, 0.68254, 0.487805, 0.000268627, 0, 0.714286, 0.468196, 0.000255887, 0, 0.746032, 0.448922, 0.000243997, 0, 0.777778, 0.430093, 0.000231662, 0, 0.809524, 0.411845, 0.000220339, 0, 0.84127, 0.393808, 0.000208694, 0, 0.873016, 0.376615, 0.000198045, 0, 0.904762, 0.359655, 0.000187375, 0, 0.936508, 0.343452, 0.000177371, 0, 0.968254, 0.32765, 0.000167525, 0, 1, 1, 1.69351e-05, 0, 0, 1, 1.69356e-05, 0, 0, 1, 1.69427e-05, 0, 0, 0.999999, 1.69736e-05, 0, 0, 0.999998, 1.70575e-05, 0, 0, 0.999995, 1.72372e-05, 0, 0, 0.99999, 1.75739e-05, 0, 0, 0.999979, 1.81568e-05, 0, 0, 0.999966, 1.91206e-05, 0, 0, 0.999944, 2.0677e-05, 0, 0, 0.999912, 2.31644e-05, 0, 0, 0.999869, 2.71268e-05, 0, 0, 0.999811, 3.34272e-05, 0, 0, 0.99973, 4.33979e-05, 0, 0, 0.999617, 5.90083e-05, 0, 6.80315e-05, 0.999445, 8.29497e-05, 0, 0.000612796, 0.999138, 0.000118019, 0, 0.00187408, 0.998095, 0.000156712, 0, 0.00395791, 0.993919, 0.000125054, 0, 0.00692144, 0.991333, 0.000126091, 0, 0.0107962, 0.989226, 0.000144912, 0, 0.0155986, 0.986954, 0.000175737, 0, 0.0213364, 0.983982, 0.000213883, 0, 0.0280114, 0.979128, 0.000234526, 0, 0.0356226, 0.973327, 0.000243725, 0, 0.0441668, 0.967416, 0.0002773, 0, 0.0536399, 0.959729, 0.000308799, 0, 0.0640376, 0.949758, 0.000322447, 0, 0.0753554, 0.939173, 0.000350021, 0, 0.0875893, 0.9296, 0.000370089, 0, 0.100736, 0.921181, 0.000391365, 0, 0.114793, 0.91164, 0.000413636, 0, 0.129759, 0.900435, 0.000427068, 0, 0.145632, 0.888183, 0.000441046, 0, 0.162412, 0.874772, 0.000454968, 0, 0.180101, 0.859566, 0.000461882, 0, 0.1987, 0.843579, 0.000471556, 0, 0.218213, 0.826453, 0.000474335, 0, 0.238641, 0.809164, 0.000477078, 0, 0.259989, 0.792179, 0.00047755, 0, 0.282262, 0.773866, 0.000472573, 0, 0.305464, 0.754944, 0.000469765, 0, 0.329599, 0.735133, 0.000462371, 0, 0.35467, 0.714858, 0.000453674, 0, 0.380678, 0.694829, 0.000443888, 0, 0.407622, 0.674453, 0.000432052, 0, 0.435493, 0.653685, 0.000420315, 0, 0.464275, 0.632666, 0.000406829, 0, 0.493938, 0.611676, 0.000392234, 0, 0.524422, 0.591193, 0.000379208, 0, 0.555624, 0.570145, 0.00036319, 0, 0.587302, 0.549566, 0.000349111, 0, 0.619048, 0.529278, 0.000334166, 0, 0.650794, 0.509026, 0.000318456, 0, 0.68254, 0.489186, 0.00030449, 0, 0.714286, 0.469662, 0.000289051, 0, 0.746032, 0.450691, 0.000275494, 0, 0.777778, 0.431841, 0.000261437, 0, 0.809524, 0.413752, 0.000247846, 0, 0.84127, 0.395951, 0.000235085, 0, 0.873016, 0.378633, 0.000222245, 0, 0.904762, 0.36194, 0.000210533, 0, 0.936508, 0.345599, 0.000198494, 0, 0.968254, 0.329999, 0.000188133, 0, 1, 1, 2.69663e-05, 0, 0, 1, 2.6967e-05, 0, 0, 1, 2.69772e-05, 0, 0, 0.999999, 2.70214e-05, 0, 0, 0.999998, 2.71415e-05, 0, 0, 0.999994, 2.7398e-05, 0, 0, 0.999988, 2.78771e-05, 0, 0, 0.999977, 2.87019e-05, 0, 0, 0.999961, 3.00544e-05, 0, 0, 0.999937, 3.22138e-05, 0, 0, 0.999904, 3.56163e-05, 0, 0, 0.999854, 4.09465e-05, 0, 0, 0.99979, 4.92651e-05, 0, 0, 0.999699, 6.21722e-05, 0, 8.8288e-07, 0.999572, 8.19715e-05, 0, 0.000223369, 0.999381, 0.000111689, 0, 0.00105414, 0.999016, 0.000153862, 0, 0.0026493, 0.997437, 0.000187667, 0, 0.00508608, 0.993545, 0.000155672, 0, 0.00840554, 0.991135, 0.000161455, 0, 0.012629, 0.989157, 0.000188241, 0, 0.0177661, 0.986874, 0.000226229, 0, 0.0238198, 0.983714, 0.000268668, 0, 0.0307887, 0.978301, 0.000277109, 0, 0.0386688, 0.973227, 0.000303446, 0, 0.0474554, 0.967317, 0.000341851, 0, 0.0571428, 0.959477, 0.000370885, 0, 0.0677256, 0.950012, 0.000392753, 0, 0.0791988, 0.939484, 0.00042781, 0, 0.0915576, 0.928135, 0.000443866, 0, 0.104798, 0.919819, 0.000472959, 0, 0.118918, 0.910049, 0.000491551, 0, 0.133915, 0.899181, 0.000512616, 0, 0.149788, 0.886881, 0.000523563, 0, 0.166537, 0.87359, 0.000540183, 0, 0.184164, 0.858613, 0.000547386, 0, 0.202669, 0.842809, 0.000554809, 0, 0.222056, 0.825727, 0.000558316, 0, 0.242329, 0.808086, 0.000557824, 0, 0.263492, 0.790728, 0.000556346, 0, 0.285551, 0.772987, 0.000552672, 0, 0.30851, 0.7541, 0.000543738, 0, 0.332376, 0.734669, 0.000536107, 0, 0.357153, 0.714411, 0.000523342, 0, 0.382845, 0.694196, 0.000512238, 0, 0.409454, 0.674252, 0.000497465, 0, 0.436977, 0.65357, 0.000481096, 0, 0.465404, 0.632999, 0.000467054, 0, 0.494713, 0.611994, 0.000448771, 0, 0.524864, 0.591604, 0.000431889, 0, 0.555779, 0.571134, 0.000415238, 0, 0.587302, 0.550528, 0.000396369, 0, 0.619048, 0.530292, 0.000379477, 0, 0.650794, 0.510364, 0.000361488, 0, 0.68254, 0.490749, 0.000343787, 0, 0.714286, 0.471266, 0.000327822, 0, 0.746032, 0.452462, 0.000310626, 0, 0.777778, 0.433907, 0.000295352, 0, 0.809524, 0.415659, 0.000279179, 0, 0.84127, 0.398138, 0.000264685, 0, 0.873016, 0.380833, 0.000249905, 0, 0.904762, 0.364247, 0.000236282, 0, 0.936508, 0.348041, 0.000222905, 0, 0.968254, 0.332389, 0.000210522, 0, 1, 1, 4.20604e-05, 0, 0, 1, 4.20614e-05, 0, 0, 1, 4.20757e-05, 0, 0, 0.999999, 4.2138e-05, 0, 0, 0.999997, 4.23067e-05, 0, 0, 0.999993, 4.26668e-05, 0, 0, 0.999986, 4.33372e-05, 0, 0, 0.999974, 4.44857e-05, 0, 0, 0.999956, 4.63554e-05, 0, 0, 0.99993, 4.93105e-05, 0, 0, 0.999892, 5.39077e-05, 0, 0, 0.999838, 6.10005e-05, 0, 0, 0.999767, 7.18822e-05, 0, 0, 0.999666, 8.84581e-05, 0, 3.65471e-05, 0.999525, 0.000113398, 0, 0.000485623, 0.999311, 0.000150043, 0, 0.00162096, 0.998865, 0.000200063, 0, 0.00355319, 0.996278, 0.000211014, 0, 0.00633818, 0.992956, 0.000189672, 0, 0.0100043, 0.991017, 0.000210262, 0, 0.0145648, 0.989055, 0.000244292, 0, 0.0200237, 0.986741, 0.000290481, 0, 0.0263798, 0.983288, 0.000334303, 0, 0.033629, 0.977784, 0.000340307, 0, 0.0417652, 0.973037, 0.000377864, 0, 0.0507821, 0.967181, 0.0004239, 0, 0.060673, 0.958971, 0.000443854, 0, 0.0714314, 0.950093, 0.000483039, 0, 0.0830518, 0.939552, 0.000517934, 0, 0.0955288, 0.927678, 0.000539449, 0, 0.108859, 0.918278, 0.000568604, 0, 0.123038, 0.908449, 0.000588505, 0, 0.138065, 0.897713, 0.000612473, 0, 0.153938, 0.885533, 0.000625575, 0, 0.170657, 0.872131, 0.00063854, 0, 0.188224, 0.857517, 0.000647034, 0, 0.20664, 0.841796, 0.00065209, 0, 0.225909, 0.824726, 0.0006544, 0, 0.246035, 0.807297, 0.000655744, 0, 0.267022, 0.789058, 0.000646716, 0, 0.288878, 0.77189, 0.000643898, 0, 0.311607, 0.753082, 0.000629973, 0, 0.335216, 0.7341, 0.000621564, 0, 0.359713, 0.714094, 0.000605171, 0, 0.385103, 0.693839, 0.000588752, 0, 0.41139, 0.673891, 0.000573294, 0, 0.438576, 0.653565, 0.000552682, 0, 0.466656, 0.633326, 0.000533446, 0, 0.495617, 0.612582, 0.000514635, 0, 0.525431, 0.59205, 0.00049303, 0, 0.556041, 0.571918, 0.000471842, 0, 0.587338, 0.551572, 0.000451713, 0, 0.619048, 0.531553, 0.000430049, 0, 0.650794, 0.51175, 0.000410445, 0, 0.68254, 0.49238, 0.000390098, 0, 0.714286, 0.473143, 0.000370033, 0, 0.746032, 0.45423, 0.000351205, 0, 0.777778, 0.435963, 0.000332049, 0, 0.809524, 0.41787, 0.000315021, 0, 0.84127, 0.400387, 0.000297315, 0, 0.873016, 0.383332, 0.000281385, 0, 0.904762, 0.366665, 0.000265397, 0, 0.936508, 0.350633, 0.000250601, 0, 0.968254, 0.334964, 0.00023589, 0, 1, 1, 6.43736e-05, 0, 0, 1, 6.4375e-05, 0, 0, 1, 6.43947e-05, 0, 0, 0.999999, 6.4481e-05, 0, 0, 0.999997, 6.47143e-05, 0, 0, 0.999994, 6.52119e-05, 0, 0, 0.999985, 6.61359e-05, 0, 0, 0.999972, 6.77116e-05, 0, 0, 0.999952, 7.02599e-05, 0, 0, 0.999922, 7.42517e-05, 0, 0, 0.99988, 8.03906e-05, 0, 0, 0.99982, 8.97315e-05, 0, 0, 0.999741, 0.000103838, 0, 0, 0.999629, 0.00012496, 0, 0.000149024, 0.999474, 0.000156161, 0, 0.000861027, 0.999229, 0.000201034, 0, 0.00231198, 0.998662, 0.000259069, 0, 0.00458147, 0.995299, 0.000245439, 0, 0.00770895, 0.992732, 0.00024498, 0, 0.0117126, 0.990847, 0.000273211, 0, 0.0165989, 0.988911, 0.000316492, 0, 0.0223674, 0.98654, 0.00037161, 0, 0.0290135, 0.982636, 0.000410352, 0, 0.0365309, 0.977346, 0.000421756, 0, 0.0449117, 0.972909, 0.000475578, 0, 0.0541481, 0.966821, 0.000522482, 0, 0.0642326, 0.958686, 0.000545008, 0, 0.075158, 0.949754, 0.000589286, 0, 0.0869181, 0.939184, 0.000619995, 0, 0.0995074, 0.927505, 0.000654266, 0, 0.112922, 0.916606, 0.000682362, 0, 0.127157, 0.906707, 0.000704286, 0, 0.142212, 0.895937, 0.000725909, 0, 0.158085, 0.883913, 0.000743939, 0, 0.174776, 0.870642, 0.000755157, 0, 0.192287, 0.856241, 0.000764387, 0, 0.210619, 0.84069, 0.000771032, 0, 0.229775, 0.823728, 0.000765906, 0, 0.249761, 0.806481, 0.000767604, 0, 0.270582, 0.787924, 0.000754385, 0, 0.292243, 0.770588, 0.000749668, 0, 0.314753, 0.751991, 0.000731613, 0, 0.338118, 0.733407, 0.000717655, 0, 0.362347, 0.713688, 0.000700604, 0, 0.387447, 0.693595, 0.000678765, 0, 0.413424, 0.673426, 0.000657042, 0, 0.440284, 0.65359, 0.000635892, 0, 0.468027, 0.633576, 0.000611569, 0, 0.496645, 0.613144, 0.000586011, 0, 0.526122, 0.592711, 0.000563111, 0, 0.556417, 0.572722, 0.000537699, 0, 0.587451, 0.552762, 0.000512556, 0, 0.619048, 0.532985, 0.000489757, 0, 0.650794, 0.513219, 0.000464139, 0, 0.68254, 0.493992, 0.000442193, 0, 0.714286, 0.47509, 0.000418629, 0, 0.746032, 0.456287, 0.000397045, 0, 0.777778, 0.438152, 0.000375504, 0, 0.809524, 0.420294, 0.00035492, 0, 0.84127, 0.402749, 0.000335327, 0, 0.873016, 0.385879, 0.000316422, 0, 0.904762, 0.369352, 0.000298333, 0, 0.936508, 0.353301, 0.000281417, 0, 0.968254, 0.337781, 0.000265203, 0, 1, 1, 9.68267e-05, 0, 0, 1, 9.68284e-05, 0, 0, 1, 9.68556e-05, 0, 0, 0.999999, 9.69733e-05, 0, 0, 0.999997, 9.72913e-05, 0, 0, 0.999993, 9.79688e-05, 0, 0, 0.999984, 9.92239e-05, 0, 0, 0.999969, 0.000101356, 0, 0, 0.999946, 0.000104784, 0, 0, 0.999913, 0.000110111, 0, 0, 0.999868, 0.000118217, 0, 0, 0.999801, 0.000130396, 0, 0, 0.999712, 0.000148523, 0, 1.24907e-05, 0.999589, 0.000175233, 0, 0.000355405, 0.999416, 0.000213999, 0, 0.0013528, 0.999136, 0.000268529, 0, 0.00312557, 0.998367, 0.000333088, 0, 0.00573045, 0.994701, 0.000304757, 0, 0.00919397, 0.992497, 0.000318031, 0, 0.0135261, 0.990608, 0.000353863, 0, 0.0187278, 0.988715, 0.000409044, 0, 0.0247947, 0.986241, 0.000472967, 0, 0.0317196, 0.981696, 0.000495104, 0, 0.039494, 0.977097, 0.000532873, 0, 0.0481087, 0.972583, 0.000594447, 0, 0.0575549, 0.966142, 0.000636867, 0, 0.0678242, 0.95823, 0.000669899, 0, 0.0789089, 0.949677, 0.000719499, 0, 0.0908023, 0.939226, 0.000750584, 0, 0.103499, 0.927501, 0.000793183, 0, 0.116993, 0.915199, 0.00081995, 0, 0.131282, 0.90498, 0.000847654, 0, 0.146364, 0.894243, 0.000868929, 0, 0.162237, 0.882154, 0.000884278, 0, 0.178902, 0.869161, 0.000898108, 0, 0.196358, 0.854751, 0.000901254, 0, 0.21461, 0.839368, 0.00090679, 0, 0.23366, 0.822874, 0.000901541, 0, 0.253512, 0.805514, 0.000897297, 0, 0.274174, 0.78716, 0.000881856, 0, 0.29565, 0.769061, 0.000870032, 0, 0.31795, 0.751, 0.000851719, 0, 0.341081, 0.732614, 0.000830671, 0, 0.365053, 0.713171, 0.000806569, 0, 0.389874, 0.693472, 0.00078338, 0, 0.415553, 0.673528, 0.000756404, 0, 0.442098, 0.653397, 0.000726872, 0, 0.469512, 0.633781, 0.000700494, 0, 0.497794, 0.613877, 0.00067105, 0, 0.526935, 0.593506, 0.000640361, 0, 0.556908, 0.573667, 0.000613502, 0, 0.587657, 0.553932, 0.000583177, 0, 0.61906, 0.534345, 0.000554375, 0, 0.650794, 0.515042, 0.000527811, 0, 0.68254, 0.495674, 0.000499367, 0, 0.714286, 0.477132, 0.00047429, 0, 0.746032, 0.458609, 0.000447726, 0, 0.777778, 0.440354, 0.000424205, 0, 0.809524, 0.422765, 0.000399549, 0, 0.84127, 0.405472, 0.000378315, 0, 0.873016, 0.388482, 0.000355327, 0, 0.904762, 0.372191, 0.000336122, 0, 0.936508, 0.356099, 0.000315247, 0, 0.968254, 0.340737, 0.00029794, 0, 1, 1, 0.000143327, 0, 0, 1, 0.00014333, 0, 0, 1, 0.000143366, 0, 0, 0.999999, 0.000143524, 0, 0, 0.999996, 0.000143952, 0, 0, 0.999991, 0.000144862, 0, 0, 0.999981, 0.000146544, 0, 0, 0.999966, 0.000149391, 0, 0, 0.999941, 0.000153946, 0, 0, 0.999905, 0.000160971, 0, 0, 0.999852, 0.000171562, 0, 0, 0.99978, 0.00018729, 0, 0, 0.999681, 0.000210386, 0, 8.26239e-05, 0.999546, 0.000243906, 0, 0.000664807, 0.999352, 0.000291739, 0, 0.00196192, 0.999027, 0.000357419, 0, 0.00405941, 0.997886, 0.000422349, 0, 0.00699664, 0.99419, 0.000385008, 0, 0.0107896, 0.99214, 0.000409775, 0, 0.0154415, 0.990274, 0.000456418, 0, 0.0209488, 0.988455, 0.000527008, 0, 0.0273037, 0.985804, 0.000597685, 0, 0.0344969, 0.98103, 0.000613124, 0, 0.0425183, 0.976674, 0.000668321, 0, 0.0513575, 0.972021, 0.000736985, 0, 0.0610046, 0.965274, 0.000773789, 0, 0.0714508, 0.958046, 0.000830852, 0, 0.0826877, 0.949333, 0.000875766, 0, 0.0947085, 0.939135, 0.000917088, 0, 0.107507, 0.927119, 0.000952244, 0, 0.121078, 0.91469, 0.000990626, 0, 0.135419, 0.903006, 0.00101304, 0, 0.150526, 0.892368, 0.00103834, 0, 0.166399, 0.880231, 0.00105002, 0, 0.183038, 0.867432, 0.00106331, 0, 0.200443, 0.853208, 0.00106783, 0, 0.218618, 0.837956, 0.00106458, 0, 0.237566, 0.821772, 0.00105945, 0, 0.257291, 0.804328, 0.00104685, 0, 0.2778, 0.786465, 0.00103178, 0, 0.2991, 0.768004, 0.00101077, 0, 0.321199, 0.74972, 0.000985504, 0, 0.344106, 0.731682, 0.000962893, 0, 0.36783, 0.712813, 0.000932146, 0, 0.392383, 0.693139, 0.00089871, 0, 0.417774, 0.673566, 0.000869678, 0, 0.444013, 0.653483, 0.000835525, 0, 0.471107, 0.633891, 0.000799853, 0, 0.49906, 0.614433, 0.000766838, 0, 0.527869, 0.594586, 0.000732227, 0, 0.557517, 0.574769, 0.000696442, 0, 0.587966, 0.555149, 0.000663935, 0, 0.61913, 0.535898, 0.000629826, 0, 0.650794, 0.516753, 0.000596486, 0, 0.68254, 0.497816, 0.000567078, 0, 0.714286, 0.479034, 0.000534399, 0, 0.746032, 0.460975, 0.000507013, 0, 0.777778, 0.442935, 0.000477421, 0, 0.809524, 0.425263, 0.000451101, 0, 0.84127, 0.408248, 0.000424964, 0, 0.873016, 0.391339, 0.00039993, 0, 0.904762, 0.37513, 0.000377619, 0, 0.936508, 0.359172, 0.000354418, 0, 0.968254, 0.343876, 0.000334823, 0, 1, 1, 0.000209042, 0, 0, 1, 0.000209045, 0, 0, 1, 0.000209093, 0, 0, 0.999999, 0.000209304, 0, 0, 0.999996, 0.000209871, 0, 0, 0.999991, 0.000211078, 0, 0, 0.999979, 0.000213304, 0, 0, 0.999963, 0.000217061, 0, 0, 0.999933, 0.000223042, 0, 0, 0.999894, 0.000232206, 0, 0, 0.999837, 0.000245901, 0, 0, 0.999756, 0.000266023, 0, 1.02927e-06, 0.999648, 0.000295204, 0, 0.000233468, 0.999499, 0.000336958, 0, 0.00108237, 0.999283, 0.000395563, 0, 0.00268832, 0.998896, 0.000473785, 0, 0.00511138, 0.997006, 0.000520008, 0, 0.00837705, 0.993819, 0.000497261, 0, 0.0124928, 0.991632, 0.000523722, 0, 0.0174561, 0.989875, 0.000587258, 0, 0.0232596, 0.988109, 0.000676329, 0, 0.0298932, 0.985155, 0.000747701, 0, 0.0373453, 0.980479, 0.000768803, 0, 0.0456045, 0.976271, 0.000841054, 0, 0.0546593, 0.971347, 0.000911469, 0, 0.0644994, 0.964528, 0.000953057, 0, 0.0751152, 0.957632, 0.00102221, 0, 0.0864981, 0.948681, 0.00106122, 0, 0.0986407, 0.938716, 0.00111857, 0, 0.111537, 0.926629, 0.00114762, 0, 0.125182, 0.914025, 0.00118995, 0, 0.139571, 0.901026, 0.00121228, 0, 0.154703, 0.890358, 0.00123946, 0, 0.170576, 0.878283, 0.0012527, 0, 0.18719, 0.865459, 0.00125536, 0, 0.204547, 0.851407, 0.00126134, 0, 0.222648, 0.836276, 0.00124759, 0, 0.241498, 0.820436, 0.00124443, 0, 0.261101, 0.803253, 0.00122071, 0, 0.281465, 0.785562, 0.00120107, 0, 0.302595, 0.76718, 0.00117762, 0, 0.324501, 0.748551, 0.00114289, 0, 0.347192, 0.730564, 0.00110872, 0, 0.370679, 0.712253, 0.00107636, 0, 0.394973, 0.692867, 0.00103646, 0, 0.420085, 0.673695, 0.000996793, 0, 0.446027, 0.653912, 0.00095675, 0, 0.47281, 0.634129, 0.000916739, 0, 0.500441, 0.615004, 0.000874401, 0, 0.528921, 0.595587, 0.000833411, 0, 0.558244, 0.575965, 0.000794556, 0, 0.588384, 0.5566, 0.00075196, 0, 0.619281, 0.537428, 0.000716381, 0, 0.650795, 0.518623, 0.000676558, 0, 0.68254, 0.499964, 0.00064074, 0, 0.714286, 0.481356, 0.000605984, 0, 0.746032, 0.463279, 0.000570256, 0, 0.777778, 0.445673, 0.000540138, 0, 0.809524, 0.428032, 0.000507299, 0, 0.84127, 0.411112, 0.000479553, 0, 0.873016, 0.394444, 0.000450737, 0, 0.904762, 0.378247, 0.000424269, 0, 0.936508, 0.362415, 0.000399111, 0, 0.968254, 0.347103, 0.000375274, 0, 1, 1, 0.000300729, 0, 0, 1, 0.000300733, 0, 0, 1, 0.000300797, 0, 0, 0.999998, 0.000301072, 0, 0, 0.999996, 0.000301817, 0, 0, 0.999989, 0.000303398, 0, 0, 0.999977, 0.000306309, 0, 0, 0.999958, 0.000311209, 0, 0, 0.999927, 0.000318975, 0, 0, 0.999884, 0.000330804, 0, 0, 0.99982, 0.00034834, 0, 0, 0.999733, 0.000373854, 0, 3.26995e-05, 0.999613, 0.000410424, 0, 0.000477174, 0.999447, 0.000462047, 0, 0.00161099, 0.999204, 0.000533322, 0, 0.00353153, 0.998725, 0.000624964, 0, 0.00627965, 0.995871, 0.000631786, 0, 0.0098693, 0.993194, 0.000632017, 0, 0.0143011, 0.991541, 0.00068923, 0, 0.019568, 0.989773, 0.000766892, 0, 0.0256593, 0.987647, 0.000863668, 0, 0.0325625, 0.984193, 0.000922089, 0, 0.0402647, 0.980016, 0.000970749, 0, 0.0487532, 0.975859, 0.00106027, 0, 0.058016, 0.970514, 0.00112239, 0, 0.0680419, 0.963625, 0.00117212, 0, 0.0788208, 0.956959, 0.00125211, 0, 0.0903439, 0.947956, 0.00129411, 0, 0.102604, 0.93809, 0.00135879, 0, 0.115594, 0.92659, 0.00139309, 0, 0.129309, 0.913829, 0.00143253, 0, 0.143745, 0.90005, 0.00145809, 0, 0.158901, 0.888129, 0.0014748, 0, 0.174774, 0.87607, 0.00148756, 0, 0.191365, 0.863461, 0.00148714, 0, 0.208674, 0.849594, 0.00148892, 0, 0.226705, 0.834531, 0.00146496, 0, 0.245461, 0.81903, 0.0014579, 0, 0.264947, 0.802122, 0.00143039, 0, 0.28517, 0.78445, 0.00139717, 0, 0.306137, 0.766434, 0.00136312, 0, 0.327857, 0.747816, 0.00132597, 0, 0.350341, 0.729519, 0.00128323, 0, 0.373598, 0.711454, 0.00123803, 0, 0.397642, 0.692699, 0.00119097, 0, 0.422485, 0.673723, 0.00114565, 0, 0.448139, 0.654386, 0.00109552, 0, 0.474619, 0.634673, 0.00104553, 0, 0.501933, 0.615554, 0.00099985, 0, 0.530089, 0.596462, 0.000948207, 0, 0.559087, 0.577385, 0.000902299, 0, 0.588913, 0.558257, 0.000856448, 0, 0.619525, 0.5392, 0.000810395, 0, 0.650826, 0.520543, 0.000768558, 0, 0.68254, 0.502206, 0.0007239, 0, 0.714286, 0.48402, 0.000685794, 0, 0.746032, 0.465779, 0.00064471, 0, 0.777778, 0.448455, 0.000609583, 0, 0.809524, 0.431091, 0.00057227, 0, 0.84127, 0.414147, 0.00054042, 0, 0.873016, 0.39765, 0.000506545, 0, 0.904762, 0.381576, 0.000477635, 0, 0.936508, 0.365881, 0.000448446, 0, 0.968254, 0.350582, 0.000421424, 0, 1, 1, 0.000427144, 0, 0, 1, 0.000427151, 0, 0, 1, 0.000427232, 0, 0, 0.999998, 0.00042759, 0, 0, 0.999995, 0.000428555, 0, 0, 0.999988, 0.000430603, 0, 0, 0.999976, 0.000434368, 0, 0, 0.999952, 0.000440688, 0, 0, 0.999919, 0.000450667, 0, 0, 0.999871, 0.00046578, 0, 0, 0.999801, 0.000488024, 0, 0, 0.999704, 0.000520092, 0, 0.000129791, 0.999572, 0.000565553, 0, 0.000821056, 0.999389, 0.000628906, 0, 0.00225241, 0.999114, 0.000714911, 0, 0.00449109, 0.998488, 0.000819218, 0, 0.00756249, 0.995234, 0.00080415, 0, 0.0114716, 0.993021, 0.000830181, 0, 0.0162131, 0.991407, 0.000902645, 0, 0.021776, 0.989625, 0.000996934, 0, 0.0281471, 0.987064, 0.00109707, 0, 0.0353118, 0.983265, 0.00114353, 0, 0.0432562, 0.979535, 0.0012272, 0, 0.0519665, 0.975224, 0.00132642, 0, 0.0614298, 0.969574, 0.00138092, 0, 0.0716348, 0.963021, 0.00145896, 0, 0.0825709, 0.956046, 0.00152834, 0, 0.094229, 0.947136, 0.00158217, 0, 0.106602, 0.937313, 0.0016347, 0, 0.119682, 0.926073, 0.00168383, 0, 0.133465, 0.913121, 0.00171627, 0, 0.147947, 0.899165, 0.00174229, 0, 0.163125, 0.885891, 0.00176137, 0, 0.178998, 0.873783, 0.00176406, 0, 0.195566, 0.861331, 0.00176156, 0, 0.21283, 0.847569, 0.00175346, 0, 0.230793, 0.832785, 0.00172753, 0, 0.249459, 0.817442, 0.00170204, 0, 0.268832, 0.800613, 0.00166576, 0, 0.28892, 0.783597, 0.00162909, 0, 0.30973, 0.76571, 0.0015826, 0, 0.331271, 0.747021, 0.00153106, 0, 0.353554, 0.728593, 0.00148036, 0, 0.37659, 0.710661, 0.00142808, 0, 0.400391, 0.692426, 0.00136906, 0, 0.424973, 0.673623, 0.00131066, 0, 0.450347, 0.65494, 0.00125569, 0, 0.476531, 0.635448, 0.00119517, 0, 0.503535, 0.616221, 0.00113828, 0, 0.531372, 0.597531, 0.0010816, 0, 0.560047, 0.578795, 0.00102673, 0, 0.589554, 0.559892, 0.000970985, 0, 0.619869, 0.541307, 0.000919773, 0, 0.650923, 0.522608, 0.000868479, 0, 0.68254, 0.504484, 0.00082137, 0, 0.714286, 0.486603, 0.000772916, 0, 0.746032, 0.468802, 0.000730353, 0, 0.777778, 0.451172, 0.000684955, 0, 0.809524, 0.434348, 0.000647565, 0, 0.84127, 0.417445, 0.000605863, 0, 0.873016, 0.401077, 0.000571885, 0, 0.904762, 0.385039, 0.000536034, 0, 0.936508, 0.369483, 0.000504227, 0, 0.968254, 0.354272, 0.000473165, 0, 1, 1, 0.000599525, 0, 0, 1, 0.000599533, 0, 0, 1, 0.000599639, 0, 0, 0.999998, 0.000600097, 0, 0, 0.999994, 0.000601336, 0, 0, 0.999987, 0.000603958, 0, 0, 0.999972, 0.000608775, 0, 0, 0.999949, 0.000616842, 0, 0, 0.999912, 0.000629534, 0, 0, 0.999857, 0.000648658, 0, 0, 0.999781, 0.000676615, 0, 5.38873e-06, 0.999674, 0.000716574, 0, 0.000308602, 0.999528, 0.000772641, 0, 0.00127003, 0.999326, 0.000849806, 0, 0.00300783, 0.999009, 0.000952682, 0, 0.00556637, 0.998112, 0.00106394, 0, 0.00895889, 0.994496, 0.00102228, 0, 0.0131827, 0.992806, 0.00108586, 0, 0.0182277, 0.991211, 0.0011759, 0, 0.0240795, 0.989415, 0.00128955, 0, 0.030723, 0.986499, 0.00139038, 0, 0.0381418, 0.982679, 0.00144539, 0, 0.046321, 0.978839, 0.00153954, 0, 0.0552459, 0.974295, 0.00164417, 0, 0.0649034, 0.968784, 0.00171517, 0, 0.0752814, 0.962324, 0.00180282, 0, 0.0863693, 0.954956, 0.00186387, 0, 0.0981578, 0.94624, 0.00193817, 0, 0.110639, 0.936517, 0.00198156, 0, 0.123806, 0.925186, 0.00203042, 0, 0.137655, 0.91252, 0.0020664, 0, 0.15218, 0.898441, 0.00207822, 0, 0.16738, 0.884394, 0.0020992, 0, 0.183253, 0.871273, 0.00208748, 0, 0.199799, 0.859057, 0.00208686, 0, 0.21702, 0.845243, 0.00205519, 0, 0.234918, 0.830723, 0.00202868, 0, 0.253496, 0.815801, 0.00199501, 0, 0.272761, 0.79914, 0.00194193, 0, 0.292719, 0.782372, 0.00188824, 0, 0.313377, 0.76482, 0.00183695, 0, 0.334745, 0.746586, 0.00177418, 0, 0.356833, 0.7281, 0.00170628, 0, 0.379654, 0.709842, 0.00164063, 0, 0.403221, 0.692019, 0.00157355, 0, 0.427548, 0.67364, 0.00150262, 0, 0.452651, 0.655277, 0.00143473, 0, 0.478545, 0.636438, 0.00136371, 0, 0.505246, 0.617364, 0.00129911, 0, 0.532768, 0.598603, 0.00123014, 0, 0.561122, 0.580195, 0.00116587, 0, 0.590309, 0.561786, 0.00110398, 0, 0.620318, 0.543377, 0.00104148, 0, 0.651102, 0.525093, 0.000983984, 0, 0.682545, 0.506791, 0.00092667, 0, 0.714286, 0.489291, 0.000874326, 0, 0.746032, 0.471811, 0.000821734, 0, 0.777778, 0.454435, 0.000774698, 0, 0.809524, 0.437493, 0.000727302, 0, 0.84127, 0.420977, 0.000684039, 0, 0.873016, 0.404729, 0.00064373, 0, 0.904762, 0.388756, 0.00060285, 0, 0.936508, 0.373344, 0.00056765, 0, 0.968254, 0.358191, 0.000531929, 0, 1, 1, 0.000832169, 0, 0, 1, 0.000832178, 0, 0, 1, 0.00083231, 0, 0, 0.999998, 0.000832893, 0, 0, 0.999995, 0.000834465, 0, 0, 0.999985, 0.000837791, 0, 0, 0.999969, 0.000843893, 0, 0, 0.999944, 0.000854086, 0, 0, 0.999903, 0.000870071, 0, 0, 0.999843, 0.000894042, 0, 0, 0.999759, 0.000928865, 0, 5.31805e-05, 0.999643, 0.000978242, 0, 0.000579365, 0.99948, 0.00104684, 0, 0.00182774, 0.999255, 0.00114012, 0, 0.00387804, 0.998885, 0.00126188, 0, 0.00675709, 0.997405, 0.00135888, 0, 0.010468, 0.99424, 0.00133626, 0, 0.0150018, 0.992458, 0.00140905, 0, 0.0203443, 0.990929, 0.00152305, 0, 0.0264786, 0.989116, 0.00165882, 0, 0.0333875, 0.985624, 0.00174128, 0, 0.0410536, 0.982003, 0.00182108, 0, 0.0494609, 0.978336, 0.00194498, 0, 0.0585941, 0.973184, 0.00202708, 0, 0.0684396, 0.9678, 0.00212166, 0, 0.0789851, 0.961348, 0.00221366, 0, 0.0902199, 0.953841, 0.00228219, 0, 0.102134, 0.94534, 0.00235662, 0, 0.114721, 0.935552, 0.00240572, 0, 0.127972, 0.924064, 0.00244405, 0, 0.141884, 0.911827, 0.00247557, 0, 0.156451, 0.897731, 0.00248374, 0, 0.171672, 0.883409, 0.00249863, 0, 0.187545, 0.868625, 0.00246688, 0, 0.20407, 0.856529, 0.00246523, 0, 0.221249, 0.842999, 0.00242368, 0, 0.239083, 0.828505, 0.00237354, 0, 0.257578, 0.813825, 0.00232588, 0, 0.276738, 0.797813, 0.00226731, 0, 0.296569, 0.781097, 0.00219704, 0, 0.31708, 0.764038, 0.00212394, 0, 0.338281, 0.746067, 0.00204786, 0, 0.360181, 0.727687, 0.00196728, 0, 0.382794, 0.709571, 0.00188779, 0, 0.406133, 0.691503, 0.00180532, 0, 0.430213, 0.673673, 0.00171849, 0, 0.45505, 0.655732, 0.00164147, 0, 0.480662, 0.637399, 0.00155858, 0, 0.507065, 0.618616, 0.00147641, 0, 0.534278, 0.60005, 0.00140125, 0, 0.562313, 0.581713, 0.00132441, 0, 0.59118, 0.563546, 0.00125014, 0, 0.620875, 0.545605, 0.00118249, 0, 0.651373, 0.527559, 0.0011116, 0, 0.682593, 0.509764, 0.00104979, 0, 0.714286, 0.49193, 0.000985977, 0, 0.746032, 0.475011, 0.000928592, 0, 0.777778, 0.457878, 0.000873466, 0, 0.809524, 0.440979, 0.000819585, 0, 0.84127, 0.424613, 0.000772365, 0, 0.873016, 0.408549, 0.000722195, 0, 0.904762, 0.392771, 0.000680014, 0, 0.936508, 0.377317, 0.000636797, 0, 0.968254, 0.362352, 0.000598318, 0, 1, 1, 0.00114313, 0, 0, 1, 0.00114314, 0, 0, 0.999999, 0.00114331, 0, 0, 0.999998, 0.00114404, 0, 0, 0.999994, 0.00114601, 0, 0, 0.999984, 0.00115019, 0, 0, 0.999967, 0.00115784, 0, 0, 0.999937, 0.0011706, 0, 0, 0.999894, 0.00119054, 0, 0, 0.999828, 0.00122031, 0, 0, 0.999735, 0.00126331, 0, 0.000169263, 0.999606, 0.00132382, 0, 0.000949167, 0.999426, 0.0014071, 0, 0.00249668, 0.999173, 0.00151895, 0, 0.00486392, 0.99873, 0.00166102, 0, 0.00806323, 0.996243, 0.0017023, 0, 0.0120895, 0.993779, 0.00172782, 0, 0.0169288, 0.9919, 0.0018108, 0, 0.0225633, 0.990524, 0.00196028, 0, 0.028974, 0.98868, 0.00212014, 0, 0.036142, 0.984663, 0.00217598, 0, 0.044049, 0.981457, 0.00230563, 0, 0.0526781, 0.977608, 0.00243966, 0, 0.0620137, 0.972215, 0.00251336, 0, 0.0720418, 0.966798, 0.0026285, 0, 0.0827499, 0.960241, 0.00271409, 0, 0.0941271, 0.952489, 0.00278381, 0, 0.106164, 0.944127, 0.00285399, 0, 0.118852, 0.934282, 0.00290994, 0, 0.132185, 0.923271, 0.00294558, 0, 0.146157, 0.910803, 0.00296269, 0, 0.160766, 0.896705, 0.00296803, 0, 0.176007, 0.88238, 0.00296637, 0, 0.19188, 0.867116, 0.00293163, 0, 0.208385, 0.853636, 0.00289418, 0, 0.225523, 0.840469, 0.00284663, 0, 0.243296, 0.82639, 0.00278594, 0, 0.261709, 0.811759, 0.00271618, 0, 0.280767, 0.796113, 0.00263187, 0, 0.300476, 0.779518, 0.00254589, 0, 0.320845, 0.763142, 0.00246003, 0, 0.341883, 0.745464, 0.00236529, 0, 0.363601, 0.727491, 0.00226536, 0, 0.386011, 0.709414, 0.00216375, 0, 0.409128, 0.691396, 0.00207127, 0, 0.432967, 0.67368, 0.00197106, 0, 0.457545, 0.656049, 0.00187022, 0, 0.482881, 0.638188, 0.00177605, 0, 0.508992, 0.620177, 0.00168482, 0, 0.535899, 0.601506, 0.00158909, 0, 0.563619, 0.58362, 0.00150583, 0, 0.592165, 0.565496, 0.00141791, 0, 0.621544, 0.54789, 0.00133693, 0, 0.651743, 0.530323, 0.00126038, 0, 0.682709, 0.512795, 0.00118556, 0, 0.714286, 0.495199, 0.00111527, 0, 0.746032, 0.478101, 0.0010489, 0, 0.777778, 0.461511, 0.000984264, 0, 0.809524, 0.444879, 0.00092591, 0, 0.84127, 0.428424, 0.000866582, 0, 0.873016, 0.412495, 0.000814463, 0, 0.904762, 0.396975, 0.000764498, 0, 0.936508, 0.381614, 0.000715967, 0, 0.968254, 0.366732, 0.000672483, 0, 1, 1, 0.00155501, 0, 0, 1, 0.00155503, 0, 0, 1, 0.00155524, 0, 0, 0.999998, 0.00155615, 0, 0, 0.999994, 0.0015586, 0, 0, 0.999983, 0.00156379, 0, 0, 0.999963, 0.0015733, 0, 0, 0.999932, 0.00158911, 0, 0, 0.999882, 0.00161376, 0, 0, 0.99981, 0.00165041, 0, 1.00875e-05, 0.999708, 0.00170304, 0, 0.000367658, 0.999565, 0.00177658, 0, 0.0014234, 0.999368, 0.00187688, 0, 0.00327939, 0.999081, 0.00200989, 0, 0.00596629, 0.99852, 0.00217177, 0, 0.0094852, 0.99549, 0.0021745, 0, 0.013824, 0.993252, 0.00222357, 0, 0.0189642, 0.991727, 0.00235022, 0, 0.0248856, 0.989951, 0.00250561, 0, 0.0315669, 0.988029, 0.00268829, 0, 0.0389882, 0.984029, 0.0027496, 0, 0.0471302, 0.980683, 0.00289793, 0, 0.0559754, 0.976554, 0.00303315, 0, 0.0655081, 0.97139, 0.00313257, 0, 0.0757138, 0.965544, 0.00323656, 0, 0.08658, 0.95912, 0.00333432, 0, 0.0980954, 0.951183, 0.0034039, 0, 0.110251, 0.942974, 0.00347515, 0, 0.123038, 0.932642, 0.00350381, 0, 0.13645, 0.922158, 0.00354519, 0, 0.150482, 0.909404, 0.00353851, 0, 0.165129, 0.896071, 0.0035435, 0, 0.18039, 0.881206, 0.00349936, 0, 0.196263, 0.866077, 0.00347256, 0, 0.212748, 0.85093, 0.003415, 0, 0.229847, 0.837703, 0.00333367, 0, 0.247561, 0.823878, 0.003249, 0, 0.265895, 0.809449, 0.00316347, 0, 0.284854, 0.794379, 0.00306351, 0, 0.304445, 0.778138, 0.0029499, 0, 0.324675, 0.761997, 0.00284099, 0, 0.345555, 0.744938, 0.00272104, 0, 0.367095, 0.727212, 0.00260715, 0, 0.389309, 0.709549, 0.00248855, 0, 0.41221, 0.691704, 0.00236783, 0, 0.435814, 0.673689, 0.00225178, 0, 0.460138, 0.656453, 0.00213765, 0, 0.485203, 0.639128, 0.00202178, 0, 0.511028, 0.621512, 0.00191443, 0, 0.537634, 0.603598, 0.00180977, 0, 0.565041, 0.58559, 0.00170456, 0, 0.593268, 0.567852, 0.00160927, 0, 0.622327, 0.5503, 0.00151395, 0, 0.652217, 0.533033, 0.00142499, 0, 0.682907, 0.515942, 0.00133955, 0, 0.714296, 0.498814, 0.0012602, 0, 0.746032, 0.481595, 0.00118188, 0, 0.777778, 0.465117, 0.00111171, 0, 0.809524, 0.448865, 0.00104091, 0, 0.84127, 0.432711, 0.000976618, 0, 0.873016, 0.416822, 0.00091859, 0, 0.904762, 0.401272, 0.000857704, 0, 0.936508, 0.386226, 0.000807172, 0, 0.968254, 0.371321, 0.00075464, 0, 1, 1, 0.00209596, 0, 0, 1, 0.00209598, 0, 0, 1, 0.00209624, 0, 0, 0.999997, 0.00209736, 0, 0, 0.999991, 0.00210039, 0, 0, 0.999979, 0.00210678, 0, 0, 0.999959, 0.00211847, 0, 0, 0.999925, 0.0021379, 0, 0, 0.99987, 0.00216809, 0, 0, 0.999791, 0.00221281, 0, 6.81487e-05, 0.999677, 0.00227669, 0, 0.000658161, 0.999521, 0.00236533, 0, 0.00200635, 0.999301, 0.00248514, 0, 0.0041779, 0.998977, 0.00264185, 0, 0.00718648, 0.998191, 0.00281695, 0, 0.0110239, 0.994801, 0.00278518, 0, 0.015672, 0.993091, 0.00288774, 0, 0.0211091, 0.991571, 0.00303931, 0, 0.0273123, 0.9897, 0.00321643, 0, 0.034259, 0.987023, 0.00337332, 0, 0.0419282, 0.983289, 0.00346146, 0, 0.0502998, 0.979892, 0.00363704, 0, 0.0593562, 0.975111, 0.00373601, 0, 0.069081, 0.970351, 0.0038842, 0, 0.0794598, 0.964131, 0.00397053, 0, 0.0904798, 0.957747, 0.00408078, 0, 0.10213, 0.949536, 0.00413533, 0, 0.1144, 0.941372, 0.00420305, 0, 0.127284, 0.931049, 0.00422815, 0, 0.140772, 0.920647, 0.00425048, 0, 0.154862, 0.908033, 0.0042281, 0, 0.169548, 0.895028, 0.00422026, 0, 0.184828, 0.879968, 0.00415042, 0, 0.200701, 0.864875, 0.00408821, 0, 0.217167, 0.84918, 0.00400909, 0, 0.234227, 0.834934, 0.00391178, 0, 0.251884, 0.821397, 0.00380066, 0, 0.270141, 0.807135, 0.00367974, 0, 0.289004, 0.792363, 0.00355172, 0, 0.308479, 0.776661, 0.003411, 0, 0.328575, 0.760705, 0.00328123, 0, 0.349301, 0.744408, 0.00314003, 0, 0.370668, 0.726994, 0.0029906, 0, 0.392689, 0.709598, 0.00285034, 0, 0.415379, 0.692112, 0.00271179, 0, 0.438754, 0.674435, 0.00257185, 0, 0.46283, 0.65676, 0.00243425, 0, 0.48763, 0.639982, 0.00230351, 0, 0.513173, 0.622983, 0.0021777, 0, 0.539482, 0.605471, 0.00204991, 0, 0.566579, 0.58796, 0.00193759, 0, 0.594488, 0.570463, 0.00181976, 0, 0.623226, 0.553058, 0.00171497, 0, 0.6528, 0.535894, 0.00161109, 0, 0.683198, 0.519089, 0.00151394, 0, 0.714354, 0.502454, 0.00142122, 0, 0.746032, 0.485681, 0.00133488, 0, 0.777778, 0.468935, 0.00124975, 0, 0.809524, 0.452951, 0.00117309, 0, 0.84127, 0.437139, 0.00110155, 0, 0.873016, 0.421446, 0.00103124, 0, 0.904762, 0.405951, 0.000966387, 0, 0.936508, 0.391003, 0.000908119, 0, 0.968254, 0.376198, 0.000848057, 0, 1, 1, 0.00280076, 0, 0, 1, 0.00280078, 0, 0, 0.999999, 0.00280109, 0, 0, 0.999997, 0.00280246, 0, 0, 0.999992, 0.00280616, 0, 0, 0.999979, 0.00281396, 0, 0, 0.999956, 0.00282822, 0, 0, 0.999916, 0.00285186, 0, 0, 0.999857, 0.0028885, 0, 0, 0.999768, 0.00294259, 0, 0.000196026, 0.999645, 0.00301946, 0, 0.00104842, 0.99947, 0.00312541, 0, 0.00270199, 0.999229, 0.00326733, 0, 0.00519449, 0.998852, 0.00344992, 0, 0.00852602, 0.997558, 0.00361052, 0, 0.0126804, 0.994417, 0.0035898, 0, 0.017635, 0.992824, 0.00372393, 0, 0.023365, 0.991344, 0.00390695, 0, 0.0298456, 0.989337, 0.00410392, 0, 0.0370529, 0.985811, 0.00420987, 0, 0.0449651, 0.982772, 0.00437488, 0, 0.0535615, 0.979001, 0.00455069, 0, 0.0628243, 0.974102, 0.00464462, 0, 0.0727368, 0.969197, 0.00480577, 0, 0.0832844, 0.962759, 0.00487818, 0, 0.0944545, 0.956207, 0.00498176, 0, 0.106236, 0.947909, 0.00503392, 0, 0.118619, 0.939596, 0.00507474, 0, 0.131595, 0.929642, 0.00509798, 0, 0.145159, 0.918807, 0.00508476, 0, 0.159305, 0.906921, 0.00505634, 0, 0.174028, 0.893312, 0.00498845, 0, 0.189327, 0.878933, 0.0049133, 0, 0.2052, 0.863986, 0.0048259, 0, 0.221647, 0.847936, 0.00470848, 0, 0.23867, 0.832253, 0.00456889, 0, 0.25627, 0.818619, 0.00442726, 0, 0.274453, 0.804788, 0.00427677, 0, 0.293222, 0.790241, 0.00411906, 0, 0.312585, 0.775162, 0.00394833, 0, 0.33255, 0.759463, 0.00377366, 0, 0.353126, 0.743598, 0.00361026, 0, 0.374324, 0.72697, 0.00343627, 0, 0.396158, 0.709646, 0.00326422, 0, 0.418641, 0.69277, 0.00309717, 0, 0.44179, 0.675371, 0.0029356, 0, 0.465624, 0.657863, 0.00277712, 0, 0.490163, 0.640772, 0.00261738, 0, 0.515429, 0.624441, 0.0024737, 0, 0.541445, 0.607497, 0.00233125, 0, 0.568236, 0.590438, 0.00218994, 0, 0.595828, 0.573224, 0.0020664, 0, 0.624242, 0.556168, 0.00193526, 0, 0.653496, 0.539232, 0.00182463, 0, 0.683588, 0.522352, 0.00170735, 0, 0.714482, 0.506172, 0.00160555, 0, 0.746032, 0.489842, 0.00150451, 0, 0.777778, 0.473463, 0.00140938, 0, 0.809524, 0.457266, 0.00132568, 0, 0.84127, 0.441609, 0.0012376, 0, 0.873016, 0.426348, 0.00116265, 0, 0.904762, 0.411002, 0.00108935, 0, 0.936508, 0.396045, 0.00101946, 0, 0.968254, 0.381448, 0.000955665, 0, 1, 1, 0.0037121, 0, 0, 1, 0.00371213, 0, 0, 1, 0.00371251, 0, 0, 0.999997, 0.00371417, 0, 0, 0.99999, 0.00371863, 0, 0, 0.999977, 0.00372807, 0, 0, 0.99995, 0.00374529, 0, 0, 0.999908, 0.0037738, 0, 0, 0.999843, 0.00381789, 0, 1.23596e-05, 0.999745, 0.00388273, 0, 0.000407442, 0.999608, 0.00397443, 0, 0.0015447, 0.999415, 0.00409998, 0, 0.00351385, 0.999143, 0.00426662, 0, 0.0063316, 0.9987, 0.00447625, 0, 0.00998679, 0.996363, 0.00455323, 0, 0.0144569, 0.994021, 0.00461052, 0, 0.0197151, 0.992372, 0.00476359, 0, 0.0257344, 0.991007, 0.00499101, 0, 0.0324882, 0.988767, 0.0051972, 0, 0.0399517, 0.984872, 0.00528407, 0, 0.0481022, 0.982004, 0.00548926, 0, 0.0569191, 0.977714, 0.00564385, 0, 0.0663839, 0.973076, 0.0057693, 0, 0.0764801, 0.967565, 0.0058924, 0, 0.0871928, 0.961384, 0.00599629, 0, 0.0985095, 0.954435, 0.00605998, 0, 0.110419, 0.946303, 0.0061133, 0, 0.122912, 0.937662, 0.00612028, 0, 0.13598, 0.927867, 0.00612209, 0, 0.149617, 0.916475, 0.00604813, 0, 0.163817, 0.90541, 0.00603088, 0, 0.178577, 0.891591, 0.00592218, 0, 0.193894, 0.877573, 0.00578854, 0, 0.209767, 0.862511, 0.00566648, 0, 0.226196, 0.846861, 0.00551481, 0, 0.243182, 0.83068, 0.00533754, 0, 0.260728, 0.815725, 0.00515487, 0, 0.278837, 0.802321, 0.0049655, 0, 0.297515, 0.787826, 0.00475421, 0, 0.316768, 0.773454, 0.00456002, 0, 0.336605, 0.758224, 0.00434727, 0, 0.357034, 0.74265, 0.00414444, 0, 0.378067, 0.726729, 0.00393738, 0, 0.399717, 0.710155, 0.00373575, 0, 0.421998, 0.693312, 0.00353736, 0, 0.444928, 0.67653, 0.00334368, 0, 0.468523, 0.659444, 0.00315981, 0, 0.492806, 0.642051, 0.00297809, 0, 0.517798, 0.625758, 0.00280592, 0, 0.543525, 0.609615, 0.00264254, 0, 0.570012, 0.592919, 0.00248459, 0, 0.597288, 0.576298, 0.00233327, 0, 0.625379, 0.559489, 0.00219519, 0, 0.654307, 0.542891, 0.00205441, 0, 0.684084, 0.526255, 0.00193385, 0, 0.714693, 0.509853, 0.00180745, 0, 0.746044, 0.494131, 0.00169817, 0, 0.777778, 0.478114, 0.0015913, 0, 0.809524, 0.462274, 0.00148981, 0, 0.84127, 0.446412, 0.00139537, 0, 0.873016, 0.431274, 0.00130984, 0, 0.904762, 0.41635, 0.00122403, 0, 0.936508, 0.401476, 0.00114809, 0, 0.968254, 0.386993, 0.00107563, 0, 1, 1, 0.00488216, 0, 0, 1, 0.0048822, 0, 0, 1, 0.00488265, 0, 0, 0.999997, 0.00488463, 0, 0, 0.999988, 0.00488999, 0, 0, 0.999974, 0.00490129, 0, 0, 0.999946, 0.00492191, 0, 0, 0.999897, 0.00495598, 0, 0, 0.999825, 0.00500855, 0, 7.44791e-05, 0.999718, 0.00508559, 0, 0.000712744, 0.999565, 0.005194, 0, 0.00215249, 0.999352, 0.00534147, 0, 0.00444576, 0.999046, 0.00553523, 0, 0.00759218, 0.998492, 0.00577016, 0, 0.0115714, 0.995564, 0.00578487, 0, 0.0163557, 0.993339, 0.00586414, 0, 0.021915, 0.991834, 0.00606002, 0, 0.0282201, 0.990496, 0.00633312, 0, 0.0352433, 0.987826, 0.00651941, 0, 0.042959, 0.98383, 0.00660842, 0, 0.0513439, 0.98109, 0.00685523, 0, 0.0603772, 0.976131, 0.00695778, 0, 0.0700402, 0.971922, 0.00714236, 0, 0.0803163, 0.965901, 0.00721437, 0, 0.0911908, 0.959606, 0.00732017, 0, 0.102651, 0.952504, 0.00735788, 0, 0.114686, 0.944365, 0.00738493, 0, 0.127286, 0.935652, 0.00737969, 0, 0.140443, 0.925813, 0.00733612, 0, 0.154151, 0.914397, 0.00723094, 0, 0.168405, 0.903257, 0.00714002, 0, 0.183201, 0.890015, 0.00700149, 0, 0.198536, 0.876014, 0.00682813, 0, 0.214409, 0.861436, 0.00665567, 0, 0.23082, 0.845752, 0.00644526, 0, 0.24777, 0.829169, 0.00621635, 0, 0.265263, 0.813435, 0.00597789, 0, 0.283301, 0.799701, 0.00575694, 0, 0.301889, 0.785726, 0.00549866, 0, 0.321035, 0.77152, 0.0052503, 0, 0.340746, 0.75683, 0.00499619, 0, 0.361032, 0.741951, 0.0047543, 0, 0.381904, 0.726367, 0.0045084, 0, 0.403374, 0.710537, 0.00426784, 0, 0.425457, 0.693965, 0.00403487, 0, 0.448169, 0.677724, 0.0038075, 0, 0.47153, 0.66117, 0.00359431, 0, 0.495561, 0.644274, 0.00338354, 0, 0.520284, 0.627449, 0.00318163, 0, 0.545725, 0.611645, 0.00299672, 0, 0.571911, 0.595614, 0.00281016, 0, 0.598873, 0.579426, 0.00264252, 0, 0.62664, 0.563016, 0.00247509, 0, 0.655239, 0.546728, 0.00232647, 0, 0.684692, 0.530539, 0.00217803, 0, 0.714999, 0.514164, 0.00204216, 0, 0.746106, 0.498344, 0.00191403, 0, 0.777778, 0.482957, 0.00179203, 0, 0.809524, 0.467336, 0.00167695, 0, 0.84127, 0.451994, 0.00157567, 0, 0.873016, 0.436514, 0.00147113, 0, 0.904762, 0.42178, 0.00138034, 0, 0.936508, 0.407271, 0.00129219, 0, 0.968254, 0.392822, 0.0012098, 0, 1, 1, 0.00637427, 0, 0, 1, 0.00637431, 0, 0, 0.999999, 0.00637485, 0, 0, 0.999996, 0.00637721, 0, 0, 0.999987, 0.00638357, 0, 0, 0.999971, 0.006397, 0, 0, 0.999939, 0.00642142, 0, 0, 0.999888, 0.00646177, 0, 0, 0.999807, 0.00652387, 0, 0.000207916, 0.999689, 0.00661454, 0, 0.00112051, 0.99952, 0.00674155, 0, 0.00287719, 0.999283, 0.00691313, 0, 0.00550145, 0.998936, 0.00713598, 0, 0.00897928, 0.998165, 0.00738501, 0, 0.0132829, 0.994847, 0.00734388, 0, 0.01838, 0.993182, 0.00749991, 0, 0.0242381, 0.991665, 0.0077246, 0, 0.030826, 0.989708, 0.00797579, 0, 0.0381152, 0.986663, 0.00813011, 0, 0.0460794, 0.983288, 0.00830365, 0, 0.0546951, 0.980104, 0.00853496, 0, 0.0639411, 0.974855, 0.00861045, 0, 0.0737988, 0.97045, 0.00879133, 0, 0.0842516, 0.964509, 0.00886377, 0, 0.0952848, 0.957594, 0.00890346, 0, 0.106886, 0.950546, 0.00893289, 0, 0.119044, 0.942225, 0.00890074, 0, 0.131749, 0.933365, 0.00886826, 0, 0.144994, 0.923202, 0.0087316, 0, 0.158772, 0.912605, 0.00863082, 0, 0.173078, 0.901099, 0.00847403, 0, 0.187908, 0.888177, 0.00825838, 0, 0.203261, 0.873955, 0.00801834, 0, 0.219134, 0.860091, 0.00779026, 0, 0.235527, 0.84434, 0.00752478, 0, 0.252443, 0.828517, 0.00724074, 0, 0.269883, 0.81239, 0.00693769, 0, 0.287851, 0.79721, 0.00664817, 0, 0.306352, 0.783489, 0.00634763, 0, 0.325393, 0.769514, 0.00604221, 0, 0.344981, 0.755419, 0.00573568, 0, 0.365126, 0.741083, 0.00544359, 0, 0.385839, 0.726059, 0.00515515, 0, 0.407132, 0.710809, 0.00487139, 0, 0.42902, 0.695052, 0.00459846, 0, 0.45152, 0.678886, 0.00433412, 0, 0.474651, 0.663042, 0.00407981, 0, 0.498433, 0.646634, 0.00384264, 0, 0.52289, 0.630117, 0.00360897, 0, 0.548048, 0.613804, 0.00338863, 0, 0.573936, 0.598338, 0.00318486, 0, 0.600584, 0.582687, 0.00298377, 0, 0.628027, 0.566809, 0.00280082, 0, 0.656295, 0.550817, 0.00262255, 0, 0.685417, 0.534937, 0.00245835, 0, 0.715406, 0.519151, 0.00230574, 0, 0.74624, 0.503118, 0.0021549, 0, 0.777778, 0.487723, 0.00202008, 0, 0.809524, 0.472725, 0.00189355, 0, 0.84127, 0.457599, 0.00177108, 0, 0.873016, 0.442558, 0.00165843, 0, 0.904762, 0.427624, 0.00155494, 0, 0.936508, 0.413171, 0.00145273, 0, 0.968254, 0.399122, 0.00136454, 0, 1, 1, 0.00826496, 0, 0, 1, 0.00826499, 0, 0, 1, 0.00826564, 0, 0, 0.999996, 0.00826842, 0, 0, 0.999987, 0.00827589, 0, 0, 0.999967, 0.00829167, 0, 0, 0.999933, 0.00832037, 0, 0, 0.999876, 0.00836768, 0, 1.09338e-05, 0.999786, 0.00844031, 0, 0.000427145, 0.999655, 0.00854603, 0, 0.0016384, 0.999468, 0.00869337, 0, 0.00372392, 0.999203, 0.008891, 0, 0.00668513, 0.998803, 0.00914387, 0, 0.0104968, 0.99748, 0.00935838, 0, 0.015125, 0.994446, 0.00933309, 0, 0.0205338, 0.99292, 0.00953084, 0, 0.0266884, 0.991414, 0.0097893, 0, 0.0335565, 0.989049, 0.0100228, 0, 0.0411086, 0.98582, 0.0101664, 0, 0.0493181, 0.982441, 0.0103582, 0, 0.0581613, 0.978595, 0.0105292, 0, 0.0676169, 0.973495, 0.0106274, 0, 0.0776661, 0.968405, 0.0107261, 0, 0.0882926, 0.962717, 0.0108234, 0, 0.0994817, 0.955478, 0.0108102, 0, 0.111221, 0.948275, 0.0107914, 0, 0.123499, 0.940006, 0.0107161, 0, 0.136308, 0.930831, 0.0106309, 0, 0.149639, 0.920648, 0.0104083, 0, 0.163485, 0.910205, 0.0102312, 0, 0.177843, 0.898445, 0.0100051, 0, 0.192707, 0.885986, 0.00971928, 0, 0.208077, 0.872204, 0.00940747, 0, 0.22395, 0.858436, 0.0091085, 0, 0.240326, 0.843454, 0.00876595, 0, 0.257208, 0.827437, 0.00839794, 0, 0.274596, 0.811488, 0.00803692, 0, 0.292496, 0.796039, 0.00767352, 0, 0.310911, 0.781083, 0.0073097, 0, 0.329849, 0.767642, 0.00694032, 0, 0.349316, 0.753901, 0.00657476, 0, 0.369323, 0.740131, 0.00622699, 0, 0.38988, 0.725845, 0.0058838, 0, 0.410999, 0.710991, 0.00555586, 0, 0.432696, 0.696002, 0.00523089, 0, 0.454987, 0.680461, 0.00492494, 0, 0.47789, 0.664875, 0.00463464, 0, 0.501426, 0.649273, 0.00435422, 0, 0.52562, 0.63302, 0.0040875, 0, 0.550498, 0.61705, 0.00384075, 0, 0.576089, 0.601154, 0.00359557, 0, 0.602427, 0.586008, 0.00337636, 0, 0.629544, 0.570699, 0.00316019, 0, 0.657479, 0.555166, 0.00296033, 0, 0.686264, 0.539645, 0.00277552, 0, 0.715924, 0.524159, 0.00259499, 0, 0.746459, 0.508682, 0.00243257, 0, 0.777789, 0.493163, 0.00227851, 0, 0.809524, 0.478004, 0.00213083, 0, 0.84127, 0.46347, 0.00199502, 0, 0.873016, 0.448778, 0.00186967, 0, 0.904762, 0.434105, 0.00174732, 0, 0.936508, 0.419576, 0.00163861, 0, 0.968254, 0.405541, 0.00153341, 0, 1, 1, 0.0106462, 0, 0, 1, 0.0106462, 0, 0, 0.999999, 0.010647, 0, 0, 0.999995, 0.0106502, 0, 0, 0.999985, 0.0106589, 0, 0, 0.999964, 0.0106773, 0, 0, 0.999925, 0.0107106, 0, 0, 0.999861, 0.0107655, 0, 7.12986e-05, 0.999763, 0.0108497, 0, 0.000743959, 0.999616, 0.0109716, 0, 0.00227361, 0.999408, 0.0111408, 0, 0.0046983, 0.999112, 0.0113659, 0, 0.00800158, 0.998637, 0.0116475, 0, 0.0121493, 0.996223, 0.0117231, 0, 0.0171023, 0.994006, 0.0118064, 0, 0.0228218, 0.992444, 0.0120254, 0, 0.0292711, 0.991028, 0.0123314, 0, 0.036417, 0.98803, 0.0124954, 0, 0.0442295, 0.984816, 0.0126538, 0, 0.0526815, 0.981399, 0.0128537, 0, 0.0617492, 0.977085, 0.0129694, 0, 0.0714114, 0.972154, 0.013091, 0, 0.0816495, 0.966617, 0.0131166, 0, 0.0924472, 0.960628, 0.0131583, 0, 0.10379, 0.953295, 0.0131094, 0, 0.115665, 0.94575, 0.0129966, 0, 0.128062, 0.937654, 0.0128796, 0, 0.140972, 0.927716, 0.0126477, 0, 0.154387, 0.917932, 0.0123889, 0, 0.168301, 0.907719, 0.012131, 0, 0.182709, 0.89584, 0.0118013, 0, 0.197608, 0.883526, 0.0114145, 0, 0.212994, 0.870301, 0.0110075, 0, 0.228867, 0.856272, 0.0106019, 0, 0.245227, 0.842251, 0.0101938, 0, 0.262074, 0.826466, 0.00973254, 0, 0.279412, 0.810859, 0.0092846, 0, 0.297244, 0.795051, 0.00883304, 0, 0.315575, 0.780053, 0.00840272, 0, 0.334412, 0.76575, 0.00796438, 0, 0.35376, 0.752298, 0.00752526, 0, 0.373631, 0.739153, 0.00711486, 0, 0.394034, 0.725514, 0.00670361, 0, 0.414983, 0.711473, 0.00632656, 0, 0.436491, 0.696936, 0.00595206, 0, 0.458575, 0.682126, 0.00559191, 0, 0.481253, 0.667027, 0.00525362, 0, 0.504547, 0.651875, 0.00493805, 0, 0.528481, 0.636463, 0.00462848, 0, 0.553081, 0.620641, 0.00433936, 0, 0.578377, 0.604931, 0.00407, 0, 0.604404, 0.589549, 0.00380864, 0, 0.631197, 0.574712, 0.00357049, 0, 0.658795, 0.559775, 0.00334466, 0, 0.687238, 0.544514, 0.00312505, 0, 0.716559, 0.529555, 0.00293199, 0, 0.746776, 0.514402, 0.00274204, 0, 0.777849, 0.499302, 0.00256647, 0, 0.809524, 0.484114, 0.00239901, 0, 0.84127, 0.469308, 0.00225148, 0, 0.873016, 0.455133, 0.00210178, 0, 0.904762, 0.440939, 0.0019727, 0, 0.936508, 0.426627, 0.00184382, 0, 0.968254, 0.412509, 0.00172548, 0, 1, 1, 0.013628, 0, 0, 1, 0.0136281, 0, 0, 0.999999, 0.0136289, 0, 0, 0.999995, 0.0136327, 0, 0, 0.999983, 0.0136427, 0, 0, 0.99996, 0.0136638, 0, 0, 0.999917, 0.0137022, 0, 0, 0.999846, 0.0137652, 0, 0.000204597, 0.999736, 0.0138615, 0, 0.00116837, 0.999573, 0.0140007, 0, 0.00303325, 0.99934, 0.0141927, 0, 0.00580613, 0.999004, 0.0144457, 0, 0.00945626, 0.998407, 0.0147489, 0, 0.0139421, 0.995464, 0.014731, 0, 0.0192202, 0.993328, 0.0148283, 0, 0.0252495, 0.991799, 0.0150797, 0, 0.0319921, 0.990397, 0.0154316, 0, 0.0394138, 0.986835, 0.0155005, 0, 0.0474843, 0.983938, 0.0157308, 0, 0.0561763, 0.980154, 0.0158753, 0, 0.0654661, 0.975659, 0.0159581, 0, 0.0753326, 0.970171, 0.0159832, 0, 0.0857571, 0.964803, 0.0160084, 0, 0.0967236, 0.958366, 0.0159484, 0, 0.108218, 0.950613, 0.0158001, 0, 0.120227, 0.942874, 0.0155845, 0, 0.132741, 0.935005, 0.0154292, 0, 0.145751, 0.924991, 0.0150742, 0, 0.159249, 0.914814, 0.0146757, 0, 0.17323, 0.904743, 0.0143097, 0, 0.187687, 0.893216, 0.0138695, 0, 0.202619, 0.880769, 0.0133706, 0, 0.218021, 0.868136, 0.0128606, 0, 0.233894, 0.85469, 0.0123403, 0, 0.250238, 0.840593, 0.0118091, 0, 0.267052, 0.825808, 0.011253, 0, 0.284341, 0.81009, 0.0107099, 0, 0.302106, 0.79504, 0.0101636, 0, 0.320354, 0.779757, 0.00964041, 0, 0.33909, 0.764697, 0.00911896, 0, 0.358322, 0.750913, 0.00859533, 0, 0.378059, 0.738175, 0.00811592, 0, 0.398311, 0.725242, 0.00764504, 0, 0.41909, 0.711864, 0.00718885, 0, 0.440412, 0.698009, 0.00675843, 0, 0.462292, 0.683841, 0.00634984, 0, 0.484748, 0.669391, 0.00595502, 0, 0.507802, 0.654731, 0.00558671, 0, 0.531477, 0.639805, 0.00523578, 0, 0.555802, 0.624789, 0.00490834, 0, 0.580805, 0.609325, 0.00459448, 0, 0.606522, 0.593975, 0.00430342, 0, 0.63299, 0.578983, 0.00403019, 0, 0.66025, 0.564442, 0.0037707, 0, 0.688346, 0.549835, 0.0035316, 0, 0.717319, 0.535039, 0.00330255, 0, 0.7472, 0.520403, 0.00308932, 0, 0.777982, 0.505687, 0.00289335, 0, 0.809524, 0.490939, 0.00270818, 0, 0.84127, 0.476233, 0.0025343, 0, 0.873016, 0.461624, 0.00237097, 0, 0.904762, 0.447833, 0.00222065, 0, 0.936508, 0.433992, 0.00207561, 0, 0.968254, 0.420147, 0.00194955, 0, 1, 1, 0.0173415, 0, 0, 1, 0.0173416, 0, 0, 0.999999, 0.0173426, 0, 0, 0.999995, 0.0173468, 0, 0, 0.999983, 0.0173582, 0, 0, 0.999954, 0.0173822, 0, 0, 0.999908, 0.0174258, 0, 6.69501e-06, 0.999828, 0.0174973, 0, 0.000427399, 0.999705, 0.0176063, 0, 0.00171019, 0.999524, 0.0177631, 0, 0.0039248, 0.999263, 0.0179781, 0, 0.00705382, 0.998878, 0.018258, 0, 0.0110552, 0.998012, 0.0185551, 0, 0.0158812, 0.994614, 0.0184264, 0, 0.0214852, 0.993132, 0.0186385, 0, 0.0278239, 0.991563, 0.0189067, 0, 0.0348585, 0.989298, 0.0191577, 0, 0.0425544, 0.986036, 0.0192522, 0, 0.050881, 0.982558, 0.0194063, 0, 0.059811, 0.978531, 0.019486, 0, 0.0693209, 0.974198, 0.0195847, 0, 0.0793895, 0.968148, 0.0194749, 0, 0.0899984, 0.962565, 0.0194277, 0, 0.101132, 0.956041, 0.0192991, 0, 0.112775, 0.947749, 0.0189893, 0, 0.124917, 0.94018, 0.018704, 0, 0.137547, 0.93165, 0.0183458, 0, 0.150655, 0.921798, 0.0178775, 0, 0.164236, 0.911573, 0.0173618, 0, 0.178281, 0.901569, 0.0168482, 0, 0.192788, 0.890341, 0.016265, 0, 0.207752, 0.877835, 0.0156199, 0, 0.223171, 0.865472, 0.0149516, 0, 0.239044, 0.852905, 0.0143274, 0, 0.255371, 0.838906, 0.0136643, 0, 0.272153, 0.824888, 0.0129903, 0, 0.289393, 0.809977, 0.0123218, 0, 0.307093, 0.794697, 0.0116572, 0, 0.325259, 0.780028, 0.0110307, 0, 0.343896, 0.765124, 0.0104236, 0, 0.363012, 0.750411, 0.0098219, 0, 0.382617, 0.737264, 0.00924397, 0, 0.402719, 0.724799, 0.00868719, 0, 0.423332, 0.712253, 0.00816476, 0, 0.444469, 0.699267, 0.00767262, 0, 0.466146, 0.685618, 0.00719746, 0, 0.488383, 0.671736, 0.00673916, 0, 0.511199, 0.657777, 0.00631937, 0, 0.534618, 0.643497, 0.00592411, 0, 0.558668, 0.62889, 0.00553928, 0, 0.58338, 0.614299, 0.0051934, 0, 0.608787, 0.599197, 0.00485985, 0, 0.634929, 0.584175, 0.00454357, 0, 0.661849, 0.569541, 0.00425787, 0, 0.689594, 0.555193, 0.00397905, 0, 0.718211, 0.540947, 0.00372364, 0, 0.747742, 0.526593, 0.00348599, 0, 0.778205, 0.512335, 0.00326103, 0, 0.80953, 0.498017, 0.00305137, 0, 0.84127, 0.483609, 0.00285485, 0, 0.873016, 0.469368, 0.00267472, 0, 0.904762, 0.455037, 0.00249945, 0, 0.936508, 0.441493, 0.00234792, 0, 0.968254, 0.428147, 0.00219936, 0, 1, 1, 0.0219422, 0, 0, 1, 0.0219423, 0, 0, 0.999998, 0.0219434, 0, 0, 0.999993, 0.0219481, 0, 0, 0.999981, 0.021961, 0, 0, 0.999949, 0.0219879, 0, 0, 0.999896, 0.0220367, 0, 5.93194e-05, 0.999808, 0.0221167, 0, 0.00075364, 0.99967, 0.0222383, 0, 0.00237884, 0.999466, 0.0224125, 0, 0.00495612, 0.999174, 0.0226495, 0, 0.00844887, 0.998725, 0.0229525, 0, 0.0128058, 0.996979, 0.0231123, 0, 0.0179742, 0.994317, 0.0230742, 0, 0.0239047, 0.992781, 0.0232895, 0, 0.0305526, 0.991191, 0.0235734, 0, 0.0378786, 0.987787, 0.0236152, 0, 0.0458475, 0.985092, 0.0237994, 0, 0.0544287, 0.981121, 0.0238553, 0, 0.0635952, 0.976924, 0.0238706, 0, 0.0733233, 0.97218, 0.0238704, 0, 0.0835922, 0.965956, 0.0236598, 0, 0.0943839, 0.959998, 0.0234735, 0, 0.105682, 0.953245, 0.0232277, 0, 0.117474, 0.944445, 0.0226973, 0, 0.129747, 0.937087, 0.0223527, 0, 0.142491, 0.928341, 0.0218144, 0, 0.155697, 0.9184, 0.0211516, 0, 0.169358, 0.907959, 0.0204553, 0, 0.183469, 0.89808, 0.0197673, 0, 0.198024, 0.887047, 0.0189915, 0, 0.21302, 0.875221, 0.0182082, 0, 0.228455, 0.86269, 0.0173584, 0, 0.244329, 0.850735, 0.0165718, 0, 0.260639, 0.837545, 0.0157524, 0, 0.277389, 0.823639, 0.0149482, 0, 0.29458, 0.809699, 0.0141431, 0, 0.312216, 0.794797, 0.0133527, 0, 0.3303, 0.780578, 0.0126193, 0, 0.34884, 0.766019, 0.0118914, 0, 0.367842, 0.751447, 0.0111839, 0, 0.387315, 0.737275, 0.010514, 0, 0.40727, 0.724545, 0.00987277, 0, 0.427717, 0.712644, 0.00926569, 0, 0.448671, 0.700432, 0.00869029, 0, 0.470149, 0.687664, 0.00814691, 0, 0.492167, 0.674288, 0.00763012, 0, 0.514746, 0.660966, 0.00714437, 0, 0.537911, 0.647264, 0.00668457, 0, 0.561688, 0.633431, 0.00626581, 0, 0.586108, 0.619133, 0.00585593, 0, 0.611206, 0.604935, 0.00548188, 0, 0.637022, 0.590236, 0.00513288, 0, 0.663599, 0.575473, 0.0047906, 0, 0.690989, 0.561228, 0.00448895, 0, 0.719242, 0.547054, 0.00420233, 0, 0.748411, 0.533175, 0.00392869, 0, 0.778531, 0.519163, 0.00367445, 0, 0.809583, 0.505328, 0.00344097, 0, 0.84127, 0.491446, 0.00322003, 0, 0.873016, 0.477356, 0.00301283, 0, 0.904762, 0.46356, 0.00282592, 0, 0.936508, 0.449623, 0.00264956, 0, 0.968254, 0.436068, 0.00246956, 0, 1, 1, 0.0276135, 0, 0, 1, 0.0276136, 0, 0, 0.999998, 0.0276148, 0, 0, 0.999993, 0.0276201, 0, 0, 0.999976, 0.0276342, 0, 0, 0.999945, 0.027664, 0, 0, 0.999884, 0.0277179, 0, 0.00018679, 0.999784, 0.027806, 0, 0.00119607, 0.99963, 0.0279394, 0, 0.00318407, 0.999401, 0.0281295, 0, 0.00613601, 0.999066, 0.0283858, 0, 0.00999963, 0.998524, 0.0287027, 0, 0.0147164, 0.995702, 0.0286256, 0, 0.0202295, 0.993593, 0.0286733, 0, 0.0264876, 0.992067, 0.0288989, 0, 0.0334452, 0.990548, 0.0292135, 0, 0.0410621, 0.986775, 0.0291296, 0, 0.0493032, 0.984054, 0.0293099, 0, 0.0581381, 0.979481, 0.0291881, 0, 0.0675397, 0.975297, 0.0291598, 0, 0.0774848, 0.96981, 0.028954, 0, 0.0879528, 0.963524, 0.028628, 0, 0.0989258, 0.957398, 0.0283135, 0, 0.110388, 0.950088, 0.0278469, 0, 0.122327, 0.941538, 0.0271798, 0, 0.134729, 0.933332, 0.0265388, 0, 0.147587, 0.924392, 0.0257776, 0, 0.160889, 0.914581, 0.024916, 0, 0.174631, 0.904347, 0.0240242, 0, 0.188806, 0.894324, 0.0231229, 0, 0.203409, 0.883724, 0.022153, 0, 0.218437, 0.872207, 0.0211355, 0, 0.233888, 0.859927, 0.0201048, 0, 0.249761, 0.848373, 0.0191263, 0, 0.266056, 0.836023, 0.0181306, 0, 0.282774, 0.82289, 0.0171718, 0, 0.299917, 0.809324, 0.0162196, 0, 0.317488, 0.795361, 0.0152622, 0, 0.335493, 0.781253, 0.01439, 0, 0.353936, 0.767338, 0.013533, 0, 0.372825, 0.753156, 0.0127244, 0, 0.392168, 0.739122, 0.0119454, 0, 0.411976, 0.725358, 0.0112054, 0, 0.432259, 0.712949, 0.010487, 0, 0.453032, 0.701621, 0.00984032, 0, 0.47431, 0.689703, 0.00921495, 0, 0.496111, 0.677216, 0.00862492, 0, 0.518456, 0.664217, 0.00806882, 0, 0.541367, 0.65137, 0.00755922, 0, 0.564872, 0.638, 0.00705705, 0, 0.589001, 0.62453, 0.00661266, 0, 0.613789, 0.610601, 0.00618432, 0, 0.639277, 0.59676, 0.00578033, 0, 0.66551, 0.582433, 0.00540927, 0, 0.692539, 0.568026, 0.00506104, 0, 0.720422, 0.55414, 0.0047353, 0, 0.749216, 0.540178, 0.00442889, 0, 0.778974, 0.526513, 0.00414363, 0, 0.809711, 0.512954, 0.00388237, 0, 0.84127, 0.499403, 0.00362875, 0, 0.873016, 0.486026, 0.00340827, 0, 0.904762, 0.472345, 0.00318598, 0, 0.936508, 0.458828, 0.00297635, 0, 0.968254, 0.445379, 0.00279447, 0, 1, 1, 0.0345716, 0, 0, 1, 0.0345717, 0, 0, 0.999999, 0.034573, 0, 0, 0.999991, 0.0345787, 0, 0, 0.999974, 0.0345941, 0, 0, 0.999937, 0.0346263, 0, 1.88589e-06, 0.999869, 0.0346847, 0, 0.000409238, 0.999757, 0.0347798, 0, 0.0017674, 0.999582, 0.0349233, 0, 0.00413658, 0.999322, 0.0351265, 0, 0.00747408, 0.998939, 0.0353967, 0, 0.0117157, 0.998219, 0.0357018, 0, 0.0167966, 0.994974, 0.0354726, 0, 0.0226572, 0.993201, 0.0355621, 0, 0.0292445, 0.991573, 0.0357641, 0, 0.0365123, 0.989301, 0.0359252, 0, 0.0444203, 0.985712, 0.0358017, 0, 0.0529334, 0.982411, 0.0358353, 0, 0.0620214, 0.977827, 0.035617, 0, 0.0716574, 0.973278, 0.0354398, 0, 0.0818186, 0.967397, 0.0350483, 0, 0.0924846, 0.960696, 0.0344795, 0, 0.103638, 0.954349, 0.0339861, 0, 0.115263, 0.946066, 0.0331323, 0, 0.127348, 0.938012, 0.032359, 0, 0.13988, 0.929413, 0.0314413, 0, 0.152849, 0.920355, 0.0304103, 0, 0.166248, 0.910586, 0.0292785, 0, 0.18007, 0.900609, 0.0281391, 0, 0.194308, 0.890093, 0.0269103, 0, 0.208958, 0.880013, 0.0257269, 0, 0.224018, 0.869001, 0.0244671, 0, 0.239485, 0.85751, 0.0232252, 0, 0.255359, 0.84582, 0.0220117, 0, 0.271638, 0.834383, 0.0208274, 0, 0.288324, 0.822158, 0.0196628, 0, 0.305419, 0.809056, 0.0185306, 0, 0.322927, 0.795832, 0.0174174, 0, 0.340851, 0.782547, 0.0163758, 0, 0.359199, 0.7689, 0.015391, 0, 0.377975, 0.755526, 0.0144488, 0, 0.397189, 0.741681, 0.0135372, 0, 0.416851, 0.728178, 0.0126957, 0, 0.436971, 0.714642, 0.0118812, 0, 0.457564, 0.702756, 0.0111165, 0, 0.478644, 0.69175, 0.0104145, 0, 0.500229, 0.680159, 0.00974439, 0, 0.522339, 0.668073, 0.00911926, 0, 0.544997, 0.655405, 0.00851393, 0, 0.56823, 0.642921, 0.00797637, 0, 0.592068, 0.629993, 0.00745119, 0, 0.616546, 0.616828, 0.00696972, 0, 0.641705, 0.603305, 0.00652425, 0, 0.66759, 0.589833, 0.00610188, 0, 0.694255, 0.575945, 0.00570834, 0, 0.72176, 0.561745, 0.00533384, 0, 0.750168, 0.548277, 0.00500001, 0, 0.779545, 0.534467, 0.00467582, 0, 0.809933, 0.521032, 0.00438092, 0, 0.841272, 0.507877, 0.00410348, 0, 0.873016, 0.494654, 0.00383618, 0, 0.904762, 0.481592, 0.00358699, 0, 0.936508, 0.468509, 0.00337281, 0, 0.968254, 0.455293, 0.00316196, 0, 1, 1, 0.0430698, 0, 0, 1, 0.0430699, 0, 0, 0.999998, 0.0430713, 0, 0, 0.999991, 0.0430773, 0, 0, 0.99997, 0.0430936, 0, 0, 0.999928, 0.0431277, 0, 4.06396e-05, 0.999852, 0.0431893, 0, 0.000744376, 0.999724, 0.0432895, 0, 0.0024806, 0.999527, 0.0434397, 0, 0.00524779, 0.99923, 0.0436507, 0, 0.00898164, 0.998783, 0.0439255, 0, 0.0136083, 0.997507, 0.0441104, 0, 0.0190582, 0.994418, 0.0438225, 0, 0.0252694, 0.992864, 0.0439396, 0, 0.0321879, 0.991127, 0.0440962, 0, 0.039767, 0.987331, 0.0438408, 0, 0.0479667, 0.984819, 0.0438991, 0, 0.056752, 0.980384, 0.0435906, 0, 0.0660929, 0.975846, 0.0432543, 0, 0.075963, 0.970748, 0.0428293, 0, 0.0863398, 0.964303, 0.042153, 0, 0.0972035, 0.95772, 0.0414111, 0, 0.108537, 0.950747, 0.0405893, 0, 0.120325, 0.942533, 0.0394887, 0, 0.132554, 0.934045, 0.0383544, 0, 0.145215, 0.924942, 0.037057, 0, 0.158296, 0.915811, 0.0356993, 0, 0.17179, 0.90612, 0.0342401, 0, 0.185691, 0.896434, 0.0328078, 0, 0.199993, 0.886021, 0.031288, 0, 0.214691, 0.876081, 0.0297776, 0, 0.229782, 0.865608, 0.0282334, 0, 0.245265, 0.854924, 0.026749, 0, 0.261138, 0.843607, 0.02526, 0, 0.277401, 0.832456, 0.0238214, 0, 0.294056, 0.821342, 0.0224682, 0, 0.311104, 0.809303, 0.0211297, 0, 0.328548, 0.796468, 0.0198387, 0, 0.346394, 0.784046, 0.0186227, 0, 0.364645, 0.771262, 0.0174561, 0, 0.38331, 0.758118, 0.0163806, 0, 0.402396, 0.745075, 0.0153287, 0, 0.421912, 0.731926, 0.0143647, 0, 0.44187, 0.71863, 0.0134363, 0, 0.462283, 0.705414, 0.0125603, 0, 0.483165, 0.693792, 0.0117508, 0, 0.504535, 0.683108, 0.0110016, 0, 0.52641, 0.67183, 0.0102757, 0, 0.548816, 0.66015, 0.00962044, 0, 0.571776, 0.647907, 0.00898031, 0, 0.595323, 0.635734, 0.00840811, 0, 0.619489, 0.623208, 0.00786211, 0, 0.644317, 0.610438, 0.00734953, 0, 0.669852, 0.597345, 0.00687688, 0, 0.696148, 0.584138, 0.00643469, 0, 0.723267, 0.5707, 0.00602236, 0, 0.75128, 0.556966, 0.0056324, 0, 0.780258, 0.543607, 0.00528277, 0, 0.810268, 0.530213, 0.00493999, 0, 0.841311, 0.516912, 0.00462265, 0, 0.873016, 0.503916, 0.0043307, 0, 0.904762, 0.491146, 0.00406858, 0, 0.936508, 0.478439, 0.00381436, 0, 0.968254, 0.465834, 0.00358003, 0, 1, 1, 0.0534039, 0, 0, 1, 0.053404, 0, 0, 0.999998, 0.0534055, 0, 0, 0.999989, 0.0534116, 0, 0, 0.999968, 0.0534283, 0, 0, 0.999918, 0.0534633, 0, 0.000155895, 0.99983, 0.0535262, 0, 0.00120914, 0.999685, 0.0536281, 0, 0.00334944, 0.999461, 0.0537799, 0, 0.00653077, 0.999119, 0.0539902, 0, 0.0106718, 0.998582, 0.0542524, 0, 0.0156907, 0.995919, 0.0540318, 0, 0.0215147, 0.993735, 0.0538914, 0, 0.0280801, 0.992126, 0.0539557, 0, 0.0353323, 0.990266, 0.0540401, 0, 0.0432247, 0.986317, 0.0536064, 0, 0.0517172, 0.983213, 0.0534425, 0, 0.0607754, 0.978303, 0.0528622, 0, 0.0703698, 0.973665, 0.0523363, 0, 0.0804742, 0.968091, 0.0516165, 0, 0.0910667, 0.961026, 0.0505434, 0, 0.102128, 0.954333, 0.049523, 0, 0.113641, 0.946372, 0.0481698, 0, 0.125591, 0.938254, 0.0467674, 0, 0.137965, 0.929516, 0.0452341, 0, 0.150754, 0.920106, 0.0435083, 0, 0.163947, 0.910899, 0.0417399, 0, 0.177537, 0.901532, 0.0399389, 0, 0.191516, 0.891919, 0.0380901, 0, 0.205881, 0.882006, 0.0362341, 0, 0.220626, 0.871965, 0.0343444, 0, 0.235749, 0.862145, 0.0324832, 0, 0.251248, 0.852058, 0.0306681, 0, 0.267121, 0.84161, 0.0289097, 0, 0.283368, 0.830806, 0.0272079, 0, 0.299992, 0.820476, 0.0256089, 0, 0.316992, 0.809514, 0.0240394, 0, 0.334374, 0.797865, 0.0225379, 0, 0.35214, 0.785621, 0.0211235, 0, 0.370296, 0.773765, 0.0197908, 0, 0.388849, 0.761629, 0.0185235, 0, 0.407807, 0.748891, 0.0173358, 0, 0.427178, 0.736437, 0.0162305, 0, 0.446974, 0.723707, 0.0151778, 0, 0.467207, 0.710606, 0.0141791, 0, 0.487892, 0.698019, 0.0132592, 0, 0.509046, 0.686203, 0.0123887, 0, 0.530687, 0.675692, 0.0115976, 0, 0.552839, 0.664826, 0.0108325, 0, 0.575527, 0.65349, 0.0101348, 0, 0.59878, 0.641774, 0.00947756, 0, 0.622634, 0.629794, 0.00886058, 0, 0.647128, 0.617647, 0.00828526, 0, 0.672308, 0.60534, 0.00775312, 0, 0.698231, 0.592718, 0.00726033, 0, 0.724958, 0.579746, 0.00679731, 0, 0.752563, 0.566763, 0.00636111, 0, 0.781127, 0.553515, 0.00595228, 0, 0.810733, 0.540118, 0.00556876, 0, 0.841426, 0.527325, 0.00523051, 0, 0.873016, 0.514265, 0.00490712, 0, 0.904762, 0.501406, 0.00460297, 0, 0.936508, 0.488922, 0.00431247, 0, 0.968254, 0.476541, 0.0040472, 0, 1, 1, 0.0659184, 0, 0, 1, 0.0659185, 0, 0, 0.999998, 0.06592, 0, 0, 0.999988, 0.0659259, 0, 0, 0.999963, 0.0659423, 0, 0, 0.999907, 0.0659764, 0, 0.000374198, 0.999806, 0.0660376, 0, 0.00182071, 0.999639, 0.0661361, 0, 0.0043894, 0.999378, 0.0662814, 0, 0.00800055, 0.998985, 0.0664779, 0, 0.0125594, 0.998285, 0.0666914, 0, 0.0179786, 0.995071, 0.0661989, 0, 0.0241822, 0.993172, 0.0660454, 0, 0.031106, 0.991438, 0.0660105, 0, 0.0386952, 0.988428, 0.0656875, 0, 0.0469032, 0.985218, 0.0652913, 0, 0.0556905, 0.981128, 0.0647107, 0, 0.065023, 0.976015, 0.0638491, 0, 0.0748717, 0.97097, 0.062993, 0, 0.0852112, 0.964582, 0.0617927, 0, 0.0960199, 0.957383, 0.0603626, 0, 0.107279, 0.949969, 0.0588128, 0, 0.118971, 0.941843, 0.0570274, 0, 0.131084, 0.933624, 0.0551885, 0, 0.143604, 0.924543, 0.053122, 0, 0.156521, 0.914919, 0.0508897, 0, 0.169825, 0.905773, 0.0486418, 0, 0.18351, 0.896434, 0.0463364, 0, 0.197569, 0.887195, 0.0440623, 0, 0.211997, 0.877706, 0.0417799, 0, 0.226789, 0.867719, 0.03945, 0, 0.241944, 0.858587, 0.037243, 0, 0.257458, 0.849317, 0.0350956, 0, 0.273331, 0.839585, 0.0329852, 0, 0.289563, 0.829856, 0.0310028, 0, 0.306154, 0.819589, 0.0290953, 0, 0.323108, 0.809714, 0.0272738, 0, 0.340426, 0.79934, 0.0255631, 0, 0.358113, 0.788224, 0.0239175, 0, 0.376175, 0.776619, 0.0223831, 0, 0.394616, 0.76521, 0.0209298, 0, 0.413445, 0.753716, 0.0195786, 0, 0.432671, 0.741564, 0.0183001, 0, 0.452305, 0.729413, 0.0171259, 0, 0.472358, 0.717146, 0.0159933, 0, 0.492845, 0.70436, 0.0149495, 0, 0.513783, 0.69219, 0.0139681, 0, 0.535189, 0.680289, 0.0130577, 0, 0.557087, 0.669611, 0.0122198, 0, 0.5795, 0.659113, 0.0114174, 0, 0.602459, 0.648148, 0.0106729, 0, 0.625997, 0.636905, 0.00998997, 0, 0.650154, 0.625154, 0.00934313, 0, 0.674976, 0.613481, 0.00874839, 0, 0.700518, 0.60154, 0.00818265, 0, 0.726845, 0.58943, 0.00766889, 0, 0.754032, 0.576828, 0.00717153, 0, 0.782167, 0.564194, 0.00672696, 0, 0.811344, 0.551501, 0.00630863, 0, 0.841644, 0.538635, 0.00592177, 0, 0.873016, 0.525724, 0.00554888, 0, 0.904762, 0.513209, 0.00520225, 0, 0.936508, 0.500457, 0.00488231, 0, 0.968254, 0.48799, 0.00457153, 0, 1, 1, 0.0810131, 0, 0, 1, 0.0810133, 0, 0, 0.999997, 0.0810145, 0, 0, 0.999985, 0.08102, 0, 0, 0.999956, 0.0810347, 0, 1.95026e-05, 0.999893, 0.0810656, 0, 0.000719316, 0.999777, 0.0811205, 0, 0.00259774, 0.999583, 0.081208, 0, 0.00561807, 0.999281, 0.0813343, 0, 0.00967472, 0.998813, 0.0814969, 0, 0.0146627, 0.997597, 0.0815217, 0, 0.0204902, 0.994379, 0.0808502, 0, 0.0270802, 0.992744, 0.0806792, 0, 0.0343674, 0.990745, 0.0804589, 0, 0.0422974, 0.986646, 0.0796107, 0, 0.0508242, 0.983611, 0.0790913, 0, 0.0599087, 0.978869, 0.0780746, 0, 0.0695175, 0.973475, 0.0768218, 0, 0.0796223, 0.967845, 0.0754926, 0, 0.0901983, 0.960778, 0.0737063, 0, 0.101224, 0.953333, 0.0718052, 0, 0.112682, 0.945274, 0.0695946, 0, 0.124555, 0.936955, 0.0672492, 0, 0.136831, 0.928319, 0.0647732, 0, 0.149496, 0.919075, 0.0620947, 0, 0.162542, 0.909114, 0.0591816, 0, 0.175958, 0.900137, 0.0563917, 0, 0.189739, 0.891069, 0.0535392, 0, 0.203877, 0.882262, 0.0507642, 0, 0.218368, 0.873232, 0.0479793, 0, 0.233208, 0.864042, 0.045226, 0, 0.248393, 0.855002, 0.0425413, 0, 0.263923, 0.846569, 0.0400126, 0, 0.279796, 0.837714, 0.0375269, 0, 0.296012, 0.828918, 0.0352027, 0, 0.312573, 0.819783, 0.0330011, 0, 0.329479, 0.810129, 0.0308908, 0, 0.346734, 0.800866, 0.0289112, 0, 0.364342, 0.79093, 0.0270255, 0, 0.382307, 0.780593, 0.0252758, 0, 0.400637, 0.769511, 0.0236178, 0, 0.419337, 0.758558, 0.0220652, 0, 0.438418, 0.747632, 0.0206289, 0, 0.457889, 0.736146, 0.0192873, 0, 0.477761, 0.724093, 0.0180333, 0, 0.49805, 0.71234, 0.0168264, 0, 0.51877, 0.700201, 0.015746, 0, 0.53994, 0.687949, 0.0147027, 0, 0.561581, 0.676163, 0.0137512, 0, 0.583718, 0.665001, 0.0128655, 0, 0.60638, 0.65472, 0.0120366, 0, 0.629599, 0.644213, 0.0112604, 0, 0.653415, 0.633382, 0.0105413, 0, 0.677874, 0.62212, 0.00986498, 0, 0.70303, 0.610631, 0.00923308, 0, 0.728948, 0.599078, 0.00864206, 0, 0.755706, 0.587519, 0.00811784, 0, 0.783396, 0.575505, 0.00761237, 0, 0.812121, 0.563148, 0.00713949, 0, 0.841989, 0.550828, 0.00668379, 0, 0.873035, 0.538458, 0.00627715, 0, 0.904762, 0.525905, 0.00588336, 0, 0.936508, 0.513517, 0.00552687, 0, 0.968254, 0.501395, 0.00519681, 0, 1, 1, 0.0991506, 0, 0, 1, 0.0991504, 0, 0, 0.999996, 0.0991515, 0, 0, 0.999984, 0.0991558, 0, 0, 0.999947, 0.0991672, 0, 0.000114389, 0.999874, 0.0991912, 0, 0.00121503, 0.999739, 0.0992331, 0, 0.00356108, 0.999514, 0.0992983, 0, 0.00705578, 0.999159, 0.0993877, 0, 0.011574, 0.998586, 0.0994837, 0, 0.017003, 0.995731, 0.0988425, 0, 0.0232484, 0.993384, 0.098276, 0, 0.0302318, 0.991615, 0.0979269, 0, 0.0378884, 0.989029, 0.0973432, 0, 0.0461641, 0.985373, 0.0963539, 0, 0.0550136, 0.981278, 0.0952306, 0, 0.0643988, 0.975777, 0.0936233, 0, 0.0742868, 0.970526, 0.0920219, 0, 0.0846501, 0.963755, 0.0898912, 0, 0.0954644, 0.956676, 0.0876064, 0, 0.106709, 0.948099, 0.0847751, 0, 0.118367, 0.939718, 0.0818638, 0, 0.130423, 0.931305, 0.078857, 0, 0.142862, 0.922342, 0.0756127, 0, 0.155674, 0.912842, 0.0721473, 0, 0.168849, 0.903304, 0.0686195, 0, 0.182378, 0.89411, 0.0650589, 0, 0.196255, 0.885512, 0.0616022, 0, 0.210473, 0.877193, 0.0582434, 0, 0.225027, 0.86877, 0.0548979, 0, 0.239915, 0.860267, 0.0516095, 0, 0.255132, 0.851915, 0.048468, 0, 0.270678, 0.843912, 0.0454447, 0, 0.286551, 0.83604, 0.0425612, 0, 0.302751, 0.828245, 0.0398752, 0, 0.31928, 0.820159, 0.0373198, 0, 0.336138, 0.81167, 0.034916, 0, 0.35333, 0.802659, 0.0326402, 0, 0.370858, 0.793921, 0.0304901, 0, 0.388728, 0.784713, 0.0284857, 0, 0.406944, 0.774946, 0.0266186, 0, 0.425515, 0.76448, 0.0248593, 0, 0.444449, 0.753793, 0.0232114, 0, 0.463756, 0.743506, 0.0217039, 0, 0.483447, 0.732555, 0.0202841, 0, 0.503535, 0.720965, 0.0189648, 0, 0.524036, 0.709422, 0.0177189, 0, 0.544968, 0.697756, 0.0165626, 0, 0.56635, 0.685565, 0.015483, 0, 0.588208, 0.673987, 0.0144892, 0, 0.610569, 0.66244, 0.0135607, 0, 0.633466, 0.651675, 0.0126956, 0, 0.656936, 0.641598, 0.0118788, 0, 0.681025, 0.63121, 0.0111261, 0, 0.705788, 0.620514, 0.010437, 0, 0.731289, 0.609366, 0.00978747, 0, 0.757606, 0.598137, 0.00917257, 0, 0.784834, 0.586966, 0.00859778, 0, 0.813085, 0.575549, 0.00806803, 0, 0.842485, 0.563797, 0.00757294, 0, 0.87313, 0.551758, 0.00710592, 0, 0.904762, 0.539894, 0.0066841, 0, 0.936508, 0.527901, 0.00627901, 0, 0.968254, 0.515819, 0.00590506, 0, 1, 1, 0.120864, 0, 0, 1, 0.120864, 0, 0, 0.999996, 0.120864, 0, 0, 0.99998, 0.120867, 0, 0, 0.99994, 0.120872, 0, 0.000323781, 0.999852, 0.120884, 0, 0.00188693, 0.999693, 0.120903, 0, 0.00473489, 0.999426, 0.120929, 0, 0.00872704, 0.999002, 0.120955, 0, 0.0137237, 0.998235, 0.120918, 0, 0.0196068, 0.994608, 0.119764, 0, 0.0262803, 0.992997, 0.119265, 0, 0.0336657, 0.990968, 0.11863, 0, 0.0416987, 0.987002, 0.117261, 0, 0.0503261, 0.983524, 0.116009, 0, 0.0595035, 0.97875, 0.114252, 0, 0.0691935, 0.972652, 0.11193, 0, 0.0793645, 0.966613, 0.109555, 0, 0.0899894, 0.959275, 0.106612, 0, 0.101045, 0.951272, 0.103375, 0, 0.112512, 0.942323, 0.0996594, 0, 0.124372, 0.933679, 0.0958841, 0, 0.136611, 0.924822, 0.0919265, 0, 0.149216, 0.915742, 0.0878061, 0, 0.162176, 0.906348, 0.0834894, 0, 0.175482, 0.896883, 0.079085, 0, 0.189125, 0.88774, 0.0746745, 0, 0.203098, 0.87986, 0.0705773, 0, 0.217396, 0.871998, 0.0665005, 0, 0.232015, 0.864325, 0.0625413, 0, 0.24695, 0.856685, 0.0586781, 0, 0.2622, 0.84925, 0.0550063, 0, 0.277761, 0.841719, 0.0514727, 0, 0.293634, 0.834755, 0.0481398, 0, 0.309819, 0.827853, 0.0450172, 0, 0.326315, 0.820888, 0.0420969, 0, 0.343126, 0.813616, 0.0393702, 0, 0.360254, 0.805767, 0.0367771, 0, 0.377701, 0.797338, 0.0343274, 0, 0.395474, 0.789122, 0.0320529, 0, 0.413577, 0.780601, 0.0299485, 0, 0.432018, 0.771424, 0.0279812, 0, 0.450804, 0.761502, 0.0261054, 0, 0.469944, 0.751166, 0.0243942, 0, 0.489451, 0.741276, 0.0228087, 0, 0.509337, 0.730898, 0.0213265, 0, 0.529617, 0.719878, 0.0199307, 0, 0.550307, 0.708379, 0.0186574, 0, 0.571428, 0.697165, 0.0174446, 0, 0.593003, 0.685554, 0.0163144, 0, 0.615059, 0.673631, 0.015276, 0, 0.637628, 0.662385, 0.0143003, 0, 0.660746, 0.651059, 0.0134112, 0, 0.68446, 0.640451, 0.0125794, 0, 0.70882, 0.630536, 0.011793, 0, 0.733893, 0.620316, 0.0110547, 0, 0.759756, 0.609722, 0.0103668, 0, 0.786505, 0.598804, 0.00973009, 0, 0.814259, 0.587871, 0.00912812, 0, 0.843157, 0.577121, 0.00858916, 0, 0.87334, 0.566019, 0.00807333, 0, 0.904762, 0.554664, 0.00759687, 0, 0.936508, 0.543101, 0.00714759, 0, 0.968254, 0.531558, 0.00673418, 0, 1, 1, 0.146767, 0, 0, 1, 0.146767, 0, 0, 0.999997, 0.146767, 0, 0, 0.999977, 0.146765, 0, 3.20658e-06, 0.999929, 0.146762, 0, 0.000682576, 0.999823, 0.146753, 0, 0.00276402, 0.999633, 0.146735, 0, 0.00614771, 0.999314, 0.146699, 0, 0.0106613, 0.998796, 0.14662, 0, 0.0161546, 0.997124, 0.146107, 0, 0.0225063, 0.994062, 0.144857, 0, 0.0296198, 0.992154, 0.144011, 0, 0.037417, 0.989186, 0.142712, 0, 0.0458348, 0.985279, 0.140926, 0, 0.0548211, 0.980826, 0.13885, 0, 0.0643326, 0.975056, 0.136168, 0, 0.074333, 0.969005, 0.133217, 0, 0.0847917, 0.961554, 0.12959, 0, 0.0956828, 0.954206, 0.125886, 0, 0.106984, 0.945046, 0.121335, 0, 0.118675, 0.935678, 0.116492, 0, 0.130741, 0.926748, 0.111635, 0, 0.143166, 0.917764, 0.106625, 0, 0.155939, 0.908358, 0.101325, 0, 0.169049, 0.899219, 0.0960249, 0, 0.182487, 0.890089, 0.0906527, 0, 0.196245, 0.881488, 0.0853905, 0, 0.210317, 0.874031, 0.0804177, 0, 0.224697, 0.866932, 0.0756005, 0, 0.23938, 0.859976, 0.0709019, 0, 0.254364, 0.853375, 0.0664391, 0, 0.269646, 0.846971, 0.0622012, 0, 0.285223, 0.840483, 0.058129, 0, 0.301096, 0.833969, 0.0542762, 0, 0.317265, 0.82806, 0.0507042, 0, 0.333729, 0.822128, 0.047368, 0, 0.350491, 0.815989, 0.044272, 0, 0.367554, 0.809336, 0.0413444, 0, 0.38492, 0.802177, 0.038601, 0, 0.402594, 0.79441, 0.0360227, 0, 0.420582, 0.786573, 0.0336383, 0, 0.438891, 0.778619, 0.0314321, 0, 0.457527, 0.77, 0.029362, 0, 0.476499, 0.760698, 0.0274102, 0, 0.49582, 0.750932, 0.0256146, 0, 0.5155, 0.740993, 0.023974, 0, 0.535555, 0.731159, 0.0224182, 0, 0.556, 0.720836, 0.0209889, 0, 0.576855, 0.709913, 0.0196411, 0, 0.598143, 0.698415, 0.0183824, 0, 0.619888, 0.68745, 0.0172222, 0, 0.642123, 0.676154, 0.0161509, 0, 0.664883, 0.664383, 0.0151397, 0, 0.688211, 0.6533, 0.0141873, 0, 0.71216, 0.642072, 0.0133105, 0, 0.736792, 0.631412, 0.0124932, 0, 0.762186, 0.621622, 0.0117408, 0, 0.788439, 0.611681, 0.0110358, 0, 0.815672, 0.60142, 0.0103775, 0, 0.844034, 0.59083, 0.00975623, 0, 0.873699, 0.580254, 0.00918084, 0, 0.904765, 0.569841, 0.00864721, 0, 0.936508, 0.559224, 0.00815731, 0, 0.968254, 0.548315, 0.00767924, 0, 1, 1, 0.177563, 0, 0, 1, 0.177563, 0, 0, 0.999994, 0.177562, 0, 0, 0.999972, 0.177555, 0, 6.64171e-05, 0.999914, 0.177536, 0, 0.0012276, 0.999787, 0.177496, 0, 0.00388025, 0.999556, 0.17742, 0, 0.00783463, 0.999165, 0.177285, 0, 0.0128953, 0.9985, 0.177037, 0, 0.0189053, 0.995388, 0.175634, 0, 0.025742, 0.993102, 0.174375, 0, 0.033309, 0.990992, 0.173121, 0, 0.0415298, 0.986932, 0.170896, 0, 0.0503425, 0.982786, 0.16847, 0, 0.0596964, 0.977592, 0.165455, 0, 0.0695498, 0.971075, 0.161676, 0, 0.0798676, 0.963967, 0.157458, 0, 0.0906201, 0.956397, 0.152836, 0, 0.101783, 0.947489, 0.147467, 0, 0.113333, 0.937564, 0.14145, 0, 0.125254, 0.928182, 0.135383, 0, 0.137529, 0.919027, 0.129212, 0, 0.150144, 0.909618, 0.12276, 0, 0.163088, 0.900492, 0.116273, 0, 0.176351, 0.891671, 0.1098, 0, 0.189924, 0.883146, 0.103362, 0, 0.203799, 0.875151, 0.0970799, 0, 0.21797, 0.868338, 0.0911732, 0, 0.232433, 0.862033, 0.0854966, 0, 0.247182, 0.856107, 0.0800691, 0, 0.262216, 0.850644, 0.0749618, 0, 0.27753, 0.845261, 0.070079, 0, 0.293124, 0.839885, 0.0654321, 0, 0.308997, 0.834609, 0.0610975, 0, 0.325149, 0.829083, 0.0569741, 0, 0.341581, 0.82404, 0.0531736, 0, 0.358294, 0.818968, 0.049665, 0, 0.37529, 0.813496, 0.0463856, 0, 0.392573, 0.807533, 0.0433217, 0, 0.410148, 0.80099, 0.0404402, 0, 0.428019, 0.793891, 0.0377578, 0, 0.446192, 0.786281, 0.0352616, 0, 0.464676, 0.778773, 0.0329577, 0, 0.483478, 0.770737, 0.030808, 0, 0.502608, 0.762094, 0.0287964, 0, 0.522079, 0.752898, 0.0269254, 0, 0.541905, 0.743306, 0.0251926, 0, 0.5621, 0.733416, 0.023595, 0, 0.582684, 0.723742, 0.0221155, 0, 0.603677, 0.713542, 0.0207435, 0, 0.625106, 0.702755, 0.019434, 0, 0.646998, 0.691484, 0.0182046, 0, 0.66939, 0.680531, 0.0170771, 0, 0.692324, 0.66953, 0.0160339, 0, 0.715849, 0.658126, 0.0150677, 0, 0.740028, 0.646933, 0.0141551, 0, 0.764937, 0.636107, 0.0133179, 0, 0.790673, 0.625271, 0.0125284, 0, 0.817358, 0.615225, 0.0117937, 0, 0.84515, 0.605678, 0.0111181, 0, 0.874244, 0.59583, 0.0104759, 0, 0.904828, 0.585704, 0.00986672, 0, 0.936508, 0.575413, 0.00929712, 0, 0.968254, 0.565373, 0.00876713, 0, 1, 1, 0.214058, 0, 0, 0.999999, 0.214058, 0, 0, 0.999994, 0.214055, 0, 0, 0.999966, 0.214039, 0, 0.000259642, 0.999893, 0.213998, 0, 0.00200075, 0.999737, 0.21391, 0, 0.00527775, 0.999449, 0.213745, 0, 0.00983959, 0.99896, 0.213458, 0, 0.0154755, 0.9979, 0.212855, 0, 0.0220249, 0.994278, 0.210779, 0, 0.0293654, 0.992254, 0.20926, 0, 0.0374021, 0.98881, 0.206908, 0, 0.0460604, 0.984715, 0.204009, 0, 0.0552802, 0.979738, 0.200471, 0, 0.0650127, 0.972884, 0.195813, 0, 0.0752175, 0.965996, 0.190856, 0, 0.0858612, 0.957974, 0.185077, 0, 0.0969155, 0.949155, 0.17868, 0, 0.108356, 0.939288, 0.171513, 0, 0.120163, 0.928996, 0.163838, 0, 0.132319, 0.919563, 0.156246, 0, 0.144808, 0.910004, 0.148359, 0, 0.157618, 0.900791, 0.140417, 0, 0.170737, 0.892135, 0.132569, 0, 0.184155, 0.883803, 0.124741, 0, 0.197866, 0.876034, 0.117091, 0, 0.211861, 0.869219, 0.109835, 0, 0.226134, 0.863062, 0.102859, 0, 0.240682, 0.857795, 0.0962928, 0, 0.255499, 0.853009, 0.0900725, 0, 0.270583, 0.848603, 0.0842101, 0, 0.285931, 0.844335, 0.0786527, 0, 0.301542, 0.840208, 0.0734397, 0, 0.317415, 0.836035, 0.0685334, 0, 0.33355, 0.83172, 0.0639275, 0, 0.349948, 0.827135, 0.0595909, 0, 0.36661, 0.822797, 0.0556204, 0, 0.383539, 0.818387, 0.0519394, 0, 0.400738, 0.813565, 0.0485317, 0, 0.41821, 0.808142, 0.0453138, 0, 0.435961, 0.802212, 0.0423354, 0, 0.453997, 0.79573, 0.0395553, 0, 0.472324, 0.788741, 0.036988, 0, 0.490951, 0.781093, 0.0345688, 0, 0.509887, 0.773597, 0.0323297, 0, 0.529144, 0.765622, 0.0302719, 0, 0.548735, 0.757083, 0.0283477, 0, 0.568674, 0.747992, 0.0265562, 0, 0.588979, 0.738591, 0.0248844, 0, 0.609671, 0.728719, 0.0233342, 0, 0.630773, 0.719146, 0.0219081, 0, 0.652314, 0.709165, 0.0205711, 0, 0.674328, 0.69875, 0.0193248, 0, 0.696854, 0.687884, 0.0181582, 0, 0.719942, 0.676818, 0.0170746, 0, 0.743651, 0.666247, 0.0160718, 0, 0.768057, 0.655284, 0.0151262, 0, 0.793253, 0.64401, 0.0142561, 0, 0.819363, 0.633353, 0.0134327, 0, 0.846547, 0.622674, 0.012653, 0, 0.875017, 0.612265, 0.0119354, 0, 0.905021, 0.602455, 0.0112533, 0, 0.936508, 0.593147, 0.0106234, 0, 0.968254, 0.583592, 0.0100213, 0, 1, 1, 0.25717, 0, 0, 1, 0.25717, 0, 0, 0.999992, 0.257164, 0, 0, 0.999958, 0.257135, 0, 0.000641715, 0.999864, 0.25706, 0, 0.00305314, 0.999666, 0.256897, 0, 0.00700975, 0.999302, 0.256596, 0, 0.0122194, 0.998663, 0.25607, 0, 0.0184622, 0.995607, 0.254123, 0, 0.0255773, 0.993094, 0.252081, 0, 0.0334439, 0.9907, 0.249867, 0, 0.0419696, 0.98594, 0.246118, 0, 0.0510823, 0.981214, 0.242049, 0, 0.0607242, 0.974966, 0.236869, 0, 0.0708486, 0.967589, 0.230724, 0, 0.081417, 0.95915, 0.223635, 0, 0.0923974, 0.950257, 0.21596, 0, 0.103763, 0.940165, 0.207296, 0, 0.115491, 0.929396, 0.197901, 0, 0.127562, 0.919288, 0.188437, 0, 0.13996, 0.909428, 0.178762, 0, 0.15267, 0.900105, 0.169072, 0, 0.165679, 0.891418, 0.159478, 0, 0.178979, 0.883347, 0.15002, 0, 0.192558, 0.875992, 0.140813, 0, 0.20641, 0.869466, 0.13196, 0, 0.220529, 0.863699, 0.123501, 0, 0.234907, 0.858553, 0.115436, 0, 0.249542, 0.854379, 0.107901, 0, 0.264428, 0.850894, 0.10088, 0, 0.279564, 0.847632, 0.0942296, 0, 0.294947, 0.844571, 0.0879861, 0, 0.310575, 0.84163, 0.0821534, 0, 0.326448, 0.838542, 0.0766409, 0, 0.342566, 0.835412, 0.0715322, 0, 0.358929, 0.831899, 0.0666883, 0, 0.37554, 0.828177, 0.0622175, 0, 0.392399, 0.82416, 0.0580452, 0, 0.409511, 0.820393, 0.054267, 0, 0.426878, 0.816068, 0.0507172, 0, 0.444506, 0.811201, 0.0474041, 0, 0.4624, 0.805785, 0.0443174, 0, 0.480566, 0.799878, 0.0414562, 0, 0.499013, 0.793469, 0.0388147, 0, 0.517749, 0.786473, 0.0363453, 0, 0.536785, 0.778874, 0.0340225, 0, 0.556134, 0.771277, 0.0318599, 0, 0.575809, 0.763426, 0.0298859, 0, 0.595827, 0.755044, 0.0280357, 0, 0.616207, 0.746161, 0.0262979, 0, 0.636973, 0.737124, 0.0247295, 0, 0.65815, 0.72761, 0.0232514, 0, 0.679772, 0.717822, 0.0218755, 0, 0.701876, 0.708279, 0.0205942, 0, 0.724509, 0.698333, 0.0193947, 0, 0.74773, 0.68802, 0.0182717, 0, 0.771609, 0.677321, 0.0172044, 0, 0.79624, 0.666504, 0.0162122, 0, 0.821743, 0.656184, 0.0152924, 0, 0.84828, 0.64556, 0.0144326, 0, 0.876069, 0.634636, 0.0136157, 0, 0.905404, 0.624124, 0.0128612, 0, 0.936508, 0.613914, 0.0121435, 0, 0.968254, 0.603589, 0.0114887, 0, 1, 1, 0.307946, 0, 0, 0.999999, 0.307945, 0, 0, 0.999988, 0.307934, 0, 2.04479e-05, 0.999944, 0.307886, 0, 0.00127833, 0.999824, 0.307756, 0, 0.00445047, 0.999565, 0.30748, 0, 0.00914673, 0.999085, 0.306966, 0, 0.0150498, 0.998103, 0.306004, 0, 0.0219367, 0.994249, 0.303028, 0, 0.0296485, 0.991807, 0.300435, 0, 0.038068, 0.987773, 0.296554, 0, 0.0471062, 0.982673, 0.2916, 0, 0.0566942, 0.976623, 0.285641, 0, 0.0667768, 0.968757, 0.27815, 0, 0.0773099, 0.959849, 0.269529, 0, 0.088257, 0.950663, 0.260248, 0, 0.0995879, 0.940129, 0.249704, 0, 0.111277, 0.92895, 0.238291, 0, 0.123304, 0.917996, 0.226501, 0, 0.13565, 0.907813, 0.214669, 0, 0.148299, 0.898305, 0.202835, 0, 0.161237, 0.889626, 0.191158, 0, 0.174455, 0.88175, 0.179695, 0, 0.187941, 0.874715, 0.168548, 0, 0.201687, 0.868746, 0.15792, 0, 0.215687, 0.863703, 0.147807, 0, 0.229933, 0.859315, 0.138149, 0, 0.24442, 0.855538, 0.128993, 0, 0.259145, 0.852428, 0.120414, 0, 0.274103, 0.850168, 0.112498, 0, 0.289293, 0.848132, 0.105054, 0, 0.304711, 0.846291, 0.0981087, 0, 0.320357, 0.844431, 0.0915942, 0, 0.33623, 0.842493, 0.0855056, 0, 0.35233, 0.840368, 0.0798204, 0, 0.368658, 0.83798, 0.0745097, 0, 0.385214, 0.83523, 0.0695424, 0, 0.402002, 0.832091, 0.0649092, 0, 0.419023, 0.828667, 0.0606291, 0, 0.436282, 0.824805, 0.0566523, 0, 0.453782, 0.820988, 0.0530229, 0, 0.471529, 0.816635, 0.0496364, 0, 0.489528, 0.811725, 0.0464658, 0, 0.507788, 0.806316, 0.0435082, 0, 0.526317, 0.800469, 0.0407873, 0, 0.545124, 0.794107, 0.038255, 0, 0.564221, 0.787218, 0.0358825, 0, 0.583621, 0.779872, 0.0336785, 0, 0.603341, 0.772097, 0.0316379, 0, 0.623397, 0.764484, 0.0297379, 0, 0.643812, 0.756428, 0.0279581, 0, 0.664611, 0.748022, 0.0263153, 0, 0.685824, 0.739268, 0.0247799, 0, 0.707488, 0.73024, 0.0233385, 0, 0.729646, 0.720893, 0.0220035, 0, 0.752354, 0.71119, 0.0207555, 0, 0.77568, 0.701791, 0.0195843, 0, 0.799715, 0.692184, 0.0184891, 0, 0.824574, 0.682258, 0.0174541, 0, 0.850417, 0.67206, 0.0164873, 0, 0.877466, 0.661717, 0.0155959, 0, 0.90604, 0.651462, 0.0147519, 0, 0.936528, 0.641467, 0.0139727, 0, 0.968254, 0.631229, 0.0132363, 0, 1, 1, 0.367573, 0, 0, 0.999999, 0.367571, 0, 0, 0.999984, 0.367553, 0, 0.000183382, 0.999925, 0.367473, 0, 0.00225254, 0.999759, 0.367259, 0, 0.00628165, 0.99941, 0.366801, 0, 0.0117858, 0.998739, 0.365946, 0, 0.0184359, 0.995529, 0.363191, 0, 0.0260114, 0.992875, 0.360171, 0, 0.0343581, 0.989135, 0.355981, 0, 0.0433637, 0.984166, 0.350401, 0, 0.0529438, 0.977871, 0.343348, 0, 0.0630334, 0.96951, 0.334341, 0, 0.0735805, 0.959964, 0.323862, 0, 0.0845437, 0.950162, 0.312521, 0, 0.095889, 0.938882, 0.299577, 0, 0.107588, 0.926992, 0.285573, 0, 0.119617, 0.915589, 0.271212, 0, 0.131957, 0.904791, 0.256611, 0, 0.144591, 0.895177, 0.242224, 0, 0.157503, 0.886403, 0.227952, 0, 0.170682, 0.878957, 0.214192, 0, 0.184117, 0.872418, 0.200795, 0, 0.197799, 0.867029, 0.188015, 0, 0.21172, 0.862835, 0.175975, 0, 0.225873, 0.859411, 0.164526, 0, 0.240253, 0.856655, 0.153693, 0, 0.254854, 0.854519, 0.14352, 0, 0.269673, 0.852828, 0.13397, 0, 0.284707, 0.851412, 0.124984, 0, 0.299953, 0.850609, 0.116748, 0, 0.315408, 0.849855, 0.10905, 0, 0.331073, 0.849017, 0.101839, 0, 0.346946, 0.848079, 0.0951359, 0, 0.363028, 0.846911, 0.0888774, 0, 0.379318, 0.845445, 0.0830375, 0, 0.395818, 0.84362, 0.0775844, 0, 0.41253, 0.841411, 0.0725054, 0, 0.429457, 0.838768, 0.0677691, 0, 0.446602, 0.835801, 0.0634016, 0, 0.463968, 0.832341, 0.0593095, 0, 0.481561, 0.828424, 0.0555121, 0, 0.499386, 0.824312, 0.052024, 0, 0.51745, 0.819918, 0.0487865, 0, 0.535761, 0.815072, 0.0457801, 0, 0.554328, 0.809863, 0.0430184, 0, 0.573162, 0.804164, 0.0404245, 0, 0.592275, 0.798034, 0.0380146, 0, 0.611681, 0.791436, 0.0357436, 0, 0.631398, 0.784498, 0.0336475, 0, 0.651445, 0.777125, 0.0316666, 0, 0.671845, 0.769365, 0.0298122, 0, 0.692628, 0.761579, 0.0281001, 0, 0.713827, 0.753746, 0.0265049, 0, 0.735484, 0.745573, 0.0250067, 0, 0.75765, 0.737083, 0.0236026, 0, 0.78039, 0.728545, 0.0223302, 0, 0.803789, 0.719691, 0.0211243, 0, 0.82796, 0.710569, 0.0199983, 0, 0.853056, 0.701216, 0.0189569, 0, 0.879298, 0.692094, 0.0179702, 0, 0.907014, 0.682909, 0.0170418, 0, 0.936691, 0.673509, 0.0161732, 0, 0.968254, 0.663863, 0.0153406, 0, 1, 1, 0.437395, 0, 0, 0.999998, 0.437394, 0, 0, 0.99998, 0.437363, 0, 0.000616704, 0.999891, 0.437232, 0, 0.00367925, 0.999656, 0.436877, 0, 0.00867446, 0.999148, 0.436121, 0, 0.0150679, 0.997959, 0.434564, 0, 0.022531, 0.993464, 0.430134, 0, 0.0308507, 0.990606, 0.426077, 0, 0.0398805, 0.985027, 0.419397, 0, 0.0495148, 0.978491, 0.41118, 0, 0.0596749, 0.969643, 0.40048, 0, 0.0703001, 0.959189, 0.38769, 0, 0.0813427, 0.948223, 0.373575, 0, 0.0927641, 0.935955, 0.357622, 0, 0.104533, 0.923237, 0.34043, 0, 0.116624, 0.911074, 0.322735, 0, 0.129015, 0.899724, 0.30479, 0, 0.141687, 0.890189, 0.287392, 0, 0.154626, 0.881796, 0.270248, 0, 0.167818, 0.874781, 0.253659, 0, 0.181252, 0.869166, 0.237786, 0, 0.194918, 0.864725, 0.222618, 0, 0.208807, 0.861565, 0.208356, 0, 0.222913, 0.859284, 0.194867, 0, 0.237229, 0.857677, 0.18212, 0, 0.25175, 0.856714, 0.17018, 0, 0.266473, 0.856155, 0.158969, 0, 0.281392, 0.8558, 0.148413, 0, 0.296505, 0.855672, 0.138578, 0, 0.311811, 0.855538, 0.129345, 0, 0.327306, 0.855689, 0.120861, 0, 0.342991, 0.855767, 0.112969, 0, 0.358864, 0.855618, 0.105593, 0, 0.374925, 0.85525, 0.0987451, 0, 0.391176, 0.854583, 0.0923727, 0, 0.407616, 0.853534, 0.0864143, 0, 0.424249, 0.852061, 0.0808338, 0, 0.441076, 0.850253, 0.0756771, 0, 0.4581, 0.848004, 0.0708612, 0, 0.475324, 0.845333, 0.0663784, 0, 0.492754, 0.842376, 0.0622631, 0, 0.510394, 0.838956, 0.0584112, 0, 0.528251, 0.835121, 0.0548328, 0, 0.546331, 0.830842, 0.0514838, 0, 0.564644, 0.826212, 0.048355, 0, 0.583198, 0.821522, 0.0454714, 0, 0.602005, 0.816551, 0.0428263, 0, 0.621078, 0.811211, 0.0403612, 0, 0.640434, 0.805479, 0.038039, 0, 0.660089, 0.799409, 0.0358739, 0, 0.680066, 0.79306, 0.0338727, 0, 0.70039, 0.786395, 0.0319985, 0, 0.721094, 0.779416, 0.030241, 0, 0.742215, 0.77214, 0.0285951, 0, 0.7638, 0.764636, 0.0270747, 0, 0.785912, 0.756836, 0.0256354, 0, 0.808628, 0.749315, 0.0243027, 0, 0.832055, 0.741561, 0.0230497, 0, 0.856338, 0.733589, 0.0218801, 0, 0.88169, 0.725479, 0.020784, 0, 0.908441, 0.717255, 0.0197702, 0, 0.937125, 0.708829, 0.0188168, 0, 0.968254, 0.700191, 0.0179113, 0, 1, 1, 0.518937, 0, 0, 0.999998, 0.518933, 0, 0, 0.999967, 0.518883, 0, 0.00147741, 0.999832, 0.51866, 0, 0.00573221, 0.999466, 0.518057, 0, 0.011826, 0.998644, 0.516752, 0, 0.0192116, 0.994458, 0.512347, 0, 0.027573, 0.991223, 0.507675, 0, 0.0367099, 0.985515, 0.500188, 0, 0.046487, 0.978308, 0.490408, 0, 0.0568071, 0.968359, 0.477357, 0, 0.0675984, 0.95682, 0.461752, 0, 0.0788059, 0.943929, 0.443796, 0, 0.090386, 0.930224, 0.423893, 0, 0.102304, 0.916514, 0.402682, 0, 0.114532, 0.903653, 0.380914, 0, 0.127047, 0.892315, 0.359212, 0, 0.139828, 0.882942, 0.338102, 0, 0.152861, 0.875438, 0.31773, 0, 0.16613, 0.869642, 0.298186, 0, 0.179624, 0.865304, 0.279491, 0, 0.193332, 0.862382, 0.261804, 0, 0.207247, 0.860666, 0.245146, 0, 0.22136, 0.859788, 0.229406, 0, 0.235666, 0.859608, 0.214605, 0, 0.250158, 0.859912, 0.200691, 0, 0.264832, 0.86053, 0.187623, 0, 0.279684, 0.861368, 0.17539, 0, 0.294711, 0.862237, 0.163901, 0, 0.309911, 0.863127, 0.153175, 0, 0.32528, 0.863923, 0.143147, 0, 0.340819, 0.864567, 0.133781, 0, 0.356524, 0.865013, 0.125042, 0, 0.372397, 0.86539, 0.116952, 0, 0.388438, 0.865591, 0.109476, 0, 0.404645, 0.865517, 0.102542, 0, 0.421022, 0.865084, 0.0960688, 0, 0.437569, 0.864309, 0.0900499, 0, 0.454287, 0.863151, 0.0844328, 0, 0.471181, 0.861649, 0.0792218, 0, 0.488253, 0.859742, 0.0743482, 0, 0.505507, 0.857446, 0.0697963, 0, 0.522947, 0.854757, 0.0655364, 0, 0.54058, 0.851783, 0.061608, 0, 0.558412, 0.848516, 0.0579701, 0, 0.576449, 0.844897, 0.0545742, 0, 0.594701, 0.840956, 0.0514167, 0, 0.613178, 0.836676, 0.0484598, 0, 0.631892, 0.832075, 0.0456934, 0, 0.650856, 0.827191, 0.0431178, 0, 0.670088, 0.822295, 0.0407718, 0, 0.689606, 0.817294, 0.0386032, 0, 0.709434, 0.812013, 0.0365675, 0, 0.7296, 0.806465, 0.0346547, 0, 0.750138, 0.800691, 0.0328717, 0, 0.771093, 0.794709, 0.031211, 0, 0.792519, 0.788493, 0.0296504, 0, 0.814488, 0.782049, 0.0281782, 0, 0.837097, 0.775403, 0.0267965, 0, 0.860481, 0.76857, 0.0255002, 0, 0.884842, 0.761536, 0.0242759, 0, 0.910494, 0.754303, 0.0231142, 0, 0.937985, 0.74692, 0.0220305, 0, 0.968254, 0.739745, 0.0210192, 0, 1, 1, 0.613914, 0, 0, 0.999996, 0.613907, 0, 9.63597e-05, 0.999942, 0.613814, 0, 0.00301247, 0.999704, 0.613407, 0, 0.00870385, 0.999046, 0.612302, 0, 0.0160714, 0.995516, 0.608266, 0, 0.0245899, 0.991726, 0.602863, 0, 0.0339681, 0.985157, 0.593956, 0, 0.0440254, 0.97642, 0.581748, 0, 0.0546409, 0.964404, 0.565183, 0, 0.0657284, 0.950601, 0.545273, 0, 0.0772246, 0.935158, 0.522129, 0, 0.0890812, 0.919364, 0.496782, 0, 0.10126, 0.904754, 0.470571, 0, 0.113731, 0.89176, 0.444037, 0, 0.126469, 0.881492, 0.418322, 0, 0.139454, 0.873656, 0.393522, 0, 0.15267, 0.868053, 0.369795, 0, 0.166101, 0.864336, 0.347171, 0, 0.179736, 0.862259, 0.325737, 0, 0.193565, 0.861556, 0.305532, 0, 0.207578, 0.861776, 0.286416, 0, 0.221769, 0.862661, 0.268355, 0, 0.23613, 0.864015, 0.251334, 0, 0.250656, 0.865711, 0.235352, 0, 0.265343, 0.867519, 0.220302, 0, 0.280187, 0.869351, 0.206161, 0, 0.295183, 0.871144, 0.192908, 0, 0.31033, 0.872839, 0.180505, 0, 0.325624, 0.874307, 0.168848, 0, 0.341065, 0.875667, 0.158021, 0, 0.35665, 0.876758, 0.147877, 0, 0.37238, 0.87764, 0.138441, 0, 0.388253, 0.878237, 0.129627, 0, 0.404269, 0.878563, 0.121415, 0, 0.42043, 0.878572, 0.113741, 0, 0.436735, 0.87842, 0.106652, 0, 0.453187, 0.878057, 0.100097, 0, 0.469786, 0.877413, 0.0940128, 0, 0.486536, 0.87646, 0.0883462, 0, 0.503439, 0.875233, 0.0830924, 0, 0.520498, 0.8737, 0.0781975, 0, 0.537717, 0.871873, 0.07364, 0, 0.555102, 0.86978, 0.0694103, 0, 0.572657, 0.867405, 0.0654696, 0, 0.59039, 0.864751, 0.0617914, 0, 0.608307, 0.861818, 0.0583491, 0, 0.626419, 0.858645, 0.0551443, 0, 0.644733, 0.855307, 0.0521894, 0, 0.663264, 0.851736, 0.0494334, 0, 0.682025, 0.847927, 0.0468504, 0, 0.701032, 0.843888, 0.0444261, 0, 0.720308, 0.839629, 0.0421497, 0, 0.739875, 0.835158, 0.0400082, 0, 0.759764, 0.830509, 0.0380076, 0, 0.780014, 0.825714, 0.0361488, 0, 0.800673, 0.820729, 0.0343956, 0, 0.821803, 0.815751, 0.0327781, 0, 0.843492, 0.810752, 0.031275, 0, 0.86586, 0.805587, 0.0298542, 0, 0.889087, 0.800317, 0.0285397, 0, 0.913466, 0.79489, 0.0272948, 0, 0.93952, 0.789314, 0.0261139, 0, 0.96835, 0.783593, 0.0249938, 0, 1, 1, 0.724258, 0, 0, 0.999992, 0.724243, 0, 0.000726889, 0.99987, 0.724044, 0, 0.00569574, 0.999336, 0.72317, 0, 0.0131702, 0.996271, 0.719432, 0, 0.0220738, 0.991159, 0.712576, 0, 0.0319405, 0.982465, 0.700927, 0, 0.0425202, 0.97049, 0.684297, 0, 0.0536599, 0.953973, 0.661244, 0, 0.065258, 0.935546, 0.633804, 0, 0.0772427, 0.916596, 0.603071, 0, 0.0895616, 0.899353, 0.57105, 0, 0.102175, 0.885216, 0.539206, 0, 0.11505, 0.875076, 0.508714, 0, 0.128164, 0.868334, 0.479571, 0, 0.141495, 0.864414, 0.451796, 0, 0.155026, 0.862678, 0.425328, 0, 0.168745, 0.862835, 0.400352, 0, 0.182639, 0.864067, 0.376532, 0, 0.196699, 0.866086, 0.35391, 0, 0.210915, 0.868557, 0.332424, 0, 0.225282, 0.871271, 0.312053, 0, 0.239792, 0.874058, 0.292764, 0, 0.25444, 0.8768, 0.27453, 0, 0.269223, 0.87939, 0.257297, 0, 0.284135, 0.8819, 0.24114, 0, 0.299174, 0.884187, 0.225934, 0, 0.314337, 0.886262, 0.211669, 0, 0.329622, 0.888119, 0.198311, 0, 0.345026, 0.889709, 0.185783, 0, 0.360549, 0.891054, 0.174063, 0, 0.376189, 0.892196, 0.163143, 0, 0.391946, 0.893101, 0.152952, 0, 0.407819, 0.893803, 0.143475, 0, 0.423808, 0.894277, 0.134647, 0, 0.439914, 0.894532, 0.126434, 0, 0.456137, 0.894576, 0.1188, 0, 0.472479, 0.894393, 0.111694, 0, 0.48894, 0.893976, 0.105069, 0, 0.505523, 0.893346, 0.0989077, 0, 0.52223, 0.892502, 0.0931724, 0, 0.539064, 0.891441, 0.0878276, 0, 0.556028, 0.890276, 0.082903, 0, 0.573125, 0.888972, 0.0783505, 0, 0.590361, 0.887469, 0.0741083, 0, 0.607741, 0.885785, 0.0701633, 0, 0.62527, 0.883914, 0.0664835, 0, 0.642957, 0.881872, 0.0630567, 0, 0.660809, 0.879651, 0.0598527, 0, 0.678836, 0.877267, 0.0568615, 0, 0.69705, 0.874717, 0.05406, 0, 0.715465, 0.872012, 0.0514378, 0, 0.734098, 0.869157, 0.0489805, 0, 0.752968, 0.866155, 0.0466727, 0, 0.772101, 0.863014, 0.0445056, 0, 0.791529, 0.859748, 0.0424733, 0, 0.81129, 0.856416, 0.0405957, 0, 0.831438, 0.852958, 0.0388273, 0, 0.852044, 0.849382, 0.0371619, 0, 0.87321, 0.845694, 0.0355959, 0, 0.89509, 0.841893, 0.0341155, 0, 0.917932, 0.837981, 0.0327141, 0, 0.942204, 0.833963, 0.0313856, 0, 0.968981, 0.829847, 0.0301275, 0, 1, 1, 0.85214, 0, 0, 0.999969, 0.852095, 0, 0.00279627, 0.999483, 0.851408, 0, 0.0107635, 0.994545, 0.84579, 0, 0.0206454, 0.986188, 0.835231, 0, 0.0315756, 0.969847, 0.814687, 0, 0.0432021, 0.945951, 0.783735, 0, 0.0553396, 0.91917, 0.746074, 0, 0.0678766, 0.895488, 0.706938, 0, 0.0807395, 0.878232, 0.669534, 0, 0.0938767, 0.868252, 0.635168, 0, 0.10725, 0.863873, 0.603069, 0, 0.120832, 0.863369, 0.572514, 0, 0.134598, 0.86545, 0.543169, 0, 0.148533, 0.868803, 0.514578, 0, 0.16262, 0.872794, 0.486762, 0, 0.176849, 0.87702, 0.459811, 0, 0.19121, 0.881054, 0.433654, 0, 0.205694, 0.884974, 0.408574, 0, 0.220294, 0.888587, 0.384525, 0, 0.235005, 0.891877, 0.36156, 0, 0.24982, 0.894793, 0.339661, 0, 0.264737, 0.89743, 0.318913, 0, 0.279751, 0.899796, 0.299302, 0, 0.294859, 0.901943, 0.280843, 0, 0.310058, 0.903858, 0.263481, 0, 0.325346, 0.905574, 0.247197, 0, 0.340721, 0.907069, 0.231915, 0, 0.356181, 0.908379, 0.217614, 0, 0.371725, 0.90952, 0.20425, 0, 0.387353, 0.910483, 0.191758, 0, 0.403063, 0.91128, 0.180092, 0, 0.418854, 0.911936, 0.169222, 0, 0.434727, 0.912454, 0.159098, 0, 0.450682, 0.912835, 0.149668, 0, 0.466718, 0.913078, 0.140884, 0, 0.482837, 0.913192, 0.132709, 0, 0.499038, 0.913175, 0.125095, 0, 0.515324, 0.91304, 0.118012, 0, 0.531695, 0.912781, 0.111417, 0, 0.548153, 0.91241, 0.105281, 0, 0.5647, 0.911924, 0.0995691, 0, 0.581338, 0.911331, 0.0942531, 0, 0.59807, 0.910637, 0.0893076, 0, 0.6149, 0.90984, 0.0846998, 0, 0.63183, 0.908941, 0.0804044, 0, 0.648865, 0.907944, 0.0763984, 0, 0.666011, 0.906857, 0.0726638, 0, 0.683273, 0.90568, 0.0691783, 0, 0.700659, 0.904416, 0.0659222, 0, 0.718176, 0.903067, 0.0628782, 0, 0.735834, 0.901637, 0.0600307, 0, 0.753646, 0.900128, 0.0573647, 0, 0.771625, 0.898544, 0.0548668, 0, 0.78979, 0.89689, 0.052527, 0, 0.808162, 0.895165, 0.0503306, 0, 0.826771, 0.893371, 0.0482668, 0, 0.845654, 0.891572, 0.0463605, 0, 0.864863, 0.889763, 0.0445998, 0, 0.884472, 0.887894, 0.0429451, 0, 0.904592, 0.885967, 0.0413884, 0, 0.925407, 0.883984, 0.0399225, 0, 0.947271, 0.881945, 0.0385405, 0, 0.97105, 0.879854, 0.0372362, 0, 1, 0.999804, 0.995833, 0, 0, 0.938155, 0.933611, 0, 0.0158731, 0.864755, 0.854311, 0, 0.0317461, 0.888594, 0.865264, 0, 0.0476191, 0.905575, 0.863922, 0, 0.0634921, 0.915125, 0.850558, 0, 0.0793651, 0.920665, 0.829254, 0, 0.0952381, 0.924073, 0.802578, 0, 0.111111, 0.926304, 0.772211, 0, 0.126984, 0.927829, 0.739366, 0, 0.142857, 0.928924, 0.705033, 0, 0.15873, 0.92973, 0.670019, 0, 0.174603, 0.930339, 0.634993, 0, 0.190476, 0.930811, 0.600485, 0, 0.206349, 0.931191, 0.566897, 0, 0.222222, 0.93149, 0.534485, 0, 0.238095, 0.931737, 0.503429, 0, 0.253968, 0.931939, 0.473811, 0, 0.269841, 0.932108, 0.445668, 0, 0.285714, 0.93225, 0.418993, 0, 0.301587, 0.932371, 0.393762, 0, 0.31746, 0.932474, 0.369939, 0, 0.333333, 0.932562, 0.347479, 0, 0.349206, 0.932638, 0.326336, 0, 0.365079, 0.932703, 0.306462, 0, 0.380952, 0.93276, 0.287805, 0, 0.396825, 0.932809, 0.270313, 0, 0.412698, 0.932851, 0.253933, 0, 0.428571, 0.932887, 0.23861, 0, 0.444444, 0.932917, 0.224289, 0, 0.460317, 0.932943, 0.210917, 0, 0.47619, 0.932965, 0.19844, 0, 0.492063, 0.932982, 0.186807, 0, 0.507937, 0.932995, 0.175966, 0, 0.52381, 0.933005, 0.165869, 0, 0.539683, 0.933011, 0.156468, 0, 0.555556, 0.933013, 0.147719, 0, 0.571429, 0.933013, 0.139579, 0, 0.587302, 0.93301, 0.132007, 0, 0.603175, 0.933004, 0.124965, 0, 0.619048, 0.932994, 0.118416, 0, 0.634921, 0.932982, 0.112326, 0, 0.650794, 0.932968, 0.106663, 0, 0.666667, 0.93295, 0.101397, 0, 0.68254, 0.932931, 0.0964993, 0, 0.698413, 0.932908, 0.0919438, 0, 0.714286, 0.932883, 0.0877057, 0, 0.730159, 0.932856, 0.0837623, 0, 0.746032, 0.932827, 0.0800921, 0, 0.761905, 0.932796, 0.0766754, 0, 0.777778, 0.932762, 0.0734936, 0, 0.793651, 0.932727, 0.0705296, 0, 0.809524, 0.932689, 0.0677676, 0, 0.825397, 0.93265, 0.0651929, 0, 0.84127, 0.932609, 0.0627917, 0, 0.857143, 0.932565, 0.0605515, 0, 0.873016, 0.932521, 0.0584606, 0, 0.888889, 0.932474, 0.0565082, 0, 0.904762, 0.932427, 0.0546841, 0, 0.920635, 0.932377, 0.0529793, 0, 0.936508, 0.932326, 0.0513851, 0, 0.952381, 0.932274, 0.0498936, 0, 0.968254, 0.93222, 0.0484975, 0, 0.984127, 0.932164, 0.0471899, 0, 1 ];

		// data textures

		const ltc_float_1 = new Float32Array( LTC_MAT_1 );
		const ltc_float_2 = new Float32Array( LTC_MAT_2 );

		const LTC_FLOAT_1 = new DataTexture( ltc_float_1, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );
		const LTC_FLOAT_2 = new DataTexture( ltc_float_2, 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );

		LTC_FLOAT_1.needsUpdate = true;
		LTC_FLOAT_2.needsUpdate = true;

		const ltc_half_1 = new Uint16Array( LTC_MAT_1.length );

		LTC_MAT_1.forEach( function ( x, index ) {

			ltc_half_1[ index ] = DataUtils.toHalfFloat( x );

		} );

		const ltc_half_2 = new Uint16Array( LTC_MAT_2.length );

		LTC_MAT_2.forEach( function ( x, index ) {

			ltc_half_2[ index ] = DataUtils.toHalfFloat( x );

		} );

		const LTC_HALF_1 = new DataTexture( ltc_half_1, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );
		const LTC_HALF_2 = new DataTexture( ltc_half_2, 64, 64, RGBAFormat, HalfFloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1 );

		LTC_HALF_1.needsUpdate = true;
		LTC_HALF_2.needsUpdate = true;

		this.LTC_HALF_1 = LTC_HALF_1;
		this.LTC_HALF_2 = LTC_HALF_2;

		this.LTC_FLOAT_1 = LTC_FLOAT_1;
		this.LTC_FLOAT_2 = LTC_FLOAT_2;

		return this;

	}

}

RectAreaLightTexturesLib.LTC_HALF_1 = null;
RectAreaLightTexturesLib.LTC_HALF_1 = null;

RectAreaLightTexturesLib.LTC_FLOAT_1 = null;
RectAreaLightTexturesLib.LTC_FLOAT_2 = null;

class RectAreaLightUniformsLib {

	static init() {

		RectAreaLightTexturesLib.init();

		const { LTC_FLOAT_1, LTC_FLOAT_2, LTC_HALF_1, LTC_HALF_2 } = RectAreaLightTexturesLib;

		// data textures

		UniformsLib.LTC_FLOAT_1 = LTC_FLOAT_1;
		UniformsLib.LTC_FLOAT_2 = LTC_FLOAT_2;

		UniformsLib.LTC_HALF_1 = LTC_HALF_1;
		UniformsLib.LTC_HALF_2 = LTC_HALF_2;

	}

}

let rectAreaLightInitialized = false;
function initRectAreaLight() {
  if (!rectAreaLightInitialized) {
    RectAreaLightUniformsLib.init();
    rectAreaLightInitialized = true;
  }
}
function kelvinToRGB(kelvin) {
  const temp = kelvin / 100;
  let r, g, b;
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  return { r: r / 255, g: g / 255, b: b / 255 };
}
class LightLayer extends BaseLayer {
  light;
  helper = null;
  lightData;
  // Point of Interest
  poiTarget = new Vector3();
  smoothedPOI = new Vector3();
  // Path following callback (set by LayerManager)
  pathProvider = null;
  // Layer position getter for POI layer tracking
  layerPositionGetter = null;
  constructor(layerData) {
    super(layerData);
    this.lightData = this.extractLightData(layerData);
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(0);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // DATA EXTRACTION
  // ============================================================================
  extractLightData(layerData) {
    const data = layerData.data;
    return {
      lightType: data?.lightType ?? "point",
      color: data?.color ?? "#ffffff",
      colorTemperature: data?.colorTemperature,
      useColorTemperature: data?.useColorTemperature ?? false,
      intensity: data?.intensity ?? 100,
      physicalIntensity: data?.physicalIntensity,
      usePhysicalIntensity: data?.usePhysicalIntensity ?? false,
      radius: data?.radius ?? 500,
      falloff: data?.falloff ?? "none",
      falloffDistance: data?.falloffDistance ?? 500,
      coneAngle: data?.coneAngle ?? 90,
      coneFeather: data?.coneFeather ?? 50,
      areaWidth: data?.areaWidth ?? 100,
      areaHeight: data?.areaHeight ?? 100,
      pointOfInterest: {
        enabled: data?.pointOfInterest?.enabled ?? false,
        targetType: data?.pointOfInterest?.targetType ?? "position",
        position: data?.pointOfInterest?.position ?? {
          id: "poi_pos",
          name: "POI Position",
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: []
        },
        targetLayerId: data?.pointOfInterest?.targetLayerId,
        offset: data?.pointOfInterest?.offset ?? { x: 0, y: 0, z: 0 },
        smoothing: data?.pointOfInterest?.smoothing ?? 0
      },
      pathFollowing: {
        enabled: data?.pathFollowing?.enabled ?? false,
        splineLayerId: data?.pathFollowing?.splineLayerId,
        progress: data?.pathFollowing?.progress ?? {
          id: "path_progress",
          name: "Path Progress",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        autoOrient: data?.pathFollowing?.autoOrient ?? true,
        bankAngle: data?.pathFollowing?.bankAngle ?? {
          id: "bank_angle",
          name: "Bank Angle",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        }
      },
      shadow: {
        enabled: data?.shadow?.enabled ?? data?.castShadows ?? false,
        type: data?.shadow?.type ?? "pcf",
        mapSize: data?.shadow?.mapSize ?? 1024,
        darkness: data?.shadow?.darkness ?? data?.shadowDarkness ?? 100,
        radius: data?.shadow?.radius ?? data?.shadowDiffusion ?? 1,
        bias: data?.shadow?.bias ?? -1e-4,
        normalBias: data?.shadow?.normalBias ?? 0,
        cameraNear: data?.shadow?.cameraNear ?? 1,
        cameraFar: data?.shadow?.cameraFar ?? 1e3,
        cameraSize: data?.shadow?.cameraSize ?? 500
      },
      lightLinking: {
        mode: data?.lightLinking?.mode ?? "include",
        layers: data?.lightLinking?.layers ?? []
      },
      animatedIntensity: data?.animatedIntensity,
      animatedConeAngle: data?.animatedConeAngle,
      animatedColor: data?.animatedColor,
      animatedColorTemperature: data?.animatedColorTemperature
    };
  }
  // ============================================================================
  // LIGHT CREATION
  // ============================================================================
  createLight() {
    const color = this.getEffectiveColor();
    const intensity = this.getEffectiveIntensity();
    switch (this.lightData.lightType) {
      case "point": {
        const light = new PointLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        this.configureShadows(light);
        return light;
      }
      case "spot": {
        const light = new SpotLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        light.angle = MathUtils.degToRad((this.lightData.coneAngle ?? 90) / 2);
        light.penumbra = (this.lightData.coneFeather ?? 50) / 100;
        this.configureShadows(light);
        return light;
      }
      case "parallel": {
        const light = new DirectionalLight(color, intensity);
        this.configureShadows(light);
        return light;
      }
      case "ambient": {
        return new AmbientLight(color, intensity);
      }
      case "area": {
        initRectAreaLight();
        const light = new RectAreaLight(
          color,
          intensity,
          this.lightData.areaWidth ?? 100,
          this.lightData.areaHeight ?? 100
        );
        return light;
      }
      default:
        layerLogger.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`);
        return new PointLight(color, intensity);
    }
  }
  getEffectiveColor() {
    if (this.lightData.useColorTemperature && this.lightData.colorTemperature) {
      const rgb = kelvinToRGB(this.lightData.colorTemperature);
      return new Color(rgb.r, rgb.g, rgb.b);
    }
    return new Color(this.lightData.color);
  }
  getEffectiveIntensity() {
    if (this.lightData.usePhysicalIntensity && this.lightData.physicalIntensity) {
      return this.lightData.physicalIntensity / 100;
    }
    return this.lightData.intensity / 100;
  }
  // ============================================================================
  // SHADOW CONFIGURATION
  // ============================================================================
  configureShadows(light) {
    const shadowConfig = this.lightData.shadow;
    light.castShadow = shadowConfig.enabled;
    if (!light.castShadow) return;
    light.shadow.mapSize.width = shadowConfig.mapSize;
    light.shadow.mapSize.height = shadowConfig.mapSize;
    switch (shadowConfig.type) {
      case "basic":
        break;
      case "pcf":
        light.shadow.radius = 1;
        break;
      case "pcfSoft":
        light.shadow.radius = shadowConfig.radius;
        break;
      case "vsm":
        light.shadow.radius = shadowConfig.radius;
        break;
    }
    light.shadow.bias = shadowConfig.bias;
    light.shadow.normalBias = shadowConfig.normalBias;
    if (light instanceof DirectionalLight) {
      const camera = light.shadow.camera;
      camera.near = shadowConfig.cameraNear;
      camera.far = shadowConfig.cameraFar;
      camera.left = -shadowConfig.cameraSize / 2;
      camera.right = shadowConfig.cameraSize / 2;
      camera.top = shadowConfig.cameraSize / 2;
      camera.bottom = -shadowConfig.cameraSize / 2;
      camera.updateProjectionMatrix();
    } else if (light instanceof SpotLight) {
      light.shadow.camera.near = shadowConfig.cameraNear;
      light.shadow.camera.far = shadowConfig.cameraFar;
      light.shadow.camera.updateProjectionMatrix();
    }
  }
  // ============================================================================
  // HELPER VISUALIZATION
  // ============================================================================
  createHelper() {
    if (this.helper) {
      this.group.remove(this.helper);
      if (this.helper.dispose) {
        this.helper.dispose();
      }
    }
    switch (this.lightData.lightType) {
      case "point": {
        const helper = new PointLightHelper(this.light, this.lightData.radius / 10);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "spot": {
        const helper = new SpotLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "parallel": {
        const helper = new DirectionalLightHelper(this.light, 50);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "area": {
        const helper = new RectAreaLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
    }
  }
  // ============================================================================
  // POINT OF INTEREST
  // ============================================================================
  /**
   * Set callback for getting layer positions (for POI layer tracking)
   */
  setLayerPositionGetter(getter) {
    this.layerPositionGetter = getter;
  }
  /**
   * Update point of interest target
   */
  updatePointOfInterest(frame) {
    const poi = this.lightData.pointOfInterest;
    if (!poi.enabled) return;
    if (this.lightData.lightType !== "spot" && this.lightData.lightType !== "parallel") {
      return;
    }
    if (poi.targetType === "layer" && poi.targetLayerId && this.layerPositionGetter) {
      const layerPos = this.layerPositionGetter(poi.targetLayerId);
      if (layerPos) {
        this.poiTarget.copy(layerPos);
        this.poiTarget.x += poi.offset.x;
        this.poiTarget.y += poi.offset.y;
        this.poiTarget.z += poi.offset.z;
      }
    } else {
      const pos = this.evaluator.evaluate(poi.position, frame);
      this.poiTarget.set(pos.x, pos.y, pos.z);
    }
    if (poi.smoothing > 0) {
      this.smoothedPOI.lerp(this.poiTarget, 1 - poi.smoothing);
    } else {
      this.smoothedPOI.copy(this.poiTarget);
    }
    if (this.light instanceof SpotLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    } else if (this.light instanceof DirectionalLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    }
  }
  // ============================================================================
  // PATH FOLLOWING
  // ============================================================================
  /**
   * Set path provider callback (from LayerManager's spline provider)
   */
  setPathProvider(provider) {
    this.pathProvider = provider;
  }
  /**
   * Update position and orientation from path
   */
  updatePathFollowing(frame) {
    const path = this.lightData.pathFollowing;
    if (!path.enabled || !path.splineLayerId || !this.pathProvider) return;
    const progress = this.evaluator.evaluate(path.progress, frame);
    const result = this.pathProvider(path.splineLayerId, progress, frame);
    if (!result) return;
    this.group.position.set(result.point.x, -result.point.y, result.point.z);
    if (path.autoOrient) {
      const angle = Math.atan2(result.tangent.y, result.tangent.x);
      this.group.rotation.z = -angle;
      const bankAngle = this.evaluator.evaluate(path.bankAngle, frame);
      this.group.rotation.x = MathUtils.degToRad(bankAngle);
    }
  }
  // ============================================================================
  // PUBLIC SETTERS
  // ============================================================================
  setLightType(type) {
    if (type === this.lightData.lightType) return;
    this.lightData.lightType = type;
    this.group.remove(this.light);
    if (this.light.dispose) {
      this.light.dispose();
    }
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
  }
  setColor(color) {
    this.lightData.color = color;
    this.lightData.useColorTemperature = false;
    this.light.color.set(color);
  }
  setColorTemperature(kelvin) {
    this.lightData.colorTemperature = kelvin;
    this.lightData.useColorTemperature = true;
    const rgb = kelvinToRGB(kelvin);
    this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
  }
  setIntensity(intensity) {
    this.lightData.intensity = intensity;
    this.lightData.usePhysicalIntensity = false;
    this.light.intensity = intensity / 100;
  }
  setFalloffDistance(distance) {
    this.lightData.falloffDistance = distance;
    if (this.light instanceof PointLight || this.light instanceof SpotLight) {
      this.light.distance = this.lightData.falloff === "none" ? 0 : distance;
    }
  }
  setConeAngle(angle) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneAngle = angle;
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
  }
  setConeFeather(feather) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneFeather = feather;
      this.light.penumbra = feather / 100;
    }
  }
  setAreaSize(width, height) {
    if (this.light instanceof RectAreaLight) {
      this.lightData.areaWidth = width;
      this.lightData.areaHeight = height;
      this.light.width = width;
      this.light.height = height;
    }
  }
  setShadowEnabled(enabled) {
    this.lightData.shadow.enabled = enabled;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.light.castShadow = enabled;
    }
  }
  setShadowType(type) {
    this.lightData.shadow.type = type;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.configureShadows(this.light);
    }
  }
  setPointOfInterestEnabled(enabled) {
    this.lightData.pointOfInterest.enabled = enabled;
  }
  setPointOfInterestTarget(layerId) {
    if (layerId) {
      this.lightData.pointOfInterest.targetType = "layer";
      this.lightData.pointOfInterest.targetLayerId = layerId;
    } else {
      this.lightData.pointOfInterest.targetType = "position";
      this.lightData.pointOfInterest.targetLayerId = void 0;
    }
  }
  setPathFollowingEnabled(enabled) {
    this.lightData.pathFollowing.enabled = enabled;
  }
  setPathSpline(splineLayerId) {
    this.lightData.pathFollowing.splineLayerId = splineLayerId ?? void 0;
  }
  // ============================================================================
  // DRIVER PROPERTY ACCESS
  // ============================================================================
  /**
   * Get a light property value by driver property path
   * Used by PropertyDriverSystem for property-to-property linking
   */
  getDriverPropertyValue(path) {
    switch (path) {
      case "light.intensity":
        return this.lightData.intensity;
      case "light.color.r":
        return this.light.color.r * 255;
      case "light.color.g":
        return this.light.color.g * 255;
      case "light.color.b":
        return this.light.color.b * 255;
      case "light.colorTemperature":
        return this.lightData.colorTemperature ?? 6500;
      case "light.coneAngle":
        return this.lightData.coneAngle ?? 90;
      case "light.penumbra":
        return this.lightData.coneFeather ?? 50;
      case "light.falloff":
        return this.lightData.falloffDistance;
      case "light.shadow.intensity":
        return this.lightData.shadow.darkness;
      case "light.shadow.softness":
        return this.lightData.shadow.radius;
      case "light.shadow.bias":
        return this.lightData.shadow.bias * 1e4;
      case "light.poi.x":
        return this.poiTarget.x;
      case "light.poi.y":
        return this.poiTarget.y;
      case "light.poi.z":
        return this.poiTarget.z;
      case "light.areaSize.width":
        return this.lightData.areaWidth ?? 100;
      case "light.areaSize.height":
        return this.lightData.areaHeight ?? 100;
      case "light.physicalIntensity":
        return this.lightData.physicalIntensity ?? this.lightData.intensity * 100;
      default:
        return null;
    }
  }
  /**
   * Set a light property value by driver property path
   * Used by PropertyDriverSystem for driven values
   */
  setDriverPropertyValue(path, value) {
    switch (path) {
      case "light.intensity":
        this.light.intensity = value / 100;
        this.lightData.intensity = value;
        break;
      case "light.color.r":
        this.light.color.r = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.g":
        this.light.color.g = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.b":
        this.light.color.b = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.colorTemperature":
        this.setColorTemperature(value);
        break;
      case "light.coneAngle":
        this.setConeAngle(value);
        break;
      case "light.penumbra":
        this.setConeFeather(value);
        break;
      case "light.falloff":
        this.setFalloffDistance(value);
        break;
      case "light.shadow.intensity":
        this.lightData.shadow.darkness = value;
        break;
      case "light.shadow.softness":
        this.lightData.shadow.radius = value;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.radius = value;
        }
        break;
      case "light.shadow.bias":
        this.lightData.shadow.bias = value / 1e4;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.bias = value / 1e4;
        }
        break;
      case "light.poi.x":
        this.poiTarget.x = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.y":
        this.poiTarget.y = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.z":
        this.poiTarget.z = value;
        this.updatePointOfInterest(0);
        break;
      case "light.areaSize.width":
        this.setAreaSize(value, this.lightData.areaHeight ?? 100);
        break;
      case "light.areaSize.height":
        this.setAreaSize(this.lightData.areaWidth ?? 100, value);
        break;
      case "light.physicalIntensity":
        this.lightData.physicalIntensity = value;
        if (this.lightData.usePhysicalIntensity) {
          this.light.intensity = value / 100;
        }
        break;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getLight() {
    return this.light;
  }
  getLightData() {
    return { ...this.lightData };
  }
  getLightLinking() {
    return { ...this.lightData.lightLinking };
  }
  /**
   * Check if this light should affect a given layer
   */
  shouldAffectLayer(layerId) {
    const linking = this.lightData.lightLinking;
    if (linking.layers.length === 0) {
      return true;
    }
    const isInList = linking.layers.includes(layerId);
    if (linking.mode === "include") {
      return isInList;
    } else {
      return !isInList;
    }
  }
  setHelperVisible(visible) {
    if (this.helper) {
      this.helper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.lightData.pathFollowing.enabled) {
      this.updatePathFollowing(frame);
    }
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(frame);
    }
    if (this.lightData.animatedIntensity?.animated) {
      const intensity = this.evaluator.evaluate(this.lightData.animatedIntensity, frame);
      this.light.intensity = intensity / 100;
    }
    if (this.lightData.animatedConeAngle?.animated && this.light instanceof SpotLight) {
      const angle = this.evaluator.evaluate(this.lightData.animatedConeAngle, frame);
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (this.lightData.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.lightData.animatedColor, frame);
      this.light.color.set(color);
    }
    if (this.lightData.animatedColorTemperature?.animated && this.lightData.useColorTemperature) {
      const kelvin = this.evaluator.evaluate(this.lightData.animatedColorTemperature, frame);
      const rgb = kelvinToRGB(kelvin);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (this.helper) {
      if (this.helper instanceof PointLightHelper || this.helper instanceof SpotLightHelper || this.helper instanceof DirectionalLightHelper) {
        this.helper.update();
      }
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["intensity"] !== void 0) {
      this.light.intensity = props["intensity"] / 100;
    }
    if (props["coneAngle"] !== void 0 && this.light instanceof SpotLight) {
      this.light.angle = MathUtils.degToRad(props["coneAngle"] / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (props["color"] !== void 0) {
      this.light.color.set(props["color"]);
    }
    if (props["colorTemperature"] !== void 0 && this.lightData.useColorTemperature) {
      const rgb = kelvinToRGB(props["colorTemperature"]);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (props["falloffDistance"] !== void 0) {
      if (this.light instanceof PointLight || this.light instanceof SpotLight) {
        this.light.distance = this.lightData.falloff === "none" ? 0 : props["falloffDistance"];
      }
    }
    if (props["poi.x"] !== void 0 || props["poi.y"] !== void 0 || props["poi.z"] !== void 0) {
      this.poiTarget.set(
        props["poi.x"] ?? this.poiTarget.x,
        props["poi.y"] ?? this.poiTarget.y,
        props["poi.z"] ?? this.poiTarget.z
      );
      this.updatePointOfInterest(0);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.lightType !== void 0 && data.lightType !== this.lightData.lightType) {
      this.setLightType(data.lightType);
    }
    if (data.color !== void 0) {
      this.setColor(data.color);
    }
    if (data.colorTemperature !== void 0) {
      this.setColorTemperature(data.colorTemperature);
    }
    if (data.intensity !== void 0) {
      this.setIntensity(data.intensity);
    }
    if (data.falloffDistance !== void 0) {
      this.setFalloffDistance(data.falloffDistance);
    }
    if (data.falloff !== void 0) {
      this.lightData.falloff = data.falloff;
      this.setFalloffDistance(this.lightData.falloffDistance);
    }
    if (data.coneAngle !== void 0) {
      this.setConeAngle(data.coneAngle);
    }
    if (data.coneFeather !== void 0) {
      this.setConeFeather(data.coneFeather);
    }
    if (data.areaWidth !== void 0 || data.areaHeight !== void 0) {
      this.setAreaSize(
        data.areaWidth ?? this.lightData.areaWidth ?? 100,
        data.areaHeight ?? this.lightData.areaHeight ?? 100
      );
    }
    if (data.shadow !== void 0) {
      Object.assign(this.lightData.shadow, data.shadow);
      if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
        this.configureShadows(this.light);
      }
    }
    if (data.pointOfInterest !== void 0) {
      Object.assign(this.lightData.pointOfInterest, data.pointOfInterest);
    }
    if (data.pathFollowing !== void 0) {
      Object.assign(this.lightData.pathFollowing, data.pathFollowing);
    }
    if (data.lightLinking !== void 0) {
      Object.assign(this.lightData.lightLinking, data.lightLinking);
    }
    if (data.animatedIntensity !== void 0) {
      this.lightData.animatedIntensity = data.animatedIntensity;
    }
    if (data.animatedConeAngle !== void 0) {
      this.lightData.animatedConeAngle = data.animatedConeAngle;
    }
    if (data.animatedColor !== void 0) {
      this.lightData.animatedColor = data.animatedColor;
    }
    if (data.animatedColorTemperature !== void 0) {
      this.lightData.animatedColorTemperature = data.animatedColorTemperature;
    }
  }
  onDispose() {
    if (this.light.dispose) {
      this.light.dispose();
    }
    if (this.helper && this.helper.dispose) {
      this.helper.dispose();
    }
  }
}

const depthflowVertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const depthflowFragmentShader = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class DepthflowLayer extends BaseLayer {
  resources;
  // Textures
  sourceTexture = null;
  depthTexture = null;
  // Mesh and material
  mesh;
  geometry;
  material;
  // Layer data
  depthflowData;
  // Dimensions
  width = 1920;
  height = 1080;
  // Animation state
  animationTime = 0;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.depthflowData = this.extractDepthflowData(layerData);
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new ShaderMaterial({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new Vector2(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: depthflowVertexShader,
      fragmentShader: depthflowFragmentShader,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `depthflow_${this.id}`;
    this.group.add(this.mesh);
    this.loadTextures();
    this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(layerData) {
    const data = layerData.data;
    return {
      sourceLayerId: data?.sourceLayerId ?? "",
      depthLayerId: data?.depthLayerId ?? "",
      config: {
        preset: data?.config?.preset ?? "static",
        zoom: data?.config?.zoom ?? 1,
        offsetX: data?.config?.offsetX ?? 0,
        offsetY: data?.config?.offsetY ?? 0,
        rotation: data?.config?.rotation ?? 0,
        depthScale: data?.config?.depthScale ?? 0.1,
        focusDepth: data?.config?.focusDepth ?? 0.5,
        dollyZoom: data?.config?.dollyZoom ?? 0,
        orbitRadius: data?.config?.orbitRadius ?? 0.1,
        orbitSpeed: data?.config?.orbitSpeed ?? 1,
        swingAmplitude: data?.config?.swingAmplitude ?? 0.05,
        swingFrequency: data?.config?.swingFrequency ?? 1,
        edgeDilation: data?.config?.edgeDilation ?? 0,
        inpaintEdges: data?.config?.inpaintEdges ?? false
      },
      animatedZoom: data?.animatedZoom,
      animatedOffsetX: data?.animatedOffsetX,
      animatedOffsetY: data?.animatedOffsetY,
      animatedRotation: data?.animatedRotation,
      animatedDepthScale: data?.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const sourceTexture = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      if (sourceTexture) {
        this.sourceTexture = sourceTexture;
        this.material.uniforms.sourceTexture.value = sourceTexture;
        if (sourceTexture.image) {
          this.setDimensions(sourceTexture.image.width, sourceTexture.image.height);
        }
      }
    }
    if (this.depthflowData.depthLayerId) {
      const depthTexture = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      if (depthTexture) {
        this.depthTexture = depthTexture;
        this.material.uniforms.depthTexture.value = depthTexture;
      }
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(layerId) {
    const texture = this.resources.getLayerTexture(layerId);
    if (texture) return texture;
    layerLogger.warn(`DepthflowLayer: Could not load texture for layer ${layerId}`);
    return null;
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) return;
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Set source layer
   */
  async setSourceLayer(layerId) {
    this.depthflowData.sourceLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.sourceTexture?.dispose();
      this.sourceTexture = texture;
      this.material.uniforms.sourceTexture.value = texture;
    }
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(layerId) {
    this.depthflowData.depthLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.depthTexture?.dispose();
      this.depthTexture = texture;
      this.material.uniforms.depthTexture.value = texture;
    }
  }
  /**
   * Update config values
   */
  updateConfig(config) {
    Object.assign(this.depthflowData.config, config);
    if (config.depthScale !== void 0) {
      this.material.uniforms.depthScale.value = config.depthScale;
    }
    if (config.focusDepth !== void 0) {
      this.material.uniforms.focusDepth.value = config.focusDepth;
    }
    if (config.zoom !== void 0) {
      this.material.uniforms.zoom.value = config.zoom;
    }
    if (config.rotation !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(config.rotation);
    }
    if (config.edgeDilation !== void 0) {
      this.material.uniforms.edgeDilation.value = config.edgeDilation;
    }
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(frame, fps = 30) {
    const config = this.depthflowData.config;
    const duration = this.outPoint - this.inPoint;
    const progress = duration > 0 ? (frame - this.inPoint) / duration : 0;
    const time = frame / fps;
    let zoom = config.zoom;
    let offsetX = config.offsetX;
    let offsetY = config.offsetY;
    let rotation = config.rotation;
    switch (config.preset) {
      case "static":
        break;
      case "zoom_in":
        zoom = 1 + progress * 0.5;
        break;
      case "zoom_out":
        zoom = 1.5 - progress * 0.5;
        break;
      case "dolly_zoom_in":
        zoom = 1 + progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * progress);
        break;
      case "dolly_zoom_out":
        zoom = 1.5 - progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * (1 - progress));
        break;
      case "pan_left":
        offsetX = progress * 0.2;
        break;
      case "pan_right":
        offsetX = -progress * 0.2;
        break;
      case "pan_up":
        offsetY = progress * 0.2;
        break;
      case "pan_down":
        offsetY = -progress * 0.2;
        break;
      case "circle_cw":
        offsetX = Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "circle_ccw":
        offsetX = -Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "horizontal_swing":
        offsetX = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
      case "vertical_swing":
        offsetY = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
    }
    return { zoom, offsetX, offsetY, rotation };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const presetValues = this.calculatePresetValues(frame);
    let zoom = presetValues.zoom;
    let offsetX = presetValues.offsetX;
    let offsetY = presetValues.offsetY;
    let rotation = presetValues.rotation;
    if (this.depthflowData.animatedZoom) {
      zoom = this.evaluator.evaluate(this.depthflowData.animatedZoom, frame);
    }
    if (this.depthflowData.animatedOffsetX) {
      offsetX = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, frame);
    }
    if (this.depthflowData.animatedOffsetY) {
      offsetY = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, frame);
    }
    if (this.depthflowData.animatedRotation) {
      rotation = this.evaluator.evaluate(this.depthflowData.animatedRotation, frame);
    }
    if (this.depthflowData.animatedDepthScale) {
      this.material.uniforms.depthScale.value = this.evaluator.evaluate(
        this.depthflowData.animatedDepthScale,
        frame
      );
    }
    zoom = this.getDrivenOrBase("depthflow.zoom", zoom);
    offsetX = this.getDrivenOrBase("depthflow.offsetX", offsetX);
    offsetY = this.getDrivenOrBase("depthflow.offsetY", offsetY);
    rotation = this.getDrivenOrBase("depthflow.rotation", rotation);
    this.material.uniforms.zoom.value = zoom;
    this.material.uniforms.offset.value.set(offsetX, offsetY);
    this.material.uniforms.rotation.value = MathUtils.degToRad(rotation);
    this.material.uniforms.time.value = frame / 30;
    this.material.needsUpdate = true;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["zoom"] !== void 0) {
      this.material.uniforms.zoom.value = props["zoom"];
    }
    if (props["offsetX"] !== void 0 || props["offsetY"] !== void 0) {
      const offsetX = props["offsetX"] ?? this.material.uniforms.offset.value.x;
      const offsetY = props["offsetY"] ?? this.material.uniforms.offset.value.y;
      this.material.uniforms.offset.value.set(offsetX, offsetY);
    }
    if (props["rotation"] !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(props["rotation"]);
    }
    if (props["depthScale"] !== void 0) {
      this.material.uniforms.depthScale.value = props["depthScale"];
    }
    this.material.needsUpdate = true;
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.sourceLayerId !== void 0 && data.sourceLayerId !== this.depthflowData.sourceLayerId) {
      this.setSourceLayer(data.sourceLayerId);
    }
    if (data.depthLayerId !== void 0 && data.depthLayerId !== this.depthflowData.depthLayerId) {
      this.setDepthLayer(data.depthLayerId);
    }
    if (data.config) {
      this.updateConfig(data.config);
    }
    if (data.animatedZoom !== void 0) {
      this.depthflowData.animatedZoom = data.animatedZoom;
    }
    if (data.animatedOffsetX !== void 0) {
      this.depthflowData.animatedOffsetX = data.animatedOffsetX;
    }
    if (data.animatedOffsetY !== void 0) {
      this.depthflowData.animatedOffsetY = data.animatedOffsetY;
    }
    if (data.animatedRotation !== void 0) {
      this.depthflowData.animatedRotation = data.animatedRotation;
    }
    if (data.animatedDepthScale !== void 0) {
      this.depthflowData.animatedDepthScale = data.animatedDepthScale;
    }
  }
  onDispose() {
    this.sourceTexture?.dispose();
    this.depthTexture?.dispose();
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ProceduralMatteLayer extends BaseLayer {
  // Matte data
  matteData;
  // Display mesh
  mesh = null;
  material = null;
  texture = null;
  // Rendering canvas (grayscale output)
  renderCanvas;
  renderCtx;
  // Animation evaluator
  matteEvaluator;
  // Dimensions
  width = 512;
  height = 512;
  // Noise seed for deterministic noise
  noiseSeed;
  constructor(layerData) {
    super(layerData);
    this.matteEvaluator = new KeyframeEvaluator();
    this.matteData = this.extractMatteData(layerData);
    this.noiseSeed = this.matteData.parameters.seed ?? Math.random() * 65536;
    this.renderCanvas = document.createElement("canvas");
    this.renderCanvas.width = this.width;
    this.renderCanvas.height = this.height;
    this.renderCtx = this.renderCanvas.getContext("2d");
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract matte data with defaults
   */
  extractMatteData(layerData) {
    const data = layerData.data;
    if (!data) {
      return {
        patternType: "linear_gradient",
        parameters: {},
        animation: {
          enabled: false,
          speed: { id: "speed", name: "Speed", type: "number", value: 1, animated: false, keyframes: [] },
          phase: { id: "phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
          direction: { id: "dir", name: "Direction", type: "number", value: 0, animated: false, keyframes: [] }
        },
        inverted: false,
        levels: {
          inputBlack: { id: "ib", name: "Input Black", type: "number", value: 0, animated: false, keyframes: [] },
          inputWhite: { id: "iw", name: "Input White", type: "number", value: 255, animated: false, keyframes: [] },
          gamma: { id: "g", name: "Gamma", type: "number", value: 1, animated: false, keyframes: [] },
          outputBlack: { id: "ob", name: "Output Black", type: "number", value: 0, animated: false, keyframes: [] },
          outputWhite: { id: "ow", name: "Output White", type: "number", value: 255, animated: false, keyframes: [] }
        }
      };
    }
    return data;
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(this.width, this.height);
    this.texture = new CanvasTexture(this.renderCanvas);
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    this.material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `matte_${this.id}`;
    this.group.add(this.mesh);
  }
  /**
   * Set dimensions
   */
  setDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.renderCanvas.width = width;
    this.renderCanvas.height = height;
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh.geometry = new PlaneGeometry(width, height);
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.renderPattern(frame);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    if (properties.data) {
      this.matteData = this.extractMatteData({ ...properties, data: properties.data });
    }
  }
  // ============================================================================
  // PATTERN RENDERING
  // ============================================================================
  /**
   * Render the pattern to the canvas
   */
  renderPattern(frame) {
    const ctx = this.renderCtx;
    const w = this.width;
    const h = this.height;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);
    const speed = this.matteEvaluator.evaluate(this.matteData.animation.speed, frame);
    const phase = this.matteEvaluator.evaluate(this.matteData.animation.phase, frame);
    const time = this.matteData.animation.enabled ? frame * speed / 60 + phase : 0;
    switch (this.matteData.patternType) {
      case "linear_gradient":
        this.renderLinearGradient(ctx, w, h, frame, time);
        break;
      case "radial_gradient":
        this.renderRadialGradient(ctx, w, h, frame, time);
        break;
      case "angular_gradient":
        this.renderAngularGradient(ctx, w, h, frame, time);
        break;
      case "ramp":
        this.renderRamp(ctx, w, h, frame, time);
        break;
      case "noise":
        this.renderNoise(ctx, w, h, frame, time);
        break;
      case "checkerboard":
        this.renderCheckerboard(ctx, w, h, frame, time);
        break;
      case "circle":
        this.renderCircle(ctx, w, h, frame, time);
        break;
      case "rectangle":
        this.renderRectangle(ctx, w, h, frame, time);
        break;
      case "iris":
        this.renderIris(ctx, w, h, frame, time);
        break;
      case "radial_wipe":
        this.renderRadialWipe(ctx, w, h, frame, time);
        break;
      case "venetian_blinds":
        this.renderVenetianBlinds(ctx, w, h, frame, time);
        break;
      case "dissolve":
        this.renderDissolve(ctx, w, h, frame, time);
        break;
      case "wave":
        this.renderWave(ctx, w, h, frame, time);
        break;
      default:
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);
    }
    this.applyLevels(frame);
    if (this.matteData.inverted) {
      this.invertCanvas();
    }
  }
  // ============================================================================
  // PATTERN IMPLEMENTATIONS
  // ============================================================================
  renderLinearGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const angle = this.matteEvaluator.evaluate(params.angle, frame) + time * 360;
    const blend = this.matteEvaluator.evaluate(params.blend, frame);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const blendHalf = Math.max(1e-3, blend / 2);
    gradient.addColorStop(Math.max(0, 0.5 - blendHalf), "black");
    gradient.addColorStop(Math.min(1, 0.5 + blendHalf), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = this.matteEvaluator.evaluate(params.centerX, frame);
    const centerY = this.matteEvaluator.evaluate(params.centerY, frame);
    const radius = this.matteEvaluator.evaluate(params.radius, frame) + time * 0.5;
    const blend = params.blend ? this.matteEvaluator.evaluate(params.blend, frame) : 0.3;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = radius * Math.max(w, h) / 2;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    gradient.addColorStop(Math.max(0, 1 - blend), "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderAngularGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rotation = (params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0) + time * 360;
    const cx = centerX * w;
    const cy = centerY * h;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI + rotation;
        angle = (angle % 360 + 360) % 360;
        const value = Math.round(angle / 360 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderRamp(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = this.matteEvaluator.evaluate(params.progress, frame);
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.1;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const soft = Math.max(1e-3, softness / 2);
    gradient.addColorStop(Math.max(0, animProgress - soft), "black");
    gradient.addColorStop(Math.min(1, animProgress + soft), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderNoise(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const scale = params.scale ? this.matteEvaluator.evaluate(params.scale, frame) : 50;
    const octaves = params.octaves ?? 4;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const timeOffset = time * 10;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let noise = 0;
        let amp = 1;
        let freq = 1 / scale;
        for (let o = 0; o < octaves; o++) {
          noise += this.perlinNoise(x * freq + timeOffset, y * freq) * amp;
          amp *= 0.5;
          freq *= 2;
        }
        const value = Math.round((noise + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderCheckerboard(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const tilesX = params.tilesX ? this.matteEvaluator.evaluate(params.tilesX, frame) : 8;
    const tilesY = params.tilesY ? this.matteEvaluator.evaluate(params.tilesY, frame) : 8;
    const rotation = params.rotation ? this.matteEvaluator.evaluate(params.rotation, frame) : 0;
    const tileW = w / tilesX;
    const tileH = h / tilesY;
    const offset = time * tileW;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.translate(-w / 2 - offset, -h / 2);
    for (let y = -1; y <= tilesY + 1; y++) {
      for (let x = -1; x <= tilesX + 1; x++) {
        const isWhite = (x + y) % 2 === 0;
        ctx.fillStyle = isWhite ? "white" : "black";
        ctx.fillRect(x * tileW, y * tileH, tileW, tileH);
      }
    }
    ctx.restore();
  }
  renderCircle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const radius = params.radius ? this.matteEvaluator.evaluate(params.radius, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = (radius + time * 0.5) * Math.min(w, h) / 2;
    if (feather > 0) {
      const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 50), cx, cy, r);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, "black");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  renderRectangle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rectWidth = params.width ? this.matteEvaluator.evaluate(params.width, frame) : 0.5;
    const rectHeight = params.height ? this.matteEvaluator.evaluate(params.height, frame) : 0.5;
    const cornerRadius = params.cornerRadius ? this.matteEvaluator.evaluate(params.cornerRadius, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const rw = (rectWidth + time * 0.2) * w;
    const rh = (rectHeight + time * 0.2) * h;
    const cr = cornerRadius * Math.min(rw, rh) / 2;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.roundRect(cx - rw / 2, cy - rh / 2, rw, rh, cr);
    ctx.fill();
  }
  renderIris(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0.1;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const maxRadius = Math.sqrt(w * w + h * h) / 2;
    const r = animProgress * maxRadius;
    const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 100), cx, cy, r);
    gradient.addColorStop(0, "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialWipe(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.05;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const angle = animProgress * Math.PI * 2;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let pixelAngle = Math.atan2(dy, dx) + Math.PI;
        const diff = pixelAngle - angle;
        const dist = Math.abs((diff + Math.PI * 3) % (Math.PI * 2) - Math.PI) / Math.PI;
        let value = dist < 0.5 ? 255 : 0;
        if (softness > 0) {
          const soft = softness * Math.PI;
          if (Math.abs(dist - 0.5) < soft) {
            value = Math.round(255 * (1 - (dist - 0.5 + soft) / (soft * 2)));
          }
        }
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderVenetianBlinds(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const slats = params.slats ? this.matteEvaluator.evaluate(params.slats, frame) : 10;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const slatHeight = h / slats;
    const openAmount = animProgress * slatHeight;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle * Math.PI / 180);
    ctx.translate(-w / 2, -h / 2);
    for (let i = 0; i < slats; i++) {
      ctx.fillStyle = "white";
      ctx.fillRect(0, i * slatHeight, w, openAmount);
    }
    ctx.restore();
  }
  renderDissolve(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const blockSize = params.blockSize ? this.matteEvaluator.evaluate(params.blockSize, frame) : 4;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const blocksX = Math.ceil(w / blockSize);
    const blocksY = Math.ceil(h / blockSize);
    for (let by = 0; by < blocksY; by++) {
      for (let bx = 0; bx < blocksX; bx++) {
        const random = this.hash(bx + by * blocksX + this.noiseSeed);
        const isVisible = random < animProgress;
        const value = isVisible ? 255 : 0;
        for (let dy = 0; dy < blockSize && by * blockSize + dy < h; dy++) {
          for (let dx = 0; dx < blockSize && bx * blockSize + dx < w; dx++) {
            const x = bx * blockSize + dx;
            const y = by * blockSize + dy;
            const idx = (y * w + x) * 4;
            data[idx] = data[idx + 1] = data[idx + 2] = value;
            data[idx + 3] = 255;
          }
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderWave(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const frequency = params.frequency ? this.matteEvaluator.evaluate(params.frequency, frame) : 4;
    const amplitude = params.amplitude ? this.matteEvaluator.evaluate(params.amplitude, frame) : 0.5;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const waveType = params.waveType ?? "sine";
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const rad = angle * Math.PI / 180;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const rx = (x - w / 2) * Math.cos(rad) - (y - h / 2) * Math.sin(rad);
        const phase = (rx / w * frequency + time) * Math.PI * 2;
        let wave;
        switch (waveType) {
          case "triangle":
            wave = Math.abs(phase / Math.PI % 2 - 1) * 2 - 1;
            break;
          case "square":
            wave = Math.sin(phase) >= 0 ? 1 : -1;
            break;
          case "sawtooth":
            wave = phase / Math.PI % 2 - 1;
            break;
          default:
            wave = Math.sin(phase);
        }
        const value = Math.round((wave * amplitude + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  /**
   * Apply levels adjustment
   */
  applyLevels(frame) {
    const levels = this.matteData.levels;
    const inputBlack = this.matteEvaluator.evaluate(levels.inputBlack, frame);
    const inputWhite = this.matteEvaluator.evaluate(levels.inputWhite, frame);
    const gamma = this.matteEvaluator.evaluate(levels.gamma, frame);
    const outputBlack = this.matteEvaluator.evaluate(levels.outputBlack, frame);
    const outputWhite = this.matteEvaluator.evaluate(levels.outputWhite, frame);
    if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
      return;
    }
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    const inputRange = inputWhite - inputBlack;
    const outputRange = outputWhite - outputBlack;
    for (let i = 0; i < data.length; i += 4) {
      let value = data[i];
      value = Math.max(0, Math.min(255, (value - inputBlack) / inputRange * 255));
      value = Math.pow(value / 255, 1 / gamma) * 255;
      value = outputBlack + value / 255 * outputRange;
      data[i] = data[i + 1] = data[i + 2] = Math.round(value);
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  /**
   * Invert the canvas
   */
  invertCanvas() {
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];
      data[i + 1] = 255 - data[i + 1];
      data[i + 2] = 255 - data[i + 2];
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  /**
   * Simple deterministic hash function
   */
  hash(n) {
    const x = Math.sin(n) * 43758.5453123;
    return x - Math.floor(x);
  }
  /**
   * Simple 2D Perlin noise approximation
   */
  perlinNoise(x, y) {
    const xi = Math.floor(x);
    const yi = Math.floor(y);
    const xf = x - xi;
    const yf = y - yi;
    const tl = this.hash(xi + yi * 57 + this.noiseSeed);
    const tr = this.hash(xi + 1 + yi * 57 + this.noiseSeed);
    const bl = this.hash(xi + (yi + 1) * 57 + this.noiseSeed);
    const br = this.hash(xi + 1 + (yi + 1) * 57 + this.noiseSeed);
    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);
    return (tl + u * (tr - tl) + v * (bl - tl) + u * v * (tl - tr - bl + br)) * 2 - 1;
  }
  // ============================================================================
  // SOURCE CANVAS (for effects and track mattes)
  // ============================================================================
  getSourceCanvas() {
    return this.renderCanvas;
  }
  applyProcessedEffects(processedCanvas) {
    this.renderCtx.clearRect(0, 0, this.width, this.height);
    this.renderCtx.drawImage(processedCanvas, 0, 0);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
  }
}

function distance(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerpPoint(a, b, t) {
  return {
    x: a.x + (b.x - a.x) * t,
    y: a.y + (b.y - a.y) * t
  };
}
function addPoints(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function normalize(p) {
  const len = Math.sqrt(p.x * p.x + p.y * p.y);
  if (len < 1e-4) return { x: 0, y: 0 };
  return { x: p.x / len, y: p.y / len };
}
function perpendicular(p) {
  return { x: -p.y, y: p.x };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function rotatePoint(p, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: p.x * cos - p.y * sin,
    y: p.x * sin + p.y * cos
  };
}
function rotateAround(p, center, angle) {
  const translated = subtractPoints(p, center);
  const rotated = rotatePoint(translated, angle);
  return addPoints(rotated, center);
}
function clonePoint(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex(v) {
  return {
    point: clonePoint(v.point),
    inHandle: clonePoint(v.inHandle),
    outHandle: clonePoint(v.outHandle)
  };
}
function clonePath(path) {
  return {
    vertices: path.vertices.map(cloneVertex),
    closed: path.closed
  };
}
function cubicBezierPoint(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function cubicBezierDerivative(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const t2 = t * t;
  return {
    x: 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x),
    y: 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y)
  };
}
function splitCubicBezier(p0, p1, p2, p3, t) {
  const q0 = lerpPoint(p0, p1, t);
  const q1 = lerpPoint(p1, p2, t);
  const q2 = lerpPoint(p2, p3, t);
  const r0 = lerpPoint(q0, q1, t);
  const r1 = lerpPoint(q1, q2, t);
  const s = lerpPoint(r0, r1, t);
  return [
    [p0, q0, r0, s],
    [s, r1, q2, p3]
  ];
}
function cubicBezierLength(p0, p1, p2, p3, subdivisions = 32) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= subdivisions; i++) {
    const t = i / subdivisions;
    const curr = cubicBezierPoint(p0, p1, p2, p3, t);
    length += distance(prev, curr);
    prev = curr;
  }
  return length;
}
function getPathLength(path) {
  if (path.vertices.length < 2) return 0;
  let totalLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    totalLength += cubicBezierLength(p0, p1, p2, p3);
  }
  return totalLength;
}
function getPointAtDistance(path, targetDistance, totalLength) {
  if (path.vertices.length < 2) return null;
  const pathLength = totalLength ?? getPathLength(path);
  if (pathLength < 1e-4) return null;
  targetDistance = Math.max(0, Math.min(pathLength, targetDistance));
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    if (accumulatedLength + segmentLength >= targetDistance) {
      const remainingDistance = targetDistance - accumulatedLength;
      const localT = remainingDistance / segmentLength;
      const point = cubicBezierPoint(p0, p1, p2, p3, localT);
      const tangent = normalize(cubicBezierDerivative(p0, p1, p2, p3, localT));
      const globalT = (i + localT) / numSegments;
      return { point, tangent, t: globalT };
    }
    accumulatedLength += segmentLength;
  }
  const lastVertex = path.vertices[path.closed ? 0 : path.vertices.length - 1];
  return {
    point: clonePoint(lastVertex.point),
    tangent: { x: 1, y: 0 },
    t: 1
  };
}
function trimPath(path, startPercent, endPercent, offsetDegrees = 0) {
  if (path.vertices.length < 2) return clonePath(path);
  const totalLength = getPathLength(path);
  if (totalLength < 1e-4) return clonePath(path);
  const offsetPercent = offsetDegrees / 360 * 100;
  let start = ((startPercent + offsetPercent) % 100 + 100) % 100;
  let end = ((endPercent + offsetPercent) % 100 + 100) % 100;
  if (start > end && path.closed) {
    const part1 = trimPathSimple(path, start, 100, totalLength);
    const part2 = trimPathSimple(path, 0, end, totalLength);
    return joinPaths(part1, part2);
  }
  if (start > end) {
    [start, end] = [end, start];
  }
  return trimPathSimple(path, start, end, totalLength);
}
function trimPathSimple(path, startPercent, endPercent, totalLength) {
  const startDist = startPercent / 100 * totalLength;
  const endDist = endPercent / 100 * totalLength;
  if (endDist - startDist < 1e-3) {
    return { vertices: [], closed: false };
  }
  const result = [];
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  let inTrimRegion = false;
  let lastPoint = null;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    const segmentStart = accumulatedLength;
    const segmentEnd = accumulatedLength + segmentLength;
    if (segmentEnd > startDist && segmentStart < endDist) {
      const tStart = Math.max(0, (startDist - segmentStart) / segmentLength);
      const tEnd = Math.min(1, (endDist - segmentStart) / segmentLength);
      let trimmedPoints;
      if (tStart > 0 && tEnd < 1) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        const newTEnd = (tEnd - tStart) / (1 - tStart);
        const [left] = splitCubicBezier(right[0], right[1], right[2], right[3], newTEnd);
        trimmedPoints = left;
      } else if (tStart > 0) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        trimmedPoints = right;
      } else if (tEnd < 1) {
        const [left] = splitCubicBezier(p0, p1, p2, p3, tEnd);
        trimmedPoints = left;
      } else {
        trimmedPoints = [p0, p1, p2, p3];
      }
      if (!inTrimRegion || result.length === 0) {
        result.push({
          point: trimmedPoints[0],
          inHandle: { x: 0, y: 0 },
          outHandle: subtractPoints(trimmedPoints[1], trimmedPoints[0])
        });
        inTrimRegion = true;
      } else if (lastPoint && distance(lastPoint, trimmedPoints[0]) > 0.01) {
        if (result.length > 0) {
          result[result.length - 1].outHandle = subtractPoints(trimmedPoints[1], result[result.length - 1].point);
        }
      }
      result.push({
        point: trimmedPoints[3],
        inHandle: subtractPoints(trimmedPoints[2], trimmedPoints[3]),
        outHandle: { x: 0, y: 0 }
      });
      lastPoint = trimmedPoints[3];
    }
    accumulatedLength += segmentLength;
  }
  return { vertices: result, closed: false };
}
function joinPaths(path1, path2) {
  if (path1.vertices.length === 0) return clonePath(path2);
  if (path2.vertices.length === 0) return clonePath(path1);
  const result = clonePath(path1);
  const p2Verts = path2.vertices.map(cloneVertex);
  const lastP1 = result.vertices[result.vertices.length - 1];
  const firstP2 = p2Verts[0];
  if (distance(lastP1.point, firstP2.point) < 0.01) {
    lastP1.outHandle = firstP2.outHandle;
    result.vertices.push(...p2Verts.slice(1));
  } else {
    result.vertices.push(...p2Verts);
  }
  return result;
}
function mergePaths(paths, mode) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const polygons = paths.map(pathToPolygon);
  let result = [polygons[0]];
  for (let i = 1; i < polygons.length; i++) {
    const newPolygons = [];
    for (const existing of result) {
      switch (mode) {
        case "add":
          newPolygons.push(...polygonUnion(existing, polygons[i]));
          break;
        case "subtract":
        case "minusFront":
          newPolygons.push(...polygonDifference(existing));
          break;
        case "minusBack":
          newPolygons.push(...polygonDifference(polygons[i]));
          break;
        case "intersect":
          newPolygons.push(...polygonIntersection(existing));
          break;
        case "exclude":
          newPolygons.push(...polygonXor(existing, polygons[i]));
          break;
      }
    }
    result = newPolygons;
  }
  return result.map(polygonToPath);
}
function pathToPolygon(path, segments = 16) {
  const points = [];
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    for (let j = 0; j < segments; j++) {
      const t = j / segments;
      points.push(cubicBezierPoint(p0, p1, p2, p3, t));
    }
  }
  return points;
}
function polygonToPath(polygon) {
  const vertices = polygon.map((p) => ({
    point: clonePoint(p),
    inHandle: { x: 0, y: 0 },
    outHandle: { x: 0, y: 0 }
  }));
  return { vertices, closed: true };
}
function polygonUnion(a, b) {
  return [a, b];
}
function polygonDifference(a, b) {
  return [a];
}
function polygonIntersection(a, b) {
  return [a];
}
function polygonXor(a, b) {
  return [a, b];
}
function offsetPath(path, amount, join = "miter", miterLimit = 4) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  const isClosed = path.closed;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    let inDir;
    let outDir;
    if (i === 0 && !isClosed) {
      inDir = { x: 0, y: 0 };
      outDir = normalize(subtractPoints(
        addPoints(next.point, next.inHandle),
        addPoints(curr.point, curr.outHandle)
      ));
    } else if (i === numVertices - 1 && !isClosed) {
      inDir = normalize(subtractPoints(
        addPoints(curr.point, curr.inHandle),
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = { x: 0, y: 0 };
    } else {
      inDir = normalize(subtractPoints(
        curr.point,
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = normalize(subtractPoints(
        addPoints(curr.point, curr.outHandle),
        curr.point
      ));
    }
    let offsetDir;
    if (Math.abs(inDir.x) < 1e-3 && Math.abs(inDir.y) < 1e-3) {
      offsetDir = perpendicular(outDir);
    } else if (Math.abs(outDir.x) < 1e-3 && Math.abs(outDir.y) < 1e-3) {
      offsetDir = perpendicular(inDir);
    } else {
      const perpIn = perpendicular(inDir);
      const perpOut = perpendicular(outDir);
      offsetDir = normalize(addPoints(perpIn, perpOut));
      const angle = Math.acos(Math.max(-1, Math.min(1, dot(inDir, outDir))));
      if (angle > 0.01) {
        const miterFactor = 1 / Math.cos(angle / 2);
        if (join === "miter" && miterFactor <= miterLimit) {
          offsetDir = scalePoint(offsetDir, miterFactor);
        }
      }
    }
    const newPoint = addPoints(curr.point, scalePoint(offsetDir, amount));
    const handleScale = 1;
    result.push({
      point: newPoint,
      inHandle: scalePoint(curr.inHandle, handleScale),
      outHandle: scalePoint(curr.outHandle, handleScale)
    });
  }
  return { vertices: result, closed: isClosed };
}
function offsetPathMultiple(path, baseAmount, copies, copyOffset, join = "miter", miterLimit = 4) {
  const results = [clonePath(path)];
  for (let i = 1; i < copies; i++) {
    const amount = baseAmount + copyOffset * i;
    results.push(offsetPath(path, amount, join, miterLimit));
  }
  return results;
}
function puckerBloat(path, amount) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const centroid = { x: 0, y: 0 };
  for (const v of path.vertices) {
    centroid.x += v.point.x;
    centroid.y += v.point.y;
  }
  centroid.x /= path.vertices.length;
  centroid.y /= path.vertices.length;
  const factor = amount / 100;
  const result = path.vertices.map((v) => {
    const dir = subtractPoints(v.point, centroid);
    const dist = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
    if (dist < 1e-3) return cloneVertex(v);
    const moveAmount = dist * factor;
    const newPoint = addPoints(v.point, scalePoint(normalize(dir), moveAmount));
    const handleFactor = 1 + factor * 0.5;
    return {
      point: newPoint,
      inHandle: scalePoint(v.inHandle, handleFactor),
      outHandle: scalePoint(v.outHandle, handleFactor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function wigglePath(path, size, detail, pointType, correlation, temporalPhase, spatialPhase, seed) {
  if (path.vertices.length < 2 || size < 1e-3) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  for (let i = 0; i < Math.floor(temporalPhase * 100); i++) {
    rng.next();
  }
  const correlationFactor = correlation / 100;
  const result = [];
  const subdividedPath = subdividePath(path, Math.max(1, Math.floor(detail)));
  let prevOffset = { x: 0, y: 0 };
  for (let i = 0; i < subdividedPath.vertices.length; i++) {
    const v = subdividedPath.vertices[i];
    const angle = rng.next() * Math.PI * 2 + spatialPhase;
    const magnitude = rng.next() * size;
    const newOffset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const offset = {
      x: prevOffset.x * correlationFactor + newOffset.x * (1 - correlationFactor),
      y: prevOffset.y * correlationFactor + newOffset.y * (1 - correlationFactor)
    };
    prevOffset = offset;
    const newVertex = {
      point: addPoints(v.point, offset),
      inHandle: pointType === "smooth" ? clonePoint(v.inHandle) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? clonePoint(v.outHandle) : { x: 0, y: 0 }
    };
    result.push(newVertex);
  }
  return { vertices: result, closed: path.closed };
}
function subdividePath(path, levels = 1) {
  if (levels <= 0) return clonePath(path);
  let current = clonePath(path);
  for (let level = 0; level < levels; level++) {
    const result = [];
    const numSegments = current.closed ? current.vertices.length : current.vertices.length - 1;
    for (let i = 0; i < numSegments; i++) {
      const v0 = current.vertices[i];
      const v1 = current.vertices[(i + 1) % current.vertices.length];
      const p0 = v0.point;
      const p1 = addPoints(v0.point, v0.outHandle);
      const p2 = addPoints(v1.point, v1.inHandle);
      const p3 = v1.point;
      const [left, right] = splitCubicBezier(p0, p1, p2, p3, 0.5);
      result.push({
        point: left[0],
        inHandle: i === 0 ? v0.inHandle : subtractPoints(left[1], left[0]),
        outHandle: subtractPoints(left[1], left[0])
      });
      result.push({
        point: left[3],
        inHandle: subtractPoints(left[2], left[3]),
        outHandle: subtractPoints(right[1], right[0])
      });
    }
    if (!current.closed) {
      const lastV = current.vertices[current.vertices.length - 1];
      result.push(cloneVertex(lastV));
    }
    current = { vertices: result, closed: current.closed };
  }
  return current;
}
function zigZagPath(path, size, ridgesPerSegment, pointType) {
  if (path.vertices.length < 2 || size < 1e-3 || ridgesPerSegment < 1) {
    return clonePath(path);
  }
  const result = [];
  const totalLength = getPathLength(path);
  const ridgeLength = totalLength / (ridgesPerSegment * (path.vertices.length - (path.closed ? 0 : 1)));
  let currentDistance = 0;
  let zigDirection = 1;
  while (currentDistance < totalLength) {
    const pointData = getPointAtDistance(path, currentDistance, totalLength);
    if (!pointData) break;
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint(perp, size * zigDirection);
    const vertex = {
      point: addPoints(pointData.point, offset),
      inHandle: pointType === "smooth" ? scalePoint(pointData.tangent, -ridgeLength * 0.3) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? scalePoint(pointData.tangent, ridgeLength * 0.3) : { x: 0, y: 0 }
    };
    result.push(vertex);
    currentDistance += ridgeLength;
    zigDirection *= -1;
  }
  if (result.length > 0 && !path.closed) {
    const lastVertex = path.vertices[path.vertices.length - 1];
    result.push({
      point: clonePoint(lastVertex.point),
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function twistPath(path, angle, center) {
  if (path.vertices.length < 2 || Math.abs(angle) < 1e-3) {
    return clonePath(path);
  }
  let minY = Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minY = Math.min(minY, v.point.y);
    maxY = Math.max(maxY, v.point.y);
  }
  const height = maxY - minY;
  if (height < 1e-3) return clonePath(path);
  const angleRad = angle * Math.PI / 180;
  const result = path.vertices.map((v) => {
    const yNorm = (v.point.y - minY) / height;
    const localAngle = angleRad * yNorm;
    const rotatedPoint = rotateAround(v.point, center, localAngle);
    const absInHandle = addPoints(v.point, v.inHandle);
    const absOutHandle = addPoints(v.point, v.outHandle);
    const rotatedIn = rotateAround(absInHandle, center, localAngle);
    const rotatedOut = rotateAround(absOutHandle, center, localAngle);
    return {
      point: rotatedPoint,
      inHandle: subtractPoints(rotatedIn, rotatedPoint),
      outHandle: subtractPoints(rotatedOut, rotatedPoint)
    };
  });
  return { vertices: result, closed: path.closed };
}
function roundCorners(path, radius) {
  if (path.vertices.length < 2 || radius < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    if (!path.closed && (i === 0 || i === numVertices - 1)) {
      result.push(cloneVertex(curr));
      continue;
    }
    const toPrev = normalize(subtractPoints(prev.point, curr.point));
    const toNext = normalize(subtractPoints(next.point, curr.point));
    const dotProduct = dot(toPrev, toNext);
    if (dotProduct > 0.99) {
      result.push(cloneVertex(curr));
      continue;
    }
    const distPrev = distance(curr.point, prev.point);
    const distNext = distance(curr.point, next.point);
    const maxRadius = Math.min(radius, distPrev / 2, distNext / 2);
    const startPoint = addPoints(curr.point, scalePoint(toPrev, maxRadius));
    const endPoint = addPoints(curr.point, scalePoint(toNext, maxRadius));
    const kappa = 0.5522847498;
    const handleLength = maxRadius * kappa;
    result.push({
      point: startPoint,
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint(toPrev, -handleLength)
    });
    result.push({
      point: endPoint,
      inHandle: scalePoint(toNext, -handleLength),
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function generateRectangle(position, size, roundness = 0, direction = 1) {
  const hw = size.x / 2;
  const hh = size.y / 2;
  const r = Math.min(roundness, hw, hh);
  const corners = [
    { x: position.x - hw, y: position.y - hh },
    // TL
    { x: position.x + hw, y: position.y - hh },
    // TR
    { x: position.x + hw, y: position.y + hh },
    // BR
    { x: position.x - hw, y: position.y + hh }
    // BL
  ];
  if (direction === -1) {
    corners.reverse();
  }
  if (r < 0.01) {
    return {
      vertices: corners.map((p) => ({
        point: p,
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      })),
      closed: true
    };
  }
  const kappa = 0.5522847498 * r;
  const vertices = [];
  for (let i = 0; i < 4; i++) {
    const curr = corners[i];
    const next = corners[(i + 1) % 4];
    const dir = normalize(subtractPoints(next, curr));
    vertices.push({
      point: addPoints(curr, scalePoint(dir, r)),
      inHandle: scalePoint(dir, -kappa),
      outHandle: { x: 0, y: 0 }
    });
    vertices.push({
      point: subtractPoints(next, scalePoint(dir, r)),
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint(dir, kappa)
    });
  }
  return { vertices, closed: true };
}
function generateEllipse(position, size, direction = 1) {
  const rx = size.x / 2;
  const ry = size.y / 2;
  const kappa = 0.5522847498;
  let vertices = [
    {
      // Top
      point: { x: position.x, y: position.y - ry },
      inHandle: { x: -rx * kappa, y: 0 },
      outHandle: { x: rx * kappa, y: 0 }
    },
    {
      // Right
      point: { x: position.x + rx, y: position.y },
      inHandle: { x: 0, y: -ry * kappa },
      outHandle: { x: 0, y: ry * kappa }
    },
    {
      // Bottom
      point: { x: position.x, y: position.y + ry },
      inHandle: { x: rx * kappa, y: 0 },
      outHandle: { x: -rx * kappa, y: 0 }
    },
    {
      // Left
      point: { x: position.x - rx, y: position.y },
      inHandle: { x: 0, y: ry * kappa },
      outHandle: { x: 0, y: -ry * kappa }
    }
  ];
  if (direction === -1) {
    vertices = vertices.reverse().map((v) => ({
      point: v.point,
      inHandle: v.outHandle,
      outHandle: v.inHandle
    }));
  }
  return { vertices, closed: true };
}
function generatePolygon(position, points, radius, roundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI * 2 / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints; i++) {
    const idx = direction === 1 ? i : numPoints - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.5;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function generateStar(position, points, outerRadius, innerRadius, outerRoundness = 0, innerRoundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints * 2; i++) {
    const idx = direction === 1 ? i : numPoints * 2 - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const isOuter = idx % 2 === 0;
    const radius = isOuter ? outerRadius : innerRadius;
    const roundness = isOuter ? outerRoundness : innerRoundness;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.3;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function simplifyPath(path, tolerance, straightLines = false) {
  if (path.vertices.length <= 2) return clonePath(path);
  const points = pathToPolygon(path, 32);
  const simplified = douglasPeucker(points, tolerance);
  if (straightLines) {
    return polygonToPath(simplified);
  } else {
    return fitBezierToPoints(simplified, path.closed);
  }
}
function douglasPeucker(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDistance(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeucker(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function perpendicularDistance(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (length < 1e-4) return distance(point, lineStart);
  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
  const closest = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return distance(point, closest);
}
function fitBezierToPoints(points, closed) {
  const vertices = [];
  for (let i = 0; i < points.length; i++) {
    const prev = points[(i - 1 + points.length) % points.length];
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const handleLength = Math.min(
      distance(curr, prev) * 0.3,
      distance(curr, next) * 0.3
    );
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    vertices.push({
      point: clonePoint(curr),
      inHandle: scalePoint(avgDir, -handleLength),
      outHandle: scalePoint(avgDir, handleLength)
    });
  }
  return { vertices, closed };
}
function smoothPath(path, amount) {
  if (path.vertices.length < 2) return clonePath(path);
  const factor = amount / 100;
  const result = path.vertices.map((v, i) => {
    const prev = path.vertices[(i - 1 + path.vertices.length) % path.vertices.length];
    const next = path.vertices[(i + 1) % path.vertices.length];
    const toPrev = subtractPoints(prev.point, v.point);
    const toNext = subtractPoints(next.point, v.point);
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    const idealHandleLength = (distance(v.point, prev.point) + distance(v.point, next.point)) / 6;
    const idealIn = scalePoint(avgDir, -idealHandleLength);
    const idealOut = scalePoint(avgDir, idealHandleLength);
    return {
      point: clonePoint(v.point),
      inHandle: lerpPoint(v.inHandle, idealIn, factor),
      outHandle: lerpPoint(v.outHandle, idealOut, factor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function applyRepeater(paths, copies, offset, anchorPoint, position, scale, rotation, startOpacity, endOpacity) {
  const results = [];
  for (let i = 0; i < copies; i++) {
    const t = copies > 1 ? i / (copies - 1) : 0;
    const copyRotation = rotation * i;
    const copyScale = {
      x: 100 + (scale.x - 100) * i,
      y: 100 + (scale.y - 100) * i
    };
    const copyPosition = {
      x: position.x * i,
      y: position.y * i
    };
    const copyOpacity = startOpacity + (endOpacity - startOpacity) * t;
    const transformedPaths = paths.map((path) => {
      return transformPath(path, anchorPoint, copyPosition, copyScale, copyRotation);
    });
    results.push({
      paths: transformedPaths,
      opacities: paths.map(() => copyOpacity / 100)
    });
  }
  return results;
}
function transformPath(path, anchorPoint, position, scale, rotation) {
  const rotRad = rotation * Math.PI / 180;
  const cos = Math.cos(rotRad);
  const sin = Math.sin(rotRad);
  const transformPoint = (p) => {
    let x = p.x - anchorPoint.x;
    let y = p.y - anchorPoint.y;
    x *= scale.x / 100;
    y *= scale.y / 100;
    const rx = x * cos - y * sin;
    const ry = x * sin + y * cos;
    return {
      x: rx + anchorPoint.x + position.x,
      y: ry + anchorPoint.y + position.y
    };
  };
  const vertices = path.vertices.map((v) => {
    const newPoint = transformPoint(v.point);
    const absIn = addPoints(v.point, v.inHandle);
    const absOut = addPoints(v.point, v.outHandle);
    const newIn = transformPoint(absIn);
    const newOut = transformPoint(absOut);
    return {
      point: newPoint,
      inHandle: subtractPoints(newIn, newPoint),
      outHandle: subtractPoints(newOut, newPoint)
    };
  });
  return { vertices, closed: path.closed };
}
const ShapeOperations = {
  // Utilities
  distance,
  lerpPoint,
  addPoints,
  subtractPoints,
  scalePoint,
  normalize,
  perpendicular,
  clonePath,
  // Bezier
  cubicBezierPoint,
  cubicBezierLength,
  getPathLength,
  getPointAtDistance,
  splitCubicBezier,
  // Path operators
  trimPath,
  mergePaths,
  offsetPath,
  offsetPathMultiple,
  puckerBloat,
  wigglePath,
  zigZagPath,
  twistPath,
  roundCorners,
  // Generators
  generateRectangle,
  generateEllipse,
  generatePolygon,
  generateStar,
  // Illustrator features
  simplifyPath,
  smoothPath,
  // Repeater
  applyRepeater,
  transformPath
};

class ShapeLayer extends BaseLayer {
  type = "shape";
  // Shape data
  shapeData;
  // Rendering
  canvas;
  ctx;
  texture;
  mesh;
  // Canvas size (matches composition)
  canvasWidth = 1920;
  canvasHeight = 1080;
  // 3D extrusion (if any)
  extrudedMeshes = [];
  extrudeGroup;
  // Current frame for animation
  currentFrame = 0;
  constructor(layerData) {
    super(layerData);
    this.shapeData = layerData.data || {
      contents: [],
      blendMode: "normal",
      quality: "normal",
      gpuAccelerated: true
    };
    this.canvas = new OffscreenCanvas(this.canvasWidth, this.canvasHeight);
    this.ctx = this.canvas.getContext("2d");
    this.texture = new CanvasTexture(this.canvas);
    this.texture.colorSpace = SRGBColorSpace;
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    const geometry = new PlaneGeometry(this.canvasWidth, this.canvasHeight);
    const material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, material);
    this.mesh.position.set(this.canvasWidth / 2, this.canvasHeight / 2, 0);
    this.group.add(this.mesh);
    this.extrudeGroup = new Group();
    this.group.add(this.extrudeGroup);
    this.renderShape();
  }
  // ============================================================================
  // SIZE MANAGEMENT
  // ============================================================================
  /**
   * Set canvas size (should match composition)
   */
  setSize(width, height) {
    if (width === this.canvasWidth && height === this.canvasHeight) return;
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.canvas = new OffscreenCanvas(width, height);
    this.ctx = this.canvas.getContext("2d");
    this.texture.image = this.canvas;
    this.texture.needsUpdate = true;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
    this.mesh.position.set(width / 2, height / 2, 0);
    this.renderShape();
  }
  // ============================================================================
  // SHAPE DATA ACCESS
  // ============================================================================
  getShapeData() {
    return this.shapeData;
  }
  setShapeData(data) {
    this.shapeData = data;
    this.renderShape();
  }
  addContent(content) {
    this.shapeData.contents.push(content);
    this.renderShape();
  }
  removeContent(index) {
    this.shapeData.contents.splice(index, 1);
    this.renderShape();
  }
  updateContent(index, content) {
    if (index >= 0 && index < this.shapeData.contents.length) {
      this.shapeData.contents[index] = content;
      this.renderShape();
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  evaluateFrame(frame) {
    this.currentFrame = frame;
    super.evaluateFrame(frame);
    this.renderShape();
  }
  /**
   * Called during frame evaluation to update shape-specific properties
   */
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
  }
  /**
   * Called when layer properties are updated
   */
  onUpdate(properties) {
    if (properties.data) {
      this.shapeData = properties.data;
      this.renderShape();
    }
  }
  onApplyEvaluatedState(state) {
    if (state.shapeData) {
      this.shapeData = state.shapeData;
    }
    this.renderShape();
  }
  // ============================================================================
  // SHAPE RENDERING
  // ============================================================================
  /**
   * Main render function
   */
  renderShape() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    const evaluatedPaths = this.evaluateContents(this.shapeData.contents);
    for (const evalPath of evaluatedPaths) {
      this.renderPath(evalPath);
    }
    this.texture.needsUpdate = true;
  }
  /**
   * Evaluate all shape contents into renderable paths
   */
  evaluateContents(contents) {
    const generators = [];
    const operators = [];
    const modifiers = [];
    const repeaters = [];
    const transforms = [];
    const groups = [];
    const illustratorOps = [];
    for (const content of contents) {
      switch (content.type) {
        case "rectangle":
        case "ellipse":
        case "polygon":
        case "star":
        case "path":
          generators.push(content);
          break;
        case "fill":
        case "stroke":
        case "gradientFill":
        case "gradientStroke":
          modifiers.push(content);
          break;
        case "trimPaths":
        case "mergePaths":
        case "offsetPaths":
        case "puckerBloat":
        case "wigglePaths":
        case "zigZag":
        case "twist":
        case "roundedCorners":
          operators.push(content);
          break;
        case "repeater":
          repeaters.push(content);
          break;
        case "transform":
          transforms.push(content);
          break;
        case "group":
          groups.push(content);
          break;
        case "simplifyPath":
        case "smoothPath":
        case "extrude":
        case "trace":
          illustratorOps.push(content);
          break;
      }
    }
    let paths = generators.map((gen) => this.generatePath(gen));
    for (const op of operators) {
      paths = this.applyOperator(paths, op);
    }
    for (const op of illustratorOps) {
      paths = this.applyIllustratorOperator(paths, op);
    }
    for (const transform of transforms) {
      paths = paths.map((p) => this.applyShapeTransform(p, transform));
    }
    for (const repeater of repeaters) {
      paths = this.applyRepeater(paths, repeater);
    }
    const result = [];
    for (const path of paths) {
      const evalPath = { path };
      for (const mod of modifiers) {
        this.applyModifier(evalPath, mod);
      }
      result.push(evalPath);
    }
    for (const group of groups) {
      const groupPaths = this.evaluateContents(group.contents);
      result.push(...groupPaths);
    }
    return result;
  }
  /**
   * Generate a path from a shape generator
   */
  generatePath(generator) {
    switch (generator.type) {
      case "rectangle": {
        const rect = generator;
        const pos = this.getAnimatedValue(rect.position);
        const size = this.getAnimatedValue(rect.size);
        const roundness = this.getAnimatedValue(rect.roundness);
        return generateRectangle(pos, size, roundness, rect.direction);
      }
      case "ellipse": {
        const ellipse = generator;
        const pos = this.getAnimatedValue(ellipse.position);
        const size = this.getAnimatedValue(ellipse.size);
        return generateEllipse(pos, size, ellipse.direction);
      }
      case "polygon": {
        const poly = generator;
        const pos = this.getAnimatedValue(poly.position);
        const points = this.getAnimatedValue(poly.points);
        const radius = this.getAnimatedValue(poly.outerRadius);
        const roundness = this.getAnimatedValue(poly.outerRoundness);
        const rotation = this.getAnimatedValue(poly.rotation);
        return generatePolygon(pos, points, radius, roundness, rotation, poly.direction);
      }
      case "star": {
        const star = generator;
        const pos = this.getAnimatedValue(star.position);
        const points = this.getAnimatedValue(star.points);
        const outerR = this.getAnimatedValue(star.outerRadius);
        const innerR = this.getAnimatedValue(star.innerRadius);
        const outerRound = this.getAnimatedValue(star.outerRoundness);
        const innerRound = this.getAnimatedValue(star.innerRoundness);
        const rotation = this.getAnimatedValue(star.rotation);
        return generateStar(pos, points, outerR, innerR, outerRound, innerRound, rotation, star.direction);
      }
      case "path": {
        const pathShape = generator;
        return clonePath(this.getAnimatedValue(pathShape.path));
      }
      default:
        return { vertices: [], closed: false };
    }
  }
  /**
   * Apply a path operator to paths
   */
  applyOperator(paths, operator) {
    switch (operator.type) {
      case "trimPaths": {
        const trim = operator;
        const start = this.getAnimatedValue(trim.start);
        const end = this.getAnimatedValue(trim.end);
        const offset = this.getAnimatedValue(trim.offset);
        if (trim.mode === "simultaneously") {
          return paths.map((p) => trimPath(p, start, end, offset));
        } else {
          return paths.map((p, i) => {
            const pathStart = (start + 100 / paths.length * i) % 100;
            const pathEnd = (end + 100 / paths.length * i) % 100;
            return trimPath(p, pathStart, pathEnd, offset);
          });
        }
      }
      case "mergePaths": {
        const merge = operator;
        return mergePaths(paths, merge.mode);
      }
      case "offsetPaths": {
        const offset = operator;
        const amount = this.getAnimatedValue(offset.amount);
        const copies = this.getAnimatedValue(offset.copies);
        const copyOff = this.getAnimatedValue(offset.copyOffset);
        const miter = this.getAnimatedValue(offset.miterLimit);
        if (copies <= 1) {
          return paths.map((p) => offsetPath(p, amount, offset.lineJoin, miter));
        } else {
          return paths.flatMap(
            (p) => ShapeOperations.offsetPathMultiple(p, amount, copies, copyOff, offset.lineJoin, miter)
          );
        }
      }
      case "puckerBloat": {
        const pb = operator;
        const amount = this.getAnimatedValue(pb.amount);
        return paths.map((p) => puckerBloat(p, amount));
      }
      case "wigglePaths": {
        const wiggle = operator;
        const size = this.getAnimatedValue(wiggle.size);
        const detail = this.getAnimatedValue(wiggle.detail);
        const correlation = this.getAnimatedValue(wiggle.correlation);
        const temporal = this.getAnimatedValue(wiggle.temporalPhase) + this.currentFrame * 0.1;
        const spatial = this.getAnimatedValue(wiggle.spatialPhase);
        return paths.map(
          (p, i) => wigglePath(p, size, detail, wiggle.points, correlation, temporal, spatial, wiggle.randomSeed + i)
        );
      }
      case "zigZag": {
        const zz = operator;
        const size = this.getAnimatedValue(zz.size);
        const ridges = this.getAnimatedValue(zz.ridgesPerSegment);
        return paths.map((p) => zigZagPath(p, size, ridges, zz.points));
      }
      case "twist": {
        const twist = operator;
        const angle = this.getAnimatedValue(twist.angle);
        const center = this.getAnimatedValue(twist.center);
        return paths.map((p) => twistPath(p, angle, center));
      }
      case "roundedCorners": {
        const rc = operator;
        const radius = this.getAnimatedValue(rc.radius);
        return paths.map((p) => roundCorners(p, radius));
      }
      default:
        return paths;
    }
  }
  /**
   * Apply Illustrator-specific operators
   */
  applyIllustratorOperator(paths, operator) {
    switch (operator.type) {
      case "simplifyPath": {
        const simp = operator;
        const tolerance = this.getAnimatedValue(simp.tolerance);
        return paths.map((p) => simplifyPath(p, tolerance, simp.straightLines));
      }
      case "smoothPath": {
        const smooth = operator;
        const amount = this.getAnimatedValue(smooth.amount);
        return paths.map((p) => smoothPath(p, amount));
      }
      case "extrude": {
        this.createExtrudedGeometry(paths, operator);
        return paths;
      }
      case "trace": {
        return paths;
      }
      default:
        return paths;
    }
  }
  /**
   * Apply a shape transform
   */
  applyShapeTransform(path, transform) {
    const anchor = this.getAnimatedValue(transform.anchorPoint);
    const position = this.getAnimatedValue(transform.position);
    const scale = this.getAnimatedValue(transform.scale);
    const rotation = this.getAnimatedValue(transform.rotation);
    return transformPath(path, anchor, position, scale, rotation);
  }
  /**
   * Apply repeater operator
   */
  applyRepeater(paths, repeater) {
    const copies = Math.floor(this.getAnimatedValue(repeater.copies));
    if (copies <= 1) return paths;
    const offset = this.getAnimatedValue(repeater.offset);
    const anchor = this.getAnimatedValue(repeater.transform.anchorPoint);
    const position = this.getAnimatedValue(repeater.transform.position);
    const scale = this.getAnimatedValue(repeater.transform.scale);
    const rotation = this.getAnimatedValue(repeater.transform.rotation);
    const startOp = this.getAnimatedValue(repeater.transform.startOpacity);
    const endOp = this.getAnimatedValue(repeater.transform.endOpacity);
    const repeated = applyRepeater(
      paths,
      copies,
      offset,
      anchor,
      position,
      scale,
      rotation,
      startOp,
      endOp
    );
    const result = [];
    if (repeater.composite === "below") {
      result.push(...paths);
      for (const rep of repeated.slice(1)) {
        result.push(...rep.paths);
      }
    } else {
      for (let i = repeated.length - 1; i >= 1; i--) {
        result.push(...repeated[i].paths);
      }
      result.push(...paths);
    }
    return result;
  }
  /**
   * Apply a modifier (fill/stroke) to an evaluated path
   */
  applyModifier(evalPath, modifier) {
    switch (modifier.type) {
      case "fill": {
        const fill = modifier;
        evalPath.fill = {
          color: this.getAnimatedValue(fill.color),
          opacity: this.getAnimatedValue(fill.opacity),
          rule: fill.fillRule
        };
        break;
      }
      case "stroke": {
        const stroke = modifier;
        evalPath.stroke = {
          color: this.getAnimatedValue(stroke.color),
          opacity: this.getAnimatedValue(stroke.opacity),
          width: this.getAnimatedValue(stroke.width),
          lineCap: stroke.lineCap,
          lineJoin: stroke.lineJoin,
          dashPattern: this.getAnimatedValue(stroke.dashPattern),
          dashOffset: this.getAnimatedValue(stroke.dashOffset)
        };
        break;
      }
      case "gradientFill": {
        const grad = modifier;
        const gradDef = this.getAnimatedValue(grad.gradient);
        evalPath.gradientFill = {
          type: gradDef.type,
          stops: gradDef.stops,
          startPoint: gradDef.startPoint,
          endPoint: gradDef.endPoint,
          opacity: this.getAnimatedValue(grad.opacity)
        };
        break;
      }
    }
  }
  /**
   * Get animated value at current frame
   */
  getAnimatedValue(prop) {
    return prop.value;
  }
  /**
   * Render a single evaluated path to canvas
   */
  renderPath(evalPath) {
    const { path, fill, stroke, gradientFill } = evalPath;
    if (path.vertices.length < 2) return;
    this.ctx.save();
    const path2d = this.buildPath2D(path);
    if (gradientFill) {
      const gradient = this.createGradient(gradientFill);
      this.ctx.globalAlpha = gradientFill.opacity / 100;
      this.ctx.fillStyle = gradient;
      this.ctx.fill(path2d, "nonzero");
    } else if (fill) {
      this.ctx.globalAlpha = fill.opacity / 100;
      this.ctx.fillStyle = this.colorToCSS(fill.color);
      this.ctx.fill(path2d, fill.rule);
    }
    if (stroke && stroke.width > 0) {
      this.ctx.globalAlpha = stroke.opacity / 100;
      this.ctx.strokeStyle = this.colorToCSS(stroke.color);
      this.ctx.lineWidth = stroke.width;
      this.ctx.lineCap = stroke.lineCap;
      this.ctx.lineJoin = stroke.lineJoin;
      if (stroke.dashPattern.length > 0) {
        this.ctx.setLineDash(stroke.dashPattern);
        this.ctx.lineDashOffset = stroke.dashOffset;
      }
      this.ctx.stroke(path2d);
    }
    this.ctx.restore();
  }
  /**
   * Build a Path2D from a BezierPath
   */
  buildPath2D(path) {
    const p = new Path2D();
    if (path.vertices.length === 0) return p;
    const v0 = path.vertices[0];
    p.moveTo(v0.point.x, v0.point.y);
    for (let i = 0; i < path.vertices.length; i++) {
      const curr = path.vertices[i];
      const next = path.vertices[(i + 1) % path.vertices.length];
      if (!path.closed && i === path.vertices.length - 1) break;
      const cp1x = curr.point.x + curr.outHandle.x;
      const cp1y = curr.point.y + curr.outHandle.y;
      const cp2x = next.point.x + next.inHandle.x;
      const cp2y = next.point.y + next.inHandle.y;
      p.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
    }
    if (path.closed) {
      p.closePath();
    }
    return p;
  }
  /**
   * Convert ShapeColor to CSS color string
   */
  colorToCSS(color) {
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
  }
  /**
   * Create canvas gradient
   */
  createGradient(gradDef) {
    if (!gradDef) {
      return this.ctx.createLinearGradient(0, 0, 0, 0);
    }
    const startX = gradDef.startPoint.x * this.canvasWidth;
    const startY = gradDef.startPoint.y * this.canvasHeight;
    const endX = gradDef.endPoint.x * this.canvasWidth;
    const endY = gradDef.endPoint.y * this.canvasHeight;
    let gradient;
    if (gradDef.type === "linear") {
      gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
    } else {
      const radius = Math.sqrt(
        Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
      );
      gradient = this.ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
    }
    for (const stop of gradDef.stops) {
      gradient.addColorStop(stop.position, this.colorToCSS(stop.color));
    }
    return gradient;
  }
  /**
   * Create extruded 3D geometry from paths
   */
  createExtrudedGeometry(paths, extrude) {
    for (const mesh of this.extrudedMeshes) {
      this.extrudeGroup.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    this.extrudedMeshes = [];
    const depth = this.getAnimatedValue(extrude.depth);
    const bevelDepth = this.getAnimatedValue(extrude.bevelDepth);
    const frontColor = this.getAnimatedValue(extrude.material.frontColor);
    this.getAnimatedValue(extrude.material.sideColor);
    for (const path of paths) {
      if (path.vertices.length < 3 || !path.closed) continue;
      const shape = new Shape();
      const v0 = path.vertices[0];
      shape.moveTo(v0.point.x, v0.point.y);
      for (let i = 0; i < path.vertices.length; i++) {
        const curr = path.vertices[i];
        const next = path.vertices[(i + 1) % path.vertices.length];
        const cp1x = curr.point.x + curr.outHandle.x;
        const cp1y = curr.point.y + curr.outHandle.y;
        const cp2x = next.point.x + next.inHandle.x;
        const cp2y = next.point.y + next.inHandle.y;
        shape.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
      }
      const geometry = new ExtrudeGeometry(shape, {
        depth,
        bevelEnabled: bevelDepth > 0,
        bevelThickness: bevelDepth,
        bevelSize: bevelDepth,
        bevelSegments: extrude.bevelSegments
      });
      const material = new MeshStandardMaterial({
        color: new Color(frontColor.r / 255, frontColor.g / 255, frontColor.b / 255),
        metalness: 0.1,
        roughness: 0.8
      });
      const mesh = new Mesh(geometry, material);
      this.extrudeGroup.add(mesh);
      this.extrudedMeshes.push(mesh);
    }
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  dispose() {
    this.texture.dispose();
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    for (const mesh of this.extrudedMeshes) {
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    super.dispose();
  }
}

class LayerManager {
  scene;
  resources;
  layers;
  // Callbacks
  onVideoMetadataLoaded;
  precompRenderContext = null;
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Renderer reference for particle systems
  rendererRef = null;
  // Composition FPS for particle timing
  compositionFPS = 60;
  // Camera reference for particles
  cameraRef = null;
  // Audio reactive callback
  audioReactiveGetter = null;
  // Track matte canvas cache - stores rendered canvases for layers used as track mattes
  trackMatteCanvases = /* @__PURE__ */ new Map();
  // Ordered layer list for render order (respects track matte dependencies)
  renderOrder = [];
  // Callback to get cross-composition matte canvas
  crossCompMatteGetter = null;
  constructor(scene, resources) {
    this.scene = scene;
    this.resources = resources;
    this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(callback) {
    this.onVideoMetadataLoaded = callback;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(context) {
    this.precompRenderContext = context;
    for (const layer of this.layers.values()) {
      if (layer.type === "precomp") {
        layer.setRenderContext(context);
      }
    }
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
    for (const layer of this.layers.values()) {
      if (layer.type === "camera") {
        layer.setCameraCallbacks(getter, updater, atFrameGetter);
      }
    }
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setRenderer(renderer);
      }
    }
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(fps) {
    this.compositionFPS = fps;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setFPS(fps);
      }
      if (layer.type === "video") {
        layer.setFPS(fps);
      }
      if (layer.type === "precomp") {
        layer.setFPS(fps);
      }
    }
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(camera) {
    this.cameraRef = camera;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(layerData) {
    if (this.layers.has(layerData.id)) {
      layerLogger.warn(`LayerManager: Layer ${layerData.id} already exists, updating instead`);
      this.update(layerData.id, layerData);
      return this.layers.get(layerData.id);
    }
    const layer = this.createLayerInstance(layerData);
    this.layers.set(layerData.id, layer);
    this.setupLayerCallbacks(layer, layerData);
    if (layerData.parentId) {
      const parentLayer = this.layers.get(layerData.parentId);
      if (parentLayer) {
        layer.setParent(parentLayer);
      }
    }
    if (!layer.hasParent()) {
      this.scene.addToComposition(layer.getObject());
    }
    return layer;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(layer, layerData) {
    if (layer.type === "video" && this.onVideoMetadataLoaded) {
      const videoLayer = layer;
      videoLayer.setMetadataCallback((metadata) => {
        this.onVideoMetadataLoaded(layerData.id, metadata);
      });
    }
    if (layer.type === "precomp" && this.precompRenderContext) {
      const precompLayer = layer;
      precompLayer.setRenderContext(this.precompRenderContext);
    }
    if (layer.type === "camera" && this.cameraGetter && this.cameraUpdater) {
      const cameraLayer = layer;
      cameraLayer.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter);
      cameraLayer.setSplineProvider(this.createSplineProvider());
    }
    if (layer.type === "particles") {
      const particleLayer = layer;
      if (this.rendererRef) {
        particleLayer.setRenderer(this.rendererRef);
      }
      particleLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "video") {
      const videoLayer = layer;
      videoLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "precomp") {
      const precompLayer = layer;
      precompLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "light") {
      const lightLayer = layer;
      lightLayer.setLayerPositionGetter((layerId) => {
        const targetLayer = this.layers.get(layerId);
        if (targetLayer) {
          const obj = targetLayer.getObject();
          return new Vector3(obj.position.x, obj.position.y, obj.position.z);
        }
        return null;
      });
      lightLayer.setPathProvider(this.createSplineProvider());
    }
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(layerData) {
    switch (layerData.type) {
      case "image":
        return new ImageLayer(layerData, this.resources);
      case "solid":
        return new SolidLayer(layerData);
      case "null":
        return new NullLayer(layerData);
      case "text":
        return new TextLayer(layerData, this.resources);
      case "spline":
        return new SplineLayer(layerData);
      case "particles":
        return new ParticleLayer(layerData);
      case "video":
        return new VideoLayer(layerData, this.resources);
      case "precomp":
        return new PrecompLayer(layerData);
      case "camera":
        return new CameraLayer(layerData);
      case "light":
        return new LightLayer(layerData);
      case "depthflow":
        return new DepthflowLayer(layerData, this.resources);
      case "matte":
        return new ProceduralMatteLayer(layerData);
      case "shape":
        return new ShapeLayer(layerData);
      default:
        layerLogger.warn(`LayerManager: Unknown layer type: ${layerData.type}, creating NullLayer`);
        return new NullLayer(layerData);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(layerId, properties) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for update`);
      return;
    }
    layer.update(properties);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(updates) {
    for (const { id, properties } of updates) {
      this.update(id, properties);
    }
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(layerId) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(layer.getObject());
    layer.dispose();
    this.layers.delete(layerId);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(layerIds) {
    for (const id of layerIds) {
      this.remove(id);
    }
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [id, layer] of this.layers) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer state.
   * Layers receive already-computed values and only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * Rendering order:
   * 1. Spline layers (for text-on-path dependencies)
   * 2. Text-on-path connections
   * 3. Track matte source layers (render to canvas)
   * 4. All other layers (with track mattes applied)
   *
   * @param evaluatedLayers - Pre-evaluated layer states from MotionEngine
   * @param frame - Optional frame number for animated spline/mask evaluation
   */
  applyEvaluatedState(evaluatedLayers, frame) {
    const currentFrame = frame ?? 0;
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type === "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.updateTextPathConnections(frame);
    this.processTrackMattes(currentFrame);
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type !== "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.scene.sortByZ();
  }
  /**
   * Evaluate all layers at a given frame
   *
   * @deprecated Use applyEvaluatedState() with pre-evaluated state from MotionEngine.
   * This method causes layers to internally call interpolateProperty(), violating
   * the single-source-of-truth principle.
   *
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(frame, audioReactiveGetter) {
    this.updateTextPathConnections(frame);
    this.processTrackMattes(frame);
    const getter = audioReactiveGetter ?? this.audioReactiveGetter;
    for (const layer of this.layers.values()) {
      if (getter) {
        const audioValues = getter(layer.id, frame);
        if (audioValues.size > 0) {
          layer.setAudioReactiveValues(audioValues);
        }
      }
      layer.evaluateFrame(frame);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setDrivenValues(values);
    }
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const layer of this.layers.values()) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   *
   * For animated splines, this must be called with the current frame
   * to get properly evaluated control points.
   *
   * @param frame - Optional frame number for animated spline evaluation
   */
  updateTextPathConnections(frame) {
    for (const layer of this.layers.values()) {
      if (layer.type === "text") {
        const textLayer = layer;
        const textData = textLayer.getTextData();
        if (textData.pathLayerId) {
          const splineLayer = this.layers.get(textData.pathLayerId);
          if (splineLayer && splineLayer.type === "spline") {
            if (splineLayer.isAnimated() && frame !== void 0) {
              const evaluatedPoints = splineLayer.getEvaluatedControlPoints(frame);
              const controlPoints = evaluatedPoints.map((ep) => ({
                id: ep.id,
                x: ep.x,
                y: ep.y,
                depth: ep.depth,
                handleIn: ep.handleIn,
                handleOut: ep.handleOut,
                type: ep.type
              }));
              textLayer.setPathFromControlPoints(controlPoints, splineLayer.isClosed());
            } else {
              const curve = splineLayer.getCurve();
              if (curve) {
                textLayer.setPathFromCurve(curve);
              }
            }
          }
        }
      }
    }
  }
  // ============================================================================
  // SPLINE PATH PROVIDER (for Particle Systems)
  // ============================================================================
  /**
   * Create a SplinePathProvider that can be used by particle systems
   * to query spline positions for path-based emission
   *
   * USAGE:
   * ```typescript
   * const provider = layerManager.createSplineProvider();
   * particleSystem.setSplineProvider(provider);
   * ```
   */
  createSplineProvider() {
    return (layerId, t, frame) => {
      return this.querySplinePath(layerId, t, frame);
    };
  }
  /**
   * Query a spline layer for position and tangent at parameter t
   *
   * @param layerId - ID of the spline layer
   * @param t - Parameter along the path (0-1)
   * @param frame - Current frame for animated splines
   * @returns Position, tangent, and length or null if spline not found
   */
  querySplinePath(layerId, t, frame) {
    const layer = this.layers.get(layerId);
    if (!layer || layer.type !== "spline") {
      return null;
    }
    const splineLayer = layer;
    if (splineLayer.isAnimated()) {
      splineLayer.getEvaluatedControlPoints(frame);
    }
    const point = splineLayer.getPointAt(t);
    const tangent = splineLayer.getTangentAt(t);
    const length = splineLayer.getLength();
    if (!point || !tangent) {
      return null;
    }
    return {
      point: {
        x: point.x,
        y: -point.y,
        // Negate back from Three.js coordinate system
        z: point.z
      },
      tangent: {
        x: tangent.x,
        y: -tangent.y
        // Negate back
      },
      length
    };
  }
  /**
   * Get all spline layer IDs (useful for UI to list available paths)
   */
  getSplineLayerIds() {
    const ids = [];
    for (const [id, layer] of this.layers) {
      if (layer.type === "spline") {
        ids.push(id);
      }
    }
    return ids;
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(textLayerId, splineLayerId) {
    const textLayer = this.layers.get(textLayerId);
    if (!textLayer || textLayer.type !== "text") {
      layerLogger.warn(`LayerManager: Text layer ${textLayerId} not found`);
      return;
    }
    if (!splineLayerId) {
      textLayer.clearPath();
      return;
    }
    const splineLayer = this.layers.get(splineLayerId);
    if (!splineLayer || splineLayer.type !== "spline") {
      layerLogger.warn(`LayerManager: Spline layer ${splineLayerId} not found`);
      return;
    }
    const curve = splineLayer.getCurve();
    if (curve) {
      textLayer.setPathFromCurve(curve);
    }
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(layerId) {
    return this.layers.get(layerId)?.getObject() ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(layerId) {
    return this.layers.get(layerId) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(type) {
    return Array.from(this.layers.values()).filter(
      (layer) => layer.type === type
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(layerId) {
    return this.layers.has(layerId);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const layer of this.layers.values()) {
      if (layer.hasParent()) {
        const parent = layer.getParent();
        if (parent) {
          parent.getObject().remove(layer.getObject());
        }
      }
    }
    for (const layer of this.layers.values()) {
      const parentId = layer.getParentId();
      if (parentId) {
        const parentLayer = this.layers.get(parentId);
        if (parentLayer) {
          layer.setParent(parentLayer);
        } else {
          layer.setParent(null);
          this.scene.addToComposition(layer.getObject());
        }
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(layerId, parentId) {
    const layer = this.layers.get(layerId);
    if (!layer) return;
    if (layer.hasParent()) {
      const oldParent = layer.getParent();
      if (oldParent) {
        oldParent.getObject().remove(layer.getObject());
      }
    } else {
      this.scene.removeFromComposition(layer.getObject());
    }
    if (parentId) {
      const newParent = this.layers.get(parentId);
      if (newParent) {
        layer.setParent(newParent);
      } else {
        layer.setParent(null);
        this.scene.addToComposition(layer.getObject());
      }
    } else {
      layer.setParent(null);
      this.scene.addToComposition(layer.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(layerId, z) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.getObject().position.z = z;
      this.scene.sortByZ();
    }
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(layerId, visible) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setVisible(visible);
    }
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      const newVisible = !layer.getObject().visible;
      layer.setVisible(newVisible);
      return newVisible;
    }
    return false;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(layerId) {
    for (const [id, layer] of this.layers) {
      layer.setVisible(id === layerId);
    }
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const layer of this.layers.values()) {
      layer.setVisible(true);
    }
  }
  // ============================================================================
  // TRACK MATTE PROCESSING
  // ============================================================================
  /**
   * Set callback for retrieving cross-composition matte canvases
   *
   * This enables track mattes from other compositions (precomps)
   * to be used as matte sources.
   */
  setCrossCompMatteGetter(getter) {
    this.crossCompMatteGetter = getter;
  }
  /**
   * Process track mattes for all layers
   *
   * Track mattes use one layer's rendered output to control
   * another layer's visibility (alpha or luma).
   *
   * This method:
   * 1. Identifies layers that are used as track mattes
   * 2. Collects their rendered canvases (from same comp or cross-comp)
   * 3. Passes the canvas to layers that use them as mattes
   *
   * @param frame - Current frame number for animated evaluation
   */
  processTrackMattes(frame) {
    this.trackMatteCanvases.clear();
    for (const layer of this.layers.values()) {
      const matteLayerId = layer.getTrackMatteLayerId();
      const matteType = layer.getTrackMatteType();
      if (!matteLayerId || matteType === "none") {
        continue;
      }
      let matteCanvas = null;
      if (layer.hasCrossCompMatte() && this.crossCompMatteGetter) {
        const compositionId = layer.getTrackMatteCompositionId();
        matteCanvas = this.crossCompMatteGetter(compositionId, matteLayerId, frame);
        if (!matteCanvas) {
          layerLogger.warn(
            `Cross-comp track matte not found: composition=${compositionId}, layer=${matteLayerId}`
          );
        }
      } else {
        const matteLayer = this.layers.get(matteLayerId);
        if (matteLayer) {
          if (this.trackMatteCanvases.has(matteLayerId)) {
            matteCanvas = this.trackMatteCanvases.get(matteLayerId);
          } else {
            matteCanvas = this.getLayerRenderedCanvas(matteLayer, frame);
            if (matteCanvas) {
              this.trackMatteCanvases.set(matteLayerId, matteCanvas);
            }
          }
        } else {
          layerLogger.warn(`Track matte source layer ${matteLayerId} not found`);
        }
      }
      layer.setTrackMatteCanvas(matteCanvas);
    }
  }
  /**
   * Get the rendered canvas from a layer (for use as track matte)
   *
   * This gets the layer's visual output as a canvas that can be used
   * for track matte operations.
   *
   * @param layer - The layer to get canvas from
   * @param frame - Current frame for animated content
   * @returns Canvas with layer's rendered content, or null if unavailable
   */
  getLayerRenderedCanvas(layer, frame) {
    const sourceCanvas = layer.getSourceCanvas?.();
    if (sourceCanvas) {
      const canvas = document.createElement("canvas");
      canvas.width = sourceCanvas.width;
      canvas.height = sourceCanvas.height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        return canvas;
      }
    }
    return null;
  }
  /**
   * Update masks for a specific layer
   */
  setLayerMasks(layerId, masks) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setMasks(masks);
    }
  }
  /**
   * Clear track matte assignment for a layer
   */
  clearTrackMatte(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setTrackMatteCanvas(null);
    }
  }
  /**
   * Compute render order respecting track matte dependencies
   *
   * Matte layers must be rendered before the layers that use them.
   * This returns a topologically sorted list of layer IDs.
   */
  computeRenderOrder() {
    const order = [];
    const visited = /* @__PURE__ */ new Set();
    const visiting = /* @__PURE__ */ new Set();
    const visit = (layerId) => {
      if (visited.has(layerId)) return;
      if (visiting.has(layerId)) {
        layerLogger.warn(`Circular track matte dependency detected involving layer ${layerId}`);
        return;
      }
      visiting.add(layerId);
      const layer = this.layers.get(layerId);
      if (layer) {
        const matteLayerId = layer.getTrackMatteLayerId();
        if (matteLayerId && this.layers.has(matteLayerId)) {
          visit(matteLayerId);
        }
        const parentId = layer.getParentId();
        if (parentId && this.layers.has(parentId)) {
          visit(parentId);
        }
      }
      visiting.delete(layerId);
      visited.add(layerId);
      order.push(layerId);
    };
    for (const layerId of this.layers.keys()) {
      visit(layerId);
    }
    this.renderOrder = order;
    return order;
  }
  /**
   * Get the computed render order
   */
  getRenderOrder() {
    return this.renderOrder;
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(x, y, camera) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, camera);
    const intersects = this.scene.raycastComposition(raycaster);
    const layerIds = /* @__PURE__ */ new Set();
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          layerIds.add(obj.userData.layerId);
          break;
        }
        obj = obj.parent;
      }
    }
    return Array.from(layerIds).map((id) => this.layers.get(id)).filter((layer) => layer !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const layer of this.layers.values()) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
}

class CameraController {
  /** The main camera */
  camera;
  /** Keyframe evaluator for animations */
  evaluator;
  /** Composition dimensions */
  width;
  height;
  /** Animation properties */
  positionProp;
  targetProp;
  fovProp;
  /** Current target position (for lookAt) */
  target;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.evaluator = new KeyframeEvaluator();
    this.camera = new PerspectiveCamera(
      50,
      // Field of view
      width / height,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = height / 2 / Math.tan(fovRad / 2);
    this.camera.position.set(width / 2, -height / 2, distance);
    this.target = new Vector3(width / 2, -height / 2, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera position directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setPositionDirect(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera target directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setTargetDirect(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(x, y, z) {
    this.camera.rotation.set(
      MathUtils.degToRad(x),
      MathUtils.degToRad(y),
      MathUtils.degToRad(z)
    );
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(fov) {
    this.camera.fov = MathUtils.clamp(fov, 1, 179);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(near, far) {
    this.camera.near = Math.max(1e-3, near);
    this.camera.far = Math.max(this.camera.near + 1, far);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEWPORT ZOOM/PAN
  // ============================================================================
  /** Pan offset for viewport navigation */
  panOffset = new Vector2(0, 0);
  zoomLevel = 1;
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(zoom) {
    this.zoomLevel = Math.max(0.1, Math.min(10, zoom));
    this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(x, y) {
    this.panOffset.set(x, y);
    this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const baseDistance = this.height / 2 / Math.tan(fovRad / 2);
    const distance = baseDistance / this.zoomLevel;
    const centerX = this.width / 2 - this.panOffset.x / this.zoomLevel;
    const centerY = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(centerX, -centerY, distance);
    this.target.set(centerX, -centerY, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(props) {
    this.positionProp = props.position;
    this.targetProp = props.target;
    this.fovProp = props.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0;
    this.targetProp = void 0;
    this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(frame) {
    if (this.positionProp) {
      const pos = this.evaluator.evaluate(this.positionProp, frame);
      this.setPosition(pos.x, pos.y, pos.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const target = this.evaluator.evaluate(this.targetProp, frame);
      this.setTarget(target.x, target.y, target.z ?? 0);
    }
    if (this.fovProp) {
      const fov = this.evaluator.evaluate(this.fovProp, frame);
      this.setFOV(fov);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = height / 2 / Math.tan(fovRad / 2);
    this.camera.position.x = width / 2;
    this.camera.position.y = -height / 2;
    this.camera.position.z = distance;
    this.target.set(width / 2, -height / 2, 0);
    this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(screenX, screenY, z = 0) {
    const ndcX = screenX / this.width * 2 - 1;
    const ndcY = -(screenY / this.height) * 2 + 1;
    const vector = new Vector3(ndcX, ndcY, 0.5);
    vector.unproject(this.camera);
    const dir = vector.sub(this.camera.position).normalize();
    const distance = (z - this.camera.position.z) / dir.z;
    return this.camera.position.clone().add(dir.multiplyScalar(distance));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(worldX, worldY, worldZ = 0) {
    const vector = new Vector3(worldX, -worldY, worldZ);
    vector.project(this.camera);
    return {
      x: (vector.x + 1) / 2 * this.width,
      y: (-vector.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(state) {
    if (state.position) {
      this.setPosition(state.position.x, state.position.y, state.position.z);
    }
    if (state.target) {
      this.setTarget(state.target.x, state.target.y, state.target.z);
    }
    if (state.fov !== void 0) {
      this.setFOV(state.fov);
    }
    if (state.near !== void 0 || state.far !== void 0) {
      this.setClipPlanes(
        state.near ?? this.camera.near,
        state.far ?? this.camera.far
      );
    }
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const fovRad = MathUtils.degToRad(50);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    this.camera.fov = 50;
    this.camera.position.set(this.width / 2, -this.height / 2, distance);
    this.target.set(this.width / 2, -this.height / 2, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const ortho = new OrthographicCamera(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    ortho.position.set(0, 0, 1e3);
    ortho.lookAt(0, 0, 0);
    return ortho;
  }
  // ============================================================================
  // 3D ORBIT CONTROLS
  // ============================================================================
  /** Current spherical coordinates for orbit mode */
  spherical = { radius: 1e3, theta: 0, phi: Math.PI / 2 };
  /** Whether orbit mode is enabled */
  orbitEnabled = false;
  /**
   * Enable orbit mode for 3D navigation
   * In orbit mode, the camera orbits around the target point
   */
  enableOrbitMode() {
    this.orbitEnabled = true;
    const offset = new Vector3().subVectors(this.camera.position, this.target);
    this.spherical.radius = offset.length();
    this.spherical.theta = Math.atan2(offset.x - this.target.x, offset.z);
    this.spherical.phi = Math.acos(MathUtils.clamp(offset.y / this.spherical.radius, -1, 1));
  }
  /**
   * Disable orbit mode (return to pan/zoom mode)
   */
  disableOrbitMode() {
    this.orbitEnabled = false;
  }
  /**
   * Check if orbit mode is active
   */
  isOrbitMode() {
    return this.orbitEnabled;
  }
  /**
   * Orbit camera around target point
   * @param deltaTheta - Horizontal rotation in radians (around Y axis)
   * @param deltaPhi - Vertical rotation in radians (around X axis)
   */
  orbit(deltaTheta, deltaPhi) {
    if (!this.orbitEnabled) return;
    this.spherical.theta -= deltaTheta;
    this.spherical.phi = MathUtils.clamp(
      this.spherical.phi - deltaPhi,
      0.01,
      // Prevent flipping at poles
      Math.PI - 0.01
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Dolly (zoom in/out) in orbit mode
   * @param delta - Positive to zoom in, negative to zoom out
   */
  dolly(delta) {
    if (!this.orbitEnabled) {
      this.setZoom(this.zoomLevel * (1 + delta * 0.1));
      return;
    }
    this.spherical.radius = MathUtils.clamp(
      this.spherical.radius * (1 - delta * 0.1),
      10,
      // Minimum distance
      5e4
      // Maximum distance
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Pan camera in orbit mode (move target point)
   * @param deltaX - Horizontal pan in screen pixels
   * @param deltaY - Vertical pan in screen pixels
   */
  orbitPan(deltaX, deltaY) {
    if (!this.orbitEnabled) {
      this.setPan(this.panOffset.x + deltaX, this.panOffset.y + deltaY);
      return;
    }
    const panSpeed = this.spherical.radius * 1e-3;
    const right = new Vector3();
    const up = new Vector3();
    right.setFromMatrixColumn(this.camera.matrix, 0);
    up.setFromMatrixColumn(this.camera.matrix, 1);
    const panOffset = new Vector3();
    panOffset.addScaledVector(right, -deltaX * panSpeed);
    panOffset.addScaledVector(up, deltaY * panSpeed);
    this.target.add(panOffset);
    this.updateCameraFromSpherical();
  }
  /**
   * Update camera position from spherical coordinates
   */
  updateCameraFromSpherical() {
    const x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
    const y = this.spherical.radius * Math.cos(this.spherical.phi);
    const z = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
    this.camera.position.set(
      this.target.x + x,
      this.target.y + y,
      this.target.z + z
    );
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEW PRESETS
  // ============================================================================
  /**
   * Available orthographic view presets
   */
  static VIEW_PRESETS = {
    front: { theta: 0, phi: Math.PI / 2, name: "Front" },
    back: { theta: Math.PI, phi: Math.PI / 2, name: "Back" },
    left: { theta: -Math.PI / 2, phi: Math.PI / 2, name: "Left" },
    right: { theta: Math.PI / 2, phi: Math.PI / 2, name: "Right" },
    top: { theta: 0, phi: 0.01, name: "Top" },
    bottom: { theta: 0, phi: Math.PI - 0.01, name: "Bottom" },
    perspective: { theta: Math.PI / 4, phi: Math.PI / 3, name: "Perspective" }
  };
  /**
   * Switch to a predefined view preset
   * @param preset - Name of the view preset
   * @param animate - Whether to animate the transition (default: false)
   */
  setViewPreset(preset, animate = false) {
    const view = CameraController.VIEW_PRESETS[preset];
    if (!view) return;
    if (!this.orbitEnabled) {
      this.enableOrbitMode();
    }
    if (animate) {
      const startTheta = this.spherical.theta;
      const startPhi = this.spherical.phi;
      const targetTheta = view.theta;
      const targetPhi = view.phi;
      const duration = 300;
      const startTime = performance.now();
      const animateView = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.spherical.theta = startTheta + (targetTheta - startTheta) * eased;
        this.spherical.phi = startPhi + (targetPhi - startPhi) * eased;
        this.updateCameraFromSpherical();
        if (t < 1) {
          requestAnimationFrame(animateView);
        }
      };
      requestAnimationFrame(animateView);
    } else {
      this.spherical.theta = view.theta;
      this.spherical.phi = view.phi;
      this.updateCameraFromSpherical();
    }
  }
  /**
   * Reset camera to default 2D view (centered on composition)
   */
  resetTo2DView() {
    this.disableOrbitMode();
    this.panOffset.set(0, 0);
    this.zoomLevel = 1;
    this.reset();
  }
  /**
   * Reset orbit to center on composition
   */
  resetOrbit() {
    this.target.set(this.width / 2, -this.height / 2, 0);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    this.spherical.radius = this.height / 2 / Math.tan(fovRad / 2);
    this.spherical.theta = 0;
    this.spherical.phi = Math.PI / 2;
    if (this.orbitEnabled) {
      this.updateCameraFromSpherical();
    } else {
      this.reset();
    }
  }
  // ============================================================================
  // FOCUS & FRAMING
  // ============================================================================
  /**
   * Focus camera on a bounding box, framing it in view
   * @param bounds - { min: {x, y, z}, max: {x, y, z} }
   */
  focusOnBounds(bounds) {
    const center = new Vector3(
      (bounds.min.x + bounds.max.x) / 2,
      -(bounds.min.y + bounds.max.y) / 2,
      // Negate for screen coords
      (bounds.min.z + bounds.max.z) / 2
    );
    const size = new Vector3(
      bounds.max.x - bounds.min.x,
      bounds.max.y - bounds.min.y,
      bounds.max.z - bounds.min.z
    );
    const maxDim = Math.max(size.x, size.y, size.z);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = maxDim / 2 / Math.tan(fovRad / 2) * 1.5;
    this.target.copy(center);
    if (this.orbitEnabled) {
      this.spherical.radius = distance;
      this.updateCameraFromSpherical();
    } else {
      this.camera.position.set(center.x, center.y, center.z + distance);
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
  }
  /**
   * Focus on a layer by its bounding rect
   * @param x - Layer X position
   * @param y - Layer Y position
   * @param width - Layer width
   * @param height - Layer height
   * @param z - Layer Z position (default 0)
   */
  focusOnLayer(x, y, width, height, z = 0) {
    this.focusOnBounds({
      min: { x, y, z: z - 10 },
      max: { x: x + width, y: y + height, z: z + 10 }
    });
  }
  // ============================================================================
  // CAMERA BOOKMARKS
  // ============================================================================
  /** Stored camera bookmarks */
  bookmarks = /* @__PURE__ */ new Map();
  /**
   * Save current camera state as a bookmark
   * @param name - Name for the bookmark
   */
  saveBookmark(name) {
    this.bookmarks.set(name, {
      position: this.camera.position.clone(),
      target: this.target.clone(),
      spherical: { ...this.spherical },
      fov: this.camera.fov,
      orbitEnabled: this.orbitEnabled
    });
  }
  /**
   * Load a saved camera bookmark
   * @param name - Name of the bookmark
   * @param animate - Whether to animate transition
   */
  loadBookmark(name, animate = false) {
    const bookmark = this.bookmarks.get(name);
    if (!bookmark) return false;
    if (animate) {
      const startPos = this.camera.position.clone();
      const startTarget = this.target.clone();
      const startFov = this.camera.fov;
      const duration = 500;
      const startTime = performance.now();
      const animateBookmark = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.camera.position.lerpVectors(startPos, bookmark.position, eased);
        this.target.lerpVectors(startTarget, bookmark.target, eased);
        this.camera.fov = startFov + (bookmark.fov - startFov) * eased;
        this.camera.lookAt(this.target);
        this.camera.updateProjectionMatrix();
        if (t < 1) {
          requestAnimationFrame(animateBookmark);
        } else {
          this.spherical = { ...bookmark.spherical };
          this.orbitEnabled = bookmark.orbitEnabled;
        }
      };
      requestAnimationFrame(animateBookmark);
    } else {
      this.camera.position.copy(bookmark.position);
      this.target.copy(bookmark.target);
      this.camera.fov = bookmark.fov;
      this.spherical = { ...bookmark.spherical };
      this.orbitEnabled = bookmark.orbitEnabled;
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
    return true;
  }
  /**
   * Delete a bookmark
   * @param name - Name of the bookmark
   */
  deleteBookmark(name) {
    return this.bookmarks.delete(name);
  }
  /**
   * Get list of bookmark names
   */
  getBookmarkNames() {
    return Array.from(this.bookmarks.keys());
  }
  /**
   * Export all bookmarks as JSON-serializable data
   */
  exportBookmarks() {
    const result = {};
    this.bookmarks.forEach((value, key) => {
      result[key] = {
        position: { x: value.position.x, y: value.position.y, z: value.position.z },
        target: { x: value.target.x, y: value.target.y, z: value.target.z },
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      };
    });
    return result;
  }
  /**
   * Import bookmarks from JSON data
   */
  importBookmarks(data) {
    Object.entries(data).forEach(([name, value]) => {
      this.bookmarks.set(name, {
        position: new Vector3(value.position.x, value.position.y, value.position.z),
        target: new Vector3(value.target.x, value.target.y, value.target.z),
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      });
    });
  }
}

class ResourceManager {
  // Texture cache (keyed by URL or ID)
  textures;
  // Geometry cache (keyed by type and parameters)
  geometries;
  // Material cache (keyed by configuration hash)
  materials;
  // Texture loader
  textureLoader;
  // Asset getter callback (set by WeylEngine)
  assetGetter;
  // Statistics
  stats = {
    texturesLoaded: 0,
    texturesFromCache: 0,
    geometriesCreated: 0,
    geometriesFromCache: 0
  };
  constructor() {
    this.textures = /* @__PURE__ */ new Map();
    this.geometries = /* @__PURE__ */ new Map();
    this.materials = /* @__PURE__ */ new Map();
    this.textureLoader = new TextureLoader();
    this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(assetId) {
    return this.assetGetter?.(assetId);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const plane = new PlaneGeometry(1, 1, 1, 1);
    this.geometries.set("plane:1:1", plane);
    const quad = new PlaneGeometry(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", quad);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(url, options) {
    const cacheKey = this.getTextureCacheKey(url, options);
    const cached = this.textures.get(cacheKey);
    if (cached) {
      this.stats.texturesFromCache++;
      return cached;
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.applyTextureOptions(texture, options);
          this.textures.set(cacheKey, texture);
          this.stats.texturesLoaded++;
          resolve(texture);
        },
        void 0,
        // Progress callback
        (error) => {
          renderLogger.error("ResourceManager: Failed to load texture:", url, error);
          reject(error);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(imageData, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof DataTexture) {
      cached.image = imageData;
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new DataTexture(
      imageData.data,
      imageData.width,
      imageData.height,
      RGBAFormat,
      UnsignedByteType
    );
    this.applyTextureOptions(texture, options);
    texture.needsUpdate = true;
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(canvas, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof CanvasTexture) {
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new CanvasTexture(canvas);
    this.applyTextureOptions(texture, options);
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Get a cached texture
   */
  getTexture(key) {
    return this.textures.get(key);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(texture, options) {
    if (!options) {
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.colorSpace = SRGBColorSpace;
      return;
    }
    if (options.wrapS !== void 0) texture.wrapS = options.wrapS;
    if (options.wrapT !== void 0) texture.wrapT = options.wrapT;
    if (options.minFilter !== void 0) texture.minFilter = options.minFilter;
    if (options.magFilter !== void 0) texture.magFilter = options.magFilter;
    if (options.generateMipmaps !== void 0) texture.generateMipmaps = options.generateMipmaps;
    if (options.flipY !== void 0) texture.flipY = options.flipY;
    if (options.colorSpace !== void 0) texture.colorSpace = options.colorSpace;
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(url, options) {
    if (!options) return url;
    return `${url}:${JSON.stringify(options)}`;
  }
  /**
   * Release a texture
   */
  releaseTexture(key) {
    const texture = this.textures.get(key);
    if (texture) {
      texture.dispose();
      this.textures.delete(key);
    }
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(layerId) {
    const layerKey = `layer:${layerId}`;
    const layerTexture = this.textures.get(layerKey);
    if (layerTexture) {
      return layerTexture;
    }
    return null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(layerId, texture) {
    const key = `layer:${layerId}`;
    this.textures.set(key, texture);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(width = 1, height = 1) {
    const key = `plane:${width}:${height}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new PlaneGeometry(width, height, 1, 1);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(radius = 1, segments = 32) {
    const key = `circle:${radius}:${segments}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new CircleGeometry(radius, segments);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(width = 1, height = 1, depth = 1) {
    const key = `box:${width}:${height}:${depth}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new BoxGeometry(width, height, depth);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(options) {
    const key = `basic:${JSON.stringify(options)}`;
    let material = this.materials.get(key);
    if (material) {
      return material;
    }
    material = new MeshBasicMaterial({
      color: options.color ?? 16777215,
      transparent: options.transparent ?? true,
      opacity: options.opacity ?? 1,
      map: options.map,
      side: options.side ?? DoubleSide
    });
    this.materials.set(key, material);
    return material;
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(type) {
    switch (type) {
      case "basic":
        return new MeshBasicMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "standard":
        return new MeshStandardMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "shader":
        return new ShaderMaterial();
      default:
        return new MeshBasicMaterial();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const texture of this.textures.values()) {
      texture.dispose();
    }
    this.textures.clear();
    for (const geometry of this.geometries.values()) {
      geometry.dispose();
    }
    this.geometries.clear();
    for (const material of this.materials.values()) {
      material.dispose();
    }
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    renderLogger.debug("ResourceManager: Resource stats:", this.getStats());
  }
}

class PerformanceMonitor {
  // Frame timing
  frameCount = 0;
  lastTime = 0;
  frameTimes = [];
  maxFrameTimes = 60;
  // FPS calculation
  fps = 0;
  fpsUpdateInterval = 500;
  // ms
  lastFpsUpdate = 0;
  framesInInterval = 0;
  // Frame start time (for measuring frame duration)
  frameStartTime = 0;
  // Last captured stats
  lastStats = {
    fps: 0,
    frameTime: 0,
    drawCalls: 0,
    triangles: 0,
    textures: 0,
    geometries: 0,
    memoryUsed: 0
  };
  constructor() {
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(renderer) {
    const now = performance.now();
    const frameTime = now - this.frameStartTime;
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxFrameTimes) {
      this.frameTimes.shift();
    }
    this.frameCount++;
    this.framesInInterval++;
    const timeSinceUpdate = now - this.lastFpsUpdate;
    if (timeSinceUpdate >= this.fpsUpdateInterval) {
      this.fps = Math.round(this.framesInInterval * 1e3 / timeSinceUpdate);
      this.framesInInterval = 0;
      this.lastFpsUpdate = now;
    }
    const info = renderer.info;
    const memory = performance.memory;
    const memoryUsed = memory?.usedJSHeapSize ?? 0;
    const avgFrameTime = this.frameTimes.length > 0 ? this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length : 0;
    this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(avgFrameTime * 100) / 100,
      drawCalls: info.render.calls,
      triangles: info.render.triangles,
      textures: info.memory.textures,
      geometries: info.memory.geometries,
      memoryUsed
    };
    this.lastTime = now;
    return this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    if (this.frameTimes.length === 0) return 0;
    return this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    if (this.frameTimes.length === 0) {
      return { min: 0, max: 0 };
    }
    return {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0;
    this.frameTimes = [];
    this.fps = 0;
    this.framesInInterval = 0;
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
    this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(targetFps = 30) {
    return this.fps > 0 && this.fps < targetFps;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const stats = this.lastStats;
    const range = this.getFrameTimeRange();
    return [
      `FPS: ${stats.fps}`,
      `Frame Time: ${stats.frameTime.toFixed(2)}ms (min: ${range.min.toFixed(2)}, max: ${range.max.toFixed(2)})`,
      `Draw Calls: ${stats.drawCalls}`,
      `Triangles: ${stats.triangles.toLocaleString()}`,
      `Textures: ${stats.textures}`,
      `Geometries: ${stats.geometries}`,
      `Memory: ${(stats.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join("\n");
  }
}

class WeylEngine {
  // Core subsystems
  scene;
  renderer;
  layers;
  camera;
  resources;
  performance;
  // State
  state;
  animationFrameId = null;
  // Background and overlay images
  backgroundImage = null;
  depthMapMesh = null;
  depthMapSettings = { colormap: "viridis", opacity: 0.5, visible: false };
  // Viewport transform for pan/zoom
  viewportTransform = [1, 0, 0, 1, 0, 0];
  // Render mode
  renderMode = "color";
  // Audio reactivity
  audioReactiveGetter = null;
  // Transform controls for layer manipulation
  transformControls = null;
  selectedLayerId = null;
  transformMode = "translate";
  // Transform change callback
  onTransformChange = null;
  // Event system
  eventHandlers;
  // Configuration
  config;
  constructor(config) {
    this.validateConfig(config);
    this.config = {
      canvas: config.canvas,
      width: config.width,
      height: config.height,
      compositionWidth: config.compositionWidth ?? config.width,
      compositionHeight: config.compositionHeight ?? config.height,
      pixelRatio: config.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      backgroundColor: config.backgroundColor ?? null,
      debug: config.debug ?? false,
      powerPreference: config.powerPreference ?? "high-performance"
    };
    this.state = {
      currentFrame: 0,
      // DEPRECATED: Use MotionEngine as time authority
      isRendering: false,
      isDisposed: false,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    };
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.resources = new ResourceManager();
    this.scene = new SceneManager(this.config.backgroundColor);
    this.camera = new CameraController(this.config.width, this.config.height);
    this.renderer = new RenderPipeline({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera);
    this.layers = new LayerManager(this.scene, this.resources);
    this.performance = new PerformanceMonitor();
    this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.setupContextLossHandling();
    if (this.config.debug) {
      engineLogger.debug("Initialized", this.config);
    }
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(config) {
    if (!(config.canvas instanceof HTMLCanvasElement)) {
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    }
    if (config.width <= 0 || config.height <= 0) {
      throw new Error("WeylEngine requires positive width and height");
    }
    if (config.width > 8192 || config.height > 8192) {
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
    }
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(layerData) {
    this.assertNotDisposed();
    this.layers.create(layerData);
    this.emit("layerAdded", { layerId: layerData.id });
    if (this.config.debug) {
      engineLogger.debug("Layer added:", layerData.id, layerData.type);
    }
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(layerId, properties) {
    this.assertNotDisposed();
    this.layers.update(layerId, properties);
    this.emit("layerUpdated", { layerId, properties });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(layerId) {
    this.assertNotDisposed();
    this.layers.remove(layerId);
    this.emit("layerRemoved", { layerId });
    if (this.config.debug) {
      engineLogger.debug("Layer removed:", layerId);
    }
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(layerId) {
    return this.layers.getObject(layerId);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(layers) {
    this.assertNotDisposed();
    const existingIds = new Set(this.layers.getLayerIds());
    const newIds = new Set(layers.map((l) => l.id));
    for (const id of existingIds) {
      if (!newIds.has(id)) {
        this.layers.remove(id);
      }
    }
    for (const layer of layers) {
      if (existingIds.has(layer.id)) {
        this.layers.update(layer.id, layer);
      } else {
        this.layers.create(layer);
      }
    }
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(getter) {
    this.resources.setAssetGetter(getter);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(callback) {
    this.layers.setVideoMetadataCallback(callback);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(context) {
    this.layers.setPrecompRenderContext(context);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.layers.setCameraCallbacks(getter, updater, atFrameGetter);
    this.activeCameraGetter = getter;
  }
  // Active camera tracking
  activeCameraGetter;
  activeCameraId = null;
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(cameraLayerId) {
    this.activeCameraId = cameraLayerId;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter) {
      return;
    }
    const cameraLayer = this.layers.getLayer(this.activeCameraId);
    if (!cameraLayer || cameraLayer.type !== "camera") {
      return;
    }
    const typedLayer = cameraLayer;
    const exportData = typedLayer.getExportData();
    if (!exportData) {
      return;
    }
    this.camera.setPosition(exportData.position.x, exportData.position.y, exportData.position.z);
    this.camera.setRotation(exportData.rotation.x, exportData.rotation.y, exportData.rotation.z);
    this.camera.setFOV(exportData.fov);
    this.camera.setClipPlanes(exportData.nearClip, exportData.farClip);
    const camera3d = typedLayer.getCameraAtCurrentFrame();
    if (camera3d && camera3d.depthOfField) {
      this.setDOFFromCamera(camera3d.depthOfField);
    }
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(fps) {
    this.layers.setCompositionFPS(fps);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer());
    this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const cam = this.camera.camera;
    return {
      projectionMatrix: cam.projectionMatrix.clone(),
      viewMatrix: cam.matrixWorldInverse.clone(),
      projectionMatrixInverse: cam.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    this.layers.setLayerDrivenValues(layerId, values);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    this.layers.clearLayerDrivenValues(layerId);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Apply a pre-evaluated FrameState from MotionEngine
   *
   * This is the CANONICAL way to update the rendering state.
   * FrameState is computed by MotionEngine.evaluate() which is PURE.
   *
   * ARCHITECTURAL RULE:
   * - Layers receive already-evaluated values via applyEvaluatedState()
   * - NO interpolation or time sampling happens here
   * - Single source of truth: MotionEngine
   *
   * @param frameState - Pre-evaluated state from MotionEngine.evaluate()
   */
  applyFrameState(frameState) {
    this.assertNotDisposed();
    this.state.currentFrame = frameState.frame;
    this.layers.applyEvaluatedState(frameState.layers, frameState.frame);
    if (frameState.camera) {
      this.applyCameraState(frameState.camera);
    } else {
      this.syncActiveCamera();
      if (!this.activeCameraId) {
        this.camera.evaluateFrame(frameState.frame);
      }
    }
  }
  /**
   * Apply evaluated camera state directly
   */
  applyCameraState(cameraState) {
    if (!cameraState) return;
    this.camera.setPositionDirect(
      cameraState.position.x,
      cameraState.position.y,
      cameraState.position.z
    );
    this.camera.setTargetDirect(
      cameraState.target.x,
      cameraState.target.y,
      cameraState.target.z
    );
    this.camera.setFOV(cameraState.fov);
  }
  /**
   * Set the current frame for animation evaluation
   *
   * @deprecated Use applyFrameState() with MotionEngine.evaluate() instead.
   * This method evaluates frames directly, bypassing the single time authority.
   * It is kept for backwards compatibility but should be phased out.
   *
   * @param frame - The frame number (0-indexed)
   */
  setFrame(frame) {
    this.assertNotDisposed();
    this.state.currentFrame = frame;
    this.layers.evaluateFrame(frame, this.audioReactiveGetter);
    this.syncActiveCamera();
    if (!this.activeCameraId) {
      this.camera.evaluateFrame(frame);
    }
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
    this.layers.setAudioReactiveCallback(getter);
  }
  /**
   * Get the current frame
   * @deprecated Frame authority is now MotionEngine. This returns cached value.
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed();
    this.performance.beginFrame();
    this.emit("frameStart", { frame: this.state.currentFrame });
    this.renderer.render();
    this.emit("frameEnd", { frame: this.state.currentFrame });
    this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    this.assertNotDisposed();
    if (this.animationFrameId !== null) {
      return;
    }
    this.state.isRendering = true;
    const loop = () => {
      if (!this.state.isRendering || this.state.isDisposed) {
        return;
      }
      this.render();
      this.animationFrameId = requestAnimationFrame(loop);
    };
    this.animationFrameId = requestAnimationFrame(loop);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = false;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(width, height, compositionWidth, compositionHeight) {
    this.assertNotDisposed();
    if (width <= 0 || height <= 0) {
      engineLogger.warn("Invalid resize dimensions:", width, height);
      return;
    }
    this.state.viewport = { width, height };
    this.renderer.resize(width, height);
    const camWidth = compositionWidth ?? width;
    const camHeight = compositionHeight ?? height;
    this.camera.resize(camWidth, camHeight);
    this.emit("resize", { width, height, compositionWidth, compositionHeight });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(x, y, z) {
    this.camera.setPosition(x, y, z);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(x, y, z) {
    this.camera.setTarget(x, y, z);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(fov) {
    this.camera.setFOV(fov);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(dof) {
    this.renderer.setDOF({
      enabled: dof.enabled,
      focusDistance: dof.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: dof.aperture * 1e-4,
      maxBlur: dof.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(enabled) {
    this.renderer.setDOFEnabled(enabled);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(distance) {
    this.renderer.setFocusDistance(distance);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(aperture) {
    this.renderer.setAperture(aperture * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   * @param config - SSAO configuration options
   */
  setSSAO(config) {
    this.renderer.setSSAO(config);
  }
  /**
   * Enable or disable SSAO
   */
  setSSAOEnabled(enabled) {
    this.renderer.setSSAOEnabled(enabled);
  }
  /**
   * Set SSAO intensity
   * @param intensity - Occlusion intensity multiplier
   */
  setSSAOIntensity(intensity) {
    this.renderer.setSSAOIntensity(intensity);
  }
  /**
   * Set SSAO sampling radius
   * @param radius - Kernel radius for occlusion sampling
   */
  setSSAORadius(radius) {
    this.renderer.setSSAORadius(radius);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return this.renderer.getSSAO();
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, bright particles) glow
   * @param config - Bloom configuration options
   */
  setBloom(config) {
    this.renderer.setBloom(config);
  }
  /**
   * Enable or disable bloom
   */
  setBloomEnabled(enabled) {
    this.renderer.setBloomEnabled(enabled);
  }
  /**
   * Set bloom intensity
   * @param strength - Bloom strength multiplier
   */
  setBloomStrength(strength) {
    this.renderer.setBloomStrength(strength);
  }
  /**
   * Set bloom threshold
   * @param threshold - Brightness threshold for bloom (0-1)
   */
  setBloomThreshold(threshold) {
    this.renderer.setBloomThreshold(threshold);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return this.renderer.getBloom();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(transform) {
    this.viewportTransform = [...transform];
    const scale = transform[0];
    const tx = transform[4];
    const ty = transform[5];
    this.camera.setZoom(scale);
    this.camera.setPan(tx, ty);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(image) {
    this.assertNotDisposed();
    if (this.backgroundImage) {
      this.scene.removeFromComposition(this.backgroundImage);
      this.backgroundImage.geometry.dispose();
      this.backgroundImage.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    texture.colorSpace = SRGBColorSpace;
    const geometry = new PlaneGeometry(image.width, image.height);
    const material = new MeshBasicMaterial({
      map: texture,
      transparent: true,
      depthWrite: false
    });
    this.backgroundImage = new Mesh(geometry, material);
    this.backgroundImage.position.set(image.width / 2, image.height / 2, -1e3);
    this.backgroundImage.userData.isBackground = true;
    this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(image, options) {
    this.assertNotDisposed();
    this.depthMapSettings = {
      colormap: options.colormap ?? this.depthMapSettings.colormap,
      opacity: options.opacity ?? this.depthMapSettings.opacity,
      visible: options.visible ?? this.depthMapSettings.visible
    };
    if (this.depthMapMesh) {
      this.scene.removeFromComposition(this.depthMapMesh);
      this.depthMapMesh.geometry.dispose();
      this.depthMapMesh.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    const material = this.createColormapMaterial(texture, this.depthMapSettings);
    const geometry = new PlaneGeometry(image.width, image.height);
    this.depthMapMesh = new Mesh(geometry, material);
    this.depthMapMesh.position.set(image.width / 2, image.height / 2, -999);
    this.depthMapMesh.visible = this.depthMapSettings.visible;
    this.depthMapMesh.userData.isDepthOverlay = true;
    this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(texture, settings) {
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `;
    const colormapIndex = settings.colormap === "viridis" ? 0 : settings.colormap === "plasma" ? 1 : 2;
    return new ShaderMaterial({
      uniforms: {
        depthMap: { value: texture },
        opacity: { value: settings.opacity },
        colormap: { value: colormapIndex }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(visible) {
    this.depthMapSettings.visible = visible;
    if (this.depthMapMesh) {
      this.depthMapMesh.visible = visible;
    }
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(colormap) {
    this.depthMapSettings.colormap = colormap;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      const colormapIndex = colormap === "viridis" ? 0 : colormap === "plasma" ? 1 : 2;
      material.uniforms.colormap.value = colormapIndex;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(opacity) {
    this.depthMapSettings.opacity = opacity;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      material.uniforms.opacity.value = opacity;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    this.renderer.setRenderMode(mode);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(x, y) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, this.camera.getCamera());
    const intersects = this.scene.raycastComposition(raycaster);
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          return obj.userData.layerId;
        }
        if (obj.userData.isBackground || obj.userData.isDepthOverlay) {
          break;
        }
        obj = obj.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    this.assertNotDisposed();
    if (this.transformControls) {
      return;
    }
    const camera = this.camera.getCamera();
    const domElement = this.renderer.getDomElement();
    this.transformControls = new TransformControls(camera, domElement);
    this.transformControls.setMode(this.transformMode);
    this.transformControls.setSpace("world");
    this.transformControls.setSize(1);
    this.scene.addUIElement(this.transformControls);
    this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const object = this.transformControls.object;
      if (!object) return;
      const transform = {
        position: {
          x: object.position.x,
          y: object.position.y,
          z: object.position.z
        },
        rotationX: MathUtils.radToDeg(object.rotation.x),
        rotationY: MathUtils.radToDeg(object.rotation.y),
        rotationZ: MathUtils.radToDeg(object.rotation.z),
        scale: {
          x: object.scale.x * 100,
          // Convert back to percentage
          y: object.scale.y * 100,
          z: object.scale.z * 100
        }
      };
      transform.rotation = transform.rotationZ;
      if (this.onTransformChange) {
        this.onTransformChange(this.selectedLayerId, transform);
      }
    });
    this.transformControls.addEventListener("dragging-changed", (event) => {
      this.emit("transform-dragging", { dragging: event.value });
    });
    this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(callback) {
    this.onTransformChange = callback;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(layerId) {
    this.assertNotDisposed();
    if (!this.transformControls) {
      this.initializeTransformControls();
    }
    if (this.selectedLayerId && this.transformControls) {
      this.transformControls.detach();
    }
    this.selectedLayerId = layerId;
    if (!layerId || !this.transformControls) {
      return;
    }
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      this.transformControls.attach(layerObject);
    }
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(mode) {
    this.transformMode = mode;
    if (this.transformControls) {
      this.transformControls.setMode(mode);
    }
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(visible) {
    if (this.transformControls) {
      this.transformControls.visible = visible;
      this.transformControls.enabled = visible;
    }
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    return this.transformControls?.dragging ?? false;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const imageData = this.renderer.captureFrame();
    return {
      imageData,
      width: imageData.width,
      height: imageData.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(format = "png", quality = 0.95) {
    this.assertNotDisposed();
    const { imageData, width, height } = this.captureFrame();
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: `image/${format}`,
      quality
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const depthBuffer = this.renderer.captureDepth();
    const cameraState = this.camera.getState();
    return {
      depthBuffer,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: cameraState.near,
      far: cameraState.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(type, handler) {
    if (!this.eventHandlers.has(type)) {
      this.eventHandlers.set(type, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(type).add(handler);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(type, handler) {
    this.eventHandlers.get(type)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => {
      try {
        handler(event);
      } catch (error) {
        engineLogger.error(`Event handler error for ${type}:`, error);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const canvas = this.config.canvas;
    canvas.addEventListener("webglcontextlost", (event) => {
      event.preventDefault();
      this.stopRenderLoop();
      this.emit("contextLost", null);
      engineLogger.warn("WebGL context lost");
    });
    canvas.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null);
      engineLogger.info("WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed) {
      throw new Error("WeylEngine has been disposed");
    }
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    if (this.state.isDisposed) {
      return;
    }
    this.stopRenderLoop();
    this.layers.dispose();
    this.renderer.dispose();
    this.scene.dispose();
    this.resources.dispose();
    this.eventHandlers.clear();
    this.state.isDisposed = true;
    this.emit("dispose", null);
    if (this.config.debug) {
      engineLogger.debug("Disposed");
    }
  }
}

const _hoisted_1$c = { class: "spline-editor" };
const _hoisted_2$c = ["viewBox"];
const _hoisted_3$c = ["x1", "y1", "x2", "y2"];
const _hoisted_4$c = ["x1", "y1", "x2", "y2"];
const _hoisted_5$c = ["cx", "cy", "onMousedown"];
const _hoisted_6$c = ["cx", "cy", "onMousedown"];
const _hoisted_7$c = ["cx", "cy", "onMousedown"];
const _hoisted_8$b = ["cx", "cy"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const selectedPointId = ref(null);
    const previewPoint = ref(null);
    const dragTarget = ref(null);
    const visibleControlPoints = computed(() => {
      if (!props.layerId) return [];
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return [];
      const splineData = layer.data;
      return splineData.controlPoints || [];
    });
    function screenToCanvas(screenX, screenY) {
      const vt = props.viewportTransform;
      const x = (screenX - vt[4]) / vt[0];
      const y = (screenY - vt[5]) / vt[3];
      return { x, y };
    }
    function getMousePos(event) {
      const svg = event.currentTarget;
      const rect = svg.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;
      return screenToCanvas(screenX, screenY);
    }
    function handleMouseDown(event) {
      if (!props.isPenMode) return;
      const pos = getMousePos(event);
      if (props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && layer.type === "spline") {
          const newPoint = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: pos.x,
            y: pos.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          store.addSplineControlPoint(props.layerId, newPoint);
          selectedPointId.value = newPoint.id;
          dragTarget.value = {
            type: "handleOut",
            pointId: newPoint.id,
            startX: pos.x,
            startY: pos.y
          };
          emit("pointAdded", newPoint);
          emit("pathUpdated");
        }
      }
    }
    function handleMouseMove(event) {
      const pos = getMousePos(event);
      if (props.isPenMode) {
        previewPoint.value = pos;
      }
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (!layer || layer.type !== "spline") return;
        const splineData = layer.data;
        const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
        if (!point) return;
        if (dragTarget.value.type === "point") {
          const dx = pos.x - point.x;
          const dy = pos.y - point.y;
          const updates = { x: pos.x, y: pos.y };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + dx, y: point.handleIn.y + dy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + dx, y: point.handleOut.y + dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, pos.x, pos.y);
        } else if (dragTarget.value.type === "handleIn") {
          const updates = { handleIn: { x: pos.x, y: pos.y } };
          if (point.type === "smooth") {
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            updates.handleOut = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "in", pos.x, pos.y);
        } else if (dragTarget.value.type === "handleOut") {
          const updates = { handleOut: { x: pos.x, y: pos.y } };
          if (point.type === "smooth") {
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            updates.handleIn = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "out", pos.x, pos.y);
        }
        emit("pathUpdated");
      }
    }
    function handleMouseUp() {
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && layer.type === "spline") {
          const splineData = layer.data;
          const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
          if (point && point.handleOut) {
            const dx = point.handleOut.x - point.x;
            const dy = point.handleOut.y - point.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) {
              store.updateSplineControlPoint(props.layerId, point.id, {
                type: "smooth",
                handleIn: { x: point.x - dx, y: point.y - dy }
              });
            } else {
              store.updateSplineControlPoint(props.layerId, point.id, {
                handleOut: null
              });
            }
          }
        }
        dragTarget.value = null;
        emit("pathUpdated");
      }
    }
    function startDragPoint(pointId, event) {
      selectedPointId.value = pointId;
      if (!props.isPenMode) {
        const pos = getMousePos(event);
        dragTarget.value = {
          type: "point",
          pointId,
          startX: pos.x,
          startY: pos.y
        };
      }
    }
    function startDragHandle(pointId, handleType, event) {
      const pos = getMousePos(event);
      dragTarget.value = {
        type: handleType === "in" ? "handleIn" : "handleOut",
        pointId,
        startX: pos.x,
        startY: pos.y
      };
    }
    function handleKeyDown(event) {
      if (event.key === "Delete" || event.key === "Backspace") {
        if (selectedPointId.value && props.layerId) {
          const layer = store.layers.find((l) => l.id === props.layerId);
          if (layer && layer.type === "spline") {
            const pointId = selectedPointId.value;
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
          }
        }
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    __expose({
      selectedPointId,
      clearSelection: () => {
        selectedPointId.value = null;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        (openBlock(), createElementBlock("svg", {
          class: "control-overlay",
          viewBox: `0 0 ${__props.canvasWidth} ${__props.canvasHeight}`,
          onMousedown: handleMouseDown,
          onMousemove: handleMouseMove,
          onMouseup: handleMouseUp,
          onMouseleave: handleMouseUp
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handles-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 0,
                x1: point.x,
                y1: point.y,
                x2: point.handleIn.x,
                y2: point.handleIn.y,
                class: "handle-line"
              }, null, 8, _hoisted_3$c)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 1,
                x1: point.x,
                y1: point.y,
                x2: point.handleOut.x,
                y2: point.handleOut.y,
                class: "handle-line"
              }, null, 8, _hoisted_4$c)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handle-points-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.handleIn.x,
                cy: point.handleIn.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleIn" && dragTarget.value.pointId === point.id }]),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "in", $event), ["stop"])
              }, null, 42, _hoisted_5$c)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 1,
                cx: point.handleOut.x,
                cy: point.handleOut.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleOut" && dragTarget.value.pointId === point.id }]),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "out", $event), ["stop"])
              }, null, 42, _hoisted_6$c)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock("circle", {
              key: `point-${point.id}`,
              cx: point.x,
              cy: point.y,
              r: "6",
              class: normalizeClass(["control-point", {
                selected: selectedPointId.value === point.id,
                corner: point.type === "corner",
                smooth: point.type === "smooth"
              }]),
              onMousedown: withModifiers(($event) => startDragPoint(point.id, $event), ["stop"])
            }, null, 42, _hoisted_7$c);
          }), 128)),
          previewPoint.value && __props.isPenMode ? (openBlock(), createElementBlock("circle", {
            key: 0,
            cx: previewPoint.value.x,
            cy: previewPoint.value.y,
            r: "4",
            class: "preview-point"
          }, null, 8, _hoisted_8$b)) : createCommentVNode("", true)
        ], 40, _hoisted_2$c))
      ]);
    };
  }
});

const SplineEditor = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-55bdee8d"]]);

const _hoisted_1$b = {
  key: 1,
  class: "overlay-controls"
};
const _hoisted_2$b = { class: "render-mode-controls" };
const _hoisted_3$b = {
  key: 2,
  class: "transform-mode-controls"
};
const _hoisted_4$b = {
  key: 3,
  class: "performance-overlay"
};
const _hoisted_5$b = {
  key: 4,
  class: "loading-overlay"
};
const _hoisted_6$b = ["src"];
const _hoisted_7$b = {
  key: 7,
  class: "segment-loading"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "ThreeCanvas",
  setup(__props, { expose: __expose }) {
    const store = useCompositorStore();
    const containerRef = ref(null);
    const canvasRef = ref(null);
    const splineEditorRef = ref(null);
    const engine = shallowRef(null);
    const loading = ref(false);
    const zoom = ref(1);
    const canvasWidth = ref(800);
    const canvasHeight = ref(600);
    const showDepthOverlay = ref(false);
    const depthColormap = ref("viridis");
    const depthOpacity = ref(50);
    const renderMode = ref("color");
    const showPerformance = ref(false);
    const performanceStats = ref({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    const viewportTransform = ref([1, 0, 0, 1, 0, 0]);
    const transformMode = ref("translate");
    const isDrawingSegmentBox = ref(false);
    const segmentBoxEnd = ref(null);
    const maskOverlayStyle = computed(() => {
      const mask = store.segmentPendingMask;
      if (!mask) return {};
      const vpt = viewportTransform.value;
      const screenX = mask.bounds.x * vpt[0] + vpt[4];
      const screenY = mask.bounds.y * vpt[3] + vpt[5];
      const screenWidth = mask.bounds.width * vpt[0];
      const screenHeight = mask.bounds.height * vpt[3];
      return {
        left: `${screenX}px`,
        top: `${screenY}px`,
        width: `${screenWidth}px`,
        height: `${screenHeight}px`
      };
    });
    const segmentBoxStyle = computed(() => {
      const start = store.segmentBoxStart;
      const end = segmentBoxEnd.value;
      if (!start || !end) return {};
      const vpt = viewportTransform.value;
      const x1 = start.x * vpt[0] + vpt[4];
      const y1 = start.y * vpt[3] + vpt[5];
      const x2 = end.x * vpt[0] + vpt[4];
      const y2 = end.y * vpt[3] + vpt[5];
      return {
        left: `${Math.min(x1, x2)}px`,
        top: `${Math.min(y1, y2)}px`,
        width: `${Math.abs(x2 - x1)}px`,
        height: `${Math.abs(y2 - y1)}px`
      };
    });
    const hasDepthMap = computed(() => store.depthMap !== null);
    const isPenMode = computed(() => store.currentTool === "pen");
    const activeSplineLayerId = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "spline") {
        return selectedLayer.id;
      }
      if (isPenMode.value) {
        const splines = store.layers.filter((l) => l.type === "spline");
        return splines.length > 0 ? splines[splines.length - 1].id : null;
      }
      return null;
    });
    const viewportTransformArray = computed(() => viewportTransform.value);
    onMounted(async () => {
      if (!canvasRef.value || !containerRef.value) return;
      const container = containerRef.value;
      const rect = container.getBoundingClientRect();
      canvasWidth.value = rect.width;
      canvasHeight.value = rect.height;
      const config = {
        canvas: canvasRef.value,
        width: rect.width,
        height: rect.height,
        compositionWidth: store.width || 1920,
        compositionHeight: store.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      };
      try {
        loading.value = true;
        engine.value = new WeylEngine(config);
        engine.value.setAssetGetter((assetId) => store.assets[assetId]);
        engine.value.setVideoMetadataCallback((layerId, metadata) => {
          store.onVideoMetadataLoaded(layerId, metadata);
        });
        engine.value.setCameraCallbacks(
          (cameraId) => store.getCamera(cameraId),
          (cameraId, updates) => store.updateCamera(cameraId, updates),
          (cameraId, frame) => store.getCameraAtFrame(cameraId, frame)
        );
        engine.value.setPrecompRenderContext({
          renderComposition: (compositionId, frame) => {
            const comp = store.getComposition(compositionId);
            if (!comp) return null;
            console.log("[ThreeCanvas] Precomp render requested:", compositionId, "frame:", frame);
            return null;
          },
          getComposition: (compositionId) => store.getComposition(compositionId)
        });
        engine.value.setAudioReactiveCallback(
          (layerId, frame) => store.getAudioReactiveValuesForLayer(layerId, frame)
        );
        engine.value.initializeTransformControls();
        engine.value.setTransformChangeCallback((layerId, transform) => {
          handleTransformChange(layerId, transform);
        });
        engine.value.initializeParticleSystems();
        engine.value.setCompositionFPS(store.fps || 60);
        engine.value.start();
        await nextTick();
        syncLayersToEngine();
        store.initializePropertyDriverSystem();
        const initialFrameState = store.getFrameState(store.currentFrame);
        engine.value.applyFrameState(initialFrameState);
        setupInputHandlers();
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(container);
        centerOnComposition();
      } catch (err) {
        console.error("[ThreeCanvas] Failed to initialize engine:", err);
      } finally {
        loading.value = false;
      }
      setupWatchers();
    });
    onUnmounted(() => {
      if (engine.value) {
        engine.value.stop();
        engine.value.dispose();
        engine.value = null;
      }
    });
    function setupWatchers() {
      watch(
        () => store.layers,
        () => {
          syncLayersToEngine();
          if (engine.value) {
            const frameState = store.getFrameState(store.currentFrame);
            engine.value.applyFrameState(frameState);
          }
        },
        { deep: true }
      );
      watch(
        () => store.currentFrame,
        (frame) => {
          if (engine.value) {
            applyPropertyDrivers();
            const frameState = store.getFrameState(frame);
            engine.value.applyFrameState(frameState);
          }
        }
      );
      watch(
        () => [store.width, store.height],
        ([width, height]) => {
          if (engine.value) {
            engine.value.resize(canvasWidth.value, canvasHeight.value, width, height);
            centerOnComposition();
          }
        }
      );
      watch(
        () => store.sourceImage,
        async (imageData) => {
          if (engine.value && imageData) {
            await loadSourceImage(imageData);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.depthMap,
        async (depthData) => {
          if (engine.value && depthData) {
            await loadDepthMap(depthData);
          }
        },
        { immediate: true }
      );
      watch(
        () => engine.value?.getPerformanceStats(),
        (stats) => {
          if (stats) {
            performanceStats.value = stats;
          }
        }
      );
      watch(
        () => store.activeCameraId,
        (activeCameraId) => {
          if (!engine.value) return;
          if (!activeCameraId) {
            engine.value.setActiveCameraLayer(null);
            return;
          }
          const cameraLayer = store.layers.find(
            (l) => l.type === "camera" && l.data?.cameraId === activeCameraId
          );
          if (cameraLayer) {
            engine.value.setActiveCameraLayer(cameraLayer.id);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.selectedLayerIds,
        (selectedIds) => {
          if (!engine.value) return;
          const selectedId = selectedIds.length > 0 ? selectedIds[0] : null;
          engine.value.selectLayer(selectedId);
        },
        { deep: true }
      );
    }
    function syncLayersToEngine() {
      if (!engine.value) return;
      const engineLayerIds = new Set(engine.value.getLayerIds());
      const storeLayerIds = new Set(store.layers.map((l) => l.id));
      for (const id of engineLayerIds) {
        if (!storeLayerIds.has(id)) {
          engine.value.removeLayer(id);
        }
      }
      for (const layer of store.layers) {
        if (engineLayerIds.has(layer.id)) {
          engine.value.updateLayer(layer.id, layer);
        } else {
          engine.value.addLayer(layer);
        }
      }
    }
    function applyPropertyDrivers() {
      if (!engine.value) return;
      engine.value.clearAllDrivenValues();
      for (const layer of store.layers) {
        const drivenValues = store.getDrivenValuesForLayer(layer.id);
        if (drivenValues.size > 0) {
          engine.value.setLayerDrivenValues(layer.id, drivenValues);
        }
      }
    }
    async function loadSourceImage(imageData) {
      if (!engine.value) return;
      try {
        loading.value = true;
        const img = await loadImage(imageData);
        engine.value.setBackgroundImage(img);
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load source image:", err);
      } finally {
        loading.value = false;
      }
    }
    async function loadDepthMap(depthData) {
      if (!engine.value) return;
      try {
        const img = await loadImage(depthData);
        engine.value.setDepthMap(img, {
          colormap: depthColormap.value,
          opacity: depthOpacity.value / 100,
          visible: showDepthOverlay.value
        });
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load depth map:", err);
      }
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
      });
    }
    function setupInputHandlers() {
      const container = containerRef.value;
      const canvas = canvasRef.value;
      if (!container || !canvas) return;
      let isPanning = false;
      let isZooming = false;
      let lastPosX = 0;
      let lastPosY = 0;
      let zoomStartY = 0;
      let zoomStartLevel = 1;
      container.addEventListener("mousedown", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("auxclick", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        let newZoom = zoom.value * (delta > 0 ? 0.9 : 1.1);
        newZoom = Math.min(Math.max(newZoom, 0.1), 10);
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const scaleFactor = newZoom / zoom.value;
        viewportTransform.value[4] = mouseX - scaleFactor * (mouseX - viewportTransform.value[4]);
        viewportTransform.value[5] = mouseY - scaleFactor * (mouseY - viewportTransform.value[5]);
        viewportTransform.value[0] = newZoom;
        viewportTransform.value[3] = newZoom;
        zoom.value = newZoom;
        if (engine.value) {
          engine.value.setViewportTransform(viewportTransform.value);
        }
      }, { passive: false });
      canvas.addEventListener("mousedown", (e) => {
        const currentTool = store.currentTool;
        if (e.button === 1 || currentTool === "hand" || e.button === 0 && e.altKey) {
          isPanning = true;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          canvas.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }
        if (currentTool === "zoom") {
          if (e.shiftKey) {
            const newZoom = Math.max(zoom.value * 0.7, 0.1);
            zoom.value = newZoom;
            viewportTransform.value[0] = newZoom;
            viewportTransform.value[3] = newZoom;
            if (engine.value) {
              engine.value.setViewportTransform(viewportTransform.value);
            }
          } else {
            isZooming = true;
            zoomStartY = e.clientY;
            zoomStartLevel = zoom.value;
          }
          return;
        }
        if (currentTool === "text") {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          const newLayer = store.createLayer("text");
          if (newLayer.transform?.position) {
            newLayer.transform.position.value = { x: scenePos.x, y: scenePos.y, z: 0 };
          }
          store.updateLayer(newLayer.id, {
            transform: {
              ...newLayer.transform,
              position: {
                ...newLayer.transform.position,
                value: { x: scenePos.x, y: scenePos.y, z: 0 }
              }
            }
          });
          store.selectLayer(newLayer.id);
          store.setTool("select");
          return;
        }
        if (currentTool === "segment" && e.button === 0) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          if (store.segmentMode === "point") {
            handleSegmentPoint(scenePos.x, scenePos.y);
          } else {
            store.setSegmentBoxStart({ x: scenePos.x, y: scenePos.y });
            segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
            isDrawingSegmentBox.value = true;
          }
          return;
        }
        if (currentTool === "select" && e.button === 0) {
          if (engine.value?.isTransformDragging()) {
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          if (engine.value) {
            const hitLayer = engine.value.raycastLayers(x, y);
            if (hitLayer) {
              store.selectLayer(hitLayer);
              engine.value.selectLayer(hitLayer);
            } else {
              store.clearSelection();
              engine.value.selectLayer(null);
            }
          }
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isPanning) {
          const dx = e.clientX - lastPosX;
          const dy = e.clientY - lastPosY;
          viewportTransform.value[4] += dx;
          viewportTransform.value[5] += dy;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          if (engine.value) {
            engine.value.setViewportTransform(viewportTransform.value);
          }
          return;
        }
        if (isZooming) {
          const dy = zoomStartY - e.clientY;
          const zoomFactor = 1 + dy * 0.01;
          const newZoom = Math.max(0.1, Math.min(10, zoomStartLevel * zoomFactor));
          zoom.value = newZoom;
          viewportTransform.value[0] = newZoom;
          viewportTransform.value[3] = newZoom;
          if (engine.value) {
            engine.value.setViewportTransform(viewportTransform.value);
          }
          return;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
          return;
        }
        const currentTool = store.currentTool;
        if (currentTool === "hand") canvas.style.cursor = "grab";
        else if (currentTool === "zoom") canvas.style.cursor = "zoom-in";
        else if (currentTool === "text") canvas.style.cursor = "text";
        else if (currentTool === "pen") canvas.style.cursor = "crosshair";
        else if (currentTool === "segment") canvas.style.cursor = "crosshair";
        else canvas.style.cursor = "default";
      });
      canvas.addEventListener("mouseup", (e) => {
        if (isPanning) {
          isPanning = false;
          canvas.style.cursor = store.currentTool === "hand" ? "grab" : "default";
        }
        if (isZooming) {
          isZooming = false;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart && segmentBoxEnd.value) {
          isDrawingSegmentBox.value = false;
          handleSegmentBox(
            store.segmentBoxStart.x,
            store.segmentBoxStart.y,
            segmentBoxEnd.value.x,
            segmentBoxEnd.value.y
          );
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
        isZooming = false;
        if (isDrawingSegmentBox.value) {
          isDrawingSegmentBox.value = false;
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
    }
    function screenToScene(screenX, screenY) {
      const vpt = viewportTransform.value;
      return {
        x: (screenX - vpt[4]) / vpt[0],
        y: (screenY - vpt[5]) / vpt[3]
      };
    }
    async function handleSegmentPoint(x, y) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      store.setSegmentLoading(true);
      try {
        const result = await segmentByPoint(store.sourceImage, { x, y });
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    async function handleSegmentBox(x1, y1, x2, y2) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      const box = [
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.max(x1, x2),
        Math.max(y1, y2)
      ];
      store.setSegmentLoading(true);
      try {
        const result = await segmentByBox(store.sourceImage, box);
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Box segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Box segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Box segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    function handleTransformChange(layerId, transform) {
      const layer = store.layers.find((l) => l.id === layerId);
      if (!layer) return;
      const updates = {};
      if (transform.position && layer.transform) {
        updates.transform = {
          ...layer.transform,
          position: {
            ...layer.transform.position,
            value: {
              x: transform.position.x,
              y: transform.position.y,
              z: transform.position.z ?? layer.transform.position?.value?.z ?? 0
            }
          }
        };
      }
      if (layer.threeD) {
        if (transform.rotationX !== void 0 || transform.rotationY !== void 0 || transform.rotationZ !== void 0) {
          if (!updates.transform && layer.transform) {
            updates.transform = { ...layer.transform };
          }
          if (updates.transform) {
            if (transform.rotationX !== void 0) {
              updates.transform.rotationX = { ...layer.transform.rotationX, value: transform.rotationX };
            }
            if (transform.rotationY !== void 0) {
              updates.transform.rotationY = { ...layer.transform.rotationY, value: transform.rotationY };
            }
            if (transform.rotationZ !== void 0) {
              updates.transform.rotationZ = { ...layer.transform.rotationZ, value: transform.rotationZ };
            }
          }
        }
      } else {
        if (transform.rotation !== void 0 && layer.transform) {
          if (!updates.transform) {
            updates.transform = { ...layer.transform };
          }
          updates.transform.rotation = { ...layer.transform.rotation, value: transform.rotation };
        }
      }
      if (transform.scale && layer.transform) {
        if (!updates.transform) {
          updates.transform = { ...layer.transform };
        }
        updates.transform.scale = {
          ...layer.transform.scale,
          value: {
            x: transform.scale.x,
            y: transform.scale.y,
            z: transform.scale.z ?? layer.transform.scale?.value?.z ?? 100
          }
        };
      }
      if (Object.keys(updates).length > 0) {
        store.updateLayer(layerId, updates);
      }
    }
    function setTransformModeTo(mode) {
      transformMode.value = mode;
      if (engine.value) {
        engine.value.setTransformMode(mode);
      }
    }
    function handleResize(entries) {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          canvasWidth.value = width;
          canvasHeight.value = height;
          if (engine.value) {
            engine.value.resize(width, height);
          }
        }
      }
    }
    function centerOnComposition() {
      const container = containerRef.value;
      if (!container || !engine.value) return;
      const compWidth = store.width || 1920;
      const compHeight = store.height || 1080;
      const containerRect = container.getBoundingClientRect();
      const padding = 60;
      const scaleX = (containerRect.width - padding * 2) / compWidth;
      const scaleY = (containerRect.height - padding * 2) / compHeight;
      const scale = Math.min(scaleX, scaleY, 1);
      viewportTransform.value = [
        scale,
        0,
        0,
        scale,
        (containerRect.width - compWidth * scale) / 2,
        (containerRect.height - compHeight * scale) / 2
      ];
      zoom.value = scale;
      engine.value.setViewportTransform(viewportTransform.value);
    }
    function setRenderMode(mode) {
      renderMode.value = mode;
      if (engine.value) {
        engine.value.setRenderMode(mode);
      }
    }
    function onPointAdded(_point) {
      if (!activeSplineLayerId.value) {
        const newLayer = store.createLayer("spline");
        store.selectLayer(newLayer.id);
      }
    }
    function onPathUpdated() {
      syncLayersToEngine();
    }
    function zoomIn() {
      const newZoom = Math.min(zoom.value * 1.2, 10);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function zoomOut() {
      const newZoom = Math.max(zoom.value * 0.8, 0.1);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function fitToView() {
      centerOnComposition();
    }
    async function captureFrame() {
      if (!engine.value) return null;
      const result = engine.value.captureFrame();
      if (!result?.imageData) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      ctx.putImageData(result.imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    async function captureDepth() {
      if (!engine.value) return null;
      const result = engine.value.captureDepth();
      if (!result?.depthBuffer) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const imageData = ctx.createImageData(result.width, result.height);
      for (let i = 0; i < result.depthBuffer.length; i++) {
        const value = Math.floor(result.depthBuffer[i] * 255);
        const idx = i * 4;
        imageData.data[idx] = value;
        imageData.data[idx + 1] = value;
        imageData.data[idx + 2] = value;
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    watch(showDepthOverlay, (visible) => {
      if (engine.value) {
        engine.value.setDepthOverlayVisible(visible);
      }
    });
    watch(depthColormap, (colormap) => {
      if (engine.value) {
        engine.value.setDepthColormap(colormap);
      }
    });
    watch(depthOpacity, (opacity) => {
      if (engine.value) {
        engine.value.setDepthOpacity(opacity / 100);
      }
    });
    __expose({
      engine,
      fitToView,
      zoomIn,
      zoomOut,
      zoom,
      captureFrame,
      captureDepth,
      showPerformance,
      performanceStats,
      renderMode,
      setRenderMode,
      transformMode,
      setTransformModeTo
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "three-canvas",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("canvas", {
          ref_key: "canvasRef",
          ref: canvasRef
        }, null, 512),
        activeSplineLayerId.value || isPenMode.value ? (openBlock(), createBlock(SplineEditor, {
          key: 0,
          layerId: activeSplineLayerId.value,
          canvasWidth: canvasWidth.value,
          canvasHeight: canvasHeight.value,
          zoom: zoom.value,
          viewportTransform: viewportTransformArray.value,
          isPenMode: isPenMode.value,
          onPointAdded,
          onPathUpdated,
          ref_key: "splineEditorRef",
          ref: splineEditorRef
        }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : createCommentVNode("", true),
        hasDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
          createBaseVNode("label", null, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showDepthOverlay.value = $event)
            }, null, 512), [
              [vModelCheckbox, showDepthOverlay.value]
            ]),
            _cache[9] || (_cache[9] = createTextVNode(" Depth Overlay ", -1))
          ]),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => depthColormap.value = $event),
            class: "colormap-select"
          }, [..._cache[10] || (_cache[10] = [
            createBaseVNode("option", { value: "viridis" }, "Viridis", -1),
            createBaseVNode("option", { value: "plasma" }, "Plasma", -1),
            createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1)
          ])], 512), [
            [vModelSelect, depthColormap.value]
          ]),
          withDirectives(createBaseVNode("input", {
            type: "range",
            min: "0",
            max: "100",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => depthOpacity.value = $event),
            class: "opacity-slider"
          }, null, 512), [
            [
              vModelText,
              depthOpacity.value,
              void 0,
              { number: true }
            ]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$b, [
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "color" }),
            onClick: _cache[3] || (_cache[3] = ($event) => setRenderMode("color")),
            title: "Color View"
          }, [..._cache[11] || (_cache[11] = [
            createBaseVNode("i", { class: "pi pi-image" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "depth" }),
            onClick: _cache[4] || (_cache[4] = ($event) => setRenderMode("depth")),
            title: "Depth View"
          }, [..._cache[12] || (_cache[12] = [
            createBaseVNode("i", { class: "pi pi-box" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "normal" }),
            onClick: _cache[5] || (_cache[5] = ($event) => setRenderMode("normal")),
            title: "Normal View"
          }, [..._cache[13] || (_cache[13] = [
            createBaseVNode("i", { class: "pi pi-compass" }, null, -1)
          ])], 2)
        ]),
        unref(store).selectedLayerIds.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "translate" }),
            onClick: _cache[6] || (_cache[6] = ($event) => setTransformModeTo("translate")),
            title: "Move (V)"
          }, [..._cache[14] || (_cache[14] = [
            createBaseVNode("i", { class: "pi pi-arrows-alt" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "rotate" }),
            onClick: _cache[7] || (_cache[7] = ($event) => setTransformModeTo("rotate")),
            title: "Rotate (R)"
          }, [..._cache[15] || (_cache[15] = [
            createBaseVNode("i", { class: "pi pi-sync" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "scale" }),
            onClick: _cache[8] || (_cache[8] = ($event) => setTransformModeTo("scale")),
            title: "Scale (S)"
          }, [..._cache[16] || (_cache[16] = [
            createBaseVNode("i", { class: "pi pi-expand" }, null, -1)
          ])], 2)
        ])) : createCommentVNode("", true),
        showPerformance.value ? (openBlock(), createElementBlock("div", _hoisted_4$b, [
          createBaseVNode("span", null, "FPS: " + toDisplayString(performanceStats.value.fps), 1),
          createBaseVNode("span", null, "Draw: " + toDisplayString(performanceStats.value.drawCalls), 1),
          createBaseVNode("span", null, "Tris: " + toDisplayString(performanceStats.value.triangles), 1)
        ])) : createCommentVNode("", true),
        loading.value ? (openBlock(), createElementBlock("div", _hoisted_5$b, [..._cache[17] || (_cache[17] = [
          createBaseVNode("div", { class: "loading-spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(store).segmentPendingMask ? (openBlock(), createElementBlock("div", {
          key: 5,
          class: "segment-mask-overlay",
          style: normalizeStyle(maskOverlayStyle.value)
        }, [
          createBaseVNode("img", {
            src: "data:image/png;base64," + unref(store).segmentPendingMask.mask,
            class: "mask-preview",
            alt: "Segmentation mask"
          }, null, 8, _hoisted_6$b)
        ], 4)) : createCommentVNode("", true),
        isDrawingSegmentBox.value && unref(store).segmentBoxStart && segmentBoxEnd.value ? (openBlock(), createElementBlock("div", {
          key: 6,
          class: "segment-box-preview",
          style: normalizeStyle(segmentBoxStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        unref(store).segmentIsLoading ? (openBlock(), createElementBlock("div", _hoisted_7$b, [..._cache[18] || (_cache[18] = [
          createBaseVNode("div", { class: "segment-spinner" }, null, -1),
          createBaseVNode("span", null, "Segmenting...", -1)
        ])])) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const ThreeCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-8dfcdece"]]);

const _hoisted_1$a = { class: "prop-wrapper" };
const _hoisted_2$a = { class: "prop-content" };
const _hoisted_3$a = { class: "prop-name" };
const _hoisted_4$a = { class: "prop-inputs" };
const _hoisted_5$a = {
  key: 0,
  class: "vec-item"
};
const _hoisted_6$a = {
  key: 1,
  class: "color-input-wrapper"
};
const _hoisted_7$a = ["value"];
const _hoisted_8$a = { class: "color-hex" };
const _hoisted_9$a = { class: "vec-item" };
const _hoisted_10$a = { class: "vec-item" };
const _hoisted_11$9 = ["onMousedown", "onDblclick", "onContextmenu"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const store = useCompositorStore();
    const selectedKeyframeIds = ref(/* @__PURE__ */ new Set());
    const trackRef = ref(null);
    const isBoxSelecting = ref(false);
    const boxStartX = ref(0);
    const boxCurrentX = ref(0);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      keyframe: null
    });
    const contextMenuStyle = computed(() => ({
      left: `${contextMenu.value.x}px`,
      top: `${contextMenu.value.y}px`
    }));
    const selectionBoxStyle = computed(() => {
      const left = Math.min(boxStartX.value, boxCurrentX.value);
      const width = Math.abs(boxCurrentX.value - boxStartX.value);
      return {
        left: `${left}px`,
        width: `${width}px`
      };
    });
    const hasKeyframeAtCurrent = computed(() => props.property.keyframes?.some((k) => k.frame === store.currentFrame));
    const isSelected = computed(() => store.selectedPropertyPath === props.propertyPath);
    function toggleAnim() {
      store.setPropertyAnimated(props.layerId, props.propertyPath, !props.property.animated);
    }
    function addKeyframeAtCurrent() {
      store.addKeyframe(props.layerId, props.propertyPath, props.property.value);
    }
    function updateValDirect(v) {
      store.setPropertyValue(props.layerId, props.propertyPath, v);
    }
    function updateValByIndex(axis, v) {
      const newVal = { ...props.property.value, [axis]: v };
      store.setPropertyValue(props.layerId, props.propertyPath, newVal);
    }
    function selectProp() {
      store.selectProperty(props.propertyPath);
    }
    function handleTrackMouseDown(e) {
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      isBoxSelecting.value = true;
      boxStartX.value = x;
      boxCurrentX.value = x;
      if (!e.shiftKey) {
        selectedKeyframeIds.value.clear();
      }
      const onMove = (ev) => {
        const currentX = ev.clientX - rect.left;
        boxCurrentX.value = Math.max(0, currentX);
        const minFrame = Math.min(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        const maxFrame = Math.max(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        if (!ev.shiftKey) {
          selectedKeyframeIds.value.clear();
        }
        for (const kf of props.property.keyframes || []) {
          if (kf.frame >= minFrame && kf.frame <= maxFrame) {
            selectedKeyframeIds.value.add(kf.id);
          }
        }
      };
      const onUp = (ev) => {
        isBoxSelecting.value = false;
        const dragDistance = Math.abs(boxCurrentX.value - boxStartX.value);
        if (dragDistance < 5) {
          const frame = Math.round(boxStartX.value / props.pixelsPerFrame);
          store.setFrame(Math.max(0, Math.min(store.frameCount - 1, frame)));
        }
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function startKeyframeDrag(e, kf) {
      if (e.shiftKey) {
        if (selectedKeyframeIds.value.has(kf.id)) {
          selectedKeyframeIds.value.delete(kf.id);
        } else {
          selectedKeyframeIds.value.add(kf.id);
        }
      } else {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const startX = e.clientX;
      const startFrame = kf.frame;
      const onMove = (ev) => {
        const dx = ev.clientX - startX;
        const frameDelta = Math.round(dx / props.pixelsPerFrame);
        let newFrame = Math.max(0, Math.min(store.frameCount - 1, startFrame + frameDelta));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(newFrame, store.snapConfig, props.pixelsPerFrame, {
            layers: store.layers,
            selectedLayerId: props.layerId,
            currentFrame: store.currentFrame,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            newFrame = snap.frame;
          }
        }
        if (newFrame !== kf.frame) {
          store.moveKeyframe(props.layerId, props.propertyPath, kf.id, newFrame);
        }
      };
      const onUp = () => {
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function deleteKeyframe(kfId) {
      store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      selectedKeyframeIds.value.delete(kfId);
    }
    function showContextMenu(e, kf) {
      if (!selectedKeyframeIds.value.has(kf.id)) {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const trackRect = trackRef.value?.getBoundingClientRect();
      if (trackRect) {
        contextMenu.value = {
          visible: true,
          x: e.clientX - trackRect.left,
          y: e.clientY - trackRect.top,
          keyframe: kf
        };
      }
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.keyframe = null;
    }
    function setInterpolation(type) {
      for (const kfId of selectedKeyframeIds.value) {
        store.setKeyframeInterpolation(props.layerId, props.propertyPath, kfId, type);
      }
      hideContextMenu();
    }
    function goToKeyframe() {
      if (contextMenu.value.keyframe) {
        store.setFrame(contextMenu.value.keyframe.frame);
      }
      hideContextMenu();
    }
    function deleteSelectedKeyframes() {
      for (const kfId of selectedKeyframeIds.value) {
        store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      }
      selectedKeyframeIds.value.clear();
      hideContextMenu();
    }
    function handleGlobalClick(e) {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleGlobalClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleGlobalClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["prop-sidebar", { selected: isSelected.value }]),
          style: normalizeStyle(__props.gridStyle),
          onClick: selectProp
        }, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "indent-spacer" }, null, -1)),
          createBaseVNode("div", {
            class: "icon-box",
            onClick: withModifiers(addKeyframeAtCurrent, ["stop"])
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["kf-btn", { active: hasKeyframeAtCurrent.value }])
            }, "", 2)
          ]),
          createBaseVNode("div", {
            class: "icon-box",
            onClick: withModifiers(toggleAnim, ["stop"])
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["stopwatch", { active: __props.property.animated }])
            }, "", 2)
          ]),
          createBaseVNode("div", _hoisted_2$a, [
            createBaseVNode("span", _hoisted_3$a, toDisplayString(__props.name), 1),
            createBaseVNode("div", _hoisted_4$a, [
              __props.name === "Z Position" ? (openBlock(), createElementBlock("div", _hoisted_5$a, [
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "label z-label" }, "Z", -1)),
                createVNode(ScrubableNumber, {
                  modelValue: __props.property.value?.z ?? 0,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => updateValByIndex("z", v))
                }, null, 8, ["modelValue"])
              ])) : __props.property.type === "color" ? (openBlock(), createElementBlock("div", _hoisted_6$a, [
                createBaseVNode("input", {
                  type: "color",
                  value: __props.property.value,
                  onInput: _cache[1] || (_cache[1] = (e) => updateValDirect(e.target.value))
                }, null, 40, _hoisted_7$a),
                createBaseVNode("span", _hoisted_8$a, toDisplayString(__props.property.value), 1)
              ])) : typeof __props.property.value === "object" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("div", _hoisted_9$a, [
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "label x-label" }, "X", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateValByIndex("x", v))
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_10$a, [
                  _cache[9] || (_cache[9] = createBaseVNode("span", { class: "label y-label" }, "Y", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateValByIndex("y", v))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof __props.property.value === "number" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 3,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 1
              }, null, 8, ["modelValue"])) : createCommentVNode("", true)
            ])
          ])
        ], 6)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "prop-track",
          onMousedown: handleTrackMouseDown,
          ref_key: "trackRef",
          ref: trackRef
        }, [
          isBoxSelecting.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "selection-box",
            style: normalizeStyle(selectionBoxStyle.value)
          }, null, 4)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.property.keyframes, (kf) => {
            return openBlock(), createElementBlock("div", {
              key: kf.id,
              class: normalizeClass(["keyframe", { selected: selectedKeyframeIds.value.has(kf.id), [kf.interpolation || "linear"]: true }]),
              style: normalizeStyle({ left: `${kf.frame * __props.pixelsPerFrame}px` }),
              onMousedown: withModifiers(($event) => startKeyframeDrag($event, kf), ["stop"]),
              onDblclick: withModifiers(($event) => deleteKeyframe(kf.id), ["stop"]),
              onContextmenu: withModifiers(($event) => showContextMenu($event, kf), ["prevent", "stop"])
            }, null, 46, _hoisted_11$9);
          }), 128)),
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: normalizeStyle(contextMenuStyle.value)
          }, [
            _cache[16] || (_cache[16] = createBaseVNode("div", { class: "menu-header" }, "Interpolation", -1)),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "linear" }]),
              onClick: _cache[4] || (_cache[4] = ($event) => setInterpolation("linear"))
            }, [..._cache[11] || (_cache[11] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Linear ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "bezier" }]),
              onClick: _cache[5] || (_cache[5] = ($event) => setInterpolation("bezier"))
            }, [..._cache[12] || (_cache[12] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Bezier ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "hold" }]),
              onClick: _cache[6] || (_cache[6] = ($event) => setInterpolation("hold"))
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Hold ", -1)
            ])], 2),
            _cache[17] || (_cache[17] = createBaseVNode("div", { class: "menu-divider" }, null, -1)),
            createBaseVNode("div", {
              class: "menu-item",
              onClick: goToKeyframe
            }, [..._cache[14] || (_cache[14] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Go to Frame ", -1)
            ])]),
            createBaseVNode("div", {
              class: "menu-item delete",
              onClick: deleteSelectedKeyframes
            }, [..._cache[15] || (_cache[15] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Delete ", -1)
            ])])
          ], 4)) : createCommentVNode("", true)
        ], 544))
      ]);
    };
  }
});

const PropertyTrack = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-32aca4cb"]]);

const _hoisted_1$9 = {
  key: 0,
  class: "track-wrapper"
};
const _hoisted_2$9 = { class: "arrow" };
const _hoisted_3$9 = { class: "layer-id" };
const _hoisted_4$9 = { class: "type-icon" };
const _hoisted_5$9 = {
  key: 0,
  class: "name-text"
};
const _hoisted_6$9 = { class: "col-mode" };
const _hoisted_7$9 = ["value"];
const _hoisted_8$9 = { class: "col-parent" };
const _hoisted_9$9 = ["value"];
const _hoisted_10$9 = ["value"];
const _hoisted_11$8 = {
  key: 0,
  class: "children-container"
};
const _hoisted_12$8 = ["onMousedown"];
const _hoisted_13$7 = { class: "arrow-col" };
const _hoisted_14$7 = { class: "arrow" };
const _hoisted_15$7 = { class: "group-label" };
const _hoisted_16$7 = { key: 0 };
const _hoisted_17$7 = {
  key: 0,
  class: "children-container"
};
const _hoisted_18$7 = { key: 0 };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const localExpanded = ref(false);
    const isExpanded = computed(() => props.isExpandedExternal ?? localExpanded.value);
    const isSelected = computed(() => store.selectedLayerIds.includes(props.layer.id));
    const expandedGroups = ref(["Transform", "Text", "More Options"]);
    const isRenaming = ref(false);
    const renameVal = ref("");
    const renameInput = ref(null);
    const contextMenuVisible = ref(false);
    const contextMenuX = ref(0);
    const contextMenuY = ref(0);
    const availableParents = computed(() => props.allLayers?.filter((l) => l.id !== props.layer.id) || []);
    const groupedProperties = computed(() => {
      const groups = {};
      const t = props.layer.transform;
      const transformProps = [];
      const add = (path, name, prop) => {
        if (prop) transformProps.push({ path, name, property: prop });
      };
      add("transform.anchorPoint", "Anchor Point", t.anchorPoint);
      add("transform.position", "Position", t.position);
      if (props.layer.threeD) {
        transformProps.push({
          path: "transform.position.z",
          name: "Z Position",
          property: t.position
          // Pass full position property, PropertyTrack handles .z
        });
      }
      add("transform.scale", "Scale", t.scale);
      if (props.layer.threeD) {
        if (t.orientation) transformProps.push({ path: "transform.orientation", name: "Orientation", property: t.orientation });
        if (t.rotationX) transformProps.push({ path: "transform.rotationX", name: "X Rotation", property: t.rotationX });
        if (t.rotationY) transformProps.push({ path: "transform.rotationY", name: "Y Rotation", property: t.rotationY });
        if (t.rotationZ) transformProps.push({ path: "transform.rotationZ", name: "Z Rotation", property: t.rotationZ });
      } else {
        if (t.rotation) transformProps.push({ path: "transform.rotation", name: "Rotation", property: t.rotation });
      }
      if (props.layer.opacity) transformProps.push({ path: "opacity", name: "Opacity", property: props.layer.opacity });
      groups["Transform"] = transformProps;
      if (props.layer.properties) {
        props.layer.properties.forEach((p) => {
          const g = p.group || "Properties";
          if (!groups[g]) groups[g] = [];
          groups[g].push({ path: p.name, name: p.name, property: p });
        });
      }
      return groups;
    });
    const barStyle = computed(() => {
      const ppf = props.pixelsPerFrame || 10;
      return { left: `${props.layer.inPoint * ppf}px`, width: `${(props.layer.outPoint - props.layer.inPoint + 1) * ppf}px` };
    });
    function selectLayer() {
      emit("select", props.layer.id);
    }
    function toggleExpand() {
      emit("toggleExpand", props.layer.id, !isExpanded.value);
    }
    function toggleGroup(g) {
      if (expandedGroups.value.includes(g)) expandedGroups.value = expandedGroups.value.filter((x) => x !== g);
      else expandedGroups.value.push(g);
    }
    function getLayerIcon(t) {
      return { text: "T", solid: "", camera: "" }[t] || "";
    }
    function startRename() {
      isRenaming.value = true;
      renameVal.value = props.layer.name;
      nextTick(() => renameInput.value?.focus());
    }
    function saveRename() {
      emit("updateLayer", props.layer.id, { name: renameVal.value });
      isRenaming.value = false;
    }
    function setParent(e) {
      emit("updateLayer", props.layer.id, { parentId: e.target.value || null });
    }
    function setBlendMode(e) {
      emit("updateLayer", props.layer.id, { blendMode: e.target.value });
    }
    function startDrag() {
    }
    function toggleVis() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
    }
    function toggleLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
    }
    function toggleColorPicker() {
    }
    function resetTransform() {
      const comp = store.getActiveComp();
      if (!comp) return;
      const defaultTransform = {
        anchorPoint: { x: comp.settings.width / 2, y: comp.settings.height / 2 },
        position: { x: comp.settings.width / 2, y: comp.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100},
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      };
      const t = props.layer.transform;
      if (t.anchorPoint) t.anchorPoint.value = { ...defaultTransform.anchorPoint };
      if (t.position) t.position.value = props.layer.threeD ? { ...defaultTransform.position } : { x: defaultTransform.position.x, y: defaultTransform.position.y };
      if (t.scale) t.scale.value = { x: defaultTransform.scale.x, y: defaultTransform.scale.y };
      if (t.rotation) t.rotation.value = defaultTransform.rotation;
      if (t.rotationX) t.rotationX.value = defaultTransform.rotationX;
      if (t.rotationY) t.rotationY.value = defaultTransform.rotationY;
      if (t.rotationZ) t.rotationZ.value = defaultTransform.rotationZ;
      if (t.orientation) t.orientation.value = { ...defaultTransform.orientation };
      if (props.layer.opacity) props.layer.opacity.value = defaultTransform.opacity;
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      console.log("[EnhancedLayerTrack] Reset transform for layer:", props.layer.name);
    }
    function showContextMenu(e) {
      contextMenuX.value = e.clientX;
      contextMenuY.value = e.clientY;
      contextMenuVisible.value = true;
      if (!isSelected.value) {
        emit("select", props.layer.id);
      }
    }
    function hideContextMenu() {
      contextMenuVisible.value = false;
    }
    function duplicateLayer() {
      store.duplicateLayer(props.layer.id);
      hideContextMenu();
    }
    function renameFromMenu() {
      hideContextMenu();
      nextTick(() => {
        isRenaming.value = true;
        renameVal.value = props.layer.name;
        nextTick(() => renameInput.value?.focus());
      });
    }
    function toggleLayerVisibility() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
      hideContextMenu();
    }
    function toggleLayerLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
      hideContextMenu();
    }
    function toggleLayer3D() {
      store.toggleLayer3D(props.layer.id);
      hideContextMenu();
    }
    function precomposeLayer() {
      store.selectLayer(props.layer.id);
      store.precomposeSelectedLayers(props.layer.name + " Precomp");
      hideContextMenu();
    }
    function deleteLayer() {
      store.deleteLayer(props.layer.id);
      hideContextMenu();
    }
    function handleOutsideClick(e) {
      if (contextMenuVisible.value) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return __props.layer ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(["sidebar-row", { selected: isSelected.value }]),
            style: normalizeStyle(__props.gridStyle),
            onMousedown: selectLayer,
            onContextmenu: withModifiers(showContextMenu, ["prevent"])
          }, [
            createBaseVNode("div", {
              class: "arrow-col",
              onMousedown: withModifiers(toggleExpand, ["stop"])
            }, [
              createBaseVNode("span", _hoisted_2$9, toDisplayString(isExpanded.value ? "" : ""), 1)
            ], 32),
            createBaseVNode("div", {
              class: "label-box",
              onMousedown: withModifiers(toggleColorPicker, ["stop"]),
              style: normalizeStyle({ background: __props.layer.labelColor || "#999" })
            }, null, 36),
            createBaseVNode("div", _hoisted_3$9, toDisplayString(__props.index), 1),
            createBaseVNode("div", {
              class: "icon-col",
              onMousedown: withModifiers(toggleVis, ["stop"])
            }, toDisplayString(__props.layer.visible ? "" : ""), 33),
            createBaseVNode("div", {
              class: "icon-col",
              onMousedown: withModifiers(toggleLock, ["stop"])
            }, toDisplayString(__props.layer.locked ? "" : ""), 33),
            createBaseVNode("div", {
              class: normalizeClass(["icon-col cube-icon", { active: __props.layer.threeD }]),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(store).toggleLayer3D(__props.layer.id), ["stop"]))
            }, "", 34),
            createBaseVNode("div", {
              class: "layer-name-col",
              onDblclick: withModifiers(startRename, ["stop"])
            }, [
              createBaseVNode("span", _hoisted_4$9, toDisplayString(getLayerIcon(__props.layer.type)), 1),
              !isRenaming.value ? (openBlock(), createElementBlock("span", _hoisted_5$9, toDisplayString(__props.layer.name), 1)) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => renameVal.value = $event),
                onBlur: saveRename,
                onKeydown: withKeys(saveRename, ["enter"]),
                class: "rename-input",
                ref_key: "renameInput",
                ref: renameInput
              }, null, 544)), [
                [vModelText, renameVal.value]
              ])
            ], 32),
            createBaseVNode("div", _hoisted_6$9, [
              createBaseVNode("select", {
                value: __props.layer.blendMode,
                class: "mini-select",
                onChange: setBlendMode,
                onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"]))
              }, [..._cache[5] || (_cache[5] = [
                createStaticVNode('<optgroup label="Normal" data-v-fb7680b0><option value="normal" data-v-fb7680b0>Normal</option><option value="dissolve" data-v-fb7680b0>Dissolve</option></optgroup><optgroup label="Darken" data-v-fb7680b0><option value="darken" data-v-fb7680b0>Darken</option><option value="multiply" data-v-fb7680b0>Multiply</option><option value="colorBurn" data-v-fb7680b0>Color Burn</option><option value="linearBurn" data-v-fb7680b0>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-fb7680b0><option value="add" data-v-fb7680b0>Add</option><option value="lighten" data-v-fb7680b0>Lighten</option><option value="screen" data-v-fb7680b0>Screen</option><option value="colorDodge" data-v-fb7680b0>Color Dodge</option><option value="linearDodge" data-v-fb7680b0>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-fb7680b0><option value="overlay" data-v-fb7680b0>Overlay</option><option value="softLight" data-v-fb7680b0>Soft Light</option><option value="hardLight" data-v-fb7680b0>Hard Light</option><option value="vividLight" data-v-fb7680b0>Vivid Light</option><option value="linearLight" data-v-fb7680b0>Linear Light</option><option value="pinLight" data-v-fb7680b0>Pin Light</option><option value="hardMix" data-v-fb7680b0>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-fb7680b0><option value="difference" data-v-fb7680b0>Difference</option><option value="exclusion" data-v-fb7680b0>Exclusion</option><option value="subtract" data-v-fb7680b0>Subtract</option><option value="divide" data-v-fb7680b0>Divide</option></optgroup><optgroup label="Component" data-v-fb7680b0><option value="hue" data-v-fb7680b0>Hue</option><option value="saturation" data-v-fb7680b0>Saturation</option><option value="color" data-v-fb7680b0>Color</option><option value="luminosity" data-v-fb7680b0>Luminosity</option></optgroup>', 6)
              ])], 40, _hoisted_7$9)
            ]),
            createBaseVNode("div", _hoisted_8$9, [
              createBaseVNode("select", {
                value: __props.layer.parentId || "",
                class: "mini-select",
                onChange: setParent,
                onMousedown: _cache[3] || (_cache[3] = withModifiers(() => {
                }, ["stop"]))
              }, [
                _cache[6] || (_cache[6] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (p) => {
                  return openBlock(), createElementBlock("option", {
                    key: p.id,
                    value: p.id
                  }, toDisplayString(p.index), 9, _hoisted_10$9);
                }), 128))
              ], 40, _hoisted_9$9)
            ])
          ], 38),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_11$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                createBaseVNode("div", {
                  class: "group-header sidebar-row",
                  style: normalizeStyle(__props.gridStyle),
                  onMousedown: withModifiers(($event) => toggleGroup(groupName), ["stop"])
                }, [
                  createBaseVNode("div", _hoisted_13$7, [
                    createBaseVNode("span", _hoisted_14$7, toDisplayString(expandedGroups.value.includes(groupName) ? "" : ""), 1)
                  ]),
                  createBaseVNode("div", _hoisted_15$7, [
                    createTextVNode(toDisplayString(groupName) + " ", 1),
                    groupName === "Transform" ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: "reset-link",
                      onClick: withModifiers(resetTransform, ["stop"])
                    }, "Reset")) : createCommentVNode("", true)
                  ])
                ], 44, _hoisted_12$8),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_16$7, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "sidebar",
                      gridStyle: __props.gridStyle,
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "layer-row track-bg",
            onMousedown: selectLayer
          }, [
            createBaseVNode("div", {
              class: "duration-bar",
              style: normalizeStyle(barStyle.value),
              onMousedown: withModifiers(startDrag, ["stop"])
            }, [
              createBaseVNode("div", {
                class: "bar-fill",
                style: normalizeStyle({ background: __props.layer.labelColor || "#777" })
              }, null, 4)
            ], 36)
          ], 32),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_17$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                _cache[7] || (_cache[7] = createBaseVNode("div", { class: "group-header track-bg" }, null, -1)),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_18$7, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "track",
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenuVisible.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-context-menu",
            style: normalizeStyle({ left: contextMenuX.value + "px", top: contextMenuY.value + "px" }),
            onClick: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: duplicateLayer }, "Duplicate Layer"),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            _cache[8] || (_cache[8] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: toggleLayerVisibility }, toDisplayString(__props.layer.visible ? "Hide" : "Show") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayerLock }, toDisplayString(__props.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayer3D }, toDisplayString(__props.layer.threeD ? "Make 2D" : "Make 3D"), 1),
            _cache[9] || (_cache[9] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: precomposeLayer }, "Pre-compose..."),
            _cache[10] || (_cache[10] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteLayer,
              class: "danger"
            }, "Delete Layer")
          ], 4)) : createCommentVNode("", true)
        ]))
      ])) : createCommentVNode("", true);
    };
  }
});

const EnhancedLayerTrack = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-fb7680b0"]]);

const _hoisted_1$8 = { class: "composition-tabs" };
const _hoisted_2$8 = { class: "tabs-container" };
const _hoisted_3$8 = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_4$8 = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
};
const _hoisted_5$8 = {
  key: 1,
  class: "tab-name"
};
const _hoisted_6$8 = {
  key: 2,
  class: "tab-name"
};
const _hoisted_7$8 = { class: "tab-info" };
const _hoisted_8$8 = ["onClick"];
const _hoisted_9$8 = ["disabled"];
const _hoisted_10$8 = ["disabled"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const editingId = ref(null);
    const editingName = ref("");
    const renameInput = ref(null);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      comp: null
    });
    const openCompositions = computed(() => store.openCompositions);
    const activeCompositionId = computed(() => store.activeCompositionId);
    const mainCompositionId = computed(() => store.project.mainCompositionId);
    function switchToComposition(compId) {
      store.switchComposition(compId);
    }
    function closeTab(compId) {
      store.closeCompositionTab(compId);
    }
    function formatCompInfo(comp) {
      const s = comp.settings;
      return `${s.width}x${s.height} ${s.fps}fps`;
    }
    function startRename(comp) {
      editingId.value = comp.id;
      editingName.value = comp.name;
      nextTick(() => {
        renameInput.value?.focus();
        renameInput.value?.select();
      });
    }
    function finishRename() {
      if (editingId.value && editingName.value.trim()) {
        store.renameComposition(editingId.value, editingName.value.trim());
      }
      editingId.value = null;
      editingName.value = "";
    }
    function cancelRename() {
      editingId.value = null;
      editingName.value = "";
    }
    function showContextMenu(event, comp) {
      contextMenu.value = {
        visible: true,
        x: event.clientX,
        y: event.clientY,
        comp
      };
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.comp = null;
    }
    function renameFromMenu() {
      if (contextMenu.value.comp) {
        startRename(contextMenu.value.comp);
      }
      hideContextMenu();
    }
    function duplicateComposition() {
      if (contextMenu.value.comp) {
        const original = contextMenu.value.comp;
        const newComp = store.createComposition(
          `${original.name} Copy`,
          original.settings,
          original.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", newComp.name);
      }
      hideContextMenu();
    }
    function openInNewTab() {
      if (contextMenu.value.comp) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function setAsMainComp() {
      if (contextMenu.value.comp) {
        store.project.mainCompositionId = contextMenu.value.comp.id;
        console.log("[CompositionTabs] Set main composition:", contextMenu.value.comp.name);
      }
      hideContextMenu();
    }
    function deleteComposition() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== mainCompositionId.value) {
        store.deleteComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function handleOutsideClick() {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createBaseVNode("div", _hoisted_2$8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(openCompositions.value, (comp) => {
            return openBlock(), createElementBlock("div", {
              key: comp.id,
              class: normalizeClass(["tab", {
                active: comp.id === activeCompositionId.value,
                precomp: comp.isPrecomp
              }]),
              onClick: ($event) => switchToComposition(comp.id),
              onDblclick: ($event) => startRename(comp),
              onContextmenu: withModifiers(($event) => showContextMenu($event, comp), ["prevent"])
            }, [
              comp.isPrecomp ? (openBlock(), createElementBlock("span", _hoisted_4$8, "")) : createCommentVNode("", true),
              editingId.value === comp.id ? (openBlock(), createElementBlock("span", _hoisted_5$8, [
                withDirectives(createBaseVNode("input", {
                  ref_for: true,
                  ref_key: "renameInput",
                  ref: renameInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editingName.value = $event),
                  type: "text",
                  class: "rename-input",
                  onBlur: finishRename,
                  onKeydown: [
                    withKeys(finishRename, ["enter"]),
                    withKeys(cancelRename, ["escape"])
                  ],
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 544), [
                  [vModelText, editingName.value]
                ])
              ])) : (openBlock(), createElementBlock("span", _hoisted_6$8, toDisplayString(comp.name), 1)),
              createBaseVNode("span", _hoisted_7$8, toDisplayString(formatCompInfo(comp)), 1),
              openCompositions.value.length > 1 ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "close-btn",
                onClick: withModifiers(($event) => closeTab(comp.id), ["stop"]),
                title: "Close tab"
              }, "  ", 8, _hoisted_8$8)) : createCommentVNode("", true)
            ], 42, _hoisted_3$8);
          }), 128)),
          createBaseVNode("button", {
            class: "new-comp-btn",
            onClick: _cache[2] || (_cache[2] = ($event) => emit("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "context-menu",
            style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            createBaseVNode("button", { onClick: duplicateComposition }, "Duplicate"),
            createBaseVNode("button", { onClick: openInNewTab }, "Open in New Tab"),
            _cache[4] || (_cache[4] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: setAsMainComp,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value
            }, " Set as Main Composition ", 8, _hoisted_9$8),
            _cache[5] || (_cache[5] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteComposition,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value,
              class: "danger"
            }, " Delete Composition ", 8, _hoisted_10$8)
          ], 4)) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const CompositionTabs = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-c032dfe4"]]);

const _hoisted_1$7 = { class: "timeline-header" };
const _hoisted_2$7 = { class: "header-left" };
const _hoisted_3$7 = { class: "timecode" };
const _hoisted_4$7 = { class: "frame-display" };
const _hoisted_5$7 = ["value"];
const _hoisted_6$7 = { class: "fps-label" };
const _hoisted_7$7 = { class: "header-center" };
const _hoisted_8$7 = {
  key: 0,
  class: "add-layer-menu"
};
const _hoisted_9$7 = { class: "tool-group" };
const _hoisted_10$7 = ["disabled"];
const _hoisted_11$7 = { class: "header-right" };
const _hoisted_12$7 = { class: "timeline-content" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const pixelsPerFrame = ref(10);
    const sidebarWidth = ref(450);
    const expandedLayers = ref({});
    const showAddLayerMenu = ref(false);
    const addLayerContainer = ref(null);
    const trackViewportRef = ref(null);
    const rulerCanvas = ref(null);
    const sidebarScrollRef = ref(null);
    const trackScrollRef = ref(null);
    const rulerScrollRef = ref(null);
    let isScrollingSidebar = false;
    let isScrollingTrack = false;
    const viewportWidth = ref(1e3);
    const filteredLayers = computed(() => store.layers || []);
    const playheadPosition = computed(() => store.currentFrame * pixelsPerFrame.value);
    const computedWidthStyle = computed(() => {
      const frameWidth = store.frameCount * pixelsPerFrame.value;
      return Math.max(frameWidth, viewportWidth.value) + "px";
    });
    const sidebarGridStyle = computed(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function toggleAddLayerMenu() {
      showAddLayerMenu.value = !showAddLayerMenu.value;
    }
    function addLayer(type) {
      if (type === "text") store.createTextLayer();
      else if (type === "video") store.createLayer("video");
      else if (type === "camera") store.createCameraLayer();
      else store.createLayer(type);
      showAddLayerMenu.value = false;
    }
    function selectLayer(id) {
      store.selectLayer(id);
    }
    function updateLayer(id, u) {
      store.updateLayer(id, u);
    }
    function deleteSelectedLayers() {
      store.selectedLayerIds.forEach((id) => store.deleteLayer(id));
    }
    function setFrame(e) {
      store.setFrame(parseInt(e.target.value) || 0);
    }
    function togglePlayback() {
      store.togglePlayback();
    }
    function handleToggleExpand(id, val) {
      expandedLayers.value[id] = val;
    }
    function formatTimecode(frame) {
      const fps = store.fps;
      const totalSeconds = Math.floor(frame / fps);
      const frames = Math.floor(frame % fps);
      const seconds = totalSeconds % 60;
      const minutes = Math.floor(totalSeconds / 60) % 60;
      const hours = Math.floor(totalSeconds / 3600);
      const pad = (n, len = 2) => String(n).padStart(len, "0");
      return `${pad(hours)};${pad(minutes)};${pad(seconds)};${pad(frames)}`;
    }
    function drawRuler() {
      const cvs = rulerCanvas.value;
      if (!cvs) return;
      const ctx = cvs.getContext("2d");
      if (!ctx) return;
      const frameWidth = store.frameCount * pixelsPerFrame.value;
      const width = Math.max(frameWidth, viewportWidth.value);
      cvs.width = width;
      cvs.height = 30;
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, cvs.width, cvs.height);
      ctx.strokeStyle = "#666";
      ctx.fillStyle = "#aaa";
      ctx.font = "11px sans-serif";
      const ppf = pixelsPerFrame.value;
      let majorStep;
      let minorStep;
      if (ppf >= 20) {
        majorStep = 1;
        minorStep = 0;
      } else if (ppf >= 10) {
        majorStep = 5;
        minorStep = 1;
      } else if (ppf >= 5) {
        majorStep = 10;
        minorStep = 5;
      } else if (ppf >= 2) {
        majorStep = 20;
        minorStep = 10;
      } else if (ppf >= 1) {
        majorStep = 50;
        minorStep = 25;
      } else if (ppf >= 0.5) {
        majorStep = 100;
        minorStep = 50;
      } else {
        majorStep = 200;
        minorStep = 0;
      }
      for (let f = 0; f <= store.frameCount; f++) {
        const x = f * ppf;
        if (f % majorStep === 0) {
          ctx.strokeStyle = "#888";
          ctx.beginPath();
          ctx.moveTo(x, 12);
          ctx.lineTo(x, 30);
          ctx.stroke();
          const labelText = String(f);
          const textMetrics = ctx.measureText(labelText);
          const nextLabelX = (f + majorStep) * ppf;
          const minSpacing = textMetrics.width + 20;
          if (nextLabelX - x >= minSpacing || f === 0 || f >= store.frameCount - majorStep) {
            ctx.fillStyle = "#ccc";
            ctx.fillText(labelText, x + 3, 10);
          }
        } else if (minorStep > 0 && f % minorStep === 0) {
          ctx.strokeStyle = "#555";
          ctx.beginPath();
          ctx.moveTo(x, 22);
          ctx.lineTo(x, 30);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = "#444";
      ctx.beginPath();
      ctx.moveTo(0, 29.5);
      ctx.lineTo(cvs.width, 29.5);
      ctx.stroke();
    }
    function startRulerScrub(e) {
      const rect = rulerCanvas.value.getBoundingClientRect();
      const update = (ev) => {
        const currentScrollX = rulerScrollRef.value?.scrollLeft || trackScrollRef.value?.scrollLeft || 0;
        const x = ev.clientX - rect.left + currentScrollX;
        let f = Math.max(0, Math.min(store.frameCount - 1, x / pixelsPerFrame.value));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(Math.round(f), store.snapConfig, pixelsPerFrame.value, {
            layers: store.layers,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            f = snap.frame;
          }
        }
        store.setFrame(Math.round(f));
      };
      update(e);
      window.addEventListener("mousemove", update);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", update), { once: true });
    }
    function startResize(e) {
      const startX = e.clientX;
      const startW = sidebarWidth.value;
      const onMove = (ev) => {
        sidebarWidth.value = Math.max(300, startW + (ev.clientX - startX));
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", onMove), { once: true });
    }
    function syncSidebarScroll(e) {
      if (isScrollingTrack) return;
      isScrollingSidebar = true;
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollTop = target.scrollTop;
      }
      requestAnimationFrame(() => {
        isScrollingSidebar = false;
      });
    }
    function handleTrackScroll(e) {
      const target = e.target;
      if (!isScrollingSidebar) {
        isScrollingTrack = true;
        if (sidebarScrollRef.value) {
          sidebarScrollRef.value.scrollTop = target.scrollTop;
        }
        requestAnimationFrame(() => {
          isScrollingTrack = false;
        });
      }
      if (rulerScrollRef.value) {
        rulerScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function syncRulerScroll(e) {
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function handleKeydown(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      if (e.code === "Space") {
        e.preventDefault();
        togglePlayback();
      }
      if (e.code === "Delete" || e.code === "Backspace") {
        e.preventDefault();
        deleteSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyC") {
        e.preventDefault();
        store.copySelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyX") {
        e.preventDefault();
        store.cutSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyV") {
        e.preventDefault();
        store.pasteLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyA") {
        e.preventDefault();
        store.selectedLayerIds = store.layers.map((l) => l.id);
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyD") {
        e.preventDefault();
        for (const id of store.selectedLayerIds) {
          store.duplicateLayer(id);
        }
      }
    }
    let resizeObserver = null;
    onMounted(() => {
      window.addEventListener("mousedown", (e) => {
        if (addLayerContainer.value && !addLayerContainer.value.contains(e.target)) {
          showAddLayerMenu.value = false;
        }
      });
      const elementToObserve = trackScrollRef.value || trackViewportRef.value;
      if (elementToObserve) {
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            viewportWidth.value = entry.contentRect.width;
            drawRuler();
          }
        });
        resizeObserver.observe(elementToObserve);
      }
      setTimeout(drawRuler, 100);
    });
    onUnmounted(() => {
      if (resizeObserver) resizeObserver.disconnect();
    });
    watch(() => [computedWidthStyle.value, pixelsPerFrame.value, store.frameCount], () => nextTick(drawRuler));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "timeline-panel",
        tabindex: "0",
        onKeydown: handleKeydown
      }, [
        createVNode(CompositionTabs, {
          onNewComposition: _cache[0] || (_cache[0] = ($event) => emit("openCompositionSettings"))
        }),
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("div", _hoisted_2$7, [
            createBaseVNode("span", _hoisted_3$7, toDisplayString(formatTimecode(unref(store).currentFrame)), 1),
            createBaseVNode("div", _hoisted_4$7, [
              createBaseVNode("input", {
                type: "number",
                value: unref(store).currentFrame,
                onChange: setFrame,
                class: "frame-input"
              }, null, 40, _hoisted_5$7),
              createBaseVNode("span", _hoisted_6$7, toDisplayString(unref(store).fps) + " fps", 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$7, [
            createBaseVNode("div", {
              class: "tool-group add-layer-wrapper",
              ref_key: "addLayerContainer",
              ref: addLayerContainer
            }, [
              createBaseVNode("button", {
                class: normalizeClass(["add-layer-btn", { active: showAddLayerMenu.value }]),
                onMousedown: withModifiers(toggleAddLayerMenu, ["stop", "prevent"])
              }, [..._cache[9] || (_cache[9] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" Layer ", -1)
              ])], 34),
              showAddLayerMenu.value ? (openBlock(), createElementBlock("div", _hoisted_8$7, [
                createBaseVNode("button", {
                  onMousedown: _cache[1] || (_cache[1] = ($event) => addLayer("solid"))
                }, [..._cache[10] || (_cache[10] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Solid", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[2] || (_cache[2] = ($event) => addLayer("text"))
                }, [..._cache[11] || (_cache[11] = [
                  createBaseVNode("span", { class: "icon" }, "T", -1),
                  createTextVNode(" Text", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[3] || (_cache[3] = ($event) => addLayer("spline"))
                }, [..._cache[12] || (_cache[12] = [
                  createBaseVNode("span", { class: "icon" }, "~", -1),
                  createTextVNode(" Shape", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[4] || (_cache[4] = ($event) => addLayer("null"))
                }, [..._cache[13] || (_cache[13] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Null", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[5] || (_cache[5] = ($event) => addLayer("camera"))
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Camera", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[6] || (_cache[6] = ($event) => addLayer("light"))
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Light", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[7] || (_cache[7] = ($event) => addLayer("video"))
                }, [..._cache[16] || (_cache[16] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Video", -1)
                ])], 32)
              ])) : createCommentVNode("", true)
            ], 512),
            createBaseVNode("div", _hoisted_9$7, [
              createBaseVNode("button", {
                class: "delete-btn",
                onClick: deleteSelectedLayers,
                disabled: unref(store).selectedLayerIds.length === 0
              }, "", 8, _hoisted_10$7)
            ])
          ]),
          createBaseVNode("div", _hoisted_11$7, [
            withDirectives(createBaseVNode("input", {
              type: "range",
              min: "0.1",
              max: "50",
              step: "0.1",
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => pixelsPerFrame.value = $event),
              class: "zoom-slider",
              title: "Zoom Timeline"
            }, null, 512), [
              [
                vModelText,
                pixelsPerFrame.value,
                void 0,
                { number: true }
              ]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_12$7, [
          createBaseVNode("div", {
            class: "timeline-sidebar",
            style: normalizeStyle({ width: sidebarWidth.value + "px" })
          }, [
            _cache[17] || (_cache[17] = createStaticVNode('<div class="sidebar-header-row" data-v-0c0bcb17><div class="col-header col-arrow" data-v-0c0bcb17></div><div class="col-header col-name" data-v-0c0bcb17>Layer Name</div><div class="col-header col-mode" data-v-0c0bcb17>Mode</div><div class="col-header col-parent" data-v-0c0bcb17>Parent</div></div>', 1)),
            createBaseVNode("div", {
              class: "sidebar-scroll-area",
              ref_key: "sidebarScrollRef",
              ref: sidebarScrollRef,
              onScroll: syncSidebarScroll
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer, idx) => {
                return openBlock(), createBlock(EnhancedLayerTrack, {
                  key: layer.id,
                  layer,
                  index: idx + 1,
                  layoutMode: "sidebar",
                  isExpandedExternal: expandedLayers.value[layer.id],
                  allLayers: unref(store).layers,
                  gridStyle: sidebarGridStyle.value,
                  onToggleExpand: handleToggleExpand,
                  onSelect: selectLayer,
                  onUpdateLayer: updateLayer
                }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]);
              }), 128))
            ], 544)
          ], 4),
          createBaseVNode("div", {
            class: "sidebar-resizer",
            onMousedown: startResize
          }, null, 32),
          createBaseVNode("div", {
            class: "track-viewport",
            ref_key: "trackViewportRef",
            ref: trackViewportRef
          }, [
            createBaseVNode("div", {
              class: "ruler-scroll-wrapper",
              onScroll: syncRulerScroll,
              ref_key: "rulerScrollRef",
              ref: rulerScrollRef
            }, [
              createBaseVNode("div", {
                class: "time-ruler",
                style: normalizeStyle({ width: computedWidthStyle.value }),
                onMousedown: startRulerScrub
              }, [
                createBaseVNode("canvas", {
                  ref_key: "rulerCanvas",
                  ref: rulerCanvas,
                  height: "30"
                }, null, 512),
                createBaseVNode("div", {
                  class: "playhead-head",
                  style: normalizeStyle({ left: playheadPosition.value + "px" })
                }, null, 4),
                createBaseVNode("div", {
                  class: "playhead-hit-area",
                  style: normalizeStyle({ left: playheadPosition.value + "px" }),
                  onMousedown: withModifiers(startRulerScrub, ["stop"])
                }, null, 36)
              ], 36)
            ], 544),
            createBaseVNode("div", {
              class: "track-scroll-area",
              ref_key: "trackScrollRef",
              ref: trackScrollRef,
              onScroll: handleTrackScroll
            }, [
              createBaseVNode("div", {
                class: "layer-bars-container",
                style: normalizeStyle({ width: computedWidthStyle.value })
              }, [
                _cache[18] || (_cache[18] = createBaseVNode("div", { class: "grid-background" }, null, -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer) => {
                  return openBlock(), createBlock(EnhancedLayerTrack, {
                    key: layer.id,
                    layer,
                    layoutMode: "track",
                    frameCount: unref(store).frameCount,
                    pixelsPerFrame: pixelsPerFrame.value,
                    isExpandedExternal: expandedLayers.value[layer.id],
                    onSelect: selectLayer,
                    onUpdateLayer: updateLayer
                  }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]);
                }), 128)),
                createBaseVNode("div", {
                  class: "playhead-line",
                  style: normalizeStyle({ left: playheadPosition.value + "px" })
                }, null, 4)
              ], 4)
            ], 544)
          ], 512)
        ])
      ], 32);
    };
  }
});

const TimelinePanel = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-0c0bcb17"]]);

const _hoisted_1$6 = { class: "graph-editor" };
const _hoisted_2$6 = { class: "graph-header" };
const _hoisted_3$6 = { class: "mode-toggle" };
const _hoisted_4$6 = { class: "preset-buttons" };
const _hoisted_5$6 = ["onClick", "title"];
const _hoisted_6$6 = { class: "toolbar" };
const _hoisted_7$6 = { class: "graph-content" };
const _hoisted_8$6 = { class: "property-list" };
const _hoisted_9$6 = { class: "property-list-header" };
const _hoisted_10$6 = ["title"];
const _hoisted_11$6 = ["onClick"];
const _hoisted_12$6 = ["onClick"];
const _hoisted_13$6 = { class: "property-name" };
const _hoisted_14$6 = {
  key: 0,
  class: "keyframe-count"
};
const _hoisted_15$6 = {
  key: 0,
  class: "dimension-toggles"
};
const _hoisted_16$6 = ["onClick"];
const _hoisted_17$6 = {
  key: 0,
  class: "no-properties"
};
const _hoisted_18$6 = { class: "graph-main" };
const _hoisted_19$6 = ["viewBox"];
const _hoisted_20$6 = ["onMousedown"];
const _hoisted_21$6 = ["x", "y", "fill", "transform"];
const _hoisted_22$6 = {
  key: 1,
  class: "bezier-handles"
};
const _hoisted_23$6 = {
  key: 0,
  class: "handle out-handle"
};
const _hoisted_24$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$4 = ["cx", "cy", "onMousedown"];
const _hoisted_26$4 = {
  key: 1,
  class: "handle in-handle"
};
const _hoisted_27$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_28$4 = ["cx", "cy", "onMousedown"];
const _hoisted_29$4 = ["x1", "x2", "y2"];
const _hoisted_30$4 = {
  key: 0,
  class: "keyframe-info-panel"
};
const _hoisted_31$2 = { class: "info-row" };
const _hoisted_32$2 = ["value"];
const _hoisted_33$2 = { class: "info-row" };
const _hoisted_34$2 = ["value"];
const _hoisted_35$2 = { class: "info-row" };
const _hoisted_36$2 = ["value"];
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$1 = ["disabled"];
const _hoisted_39$1 = ["disabled"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "GraphEditor",
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const canvasRef = ref(null);
    const canvasContainerRef = ref(null);
    const timeRulerRef = ref(null);
    const timeRulerCanvas = ref(null);
    const valueAxisRef = ref(null);
    const valueAxisCanvas = ref(null);
    const canvasWidth = ref(400);
    const canvasHeight = ref(200);
    const mode = ref("value");
    const viewState = reactive({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    });
    const selectedPropertyIds = ref([]);
    const visiblePropertyIds = ref([]);
    const visibleDimensions = ref({});
    const selectedKeyframes = ref([]);
    const hoveredKeyframe = ref(null);
    const dragTarget = ref(null);
    const selectionBox = ref(null);
    const contextMenu = ref(null);
    const clipboard = ref(null);
    const snapEnabled = ref(false);
    const autoSelectNearby = ref(true);
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const propertyColors = {
      "Position": "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      "Scale": "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      "Rotation": "#bb8fce",
      "Opacity": "#f8b739",
      "default": "#7c9cff"
    };
    const presetList = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ];
    const animatableProperties = computed(() => {
      const layer = store.selectedLayer;
      if (!layer) return [];
      const props = [];
      props.push(layer.transform.position);
      props.push(layer.transform.scale);
      props.push(layer.transform.rotation);
      props.push(layer.opacity);
      props.push(...layer.properties);
      return props;
    });
    const visibleProperties = computed(() => {
      return animatableProperties.value.filter(
        (p) => visiblePropertyIds.value.includes(p.id) && p.animated
      );
    });
    const allPropertiesVisible = computed(() => {
      return animatableProperties.value.every((p) => visiblePropertyIds.value.includes(p.id));
    });
    const currentFrameScreenX = computed(() => {
      return frameToScreenX(store.currentFrame);
    });
    function frameToScreenX(frame) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (frame - viewState.frameStart) / (viewState.frameEnd - viewState.frameStart);
      return margin.left + t * graphWidth;
    }
    function screenXToFrame(screenX) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (screenX - margin.left) / graphWidth;
      return viewState.frameStart + t * (viewState.frameEnd - viewState.frameStart);
    }
    function valueToScreenY(value) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (value - viewState.valueMin) / (viewState.valueMax - viewState.valueMin);
      return canvasHeight.value - margin.bottom - t * graphHeight;
    }
    function screenYToValue(screenY) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (canvasHeight.value - margin.bottom - screenY) / graphHeight;
      return viewState.valueMin + t * (viewState.valueMax - viewState.valueMin);
    }
    function getKeyframeScreenX(kf) {
      return frameToScreenX(kf.frame);
    }
    function getKeyframeScreenY(prop, kf) {
      const value = typeof kf.value === "number" ? kf.value : typeof kf.value === "object" ? kf.value.x ?? kf.value : 0;
      return valueToScreenY(value);
    }
    function getKeyframeDisplayValue(selection) {
      if (!selection) return 0;
      const value = selection.keyframe.value;
      return typeof value === "number" ? value : typeof value === "object" ? value.x ?? 0 : 0;
    }
    function getOutHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.outHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getOutHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.outHandle.value;
      return valueToScreenY(handleValue);
    }
    function getInHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.inHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getInHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.inHandle.value;
      return valueToScreenY(handleValue);
    }
    function getNumericValue(value) {
      if (typeof value === "number") return value;
      if (typeof value === "object") return value.x ?? value.y ?? value.z ?? 0;
      return 0;
    }
    function getPropertyColor(propId) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return propertyColors.default;
      return propertyColors[prop.name] ?? propertyColors.default;
    }
    function isKeyframeInView(kf) {
      return kf.frame >= viewState.frameStart && kf.frame <= viewState.frameEnd;
    }
    function isKeyframeSelected(propId, index) {
      return selectedKeyframes.value.some((sk) => sk.propId === propId && sk.index === index);
    }
    function hasDimension(prop, dim) {
      if (!prop.animated || prop.keyframes.length === 0) return false;
      const value = prop.keyframes[0].value;
      return typeof value === "object" && dim in value;
    }
    function toggleProperty(propId) {
      const index = selectedPropertyIds.value.indexOf(propId);
      if (index === -1) {
        selectedPropertyIds.value.push(propId);
      } else {
        selectedPropertyIds.value.splice(index, 1);
      }
    }
    function togglePropertyVisibility(propId) {
      const index = visiblePropertyIds.value.indexOf(propId);
      if (index === -1) {
        visiblePropertyIds.value.push(propId);
      } else {
        visiblePropertyIds.value.splice(index, 1);
      }
      updateViewBounds();
    }
    function toggleAllProperties() {
      if (allPropertiesVisible.value) {
        visiblePropertyIds.value = [];
      } else {
        visiblePropertyIds.value = animatableProperties.value.map((p) => p.id);
      }
      updateViewBounds();
    }
    function toggleDimension(propId, dim) {
      if (!visibleDimensions.value[propId]) {
        visibleDimensions.value[propId] = [];
      }
      const dims = visibleDimensions.value[propId];
      const index = dims.indexOf(dim);
      if (index === -1) {
        dims.push(dim);
      } else {
        dims.splice(index, 1);
      }
    }
    function fitToView() {
      const visible = visibleProperties.value;
      if (visible.length === 0) return;
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const prop of visible) {
        for (const kf of prop.keyframes) {
          minFrame = Math.min(minFrame, kf.frame);
          maxFrame = Math.max(maxFrame, kf.frame);
          const value = getNumericValue(kf.value);
          minValue = Math.min(minValue, value);
          maxValue = Math.max(maxValue, value);
        }
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
    }
    function updateViewBounds() {
      fitToView();
    }
    function toggleAutoSelect() {
      autoSelectNearby.value = !autoSelectNearby.value;
    }
    function isPresetActive(presetKey) {
      if (selectedKeyframes.value.length === 0) return false;
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return false;
      if (presetKey === "linear") {
        return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "linear");
      }
      return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "bezier");
    }
    function applyPreset(presetKey) {
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const propertyPath = getPropertyPath(prop);
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? sk.keyframe.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - sk.keyframe.frame : 10;
        if (presetKey === "linear") {
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "linear");
          sk.keyframe.interpolation = "linear";
          sk.keyframe.outHandle = { frame: outDuration * 0.33, value: 0, enabled: false };
          sk.keyframe.inHandle = { frame: -inDuration * 0.33, value: 0, enabled: false };
        } else {
          const outHandle = {
            frame: preset.outHandle.x * outDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          const inHandle = {
            frame: -preset.inHandle.x * inDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "bezier");
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "out", outHandle);
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "in", inHandle);
          sk.keyframe.interpolation = "bezier";
          sk.keyframe.outHandle = outHandle;
          sk.keyframe.inHandle = inHandle;
        }
      }
      drawGraph();
    }
    function handleMouseDown(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 1 || event.button === 0 && event.altKey) {
        dragTarget.value = { type: "pan", startX: x, startY: y };
      } else if (event.button === 0) {
        if (!event.shiftKey) {
          selectedKeyframes.value = [];
        }
        selectionBox.value = { x, y, width: 0, height: 0 };
        dragTarget.value = { type: "select", startX: x, startY: y };
      }
    }
    function handleMouseMove(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      updateHoveredKeyframe(x, y);
      if (!dragTarget.value) return;
      if (dragTarget.value.type === "pan") {
        const dx = x - (dragTarget.value.startX ?? 0);
        const dy = y - (dragTarget.value.startY ?? 0);
        const graphWidth = canvasWidth.value - margin.left - margin.right;
        const graphHeight = canvasHeight.value - margin.top - margin.bottom;
        const frameShift = -dx / graphWidth * (viewState.frameEnd - viewState.frameStart);
        const valueShift = dy / graphHeight * (viewState.valueMax - viewState.valueMin);
        viewState.frameStart += frameShift;
        viewState.frameEnd += frameShift;
        viewState.valueMin += valueShift;
        viewState.valueMax += valueShift;
        dragTarget.value.startX = x;
        dragTarget.value.startY = y;
        drawGraph();
      } else if (dragTarget.value.type === "select" && selectionBox.value) {
        const startX = dragTarget.value.startX ?? 0;
        const startY = dragTarget.value.startY ?? 0;
        selectionBox.value = {
          x: Math.min(x, startX),
          y: Math.min(y, startY),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY)
        };
      } else if (dragTarget.value.type === "keyframe") {
        moveSelectedKeyframes(x, y);
      } else if (dragTarget.value.type === "outHandle" || dragTarget.value.type === "inHandle") {
        moveHandle(x, y);
      }
    }
    function handleMouseUp() {
      if (dragTarget.value?.type === "select" && selectionBox.value) {
        selectKeyframesInBox();
      }
      dragTarget.value = null;
      selectionBox.value = null;
    }
    function handleWheel(event) {
      event.preventDefault();
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
      const frameAtCursor = screenXToFrame(x);
      const newFrameStart = frameAtCursor - (frameAtCursor - viewState.frameStart) * zoomFactor;
      const newFrameEnd = frameAtCursor + (viewState.frameEnd - frameAtCursor) * zoomFactor;
      if (event.shiftKey) {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
      } else {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
        const y = event.clientY - rect.top;
        const valueAtCursor = screenYToValue(y);
        viewState.valueMin = valueAtCursor - (valueAtCursor - viewState.valueMin) * zoomFactor;
        viewState.valueMax = valueAtCursor + (viewState.valueMax - valueAtCursor) * zoomFactor;
      }
      drawGraph();
    }
    function updateHoveredKeyframe(x, y) {
      hoveredKeyframe.value = null;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const kfX = getKeyframeScreenX(kf);
          const kfY = getKeyframeScreenY(prop, kf);
          const dist = Math.sqrt((x - kfX) ** 2 + (y - kfY) ** 2);
          if (dist < 10) {
            hoveredKeyframe.value = { propId: prop.id, index: i };
            return;
          }
        }
      }
    }
    function onKeyframeMouseDown(propId, index, event) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return;
      const kf = prop.keyframes[index];
      if (!event.shiftKey) {
        selectedKeyframes.value = [];
      }
      if (!isKeyframeSelected(propId, index)) {
        selectedKeyframes.value.push({ propId, index, keyframe: kf });
      }
      dragTarget.value = { type: "keyframe", propId, index };
    }
    function selectKeyframesInBox() {
      if (!selectionBox.value) return;
      const box = selectionBox.value;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const x = getKeyframeScreenX(kf);
          const y = getKeyframeScreenY(prop, kf);
          if (x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height) {
            if (!isKeyframeSelected(prop.id, i)) {
              selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: kf });
            }
          }
        }
      }
    }
    function moveSelectedKeyframes(screenX, screenY) {
      const newFrame = Math.round(screenXToFrame(screenX));
      const newValue = screenYToValue(screenY);
      const layer = store.selectedLayer;
      if (!layer) return;
      if (selectedKeyframes.value.length > 0) {
        const sk = selectedKeyframes.value[0];
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) return;
        const frame = snapEnabled.value ? Math.round(newFrame / 5) * 5 : newFrame;
        const propertyPath = getPropertyPath(prop);
        store.updateKeyframe(layer.id, propertyPath, sk.keyframe.id, {
          frame,
          value: typeof sk.keyframe.value === "number" ? newValue : void 0
        });
        sk.keyframe.frame = frame;
        if (typeof sk.keyframe.value === "number") {
          sk.keyframe.value = newValue;
        }
      }
      drawGraph();
    }
    function getPropertyPath(prop) {
      const name = prop.name.toLowerCase();
      if (name === "position") return "transform.position";
      if (name === "scale") return "transform.scale";
      if (name === "rotation") return "transform.rotation";
      if (name === "opacity") return "opacity";
      if (name === "anchor point") return "transform.anchorPoint";
      return prop.id;
    }
    function startDragHandle(type, propId, index, event) {
      dragTarget.value = { type, propId, index };
      document.addEventListener("mousemove", onDragHandle);
      document.addEventListener("mouseup", stopDragHandle);
    }
    function onDragHandle(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect || !dragTarget.value) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      moveHandle(x, y);
    }
    function moveHandle(screenX, screenY) {
      if (!dragTarget.value || !dragTarget.value.propId) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = animatableProperties.value.find((p) => p.id === dragTarget.value.propId);
      if (!prop) return;
      const kfIndex = dragTarget.value.index;
      const kf = prop.keyframes[kfIndex];
      if (!kf) return;
      const handleFrame = screenXToFrame(screenX);
      const handleValue = screenYToValue(screenY);
      const propertyPath = getPropertyPath(prop);
      if (dragTarget.value.type === "outHandle") {
        const nextKf = prop.keyframes[kfIndex + 1];
        let frameOffset = handleFrame - kf.frame;
        if (nextKf) {
          frameOffset = Math.max(0, Math.min(nextKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.max(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", newHandle);
        kf.outHandle = newHandle;
        kf.interpolation = "bezier";
        applyControlModeConstraints(kf, "out", propertyPath);
      } else if (dragTarget.value.type === "inHandle") {
        const prevKf = prop.keyframes[kfIndex - 1];
        let frameOffset = handleFrame - kf.frame;
        if (prevKf) {
          frameOffset = Math.min(0, Math.max(prevKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.min(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", newHandle);
        kf.inHandle = newHandle;
        applyControlModeConstraints(kf, "in", propertyPath);
      }
      drawGraph();
    }
    function applyControlModeConstraints(kf, changedHandle, propertyPath) {
      if (!kf.controlMode || kf.controlMode === "corner") {
        return;
      }
      const layer = store.selectedLayer;
      if (!layer) return;
      if (kf.controlMode === "symmetric") {
        if (changedHandle === "in") {
          kf.outHandle.frame = -kf.inHandle.frame;
          kf.outHandle.value = -kf.inHandle.value;
          kf.outHandle.enabled = kf.inHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", { ...kf.outHandle });
        } else {
          kf.inHandle.frame = -kf.outHandle.frame;
          kf.inHandle.value = -kf.outHandle.value;
          kf.inHandle.enabled = kf.outHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", { ...kf.inHandle });
        }
      }
      if (kf.controlMode === "smooth") {
        const changed = changedHandle === "in" ? kf.inHandle : kf.outHandle;
        const other = changedHandle === "in" ? kf.outHandle : kf.inHandle;
        const otherType = changedHandle === "in" ? "out" : "in";
        if (changed.frame !== 0 || changed.value !== 0) {
          const angle = Math.atan2(changed.value, changed.frame);
          const oppositeAngle = angle + Math.PI;
          const otherLength = Math.hypot(other.frame, other.value);
          other.frame = Math.cos(oppositeAngle) * otherLength;
          other.value = Math.sin(oppositeAngle) * otherLength;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, otherType, { ...other });
        }
      }
    }
    function stopDragHandle() {
      dragTarget.value = null;
      document.removeEventListener("mousemove", onDragHandle);
      document.removeEventListener("mouseup", stopDragHandle);
    }
    function showContextMenu(event) {
      contextMenu.value = { x: event.offsetX, y: event.offsetY };
    }
    function addKeyframeAtPosition() {
      if (!contextMenu.value) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const frame = Math.round(screenXToFrame(contextMenu.value.x));
      const value = screenYToValue(contextMenu.value.y);
      if (visibleProperties.value.length > 0) {
        const prop = visibleProperties.value[0];
        const propertyPath = getPropertyPath(prop);
        const keyframeValue = typeof prop.value === "number" ? value : { x: value, y: value };
        store.addKeyframe(layer.id, propertyPath, keyframeValue, frame);
        drawGraph();
      }
      contextMenu.value = null;
    }
    function deleteSelectedKeyframes() {
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (prop) {
          const propertyPath = getPropertyPath(prop);
          store.removeKeyframe(layer.id, propertyPath, sk.keyframe.id);
        }
      }
      selectedKeyframes.value = [];
      drawGraph();
    }
    function copyKeyframes() {
      clipboard.value = selectedKeyframes.value.map((sk) => ({ ...sk.keyframe }));
    }
    function pasteKeyframes() {
      if (!clipboard.value || visibleProperties.value.length === 0) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = visibleProperties.value[0];
      const propertyPath = getPropertyPath(prop);
      const offset = store.currentFrame - clipboard.value[0].frame;
      for (const kf of clipboard.value) {
        const newFrame = kf.frame + offset;
        const newKeyframe = store.addKeyframe(layer.id, propertyPath, kf.value, newFrame);
        if (newKeyframe) {
          if (kf.interpolation !== "linear") {
            store.setKeyframeInterpolation(layer.id, propertyPath, newKeyframe.id, kf.interpolation);
          }
          if (kf.inHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "in", kf.inHandle);
          }
          if (kf.outHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "out", kf.outHandle);
          }
        }
      }
      drawGraph();
    }
    function selectAllKeyframes() {
      selectedKeyframes.value = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
        }
      }
    }
    function invertSelection() {
      const newSelection = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          if (!isKeyframeSelected(prop.id, i)) {
            newSelection.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
          }
        }
      }
      selectedKeyframes.value = newSelection;
    }
    function updateSelectedKeyframeFrame(event) {
      const value = parseInt(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        selectedKeyframes.value[0].keyframe.frame = value;
        drawGraph();
      }
    }
    function updateSelectedKeyframeValue(event) {
      const value = parseFloat(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        const kf = selectedKeyframes.value[0].keyframe;
        if (typeof kf.value === "number") {
          kf.value = value;
        } else if (typeof kf.value === "object") {
          kf.value.x = value;
        }
        drawGraph();
      }
    }
    function updateSelectedKeyframeInterpolation(event) {
      const value = event.target.value;
      if (selectedKeyframes.value.length > 0) {
        selectedKeyframes.value[0].keyframe.interpolation = value;
        drawGraph();
      }
    }
    function onTimeRulerClick(event) {
      const rect = timeRulerCanvas.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const frame = Math.round(screenXToFrame(x));
      store.setFrame(frame);
    }
    function drawGraph() {
      drawMainCanvas();
      drawTimeRuler();
      drawValueAxis();
    }
    function drawMainCanvas() {
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = canvasWidth.value;
      canvas.height = canvasHeight.value;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
      drawGrid(ctx);
      for (const prop of visibleProperties.value) {
        drawPropertyCurve(ctx, prop);
      }
    }
    function drawGrid(ctx) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, graphWidth, 50);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, graphHeight, 30);
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
      ctx.strokeStyle = "#3a3a3a";
      ctx.lineWidth = 1;
      if (viewState.frameStart <= 0 && viewState.frameEnd >= 0) {
        const x = frameToScreenX(0);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      if (viewState.valueMin <= 0 && viewState.valueMax >= 0) {
        const y = valueToScreenY(0);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
    }
    function calculateGridStep(range, pixelSize, targetSpacing) {
      const rawStep = range * targetSpacing / pixelSize;
      const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const normalized = rawStep / magnitude;
      if (normalized <= 1) return magnitude;
      if (normalized <= 2) return 2 * magnitude;
      if (normalized <= 5) return 5 * magnitude;
      return 10 * magnitude;
    }
    function drawPropertyCurve(ctx, prop) {
      if (prop.keyframes.length < 2) return;
      const color = getPropertyColor(prop.id);
      for (let pass = 0; pass < 2; pass++) {
        if (pass === 0) {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < prop.keyframes.length - 1; i++) {
          const kf1 = prop.keyframes[i];
          const kf2 = prop.keyframes[i + 1];
          if (kf2.frame < viewState.frameStart || kf1.frame > viewState.frameEnd) continue;
          const x1 = getKeyframeScreenX(kf1);
          const y1 = getKeyframeScreenY(prop, kf1);
          const x2 = getKeyframeScreenX(kf2);
          const y2 = getKeyframeScreenY(prop, kf2);
          if (!started) {
            ctx.moveTo(x1, y1);
            started = true;
          }
          if (kf1.interpolation === "hold") {
            ctx.lineTo(x2, y1);
            ctx.lineTo(x2, y2);
          } else if (kf1.interpolation === "linear" || !kf1.outHandle.enabled && !kf2.inHandle.enabled) {
            ctx.lineTo(x2, y2);
          } else {
            const cp1x = frameToScreenX(kf1.frame + kf1.outHandle.frame);
            const cp1y = valueToScreenY(getNumericValue(kf1.value) + kf1.outHandle.value);
            const cp2x = frameToScreenX(kf2.frame + kf2.inHandle.frame);
            const cp2y = valueToScreenY(getNumericValue(kf2.value) + kf2.inHandle.value);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
          }
        }
        ctx.stroke();
      }
    }
    function drawTimeRuler() {
      const canvas = timeRulerCanvas.value;
      if (!canvas) return;
      const rect = timeRulerRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = rect.width;
      canvas.height = 24;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, canvas.width, 60);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.fillText(frame.toString(), x, 16);
        ctx.strokeStyle = "#444";
        ctx.beginPath();
        ctx.moveTo(x, 20);
        ctx.lineTo(x, 24);
        ctx.stroke();
      }
      const ctfX = frameToScreenX(store.currentFrame);
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.moveTo(ctfX - 5, 0);
      ctx.lineTo(ctfX + 5, 0);
      ctx.lineTo(ctfX, 8);
      ctx.closePath();
      ctx.fill();
    }
    function drawValueAxis() {
      const canvas = valueAxisCanvas.value;
      if (!canvas) return;
      const rect = valueAxisRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = 40;
      canvas.height = rect.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, canvas.height, 30);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.fillText(value.toFixed(0), 36, y + 4);
      }
    }
    function applyEasyEase(direction = "both") {
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const kf = sk.keyframe;
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? kf.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - kf.frame : 10;
        const influence = 0.3333;
        if (direction === "both" || direction === "in") {
          kf.inHandle = {
            frame: -inDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        if (direction === "both" || direction === "out") {
          kf.outHandle = {
            frame: outDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        kf.interpolation = "bezier";
        kf.controlMode = "smooth";
      }
      drawGraph();
    }
    function goToPreviousKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const prev = [...allKeyframes].reverse().find((f) => f < currentFrame);
      if (prev !== void 0) {
        store.setFrame(prev);
      }
    }
    function goToNextKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const next = allKeyframes.find((f) => f > currentFrame);
      if (next !== void 0) {
        store.setFrame(next);
      }
    }
    function handleKeyDown(event) {
      if (event.key === "F9") {
        event.preventDefault();
        if (event.ctrlKey && event.shiftKey) {
          applyEasyEase("out");
        } else if (event.shiftKey) {
          applyEasyEase("in");
        } else {
          applyEasyEase("both");
        }
        return;
      }
      if (event.key.toLowerCase() === "j") {
        event.preventDefault();
        goToPreviousKeyframe();
        return;
      }
      if (event.key.toLowerCase() === "k") {
        event.preventDefault();
        goToNextKeyframe();
        return;
      }
      if (event.key === "Delete" || event.key === "Backspace") {
        event.preventDefault();
        deleteSelectedKeyframes();
        return;
      }
      if (event.key.toLowerCase() === "f" && !event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          fitToView();
        } else if (selectedKeyframes.value.length > 0) {
          fitSelectionToView();
        } else {
          fitToView();
        }
        return;
      }
      if (event.key === "=" || event.key === "+") {
        event.preventDefault();
        zoomIn();
        return;
      }
      if (event.key === "-" || event.key === "_") {
        event.preventDefault();
        zoomOut();
        return;
      }
    }
    function fitSelectionToView() {
      if (selectedKeyframes.value.length === 0) {
        fitToView();
        return;
      }
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const sk of selectedKeyframes.value) {
        minFrame = Math.min(minFrame, sk.keyframe.frame);
        maxFrame = Math.max(maxFrame, sk.keyframe.frame);
        const value = getNumericValue(sk.keyframe.value);
        minValue = Math.min(minValue, value);
        maxValue = Math.max(maxValue, value);
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
      drawGraph();
    }
    function zoomIn() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.4;
      viewState.frameEnd = centerFrame + frameRange * 0.4;
      drawGraph();
    }
    function zoomOut() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.6;
      viewState.frameEnd = centerFrame + frameRange * 0.6;
      drawGraph();
    }
    let resizeObserver = null;
    onMounted(() => {
      if (canvasContainerRef.value) {
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            canvasWidth.value = entry.contentRect.width;
            canvasHeight.value = entry.contentRect.height;
            drawGraph();
          }
        });
        resizeObserver.observe(canvasContainerRef.value);
      }
      visiblePropertyIds.value = animatableProperties.value.filter((p) => p.animated).map((p) => p.id);
      window.addEventListener("keydown", handleKeyDown);
      fitToView();
      drawGraph();
    });
    onUnmounted(() => {
      resizeObserver?.disconnect();
      window.removeEventListener("keydown", handleKeyDown);
    });
    watch([() => store.currentFrame, visiblePropertyIds, mode], () => {
      drawGraph();
    });
    watch(animatableProperties, () => {
      fitToView();
      drawGraph();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$6, [
          _cache[9] || (_cache[9] = createBaseVNode("span", { class: "graph-title" }, "Graph Editor", -1)),
          createBaseVNode("div", _hoisted_3$6, [
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "value" }),
              onClick: _cache[0] || (_cache[0] = ($event) => mode.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "speed" }),
              onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          createBaseVNode("div", _hoisted_4$6, [
            (openBlock(), createElementBlock(Fragment, null, renderList(presetList, (preset) => {
              return createBaseVNode("button", {
                key: preset.key,
                class: normalizeClass(["preset-btn", { active: isPresetActive(preset.key) }]),
                onClick: ($event) => applyPreset(preset.key),
                title: preset.label
              }, toDisplayString(preset.shortLabel), 11, _hoisted_5$6);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_6$6, [
            createBaseVNode("button", {
              onClick: fitToView,
              title: "Fit to View"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("span", { class: "icon" }, "[ ]", -1)
            ])]),
            createBaseVNode("button", {
              onClick: toggleAutoSelect,
              class: normalizeClass({ active: autoSelectNearby.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("span", { class: "icon" }, "A", -1)
            ])], 2),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => snapEnabled.value = !snapEnabled.value),
              class: normalizeClass({ active: snapEnabled.value }),
              title: "Snap to Grid"
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          createBaseVNode("button", {
            class: "close-btn",
            onClick: _cache[3] || (_cache[3] = ($event) => emit("close"))
          }, [..._cache[8] || (_cache[8] = [
            createBaseVNode("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        createBaseVNode("div", _hoisted_7$6, [
          createBaseVNode("div", _hoisted_8$6, [
            createBaseVNode("div", _hoisted_9$6, [
              _cache[10] || (_cache[10] = createTextVNode(" Properties ", -1)),
              createBaseVNode("button", {
                class: "toggle-all-btn",
                onClick: toggleAllProperties,
                title: allPropertiesVisible.value ? "Hide All" : "Show All"
              }, toDisplayString(allPropertiesVisible.value ? "Hide" : "Show"), 9, _hoisted_10$6)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(animatableProperties.value, (prop) => {
              return openBlock(), createElementBlock("div", {
                key: prop.id,
                class: normalizeClass(["property-item", {
                  selected: selectedPropertyIds.value.includes(prop.id),
                  animated: prop.animated
                }])
              }, [
                createBaseVNode("div", {
                  class: "property-row",
                  onClick: ($event) => toggleProperty(prop.id)
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(["visibility-toggle", { visible: visiblePropertyIds.value.includes(prop.id) }]),
                    onClick: withModifiers(($event) => togglePropertyVisibility(prop.id), ["stop"])
                  }, null, 10, _hoisted_12$6),
                  createBaseVNode("span", {
                    class: "property-color",
                    style: normalizeStyle({ background: getPropertyColor(prop.id) })
                  }, null, 4),
                  createBaseVNode("span", _hoisted_13$6, toDisplayString(prop.name), 1),
                  prop.animated ? (openBlock(), createElementBlock("span", _hoisted_14$6, toDisplayString(prop.keyframes.length), 1)) : createCommentVNode("", true)
                ], 8, _hoisted_11$6),
                prop.name === "Position" || prop.name === "Scale" ? (openBlock(), createElementBlock("div", _hoisted_15$6, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(["x", "y", "z"], (dim) => {
                    return createBaseVNode("button", {
                      key: dim,
                      class: normalizeClass({
                        active: visibleDimensions.value[prop.id]?.includes(dim),
                        hasValue: hasDimension(prop, dim)
                      }),
                      onClick: ($event) => toggleDimension(prop.id, dim)
                    }, toDisplayString(dim.toUpperCase()), 11, _hoisted_16$6);
                  }), 64))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128)),
            animatableProperties.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_17$6, " No animated properties ")) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$6, [
            createBaseVNode("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: timeRulerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "timeRulerCanvas",
                ref: timeRulerCanvas,
                onClick: onTimeRulerClick
              }, null, 512)
            ], 512),
            createBaseVNode("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "canvasRef",
                ref: canvasRef,
                onMousedown: handleMouseDown,
                onMousemove: handleMouseMove,
                onMouseup: handleMouseUp,
                onMouseleave: handleMouseUp,
                onWheel: handleWheel,
                onContextmenu: withModifiers(showContextMenu, ["prevent"])
              }, null, 544),
              selectionBox.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "selection-box",
                style: normalizeStyle({
                  left: selectionBox.value.x + "px",
                  top: selectionBox.value.y + "px",
                  width: selectionBox.value.width + "px",
                  height: selectionBox.value.height + "px"
                })
              }, null, 4)) : createCommentVNode("", true),
              (openBlock(), createElementBlock("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleProperties.value, (prop) => {
                  return openBlock(), createElementBlock("g", {
                    key: prop.id,
                    class: "property-handles"
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(prop.keyframes, (kf, kfIndex) => {
                      return openBlock(), createElementBlock(Fragment, { key: kfIndex }, [
                        isKeyframeInView(kf) ? (openBlock(), createElementBlock("g", {
                          key: 0,
                          class: normalizeClass(["keyframe-marker", {
                            selected: isKeyframeSelected(prop.id, kfIndex),
                            hovered: hoveredKeyframe.value?.propId === prop.id && hoveredKeyframe.value?.index === kfIndex
                          }]),
                          onMousedown: withModifiers(($event) => onKeyframeMouseDown(prop.id, kfIndex, $event), ["stop"])
                        }, [
                          createBaseVNode("rect", {
                            x: getKeyframeScreenX(kf) - 5,
                            y: getKeyframeScreenY(prop, kf) - 5,
                            width: "10",
                            height: "10",
                            fill: getPropertyColor(prop.id),
                            "transform-origin": "center",
                            transform: `rotate(45, ${getKeyframeScreenX(kf)}, ${getKeyframeScreenY(prop, kf)})`
                          }, null, 8, _hoisted_21$6)
                        ], 42, _hoisted_20$6)) : createCommentVNode("", true),
                        isKeyframeSelected(prop.id, kfIndex) && kf.interpolation !== "hold" ? (openBlock(), createElementBlock("g", _hoisted_22$6, [
                          prop.keyframes[kfIndex + 1] && (kf.outHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_23$6, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getOutHandleX(prop, kfIndex),
                              y2: getOutHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_24$4),
                            createBaseVNode("circle", {
                              cx: getOutHandleX(prop, kfIndex),
                              cy: getOutHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "outHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("outHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_25$4)
                          ])) : createCommentVNode("", true),
                          kfIndex > 0 && (kf.inHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_26$4, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getInHandleX(prop, kfIndex),
                              y2: getInHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_27$4),
                            createBaseVNode("circle", {
                              cx: getInHandleX(prop, kfIndex),
                              cy: getInHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "inHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("inHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_28$4)
                          ])) : createCommentVNode("", true)
                        ])) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]);
                }), 128)),
                createBaseVNode("line", {
                  x1: currentFrameScreenX.value,
                  y1: 0,
                  x2: currentFrameScreenX.value,
                  y2: canvasHeight.value,
                  class: "current-time-line"
                }, null, 8, _hoisted_29$4)
              ], 8, _hoisted_19$6))
            ], 512),
            createBaseVNode("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: valueAxisRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "valueAxisCanvas",
                ref: valueAxisCanvas
              }, null, 512)
            ], 512)
          ])
        ]),
        selectedKeyframes.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$4, [
          createBaseVNode("div", _hoisted_31$2, [
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "info-label" }, "Frame:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: selectedKeyframes.value[0]?.keyframe.frame,
              onChange: updateSelectedKeyframeFrame,
              class: "info-input"
            }, null, 40, _hoisted_32$2)
          ]),
          createBaseVNode("div", _hoisted_33$2, [
            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "info-label" }, "Value:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: getKeyframeDisplayValue(selectedKeyframes.value[0]),
              onChange: updateSelectedKeyframeValue,
              class: "info-input",
              step: "0.1"
            }, null, 40, _hoisted_34$2)
          ]),
          createBaseVNode("div", _hoisted_35$2, [
            _cache[14] || (_cache[14] = createBaseVNode("span", { class: "info-label" }, "Interpolation:", -1)),
            createBaseVNode("select", {
              value: selectedKeyframes.value[0]?.keyframe.interpolation,
              onChange: updateSelectedKeyframeInterpolation,
              class: "info-select"
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "linear" }, "Linear", -1),
              createBaseVNode("option", { value: "bezier" }, "Bezier", -1),
              createBaseVNode("option", { value: "hold" }, "Hold", -1)
            ])], 40, _hoisted_36$2)
          ])
        ])) : createCommentVNode("", true),
        contextMenu.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "context-menu",
          style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
          onClick: _cache[4] || (_cache[4] = ($event) => contextMenu.value = null)
        }, [
          createBaseVNode("button", { onClick: addKeyframeAtPosition }, "Add Keyframe"),
          createBaseVNode("button", {
            onClick: deleteSelectedKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Delete Keyframe(s)", 8, _hoisted_37$2),
          _cache[15] || (_cache[15] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", {
            onClick: copyKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Copy", 8, _hoisted_38$1),
          createBaseVNode("button", {
            onClick: pasteKeyframes,
            disabled: !clipboard.value
          }, "Paste", 8, _hoisted_39$1),
          _cache[16] || (_cache[16] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", { onClick: selectAllKeyframes }, "Select All"),
          createBaseVNode("button", { onClick: invertSelection }, "Invert Selection")
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
});

const GraphEditor = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-70deec8d"]]);

// math-inlining.
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;

// cube root function yielding real roots
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}

// trig constants
const pi$1 = Math.PI,
  tau = 2 * pi$1,
  quart = pi$1 / 2,
  // float precision significant decimal
  epsilon = 0.000001,
  // extremas used in bbox calculation and similar algorithms
  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
  // a zero coordinate, which is surprisingly useful
  ZERO = { x: 0, y: 0, z: 0 };

// Bezier utility functions
const utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.0640568928626056260850430826247450385909,
    -0.1911188674736163,
    0.1911188674736163091586398207570696318404,
    -0.3150426796961634,
    0.3150426796961633743867932913198102407864,
    -0.4337935076260451,
    0.4337935076260451384870842319133497124524,
    -0.5454214713888396,
    0.5454214713888395356583756172183723700107,
    -0.6480936519369755,
    0.6480936519369755692524957869107476266696,
    -0.7401241915785544,
    0.7401241915785543642438281030999784255232,
    -0.820001985973903,
    0.8200019859739029219539498726697452080761,
    -0.8864155270044011,
    0.8864155270044010342131543419821967550873,
    -0.9382745520027328,
    0.9382745520027327585236490017087214496548,
    -0.9747285559713095,
    0.9747285559713094981983919930081690617411,
    -0.9951872199970213,
    0.9951872199970213601799974097007368118745,
  ],

  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.1279381953467521569740561652246953718517,
    0.1279381953467521569740561652246953718517,
    0.1258374563468282961213753825111836887264,
    0.1258374563468282961213753825111836887264,
    0.121670472927803391204463153476262425607,
    0.121670472927803391204463153476262425607,
    0.1155056680537256013533444839067835598622,
    0.1155056680537256013533444839067835598622,
    0.1074442701159656347825773424466062227946,
    0.1074442701159656347825773424466062227946,
    0.0976186521041138882698806644642471544279,
    0.0976186521041138882698806644642471544279,
    0.086190161531953275917185202983742667185,
    0.086190161531953275917185202983742667185,
    0.0733464814110803057340336152531165181193,
    0.0733464814110803057340336152531165181193,
    0.0592985849154367807463677585001085845412,
    0.0592985849154367807463677585001085845412,
    0.0442774388174198061686027482113382288593,
    0.0442774388174198061686027482113382288593,
    0.0285313886289336631813078159518782864491,
    0.0285313886289336631813078159518782864491,
    0.0123412297999871995468056670700372915759,
    0.0123412297999871995468056670700372915759,
  ],

  arcfn: function (t, derivativeFn) {
    const d = derivativeFn(t);
    let l = d.x * d.x + d.y * d.y;
    if (typeof d.z !== "undefined") {
      l += d.z * d.z;
    }
    return sqrt$1(l);
  },

  compute: function (t, points, _3d) {
    // shortcuts
    if (t === 0) {
      points[0].t = 0;
      return points[0];
    }

    const order = points.length - 1;

    if (t === 1) {
      points[order].t = 1;
      return points[order];
    }

    const mt = 1 - t;
    let p = points;

    // constant?
    if (order === 0) {
      points[0].t = t;
      return points[0];
    }

    // linear?
    if (order === 1) {
      const ret = {
        x: mt * p[0].x + t * p[1].x,
        y: mt * p[0].y + t * p[1].y,
        t: t,
      };
      if (_3d) {
        ret.z = mt * p[0].z + t * p[1].z;
      }
      return ret;
    }

    // quadratic/cubic curve?
    if (order < 4) {
      let mt2 = mt * mt,
        t2 = t * t,
        a,
        b,
        c,
        d = 0;
      if (order === 2) {
        p = [p[0], p[1], p[2], ZERO];
        a = mt2;
        b = mt * t * 2;
        c = t2;
      } else if (order === 3) {
        a = mt2 * mt;
        b = mt2 * t * 3;
        c = mt * t2 * 3;
        d = t * t2;
      }
      const ret = {
        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t,
      };
      if (_3d) {
        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
      }
      return ret;
    }

    // higher order curves: use de Casteljau's computation
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i = 0; i < dCpts.length - 1; i++) {
        dCpts[i] = {
          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,
        };
        if (typeof dCpts[i].z !== "undefined") {
          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t;
    return dCpts[0];
  },

  computeWithRatios: function (t, points, ratios, _3d) {
    const mt = 1 - t,
      r = ratios,
      p = points;

    let f1 = r[0],
      f2 = r[1],
      f3 = r[2],
      f4 = r[3],
      d;

    // spec for linear
    f1 *= mt;
    f2 *= t;

    if (p.length === 2) {
      d = f1 + f2;
      return {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
        t: t,
      };
    }

    // upgrade to quadratic
    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t * t;

    if (p.length === 3) {
      d = f1 + f2 + f3;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
        t: t,
      };
    }

    // upgrade to cubic
    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t * t * t;

    if (p.length === 4) {
      d = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: !_3d
          ? false
          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
        t: t,
      };
    }
  },

  derive: function (points, _3d) {
    const dpoints = [];
    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list = [];
      for (let j = 0, dpt; j < c; j++) {
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y),
        };
        if (_3d) {
          dpt.z = c * (p[j + 1].z - p[j].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p = list;
    }
    return dpoints;
  },

  between: function (v, m, M) {
    return (
      (m <= v && v <= M) ||
      utils.approximately(v, m) ||
      utils.approximately(v, M)
    );
  },

  approximately: function (a, b, precision) {
    return abs$1(a - b) <= (precision || epsilon);
  },

  length: function (derivativeFn) {
    const z = 0.5,
      len = utils.Tvalues.length;

    let sum = 0;

    for (let i = 0, t; i < len; i++) {
      t = z * utils.Tvalues[i] + z;
      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);
    }
    return z * sum;
  },

  map: function (v, ds, de, ts, te) {
    const d1 = de - ds,
      d2 = te - ts,
      v2 = v - ds,
      r = v2 / d1;
    return ts + d2 * r;
  },

  lerp: function (r, v1, v2) {
    const ret = {
      x: v1.x + r * (v2.x - v1.x),
      y: v1.y + r * (v2.y - v1.y),
    };
    if (v1.z !== undefined && v2.z !== undefined) {
      ret.z = v1.z + r * (v2.z - v1.z);
    }
    return ret;
  },

  pointToString: function (p) {
    let s = p.x + "/" + p.y;
    if (typeof p.z !== "undefined") {
      s += "/" + p.z;
    }
    return s;
  },

  pointsToString: function (points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },

  copy: function (obj) {
    return JSON.parse(JSON.stringify(obj));
  },

  angle: function (o, v1, v2) {
    const dx1 = v1.x - o.x,
      dy1 = v1.y - o.y,
      dx2 = v2.x - o.x,
      dy2 = v2.y - o.y,
      cross = dx1 * dy2 - dy1 * dx2,
      dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },

  // round as string, to avoid rounding errors
  round: function (v, d) {
    const s = "" + v;
    const pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },

  dist: function (p1, p2) {
    const dx = p1.x - p2.x,
      dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },

  closest: function (LUT, point) {
    let mdist = pow(2, 63),
      mpos,
      d;
    LUT.forEach(function (p, idx) {
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        mpos = idx;
      }
    });
    return { mdist: mdist, mpos: mpos };
  },

  abcratio: function (t, n) {
    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const bottom = pow(t, n) + pow(1 - t, n),
      top = bottom - 1;
    return abs$1(top / bottom);
  },

  projectionratio: function (t, n) {
    // see u(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const top = pow(1 - t, n),
      bottom = pow(t, n) + top;
    return top / bottom;
  },

  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx =
        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d == 0) {
      return false;
    }
    return { x: nx / d, y: ny / d };
  },

  lli4: function (p1, p2, p3, p4) {
    const x1 = p1.x,
      y1 = p1.y,
      x2 = p2.x,
      y2 = p2.y,
      x3 = p3.x,
      y3 = p3.y,
      x4 = p4.x,
      y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },

  lli: function (v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },

  makeline: function (p1, p2) {
    return new Bezier$1(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },

  findbbox: function (sections) {
    let mx = nMax,
      my = nMax,
      MX = nMin,
      MY = nMin;
    sections.forEach(function (s) {
      const bbox = s.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },
    };
  },

  shapeintersections: function (
    s1,
    bbox1,
    s2,
    bbox2,
    curveIntersectionThreshold
  ) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function (l1) {
      if (l1.virtual) return;
      a2.forEach(function (l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },

  makeshape: function (forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward: forward,
      back: back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end]),
    };
    shape.intersections = function (s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },

  getminmax: function (curve, d, list) {
    if (!list) return { min: 0, max: 0 };
    let min = nMax,
      max = nMin,
      t,
      c;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i = 0, len = list.length; i < len; i++) {
      t = list[i];
      c = curve.get(t);
      if (c[d] < min) {
        min = c[d];
      }
      if (c[d] > max) {
        max = c[d];
      }
    }
    return { min: min, mid: (min + max) / 2, max: max, size: max - min };
  },

  align: function (points, line) {
    const tx = line.p1.x,
      ty = line.p1.y,
      a = -atan2(line.p2.y - ty, line.p2.x - tx),
      d = function (v) {
        return {
          x: (v.x - tx) * cos$1(a) - (v.y - ty) * sin$1(a),
          y: (v.x - tx) * sin$1(a) + (v.y - ty) * cos$1(a),
        };
      };
    return points.map(d);
  },

  roots: function (points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };

    const order = points.length - 1;
    const aligned = utils.align(points, line);
    const reduce = function (t) {
      return 0 <= t && t <= 1;
    };

    if (order === 2) {
      const a = aligned[0].y,
        b = aligned[1].y,
        c = aligned[2].y,
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2].filter(reduce);
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);
      }
      return [];
    }

    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
    const pa = aligned[0].y,
      pb = aligned[1].y,
      pc = aligned[2].y,
      pd = aligned[3].y;

    let d = -pa + 3 * pb - 3 * pc + pd,
      a = 3 * pa - 6 * pb + 3 * pc,
      b = -3 * pa + 3 * pb,
      c = pa;

    if (utils.approximately(d, 0)) {
      // this is not a cubic curve.
      if (utils.approximately(a, 0)) {
        // in fact, this is not a quadratic curve either.
        if (utils.approximately(b, 0)) {
          // in fact in fact, there are no solutions.
          return [];
        }
        // linear solution:
        return [-c / b].filter(reduce);
      }
      // quadratic solution:
      const q = sqrt$1(b * b - 4 * a * c),
        a2 = 2 * a;
      return [(q - b) / a2, (-b - q) / a2].filter(reduce);
    }

    // at this point, we know we need a cubic solution:

    a /= d;
    b /= d;
    c /= d;

    const p = (3 * b - a * a) / 3,
      p3 = p / 3,
      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
      q2 = q / 2,
      discriminant = q2 * q2 + p3 * p3 * p3;

    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p / 3,
        mp33 = mp3 * mp3 * mp3,
        r = sqrt$1(mp33),
        t = -q / (2 * r),
        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
        phi = acos$1(cosphi),
        crtr = crt(r),
        t1 = 2 * crtr;
      x1 = t1 * cos$1(phi / 3) - a / 3;
      x2 = t1 * cos$1((phi + tau) / 3) - a / 3;
      x3 = t1 * cos$1((phi + 2 * tau) / 3) - a / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q2 < 0 ? crt(-q2) : -crt(q2);
      x1 = 2 * u1 - a / 3;
      x2 = -u1 - a / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt$1(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      return [u1 - v1 - a / 3].filter(reduce);
    }
  },

  droots: function (p) {
    // quadratic roots are easy
    if (p.length === 3) {
      const a = p[0],
        b = p[1],
        c = p[2],
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * (b - c))];
      }
      return [];
    }

    // linear roots are even easier
    if (p.length === 2) {
      const a = p[0],
        b = p[1];
      if (a !== b) {
        return [a / (a - b)];
      }
      return [];
    }

    return [];
  },

  curvature: function (t, d1, d2, _3d, kOnly) {
    let num,
      dnm,
      adk,
      dk,
      k = 0,
      r = 0;

    //
    // We're using the following formula for curvature:
    //
    //              x'y" - y'x"
    //   k(t) = ------------------
    //           (x' + y')^(3/2)
    //
    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
    //
    // With it corresponding 3D counterpart:
    //
    //          sqrt( (y'z" - y"z') + (z'x" - z"x') + (x'y" - x"y'))
    //   k(t) = -------------------------------------------------------
    //                     (x' + y' + z')^(3/2)
    //

    const d = utils.compute(t, d1);
    const dd = utils.compute(t, d2);
    const qdsum = d.x * d.x + d.y * d.y;

    if (_3d) {
      num = sqrt$1(
        pow(d.y * dd.z - dd.y * d.z, 2) +
          pow(d.z * dd.x - dd.z * d.x, 2) +
          pow(d.x * dd.y - dd.x * d.y, 2)
      );
      dnm = pow(qdsum + d.z * d.z, 3 / 2);
    } else {
      num = d.x * dd.y - d.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }

    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }

    k = num / dnm;
    r = dnm / num;

    // We're also computing the derivative of kappa, because
    // there is value in knowing the rate of change for the
    // curvature along the curve. And we're just going to
    // ballpark it based on an epsilon.
    if (!kOnly) {
      // compute k'(t) based on the interval before, and after it,
      // to at least try to not introduce forward/backward pass bias.
      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;
      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;
      dk = (nk - k + (k - pk)) / 2;
      adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }

    return { k: k, r: r, dk: dk, adk: adk };
  },

  inflections: function (points) {
    if (points.length < 4) return [];

    // FIXME: TODO: add in inflection abstraction for quartic+ curves?

    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
      a = p[2].x * p[1].y,
      b = p[3].x * p[1].y,
      c = p[1].x * p[2].y,
      d = p[3].x * p[2].y,
      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
      v2 = 18 * (3 * a - b - 3 * c),
      v3 = 18 * (c - a);

    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t = -v3 / v2;
        if (0 <= t && t <= 1) return [t];
      }
      return [];
    }

    const d2 = 2 * v1;

    if (utils.approximately(d2, 0)) return [];

    const trm = v2 * v2 - 4 * v1 * v3;

    if (trm < 0) return [];

    const sq = Math.sqrt(trm);

    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {
      return 0 <= r && r <= 1;
    });
  },

  bboxoverlap: function (b1, b2) {
    const dims = ["x", "y"],
      len = dims.length;

    for (let i = 0, dim, l, t, d; i < len; i++) {
      dim = dims[i];
      l = b1[dim].mid;
      t = b2[dim].mid;
      d = (b1[dim].size + b2[dim].size) / 2;
      if (abs$1(l - t) >= d) return false;
    }
    return true;
  },

  expandbox: function (bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },

  pairiteration: function (c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(),
      c2b = c2.bbox(),
      r = 100000,
      threshold = curveIntersectionThreshold || 0.5;

    if (
      c1b.x.size + c1b.y.size < threshold &&
      c2b.x.size + c2b.y.size < threshold
    ) {
      return [
        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +
          "/" +
          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,
      ];
    }

    let cc1 = c1.split(0.5),
      cc2 = c2.split(0.5),
      pairs = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left },
      ];

    pairs = pairs.filter(function (pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });

    let results = [];

    if (pairs.length === 0) return results;

    pairs.forEach(function (pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    });

    results = results.filter(function (v, i) {
      return results.indexOf(v) === i;
    });

    return results;
  },

  getccenter: function (p1, p2, p3) {
    const dx1 = p2.x - p1.x,
      dy1 = p2.y - p1.y,
      dx2 = p3.x - p2.x,
      dy2 = p3.y - p2.y,
      dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart),
      dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart),
      dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart),
      dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart),
      // chord midpoints
      mx1 = (p1.x + p2.x) / 2,
      my1 = (p1.y + p2.y) / 2,
      mx2 = (p2.x + p3.x) / 2,
      my2 = (p2.y + p3.y) / 2,
      // midpoint offsets
      mx1n = mx1 + dx1p,
      my1n = my1 + dy1p,
      mx2n = mx2 + dx2p,
      my2n = my2 + dy2p,
      // intersection of these lines:
      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
      r = utils.dist(arc, p1);

    // arc start/end values, over mid point:
    let s = atan2(p1.y - arc.y, p1.x - arc.x),
      m = atan2(p2.y - arc.y, p2.x - arc.x),
      e = atan2(p3.y - arc.y, p3.x - arc.x),
      _;

    // determine arc direction (cw/ccw correction)
    if (s < e) {
      // if s<m<e, arc(s, e)
      // if m<s<e, arc(e, s + tau)
      // if s<e<m, arc(e, s + tau)
      if (s > m || m > e) {
        s += tau;
      }
      if (s > e) {
        _ = e;
        e = s;
        s = _;
      }
    } else {
      // if e<m<s, arc(e, s)
      // if m<e<s, arc(s, e + tau)
      // if e<s<m, arc(s, e + tau)
      if (e < m && m < s) {
        _ = e;
        e = s;
        s = _;
      } else {
        e += tau;
      }
    }
    // assign and done.
    arc.s = s;
    arc.e = e;
    arc.r = r;
    return arc;
  },

  numberSort: function (a, b) {
    return a - b;
  },
};

/**
 * Poly Bezier
 * @param {[type]} curves [description]
 */
class PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return (
      "[" +
      this.curves
        .map(function (curve) {
          return utils.pointsToString(curve.points);
        })
        .join(", ") +
      "]"
    );
  }

  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }

  length() {
    return this.curves
      .map(function (v) {
        return v.length();
      })
      .reduce(function (a, b) {
        return a + b;
      });
  }

  curve(idx) {
    return this.curves[idx];
  }

  bbox() {
    const c = this.curves;
    var bbox = c[0].bbox();
    for (var i = 1; i < c.length; i++) {
      utils.expandbox(bbox, c[i].bbox());
    }
    return bbox;
  }

  offset(d) {
    const offset = [];
    this.curves.forEach(function (v) {
      offset.push(...v.offset(d));
    });
    return new PolyBezier(offset);
  }
}

/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/


// math-inlining.
const { abs, min, max, cos, sin, acos, sqrt } = Math;
const pi = Math.PI;

/**
 * Bezier curve constructor.
 *
 * ...docs pending...
 */
let Bezier$1 = class Bezier {
  constructor(coords) {
    let args =
      coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;

    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function (point) {
        ["x", "y", "z"].forEach(function (d) {
          if (typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }

    let higher = false;
    const len = args.length;

    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }

    const _3d = (this._3d =
      (!higher && (len === 9 || len === 12)) ||
      (coords && coords[0] && typeof coords[0].z !== "undefined"));

    const points = (this.points = []);
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1],
      };
      if (_3d) {
        point.z = args[idx + 2];
      }
      points.push(point);
    }
    const order = (this.order = points.length - 1);

    const dims = (this.dims = ["x", "y"]);
    if (_3d) dims.push("z");
    this.dimlen = dims.length;

    // is this curve, practically speaking, a straight line?
    const aligned = utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;

    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }

  static quadraticFromPoints(p1, p2, p3, t) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    // shortcuts, although they're really dumb
    if (t === 0) {
      return new Bezier(p2, p2, p3);
    }
    if (t === 1) {
      return new Bezier(p1, p2, p2);
    }
    // real fitting.
    const abc = Bezier.getABC(2, p1, p2, p3, t);
    return new Bezier(p1, abc.A, p3);
  }

  static cubicFromPoints(S, B, E, t, d1) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    const abc = Bezier.getABC(3, S, B, E, t);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B, abc.C);
    }
    const d2 = (d1 * (1 - t)) / t;

    const selen = utils.dist(S, E),
      lx = (E.x - S.x) / selen,
      ly = (E.y - S.y) / selen,
      bx1 = d1 * lx,
      by1 = d1 * ly,
      bx2 = d2 * lx,
      by2 = d2 * ly;
    // derivation of new hull coordinates
    const e1 = { x: B.x - bx1, y: B.y - by1 },
      e2 = { x: B.x + bx2, y: B.y + by2 },
      A = abc.A,
      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },
      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },
      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },
      nc2 = {
        x: E.x + (v2.x - E.x) / (1 - t),
        y: E.y + (v2.y - E.y) / (1 - t),
      };
    // ...done
    return new Bezier(S, nc1, nc2, E);
  }

  static getUtils() {
    return utils;
  }

  getUtils() {
    return Bezier.getUtils();
  }

  static get PolyBezier() {
    return PolyBezier;
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return utils.pointsToString(this.points);
  }

  toSVG() {
    if (this._3d) return false;
    const p = this.points,
      x = p[0].x,
      y = p[0].y,
      s = ["M", x, y, this.order === 2 ? "Q" : "C"];
    for (let i = 1, last = p.length; i < last; i++) {
      s.push(p[i].x);
      s.push(p[i].y);
    }
    return s.join(" ");
  }

  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = []; //  invalidate any precomputed LUT
  }

  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }

  coordDigest() {
    return this.points
      .map(function (c, pos) {
        return "" + pos + c.x + c.y + (c.z ? c.z : 0);
      })
      .join("");
  }

  update() {
    // invalidate any precomputed LUT
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }

  computedirection() {
    const points = this.points;
    const angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }

  length() {
    return utils.length(this.derivative.bind(this));
  }

  static getABC(order = 2, S, B, E, t = 0.5) {
    const u = utils.projectionratio(t, order),
      um = 1 - u,
      C = {
        x: u * S.x + um * E.x,
        y: u * S.y + um * E.y,
      },
      s = utils.abcratio(t, order),
      A = {
        x: B.x + (B.x - C.x) / s,
        y: B.y + (B.y - C.y) / s,
      };
    return { A, B, C, S, E };
  }

  getABC(t, B) {
    B = B || this.get(t);
    let S = this.points[0];
    let E = this.points[this.order];
    return Bezier.getABC(this.order, S, B, E, t);
  }

  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) {
      return this._lut;
    }
    this._lut = [];
    // n steps means n+1 points
    steps++;
    this._lut = [];
    for (let i = 0, p, t; i < steps; i++) {
      t = i / (steps - 1);
      p = this.compute(t);
      p.t = t;
      this._lut.push(p);
    }
    return this._lut;
  }

  on(point, error) {
    error = error || 5;
    const lut = this.getLUT(),
      hits = [];
    for (let i = 0, c, t = 0; i < lut.length; i++) {
      c = lut[i];
      if (utils.dist(c, point) < error) {
        hits.push(c);
        t += i / lut.length;
      }
    }
    if (!hits.length) return false;
    return (t /= hits.length);
  }

  project(point) {
    // step 1: coarse check
    const LUT = this.getLUT(),
      l = LUT.length - 1,
      closest = utils.closest(LUT, point),
      mpos = closest.mpos,
      t1 = (mpos - 1) / l,
      t2 = (mpos + 1) / l,
      step = 0.1 / l;

    // step 2: fine check
    let mdist = closest.mdist,
      t = t1,
      ft = t,
      p;
    mdist += 1;
    for (let d; t < t2 + step; t += step) {
      p = this.compute(t);
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        ft = t;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p = this.compute(ft);
    p.t = ft;
    p.d = mdist;
    return p;
  }

  get(t) {
    return this.compute(t);
  }

  point(idx) {
    return this.points[idx];
  }

  compute(t) {
    if (this.ratios) {
      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);
    }
    return utils.compute(t, this.points, this._3d, this.ratios);
  }

  raise() {
    const p = this.points,
      np = [p[0]],
      k = p.length;
    for (let i = 1, pi, pim; i < k; i++) {
      pi = p[i];
      pim = p[i - 1];
      np[i] = {
        x: ((k - i) / k) * pi.x + (i / k) * pim.x,
        y: ((k - i) / k) * pi.y + (i / k) * pim.y,
      };
    }
    np[k] = p[k - 1];
    return new Bezier(np);
  }

  derivative(t) {
    return utils.compute(t, this.dpoints[0], this._3d);
  }

  dderivative(t) {
    return utils.compute(t, this.dpoints[1], this._3d);
  }

  align() {
    let p = this.points;
    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
  }

  curvature(t) {
    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);
  }

  inflections() {
    return utils.inflections(this.points);
  }

  normal(t) {
    return this._3d ? this.__normal3(t) : this.__normal2(t);
  }

  __normal2(t) {
    const d = this.derivative(t);
    const q = sqrt(d.x * d.x + d.y * d.y);
    return { t, x: -d.y / q, y: d.x / q };
  }

  __normal3(t) {
    // see http://stackoverflow.com/questions/25453159
    const r1 = this.derivative(t),
      r2 = this.derivative(t + 0.01),
      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    // cross product
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x,
    };
    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m;
    c.y /= m;
    c.z /= m;
    // rotation matrix
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z,
    ];
    // normal vector:
    const n = {
      t,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,
    };
    return n;
  }

  hull(t) {
    let p = this.points,
      _p = [],
      q = [],
      idx = 0;
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];
    if (this.order === 3) {
      q[idx++] = p[3];
    }
    // we lerp between all points at each iteration, until we have 1 point left.
    while (p.length > 1) {
      _p = [];
      for (let i = 0, pt, l = p.length - 1; i < l; i++) {
        pt = utils.lerp(t, p[i], p[i + 1]);
        q[idx++] = pt;
        _p.push(pt);
      }
      p = _p;
    }
    return q;
  }

  split(t1, t2) {
    // shortcuts
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }
    if (t2 === 1) {
      return this.split(t1).right;
    }

    // no shortcut: use "de Casteljau" iteration.
    const q = this.hull(t1);
    const result = {
      left:
        this.order === 2
          ? new Bezier([q[0], q[3], q[5]])
          : new Bezier([q[0], q[4], q[7], q[9]]),
      right:
        this.order === 2
          ? new Bezier([q[5], q[4], q[2]])
          : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q,
    };

    // make sure we bind _t1/_t2 information!
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);

    // if we have no t2, we're done
    if (!t2) {
      return result;
    }

    // if we have a t2, split again:
    t2 = utils.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }

  extrema() {
    const result = {};
    let roots = [];

    this.dims.forEach(
      function (dim) {
        let mfn = function (v) {
          return v[dim];
        };
        let p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if (this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function (t) {
          return t >= 0 && t <= 1;
        });
        roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    );

    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {
      return roots.indexOf(v) === idx;
    });

    return result;
  }

  bbox() {
    const extrema = this.extrema(),
      result = {};
    this.dims.forEach(
      function (d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this)
    );
    return result;
  }

  overlaps(curve) {
    const lbbox = this.bbox(),
      tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }

  offset(t, d) {
    if (typeof d !== "undefined") {
      const c = this.get(t),
        n = this.normal(t);
      const ret = {
        c: c,
        n: n,
        x: c.x + n.x * d,
        y: c.y + n.y * d,
      };
      if (this._3d) {
        ret.z = c.z + n.z * d;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0),
        coords = this.points.map(function (p) {
          const ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y,
          };
          if (p.z && nv.z) {
            ret.z = p.z + t * nv.z;
          }
          return ret;
        });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function (s) {
      if (s._linear) {
        return s.offset(t)[0];
      }
      return s.scale(t);
    });
  }

  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s += n1.z * n2.z;
    }
    return abs(acos(s)) < pi / 3;
  }

  reduce() {
    // TODO: examine these var types in more detail...
    let i,
      t1 = 0,
      t2 = 0,
      step = 0.01,
      segment,
      pass1 = [],
      pass2 = [];
    // first pass: split on extrema
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }

    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
      t2 = extrema[i];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    }

    // second pass: further reduce these segments to simple segments
    pass1.forEach(function (p1) {
      t1 = 0;
      t2 = 0;
      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);
          if (!segment.simple()) {
            t2 -= step;
            if (abs(t1 - t2) < step) {
              // we can never form a reduction
              return [];
            }
            segment = p1.split(t1, t2);
            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }

  translate(v, d1, d2) {
    d2 = typeof d2 === "number" ? d2 : d1;

    // TODO: make this take curves with control points outside
    //       of the start-end interval into account

    const o = this.order;
    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);
    return new Bezier(
      this.points.map((p, i) => ({
        x: p.x + v.x * d[i],
        y: p.y + v.y * d[i],
      }))
    );
  }

  scale(d) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d === "function") {
      distanceFn = d;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }

    // TODO: add special handling for non-linear degenerate curves.

    const clockwise = this.clockwise;
    const points = this.points;

    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d,
        distanceFn ? distanceFn(1) : d
      );
    }

    const r1 = distanceFn ? distanceFn(0) : d;
    const r2 = distanceFn ? distanceFn(1) : d;
    const v = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);

    if (!o) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }

    // move all points by distance 'd' wrt the origin 'o',
    // and move end points by fixed distance along normal.
    [0, 1].forEach(function (t) {
      const p = (np[t * order] = utils.copy(points[t * order]));
      p.x += (t ? r2 : r1) * v[t].n.x;
      p.y += (t ? r2 : r1) * v[t].n.y;
    });

    if (!distanceFn) {
      // move control points to lie on the intersection of the offset
      // derivative vector, and the origin-through-control vector
      [0, 1].forEach((t) => {
        if (order === 2 && !!t) return;
        const p = np[t * order];
        const d = this.derivative(t);
        const p2 = { x: p.x + d.x, y: p.y + d.y };
        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);
      });
      return new Bezier(np);
    }

    // move control points by "however much necessary to
    // ensure the correct tangent to endpoint".
    [0, 1].forEach(function (t) {
      if (order === 2 && !!t) return;
      var p = points[t + 1];
      var ov = {
        x: p.x - o.x,
        y: p.y - o.y,
      };
      var rc = distanceFn ? distanceFn((t + 1) / order) : d;
      if (distanceFn && !clockwise) rc = -rc;
      var m = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m;
      ov.y /= m;
      np[t + 1] = {
        x: p.x + rc * ov.x,
        y: p.y + rc * ov.y,
      };
    });
    return new Bezier(np);
  }

  outline(d1, d2, d3, d4) {
    d2 = d2 === undefined ? d1 : d2;

    if (this._linear) {
      // TODO: find the actual extrema, because they might
      //       be before the start, or past the end.

      const n = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s, mid, e;

      if (d3 === undefined) {
        d3 = d1;
        d4 = d2;
      }

      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };
      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const fline = [s, mid, e];

      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };
      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const bline = [e, mid, s];

      const ls = utils.makeline(bline[2], fline[0]);
      const le = utils.makeline(fline[2], bline[0]);
      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];
      return new PolyBezier(segments);
    }

    const reduced = this.reduce(),
      len = reduced.length,
      fcurves = [];

    let bcurves = [],
      p,
      alen = 0,
      tlen = this.length();

    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

    function linearDistanceFunction(s, e, tlen, alen, slen) {
      return function (v) {
        const f1 = alen / tlen,
          f2 = (alen + slen) / tlen,
          d = e - s;
        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    }

    // form curve oulines
    reduced.forEach(function (segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }
      alen += slen;
    });

    // reverse the "return" outline
    bcurves = bcurves
      .map(function (s) {
        p = s.points;
        if (p[3]) {
          s.points = [p[3], p[2], p[1], p[0]];
        } else {
          s.points = [p[2], p[1], p[0]];
        }
        return s;
      })
      .reverse();

    // form the endcaps as lines
    const fs = fcurves[0].points[0],
      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
      be = bcurves[0].points[0],
      ls = utils.makeline(bs, fs),
      le = utils.makeline(fe, be),
      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);

    return new PolyBezier(segments);
  }

  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];
    for (let i = 1, len = outline.length; i < len / 2; i++) {
      const shape = utils.makeshape(
        outline[i],
        outline[len - i],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i > 1;
      shape.endcap.virtual = i < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }

  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }

  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x),
      my = min(line.p1.y, line.p2.y),
      MX = max(line.p1.x, line.p2.x),
      MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t) => {
      var p = this.get(t);
      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
    });
  }

  selfintersects(curveIntersectionThreshold) {
    // "simple" curves cannot intersect with their direct
    // neighbour, so for each segment X we check whether
    // it intersects [0:x-2][x+2:last].

    const reduced = this.reduce(),
      len = reduced.length - 2,
      results = [];

    for (let i = 0, result, left, right; i < len; i++) {
      left = reduced.slice(i, i + 1);
      right = reduced.slice(i + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }

  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    // step 1: pair off any overlapping segments
    c1.forEach(function (l) {
      c2.forEach(function (r) {
        if (l.overlaps(r)) {
          pairs.push({ left: l, right: r });
        }
      });
    });
    // step 2: for each pairing, run through the convergence algorithm.
    let intersections = [];
    pairs.forEach(function (pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }

  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }

  _error(pc, np1, s, e) {
    const q = (e - s) / 4,
      c1 = this.get(s + q),
      c2 = this.get(e - q),
      ref = utils.dist(pc, np1),
      d1 = utils.dist(pc, c1),
      d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }

  _iterate(errorThreshold, circles) {
    let t_s = 0,
      t_e = 1,
      safety;
    // we do a binary search to find the "good `t` closest to no-longer-good"
    do {
      safety = 0;

      // step 1: start with the maximum possible arc
      t_e = 1;

      // points:
      let np1 = this.get(t_s),
        np2,
        np3,
        arc,
        prev_arc;

      // booleans:
      let curr_good = false,
        prev_good = false,
        done;

      // numbers:
      let t_m = t_e,
        prev_e = 1;

      // step 2: find the best possible arc
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;

        np2 = this.get(t_m);
        np3 = this.get(t_e);

        arc = utils.getccenter(np1, np2, np3);

        //also save the t values
        arc.interval = {
          start: t_s,
          end: t_e,
        };

        let error = this._error(arc, np1, t_s, t_e);
        curr_good = error <= errorThreshold;

        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;

        // this arc is fine: we can move 'e' up to see if we can find a wider arc
        if (curr_good) {
          // if e is already at max, then we're done for this arc.
          if (t_e >= 1) {
            // make sure we cap at t=1
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            // if we capped the arc segment to t=1 we also need to make sure that
            // the arc's end angle is correct with respect to the bezier end point.
            if (t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e),
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
            }
            break;
          }
          // if not, move it up by half the iteration distance
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          // this is a bad arc: we need to move 'e' down to find a good arc
          t_e = t_m;
        }
      } while (!done && safety++ < 100);

      if (safety >= 100) {
        break;
      }

      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
};

const BezierModule = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Bezier: Bezier$1
}, Symbol.toStringTag, { value: 'Module' }));

const Bezier = BezierModule;
class ArcLengthParameterizer {
  curve;
  lut;
  totalLength;
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(curve, resolution = 1e3) {
    this.curve = curve;
    this.lut = [];
    this.totalLength = 0;
    this.buildLUT(resolution);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(resolution) {
    let accumulatedLength = 0;
    let prevPoint = this.curve.get(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.get(t);
      if (i > 0) {
        const dx = point.x - prevPoint.x;
        const dy = point.y - prevPoint.y;
        accumulatedLength += Math.sqrt(dx * dx + dy * dy);
      }
      this.lut.push({
        t,
        length: accumulatedLength
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.lut.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.lut[mid].length < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.lut[low];
    const prevEntry = this.lut[Math.max(0, low - 1)];
    if (entry.length === prevEntry.length) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.length) / (entry.length - prevEntry.length);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    return {
      point: this.curve.get(t),
      tangent: this.curve.derivative(t),
      t
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(count) {
    const points = [];
    const spacing = this.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.getPointAtDistance(distance));
    }
    return points;
  }
}
function pathCommandsToBezier(pathCommands) {
  if (!pathCommands || pathCommands.length < 2) {
    return null;
  }
  let startPoint = null;
  for (const cmd of pathCommands) {
    const [command, ...coords] = cmd;
    if (command === "M") {
      startPoint = { x: coords[0], y: coords[1] };
    } else if (command === "C" && startPoint) {
      return new Bezier(
        startPoint.x,
        startPoint.y,
        coords[0],
        coords[1],
        // control point 1
        coords[2],
        coords[3],
        // control point 2
        coords[4],
        coords[5]
        // end point
      );
    } else if (command === "Q" && startPoint) {
      return new Bezier(
        startPoint.x,
        startPoint.y,
        coords[0],
        coords[1],
        // control point
        coords[2],
        coords[3]
        // end point
      );
    }
  }
  return null;
}

class MatteExporter {
  offscreenCanvas = null;
  ctx = null;
  particleSystems = /* @__PURE__ */ new Map();
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(width, height) {
    const correctedWidth = Math.round(width / 8) * 8;
    const correctedHeight = Math.round(height / 8) * 8;
    const finalWidth = Math.max(256, correctedWidth);
    const finalHeight = Math.max(256, correctedHeight);
    const valid = width === finalWidth && height === finalHeight;
    return {
      valid,
      correctedWidth: finalWidth,
      correctedHeight: finalHeight,
      message: valid ? void 0 : `Adjusted to ${finalWidth}x${finalHeight} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(project, options, onProgress) {
    const { frameCount } = project.composition;
    const { width, height } = options;
    this.offscreenCanvas = new OffscreenCanvas(width, height);
    this.ctx = this.offscreenCanvas.getContext("2d");
    this.initializeParticleSystems(project);
    const frames = [];
    for (let frame = 0; frame < frameCount; frame++) {
      if (onProgress) {
        onProgress({
          frame,
          total: frameCount,
          percent: Math.round(frame / frameCount * 100)
        });
      }
      this.stepParticleSystemsToFrame(project, frame);
      const frameBlob = await this.generateFrame(project, frame, options);
      frames.push(frameBlob);
    }
    this.particleSystems.clear();
    if (onProgress) {
      onProgress({
        frame: frameCount,
        total: frameCount,
        percent: 100
      });
    }
    return frames;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(project, frame, options) {
    const ctx = this.ctx;
    const { width, height } = options;
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    if (options.matteMode === "include_all") {
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    }
    ctx.fillStyle = "#000000";
    const scaleX = width / project.composition.width;
    const scaleY = height / project.composition.height;
    const textLayers = project.layers.filter(
      (layer) => layer.type === "text" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of textLayers) {
      await this.renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY);
    }
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of particleLayers) {
      this.renderParticleLayerToMatte(ctx, layer, width, height);
    }
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(project, frame, options) {
    if (!this.offscreenCanvas || this.offscreenCanvas.width !== options.width || this.offscreenCanvas.height !== options.height) {
      this.offscreenCanvas = new OffscreenCanvas(options.width, options.height);
      this.ctx = this.offscreenCanvas.getContext("2d");
    }
    const blob = await this.generateFrame(project, frame, options);
    return URL.createObjectURL(blob);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY) {
    const textData = layer.data;
    if (!textData) return;
    const fontSizeProp = layer.properties.find((p) => p.name === "fontSize");
    const fontSize = fontSizeProp ? interpolateProperty(fontSizeProp, frame) : textData.fontSize;
    const scaledFontSize = fontSize * Math.min(scaleX, scaleY);
    ctx.font = `${textData.fontWeight} ${scaledFontSize}px "${textData.fontFamily}"`;
    if (textData.pathLayerId) {
      await this.renderTextOnPathToMatte(ctx, layer, textData, project, frame, scaledFontSize, scaleX, scaleY);
    } else {
      this.renderTextBlockToMatte(ctx, layer, textData, frame, scaledFontSize, scaleX, scaleY);
    }
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(ctx, layer, textData, project, frame, fontSize, scaleX, scaleY) {
    const pathLayer = project.layers.find((l) => l.id === textData.pathLayerId);
    if (!pathLayer || pathLayer.type !== "spline") return;
    const splineData = pathLayer.data;
    if (!splineData?.controlPoints || splineData.controlPoints.length < 2) return;
    const pathCommands = this.buildPathCommands(splineData);
    if (!pathCommands || pathCommands.length < 2) return;
    const bezierCurve = pathCommandsToBezier(pathCommands);
    if (!bezierCurve) return;
    const parameterizer = new ArcLengthParameterizer(bezierCurve);
    const offsetProp = layer.properties.find((p) => p.name === "pathOffset");
    const pathOffset = offsetProp ? interpolateProperty(offsetProp, frame) : textData.pathOffset;
    const totalLength = parameterizer.totalLength;
    let currentDistance = pathOffset * totalLength;
    const padding = 4 * Math.min(scaleX, scaleY);
    for (const char of textData.text) {
      if (char === " ") {
        const spaceWidth = ctx.measureText(" ").width;
        currentDistance += spaceWidth + textData.letterSpacing;
        continue;
      }
      const charWidth = ctx.measureText(char).width;
      const clampedDistance = Math.max(0, Math.min(currentDistance, totalLength));
      const { point, tangent } = parameterizer.getPointAtDistance(clampedDistance);
      const angle = Math.atan2(tangent.y, tangent.x);
      const scaledX = point.x * scaleX;
      const scaledY = point.y * scaleY;
      ctx.save();
      ctx.translate(scaledX, scaledY);
      ctx.rotate(angle);
      ctx.fillRect(
        -padding,
        -fontSize - padding,
        charWidth + padding * 2,
        fontSize + padding * 2
      );
      ctx.restore();
      currentDistance += charWidth + textData.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(splineData) {
    const cp = splineData.controlPoints;
    if (!cp || cp.length < 2) return null;
    const pathCommands = [];
    pathCommands.push(["M", cp[0].x, cp[0].y]);
    for (let i = 0; i < cp.length - 1; i++) {
      const p1 = cp[i];
      const p2 = cp[i + 1];
      const h1 = p1.handleOut || { x: p1.x, y: p1.y };
      const h2 = p2.handleIn || { x: p2.x, y: p2.y };
      pathCommands.push([
        "C",
        h1.x,
        h1.y,
        h2.x,
        h2.y,
        p2.x,
        p2.y
      ]);
    }
    return pathCommands;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(ctx, layer, textData, frame, fontSize, scaleX, scaleY) {
    const positionProp = layer.transform.position;
    const position = interpolateProperty(positionProp, frame);
    const rotationProp = layer.transform.rotation;
    const rotation = interpolateProperty(rotationProp, frame);
    const scaleProp = layer.transform.scale;
    const scale = interpolateProperty(scaleProp, frame);
    ctx.save();
    ctx.translate(position.x * scaleX, position.y * scaleY);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scale.x, scale.y);
    const metrics = ctx.measureText(textData.text);
    const textWidth = metrics.width;
    const textHeight = fontSize;
    const padding = 4;
    ctx.fillRect(
      -padding,
      -textHeight - padding,
      textWidth + padding * 2,
      textHeight + padding * 2
    );
    ctx.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(frames, filename = "matte_sequence", onProgress) {
    const JSZip = (await Promise.resolve().then(() => jszip_min)).default;
    const zip = new JSZip();
    frames.forEach((blob, index) => {
      const frameName = `${filename}_${String(index).padStart(4, "0")}.png`;
      zip.file(frameName, blob);
    });
    const content = await zip.generateAsync(
      { type: "blob" },
      (metadata) => {
        if (onProgress) {
          onProgress(Math.round(metadata.percent));
        }
      }
    );
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${filename}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(project) {
    this.particleSystems.clear();
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles"
    );
    for (const layer of particleLayers) {
      const data = layer.data;
      if (!data) continue;
      const system = new ParticleSystem(data.systemConfig);
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
      const warmupFrames = data.systemConfig.warmupPeriod || 0;
      for (let i = 0; i < warmupFrames; i++) {
        system.step();
      }
      this.particleSystems.set(layer.id, system);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(project, frame) {
    if (frame === 0) return;
    for (const layer of project.layers) {
      if (layer.type !== "particles") continue;
      const system = this.particleSystems.get(layer.id);
      if (!system) continue;
      if (layer.visible && frame >= layer.inPoint && frame <= layer.outPoint) {
        system.step();
      }
    }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(ctx, layer, width, height) {
    const system = this.particleSystems.get(layer.id);
    if (!system) return;
    const maskData = system.renderToMask(width, height);
    const tempCanvas = new OffscreenCanvas(width, height);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.putImageData(maskData, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null;
    this.ctx = null;
    this.particleSystems.clear();
  }
}
const matteExporter = new MatteExporter();

const _hoisted_1$5 = { class: "export-dialog" };
const _hoisted_2$5 = { class: "dialog-header" };
const _hoisted_3$5 = { class: "dialog-content" };
const _hoisted_4$5 = { class: "form-group" };
const _hoisted_5$5 = { class: "resolution-presets" };
const _hoisted_6$5 = ["onClick"];
const _hoisted_7$5 = { class: "custom-resolution" };
const _hoisted_8$5 = { class: "dimension-input" };
const _hoisted_9$5 = { class: "dimension-input" };
const _hoisted_10$5 = {
  key: 0,
  class: "dimension-warning"
};
const _hoisted_11$5 = { class: "form-group" };
const _hoisted_12$5 = { class: "matte-mode-options" };
const _hoisted_13$5 = { class: "form-group" };
const _hoisted_14$5 = { class: "preview-container" };
const _hoisted_15$5 = ["src"];
const _hoisted_16$5 = {
  key: 1,
  class: "preview-placeholder"
};
const _hoisted_17$5 = {
  key: 0,
  class: "progress-section"
};
const _hoisted_18$5 = { class: "progress-bar" };
const _hoisted_19$5 = { class: "progress-text" };
const _hoisted_20$5 = { class: "dialog-footer" };
const _hoisted_21$5 = { class: "export-info" };
const _hoisted_22$5 = ["disabled"];
const _hoisted_23$5 = ["disabled"];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const resolutionPresets = matteExporter.getResolutionPresets();
    const selectedPreset = ref("720p (1280x720)");
    const customWidth = ref(1280);
    const customHeight = ref(720);
    const dimensionWarning = ref();
    const matteMode = ref("exclude_text");
    const previewUrl = ref(null);
    const isExporting = ref(false);
    const exportProgress = ref(0);
    const progressMessage = ref("");
    const exportWidth = computed(() => customWidth.value);
    const exportHeight = computed(() => customHeight.value);
    function selectPreset(preset) {
      selectedPreset.value = preset.label;
      customWidth.value = preset.width;
      customHeight.value = preset.height;
      dimensionWarning.value = void 0;
    }
    function validateCustomDimensions() {
      const validation = matteExporter.validateDimensions(customWidth.value, customHeight.value);
      if (!validation.valid) {
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        dimensionWarning.value = validation.message;
        selectedPreset.value = "";
      } else {
        dimensionWarning.value = void 0;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
      }
    }
    async function generatePreview() {
      if (!store.hasProject) return;
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
        previewUrl.value = null;
      }
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      previewUrl.value = await matteExporter.generatePreviewFrame(
        store.project,
        0,
        options
      );
    }
    async function startExport() {
      if (isExporting.value || !store.hasProject) return;
      isExporting.value = true;
      exportProgress.value = 0;
      progressMessage.value = "Generating frames...";
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      try {
        const frames = await matteExporter.generateMatteSequence(
          store.project,
          options,
          (progress) => {
            exportProgress.value = progress.percent;
            progressMessage.value = `Generating frame ${progress.frame + 1} of ${progress.total}...`;
          }
        );
        progressMessage.value = "Creating ZIP archive...";
        await matteExporter.downloadAsZip(
          frames,
          `matte_${Date.now()}`,
          (percent) => {
            progressMessage.value = `Compressing... ${percent}%`;
          }
        );
        progressMessage.value = "Export complete!";
        emit("exported");
        setTimeout(() => {
          emit("close");
        }, 1e3);
      } catch (err) {
        console.error("[ExportDialog] Export failed:", err);
        progressMessage.value = `Export failed: ${err instanceof Error ? err.message : "Unknown error"}`;
      } finally {
        isExporting.value = false;
      }
    }
    watch(
      [exportWidth, exportHeight, matteMode],
      () => {
        generatePreview();
      },
      { immediate: false }
    );
    onMounted(() => {
      if (store.hasProject) {
        const validation = matteExporter.validateDimensions(store.width, store.height);
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
        if (!validation.valid) {
          dimensionWarning.value = validation.message;
        }
      }
      generatePreview();
    });
    onUnmounted(() => {
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
      }
      matteExporter.dispose();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$5, [
          createBaseVNode("div", _hoisted_2$5, [
            _cache[8] || (_cache[8] = createBaseVNode("h3", null, "Export Matte Sequence", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_3$5, [
            createBaseVNode("div", _hoisted_4$5, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Resolution", -1)),
              createBaseVNode("div", _hoisted_5$5, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(resolutionPresets), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.label,
                    class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.label }]),
                    onClick: ($event) => selectPreset(preset)
                  }, toDisplayString(preset.label), 11, _hoisted_6$5);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_7$5, [
                createBaseVNode("div", _hoisted_8$5, [
                  _cache[9] || (_cache[9] = createBaseVNode("label", null, "Width", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => customWidth.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customWidth.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                _cache[11] || (_cache[11] = createBaseVNode("span", { class: "dimension-x" }, "", -1)),
                createBaseVNode("div", _hoisted_9$5, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", null, "Height", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customHeight.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customHeight.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ])
              ]),
              dimensionWarning.value ? (openBlock(), createElementBlock("p", _hoisted_10$5, [
                _cache[12] || (_cache[12] = createBaseVNode("i", { class: "pi pi-info-circle" }, null, -1)),
                createTextVNode(" " + toDisplayString(dimensionWarning.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_11$5, [
              _cache[16] || (_cache[16] = createBaseVNode("label", null, "Matte Mode", -1)),
              createBaseVNode("div", _hoisted_12$5, [
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "exclude_text" }]),
                  onClick: _cache[3] || (_cache[3] = ($event) => matteMode.value = "exclude_text")
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("i", { class: "pi pi-ban" }, null, -1),
                  createBaseVNode("span", null, "Exclude Text", -1),
                  createBaseVNode("small", null, "Text regions are BLACK (excluded from generation)", -1)
                ])], 2),
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "include_all" }]),
                  onClick: _cache[4] || (_cache[4] = ($event) => matteMode.value = "include_all")
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("i", { class: "pi pi-check-circle" }, null, -1),
                  createBaseVNode("span", null, "Include All", -1),
                  createBaseVNode("small", null, "Entire frame is WHITE (generate everything)", -1)
                ])], 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$5, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Preview (Frame 0)", -1)),
              createBaseVNode("div", _hoisted_14$5, [
                previewUrl.value ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: previewUrl.value,
                  alt: "Matte preview",
                  class: "preview-image"
                }, null, 8, _hoisted_15$5)) : (openBlock(), createElementBlock("div", _hoisted_16$5, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-image" }, null, -1),
                  createBaseVNode("span", null, "Generating preview...", -1)
                ])]))
              ]),
              _cache[19] || (_cache[19] = createBaseVNode("p", { class: "preview-info" }, [
                createTextVNode(" White = Keep original / generate content"),
                createBaseVNode("br"),
                createTextVNode(" Black = Exclude from generation ")
              ], -1))
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_17$5, [
              createBaseVNode("div", _hoisted_18$5, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: `${exportProgress.value}%` })
                }, null, 4)
              ]),
              createBaseVNode("p", _hoisted_19$5, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_20$5, [
            createBaseVNode("div", _hoisted_21$5, [
              createBaseVNode("span", null, toDisplayString(unref(store).frameCount) + " frames @ " + toDisplayString(exportWidth.value) + "" + toDisplayString(exportHeight.value), 1)
            ]),
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[5] || (_cache[5] = ($event) => emit("close")),
              disabled: isExporting.value
            }, " Cancel ", 8, _hoisted_22$5),
            createBaseVNode("button", {
              class: "export-btn",
              onClick: startExport,
              disabled: isExporting.value || !unref(store).hasProject
            }, [
              _cache[20] || (_cache[20] = createBaseVNode("i", { class: "pi pi-download" }, null, -1)),
              createTextVNode(" " + toDisplayString(isExporting.value ? "Exporting..." : "Export ZIP"), 1)
            ], 8, _hoisted_23$5)
          ])
        ])
      ]);
    };
  }
});

const ExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-34eee532"]]);

const EXPORT_PRESETS = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: false,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "motionctrl": {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 3
  },
  "cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ati": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ttm": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-wan": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 50,
    cfgScale: 6
  },
  "ttm-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  }
};
const DEPTH_FORMAT_SPECS = {
  "midas": {
    format: "midas",
    bitDepth: 8,
    invert: true,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "zoe": {
    format: "zoe",
    bitDepth: 16,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: false,
    normalize: false,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  "normalized": {
    format: "normalized",
    bitDepth: 8,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
};
const RESOLUTION_PRESETS = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
];
const FRAME_COUNT_PRESETS = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
];
const EXPORT_TARGET_INFO = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  "motionctrl": {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  "cogvideox": {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  "ati": {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  "ttm": {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "ttm-wan": {
    name: "TTM (Wan 2.1 Backend)",
    description: "Time-to-Move with Wan 2.1 model for high-quality generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControl", "TTM_TrajectoryFromPoints", "WanImageToVideo"]
  },
  "ttm-cogvideox": {
    name: "TTM (CogVideoX Backend)",
    description: "Time-to-Move with CogVideoX model for longer sequences",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlCogVideo", "TTM_TrajectoryFromPoints", "CogVideoImageToVideo"]
  },
  "ttm-svd": {
    name: "TTM (SVD Backend)",
    description: "Time-to-Move with Stable Video Diffusion for fast generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlSVD", "TTM_TrajectoryFromPoints", "SVDEncode"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};

function renderDepthFrame(options) {
  const { width, height, nearClip, farClip, camera, layers, frame } = options;
  const depthBuffer = new Float32Array(width * height);
  depthBuffer.fill(farClip);
  let minDepth = farClip;
  let maxDepth = nearClip;
  const sortedLayers = [...layers].filter((l) => l.visible).sort((a, b) => {
    const aZ = getLayerDepth(a, frame);
    const bZ = getLayerDepth(b, frame);
    return aZ - bZ;
  });
  for (const layer of sortedLayers) {
    const layerDepth = getLayerDepth(layer, frame);
    const layerOpacity = getLayerOpacity(layer, frame);
    if (layerOpacity < 0.01) continue;
    const bounds = getLayerScreenBounds(layer, frame, camera, width, height);
    if (!bounds) continue;
    const cameraZ = camera.position.z;
    const relativeDepth = Math.abs(layerDepth - cameraZ);
    const clampedDepth = Math.max(nearClip, Math.min(farClip, relativeDepth));
    minDepth = Math.min(minDepth, clampedDepth);
    maxDepth = Math.max(maxDepth, clampedDepth);
    if (layer.type === "depthflow" && hasDepthData(layer)) {
      fillDepthFromDepthflow(depthBuffer, layer, bounds, width, height, nearClip, farClip);
    } else {
      fillUniformDepth(depthBuffer, bounds, clampedDepth, layerOpacity, width, height);
    }
  }
  return {
    depthBuffer,
    width,
    height,
    minDepth,
    maxDepth
  };
}
function getLayerDepth(layer, frame) {
  const position = layer.transform?.position;
  if (!position) return 0;
  if (position.keyframes && position.keyframes.length > 0) {
    return interpolateValue(position.keyframes, frame, 2) || 0;
  }
  if (position.value) {
    const value = position.value;
    if (typeof value === "object" && "z" in value) {
      return value.z ?? 0;
    }
  }
  return 0;
}
function getLayerOpacity(layer, frame) {
  if (layer.opacity && "keyframes" in layer.opacity && layer.opacity.keyframes?.length > 0) {
    return (interpolateValue(layer.opacity.keyframes, frame) || 100) / 100;
  }
  if (layer.opacity && "value" in layer.opacity) {
    return (layer.opacity.value || 100) / 100;
  }
  return 1;
}
function getLayerScreenBounds(layer, frame, camera, screenWidth, screenHeight) {
  let x = 0, y = 0;
  const position = layer.transform?.position;
  if (position && "value" in position) {
    const value = position.value;
    if (Array.isArray(value)) {
      x = value[0] || 0;
      y = value[1] || 0;
    }
  }
  const layerWidth = layer.width || screenWidth;
  const layerHeight = layer.height || screenHeight;
  let scaleX = 1, scaleY = 1;
  const scale = layer.transform?.scale;
  if (scale && "value" in scale) {
    const value = scale.value;
    if (Array.isArray(value)) {
      scaleX = (value[0] || 100) / 100;
      scaleY = (value[1] || 100) / 100;
    }
  }
  const finalWidth = layerWidth * scaleX;
  const finalHeight = layerHeight * scaleY;
  let anchorX = 0.5, anchorY = 0.5;
  const anchorPoint = layer.transform?.anchorPoint;
  if (anchorPoint && "value" in anchorPoint) {
    const value = anchorPoint.value;
    if (Array.isArray(value)) {
      anchorX = (value[0] || 0) / layerWidth + 0.5;
      anchorY = (value[1] || 0) / layerHeight + 0.5;
    }
  }
  const screenX = x - finalWidth * anchorX + screenWidth / 2;
  const screenY = y - finalHeight * anchorY + screenHeight / 2;
  const clippedX = Math.max(0, Math.min(screenWidth, screenX));
  const clippedY = Math.max(0, Math.min(screenHeight, screenY));
  const clippedWidth = Math.max(0, Math.min(screenWidth - clippedX, finalWidth - (clippedX - screenX)));
  const clippedHeight = Math.max(0, Math.min(screenHeight - clippedY, finalHeight - (clippedY - screenY)));
  if (clippedWidth <= 0 || clippedHeight <= 0) return null;
  return {
    x: clippedX,
    y: clippedY,
    width: clippedWidth,
    height: clippedHeight
  };
}
function hasDepthData(layer) {
  return layer.type === "depthflow" && !!layer.depthMapData;
}
function fillDepthFromDepthflow(depthBuffer, layer, bounds, screenWidth, screenHeight, nearClip, farClip) {
  const depthData = layer.depthMapData;
  const depthWidth = layer.depthWidth || bounds.width;
  const depthHeight = layer.depthHeight || bounds.height;
  for (let y = 0; y < bounds.height; y++) {
    for (let x = 0; x < bounds.width; x++) {
      const screenX = Math.floor(bounds.x + x);
      const screenY = Math.floor(bounds.y + y);
      if (screenX < 0 || screenX >= screenWidth || screenY < 0 || screenY >= screenHeight) continue;
      const sampleX = Math.floor(x / bounds.width * depthWidth);
      const sampleY = Math.floor(y / bounds.height * depthHeight);
      const sampleIdx = sampleY * depthWidth + sampleX;
      let depthValue;
      if (depthData instanceof Float32Array) {
        depthValue = depthData[sampleIdx];
      } else {
        depthValue = depthData[sampleIdx] / 255;
      }
      const worldDepth = nearClip + depthValue * (farClip - nearClip);
      const bufferIdx = screenY * screenWidth + screenX;
      if (worldDepth < depthBuffer[bufferIdx]) {
        depthBuffer[bufferIdx] = worldDepth;
      }
    }
  }
}
function fillUniformDepth(depthBuffer, bounds, depth, opacity, screenWidth, screenHeight) {
  const startX = Math.floor(bounds.x);
  const startY = Math.floor(bounds.y);
  const endX = Math.min(screenWidth, Math.ceil(bounds.x + bounds.width));
  const endY = Math.min(screenHeight, Math.ceil(bounds.y + bounds.height));
  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      const idx = y * screenWidth + x;
      if (opacity > 0.5 && depth < depthBuffer[idx]) {
        depthBuffer[idx] = depth;
      }
    }
  }
}
function interpolateValue(keyframes, frame, index) {
  if (!keyframes || keyframes.length === 0) return null;
  let prev = keyframes[0];
  let next = keyframes[keyframes.length - 1];
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i].frame <= frame) {
      prev = keyframes[i];
    }
    if (keyframes[i].frame >= frame && i < keyframes.length) {
      next = keyframes[i];
      break;
    }
  }
  if (prev.frame === next.frame) {
    const value = prev.value;
    return index !== void 0 && Array.isArray(value) ? value[index] : value;
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevValue = index !== void 0 && Array.isArray(prev.value) ? prev.value[index] : prev.value;
  const nextValue = index !== void 0 && Array.isArray(next.value) ? next.value[index] : next.value;
  return prevValue + (nextValue - prevValue) * t;
}
function convertDepthToFormat(result, format) {
  const spec = DEPTH_FORMAT_SPECS[format];
  const { depthBuffer, width, height, minDepth, maxDepth } = result;
  const pixelCount = width * height;
  if (spec.bitDepth === 16) {
    const output = new Uint16Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized;
      if (spec.normalize) {
        normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      } else {
        normalized = depthBuffer[i] / spec.farClip;
      }
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(65535, Math.round(normalized * 65535)));
    }
    return output;
  } else {
    const output = new Uint8Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(255, Math.round(normalized * 255)));
    }
    return output;
  }
}
function depthToImageData(depthData, width, height) {
  const imageData = new ImageData(width, height);
  const is16bit = depthData instanceof Uint16Array;
  for (let i = 0; i < width * height; i++) {
    const value = is16bit ? Math.floor(depthData[i] / 256) : depthData[i];
    const pixelIdx = i * 4;
    imageData.data[pixelIdx] = value;
    imageData.data[pixelIdx + 1] = value;
    imageData.data[pixelIdx + 2] = value;
    imageData.data[pixelIdx + 3] = 255;
  }
  return imageData;
}

const comfyLogger = createLogger("ComfyUI");
class ComfyUIClient {
  serverAddress;
  clientId;
  ws = null;
  messageHandlers = /* @__PURE__ */ new Map();
  constructor(config) {
    this.serverAddress = config.serverAddress.replace(/\/$/, "");
    this.clientId = config.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      });
      return response.ok;
    } catch {
      return false;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const response = await fetch(`http://${this.serverAddress}/prompt`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(imageData, filename, type = "input", subfolder, overwrite = true) {
    const formData = new FormData();
    formData.append("image", imageData, filename);
    formData.append("type", type);
    formData.append("overwrite", overwrite.toString());
    if (subfolder) {
      formData.append("subfolder", subfolder);
    }
    const response = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to upload image: ${error}`);
    }
    return response.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(maskData, filename, originalRef) {
    const formData = new FormData();
    formData.append("image", maskData, filename);
    formData.append("original_ref", JSON.stringify(originalRef));
    formData.append("type", "input");
    const response = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Failed to upload mask: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(workflow, extraData) {
    const payload = {
      prompt: workflow,
      client_id: this.clientId,
      extra_data: extraData
    };
    const response = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to queue prompt: ${error}`);
    }
    return response.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(promptId) {
    const url = promptId ? `http://${this.serverAddress}/history/${promptId}` : `http://${this.serverAddress}/history`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to get history: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(filename, subfolder = "", type = "output") {
    const params = new URLSearchParams({
      filename,
      subfolder,
      type
    });
    const response = await fetch(`http://${this.serverAddress}/view?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to get output: ${await response.text()}`);
    }
    return response.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(filename, subfolder = "", type = "output") {
    const blob = await this.getOutput(filename, subfolder, type);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const response = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`Failed to interrupt: ${await response.text()}`);
    }
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const response = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: true })
    });
    if (!response.ok) {
      throw new Error(`Failed to clear queue: ${await response.text()}`);
    }
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(deleteType, ids) {
    const response = await fetch(`http://${this.serverAddress}/${deleteType}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: ids })
    });
    if (!response.ok) {
      throw new Error(`Failed to delete from ${deleteType}: ${await response.text()}`);
    }
  }
  /**
   * Get available models
   */
  async getModels(type) {
    const folderMap = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    };
    const response = await fetch(
      `http://${this.serverAddress}/models/${folderMap[type]}`
    );
    if (!response.ok) {
      return [];
    }
    return response.json();
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const wsUrl = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(wsUrl);
      this.ws.onopen = () => {
        comfyLogger.debug("WebSocket connected");
        resolve();
      };
      this.ws.onerror = (event) => {
        comfyLogger.error("WebSocket error:", event);
        reject(new Error("WebSocket connection failed"));
      };
      this.ws.onclose = () => {
        comfyLogger.debug("WebSocket disconnected");
        this.ws = null;
      };
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (e) {
          comfyLogger.error("Failed to parse WebSocket message:", e);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  /**
   * Remove a message handler
   */
  offMessage(type) {
    this.messageHandlers.delete(type);
  }
  handleWebSocketMessage(data) {
    const { type } = data;
    const handler = this.messageHandlers.get(type);
    if (handler) {
      handler(data);
    }
    const allHandler = this.messageHandlers.get("all");
    if (allHandler) {
      allHandler(data);
    }
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(imageData, filename, subfolder) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(canvas, filename, subfolder) {
    let blob;
    if (canvas instanceof OffscreenCanvas) {
      blob = await canvas.convertToBlob({ type: "image/png" });
    } else {
      blob = await new Promise((resolve, reject) => {
        canvas.toBlob((b) => {
          if (b) resolve(b);
          else reject(new Error("Failed to convert canvas to blob"));
        }, "image/png");
      });
    }
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(promptId, onProgress, timeoutMs = 3e5) {
    const startTime = Date.now();
    if (!this.isWebSocketConnected()) {
      await this.connectWebSocket();
    }
    return new Promise((resolve, reject) => {
      let completed = false;
      const cleanup = () => {
        this.offMessage("progress");
        this.offMessage("executing");
        this.offMessage("executed");
        this.offMessage("execution_error");
      };
      const checkTimeout = () => {
        if (Date.now() - startTime > timeoutMs) {
          cleanup();
          reject(new Error("Prompt execution timed out"));
        }
      };
      this.onMessage("progress", (data) => {
        checkTimeout();
        onProgress?.({
          status: "executing",
          currentStep: data.data.value,
          totalSteps: data.data.max,
          percentage: data.data.value / data.data.max * 100
        });
      });
      this.onMessage("executing", (data) => {
        checkTimeout();
        if (data.data.prompt_id === promptId) {
          onProgress?.({
            status: "executing",
            currentNode: data.data.node,
            percentage: 10
            // Approximate
          });
        }
      });
      this.onMessage("executed", async (data) => {
        if (data.data.prompt_id === promptId && !completed) {
          completed = true;
          cleanup();
          onProgress?.({
            status: "completed",
            percentage: 100
          });
          const history = await this.getHistory(promptId);
          resolve(history[promptId]);
        }
      });
      this.onMessage("execution_error", (data) => {
        if (data.data.prompt_id === promptId) {
          cleanup();
          onProgress?.({
            status: "error",
            percentage: 0
          });
          reject(new Error(data.data.exception_message || "Execution failed"));
        }
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(workflow, onProgress) {
    const { prompt_id } = await this.queuePrompt(workflow);
    onProgress?.({
      status: "queued",
      percentage: 0
    });
    const history = await this.waitForPrompt(prompt_id, onProgress);
    const outputs = [];
    for (const nodeOutputs of Object.values(history.outputs)) {
      if (nodeOutputs.images) {
        outputs.push(...nodeOutputs.images);
      }
      if (nodeOutputs.gifs) {
        outputs.push(...nodeOutputs.gifs);
      }
    }
    return {
      promptId: prompt_id,
      history,
      outputs
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let defaultClient = null;
function getComfyUIClient(serverAddress) {
  if (!defaultClient || serverAddress && serverAddress !== defaultClient.server) {
    defaultClient = new ComfyUIClient({
      serverAddress: serverAddress || "127.0.0.1:8188"
    });
  }
  return defaultClient;
}

let nodeIdCounter = 1;
function resetNodeIds() {
  nodeIdCounter = 1;
}
function nextNodeId() {
  return String(nodeIdCounter++);
}
function createNode(classType, inputs, title) {
  const node = {
    class_type: classType,
    inputs
  };
  if (title) {
    node._meta = { title };
  }
  return node;
}
function conn(nodeId, outputIndex = 0) {
  return [nodeId, outputIndex];
}
function addCheckpointLoader(workflow, checkpoint) {
  const id = nextNodeId();
  workflow[id] = createNode("CheckpointLoaderSimple", {
    ckpt_name: checkpoint
  }, "Load Checkpoint");
  return id;
}
function addCLIPTextEncode(workflow, clipConnection, text, title) {
  const id = nextNodeId();
  workflow[id] = createNode("CLIPTextEncode", {
    clip: clipConnection,
    text
  }, title);
  return id;
}
function addLoadImage(workflow, imageName, title) {
  const id = nextNodeId();
  workflow[id] = createNode("LoadImage", {
    image: imageName
  }, title || "Load Image");
  return id;
}
function addImageResize(workflow, imageConnection, width, height) {
  const id = nextNodeId();
  workflow[id] = createNode("ImageResize", {
    image: imageConnection,
    width,
    height,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image");
  return id;
}
function addVAEEncode(workflow, imageConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEEncode", {
    pixels: imageConnection,
    vae: vaeConnection
  }, "VAE Encode");
  return id;
}
function addVAEDecode(workflow, samplesConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEDecode", {
    samples: samplesConnection,
    vae: vaeConnection
  }, "VAE Decode");
  return id;
}
function addKSampler(workflow, modelConnection, positiveConnection, negativeConnection, latentConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("KSampler", {
    model: modelConnection,
    positive: positiveConnection,
    negative: negativeConnection,
    latent_image: latentConnection,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    steps: params.steps ?? 20,
    cfg: params.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: params.denoise ?? 1
  }, "KSampler");
  return id;
}
function addVideoOutput(workflow, imagesConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("VHS_VideoCombine", {
    images: imagesConnection,
    frame_rate: params.fps,
    loop_count: 0,
    filename_prefix: params.filename || "weyl_output",
    format: params.format || "video/h264-mp4",
    pingpong: false,
    save_output: true,
    audio: null,
    meta_batch: null
  }, "Video Output");
  return id;
}
function generateWan22I2VWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const isHD = params.width > 640 || params.height > 640;
  const wanModel = params.wanModel || (isHD ? "i2v_720p" : "i2v_480p");
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${wanModel}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanImageToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: params.denoise || 1
  }, "I2V Generation");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_i2v"
  });
  return workflow;
}
function generateWan22FunCameraWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("WanFunCameraMotion", {
    motion_type: params.cameraMotion || "Static",
    length: params.frameCount
  }, "Camera Motion");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFunCameraI2V", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    camera_motion: conn(cameraCtrlId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_fun_camera"
  });
  return workflow;
}
function generateWan22FirstLastWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const firstImageId = addLoadImage(workflow, params.referenceImage || "first.png", "First Frame");
  const lastImageId = addLoadImage(workflow, params.lastFrameImage || "last.png", "Last Frame");
  const resizeFirstId = addImageResize(workflow, conn(firstImageId), params.width, params.height);
  const resizeLastId = addImageResize(workflow, conn(lastImageId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFirstLastFrameToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    first_frame: conn(resizeFirstId),
    last_frame: conn(resizeLastId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_flf"
  });
  return workflow;
}
function generateUni3CWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const uni3cLoaderId = nextNodeId();
  workflow[uni3cLoaderId] = createNode("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const trajId = nextNodeId();
  if (params.trajType === "custom" && params.cameraData?.trajectory) {
    workflow[trajId] = createNode("Uni3CCustomTrajectory", {
      trajectory_data: JSON.stringify(params.cameraData.trajectory),
      length: params.frameCount
    }, "Custom Trajectory");
  } else {
    workflow[trajId] = createNode("Uni3CPresetTrajectory", {
      traj_type: params.trajType || "orbit",
      length: params.frameCount
    }, "Preset Trajectory");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyUni3CCameraControl", {
    model: conn(baseModelId),
    uni3c: conn(uni3cLoaderId),
    trajectory: conn(trajId),
    image: conn(resizeId),
    control_strength: 1
  }, "Apply Camera Control");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "uni3c_output"
  });
  return workflow;
}
function generateMotionCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const motionCtrlId = nextNodeId();
  workflow[motionCtrlId] = createNode("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("MotionCtrlCameraPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("MotionCtrlPresetPoses", {
      preset: params.motionPreset || "static",
      length: params.frameCount
    }, "Preset Poses");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyMotionCtrl", {
    model: conn(baseModelId),
    motion_ctrl: conn(motionCtrlId),
    camera_poses: conn(posesId),
    control_strength: 1
  }, "Apply MotionCtrl");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "motionctrl_output"
  });
  return workflow;
}
function generateControlNetDepthWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "sd_xl_base_1.0.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const depthLoaderId = nextNodeId();
  workflow[depthLoaderId] = createNode("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const refImageId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeRefId = addImageResize(workflow, conn(refImageId), params.width, params.height);
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(depthLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const encodeRefId = addVAEEncode(workflow, conn(resizeRefId), conn(checkpointId, 2));
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(encodeRefId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7, denoise: params.denoise || 0.75 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "controlnet_depth"
  });
  return workflow;
}
function generateAnimateDiffCameraCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "dreamshaper_8.safetensors");
  const animateDiffId = nextNodeId();
  workflow[animateDiffId] = createNode("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("ADE_CameraCtrlPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("ADE_CameraCtrlPreset", {
      motion_type: params.cameraMotion || "Static",
      speed: 1,
      frame_length: params.frameCount
    }, "Camera Preset");
  }
  const applyADId = nextNodeId();
  workflow[applyADId] = createNode("ADE_ApplyAnimateDiffModel", {
    model: conn(checkpointId),
    motion_model: conn(animateDiffId)
  }, "Apply AnimateDiff");
  const applyCamId = nextNodeId();
  workflow[applyCamId] = createNode("ADE_ApplyCameraCtrl", {
    model: conn(applyADId),
    cameractrl: conn(cameraCtrlId),
    poses: conn(posesId)
  }, "Apply CameraCtrl");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(applyCamId),
    conn(positiveId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "animatediff_cameractrl"
  });
  return workflow;
}
function generateCogVideoXWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const cogVideoId = nextNodeId();
  workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const t5Id = nextNodeId();
  workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const vaeId = nextNodeId();
  workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const encodePromptId = nextNodeId();
  workflow[encodePromptId] = createNode("CogVideoTextEncode", {
    text_encoder: conn(t5Id),
    prompt: params.prompt,
    force_offload: true
  }, "Encode Prompt");
  const generateId = nextNodeId();
  workflow[generateId] = createNode("CogVideoImageToVideo", {
    model: conn(cogVideoId),
    positive: conn(encodePromptId),
    image: conn(resizeId),
    vae: conn(vaeId),
    width: params.width,
    height: params.height,
    num_frames: params.frameCount,
    steps: params.steps || 50,
    cfg: params.cfgScale || 6,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("CogVideoDecode", {
    vae: conn(vaeId),
    samples: conn(generateId),
    enable_vae_tiling: true
  }, "Decode Video");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "cogvideox_output"
  });
  return workflow;
}
function generateTTMWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const ttmModel = params.ttmModel || "wan";
  const layers = params.ttmLayers || [];
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const combinedMaskId = nextNodeId();
  workflow[combinedMaskId] = createNode("LoadImage", {
    image: params.ttmCombinedMask || "combined_motion_mask.png"
  }, "Combined Motion Mask");
  const layerMaskIds = [];
  const trajectoryIds = [];
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];
    const maskId = nextNodeId();
    workflow[maskId] = createNode("LoadImage", {
      image: layer.motionMask
    }, `Layer ${i + 1} Mask: ${layer.layerName}`);
    layerMaskIds.push(maskId);
    const trajId = nextNodeId();
    workflow[trajId] = createNode("TTM_TrajectoryFromPoints", {
      points: JSON.stringify(layer.trajectory.map((t) => [t.x, t.y])),
      frames: JSON.stringify(layer.trajectory.map((t) => t.frame)),
      total_frames: params.frameCount,
      interpolation: "linear"
    }, `Trajectory: ${layer.layerName}`);
    trajectoryIds.push(trajId);
  }
  let combinedLayerDataId = null;
  if (layers.length > 0) {
    combinedLayerDataId = nextNodeId();
    workflow[combinedLayerDataId] = createNode("TTM_CombineLayers", {
      masks: layerMaskIds.map((id) => conn(id)),
      trajectories: trajectoryIds.map((id) => conn(id)),
      blend_mode: "additive"
    }, "Combine Layer Data");
  }
  if (ttmModel === "wan") {
    const wanLoaderId = nextNodeId();
    workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
      model: "wan2.1_i2v_480p_bf16.safetensors",
      base_precision: "bf16",
      quantization: "disabled"
    }, "Load Wan Model");
    const vaeLoaderId = nextNodeId();
    workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
      vae: "wan_2.1_vae.safetensors",
      precision: "bf16"
    }, "Load Wan VAE");
    const clipLoaderId = nextNodeId();
    workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
      text_encoder: "umt5-xxl-enc-bf16.safetensors",
      precision: "bf16"
    }, "Load Text Encoder");
    const positiveId = nextNodeId();
    workflow[positiveId] = createNode("WanTextEncode", {
      text_encoder: conn(clipLoaderId),
      prompt: params.prompt,
      force_offload: true
    }, "Positive Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControl", {
      wan_model: conn(wanLoaderId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const latentId = nextNodeId();
    workflow[latentId] = createNode("WanImageToVideo", {
      wan_model: conn(ttmControlId),
      positive: conn(positiveId),
      image: conn(resizeId),
      vae: conn(vaeLoaderId),
      width: params.width,
      height: params.height,
      length: params.frameCount,
      steps: params.steps || 30,
      cfg: params.cfgScale || 5,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "DPM++ 2M SDE",
      denoise_strength: params.denoise || 1
    }, "TTM I2V Generation");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("WanVAEDecode", {
      vae: conn(vaeLoaderId),
      samples: conn(latentId),
      enable_vae_tiling: true,
      tile_sample_min_height: 240,
      tile_sample_min_width: 240,
      tile_overlap_factor_height: 0.2,
      tile_overlap_factor_width: 0.2
    }, "VAE Decode");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_output"
    });
  } else if (ttmModel === "cogvideox") {
    const cogVideoId = nextNodeId();
    workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
      model: "CogVideoX-5b-I2V",
      precision: "bf16"
    }, "Load CogVideoX");
    const t5Id = nextNodeId();
    workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
      model: "t5-v1_1-xxl-encoder-bf16",
      precision: "bf16"
    }, "Load T5 Encoder");
    const vaeId = nextNodeId();
    workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
      model: "cogvideox_vae",
      precision: "bf16"
    }, "Load CogVideo VAE");
    const encodePromptId = nextNodeId();
    workflow[encodePromptId] = createNode("CogVideoTextEncode", {
      text_encoder: conn(t5Id),
      prompt: params.prompt,
      force_offload: true
    }, "Encode Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlCogVideo", {
      model: conn(cogVideoId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const generateId = nextNodeId();
    workflow[generateId] = createNode("CogVideoImageToVideo", {
      model: conn(ttmControlId),
      positive: conn(encodePromptId),
      image: conn(resizeId),
      vae: conn(vaeId),
      width: params.width,
      height: params.height,
      num_frames: params.frameCount,
      steps: params.steps || 50,
      cfg: params.cfgScale || 6,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "CogVideoX DDIM"
    }, "CogVideoX I2V");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("CogVideoDecode", {
      vae: conn(vaeId),
      samples: conn(generateId),
      enable_vae_tiling: true
    }, "Decode Video");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_cogvideo_output"
    });
  } else {
    const baseModelId = nextNodeId();
    workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
      ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
    }, "Load SVD");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlSVD", {
      model: conn(baseModelId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const encodeId = nextNodeId();
    workflow[encodeId] = createNode("SVDEncode", {
      model: conn(ttmControlId),
      image: conn(resizeId),
      vae: conn(baseModelId, 2),
      width: params.width,
      height: params.height,
      video_frames: params.frameCount,
      motion_bucket_id: 127,
      fps: params.fps,
      augmentation_level: 0
    }, "SVD Encode");
    const sampleId = addKSampler(
      workflow,
      conn(ttmControlId),
      conn(encodeId, 1),
      conn(encodeId, 2),
      conn(encodeId),
      { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
    );
    const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_svd_output"
    });
  }
  return workflow;
}
function generateControlNetWorkflow(params, controlType) {
  resetNodeIds();
  const workflow = {};
  const controlnetModels = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  };
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "v1-5-pruned-emaonly.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || controlnetModels[controlType]
  }, `Load ControlNet ${controlType}`);
  const controlLoaderId = nextNodeId();
  workflow[controlLoaderId] = createNode("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(controlLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || `controlnet_${controlType}`
  });
  return workflow;
}
function generateWorkflowForTarget(target, params) {
  switch (target) {
    case "wan22-i2v":
      return generateWan22I2VWorkflow(params);
    case "wan22-t2v":
      return generateWan22I2VWorkflow({ ...params, referenceImage: void 0 });
    case "wan22-fun-camera":
      return generateWan22FunCameraWorkflow(params);
    case "wan22-first-last":
      return generateWan22FirstLastWorkflow(params);
    case "uni3c-camera":
    case "uni3c-motion":
      return generateUni3CWorkflow(params);
    case "motionctrl":
    case "motionctrl-svd":
      return generateMotionCtrlWorkflow(params);
    case "cogvideox":
      return generateCogVideoXWorkflow(params);
    case "controlnet-depth":
      return generateControlNetDepthWorkflow(params);
    case "controlnet-canny":
      return generateControlNetWorkflow(params, "canny");
    case "controlnet-lineart":
      return generateControlNetWorkflow(params, "lineart");
    case "animatediff-cameractrl":
      return generateAnimateDiffCameraCtrlWorkflow(params);
    case "ttm":
    case "ttm-wan":
    case "ttm-cogvideox":
    case "ttm-svd":
      return generateTTMWorkflow(params);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${target}`);
  }
}
function validateWorkflow(workflow) {
  const errors = [];
  const warnings = [];
  const nodeIds = Object.keys(workflow);
  for (const [nodeId, node] of Object.entries(workflow)) {
    if (!node.class_type) {
      errors.push(`Node ${nodeId}: missing class_type`);
    }
    for (const [inputName, inputValue] of Object.entries(node.inputs)) {
      if (Array.isArray(inputValue) && inputValue.length === 2) {
        const [refNodeId] = inputValue;
        if (typeof refNodeId === "string" && !nodeIds.includes(refNodeId)) {
          errors.push(`Node ${nodeId}.${inputName}: references non-existent node ${refNodeId}`);
        }
      }
    }
  }
  const hasOutput = Object.values(workflow).some(
    (node) => node.class_type.includes("Save") || node.class_type.includes("Output") || node.class_type.includes("Preview")
  );
  if (!hasOutput) {
    warnings.push("Workflow has no output/save nodes");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

class ExportPipeline {
  layers;
  cameraKeyframes;
  config;
  onProgress;
  abortSignal;
  aborted = false;
  constructor(options) {
    this.layers = options.layers;
    this.cameraKeyframes = options.cameraKeyframes;
    this.config = options.config;
    this.onProgress = options.onProgress || (() => {
    });
    this.abortSignal = options.abortSignal;
    if (this.abortSignal) {
      this.abortSignal.addEventListener("abort", () => {
        this.aborted = true;
      });
    }
  }
  checkAborted() {
    if (this.aborted) {
      throw new Error("Export aborted");
    }
  }
  updateProgress(progress) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...progress
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const startTime = Date.now();
    const result = {
      success: false,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const configErrors = this.validateConfig();
      if (configErrors.length > 0) {
        result.errors = configErrors;
        return result;
      }
      if (this.config.exportReferenceFrame) {
        this.checkAborted();
        await this.renderReferenceFrame(result);
      }
      if (this.config.exportLastFrame) {
        this.checkAborted();
        await this.renderLastFrame(result);
      }
      if (this.config.exportDepthMap) {
        this.checkAborted();
        await this.renderDepthSequence(result);
      }
      if (this.config.exportControlImages) {
        this.checkAborted();
        await this.renderControlSequence(result);
      }
      if (this.config.exportCameraData) {
        this.checkAborted();
        await this.exportCameraData(result);
      }
      this.checkAborted();
      await this.generateWorkflow(result);
      if (this.config.autoQueueWorkflow && this.config.comfyuiServer) {
        this.checkAborted();
        await this.queueWorkflow(result);
      }
      result.success = result.errors.length === 0;
    } catch (error) {
      if (error instanceof Error && error.message === "Export aborted") {
        result.errors.push("Export was cancelled");
      } else {
        result.errors.push(error instanceof Error ? error.message : "Unknown error");
      }
    }
    result.duration = Date.now() - startTime;
    return result;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const errors = [];
    if (this.config.width < 64 || this.config.width > 4096) {
      errors.push("Width must be between 64 and 4096");
    }
    if (this.config.height < 64 || this.config.height > 4096) {
      errors.push("Height must be between 64 and 4096");
    }
    if (this.config.frameCount < 1 || this.config.frameCount > 1e3) {
      errors.push("Frame count must be between 1 and 1000");
    }
    if (this.config.fps < 1 || this.config.fps > 120) {
      errors.push("FPS must be between 1 and 120");
    }
    if (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) {
      errors.push("Invalid start frame");
    }
    if (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) {
      errors.push("Invalid end frame");
    }
    if (!this.config.prompt && this.needsPrompt()) {
      errors.push("Prompt is required for this export target");
    }
    return errors;
  }
  needsPrompt() {
    const noPromptTargets = ["controlnet-depth", "controlnet-canny", "controlnet-lineart"];
    return !noPromptTargets.includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.startFrame);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.referenceImage = uploadResult.name;
    } else {
      result.outputFiles.referenceImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.endFrame - 1);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.lastImage = uploadResult.name;
    } else {
      result.outputFiles.lastImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(ctx, frameIndex) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    const sortedLayers = [...this.layers].filter((layer) => layer.visible).sort((a, b) => {
      const az = a.transform?.position?.value?.z ?? 0;
      const bz = b.transform?.position?.value?.z ?? 0;
      return az - bz;
    });
    for (const layer of sortedLayers) {
      await this.renderLayerToCanvas(ctx, layer, frameIndex);
    }
  }
  async renderLayerToCanvas(ctx, layer, _frameIndex) {
    const pos = layer.transform?.position?.value ?? { x: 0, y: 0 };
    const scaleVal = layer.transform?.scale?.value ?? { x: 100, y: 100 };
    const rotation = layer.transform?.rotation?.value ?? 0;
    const opacity = typeof layer.opacity?.value === "number" ? layer.opacity.value : 100;
    ctx.save();
    ctx.globalAlpha = opacity / 100;
    ctx.translate(pos.x, pos.y);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scaleVal.x / 100, scaleVal.y / 100);
    const layerData = layer.data;
    if (layer.type === "image" && layerData?.src) {
      const img = await this.loadImage(layerData.src);
      ctx.drawImage(img, -img.width / 2, -img.height / 2);
    } else if (layer.type === "solid" && layerData?.color) {
      ctx.fillStyle = layerData.color || "#000000";
      const width = layerData.width ?? 100;
      const height = layerData.height ?? 100;
      ctx.fillRect(-width / 2, -height / 2, width, height);
    }
    ctx.restore();
  }
  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const depthFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: progress,
        overallProgress: 15 + progress * 0.25,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering depth frame ${i + 1}/${frameCount}`
      });
      const defaultCamera = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: false,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      };
      const depthResult = renderDepthFrame({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: defaultCamera,
        layers: this.layers,
        frame: frameIndex
      });
      const convertedDepth = convertDepthToFormat(
        depthResult,
        this.config.depthFormat
      );
      const imageData = depthToImageData(
        convertedDepth,
        this.config.width,
        this.config.height
      );
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      const blob = await canvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_depth_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "depth_sequence");
        depthFiles.push(uploadResult.name);
      } else {
        depthFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.depthSequence = depthFiles;
    this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const controlFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: progress,
        overallProgress: 40 + progress * 0.2,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering control frame ${i + 1}/${frameCount}`
      });
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      await this.renderFrameToCanvas(ctx, frameIndex);
      const controlCanvas = await this.applyControlPreprocessing(canvas, this.config.controlType || "depth");
      const blob = await controlCanvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_control_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "control_sequence");
        controlFiles.push(uploadResult.name);
      } else {
        controlFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.controlSequence = controlFiles;
    this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(input, controlType) {
    const output = new OffscreenCanvas(input.width, input.height);
    const ctx = output.getContext("2d");
    const inputCtx = input.getContext("2d");
    const imageData = inputCtx.getImageData(0, 0, input.width, input.height);
    const data = imageData.data;
    switch (controlType) {
      case "canny":
        this.applyEdgeDetection(data, input.width, input.height);
        break;
      case "lineart":
        this.applyLineart(data);
        break;
      case "softedge":
        this.applySoftEdge(data, input.width, input.height);
        break;
    }
    ctx.putImageData(imageData, 0, 0);
    return output;
  }
  applyEdgeDetection(data, width, height) {
    const grayscale = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      grayscale[i] = (data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114) / 255;
    }
    const edges = new Float32Array(width * height);
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = y * width + x;
        const gx = -grayscale[idx - width - 1] + grayscale[idx - width + 1] + -2 * grayscale[idx - 1] + 2 * grayscale[idx + 1] + -grayscale[idx + width - 1] + grayscale[idx + width + 1];
        const gy = -grayscale[idx - width - 1] - 2 * grayscale[idx - width] - grayscale[idx - width + 1] + grayscale[idx + width - 1] + 2 * grayscale[idx + width] + grayscale[idx + width + 1];
        edges[idx] = Math.min(1, Math.sqrt(gx * gx + gy * gy) * 2);
      }
    }
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      const val = Math.floor(edges[i] * 255);
      data[idx] = val;
      data[idx + 1] = val;
      data[idx + 2] = val;
    }
  }
  applyLineart(data) {
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      const val = gray > 128 ? 255 : 0;
      data[i] = val;
      data[i + 1] = val;
      data[i + 2] = val;
    }
  }
  applySoftEdge(data, width, height) {
    this.applyEdgeDetection(data, width, height);
    const temp = new Uint8ClampedArray(data);
    const kernel = 2;
    for (let y = kernel; y < height - kernel; y++) {
      for (let x = kernel; x < width - kernel; x++) {
        let sum = 0;
        let count = 0;
        for (let ky = -kernel; ky <= kernel; ky++) {
          for (let kx = -kernel; kx <= kernel; kx++) {
            const idx2 = ((y + ky) * width + (x + kx)) * 4;
            sum += temp[idx2];
            count++;
          }
        }
        const idx = (y * width + x) * 4;
        const val = Math.floor(sum / count);
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
    }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(result) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const exportCamera = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: false,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: false
      }};
    const cameraData = exportCameraForTarget(
      this.config.target,
      exportCamera,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    );
    const filename = `${this.config.filenamePrefix}_camera.json`;
    const blob = new Blob([JSON.stringify(cameraData, null, 2)], { type: "application/json" });
    if (this.config.comfyuiServer) {
      result.outputFiles.cameraData = filename;
    } else {
      result.outputFiles.cameraData = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(result) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const params = {
      referenceImage: result.outputFiles.referenceImage,
      lastFrameImage: result.outputFiles.lastImage,
      depthSequence: result.outputFiles.depthSequence,
      controlImages: result.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    if (result.outputFiles.cameraData) {
      params.cameraData = result.outputFiles.cameraData;
    }
    const workflow = generateWorkflowForTarget(this.config.target, params);
    const validation = validateWorkflow(workflow);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
    }
    result.warnings.push(...validation.warnings);
    const filename = `${this.config.filenamePrefix}_workflow.json`;
    const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: "application/json" });
    result.outputFiles.workflowJson = await this.saveBlobLocally(blob, filename);
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(result) {
    if (!this.config.comfyuiServer || !result.outputFiles.workflowJson) {
      return;
    }
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const client = getComfyUIClient(this.config.comfyuiServer);
    const connected = await client.checkConnection();
    if (!connected) {
      result.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const response = await fetch(result.outputFiles.workflowJson);
    const workflow = await response.json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const promptResult = await client.queuePrompt(workflow);
    result.outputFiles.promptId = promptResult.prompt_id;
    if (promptResult.node_errors && Object.keys(promptResult.node_errors).length > 0) {
      result.errors.push("Workflow has node errors: " + JSON.stringify(promptResult.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await client.waitForPrompt(promptResult.prompt_id, (progress) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: progress.percentage,
          overallProgress: 80 + progress.percentage * 0.15,
          message: `Generating: ${progress.percentage.toFixed(0)}%`,
          preview: progress.preview
        });
      });
      this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return url;
  }
}
async function exportToComfyUI(layers, cameraKeyframes, config, onProgress) {
  const pipeline = new ExportPipeline({
    layers,
    cameraKeyframes,
    config,
    onProgress
  });
  return pipeline.execute();
}

const _hoisted_1$4 = { class: "export-dialog" };
const _hoisted_2$4 = { class: "dialog-tabs" };
const _hoisted_3$4 = { class: "dialog-content" };
const _hoisted_4$4 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_5$4 = { class: "target-grid" };
const _hoisted_6$4 = { class: "target-buttons" };
const _hoisted_7$4 = ["onClick"];
const _hoisted_8$4 = {
  key: 0,
  class: "target-info"
};
const _hoisted_9$4 = { class: "info-row" };
const _hoisted_10$4 = { class: "info-row" };
const _hoisted_11$4 = { class: "info-row" };
const _hoisted_12$4 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_13$4 = { class: "settings-section" };
const _hoisted_14$4 = { class: "preset-buttons" };
const _hoisted_15$4 = ["onClick"];
const _hoisted_16$4 = { class: "input-row" };
const _hoisted_17$4 = { class: "settings-section" };
const _hoisted_18$4 = { class: "preset-buttons" };
const _hoisted_19$4 = ["onClick"];
const _hoisted_20$4 = { class: "input-row" };
const _hoisted_21$4 = { class: "input-row" };
const _hoisted_22$4 = { class: "settings-section" };
const _hoisted_23$4 = { class: "checkbox-grid" };
const _hoisted_24$3 = {
  key: 0,
  class: "settings-section"
};
const _hoisted_25$3 = ["value"];
const _hoisted_26$3 = {
  key: 1,
  class: "settings-section"
};
const _hoisted_27$3 = ["value"];
const _hoisted_28$3 = {
  key: 2,
  class: "tab-content"
};
const _hoisted_29$3 = { class: "settings-section" };
const _hoisted_30$3 = { class: "settings-section" };
const _hoisted_31$1 = { class: "settings-section" };
const _hoisted_32$1 = { class: "input-row" };
const _hoisted_33$1 = { class: "input-row seed-row" };
const _hoisted_34$1 = {
  key: 3,
  class: "tab-content"
};
const _hoisted_35$1 = { class: "settings-section" };
const _hoisted_36$1 = { class: "server-row" };
const _hoisted_37$1 = { key: 0 };
const _hoisted_38 = { key: 1 };
const _hoisted_39 = { key: 2 };
const _hoisted_40 = { key: 3 };
const _hoisted_41 = { class: "settings-section" };
const _hoisted_42 = { class: "checkbox-large" };
const _hoisted_43 = {
  key: 0,
  class: "export-progress"
};
const _hoisted_44 = { class: "progress-header" };
const _hoisted_45 = { class: "progress-bar" };
const _hoisted_46 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_47 = {
  key: 1,
  class: "export-error"
};
const _hoisted_48 = { class: "dialog-footer" };
const _hoisted_49 = ["disabled"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const activeTab = ref("target");
    const selectedTarget = ref("wan22-i2v");
    const width = ref(832);
    const height = ref(480);
    const frameCount = ref(81);
    const fps = ref(24);
    const startFrame = ref(0);
    const endFrame = ref(81);
    const exportDepthMap = ref(true);
    const exportControlImages = ref(false);
    const exportCameraData = ref(true);
    const exportReferenceFrame = ref(true);
    const exportLastFrame = ref(false);
    const depthFormat = ref("midas");
    const controlType = ref("depth");
    const prompt = ref("");
    const negativePrompt = ref("blurry, low quality, distorted");
    const seed = ref(void 0);
    const steps = ref(30);
    const cfgScale = ref(5);
    const comfyuiServer = ref("127.0.0.1:8188");
    const autoQueueWorkflow = ref(false);
    const connectionStatus = ref("disconnected");
    const isExporting = ref(false);
    const exportProgress = ref(null);
    const exportError = ref(null);
    const abortController = ref(null);
    const targetInfo = computed(() => EXPORT_TARGET_INFO[selectedTarget.value]);
    const targetCategories = computed(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      "Uni3C": ["uni3c-camera", "uni3c-motion"],
      "MotionCtrl": ["motionctrl", "motionctrl-svd"],
      "Camera": ["animatediff-cameractrl", "camera-comfyui", "ati"],
      "Advanced": ["light-x", "ttm", "cogvideox"],
      "ControlNet": ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      "Custom": ["custom-workflow"]
    }));
    const targetDisplayName = computed(() => {
      const names = {
        "wan22-i2v": "Image to Video",
        "wan22-t2v": "Text to Video",
        "wan22-fun-camera": "Fun Camera",
        "wan22-first-last": "First + Last Frame",
        "wan-move": "Point Trajectories",
        "uni3c-camera": "Camera Control",
        "uni3c-motion": "Motion + Camera",
        "motionctrl": "MotionCtrl",
        "motionctrl-svd": "MotionCtrl SVD",
        "cogvideox": "CogVideoX I2V",
        "animatediff-cameractrl": "CameraCtrl",
        "camera-comfyui": "4x4 Matrices",
        "ati": "Any Trajectory",
        "light-x": "Relighting",
        "ttm": "Cut & Drag",
        "controlnet-depth": "Depth",
        "controlnet-canny": "Canny Edge",
        "controlnet-lineart": "Line Art",
        "custom-workflow": "Custom Workflow"
      };
      return names;
    });
    const depthFormats = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ];
    const controlTypes = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function selectTarget(target) {
      selectedTarget.value = target;
      const preset = EXPORT_PRESETS[target];
      if (preset) {
        width.value = preset.width ?? 832;
        height.value = preset.height ?? 480;
        frameCount.value = preset.frameCount ?? 81;
        fps.value = preset.fps ?? 24;
        endFrame.value = frameCount.value;
      }
      const info = EXPORT_TARGET_INFO[target];
      if (info) {
        exportDepthMap.value = info.requiredInputs.includes("depth_sequence") || info.requiredInputs.includes("depth_map");
        exportCameraData.value = info.requiredInputs.includes("camera_data") || info.requiredInputs.includes("camera_trajectory") || info.requiredInputs.includes("camera_poses");
        exportReferenceFrame.value = info.requiredInputs.includes("reference_image") || info.requiredInputs.includes("first_frame");
        exportLastFrame.value = info.requiredInputs.includes("last_frame");
        exportControlImages.value = target.startsWith("controlnet-");
      }
    }
    async function checkConnection() {
      connectionStatus.value = "connecting";
      try {
        const client = getComfyUIClient(comfyuiServer.value);
        const connected = await client.checkConnection();
        connectionStatus.value = connected ? "connected" : "error";
      } catch {
        connectionStatus.value = "error";
      }
    }
    function applyResolutionPreset(preset) {
      width.value = preset.width;
      height.value = preset.height;
    }
    function applyFrameCountPreset(count) {
      frameCount.value = count;
      endFrame.value = Math.min(endFrame.value, count);
    }
    function randomizeSeed() {
      seed.value = Math.floor(Math.random() * 2147483647);
    }
    async function startExport() {
      isExporting.value = true;
      exportError.value = null;
      abortController.value = new AbortController();
      const config = {
        target: selectedTarget.value,
        width: width.value,
        height: height.value,
        frameCount: frameCount.value,
        fps: fps.value,
        startFrame: startFrame.value,
        endFrame: endFrame.value,
        outputDir: "",
        filenamePrefix: `weyl_${selectedTarget.value}_${Date.now()}`,
        exportDepthMap: exportDepthMap.value,
        exportControlImages: exportControlImages.value,
        exportCameraData: exportCameraData.value,
        exportReferenceFrame: exportReferenceFrame.value,
        exportLastFrame: exportLastFrame.value,
        depthFormat: depthFormat.value,
        controlType: controlType.value,
        prompt: prompt.value,
        negativePrompt: negativePrompt.value,
        seed: seed.value,
        steps: steps.value,
        cfgScale: cfgScale.value,
        comfyuiServer: comfyuiServer.value,
        autoQueueWorkflow: autoQueueWorkflow.value
      };
      try {
        const result = await exportToComfyUI(
          props.layers,
          props.cameraKeyframes,
          config,
          (progress) => {
            exportProgress.value = progress;
          }
        );
        if (result.success) {
          emit("exported", result);
        } else {
          exportError.value = result.errors.join("\n");
        }
      } catch (error) {
        exportError.value = error instanceof Error ? error.message : "Export failed";
      } finally {
        isExporting.value = false;
        abortController.value = null;
      }
    }
    function cancelExport() {
      if (abortController.value) {
        abortController.value.abort();
      }
    }
    function close() {
      if (isExporting.value) {
        cancelExport();
      }
      emit("close");
    }
    onMounted(() => {
      endFrame.value = Math.min(frameCount.value, props.totalFrames);
      checkConnection();
    });
    watch(selectedTarget, () => {
      selectTarget(selectedTarget.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: withModifiers(close, ["self"])
      }, [
        createBaseVNode("div", _hoisted_1$4, [
          createBaseVNode("header", { class: "dialog-header" }, [
            _cache[24] || (_cache[24] = createBaseVNode("h2", null, "Export to ComfyUI", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: close
            }, "")
          ]),
          createBaseVNode("nav", _hoisted_2$4, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "target" }),
              onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "target")
            }, " Target ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "output" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "output")
            }, " Output ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "generation" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "generation")
            }, " Generation ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "comfyui" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          createBaseVNode("div", _hoisted_3$4, [
            activeTab.value === "target" ? (openBlock(), createElementBlock("div", _hoisted_4$4, [
              createBaseVNode("div", _hoisted_5$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(targetCategories.value, (targets, category) => {
                  return openBlock(), createElementBlock("div", {
                    key: category,
                    class: "target-category"
                  }, [
                    createBaseVNode("h3", null, toDisplayString(category), 1),
                    createBaseVNode("div", _hoisted_6$4, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                        return openBlock(), createElementBlock("button", {
                          key: target,
                          class: normalizeClass({ selected: selectedTarget.value === target }),
                          onClick: ($event) => selectTarget(target)
                        }, toDisplayString(targetDisplayName.value[target]), 11, _hoisted_7$4);
                      }), 128))
                    ])
                  ]);
                }), 128))
              ]),
              targetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
                createBaseVNode("h4", null, toDisplayString(targetDisplayName.value[selectedTarget.value]), 1),
                createBaseVNode("div", _hoisted_9$4, [
                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "label" }, "Required:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_10$4, [
                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "label" }, "Optional:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_11$4, [
                  _cache[27] || (_cache[27] = createBaseVNode("span", { class: "label" }, "Outputs:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.outputTypes.join(", ")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "output" ? (openBlock(), createElementBlock("div", _hoisted_12$4, [
              createBaseVNode("div", _hoisted_13$4, [
                _cache[28] || (_cache[28] = createBaseVNode("h3", null, "Resolution", -1)),
                createBaseVNode("div", _hoisted_14$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(RESOLUTION_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyResolutionPreset(preset)
                    }, toDisplayString(preset.name), 9, _hoisted_15$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_16$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: width.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => width.value = $event),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: height.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => height.value = $event),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$4, [
                _cache[29] || (_cache[29] = createBaseVNode("h3", null, "Frames", -1)),
                createBaseVNode("div", _hoisted_18$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(FRAME_COUNT_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyFrameCountPreset(preset.frameCount)
                    }, toDisplayString(preset.name), 9, _hoisted_19$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_20$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: frameCount.value,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => frameCount.value = $event),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: fps.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => fps.value = $event),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: startFrame.value,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => startFrame.value = $event),
                    label: "Start",
                    min: 0,
                    max: endFrame.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  createVNode(ScrubableNumber, {
                    modelValue: endFrame.value,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => endFrame.value = $event),
                    label: "End",
                    min: startFrame.value + 1,
                    max: frameCount.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              createBaseVNode("div", _hoisted_22$4, [
                _cache[35] || (_cache[35] = createBaseVNode("h3", null, "Export Options", -1)),
                createBaseVNode("div", _hoisted_23$4, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => exportReferenceFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportReferenceFrame.value]
                    ]),
                    _cache[30] || (_cache[30] = createTextVNode(" Reference Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => exportLastFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportLastFrame.value]
                    ]),
                    _cache[31] || (_cache[31] = createTextVNode(" Last Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => exportDepthMap.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportDepthMap.value]
                    ]),
                    _cache[32] || (_cache[32] = createTextVNode(" Depth Maps ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => exportControlImages.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportControlImages.value]
                    ]),
                    _cache[33] || (_cache[33] = createTextVNode(" Control Images ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => exportCameraData.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportCameraData.value]
                    ]),
                    _cache[34] || (_cache[34] = createTextVNode(" Camera Data ", -1))
                  ])
                ])
              ]),
              exportDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_24$3, [
                _cache[36] || (_cache[36] = createBaseVNode("h3", null, "Depth Format", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => depthFormat.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(depthFormats, (fmt) => {
                    return createBaseVNode("option", {
                      key: fmt.value,
                      value: fmt.value
                    }, toDisplayString(fmt.label), 9, _hoisted_25$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, depthFormat.value]
                ])
              ])) : createCommentVNode("", true),
              exportControlImages.value ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                _cache[37] || (_cache[37] = createBaseVNode("h3", null, "Control Type", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => controlType.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(controlTypes, (ct) => {
                    return createBaseVNode("option", {
                      key: ct.value,
                      value: ct.value
                    }, toDisplayString(ct.label), 9, _hoisted_27$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, controlType.value]
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "generation" ? (openBlock(), createElementBlock("div", _hoisted_28$3, [
              createBaseVNode("div", _hoisted_29$3, [
                _cache[38] || (_cache[38] = createBaseVNode("h3", null, "Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => prompt.value = $event),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_30$3, [
                _cache[39] || (_cache[39] = createBaseVNode("h3", null, "Negative Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => negativePrompt.value = $event),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [vModelText, negativePrompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_31$1, [
                _cache[40] || (_cache[40] = createBaseVNode("h3", null, "Parameters", -1)),
                createBaseVNode("div", _hoisted_32$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: steps.value,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => steps.value = $event),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: cfgScale.value,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => cfgScale.value = $event),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_33$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: seed.value ?? 0,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => seed.value = v),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("button", {
                    class: "randomize-btn",
                    onClick: randomizeSeed
                  }, "Random")
                ])
              ])
            ])) : createCommentVNode("", true),
            activeTab.value === "comfyui" ? (openBlock(), createElementBlock("div", _hoisted_34$1, [
              createBaseVNode("div", _hoisted_35$1, [
                _cache[41] || (_cache[41] = createBaseVNode("h3", null, "Server", -1)),
                createBaseVNode("div", _hoisted_36$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => comfyuiServer.value = $event),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [vModelText, comfyuiServer.value]
                  ]),
                  createBaseVNode("button", { onClick: checkConnection }, toDisplayString(connectionStatus.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["connection-status", connectionStatus.value])
                }, [
                  connectionStatus.value === "connected" ? (openBlock(), createElementBlock("span", _hoisted_37$1, "Connected")) : connectionStatus.value === "error" ? (openBlock(), createElementBlock("span", _hoisted_38, "Connection failed")) : connectionStatus.value === "connecting" ? (openBlock(), createElementBlock("span", _hoisted_39, "Connecting...")) : (openBlock(), createElementBlock("span", _hoisted_40, "Not connected"))
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_41, [
                _cache[43] || (_cache[43] = createBaseVNode("h3", null, "Workflow", -1)),
                createBaseVNode("label", _hoisted_42, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => autoQueueWorkflow.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, autoQueueWorkflow.value]
                  ]),
                  _cache[42] || (_cache[42] = createBaseVNode("span", null, [
                    createBaseVNode("strong", null, "Auto-queue workflow"),
                    createBaseVNode("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : createCommentVNode("", true)
          ]),
          isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_43, [
            createBaseVNode("div", _hoisted_44, [
              createBaseVNode("span", null, toDisplayString(exportProgress.value?.message || "Exporting..."), 1),
              createBaseVNode("button", { onClick: cancelExport }, "Cancel")
            ]),
            createBaseVNode("div", _hoisted_45, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value?.overallProgress || 0}%` })
              }, null, 4)
            ]),
            exportProgress.value?.currentFrame ? (openBlock(), createElementBlock("div", _hoisted_46, " Frame " + toDisplayString(exportProgress.value.currentFrame) + " / " + toDisplayString(exportProgress.value.totalFrames), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          exportError.value ? (openBlock(), createElementBlock("div", _hoisted_47, toDisplayString(exportError.value), 1)) : createCommentVNode("", true),
          createBaseVNode("footer", _hoisted_48, [
            createBaseVNode("button", {
              class: "secondary",
              onClick: close
            }, "Cancel"),
            createBaseVNode("button", {
              class: "primary",
              disabled: isExporting.value,
              onClick: startExport
            }, toDisplayString(isExporting.value ? "Exporting..." : "Export"), 9, _hoisted_49)
          ])
        ])
      ]);
    };
  }
});

const ComfyUIExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-784836ff"]]);

const _hoisted_1$3 = { class: "dialog-container" };
const _hoisted_2$3 = { class: "dialog-content" };
const _hoisted_3$3 = { class: "form-row" };
const _hoisted_4$3 = { class: "tabs" };
const _hoisted_5$3 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_6$3 = { class: "form-row" };
const _hoisted_7$3 = { class: "form-row dimensions-row" };
const _hoisted_8$3 = { class: "dimension-group" };
const _hoisted_9$3 = { class: "dimension-group" };
const _hoisted_10$3 = { class: "form-row" };
const _hoisted_11$3 = { class: "aspect-info" };
const _hoisted_12$3 = { class: "form-row" };
const _hoisted_13$3 = { class: "form-row" };
const _hoisted_14$3 = { class: "resolution-info" };
const _hoisted_15$3 = { class: "form-row" };
const _hoisted_16$3 = { class: "duration-inputs" };
const _hoisted_17$3 = { class: "duration-helper" };
const _hoisted_18$3 = { class: "form-row" };
const _hoisted_19$3 = { class: "color-picker-row" };
const _hoisted_20$3 = { class: "color-label" };
const _hoisted_21$3 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_22$3 = { class: "form-row" };
const _hoisted_23$3 = { class: "form-row" };
const _hoisted_24$2 = { class: "form-row" };
const _hoisted_25$2 = { class: "motion-blur-settings" };
const _hoisted_26$2 = {
  key: 0,
  class: "motion-blur-params"
};
const _hoisted_27$2 = { class: "param-row" };
const _hoisted_28$2 = { class: "param-row" };
const _hoisted_29$2 = { class: "dialog-footer" };
const _hoisted_30$2 = { class: "preview-toggle" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const activeTab = ref("basic");
    const selectedPreset = ref("custom");
    const lockAspectRatio = ref(false);
    const aspectRatio = ref(16 / 9);
    const previewChanges = ref(false);
    const settings = ref({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: true,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: false,
      shutterAngle: 180,
      shutterPhase: -90
    });
    const frameAspectRatio = computed(() => {
      const ratio = settings.value.width / settings.value.height * settings.value.pixelAspectRatio;
      if (Math.abs(ratio - 16 / 9) < 0.01) return "16:9 (1.78)";
      if (Math.abs(ratio - 4 / 3) < 0.01) return "4:3 (1.33)";
      if (Math.abs(ratio - 1) < 0.01) return "1:1 (1.0)";
      if (Math.abs(ratio - 9 / 16) < 0.01) return "9:16 (0.56)";
      if (Math.abs(ratio - 21 / 9) < 0.01) return "21:9 (2.33)";
      return `${ratio.toFixed(2)}`;
    });
    const durationSeconds = computed(() => {
      return settings.value.frameCount / settings.value.fps;
    });
    const durationTimecode = ref("00:00:10:00");
    const resolutionInfo = computed(() => {
      const divisors = { full: 1, half: 2, third: 3, quarter: 4 };
      const d = divisors[settings.value.resolution];
      const w = Math.floor(settings.value.width / d);
      const h = Math.floor(settings.value.height / d);
      const mb = (w * h * 4 / (1024 * 1024)).toFixed(1);
      return `${w} x ${h}, ${mb} MB per 8bpc frame`;
    });
    const presets = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      "instagram_square": { width: 1080, height: 1080, fps: 30 },
      "instagram_story": { width: 1080, height: 1920, fps: 30 },
      "tiktok": { width: 1080, height: 1920, fps: 30 },
      "youtube_short": { width: 1080, height: 1920, fps: 60 },
      "sd15_512": { width: 512, height: 512, fps: 8 },
      "sd15_768": { width: 768, height: 512, fps: 8 },
      "sdxl_1024": { width: 1024, height: 1024, fps: 8 },
      "wan_480p": { width: 832, height: 480, fps: 16 },
      "wan_720p": { width: 1280, height: 720, fps: 16 }
    };
    function applyPreset() {
      const preset = presets[selectedPreset.value];
      if (preset) {
        if (preset.width) settings.value.width = preset.width;
        if (preset.height) settings.value.height = preset.height;
        if (preset.fps) settings.value.fps = preset.fps;
        aspectRatio.value = settings.value.width / settings.value.height;
        updateDurationTimecode();
      }
    }
    function onDimensionChange(changed) {
      settings.value.width = Math.round(settings.value.width / 8) * 8;
      settings.value.height = Math.round(settings.value.height / 8) * 8;
      if (lockAspectRatio.value) {
        if (changed === "width") {
          settings.value.height = Math.round(settings.value.width / aspectRatio.value / 8) * 8;
        } else {
          settings.value.width = Math.round(settings.value.height * aspectRatio.value / 8) * 8;
        }
      } else {
        aspectRatio.value = settings.value.width / settings.value.height;
      }
      selectedPreset.value = "custom";
    }
    function parseDuration() {
      const parts = durationTimecode.value.split(":").map((p) => parseInt(p) || 0);
      if (parts.length === 4) {
        const [hours, minutes, seconds, frames] = parts;
        const totalSeconds = hours * 3600 + minutes * 60 + seconds;
        settings.value.frameCount = Math.round(totalSeconds * settings.value.fps) + frames;
      } else if (parts.length === 1) {
        settings.value.frameCount = parts[0];
      }
    }
    function updateDurationTimecode() {
      const totalFrames = settings.value.frameCount;
      const fps = settings.value.fps;
      const totalSeconds = Math.floor(totalFrames / fps);
      const frames = totalFrames % Math.round(fps);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor(totalSeconds % 3600 / 60);
      const seconds = totalSeconds % 60;
      durationTimecode.value = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}:${pad(frames)}`;
    }
    function pad(n) {
      return n.toString().padStart(2, "0");
    }
    function loadCurrentSettings() {
      settings.value = {
        name: store.project?.meta?.name || "Main Comp",
        width: store.width,
        height: store.height,
        pixelAspectRatio: 1,
        fps: store.fps,
        frameCount: store.frameCount,
        resolution: "full",
        backgroundColor: store.project?.composition?.backgroundColor || "#000000",
        autoResizeToContent: store.project?.composition?.autoResizeToContent ?? true,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: false,
        shutterAngle: 180,
        shutterPhase: -90
      };
      aspectRatio.value = settings.value.width / settings.value.height;
      updateDurationTimecode();
    }
    function cancel() {
      emit("close");
    }
    function confirm() {
      emit("confirm", { ...settings.value });
      emit("close");
    }
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && !e.shiftKey) {
        confirm();
      }
    }
    watch(() => props.visible, (visible) => {
      if (visible) {
        loadCurrentSettings();
      }
    });
    watch(settings, () => {
      if (previewChanges.value && props.visible) {
        store.resizeComposition(settings.value.width, settings.value.height, settings.value.frameCount);
      }
    }, { deep: true });
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$3, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "dialog-title" }, "Composition Settings", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$3, [
              createBaseVNode("div", _hoisted_3$3, [
                _cache[21] || (_cache[21] = createBaseVNode("label", null, "Composition Name:", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => settings.value.name = $event),
                  class: "text-input full-width"
                }, null, 512), [
                  [vModelText, settings.value.name]
                ])
              ]),
              createBaseVNode("div", _hoisted_4$3, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "basic" }),
                  onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "basic")
                }, "Basic", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "advanced" }),
                  onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "advanced")
                }, "Advanced", 2)
              ]),
              activeTab.value === "basic" ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
                createBaseVNode("div", _hoisted_6$3, [
                  _cache[23] || (_cache[23] = createBaseVNode("label", null, "Preset:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedPreset.value = $event),
                    onChange: applyPreset,
                    class: "select-input"
                  }, [..._cache[22] || (_cache[22] = [
                    createBaseVNode("option", { value: "custom" }, "Custom", -1),
                    createBaseVNode("optgroup", { label: "Video" }, [
                      createBaseVNode("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                      createBaseVNode("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                      createBaseVNode("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                      createBaseVNode("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Social Media" }, [
                      createBaseVNode("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                      createBaseVNode("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                      createBaseVNode("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                      createBaseVNode("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "AI Video (ComfyUI)" }, [
                      createBaseVNode("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                      createBaseVNode("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                      createBaseVNode("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                      createBaseVNode("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                      createBaseVNode("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                    ], -1)
                  ])], 544), [
                    [vModelSelect, selectedPreset.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_7$3, [
                  createBaseVNode("div", _hoisted_8$3, [
                    _cache[24] || (_cache[24] = createBaseVNode("label", null, "Width:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => settings.value.width = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[5] || (_cache[5] = ($event) => onDimensionChange("width"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.width,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[25] || (_cache[25] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["lock-btn", { locked: lockAspectRatio.value }]),
                    onClick: _cache[6] || (_cache[6] = ($event) => lockAspectRatio.value = !lockAspectRatio.value),
                    title: "Lock Aspect Ratio"
                  }, toDisplayString(lockAspectRatio.value ? "" : ""), 3),
                  createBaseVNode("div", _hoisted_9$3, [
                    _cache[26] || (_cache[26] = createBaseVNode("label", null, "Height:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => settings.value.height = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[8] || (_cache[8] = ($event) => onDimensionChange("height"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.height,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[27] || (_cache[27] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_10$3, [
                  _cache[29] || (_cache[29] = createBaseVNode("label", null, "Pixel Aspect Ratio:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => settings.value.pixelAspectRatio = $event),
                    class: "select-input"
                  }, [..._cache[28] || (_cache[28] = [
                    createBaseVNode("option", { value: "1" }, "Square Pixels (1.0)", -1),
                    createBaseVNode("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                    createBaseVNode("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                    createBaseVNode("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.pixelAspectRatio]
                  ]),
                  createBaseVNode("span", _hoisted_11$3, "Frame Aspect Ratio: " + toDisplayString(frameAspectRatio.value), 1)
                ]),
                createBaseVNode("div", _hoisted_12$3, [
                  _cache[31] || (_cache[31] = createBaseVNode("label", null, "Frame Rate:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => settings.value.fps = $event),
                    class: "select-input short"
                  }, [..._cache[30] || (_cache[30] = [
                    createBaseVNode("option", { value: 8 }, "8", -1),
                    createBaseVNode("option", { value: 12 }, "12", -1),
                    createBaseVNode("option", { value: 15 }, "15", -1),
                    createBaseVNode("option", { value: 16 }, "16", -1),
                    createBaseVNode("option", { value: 23.976 }, "23.976", -1),
                    createBaseVNode("option", { value: 24 }, "24", -1),
                    createBaseVNode("option", { value: 25 }, "25", -1),
                    createBaseVNode("option", { value: 29.97 }, "29.97", -1),
                    createBaseVNode("option", { value: 30 }, "30", -1),
                    createBaseVNode("option", { value: 50 }, "50", -1),
                    createBaseVNode("option", { value: 59.94 }, "59.94", -1),
                    createBaseVNode("option", { value: 60 }, "60", -1)
                  ])], 512), [
                    [
                      vModelSelect,
                      settings.value.fps,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("span", { class: "unit" }, "frames per second", -1))
                ]),
                createBaseVNode("div", _hoisted_13$3, [
                  _cache[34] || (_cache[34] = createBaseVNode("label", null, "Resolution:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => settings.value.resolution = $event),
                    class: "select-input short"
                  }, [..._cache[33] || (_cache[33] = [
                    createBaseVNode("option", { value: "full" }, "Full", -1),
                    createBaseVNode("option", { value: "half" }, "Half", -1),
                    createBaseVNode("option", { value: "third" }, "Third", -1),
                    createBaseVNode("option", { value: "quarter" }, "Quarter", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.resolution]
                  ]),
                  createBaseVNode("span", _hoisted_14$3, toDisplayString(resolutionInfo.value), 1)
                ]),
                createBaseVNode("div", _hoisted_15$3, [
                  _cache[35] || (_cache[35] = createBaseVNode("label", null, "Duration:", -1)),
                  createBaseVNode("div", _hoisted_16$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => durationTimecode.value = $event),
                      class: "timecode-input",
                      placeholder: "00:00:00:00",
                      onBlur: parseDuration
                    }, null, 544), [
                      [vModelText, durationTimecode.value]
                    ]),
                    createBaseVNode("span", _hoisted_17$3, toDisplayString(settings.value.frameCount) + " frames = " + toDisplayString(durationSeconds.value.toFixed(2)) + "s ", 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$3, [
                  _cache[36] || (_cache[36] = createBaseVNode("label", null, "Background Color:", -1)),
                  createBaseVNode("div", _hoisted_19$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "color",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => settings.value.backgroundColor = $event),
                      class: "color-input"
                    }, null, 512), [
                      [vModelText, settings.value.backgroundColor]
                    ]),
                    createBaseVNode("span", _hoisted_20$3, toDisplayString(settings.value.backgroundColor), 1)
                  ])
                ])
              ])) : createCommentVNode("", true),
              activeTab.value === "advanced" ? (openBlock(), createElementBlock("div", _hoisted_21$3, [
                createBaseVNode("div", _hoisted_22$3, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => settings.value.autoResizeToContent = $event)
                    }, null, 512), [
                      [vModelCheckbox, settings.value.autoResizeToContent]
                    ]),
                    _cache[37] || (_cache[37] = createTextVNode(" Auto-resize composition when importing video ", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_23$3, [
                  _cache[38] || (_cache[38] = createBaseVNode("label", null, "Start Timecode:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => settings.value.startTimecode = $event),
                    class: "timecode-input",
                    placeholder: "00:00:00:00"
                  }, null, 512), [
                    [vModelText, settings.value.startTimecode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$2, [
                  _cache[44] || (_cache[44] = createBaseVNode("label", null, "Motion Blur:", -1)),
                  createBaseVNode("div", _hoisted_25$2, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => settings.value.motionBlurEnabled = $event)
                      }, null, 512), [
                        [vModelCheckbox, settings.value.motionBlurEnabled]
                      ]),
                      _cache[39] || (_cache[39] = createTextVNode(" Enable Motion Blur ", -1))
                    ]),
                    settings.value.motionBlurEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$2, [
                      createBaseVNode("div", _hoisted_27$2, [
                        _cache[40] || (_cache[40] = createBaseVNode("label", null, "Shutter Angle:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => settings.value.shutterAngle = $event),
                          min: "0",
                          max: "720",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterAngle,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[41] || (_cache[41] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ]),
                      createBaseVNode("div", _hoisted_28$2, [
                        _cache[42] || (_cache[42] = createBaseVNode("label", null, "Shutter Phase:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => settings.value.shutterPhase = $event),
                          min: "-360",
                          max: "360",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterPhase,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[43] || (_cache[43] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_29$2, [
              createBaseVNode("div", _hoisted_30$2, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => previewChanges.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, previewChanges.value]
                  ]),
                  _cache[45] || (_cache[45] = createTextVNode(" Preview ", -1))
                ])
              ]),
              createBaseVNode("div", { class: "dialog-actions" }, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: confirm
                }, "OK")
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const CompositionSettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-76356b13"]]);

const logger$1 = createLogger("MotionIntentResolver");
const SYSTEM_PROMPT = `You are a motion graphics expert analyzing images for camera movements and animation paths.

Given an image, suggest motion paths and camera trajectories that would create compelling visual effects.

ALWAYS respond in valid JSON format with this structure:
{
  "description": "Brief description of suggested motion",
  "confidence": 0.0-1.0,
  "cameraIntents": [...],
  "splineIntents": [...],
  "particleIntents": [...],
  "layerIntents": [...]
}

For spline/path suggestions, provide control points as:
{
  "suggestedPoints": [
    { "id": "p1", "x": 100, "y": 200, "depth": 0.5, "handleIn": null, "handleOut": null, "type": "smooth" }
  ]
}

Consider:
- Depth information if available (closer = lower depth values)
- Subject positions and focal points
- Natural motion paths that follow scene geometry
- Parallax opportunities based on depth layers
`;
const PATH_SUGGESTION_PROMPT = `Analyze this image and suggest camera/motion paths.

Consider:
1. Main subjects and their positions
2. Depth layers (foreground, midground, background)
3. Natural movement paths that would be visually interesting
4. Points of interest to orbit around or move between

Suggest 2-3 different trajectory options with varying complexity.`;
class MotionIntentResolver {
  config;
  lastResult = null;
  constructor(config) {
    this.config = {
      modelId: config?.modelId ?? "rule-based",
      apiEndpoint: config?.apiEndpoint,
      apiKey: config?.apiKey,
      maxTokens: config?.maxTokens ?? 2048,
      temperature: config?.temperature ?? 0.7
    };
  }
  /**
   * Resolve a user prompt into structured motion intents
   */
  async resolve(prompt, context, modelOverride) {
    const modelId = modelOverride ?? this.config.modelId;
    logger$1.info(`Resolving motion intent with ${modelId}:`, prompt);
    try {
      let result;
      switch (modelId) {
        case "rule-based":
          result = await this.resolveWithRules(prompt, context);
          break;
        case "gpt-4v":
        case "gpt-4o":
          result = await this.resolveWithOpenAI(prompt, context, modelId);
          break;
        case "claude-vision":
          result = await this.resolveWithClaude(prompt, context);
          break;
        case "qwen-vl":
        case "qwen2-vl":
        case "llava":
        case "local-vlm":
          result = await this.resolveWithLocalVLM(prompt, context, modelId);
          break;
        default:
          result = await this.resolveWithRules(prompt, context);
      }
      this.lastResult = result;
      return result;
    } catch (error) {
      logger$1.error("Motion intent resolution failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  /**
   * Suggest paths based on image analysis
   * This is the main entry point for "suggest trajectories across image"
   */
  async suggestPaths(context, modelOverride) {
    return this.resolve(PATH_SUGGESTION_PROMPT, context, modelOverride);
  }
  // ============================================================================
  // RULE-BASED FALLBACK
  // ============================================================================
  async resolveWithRules(prompt, context) {
    const lowerPrompt = prompt.toLowerCase();
    const intents = {
      description: "Rule-based motion suggestion",
      confidence: 0.6,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: []
    };
    const cameraIntents = [];
    if (lowerPrompt.includes("dolly") || lowerPrompt.includes("push in") || lowerPrompt.includes("pull out")) {
      cameraIntents.push({
        type: "dolly",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "z",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("pan") || lowerPrompt.includes("sweep")) {
      cameraIntents.push({
        type: "pan",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "y",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("orbit") || lowerPrompt.includes("around")) {
      cameraIntents.push({
        type: "orbit",
        intensity: this.extractIntensity(lowerPrompt),
        durationFrames: context.frameCount,
        orbitCenter: { x: context.width / 2, y: context.height / 2, z: 0 },
        suggestedEasing: "linear"
      });
    }
    if (lowerPrompt.includes("drift") || lowerPrompt.includes("float") || lowerPrompt.includes("subtle")) {
      cameraIntents.push({
        type: "drift",
        intensity: "very_subtle",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("handheld") || lowerPrompt.includes("shake")) {
      cameraIntents.push({
        type: "handheld",
        intensity: this.extractIntensity(lowerPrompt),
        noiseAmount: lowerPrompt.includes("light") ? 0.3 : 0.6,
        durationFrames: context.frameCount
      });
    }
    const splineIntents = [];
    if (context.depthMap || lowerPrompt.includes("path") || lowerPrompt.includes("trajectory")) {
      const defaultPath = this.generateDefaultPath(context);
      splineIntents.push({
        usage: "camera_path",
        smoothness: 0.8,
        complexity: defaultPath.length,
        worldSpace: true,
        suggestedPoints: defaultPath,
        closed: false
      });
      if (context.depthMap) {
        const depthPath = this.generateDepthBasedPath(context);
        splineIntents.push({
          usage: "camera_path",
          smoothness: 0.9,
          complexity: depthPath.length,
          worldSpace: true,
          suggestedPoints: depthPath,
          closed: false
        });
      }
    }
    const particleIntents = [];
    if (lowerPrompt.includes("particle") || lowerPrompt.includes("dust") || lowerPrompt.includes("snow")) {
      particleIntents.push({
        behavior: lowerPrompt.includes("snow") ? "snow" : lowerPrompt.includes("dust") ? "dust" : "drift",
        intensity: 0.5,
        spread: 45,
        lifetime: 120
      });
    }
    return {
      ...intents,
      cameraIntents,
      splineIntents,
      particleIntents
    };
  }
  extractIntensity(prompt) {
    if (prompt.includes("very subtle") || prompt.includes("barely")) return "very_subtle";
    if (prompt.includes("subtle") || prompt.includes("gentle") || prompt.includes("soft")) return "subtle";
    if (prompt.includes("dramatic") || prompt.includes("intense") || prompt.includes("strong")) return "dramatic";
    if (prompt.includes("bold") || prompt.includes("dynamic")) return "strong";
    return "medium";
  }
  generateDefaultPath(context) {
    const { width, height } = context;
    const padding = Math.min(width, height) * 0.1;
    return [
      this.createControlPoint("p1", padding, height / 2, 0),
      this.createControlPoint("p2", width * 0.33, height * 0.3, 0.3),
      this.createControlPoint("p3", width * 0.66, height * 0.7, 0.6),
      this.createControlPoint("p4", width - padding, height / 2, 1)
    ];
  }
  generateDepthBasedPath(context) {
    const { width, height, depthMap } = context;
    if (!depthMap) {
      return this.generateDefaultPath(context);
    }
    const points = [];
    const numPoints = 5;
    for (let i = 0; i < numPoints; i++) {
      const t = i / (numPoints - 1);
      const x = width * (0.2 + t * 0.6);
      const y = height * (0.3 + Math.sin(t * Math.PI) * 0.4);
      const pixelIndex = Math.floor(y) * width + Math.floor(x);
      const depth = depthMap[pixelIndex] ?? 0.5;
      points.push(this.createControlPoint(`dp${i}`, x, y, depth));
    }
    return points;
  }
  createControlPoint(id, x, y, depth) {
    return {
      id,
      x,
      y,
      depth,
      handleIn: null,
      handleOut: null,
      type: "smooth"
    };
  }
  // ============================================================================
  // OPENAI GPT-4V / GPT-4o
  // ============================================================================
  async resolveWithOpenAI(prompt, context, model) {
    if (!this.config.apiKey) {
      logger$1.warn("OpenAI API key not configured, falling back to rule-based");
      return this.resolveWithRules(prompt, context);
    }
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: imageBase64 ? [
          { type: "text", text: prompt },
          { type: "image_url", image_url: { url: `data:image/png;base64,${imageBase64}` } }
        ] : prompt
      }
    ];
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: model === "gpt-4o" ? "gpt-4o" : "gpt-4-vision-preview",
          messages,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      return this.parseAIResponse(content, prompt);
    } catch (error) {
      logger$1.error("OpenAI API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // CLAUDE VISION
  // ============================================================================
  async resolveWithClaude(prompt, context) {
    if (!this.config.apiKey) {
      logger$1.warn("Anthropic API key not configured, falling back to rule-based");
      return this.resolveWithRules(prompt, context);
    }
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const content = imageBase64 ? [
      { type: "image", source: { type: "base64", media_type: "image/png", data: imageBase64 } },
      { type: "text", text: prompt }
    ] : [{ type: "text", text: prompt }];
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.config.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: this.config.maxTokens,
          system: SYSTEM_PROMPT,
          messages: [{ role: "user", content }]
        })
      });
      if (!response.ok) {
        throw new Error(`Anthropic API error: ${response.status}`);
      }
      const data = await response.json();
      const responseContent = data.content[0]?.text;
      return this.parseAIResponse(responseContent, prompt);
    } catch (error) {
      logger$1.error("Anthropic API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // LOCAL VLM (via ComfyUI or local endpoint)
  // ============================================================================
  async resolveWithLocalVLM(prompt, context, model) {
    const endpoint = this.config.apiEndpoint ?? "http://localhost:8188/api/vlm";
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model,
          prompt: `${SYSTEM_PROMPT}

User request: ${prompt}`,
          image: imageBase64,
          max_tokens: this.config.maxTokens
        })
      });
      if (!response.ok) {
        throw new Error(`Local VLM API error: ${response.status}`);
      }
      const data = await response.json();
      return this.parseAIResponse(data.response ?? data.text ?? data.content, prompt);
    } catch (error) {
      logger$1.error("Local VLM API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // RESPONSE PARSING
  // ============================================================================
  parseAIResponse(content, originalPrompt) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          description: parsed.description ?? "AI-generated motion suggestion",
          confidence: parsed.confidence ?? 0.8,
          cameraIntents: parsed.cameraIntents ?? [],
          splineIntents: parsed.splineIntents ?? [],
          particleIntents: parsed.particleIntents ?? [],
          layerIntents: parsed.layerIntents ?? [],
          rawResponse: content
        };
      }
    } catch (error) {
      logger$1.warn("Failed to parse AI response as JSON:", error);
    }
    return {
      description: content.slice(0, 200),
      confidence: 0.5,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: [],
      rawResponse: content
    };
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  imageDataToBase64(imageData) {
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL("image/png").split(",")[1];
  }
  /**
   * Get last resolution result
   */
  getLastResult() {
    return this.lastResult;
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
const motionIntentResolver = new MotionIntentResolver();

const logger = createLogger("MotionIntentTranslator");
const INTENSITY_TO_DISTANCE = {
  very_subtle: 10,
  subtle: 30,
  medium: 80,
  strong: 200,
  dramatic: 500
};
const INTENSITY_TO_ROTATION = {
  very_subtle: 2,
  subtle: 5,
  medium: 15,
  strong: 45,
  dramatic: 90
};
function getEasingHandles(easing, duration) {
  const third = duration / 3;
  switch (easing) {
    case "linear":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeIn":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "easeOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeInOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "bounce":
      return {
        inHandle: { frame: -third * 0.5, value: 0, enabled: true },
        outHandle: { frame: third * 0.5, value: 0, enabled: true }
      };
    case "elastic":
      return {
        inHandle: { frame: -third * 0.3, value: 0, enabled: true },
        outHandle: { frame: third * 0.3, value: 0, enabled: true }
      };
    default:
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
  }
}
class MotionIntentTranslator {
  /**
   * Translate a camera motion intent to keyframes
   */
  translateCameraIntent(intent, cameraLayerId, currentPosition, compositionFrameCount) {
    const duration = intent.durationFrames ?? compositionFrameCount;
    const distance = INTENSITY_TO_DISTANCE[intent.intensity];
    const rotation = INTENSITY_TO_ROTATION[intent.intensity];
    const easing = intent.suggestedEasing ?? "easeInOut";
    const batches = [];
    switch (intent.type) {
      case "dolly":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.z",
            currentPosition.z,
            currentPosition.z + (intent.axis === "z" ? distance : 0),
            0,
            duration,
            easing
          )
        );
        break;
      case "truck":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.x",
            currentPosition.x,
            currentPosition.x + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pedestal":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.y",
            currentPosition.y,
            currentPosition.y + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pan":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.y",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "tilt":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.x",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "roll":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.z",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "zoom":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "camera.fov",
            60,
            60 - distance * 0.5,
            // Narrower FOV = zoom in
            0,
            duration,
            easing
          )
        );
        break;
      case "drift":
        batches.push(
          ...this.createDriftKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "handheld":
        batches.push(
          ...this.createHandheldKeyframes(
            cameraLayerId,
            currentPosition,
            duration,
            intent.noiseAmount ?? 0.5
          )
        );
        break;
      case "orbit":
        if (intent.orbitCenter) {
          batches.push(
            ...this.createOrbitKeyframes(
              cameraLayerId,
              currentPosition,
              intent.orbitCenter,
              duration,
              intent.intensity
            )
          );
        }
        break;
      case "crane":
        batches.push(
          ...this.createCraneKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "follow_path":
        if (intent.suggestedPath) {
          logger.info("Camera path following requires spline layer creation");
        }
        break;
    }
    return batches;
  }
  /**
   * Translate a spline intent to a spline layer configuration
   */
  translateSplineIntent(intent, compositionWidth, compositionHeight) {
    const controlPoints = intent.suggestedPoints.map((p, i) => ({
      id: p.id ?? `sp_${i}`,
      x: p.x,
      y: p.y,
      depth: p.depth ?? 0,
      handleIn: this.generateHandle(intent.suggestedPoints, i, -1, intent.smoothness),
      handleOut: this.generateHandle(intent.suggestedPoints, i, 1, intent.smoothness),
      type: p.type ?? "smooth"
    }));
    return {
      keyframeBatches: [],
      newSplines: [
        {
          name: `AI Path - ${intent.usage}`,
          points: controlPoints,
          closed: intent.closed
        }
      ]
    };
  }
  /**
   * Translate a particle intent to emitter configuration
   */
  translateParticleIntent(intent, compositionWidth, compositionHeight) {
    const baseConfig = {
      emissionRate: intent.intensity * 20,
      particleLifetime: intent.lifetime ?? 60,
      spread: intent.spread ?? 30
    };
    switch (intent.behavior) {
      case "snow":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 50,
          speedVariance: 20,
          gravity: 0.1
        });
        break;
      case "rain":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 200,
          speedVariance: 30,
          gravity: 0.5
        });
        break;
      case "dust":
        Object.assign(baseConfig, {
          direction: 0,
          speed: 20,
          speedVariance: 15,
          gravity: 0
        });
        break;
      case "fireflies":
        Object.assign(baseConfig, {
          direction: 90,
          speed: 30,
          speedVariance: 20,
          gravity: -0.05
        });
        break;
      case "explosion":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 300,
          speedVariance: 100,
          initialBurst: 50,
          emissionRate: 0
        });
        break;
      case "vortex":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 100
          // Would need vortex force field
        });
        break;
    }
    return {
      keyframeBatches: [],
      newLayers: [
        {
          type: "particles",
          name: `AI Particles - ${intent.behavior}`,
          config: baseConfig
        }
      ]
    };
  }
  /**
   * Translate a layer motion intent to keyframes
   */
  translateLayerIntent(intent, layer, compositionFrameCount) {
    const duration = compositionFrameCount;
    const amplitude = intent.amplitude;
    const frequency = intent.frequency ?? 1;
    const batches = [];
    switch (intent.motionType) {
      case "parallax":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 50,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "float":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.y",
            0,
            amplitude * 30,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "sway":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 40,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "breathe":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.x",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          ),
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.y",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "pulse":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "opacity",
            100,
            100 - amplitude * 30,
            duration,
            frequency * 2,
            intent.phase ?? 0
          )
        );
        break;
      case "rotate":
        batches.push(
          this.createPositionKeyframes(
            layer.id,
            "transform.rotation.z",
            0,
            360 * frequency,
            0,
            duration,
            "linear"
          )
        );
        break;
    }
    return batches;
  }
  // ============================================================================
  // KEYFRAME GENERATORS
  // ============================================================================
  createPositionKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    const handles = getEasingHandles(easing, endFrame - startFrame);
    return {
      layerId,
      propertyPath,
      keyframes: [
        {
          id: `kf_${layerId}_${propertyPath}_0`,
          frame: startFrame,
          value: startValue,
          interpolation: easing === "linear" ? "linear" : "bezier",
          ...handles,
          controlMode: "smooth"
        },
        {
          id: `kf_${layerId}_${propertyPath}_1`,
          frame: endFrame,
          value: endValue,
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: false },
          outHandle: { frame: 0, value: 0, enabled: false },
          controlMode: "smooth"
        }
      ]
    };
  }
  createRotationKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    return this.createPositionKeyframes(
      layerId,
      propertyPath,
      startValue,
      endValue,
      startFrame,
      endFrame,
      easing
    );
  }
  createOscillatingKeyframes(layerId, propertyPath, centerValue, amplitude, duration, cycles, phase) {
    const keyframes = [];
    const framesPerCycle = duration / cycles;
    const quarterCycle = framesPerCycle / 4;
    for (let i = 0; i <= cycles * 4; i++) {
      const frame = Math.round(i * quarterCycle);
      if (frame > duration) break;
      const sinePhase = (i + phase * 4) % 4;
      let value;
      switch (sinePhase) {
        case 0:
          value = centerValue;
          break;
        case 1:
          value = centerValue + amplitude;
          break;
        case 2:
          value = centerValue;
          break;
        case 3:
          value = centerValue - amplitude;
          break;
        default:
          value = centerValue;
      }
      keyframes.push({
        id: `kf_${layerId}_${propertyPath}_${i}`,
        frame,
        value,
        interpolation: "bezier",
        inHandle: { frame: -quarterCycle * 0.5, value: 0, enabled: true },
        outHandle: { frame: quarterCycle * 0.5, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return { layerId, propertyPath, keyframes };
  }
  createDriftKeyframes(layerId, startPosition, duration, intensity) {
    const distance = INTENSITY_TO_DISTANCE[intensity] * 0.3;
    return [
      this.createOscillatingKeyframes(layerId, "transform.position.x", startPosition.x, distance, duration, 0.5, 0),
      this.createOscillatingKeyframes(layerId, "transform.position.y", startPosition.y, distance * 0.7, duration, 0.3, 0.25),
      this.createOscillatingKeyframes(layerId, "transform.position.z", startPosition.z, distance * 0.5, duration, 0.4, 0.5)
    ];
  }
  createHandheldKeyframes(layerId, startPosition, duration, noiseAmount) {
    const seed = this.hashString(layerId);
    const amplitude = noiseAmount * 5;
    const keyframes = [];
    for (const axis of ["x", "y", "z"]) {
      const axisKeyframes = [];
      const baseValue = startPosition[axis];
      const numKeyframes = Math.floor(duration / 4);
      for (let i = 0; i <= numKeyframes; i++) {
        const frame = Math.min(i * 4, duration);
        const noise = this.deterministicNoise(seed, axis, frame) * amplitude;
        axisKeyframes.push({
          id: `kf_${layerId}_handheld_${axis}_${i}`,
          frame,
          value: baseValue + noise,
          interpolation: "bezier",
          inHandle: { frame: -1, value: 0, enabled: true },
          outHandle: { frame: 1, value: 0, enabled: true },
          controlMode: "smooth"
        });
      }
      keyframes.push({
        layerId,
        propertyPath: `transform.position.${axis}`,
        keyframes: axisKeyframes
      });
    }
    return keyframes;
  }
  createOrbitKeyframes(layerId, startPosition, center, duration, intensity) {
    const radius = Math.sqrt(
      Math.pow(startPosition.x - center.x, 2) + Math.pow(startPosition.z - center.z, 2)
    ) || INTENSITY_TO_DISTANCE[intensity];
    const numKeyframes = 8;
    const xKeyframes = [];
    const zKeyframes = [];
    for (let i = 0; i <= numKeyframes; i++) {
      const frame = Math.round(i / numKeyframes * duration);
      const angle = i / numKeyframes * Math.PI * 2;
      xKeyframes.push({
        id: `kf_${layerId}_orbit_x_${i}`,
        frame,
        value: center.x + Math.cos(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
      zKeyframes.push({
        id: `kf_${layerId}_orbit_z_${i}`,
        frame,
        value: center.z + Math.sin(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return [
      { layerId, propertyPath: "transform.position.x", keyframes: xKeyframes },
      { layerId, propertyPath: "transform.position.z", keyframes: zKeyframes }
    ];
  }
  createCraneKeyframes(layerId, startPosition, duration, intensity) {
    const height = INTENSITY_TO_DISTANCE[intensity];
    return [
      this.createPositionKeyframes(
        layerId,
        "transform.position.y",
        startPosition.y,
        startPosition.y + height,
        0,
        duration / 2,
        "easeOut"
      ),
      this.createPositionKeyframes(
        layerId,
        "transform.position.z",
        startPosition.z,
        startPosition.z + height * 0.5,
        0,
        duration,
        "easeInOut"
      )
    ];
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  generateHandle(points, index, direction, smoothness) {
    const prevPoint = points[index - 1];
    const nextPoint = points[index + 1];
    const currentPoint = points[index];
    if (!currentPoint) return null;
    let tangentX = 0;
    let tangentY = 0;
    if (prevPoint && nextPoint) {
      tangentX = (nextPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else if (nextPoint) {
      tangentX = (nextPoint.x - currentPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - currentPoint.y) * 0.25 * smoothness;
    } else if (prevPoint) {
      tangentX = (currentPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (currentPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else {
      return null;
    }
    return {
      x: tangentX * direction,
      y: tangentY * direction
    };
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  deterministicNoise(seed, axis, frame) {
    const axisOffset = axis === "x" ? 0 : axis === "y" ? 1e3 : 2e3;
    const combined = seed + axisOffset + frame * 13;
    const x = Math.sin(combined) * 1e4;
    return x - Math.floor(x) - 0.5;
  }
}
const motionIntentTranslator = new MotionIntentTranslator();

const _hoisted_1$2 = { class: "dialog-container" };
const _hoisted_2$2 = { class: "dialog-content" };
const _hoisted_3$2 = { class: "form-section" };
const _hoisted_4$2 = { class: "form-row" };
const _hoisted_5$2 = {
  key: 0,
  class: "form-row api-key-row"
};
const _hoisted_6$2 = ["placeholder"];
const _hoisted_7$2 = {
  key: 1,
  class: "form-row"
};
const _hoisted_8$2 = { class: "form-section" };
const _hoisted_9$2 = { class: "prompt-presets" };
const _hoisted_10$2 = ["onClick"];
const _hoisted_11$2 = {
  key: 0,
  class: "form-section"
};
const _hoisted_12$2 = {
  key: 0,
  class: "spinner"
};
const _hoisted_13$2 = { class: "status-text" };
const _hoisted_14$2 = {
  key: 1,
  class: "form-section"
};
const _hoisted_15$2 = { class: "suggestions-list" };
const _hoisted_16$2 = ["onClick"];
const _hoisted_17$2 = { class: "suggestion-header" };
const _hoisted_18$2 = { class: "suggestion-type" };
const _hoisted_19$2 = { class: "suggestion-confidence" };
const _hoisted_20$2 = { class: "suggestion-description" };
const _hoisted_21$2 = { class: "suggestion-details" };
const _hoisted_22$2 = { key: 0 };
const _hoisted_23$2 = { key: 1 };
const _hoisted_24$1 = { class: "form-section preview-section" };
const _hoisted_25$1 = { class: "dialog-footer" };
const _hoisted_26$1 = { class: "footer-left" };
const _hoisted_27$1 = ["disabled"];
const _hoisted_28$1 = {
  key: 0,
  class: "spinner-small"
};
const _hoisted_29$1 = { class: "dialog-actions" };
const _hoisted_30$1 = ["disabled"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "PathSuggestionDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "accept", "preview"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectedModel = ref("rule-based");
    const apiKey = ref("");
    const localEndpoint = ref("http://localhost:8188/api/vlm");
    const prompt = ref("");
    const selectedPreset = ref(null);
    const status = ref("idle");
    const statusMessage = ref("");
    const suggestions = ref([]);
    const selectedSuggestion = ref(null);
    const showPreview = ref(true);
    const promptPresets = [
      { id: "dolly", label: "Dolly", prompt: "Gentle dolly in towards the subject" },
      { id: "orbit", label: "Orbit", prompt: "Slow orbit around the center point" },
      { id: "drift", label: "Drift", prompt: "Subtle floating drift movement" },
      { id: "handheld", label: "Handheld", prompt: "Organic handheld camera shake" },
      { id: "pan", label: "Pan", prompt: "Smooth horizontal pan across the scene" },
      { id: "crane", label: "Crane", prompt: "Vertical crane movement" }
    ];
    const requiresApiKey = computed(() => {
      return ["gpt-4v", "gpt-4o", "claude-vision"].includes(selectedModel.value);
    });
    const isLocalModel = computed(() => {
      return ["qwen-vl", "qwen2-vl", "llava", "local-vlm"].includes(selectedModel.value);
    });
    const apiKeyPlaceholder = computed(() => {
      if (selectedModel.value.startsWith("gpt-")) return "sk-...";
      if (selectedModel.value === "claude-vision") return "sk-ant-...";
      return "API Key";
    });
    function selectPreset(preset) {
      selectedPreset.value = preset.id;
      prompt.value = preset.prompt;
    }
    async function testConnection() {
      status.value = "loading";
      statusMessage.value = "Testing connection...";
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiKey: apiKey.value || void 0,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const testContext = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: [],
          currentFrame: store.currentFrame
        };
        await motionIntentResolver.resolve("test", testContext, selectedModel.value);
        status.value = "success";
        statusMessage.value = "Connection successful!";
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Connection failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    async function loadDepthMapAsFloat32Array(depthMapUrl) {
      if (!depthMapUrl) return void 0;
      try {
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = reject;
          img.src = depthMapUrl;
        });
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) return void 0;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const depthArray = new Float32Array(img.width * img.height);
        for (let i = 0; i < depthArray.length; i++) {
          const r = imageData.data[i * 4];
          const g = imageData.data[i * 4 + 1];
          const b = imageData.data[i * 4 + 2];
          depthArray[i] = (r + g + b) / (3 * 255);
        }
        return depthArray;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to load depth map:", error);
        return void 0;
      }
    }
    async function captureCurrentFrameImage() {
      try {
        const canvas = document.querySelector(".viewport-content canvas");
        if (!canvas) return void 0;
        const ctx = canvas.getContext("2d") || canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!ctx) return void 0;
        if (ctx instanceof WebGLRenderingContext || ctx instanceof WebGL2RenderingContext) {
          const width = canvas.width;
          const height = canvas.height;
          const pixels = new Uint8Array(width * height * 4);
          ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
          const imageData = new ImageData(width, height);
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const srcIdx = ((height - 1 - y) * width + x) * 4;
              const dstIdx = (y * width + x) * 4;
              imageData.data[dstIdx] = pixels[srcIdx];
              imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
              imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
              imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
          }
          return imageData;
        }
        if (ctx instanceof CanvasRenderingContext2D) {
          return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        return void 0;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to capture frame:", error);
        return void 0;
      }
    }
    async function suggestPaths() {
      if (!prompt.value.trim()) {
        status.value = "error";
        statusMessage.value = "Please enter a motion description";
        return;
      }
      status.value = "loading";
      statusMessage.value = "Analyzing scene and generating suggestions...";
      suggestions.value = [];
      selectedSuggestion.value = null;
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiKey: apiKey.value || void 0,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const depthMap = await loadDepthMapAsFloat32Array(store.depthMap);
        const frameImage = await captureCurrentFrameImage();
        const context = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: store.selectedLayerIds,
          currentFrame: store.currentFrame,
          depthMap,
          frameImage
        };
        const result = await motionIntentResolver.resolve(prompt.value, context, selectedModel.value);
        const items = [];
        if (result.cameraIntents) {
          for (const intent of result.cameraIntents) {
            items.push({
              type: "camera",
              description: `${intent.type} motion - ${intent.intensity}`,
              confidence: 0.8,
              duration: intent.durationFrames,
              intent
            });
          }
        }
        if (result.splineIntents) {
          for (const intent of result.splineIntents) {
            items.push({
              type: "spline",
              description: `${intent.usage} - ${intent.suggestedPoints.length} point path`,
              confidence: 0.9,
              points: intent.suggestedPoints.map((p) => ({ x: p.x, y: p.y, depth: p.depth })),
              intent
            });
          }
        }
        suggestions.value = items;
        status.value = "success";
        statusMessage.value = `Found ${items.length} suggestion${items.length !== 1 ? "s" : ""}`;
        if (items.length > 0) {
          selectedSuggestion.value = 0;
        }
        if (showPreview.value) {
          emit("preview", suggestions.value);
        }
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    function acceptSuggestion() {
      if (selectedSuggestion.value === null) return;
      const suggestion = suggestions.value[selectedSuggestion.value];
      const result = {
        keyframes: [],
        splines: []
      };
      if (suggestion.type === "camera") {
        const translation = motionIntentTranslator.translateCameraIntent(
          suggestion.intent,
          store.width,
          store.height,
          store.frameCount
        );
        result.keyframes = translation.keyframeBatches;
      } else if (suggestion.type === "spline") {
        const translation = motionIntentTranslator.translateSplineIntent(
          suggestion.intent,
          store.width,
          store.height
        );
        result.splines = translation.newSplines || [];
      }
      emit("accept", result);
      emit("close");
    }
    function cancel() {
      emit("close");
    }
    watch(showPreview, (show) => {
      if (show && suggestions.value.length > 0) {
        emit("preview", suggestions.value);
      } else {
        emit("preview", []);
      }
    });
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && e.ctrlKey) {
        suggestPaths();
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$2, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "dialog-title" }, "AI Path Suggestion", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$2, [
              createBaseVNode("div", _hoisted_3$2, [
                _cache[9] || (_cache[9] = createBaseVNode("label", { class: "section-label" }, "Vision Model", -1)),
                createBaseVNode("div", _hoisted_4$2, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
                    class: "select-input"
                  }, [..._cache[6] || (_cache[6] = [
                    createBaseVNode("option", { value: "rule-based" }, "Rule-Based (Offline)", -1),
                    createBaseVNode("optgroup", { label: "Cloud Models" }, [
                      createBaseVNode("option", { value: "gpt-4o" }, "OpenAI GPT-4o"),
                      createBaseVNode("option", { value: "gpt-4v" }, "OpenAI GPT-4V"),
                      createBaseVNode("option", { value: "claude-vision" }, "Claude Vision")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Local Models" }, [
                      createBaseVNode("option", { value: "qwen2-vl" }, "Qwen2-VL"),
                      createBaseVNode("option", { value: "qwen-vl" }, "Qwen-VL"),
                      createBaseVNode("option", { value: "llava" }, "LLaVA"),
                      createBaseVNode("option", { value: "local-vlm" }, "Custom Local VLM")
                    ], -1)
                  ])], 512), [
                    [vModelSelect, selectedModel.value]
                  ])
                ]),
                requiresApiKey.value ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
                  _cache[7] || (_cache[7] = createBaseVNode("label", null, "API Key:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "password",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => apiKey.value = $event),
                    class: "text-input",
                    placeholder: apiKeyPlaceholder.value
                  }, null, 8, _hoisted_6$2), [
                    [vModelText, apiKey.value]
                  ]),
                  createBaseVNode("button", {
                    class: "btn btn-small",
                    onClick: testConnection
                  }, "Test")
                ])) : createCommentVNode("", true),
                isLocalModel.value ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                  _cache[8] || (_cache[8] = createBaseVNode("label", null, "Endpoint:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localEndpoint.value = $event),
                    class: "text-input",
                    placeholder: "http://localhost:8188/api/vlm"
                  }, null, 512), [
                    [vModelText, localEndpoint.value]
                  ])
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_8$2, [
                _cache[10] || (_cache[10] = createBaseVNode("label", { class: "section-label" }, "Motion Description", -1)),
                createBaseVNode("div", _hoisted_9$2, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(promptPresets, (preset) => {
                    return createBaseVNode("button", {
                      key: preset.id,
                      class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                      onClick: ($event) => selectPreset(preset)
                    }, toDisplayString(preset.label), 11, _hoisted_10$2);
                  }), 64))
                ]),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => prompt.value = $event),
                  class: "prompt-input",
                  rows: "3",
                  placeholder: "Describe the motion you want, e.g., 'dolly in slowly' or 'orbit around the subject'"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              status.value !== "idle" ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-bar", status.value])
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_12$2)) : createCommentVNode("", true),
                  createBaseVNode("span", _hoisted_13$2, toDisplayString(statusMessage.value), 1)
                ], 2)
              ])) : createCommentVNode("", true),
              suggestions.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
                _cache[11] || (_cache[11] = createBaseVNode("label", { class: "section-label" }, "Suggested Paths", -1)),
                createBaseVNode("div", _hoisted_15$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(suggestions.value, (suggestion, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["suggestion-item", { selected: selectedSuggestion.value === index }]),
                      onClick: ($event) => selectedSuggestion.value = index
                    }, [
                      createBaseVNode("div", _hoisted_17$2, [
                        createBaseVNode("span", _hoisted_18$2, toDisplayString(suggestion.type), 1),
                        createBaseVNode("span", _hoisted_19$2, toDisplayString(Math.round(suggestion.confidence * 100)) + "% ", 1)
                      ]),
                      createBaseVNode("div", _hoisted_20$2, toDisplayString(suggestion.description), 1),
                      createBaseVNode("div", _hoisted_21$2, [
                        suggestion.points ? (openBlock(), createElementBlock("span", _hoisted_22$2, toDisplayString(suggestion.points.length) + " points", 1)) : createCommentVNode("", true),
                        suggestion.duration ? (openBlock(), createElementBlock("span", _hoisted_23$2, toDisplayString(suggestion.duration) + " frames", 1)) : createCommentVNode("", true)
                      ])
                    ], 10, _hoisted_16$2);
                  }), 128))
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_24$1, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showPreview.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, showPreview.value]
                  ]),
                  _cache[12] || (_cache[12] = createTextVNode(" Show preview on canvas ", -1))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_25$1, [
              createBaseVNode("div", _hoisted_26$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: suggestPaths,
                  disabled: status.value === "loading"
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_28$1)) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(status.value === "loading" ? "Analyzing..." : "Suggest Paths"), 1)
                ], 8, _hoisted_27$1)
              ]),
              createBaseVNode("div", _hoisted_29$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: acceptSuggestion,
                  disabled: selectedSuggestion.value === null
                }, " Accept ", 8, _hoisted_30$1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const PathSuggestionDialog = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-f14ac83f"]]);

const _hoisted_1$1 = ["viewBox"];
const _hoisted_2$1 = ["width", "height"];
const _hoisted_3$1 = ["d"];
const _hoisted_4$1 = {
  key: 0,
  width: "100%",
  height: "100%",
  fill: "url(#preview-grid)"
};
const _hoisted_5$1 = ["onClick"];
const _hoisted_6$1 = ["d", "stroke"];
const _hoisted_7$1 = ["d", "stroke", "stroke-dasharray"];
const _hoisted_8$1 = { key: 2 };
const _hoisted_9$1 = ["cx", "cy", "stroke"];
const _hoisted_10$1 = ["cx", "cy", "fill"];
const _hoisted_11$1 = ["x", "y", "fill"];
const _hoisted_12$1 = ["x", "y"];
const _hoisted_13$1 = ["x", "y", "fill"];
const _hoisted_14$1 = ["cx", "cy", "stroke"];
const _hoisted_15$1 = ["x1", "y1", "x2", "y2", "stroke"];
const _hoisted_16$1 = ["x", "y", "fill"];
const _hoisted_17$1 = { key: 1 };
const _hoisted_18$1 = ["cx", "cy"];
const _hoisted_19$1 = ["cx", "cy"];
const _hoisted_20$1 = {
  key: 0,
  class: "legend"
};
const _hoisted_21$1 = ["onClick"];
const _hoisted_22$1 = { class: "legend-text" };
const _hoisted_23$1 = {
  key: 1,
  class: "instructions"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "PathPreviewOverlay",
  props: {
    width: {},
    height: {},
    suggestions: {},
    selectedIndex: {},
    showGrid: { type: Boolean, default: true },
    showPoints: { type: Boolean, default: true },
    showLabels: { type: Boolean, default: true },
    showDepth: { type: Boolean, default: true },
    showLegend: { type: Boolean, default: true },
    showAnimation: { type: Boolean, default: true },
    gridSize: { default: 50 }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const overlayRef = ref(null);
    const animatedPosition = ref(null);
    let animationFrame = 0;
    let animationId = null;
    const pathColors = [
      "#4a90d9",
      // Blue
      "#d94a4a",
      // Red
      "#4ad94a",
      // Green
      "#d9d94a",
      // Yellow
      "#d94ad9",
      // Magenta
      "#4ad9d9"
      // Cyan
    ];
    const overlayStyle = computed(() => ({
      width: `${props.width}px`,
      height: `${props.height}px`
    }));
    const cameraSuggestions = computed(() => {
      return props.suggestions.filter((s) => s.type === "camera" && s.points && s.points.length >= 2).map((s) => ({
        type: s.description?.split(" ")[0] || "Camera",
        startX: s.points[0].x,
        startY: s.points[0].y,
        endX: s.points[s.points.length - 1].x,
        endY: s.points[s.points.length - 1].y
      }));
    });
    function getPathColor(index, opacity) {
      const baseColor = pathColors[index % pathColors.length];
      if (opacity === 1) return baseColor;
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    function pointsToPathData(points) {
      if (points.length < 2) return "";
      let d = `M ${points[0].x} ${points[0].y}`;
      if (points.length === 2) {
        d += ` L ${points[1].x} ${points[1].y}`;
      } else {
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[Math.max(0, i - 1)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(points.length - 1, i + 2)];
          const tension = 0.3;
          const cp1x = p1.x + (p2.x - p0.x) * tension;
          const cp1y = p1.y + (p2.y - p0.y) * tension;
          const cp2x = p2.x - (p3.x - p1.x) * tension;
          const cp2y = p2.y - (p3.y - p1.y) * tension;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
        }
      }
      return d;
    }
    function startAnimation() {
      if (props.selectedIndex === null) {
        animatedPosition.value = null;
        return;
      }
      const suggestion = props.suggestions[props.selectedIndex];
      if (!suggestion.points || suggestion.points.length < 2) {
        animatedPosition.value = null;
        return;
      }
      const points = suggestion.points;
      const totalLength = points.length - 1;
      function animate() {
        animationFrame = (animationFrame + 0.5) % (totalLength * 60);
        const t = animationFrame / (totalLength * 60);
        const segmentIndex = Math.min(Math.floor(t * totalLength), totalLength - 1);
        const segmentT = t * totalLength - segmentIndex;
        const p1 = points[segmentIndex];
        const p2 = points[segmentIndex + 1];
        animatedPosition.value = {
          x: p1.x + (p2.x - p1.x) * segmentT,
          y: p1.y + (p2.y - p1.y) * segmentT
        };
        animationId = requestAnimationFrame(animate);
      }
      animate();
    }
    function stopAnimation() {
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      animatedPosition.value = null;
    }
    watch(() => props.suggestions, (newSuggestions) => {
      for (const suggestion of newSuggestions) {
        if (suggestion.points && !suggestion.pathData) {
          suggestion.pathData = pointsToPathData(suggestion.points);
        }
      }
    }, { immediate: true, deep: true });
    watch(() => props.selectedIndex, () => {
      stopAnimation();
      if (props.showAnimation) {
        startAnimation();
      }
    });
    onMounted(() => {
      if (props.showAnimation && props.selectedIndex !== null) {
        startAnimation();
      }
    });
    onUnmounted(() => {
      stopAnimation();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "overlayRef",
        ref: overlayRef,
        class: "path-preview-overlay",
        style: normalizeStyle(overlayStyle.value)
      }, [
        (openBlock(), createElementBlock("svg", {
          class: "preview-svg",
          viewBox: `0 0 ${__props.width} ${__props.height}`,
          preserveAspectRatio: "xMidYMid meet"
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("pattern", {
              id: "preview-grid",
              width: __props.gridSize,
              height: __props.gridSize,
              patternUnits: "userSpaceOnUse"
            }, [
              createBaseVNode("path", {
                d: `M ${__props.gridSize} 0 L 0 0 0 ${__props.gridSize}`,
                fill: "none",
                stroke: "rgba(255,255,255,0.05)",
                "stroke-width": "1"
              }, null, 8, _hoisted_3$1)
            ], 8, _hoisted_2$1),
            _cache[0] || (_cache[0] = createStaticVNode('<filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%" data-v-021b36ff><feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" data-v-021b36ff></feGaussianBlur><feMerge data-v-021b36ff><feMergeNode in="blur" data-v-021b36ff></feMergeNode><feMergeNode in="SourceGraphic" data-v-021b36ff></feMergeNode></feMerge></filter><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse" data-v-021b36ff><path d="M 0 0 L 10 5 L 0 10 z" fill="#4a90d9" data-v-021b36ff></path></marker>', 2))
          ]),
          __props.showGrid ? (openBlock(), createElementBlock("rect", _hoisted_4$1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: index,
              class: normalizeClass(["path-group", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 0,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 0.3),
                "stroke-width": "8",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                filter: "url(#path-glow)"
              }, null, 8, _hoisted_6$1)) : createCommentVNode("", true),
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 1,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 1),
                "stroke-width": "2",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-dasharray": __props.selectedIndex === index ? "none" : "8,4",
                "marker-end": "url(#arrow)"
              }, null, 8, _hoisted_7$1)) : createCommentVNode("", true),
              suggestion.points && __props.showPoints ? (openBlock(), createElementBlock("g", _hoisted_8$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(suggestion.points, (point, pIndex) => {
                  return openBlock(), createElementBlock("g", {
                    key: pIndex,
                    class: "control-point"
                  }, [
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "8",
                      fill: "none",
                      stroke: getPathColor(index, 0.5),
                      "stroke-width": "2"
                    }, null, 8, _hoisted_9$1),
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "4",
                      fill: getPathColor(index, 1)
                    }, null, 8, _hoisted_10$1),
                    __props.showLabels ? (openBlock(), createElementBlock("text", {
                      key: 0,
                      x: point.x + 12,
                      y: point.y + 4,
                      class: "point-label",
                      fill: getPathColor(index, 0.8)
                    }, toDisplayString(pIndex + 1), 9, _hoisted_11$1)) : createCommentVNode("", true),
                    point.depth !== void 0 && __props.showDepth ? (openBlock(), createElementBlock("text", {
                      key: 1,
                      x: point.x + 12,
                      y: point.y + 16,
                      class: "depth-label"
                    }, " z: " + toDisplayString(point.depth.toFixed(2)), 9, _hoisted_12$1)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 10, _hoisted_5$1);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(cameraSuggestions.value, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: `cam-${index}`
            }, [
              createBaseVNode("g", {
                class: normalizeClass(["camera-indicator", { selected: __props.selectedIndex === index }])
              }, [
                createBaseVNode("rect", {
                  x: suggestion.startX - 12,
                  y: suggestion.startY - 8,
                  width: "24",
                  height: "16",
                  rx: "2",
                  fill: getPathColor(index, 0.8)
                }, null, 8, _hoisted_13$1),
                createBaseVNode("circle", {
                  cx: suggestion.startX + 8,
                  cy: suggestion.startY,
                  r: "4",
                  fill: "none",
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2"
                }, null, 8, _hoisted_14$1),
                createBaseVNode("line", {
                  x1: suggestion.startX,
                  y1: suggestion.startY,
                  x2: suggestion.endX,
                  y2: suggestion.endY,
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2",
                  "stroke-dasharray": "4,2",
                  "marker-end": "url(#arrow)"
                }, null, 8, _hoisted_15$1),
                createBaseVNode("text", {
                  x: (suggestion.startX + suggestion.endX) / 2,
                  y: (suggestion.startY + suggestion.endY) / 2 - 10,
                  class: "motion-label",
                  fill: getPathColor(index, 1)
                }, toDisplayString(suggestion.type), 9, _hoisted_16$1)
              ], 2)
            ]);
          }), 128)),
          animatedPosition.value && __props.showAnimation ? (openBlock(), createElementBlock("g", _hoisted_17$1, [
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "6",
              fill: "#fff",
              class: "animated-dot"
            }, null, 8, _hoisted_18$1),
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "12",
              fill: "none",
              stroke: "#fff",
              "stroke-width": "2",
              opacity: "0.5",
              class: "animated-ring"
            }, null, 8, _hoisted_19$1)
          ])) : createCommentVNode("", true)
        ], 8, _hoisted_1$1)),
        __props.suggestions.length > 0 && __props.showLegend ? (openBlock(), createElementBlock("div", _hoisted_20$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["legend-item", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              createBaseVNode("span", {
                class: "legend-color",
                style: normalizeStyle({ backgroundColor: getPathColor(index, 1) })
              }, null, 4),
              createBaseVNode("span", _hoisted_22$1, toDisplayString(suggestion.description || `Path ${index + 1}`), 1)
            ], 10, _hoisted_21$1);
          }), 128))
        ])) : createCommentVNode("", true),
        __props.suggestions.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_23$1, " Click a path to select it. Press Enter to accept. ")) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const PathPreviewOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-021b36ff"]]);

const _hoisted_1 = { class: "workspace-layout" };
const _hoisted_2 = { class: "toolbar" };
const _hoisted_3 = { class: "tool-group" };
const _hoisted_4 = { class: "tool-group segment-options" };
const _hoisted_5 = {
  key: 1,
  class: "loading-indicator"
};
const _hoisted_6 = { class: "tool-group" };
const _hoisted_7 = ["title"];
const _hoisted_8 = { class: "icon" };
const _hoisted_9 = { class: "timecode-display" };
const _hoisted_10 = { class: "tool-group" };
const _hoisted_11 = { class: "tool-group" };
const _hoisted_12 = ["disabled"];
const _hoisted_13 = ["disabled"];
const _hoisted_14 = { class: "workspace-content" };
const _hoisted_15 = { class: "panel left-panel" };
const _hoisted_16 = { class: "panel-tabs" };
const _hoisted_17 = { class: "panel-content" };
const _hoisted_18 = { class: "panel viewport-panel" };
const _hoisted_19 = { class: "viewport-header" };
const _hoisted_20 = { class: "viewport-tabs" };
const _hoisted_21 = { class: "viewport-controls" };
const _hoisted_22 = { class: "viewport-content" };
const _hoisted_23 = { class: "panel timeline-panel" };
const _hoisted_24 = { class: "panel graph-editor-panel" };
const _hoisted_25 = {
  key: 1,
  class: "panel timeline-panel"
};
const _hoisted_26 = { class: "panel right-panel" };
const _hoisted_27 = { class: "panel-tabs" };
const _hoisted_28 = { class: "panel-content" };
const _hoisted_29 = { class: "status-bar" };
const _hoisted_30 = { class: "status-left" };
const _hoisted_31 = { class: "status-item" };
const _hoisted_32 = { class: "status-item" };
const _hoisted_33 = { class: "status-center" };
const _hoisted_34 = {
  key: 0,
  class: "render-progress"
};
const _hoisted_35 = { class: "status-right" };
const _hoisted_36 = { class: "status-item" };
const _hoisted_37 = { class: "status-item" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "WorkspaceLayout",
  setup(__props) {
    const store = useCompositorStore();
    const currentTool = computed({
      get: () => store.currentTool,
      set: (tool) => store.setTool(tool)
    });
    const segmentMode = computed(() => store.segmentMode);
    const segmentPendingMask = computed(() => store.segmentPendingMask);
    const segmentIsLoading = computed(() => store.segmentIsLoading);
    function setSegmentMode(mode) {
      store.setSegmentMode(mode);
    }
    async function confirmSegmentMask() {
      await store.confirmSegmentMask();
    }
    function clearSegmentMask() {
      store.clearSegmentPendingMask();
    }
    const activeWorkspace = ref("standard");
    const leftTab = ref("project");
    const rightTab = ref("properties");
    const viewportTab = ref("composition");
    const viewZoom = ref("fit");
    const showGuides = ref(false);
    const showGrid = ref(true);
    const showGraphEditor = ref(false);
    const showExportDialog = ref(false);
    const showComfyUIExportDialog = ref(false);
    const showCompositionSettingsDialog = ref(false);
    const showPathSuggestionDialog = ref(false);
    const pathSuggestions = ref([]);
    const selectedPathIndex = ref(null);
    const isPlaying = ref(false);
    const gpuTier = ref("cpu");
    const threeCanvasRef = ref(null);
    const activeCamera = computed(() => {
      const cam = store.getActiveCameraAtFrame();
      if (cam) return cam;
      return createDefaultCamera("default", compWidth.value, compHeight.value);
    });
    const viewportState = ref(createDefaultViewportState());
    const viewOptions = ref({
      showGrid: true,
      showAxes: true,
      showCameraFrustum: true,
      showCompositionBounds: true,
      showFocalPlane: false,
      showLayerOutlines: true,
      gridSize: 100,
      gridDivisions: 10
    });
    const compWidth = computed(() => store.project?.composition?.width || 1920);
    const compHeight = computed(() => store.project?.composition?.height || 1080);
    const fps = ref(60);
    const memoryUsage = ref("0 MB");
    const renderProgress = ref(0);
    const formattedTimecode = computed(() => {
      const frame = store.currentFrame;
      const fpsVal = store.project?.composition?.fps || 30;
      const totalSeconds = frame / fpsVal;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const frames = frame % fpsVal;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    const projectName = computed(() => {
      return store.project?.meta?.name || "Untitled Project";
    });
    const compositionInfo = computed(() => {
      const comp = store.project?.composition;
      if (!comp) return "No Composition";
      return `${comp.width}${comp.height} @ ${comp.fps}fps`;
    });
    const canUndo = computed(() => store.canUndo);
    const canRedo = computed(() => store.canRedo);
    function togglePlay() {
      isPlaying.value = !isPlaying.value;
      if (isPlaying.value) {
        store.play();
      } else {
        store.pause();
      }
    }
    function goToStart() {
      store.goToStart();
    }
    function goToEnd() {
      store.goToEnd();
    }
    function stepForward() {
      store.setFrame(store.currentFrame + 1);
    }
    function stepBackward() {
      store.setFrame(Math.max(0, store.currentFrame - 1));
    }
    function undo() {
      store.undo();
    }
    function redo() {
      store.redo();
    }
    function updateCamera(camera) {
      if (store.activeCameraId) {
        store.updateCamera(camera.id, camera);
      }
    }
    function onExportComplete() {
      console.log("[Weyl] Matte export completed");
    }
    function onComfyUIExportComplete(result) {
      console.log("[Weyl] ComfyUI export completed", result);
      showComfyUIExportDialog.value = false;
    }
    function onCompositionSettingsConfirm(settings) {
      console.log("[Weyl] Composition settings updated:", settings);
      store.updateCompositionSettings(store.activeCompositionId, {
        width: settings.width,
        height: settings.height,
        fps: settings.fps,
        frameCount: settings.frameCount,
        backgroundColor: settings.backgroundColor,
        autoResizeToContent: settings.autoResizeToContent
      });
      store.renameComposition(store.activeCompositionId, settings.name);
      showCompositionSettingsDialog.value = false;
    }
    function generatePathDataFromPoints(points, closed) {
      if (points.length === 0) return "";
      if (points.length === 1) return `M ${points[0].x} ${points[0].y}`;
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        if (p0.handleOut && p1.handleIn) {
          const cp1x = p0.x + p0.handleOut.x;
          const cp1y = p0.y + p0.handleOut.y;
          const cp2x = p1.x + p1.handleIn.x;
          const cp2y = p1.y + p1.handleIn.y;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
        } else if (p0.handleOut) {
          const cpx = p0.x + p0.handleOut.x;
          const cpy = p0.y + p0.handleOut.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else if (p1.handleIn) {
          const cpx = p1.x + p1.handleIn.x;
          const cpy = p1.y + p1.handleIn.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else {
          d += ` L ${p1.x} ${p1.y}`;
        }
      }
      if (closed && points.length > 2) {
        d += " Z";
      }
      return d;
    }
    function onPathSuggestionClose() {
      showPathSuggestionDialog.value = false;
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
    }
    function onPathSuggestionPreview(suggestions) {
      pathSuggestions.value = suggestions;
      selectedPathIndex.value = suggestions.length > 0 ? 0 : null;
    }
    function onPathSuggestionAccept(result) {
      console.log("[Weyl] Path suggestion accepted:", result);
      if (result.keyframes && result.keyframes.length > 0) {
        for (const batch of result.keyframes) {
          for (const keyframe of batch.keyframes) {
            store.addKeyframe(batch.layerId, batch.propertyPath, keyframe.frame, keyframe.value, keyframe.easing);
          }
        }
      }
      if (result.splines && result.splines.length > 0) {
        for (const spline of result.splines) {
          const layer = store.createSplineLayer();
          if (spline.name) {
            store.renameLayer(layer.id, spline.name);
          }
          const controlPoints = (spline.points || []).map((p, i) => ({
            id: p.id || `cp_${Date.now()}_${i}`,
            x: p.x,
            y: p.y,
            depth: p.depth ?? 0,
            // Preserve z-space depth
            handleIn: p.handleIn || null,
            // Preserve bezier handles from translator
            handleOut: p.handleOut || null,
            type: p.type || "smooth"
          }));
          const pathData = generatePathDataFromPoints(controlPoints, spline.closed || false);
          store.updateLayerData(layer.id, {
            controlPoints,
            pathData,
            closed: spline.closed || false
          });
        }
      }
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
      showPathSuggestionDialog.value = false;
    }
    const activeCameraKeyframes = computed(() => {
      const activeCam = store.getActiveCameraAtFrame();
      if (!activeCam) return [];
      return store.getCameraKeyframes(activeCam.id);
    });
    function handleZoomChange() {
      if (!threeCanvasRef.value) return;
      if (viewZoom.value === "fit") {
        threeCanvasRef.value.fitToView();
      } else {
        const zoomLevel = parseInt(viewZoom.value) / 100;
        threeCanvasRef.value.zoom = zoomLevel;
      }
    }
    function handleKeydown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA") {
        return;
      }
      switch (e.key.toLowerCase()) {
        case " ":
          e.preventDefault();
          togglePlay();
          break;
        case "v":
          currentTool.value = "select";
          break;
        case "p":
          currentTool.value = "pen";
          break;
        case "t":
          currentTool.value = "text";
          break;
        case "h":
          currentTool.value = "hand";
          break;
        case "z":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
          } else {
            currentTool.value = "zoom";
          }
          break;
        case "home":
          e.preventDefault();
          goToStart();
          break;
        case "end":
          e.preventDefault();
          goToEnd();
          break;
        case "arrowleft":
          e.preventDefault();
          stepBackward();
          break;
        case "arrowright":
          e.preventDefault();
          stepForward();
          break;
        case "g":
          if (e.shiftKey) {
            showGraphEditor.value = !showGraphEditor.value;
          }
          break;
        case "k":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            showCompositionSettingsDialog.value = true;
          }
          break;
      }
    }
    let perfInterval;
    function updatePerformanceStats() {
      if ("memory" in performance) {
        const mem = performance.memory;
        const usedMB = Math.round(mem.usedJSHeapSize / 1024 / 1024);
        memoryUsage.value = `${usedMB} MB`;
      }
    }
    onMounted(async () => {
      const tierInfo = await detectGPUTier();
      gpuTier.value = tierInfo.tier;
      window.addEventListener("keydown", handleKeydown);
      perfInterval = window.setInterval(updatePerformanceStats, 1e3);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
      clearInterval(perfInterval);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "select" }),
              onClick: _cache[0] || (_cache[0] = ($event) => currentTool.value = "select"),
              title: "Select (V)"
            }, [..._cache[32] || (_cache[32] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "pen" }),
              onClick: _cache[1] || (_cache[1] = ($event) => currentTool.value = "pen"),
              title: "Pen Tool (P)"
            }, [..._cache[33] || (_cache[33] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "text" }),
              onClick: _cache[2] || (_cache[2] = ($event) => currentTool.value = "text"),
              title: "Text Tool (T)"
            }, [..._cache[34] || (_cache[34] = [
              createBaseVNode("span", { class: "icon" }, "T", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "hand" }),
              onClick: _cache[3] || (_cache[3] = ($event) => currentTool.value = "hand"),
              title: "Hand Tool (H)"
            }, [..._cache[35] || (_cache[35] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "zoom" }),
              onClick: _cache[4] || (_cache[4] = ($event) => currentTool.value = "zoom"),
              title: "Zoom Tool (Z)"
            }, [..._cache[36] || (_cache[36] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "segment" }),
              onClick: _cache[5] || (_cache[5] = ($event) => currentTool.value = "segment"),
              title: "Segment Tool (S) - Click to select objects"
            }, [..._cache[37] || (_cache[37] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 2)
          ]),
          currentTool.value === "segment" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _cache[43] || (_cache[43] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("div", _hoisted_4, [
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "point" }),
                onClick: _cache[6] || (_cache[6] = ($event) => setSegmentMode("point")),
                title: "Point Mode - Click to segment"
              }, [..._cache[38] || (_cache[38] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Point ", -1)
              ])], 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "box" }),
                onClick: _cache[7] || (_cache[7] = ($event) => setSegmentMode("box")),
                title: "Box Mode - Draw rectangle to segment"
              }, [..._cache[39] || (_cache[39] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Box ", -1)
              ])], 2),
              segmentPendingMask.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _cache[42] || (_cache[42] = createBaseVNode("div", { class: "divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: confirmSegmentMask,
                  class: "confirm-btn",
                  title: "Create Layer from Selection"
                }, [..._cache[40] || (_cache[40] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Create Layer ", -1)
                ])]),
                createBaseVNode("button", {
                  onClick: clearSegmentMask,
                  class: "cancel-btn",
                  title: "Cancel Selection"
                }, [..._cache[41] || (_cache[41] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])])
              ], 64)) : createCommentVNode("", true),
              segmentIsLoading.value ? (openBlock(), createElementBlock("span", _hoisted_5, "Segmenting...")) : createCommentVNode("", true)
            ])
          ], 64)) : createCommentVNode("", true),
          _cache[55] || (_cache[55] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("button", {
              onClick: goToStart,
              title: "Go to Start (Home)"
            }, [..._cache[44] || (_cache[44] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: stepBackward,
              title: "Step Backward"
            }, [..._cache[45] || (_cache[45] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: togglePlay,
              title: isPlaying.value ? "Pause (Space)" : "Play (Space)"
            }, [
              createBaseVNode("span", _hoisted_8, toDisplayString(isPlaying.value ? "" : ""), 1)
            ], 8, _hoisted_7),
            createBaseVNode("button", {
              onClick: stepForward,
              title: "Step Forward"
            }, [..._cache[46] || (_cache[46] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: goToEnd,
              title: "Go to End (End)"
            }, [..._cache[47] || (_cache[47] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_9, toDisplayString(formattedTimecode.value), 1),
          _cache[56] || (_cache[56] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_10, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => activeWorkspace.value = $event),
              class: "workspace-selector"
            }, [..._cache[48] || (_cache[48] = [
              createBaseVNode("option", { value: "standard" }, "Standard", -1),
              createBaseVNode("option", { value: "animation" }, "Animation", -1),
              createBaseVNode("option", { value: "effects" }, "Effects", -1),
              createBaseVNode("option", { value: "minimal" }, "Minimal", -1)
            ])], 512), [
              [vModelSelect, activeWorkspace.value]
            ])
          ]),
          _cache[57] || (_cache[57] = createBaseVNode("div", { class: "spacer" }, null, -1)),
          createBaseVNode("div", _hoisted_11, [
            createBaseVNode("span", {
              class: normalizeClass(["gpu-badge", gpuTier.value])
            }, toDisplayString(gpuTier.value.toUpperCase()), 3),
            createBaseVNode("button", {
              onClick: undo,
              disabled: !canUndo.value,
              title: "Undo (Ctrl+Z)"
            }, [..._cache[49] || (_cache[49] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_12),
            createBaseVNode("button", {
              onClick: redo,
              disabled: !canRedo.value,
              title: "Redo (Ctrl+Shift+Z)"
            }, [..._cache[50] || (_cache[50] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_13),
            _cache[54] || (_cache[54] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("button", {
              onClick: _cache[9] || (_cache[9] = ($event) => showPathSuggestionDialog.value = true),
              title: "AI Path Suggestion",
              class: "ai-btn"
            }, [..._cache[51] || (_cache[51] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" AI ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[10] || (_cache[10] = ($event) => showExportDialog.value = true),
              title: "Export Matte"
            }, [..._cache[52] || (_cache[52] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Matte ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[11] || (_cache[11] = ($event) => showComfyUIExportDialog.value = true),
              title: "Export to ComfyUI"
            }, [..._cache[53] || (_cache[53] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" ComfyUI ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_14, [
          createVNode(unref(Pe), { class: "default-theme horizontal-split" }, {
            default: withCtx(() => [
              createVNode(unref(ge), {
                size: 12,
                "min-size": 8,
                "max-size": 20
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_15, [
                    createBaseVNode("div", _hoisted_16, [
                      createBaseVNode("button", {
                        class: normalizeClass({ active: leftTab.value === "project" }),
                        onClick: _cache[12] || (_cache[12] = ($event) => leftTab.value = "project")
                      }, " Project ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: leftTab.value === "effects" }),
                        onClick: _cache[13] || (_cache[13] = ($event) => leftTab.value = "effects")
                      }, " Effects ", 2)
                    ]),
                    createBaseVNode("div", _hoisted_17, [
                      leftTab.value === "project" ? (openBlock(), createBlock(ProjectPanel, {
                        key: 0,
                        onOpenCompositionSettings: _cache[14] || (_cache[14] = ($event) => showCompositionSettingsDialog.value = true)
                      })) : leftTab.value === "effects" ? (openBlock(), createBlock(EffectsPanel, { key: 1 })) : createCommentVNode("", true)
                    ])
                  ])
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 70,
                "min-size": 40
              }, {
                default: withCtx(() => [
                  createVNode(unref(Pe), {
                    horizontal: "",
                    class: "default-theme"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ge), {
                        size: 65,
                        "min-size": 20
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_18, [
                            createBaseVNode("div", _hoisted_19, [
                              createBaseVNode("div", _hoisted_20, [
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "composition" }),
                                  onClick: _cache[15] || (_cache[15] = ($event) => viewportTab.value = "composition")
                                }, " Composition ", 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "layer" }),
                                  onClick: _cache[16] || (_cache[16] = ($event) => viewportTab.value = "layer")
                                }, " Layer ", 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "footage" }),
                                  onClick: _cache[17] || (_cache[17] = ($event) => viewportTab.value = "footage")
                                }, " Footage ", 2)
                              ]),
                              createBaseVNode("div", _hoisted_21, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => viewZoom.value = $event),
                                  onChange: handleZoomChange,
                                  class: "zoom-select"
                                }, [..._cache[58] || (_cache[58] = [
                                  createBaseVNode("option", { value: "fit" }, "Fit", -1),
                                  createBaseVNode("option", { value: "25" }, "25%", -1),
                                  createBaseVNode("option", { value: "50" }, "50%", -1),
                                  createBaseVNode("option", { value: "75" }, "75%", -1),
                                  createBaseVNode("option", { value: "100" }, "100%", -1),
                                  createBaseVNode("option", { value: "150" }, "150%", -1),
                                  createBaseVNode("option", { value: "200" }, "200%", -1)
                                ])], 544), [
                                  [vModelSelect, viewZoom.value]
                                ]),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: showGuides.value }),
                                  onClick: _cache[19] || (_cache[19] = ($event) => showGuides.value = !showGuides.value),
                                  title: "Toggle Guides"
                                }, [..._cache[59] || (_cache[59] = [
                                  createBaseVNode("span", { class: "icon" }, "", -1)
                                ])], 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: showGrid.value }),
                                  onClick: _cache[20] || (_cache[20] = ($event) => showGrid.value = !showGrid.value),
                                  title: "Toggle Grid"
                                }, [..._cache[60] || (_cache[60] = [
                                  createBaseVNode("span", { class: "icon" }, "", -1)
                                ])], 2)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_22, [
                              viewportTab.value === "composition" ? (openBlock(), createBlock(ThreeCanvas, {
                                key: 0,
                                ref_key: "threeCanvasRef",
                                ref: threeCanvasRef
                              }, null, 512)) : (openBlock(), createBlock(ViewportRenderer, {
                                key: 1,
                                camera: activeCamera.value,
                                viewportState: viewportState.value,
                                viewOptions: viewOptions.value,
                                compWidth: compWidth.value,
                                compHeight: compHeight.value
                              }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                            ])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ge), {
                        size: 35,
                        "min-size": 15
                      }, {
                        default: withCtx(() => [
                          showGraphEditor.value ? (openBlock(), createBlock(unref(Pe), {
                            key: 0,
                            horizontal: "",
                            class: "default-theme"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_23, [
                                    createVNode(TimelinePanel, {
                                      onOpenCompositionSettings: _cache[21] || (_cache[21] = ($event) => showCompositionSettingsDialog.value = true)
                                    })
                                  ])
                                ]),
                                _: 1
                              }),
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_24, [
                                    createVNode(GraphEditor, {
                                      onClose: _cache[22] || (_cache[22] = ($event) => showGraphEditor.value = false)
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })) : (openBlock(), createElementBlock("div", _hoisted_25, [
                            createVNode(TimelinePanel, {
                              onOpenCompositionSettings: _cache[23] || (_cache[23] = ($event) => showCompositionSettingsDialog.value = true)
                            })
                          ]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 18,
                "min-size": 12,
                "max-size": 25
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_26, [
                    createBaseVNode("div", _hoisted_27, [
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "effects" }),
                        onClick: _cache[24] || (_cache[24] = ($event) => rightTab.value = "effects")
                      }, " Effects ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "properties" }),
                        onClick: _cache[25] || (_cache[25] = ($event) => rightTab.value = "properties")
                      }, " Props ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "camera" }),
                        onClick: _cache[26] || (_cache[26] = ($event) => rightTab.value = "camera")
                      }, " Cam ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "audio" }),
                        onClick: _cache[27] || (_cache[27] = ($event) => rightTab.value = "audio")
                      }, " Audio ", 2)
                    ]),
                    createBaseVNode("div", _hoisted_28, [
                      rightTab.value === "effects" ? (openBlock(), createBlock(EffectControlsPanel, { key: 0 })) : rightTab.value === "properties" ? (openBlock(), createBlock(PropertiesPanel, { key: 1 })) : rightTab.value === "camera" ? (openBlock(), createBlock(CameraProperties, {
                        key: 2,
                        camera: activeCamera.value,
                        "onUpdate:camera": updateCamera
                      }, null, 8, ["camera"])) : rightTab.value === "audio" ? (openBlock(), createBlock(AudioPanel, { key: 3 })) : createCommentVNode("", true)
                    ])
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        createBaseVNode("div", _hoisted_29, [
          createBaseVNode("div", _hoisted_30, [
            createBaseVNode("span", _hoisted_31, toDisplayString(projectName.value), 1),
            _cache[61] || (_cache[61] = createBaseVNode("span", { class: "status-divider" }, "|", -1)),
            createBaseVNode("span", _hoisted_32, toDisplayString(compositionInfo.value), 1)
          ]),
          createBaseVNode("div", _hoisted_33, [
            renderProgress.value > 0 ? (openBlock(), createElementBlock("span", _hoisted_34, " Rendering: " + toDisplayString(Math.round(renderProgress.value * 100)) + "% ", 1)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_35, [
            createBaseVNode("span", _hoisted_36, toDisplayString(memoryUsage.value), 1),
            _cache[62] || (_cache[62] = createBaseVNode("span", { class: "status-divider" }, "|", -1)),
            createBaseVNode("span", _hoisted_37, toDisplayString(fps.value) + " fps", 1)
          ])
        ]),
        showExportDialog.value ? (openBlock(), createBlock(ExportDialog, {
          key: 0,
          onClose: _cache[28] || (_cache[28] = ($event) => showExportDialog.value = false),
          onExported: onExportComplete
        })) : createCommentVNode("", true),
        showComfyUIExportDialog.value ? (openBlock(), createBlock(ComfyUIExportDialog, {
          key: 1,
          layers: unref(store).layers,
          "camera-keyframes": activeCameraKeyframes.value,
          "current-frame": unref(store).currentFrame,
          "total-frames": unref(store).frameCount,
          onClose: _cache[29] || (_cache[29] = ($event) => showComfyUIExportDialog.value = false),
          onExported: onComfyUIExportComplete
        }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : createCommentVNode("", true),
        createVNode(CompositionSettingsDialog, {
          visible: showCompositionSettingsDialog.value,
          onClose: _cache[30] || (_cache[30] = ($event) => showCompositionSettingsDialog.value = false),
          onConfirm: onCompositionSettingsConfirm
        }, null, 8, ["visible"]),
        createVNode(PathSuggestionDialog, {
          visible: showPathSuggestionDialog.value,
          onClose: onPathSuggestionClose,
          onAccept: onPathSuggestionAccept,
          onPreview: onPathSuggestionPreview
        }, null, 8, ["visible"]),
        pathSuggestions.value.length > 0 ? (openBlock(), createBlock(Teleport, {
          key: 2,
          to: ".viewport-content"
        }, [
          createVNode(PathPreviewOverlay, {
            width: compWidth.value,
            height: compHeight.value,
            suggestions: pathSuggestions.value,
            selectedIndex: selectedPathIndex.value,
            onSelect: _cache[31] || (_cache[31] = ($event) => selectedPathIndex.value = $event)
          }, null, 8, ["width", "height", "suggestions", "selectedIndex"])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const WorkspaceLayout = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-05c5905a"]]);

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WorkspaceLayout);
    };
  }
});

const MUL_TABLE = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
const SHG_TABLE = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function createBlurStack(size) {
  const first = { r: 0, g: 0, b: 0, a: 0, next: null };
  let current = first;
  for (let i = 1; i < size; i++) {
    current.next = { r: 0, g: 0, b: 0, a: 0, next: null };
    current = current.next;
  }
  current.next = first;
  return first;
}
function stackBlur(imageData, radiusX, radiusY) {
  const pixels = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  radiusX = Math.max(0, Math.min(255, Math.round(radiusX)));
  radiusY = Math.max(0, Math.min(255, Math.round(radiusY)));
  if (radiusX === 0 && radiusY === 0) return;
  if (radiusX > 0) {
    stackBlurHorizontal(pixels, width, height, radiusX);
  }
  if (radiusY > 0) {
    stackBlurVertical(pixels, width, height, radiusY);
  }
}
function stackBlurHorizontal(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const widthMinus1 = width - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let y = 0; y < height; y++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    const yOffset = y * width;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[yOffset * 4];
    const pg = pixels[yOffset * 4 + 1];
    const pb = pixels[yOffset * 4 + 2];
    const pa = pixels[yOffset * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, widthMinus1);
      const pOffset = (yOffset + p) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let x = 0; x < width; x++) {
      const pOffset = (yOffset + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(x + radius + 1, widthMinus1);
      const pIn = (yOffset + p) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function stackBlurVertical(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const heightMinus1 = height - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let x = 0; x < width; x++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[x * 4];
    const pg = pixels[x * 4 + 1];
    const pb = pixels[x * 4 + 2];
    const pa = pixels[x * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, heightMinus1);
      const pOffset = (p * width + x) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let y = 0; y < height; y++) {
      const pOffset = (y * width + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(y + radius + 1, heightMinus1);
      const pIn = (p * width + x) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function gaussianBlurRenderer(input, params) {
  const blurriness = params.blurriness ?? 10;
  const dimensions = params.blur_dimensions ?? "both";
  if (blurriness <= 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  let radiusX = 0;
  let radiusY = 0;
  switch (dimensions) {
    case "horizontal":
      radiusX = blurriness;
      break;
    case "vertical":
      radiusY = blurriness;
      break;
    case "both":
    default:
      radiusX = blurriness;
      radiusY = blurriness;
      break;
  }
  stackBlur(imageData, radiusX, radiusY);
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function directionalBlurRenderer(input, params) {
  const direction = (params.direction ?? 0) * Math.PI / 180;
  const blurLength = Math.max(0, Math.min(500, params.blur_length ?? 10));
  if (blurLength <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const dx = Math.cos(direction);
  const dy = Math.sin(direction);
  const samples = Math.max(3, Math.ceil(blurLength));
  const halfSamples = Math.floor(samples / 2);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      for (let i = -halfSamples; i <= halfSamples; i++) {
        const sampleX = Math.round(x + dx * i * (blurLength / samples));
        const sampleY = Math.round(y + dy * i * (blurLength / samples));
        const sx = Math.max(0, Math.min(width - 1, sampleX));
        const sy = Math.max(0, Math.min(height - 1, sampleY));
        const idx = (sy * width + sx) * 4;
        r += src[idx];
        g += src[idx + 1];
        b += src[idx + 2];
        a += src[idx + 3];
        count++;
      }
      const outIdx = (y * width + x) * 4;
      dst[outIdx] = Math.round(r / count);
      dst[outIdx + 1] = Math.round(g / count);
      dst[outIdx + 2] = Math.round(b / count);
      dst[outIdx + 3] = Math.round(a / count);
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function radialBlurRenderer(input, params) {
  const type = params.type ?? "spin";
  const amount = Math.max(0, Math.min(100, params.amount ?? 10));
  const centerX = (params.center_x ?? 50) / 100;
  const centerY = (params.center_y ?? 50) / 100;
  const quality = params.quality ?? "good";
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const cx = centerX * width;
  const cy = centerY * height;
  const samples = quality === "best" ? 32 : quality === "good" ? 16 : 8;
  if (type === "spin") {
    const maxAngle = amount / 100 * Math.PI * 0.5;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const baseAngle = Math.atan2(dy, dx);
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1) - 0.5;
          const angle = baseAngle + t * maxAngle;
          const sampleX = Math.round(cx + Math.cos(angle) * dist);
          const sampleY = Math.round(cy + Math.sin(angle) * dist);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  } else {
    const maxZoom = amount / 100;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1);
          const scale = 1 - t * maxZoom;
          const sampleX = Math.round(cx + dx * scale);
          const sampleY = Math.round(cy + dy * scale);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function boxBlurRenderer(input, params) {
  const radius = Math.max(0, Math.min(100, Math.round(params.radius ?? 5)));
  const iterations = Math.max(1, Math.min(5, params.iterations ?? 1));
  if (radius <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  let current = createMatchingCanvas(input.canvas);
  current.ctx.drawImage(input.canvas, 0, 0);
  for (let iter = 0; iter < iterations; iter++) {
    const imageData = current.ctx.getImageData(0, 0, width, height);
    const src = imageData.data;
    const dst = new Uint8ClampedArray(src.length);
    const size = radius * 2 + 1;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dx = -radius; dx <= radius; dx++) {
          const sx = Math.max(0, Math.min(width - 1, x + dx));
          const idx = (y * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    src.set(dst);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dy = -radius; dy <= radius; dy++) {
          const sy = Math.max(0, Math.min(height - 1, y + dy));
          const idx = (sy * width + x) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    imageData.data.set(dst);
    current.ctx.putImageData(imageData, 0, 0);
  }
  return current;
}
function sharpenRenderer(input, params) {
  const amount = (params.amount ?? 100) / 100;
  const radius = Math.max(1, Math.min(100, params.radius ?? 1));
  const threshold = params.threshold ?? 0;
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const blurred = createMatchingCanvas(input.canvas);
  blurred.ctx.drawImage(input.canvas, 0, 0);
  const blurredData = blurred.ctx.getImageData(0, 0, width, height);
  stackBlur(blurredData, radius, radius);
  const output = createMatchingCanvas(input.canvas);
  const originalData = input.ctx.getImageData(0, 0, width, height);
  const orig = originalData.data;
  const blur = blurredData.data;
  for (let i = 0; i < orig.length; i += 4) {
    for (let c = 0; c < 3; c++) {
      const diff = orig[i + c] - blur[i + c];
      if (Math.abs(diff) >= threshold) {
        const sharpened = orig[i + c] + diff * amount;
        orig[i + c] = Math.max(0, Math.min(255, Math.round(sharpened)));
      }
    }
  }
  output.ctx.putImageData(originalData, 0, 0);
  return output;
}
function registerBlurEffects() {
  registerEffectRenderer("gaussian-blur", gaussianBlurRenderer);
  registerEffectRenderer("directional-blur", directionalBlurRenderer);
  registerEffectRenderer("radial-blur", radialBlurRenderer);
  registerEffectRenderer("box-blur", boxBlurRenderer);
  registerEffectRenderer("sharpen", sharpenRenderer);
}

function brightnessContrastRenderer(input, params) {
  const brightness = (params.brightness ?? 0) / 100;
  const contrast = (params.contrast ?? 0) / 100;
  const useLegacy = params.use_legacy ?? false;
  if (brightness === 0 && contrast === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const contrastFactor = useLegacy ? 1 + contrast : 259 * (contrast * 255 + 255) / (255 * (259 - contrast * 255));
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    r += brightness * 255;
    g += brightness * 255;
    b += brightness * 255;
    r = contrastFactor * (r - 128) + 128;
    g = contrastFactor * (g - 128) + 128;
    b = contrastFactor * (b - 128) + 128;
    data[i] = Math.max(0, Math.min(255, r));
    data[i + 1] = Math.max(0, Math.min(255, g));
    data[i + 2] = Math.max(0, Math.min(255, b));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }
  return [h, s, l];
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
function hueSaturationRenderer(input, params) {
  const hueShift = (params.master_hue ?? 0) / 360;
  const saturationShift = (params.master_saturation ?? 0) / 100;
  const lightnessShift = (params.master_lightness ?? 0) / 100;
  const colorize = params.colorize ?? false;
  if (hueShift === 0 && saturationShift === 0 && lightnessShift === 0 && !colorize) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    let [h, s, l] = rgbToHsl(r, g, b);
    if (colorize) {
      h = hueShift;
      s = Math.abs(saturationShift) + 0.25;
    } else {
      h = (h + hueShift) % 1;
      if (h < 0) h += 1;
      s = s + s * saturationShift;
    }
    l = l + l * lightnessShift;
    s = Math.max(0, Math.min(1, s));
    l = Math.max(0, Math.min(1, l));
    const [newR, newG, newB] = hslToRgb(h, s, l);
    data[i] = newR;
    data[i + 1] = newG;
    data[i + 2] = newB;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function levelsRenderer(input, params) {
  const inputBlack = params.input_black ?? 0;
  const inputWhite = params.input_white ?? 255;
  const gamma = params.gamma ?? 1;
  const outputBlack = params.output_black ?? 0;
  const outputWhite = params.output_white ?? 255;
  if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const inputRange = inputWhite - inputBlack;
  const outputRange = outputWhite - outputBlack;
  for (let i = 0; i < 256; i++) {
    let value = (i - inputBlack) / inputRange;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, 1 / gamma);
    value = outputBlack + value * outputRange;
    value = Math.max(0, Math.min(255, value));
    lut[i] = Math.round(value);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function tintRenderer(input, params) {
  const blackColor = params.map_black_to ?? { r: 0, g: 0, b: 0 };
  const whiteColor = params.map_white_to ?? { r: 255, g: 255, b: 255 };
  const amount = (params.amount_to_tint ?? 100) / 100;
  if (amount === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const tintR = blackColor.r + (whiteColor.r - blackColor.r) * lum;
    const tintG = blackColor.g + (whiteColor.g - blackColor.g) * lum;
    const tintB = blackColor.b + (whiteColor.b - blackColor.b) * lum;
    data[i] = Math.round(r + (tintR - r) * amount);
    data[i + 1] = Math.round(g + (tintG - g) * amount);
    data[i + 2] = Math.round(b + (tintB - b) * amount);
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function cubicBezier(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
}
function buildCurveLUT(points) {
  const lut = new Uint8Array(256);
  if (!points || points.length === 0) {
    for (let i = 0; i < 256; i++) {
      lut[i] = i;
    }
    return lut;
  }
  if (points.length === 1) {
    for (let i = 0; i < 256; i++) {
      lut[i] = Math.max(0, Math.min(255, Math.round(points[0].y)));
    }
    return lut;
  }
  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
  if (sortedPoints[0].x > 0) {
    sortedPoints.unshift({ x: 0, y: sortedPoints[0].y });
  }
  if (sortedPoints[sortedPoints.length - 1].x < 255) {
    sortedPoints.push({ x: 255, y: sortedPoints[sortedPoints.length - 1].y });
  }
  for (let i = 0; i < 256; i++) {
    let segmentIndex = 0;
    for (let j = 0; j < sortedPoints.length - 1; j++) {
      if (i >= sortedPoints[j].x && i <= sortedPoints[j + 1].x) {
        segmentIndex = j;
        break;
      }
    }
    const p0 = sortedPoints[segmentIndex];
    const p1 = sortedPoints[segmentIndex + 1];
    const t = (i - p0.x) / (p1.x - p0.x || 1);
    let tangent0 = 0;
    let tangent1 = 0;
    if (segmentIndex > 0) {
      const pPrev = sortedPoints[segmentIndex - 1];
      tangent0 = (p1.y - pPrev.y) / (p1.x - pPrev.x || 1) * (p1.x - p0.x);
    }
    if (segmentIndex < sortedPoints.length - 2) {
      const pNext = sortedPoints[segmentIndex + 2];
      tangent1 = (pNext.y - p0.y) / (pNext.x - p0.x || 1) * (p1.x - p0.x);
    }
    const cp1y = p0.y + tangent0 / 3;
    const cp2y = p1.y - tangent1 / 3;
    const value = cubicBezier(p0.y, cp1y, cp2y, p1.y, t);
    lut[i] = Math.max(0, Math.min(255, Math.round(value)));
  }
  return lut;
}
function curvesRenderer(input, params) {
  const masterCurve = params.master_curve;
  const redCurve = params.red_curve;
  const greenCurve = params.green_curve;
  const blueCurve = params.blue_curve;
  const alphaCurve = params.alpha_curve;
  const blend = (params.blend_with_original ?? 100) / 100;
  const hasCurves = masterCurve || redCurve || greenCurve || blueCurve || alphaCurve;
  if (!hasCurves || blend === 0) {
    return input;
  }
  const masterLUT = buildCurveLUT(masterCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const redLUT = buildCurveLUT(redCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const greenLUT = buildCurveLUT(greenCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const blueLUT = buildCurveLUT(blueCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const alphaLUT = alphaCurve ? buildCurveLUT(alphaCurve) : null;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    const origA = data[i + 3];
    let r = masterLUT[origR];
    let g = masterLUT[origG];
    let b = masterLUT[origB];
    r = redLUT[r];
    g = greenLUT[g];
    b = blueLUT[b];
    const a = alphaLUT ? alphaLUT[origA] : origA;
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
    data[i + 3] = a;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function glowRenderer(input, params) {
  const threshold = params.glow_threshold ?? 128;
  const radius = params.glow_radius ?? 20;
  const intensity = (params.glow_intensity ?? 100) / 100;
  const operation = params.glow_operation ?? "add";
  if (intensity === 0 || radius === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const thresholdCanvas = document.createElement("canvas");
  thresholdCanvas.width = width;
  thresholdCanvas.height = height;
  const thresholdCtx = thresholdCanvas.getContext("2d");
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const thresholdData = thresholdCtx.createImageData(width, height);
  for (let i = 0; i < inputData.data.length; i += 4) {
    const r = inputData.data[i];
    const g = inputData.data[i + 1];
    const b = inputData.data[i + 2];
    const a = inputData.data[i + 3];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    if (lum > threshold) {
      const scale = (lum - threshold) / (255 - threshold) * intensity;
      thresholdData.data[i] = Math.min(255, r * scale);
      thresholdData.data[i + 1] = Math.min(255, g * scale);
      thresholdData.data[i + 2] = Math.min(255, b * scale);
      thresholdData.data[i + 3] = a;
    } else {
      thresholdData.data[i] = 0;
      thresholdData.data[i + 1] = 0;
      thresholdData.data[i + 2] = 0;
      thresholdData.data[i + 3] = 0;
    }
  }
  thresholdCtx.putImageData(thresholdData, 0, 0);
  const blurCanvas = document.createElement("canvas");
  blurCanvas.width = width;
  blurCanvas.height = height;
  const blurCtx = blurCanvas.getContext("2d");
  blurCtx.filter = `blur(${radius}px)`;
  blurCtx.drawImage(thresholdCanvas, 0, 0);
  output.ctx.drawImage(input.canvas, 0, 0);
  switch (operation) {
    case "screen":
      output.ctx.globalCompositeOperation = "screen";
      break;
    case "lighten":
      output.ctx.globalCompositeOperation = "lighten";
      break;
    case "add":
    default:
      output.ctx.globalCompositeOperation = "lighter";
      break;
  }
  output.ctx.drawImage(blurCanvas, 0, 0);
  output.ctx.globalCompositeOperation = "source-over";
  return output;
}
function dropShadowRenderer(input, params) {
  const shadowColor = params.shadow_color ?? { r: 0, g: 0, b: 0};
  const opacity = (params.opacity ?? 50) / 100;
  const direction = (params.direction ?? 135) * Math.PI / 180;
  const distance = params.distance ?? 5;
  const softness = params.softness ?? 5;
  const shadowOnly = params.shadow_only ?? false;
  const output = createMatchingCanvas(input.canvas);
  const offsetX = Math.cos(direction) * distance;
  const offsetY = Math.sin(direction) * distance;
  output.ctx.shadowColor = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${opacity})`;
  output.ctx.shadowBlur = softness;
  output.ctx.shadowOffsetX = offsetX;
  output.ctx.shadowOffsetY = offsetY;
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.shadowColor = "transparent";
  output.ctx.shadowBlur = 0;
  output.ctx.shadowOffsetX = 0;
  output.ctx.shadowOffsetY = 0;
  if (!shadowOnly) {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  return output;
}
function colorBalanceRenderer(input, params) {
  const shadowR = (params.shadow_red ?? 0) / 100;
  const shadowG = (params.shadow_green ?? 0) / 100;
  const shadowB = (params.shadow_blue ?? 0) / 100;
  const midtoneR = (params.midtone_red ?? 0) / 100;
  const midtoneG = (params.midtone_green ?? 0) / 100;
  const midtoneB = (params.midtone_blue ?? 0) / 100;
  const highlightR = (params.highlight_red ?? 0) / 100;
  const highlightG = (params.highlight_green ?? 0) / 100;
  const highlightB = (params.highlight_blue ?? 0) / 100;
  const preserveLuminosity = params.preserve_luminosity ?? true;
  if (shadowR === 0 && shadowG === 0 && shadowB === 0 && midtoneR === 0 && midtoneG === 0 && midtoneB === 0 && highlightR === 0 && highlightG === 0 && highlightB === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const shadowWeight = Math.max(0, 1 - lum * 3);
    const highlightWeight = Math.max(0, (lum - 0.67) * 3);
    const midtoneWeight = 1 - shadowWeight - highlightWeight;
    const rAdjust = shadowR * shadowWeight + midtoneR * midtoneWeight + highlightR * highlightWeight;
    const gAdjust = shadowG * shadowWeight + midtoneG * midtoneWeight + highlightG * highlightWeight;
    const bAdjust = shadowB * shadowWeight + midtoneB * midtoneWeight + highlightB * highlightWeight;
    r = r + rAdjust * 255;
    g = g + gAdjust * 255;
    b = b + bAdjust * 255;
    if (preserveLuminosity) {
      const newLum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      if (newLum > 1e-3) {
        const lumRatio = lum / newLum;
        r *= lumRatio;
        g *= lumRatio;
        b *= lumRatio;
      }
    }
    data[i] = Math.max(0, Math.min(255, Math.round(r)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function exposureRenderer(input, params) {
  const exposure = params.exposure ?? 0;
  const offset = params.offset ?? 0;
  const gamma = params.gamma ?? 1;
  if (exposure === 0 && offset === 0 && gamma === 1) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const exposureMultiplier = Math.pow(2, exposure);
  const gammaInv = 1 / gamma;
  for (let i = 0; i < 256; i++) {
    let value = i / 255;
    value *= exposureMultiplier;
    value += offset;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, gammaInv);
    lut[i] = Math.round(value * 255);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function vibranceRenderer(input, params) {
  const vibrance = (params.vibrance ?? 0) / 100;
  const saturation = (params.saturation ?? 0) / 100;
  if (vibrance === 0 && saturation === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i] / 255;
    let g = data[i + 1] / 255;
    let b = data[i + 2] / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const currentSat = max - min;
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const skinProtection = 1 - Math.max(0, Math.min(
      1,
      Math.abs(r - 0.8) * 2 + Math.abs(g - 0.5) * 2 + Math.abs(b - 0.3) * 3
    ));
    const vibranceAmount = vibrance * (1 - currentSat) * (1 - skinProtection * 0.5);
    const satAdjust = 1 + saturation + vibranceAmount;
    r = lum + (r - lum) * satAdjust;
    g = lum + (g - lum) * satAdjust;
    b = lum + (b - lum) * satAdjust;
    data[i] = Math.max(0, Math.min(255, Math.round(r * 255)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function invertRenderer(input, params) {
  const blend = (params.blend ?? 100) / 100;
  const channel = params.channel ?? "rgb";
  if (blend === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    let r = origR;
    let g = origG;
    let b = origB;
    switch (channel) {
      case "rgb":
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
        break;
      case "red":
        r = 255 - r;
        break;
      case "green":
        g = 255 - g;
        break;
      case "blue":
        b = 255 - b;
        break;
      case "hue":
      case "saturation":
      case "lightness": {
        let [h, s, l] = rgbToHsl(r, g, b);
        if (channel === "hue") h = (h + 0.5) % 1;
        else if (channel === "saturation") s = 1 - s;
        else if (channel === "lightness") l = 1 - l;
        [r, g, b] = hslToRgb(h, s, l);
        break;
      }
    }
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function posterizeRenderer(input, params) {
  const levels = Math.max(2, Math.min(256, params.levels ?? 6));
  if (levels === 256) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const step = 255 / (levels - 1);
  for (let i = 0; i < 256; i++) {
    const level = Math.round(i / 255 * (levels - 1));
    lut[i] = Math.round(level * step);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function thresholdRenderer(input, params) {
  const threshold = params.threshold ?? 128;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const value = lum >= threshold ? 255 : 0;
    data[i] = value;
    data[i + 1] = value;
    data[i + 2] = value;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function registerColorEffects() {
  registerEffectRenderer("brightness-contrast", brightnessContrastRenderer);
  registerEffectRenderer("hue-saturation", hueSaturationRenderer);
  registerEffectRenderer("levels", levelsRenderer);
  registerEffectRenderer("tint", tintRenderer);
  registerEffectRenderer("curves", curvesRenderer);
  registerEffectRenderer("glow", glowRenderer);
  registerEffectRenderer("drop-shadow", dropShadowRenderer);
  registerEffectRenderer("color-balance", colorBalanceRenderer);
  registerEffectRenderer("exposure", exposureRenderer);
  registerEffectRenderer("vibrance", vibranceRenderer);
  registerEffectRenderer("invert", invertRenderer);
  registerEffectRenderer("posterize", posterizeRenderer);
  registerEffectRenderer("threshold", thresholdRenderer);
}

function initializeEffects() {
  registerBlurEffects();
  registerColorEffects();
}

let appInstance = null;
function mountApp(container) {
  let el = null;
  if (typeof container === "string") {
    el = document.getElementById(container) || document.querySelector(container);
  } else if (container instanceof HTMLElement) {
    el = container;
  } else {
    el = document.getElementById("weyl-compositor-root") || document.getElementById("app");
  }
  if (!el) return null;
  initializeEffects();
  const app = createApp(_sfc_main);
  app.use(createPinia());
  app.mount(el);
  appInstance = app;
  setupBridge();
  return app;
}
function setupBridge() {
  window.addEventListener("weyl:inputs-ready", (e) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: e.detail }));
  });
}
async function sendToComfyUI(matte, preview) {
  return window.WeylCompositor?.sendOutput?.(matte, preview) ?? false;
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => mountApp());
} else {
  setTimeout(() => {
    if (!appInstance) mountApp();
  }, 0);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var jszip_min$1 = {exports: {}};

(function (module, exports$1) {
	var define_process_default = { env: {} };
	/*!

	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/main/LICENSE
	*/
	!function(e) {
	  module.exports = e();
	}(function() {
	  return function s(a, o, h) {
	    function u(r, e2) {
	      if (!o[r]) {
	        if (!a[r]) {
	          var t = "function" == typeof commonjsRequire && commonjsRequire;
	          if (!e2 && t) return t(r, true);
	          if (l) return l(r, true);
	          var n = new Error("Cannot find module '" + r + "'");
	          throw n.code = "MODULE_NOT_FOUND", n;
	        }
	        var i = o[r] = { exports: {} };
	        a[r][0].call(i.exports, function(e3) {
	          var t2 = a[r][1][e3];
	          return u(t2 || e3);
	        }, i, i.exports, s, a, o, h);
	      }
	      return o[r].exports;
	    }
	    for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++) u(h[e]);
	    return u;
	  }({ 1: [function(e, t, r) {
	    var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	    r.encode = function(e2) {
	      for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
	      return h.join("");
	    }, r.decode = function(e2) {
	      var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
	      if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
	      var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
	      if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
	      for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
	      return l;
	    };
	  }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
	    var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
	    function o(e2, t2, r2, n2, i2) {
	      this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
	    }
	    o.prototype = { getContentWorker: function() {
	      var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
	      return e2.on("end", function() {
	        if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
	      }), e2;
	    }, getCompressedWorker: function() {
	      return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
	    } }, o.createWorkerFrom = function(e2, t2, r2) {
	      return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
	    }, t.exports = o;
	  }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
	    var n = e("./stream/GenericWorker");
	    r.STORE = { magic: "\0\0", compressWorker: function() {
	      return new n("STORE compression");
	    }, uncompressWorker: function() {
	      return new n("STORE decompression");
	    } }, r.DEFLATE = e("./flate");
	  }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
	    var n = e("./utils");
	    var o = function() {
	      for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
	        e2 = r2;
	        for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
	        t2[r2] = e2;
	      }
	      return t2;
	    }();
	    t.exports = function(e2, t2) {
	      return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
	        var i = o, s = n2 + r2;
	        e3 ^= -1;
	        for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
	        return -1 ^ e3;
	      }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
	        var i = o, s = n2 + r2;
	        e3 ^= -1;
	        for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
	        return -1 ^ e3;
	      }(0 | t2, e2, e2.length, 0) : 0;
	    };
	  }, { "./utils": 32 }], 5: [function(e, t, r) {
	    r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
	  }, {}], 6: [function(e, t, r) {
	    var n = null;
	    n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
	  }, { lie: 37 }], 7: [function(e, t, r) {
	    var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
	    function h(e2, t2) {
	      a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
	    }
	    r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
	      this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
	    }, h.prototype.flush = function() {
	      a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
	    }, h.prototype.cleanUp = function() {
	      a.prototype.cleanUp.call(this), this._pako = null;
	    }, h.prototype._createPako = function() {
	      this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
	      var t2 = this;
	      this._pako.onData = function(e2) {
	        t2.push({ data: e2, meta: t2.meta });
	      };
	    }, r.compressWorker = function(e2) {
	      return new h("Deflate", e2);
	    }, r.uncompressWorker = function() {
	      return new h("Inflate", {});
	    };
	  }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
	    function A(e2, t2) {
	      var r2, n2 = "";
	      for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
	      return n2;
	    }
	    function n(e2, t2, r2, n2, i2, s2) {
	      var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
	      t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
	      var S = 0;
	      t2 && (S |= 8), l || !_ && !g || (S |= 2048);
	      var z = 0, C = 0;
	      w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
	        var r3 = e3;
	        return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
	      }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
	        return 63 & (e3 || 0);
	      }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
	      var E = "";
	      return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
	    }
	    var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
	    function s(e2, t2, r2, n2) {
	      i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
	    }
	    I.inherits(s, i), s.prototype.push = function(e2) {
	      var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
	      this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
	    }, s.prototype.openedSource = function(e2) {
	      this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
	      var t2 = this.streamFiles && !e2.file.dir;
	      if (t2) {
	        var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
	        this.push({ data: r2.fileRecord, meta: { percent: 0 } });
	      } else this.accumulate = true;
	    }, s.prototype.closedSource = function(e2) {
	      this.accumulate = false;
	      var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
	      if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: function(e3) {
	        return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
	      }(e2), meta: { percent: 100 } });
	      else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
	      this.currentFile = null;
	    }, s.prototype.flush = function() {
	      for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
	      var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
	        var s2 = I.transformTo("string", i2(n3));
	        return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
	      }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
	      this.push({ data: n2, meta: { percent: 100 } });
	    }, s.prototype.prepareNextSource = function() {
	      this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
	    }, s.prototype.registerPrevious = function(e2) {
	      this._sources.push(e2);
	      var t2 = this;
	      return e2.on("data", function(e3) {
	        t2.processChunk(e3);
	      }), e2.on("end", function() {
	        t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
	      }), e2.on("error", function(e3) {
	        t2.error(e3);
	      }), this;
	    }, s.prototype.resume = function() {
	      return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
	    }, s.prototype.error = function(e2) {
	      var t2 = this._sources;
	      if (!i.prototype.error.call(this, e2)) return false;
	      for (var r2 = 0; r2 < t2.length; r2++) try {
	        t2[r2].error(e2);
	      } catch (e3) {
	      }
	      return true;
	    }, s.prototype.lock = function() {
	      i.prototype.lock.call(this);
	      for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
	    }, t.exports = s;
	  }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
	    var u = e("../compressions"), n = e("./ZipFileWorker");
	    r.generateWorker = function(e2, a, t2) {
	      var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
	      try {
	        e2.forEach(function(e3, t3) {
	          h++;
	          var r2 = function(e4, t4) {
	            var r3 = e4 || t4, n3 = u[r3];
	            if (!n3) throw new Error(r3 + " is not a valid compression method !");
	            return n3;
	          }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
	          t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
	        }), o.entriesCount = h;
	      } catch (e3) {
	        o.error(e3);
	      }
	      return o;
	    };
	  }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
	    function n() {
	      if (!(this instanceof n)) return new n();
	      if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
	      this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
	        var e2 = new n();
	        for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
	        return e2;
	      };
	    }
	    (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
	      return new n().loadAsync(e2, t2);
	    }, n.external = e("./external"), t.exports = n;
	  }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
	    var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
	    function f(n2) {
	      return new i.Promise(function(e2, t2) {
	        var r2 = n2.decompressed.getContentWorker().pipe(new a());
	        r2.on("error", function(e3) {
	          t2(e3);
	        }).on("end", function() {
	          r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
	        }).resume();
	      });
	    }
	    t.exports = function(e2, o) {
	      var h = this;
	      return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
	        var t2 = new s(o);
	        return t2.load(e3), t2;
	      }).then(function(e3) {
	        var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
	        if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
	        return i.Promise.all(t2);
	      }).then(function(e3) {
	        for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
	          var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
	          h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
	        }
	        return t2.zipComment.length && (h.comment = t2.zipComment), h;
	      });
	    };
	  }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
	    var n = e("../utils"), i = e("../stream/GenericWorker");
	    function s(e2, t2) {
	      i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
	    }
	    n.inherits(s, i), s.prototype._bindStream = function(e2) {
	      var t2 = this;
	      (this._stream = e2).pause(), e2.on("data", function(e3) {
	        t2.push({ data: e3, meta: { percent: 0 } });
	      }).on("error", function(e3) {
	        t2.isPaused ? this.generatedError = e3 : t2.error(e3);
	      }).on("end", function() {
	        t2.isPaused ? t2._upstreamEnded = true : t2.end();
	      });
	    }, s.prototype.pause = function() {
	      return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
	    }, s.prototype.resume = function() {
	      return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
	    }, t.exports = s;
	  }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
	    var i = e("readable-stream").Readable;
	    function n(e2, t2, r2) {
	      i.call(this, t2), this._helper = e2;
	      var n2 = this;
	      e2.on("data", function(e3, t3) {
	        n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
	      }).on("error", function(e3) {
	        n2.emit("error", e3);
	      }).on("end", function() {
	        n2.push(null);
	      });
	    }
	    e("../utils").inherits(n, i), n.prototype._read = function() {
	      this._helper.resume();
	    }, t.exports = n;
	  }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
	    t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
	      if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);
	      if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
	      return new Buffer(e2, t2);
	    }, allocBuffer: function(e2) {
	      if (Buffer.alloc) return Buffer.alloc(e2);
	      var t2 = new Buffer(e2);
	      return t2.fill(0), t2;
	    }, isBuffer: function(e2) {
	      return Buffer.isBuffer(e2);
	    }, isStream: function(e2) {
	      return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
	    } };
	  }, {}], 15: [function(e, t, r) {
	    function s(e2, t2, r2) {
	      var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
	      s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
	      var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
	      r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
	      var o2 = null;
	      o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
	      var h2 = new d(e2, o2, s2);
	      this.files[e2] = h2;
	    }
	    var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
	      "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
	      var t2 = e2.lastIndexOf("/");
	      return 0 < t2 ? e2.substring(0, t2) : "";
	    }, g = function(e2) {
	      return "/" !== e2.slice(-1) && (e2 += "/"), e2;
	    }, b = function(e2, t2) {
	      return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
	    };
	    function h(e2) {
	      return "[object RegExp]" === Object.prototype.toString.call(e2);
	    }
	    var n = { load: function() {
	      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
	    }, forEach: function(e2) {
	      var t2, r2, n2;
	      for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
	    }, filter: function(r2) {
	      var n2 = [];
	      return this.forEach(function(e2, t2) {
	        r2(e2, t2) && n2.push(t2);
	      }), n2;
	    }, file: function(e2, t2, r2) {
	      if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
	      if (h(e2)) {
	        var n2 = e2;
	        return this.filter(function(e3, t3) {
	          return !t3.dir && n2.test(e3);
	        });
	      }
	      var i2 = this.files[this.root + e2];
	      return i2 && !i2.dir ? i2 : null;
	    }, folder: function(r2) {
	      if (!r2) return this;
	      if (h(r2)) return this.filter(function(e3, t3) {
	        return t3.dir && r2.test(e3);
	      });
	      var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
	      return n2.root = t2.name, n2;
	    }, remove: function(r2) {
	      r2 = this.root + r2;
	      var e2 = this.files[r2];
	      if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
	      else for (var t2 = this.filter(function(e3, t3) {
	        return t3.name.slice(0, r2.length) === r2;
	      }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
	      return this;
	    }, generate: function() {
	      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
	    }, generateInternalStream: function(e2) {
	      var t2, r2 = {};
	      try {
	        if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
	        u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
	        var n2 = r2.comment || this.comment || "";
	        t2 = o.generateWorker(this, r2, n2);
	      } catch (e3) {
	        (t2 = new l("error")).error(e3);
	      }
	      return new a(t2, r2.type || "string", r2.mimeType);
	    }, generateAsync: function(e2, t2) {
	      return this.generateInternalStream(e2).accumulate(t2);
	    }, generateNodeStream: function(e2, t2) {
	      return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
	    } };
	    t.exports = n;
	  }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
	    t.exports = e("stream");
	  }, { stream: void 0 }], 17: [function(e, t, r) {
	    var n = e("./DataReader");
	    function i(e2) {
	      n.call(this, e2);
	      for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
	    }
	    e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
	      return this.data[this.zero + e2];
	    }, i.prototype.lastIndexOfSignature = function(e2) {
	      for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
	      return -1;
	    }, i.prototype.readAndCheckSignature = function(e2) {
	      var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
	      return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
	    }, i.prototype.readData = function(e2) {
	      if (this.checkOffset(e2), 0 === e2) return [];
	      var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
	      return this.index += e2, t2;
	    }, t.exports = i;
	  }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
	    var n = e("../utils");
	    function i(e2) {
	      this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
	    }
	    i.prototype = { checkOffset: function(e2) {
	      this.checkIndex(this.index + e2);
	    }, checkIndex: function(e2) {
	      if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
	    }, setIndex: function(e2) {
	      this.checkIndex(e2), this.index = e2;
	    }, skip: function(e2) {
	      this.setIndex(this.index + e2);
	    }, byteAt: function() {
	    }, readInt: function(e2) {
	      var t2, r2 = 0;
	      for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
	      return this.index += e2, r2;
	    }, readString: function(e2) {
	      return n.transformTo("string", this.readData(e2));
	    }, readData: function() {
	    }, lastIndexOfSignature: function() {
	    }, readAndCheckSignature: function() {
	    }, readDate: function() {
	      var e2 = this.readInt(4);
	      return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
	    } }, t.exports = i;
	  }, { "../utils": 32 }], 19: [function(e, t, r) {
	    var n = e("./Uint8ArrayReader");
	    function i(e2) {
	      n.call(this, e2);
	    }
	    e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
	      this.checkOffset(e2);
	      var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
	      return this.index += e2, t2;
	    }, t.exports = i;
	  }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
	    var n = e("./DataReader");
	    function i(e2) {
	      n.call(this, e2);
	    }
	    e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
	      return this.data.charCodeAt(this.zero + e2);
	    }, i.prototype.lastIndexOfSignature = function(e2) {
	      return this.data.lastIndexOf(e2) - this.zero;
	    }, i.prototype.readAndCheckSignature = function(e2) {
	      return e2 === this.readData(4);
	    }, i.prototype.readData = function(e2) {
	      this.checkOffset(e2);
	      var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
	      return this.index += e2, t2;
	    }, t.exports = i;
	  }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
	    var n = e("./ArrayReader");
	    function i(e2) {
	      n.call(this, e2);
	    }
	    e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
	      if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
	      var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
	      return this.index += e2, t2;
	    }, t.exports = i;
	  }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
	    var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
	    t.exports = function(e2) {
	      var t2 = n.getTypeOf(e2);
	      return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
	    };
	  }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
	    r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
	  }, {}], 24: [function(e, t, r) {
	    var n = e("./GenericWorker"), i = e("../utils");
	    function s(e2) {
	      n.call(this, "ConvertWorker to " + e2), this.destType = e2;
	    }
	    i.inherits(s, n), s.prototype.processChunk = function(e2) {
	      this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
	    }, t.exports = s;
	  }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
	    var n = e("./GenericWorker"), i = e("../crc32");
	    function s() {
	      n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
	    }
	    e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
	      this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
	    }, t.exports = s;
	  }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
	    var n = e("../utils"), i = e("./GenericWorker");
	    function s(e2) {
	      i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
	    }
	    n.inherits(s, i), s.prototype.processChunk = function(e2) {
	      if (e2) {
	        var t2 = this.streamInfo[this.propName] || 0;
	        this.streamInfo[this.propName] = t2 + e2.data.length;
	      }
	      i.prototype.processChunk.call(this, e2);
	    }, t.exports = s;
	  }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
	    var n = e("../utils"), i = e("./GenericWorker");
	    function s(e2) {
	      i.call(this, "DataWorker");
	      var t2 = this;
	      this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
	        t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
	      }, function(e3) {
	        t2.error(e3);
	      });
	    }
	    n.inherits(s, i), s.prototype.cleanUp = function() {
	      i.prototype.cleanUp.call(this), this.data = null;
	    }, s.prototype.resume = function() {
	      return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
	    }, s.prototype._tickAndRepeat = function() {
	      this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
	    }, s.prototype._tick = function() {
	      if (this.isPaused || this.isFinished) return false;
	      var e2 = null, t2 = Math.min(this.max, this.index + 16384);
	      if (this.index >= this.max) return this.end();
	      switch (this.type) {
	        case "string":
	          e2 = this.data.substring(this.index, t2);
	          break;
	        case "uint8array":
	          e2 = this.data.subarray(this.index, t2);
	          break;
	        case "array":
	        case "nodebuffer":
	          e2 = this.data.slice(this.index, t2);
	      }
	      return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
	    }, t.exports = s;
	  }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
	    function n(e2) {
	      this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
	    }
	    n.prototype = { push: function(e2) {
	      this.emit("data", e2);
	    }, end: function() {
	      if (this.isFinished) return false;
	      this.flush();
	      try {
	        this.emit("end"), this.cleanUp(), this.isFinished = true;
	      } catch (e2) {
	        this.emit("error", e2);
	      }
	      return true;
	    }, error: function(e2) {
	      return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
	    }, on: function(e2, t2) {
	      return this._listeners[e2].push(t2), this;
	    }, cleanUp: function() {
	      this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
	    }, emit: function(e2, t2) {
	      if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);
	    }, pipe: function(e2) {
	      return e2.registerPrevious(this);
	    }, registerPrevious: function(e2) {
	      if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
	      this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
	      var t2 = this;
	      return e2.on("data", function(e3) {
	        t2.processChunk(e3);
	      }), e2.on("end", function() {
	        t2.end();
	      }), e2.on("error", function(e3) {
	        t2.error(e3);
	      }), this;
	    }, pause: function() {
	      return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
	    }, resume: function() {
	      if (!this.isPaused || this.isFinished) return false;
	      var e2 = this.isPaused = false;
	      return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
	    }, flush: function() {
	    }, processChunk: function(e2) {
	      this.push(e2);
	    }, withStreamInfo: function(e2, t2) {
	      return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
	    }, mergeStreamInfo: function() {
	      for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
	    }, lock: function() {
	      if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
	      this.isLocked = true, this.previous && this.previous.lock();
	    }, toString: function() {
	      var e2 = "Worker " + this.name;
	      return this.previous ? this.previous + " -> " + e2 : e2;
	    } }, t.exports = n;
	  }, {}], 29: [function(e, t, r) {
	    var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
	    if (n.nodestream) try {
	      o = e("../nodejs/NodejsStreamOutputAdapter");
	    } catch (e2) {
	    }
	    function l(e2, o2) {
	      return new a.Promise(function(t2, r2) {
	        var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
	        e2.on("data", function(e3, t3) {
	          n2.push(e3), o2 && o2(t3);
	        }).on("error", function(e3) {
	          n2 = [], r2(e3);
	        }).on("end", function() {
	          try {
	            var e3 = function(e4, t3, r3) {
	              switch (e4) {
	                case "blob":
	                  return h.newBlob(h.transformTo("arraybuffer", t3), r3);
	                case "base64":
	                  return u.encode(t3);
	                default:
	                  return h.transformTo(e4, t3);
	              }
	            }(s2, function(e4, t3) {
	              var r3, n3 = 0, i3 = null, s3 = 0;
	              for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
	              switch (e4) {
	                case "string":
	                  return t3.join("");
	                case "array":
	                  return Array.prototype.concat.apply([], t3);
	                case "uint8array":
	                  for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
	                  return i3;
	                case "nodebuffer":
	                  return Buffer.concat(t3);
	                default:
	                  throw new Error("concat : unsupported type '" + e4 + "'");
	              }
	            }(i2, n2), a2);
	            t2(e3);
	          } catch (e4) {
	            r2(e4);
	          }
	          n2 = [];
	        }).resume();
	      });
	    }
	    function f(e2, t2, r2) {
	      var n2 = t2;
	      switch (t2) {
	        case "blob":
	        case "arraybuffer":
	          n2 = "uint8array";
	          break;
	        case "base64":
	          n2 = "string";
	      }
	      try {
	        this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
	      } catch (e3) {
	        this._worker = new s("error"), this._worker.error(e3);
	      }
	    }
	    f.prototype = { accumulate: function(e2) {
	      return l(this, e2);
	    }, on: function(e2, t2) {
	      var r2 = this;
	      return "data" === e2 ? this._worker.on(e2, function(e3) {
	        t2.call(r2, e3.data, e3.meta);
	      }) : this._worker.on(e2, function() {
	        h.delay(t2, arguments, r2);
	      }), this;
	    }, resume: function() {
	      return h.delay(this._worker.resume, [], this._worker), this;
	    }, pause: function() {
	      return this._worker.pause(), this;
	    }, toNodejsStream: function(e2) {
	      if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
	      return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
	    } }, t.exports = f;
	  }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
	    if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
	    else {
	      var n = new ArrayBuffer(0);
	      try {
	        r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
	      } catch (e2) {
	        try {
	          var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
	          i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
	        } catch (e3) {
	          r.blob = false;
	        }
	      }
	    }
	    try {
	      r.nodestream = !!e("readable-stream").Readable;
	    } catch (e2) {
	      r.nodestream = false;
	    }
	  }, { "readable-stream": 16 }], 31: [function(e, t, s) {
	    for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
	    u[254] = u[254] = 1;
	    function a() {
	      n.call(this, "utf-8 decode"), this.leftOver = null;
	    }
	    function l() {
	      n.call(this, "utf-8 encode");
	    }
	    s.utf8encode = function(e2) {
	      return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
	        var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
	        for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
	        for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
	        return t2;
	      }(e2);
	    }, s.utf8decode = function(e2) {
	      return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
	        var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
	        for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;
	        else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;
	        else {
	          for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
	          1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
	        }
	        return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
	      }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
	    }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
	      var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
	      if (this.leftOver && this.leftOver.length) {
	        if (h.uint8array) {
	          var r2 = t2;
	          (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
	        } else t2 = this.leftOver.concat(t2);
	        this.leftOver = null;
	      }
	      var n2 = function(e3, t3) {
	        var r3;
	        for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
	        return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
	      }(t2), i2 = t2;
	      n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
	    }, a.prototype.flush = function() {
	      this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
	    }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
	      this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
	    }, s.Utf8EncodeWorker = l;
	  }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
	    var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
	    function n(e2) {
	      return e2;
	    }
	    function l(e2, t2) {
	      for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);
	      return t2;
	    }
	    e("setimmediate"), a.newBlob = function(t2, r2) {
	      a.checkSupport("blob");
	      try {
	        return new Blob([t2], { type: r2 });
	      } catch (e2) {
	        try {
	          var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
	          return n2.append(t2), n2.getBlob(r2);
	        } catch (e3) {
	          throw new Error("Bug : can't construct the Blob.");
	        }
	      }
	    };
	    var i = { stringifyByChunk: function(e2, t2, r2) {
	      var n2 = [], i2 = 0, s2 = e2.length;
	      if (s2 <= r2) return String.fromCharCode.apply(null, e2);
	      for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
	      return n2.join("");
	    }, stringifyByChar: function(e2) {
	      for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);
	      return t2;
	    }, applyCanBeUsed: { uint8array: function() {
	      try {
	        return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
	      } catch (e2) {
	        return false;
	      }
	    }(), nodebuffer: function() {
	      try {
	        return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
	      } catch (e2) {
	        return false;
	      }
	    }() } };
	    function s(e2) {
	      var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
	      if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
	        return i.stringifyByChunk(e2, r2, t2);
	      } catch (e3) {
	        t2 = Math.floor(t2 / 2);
	      }
	      return i.stringifyByChar(e2);
	    }
	    function f(e2, t2) {
	      for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];
	      return t2;
	    }
	    a.applyFromCharCode = s;
	    var c = {};
	    c.string = { string: n, array: function(e2) {
	      return l(e2, new Array(e2.length));
	    }, arraybuffer: function(e2) {
	      return c.string.uint8array(e2).buffer;
	    }, uint8array: function(e2) {
	      return l(e2, new Uint8Array(e2.length));
	    }, nodebuffer: function(e2) {
	      return l(e2, r.allocBuffer(e2.length));
	    } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
	      return new Uint8Array(e2).buffer;
	    }, uint8array: function(e2) {
	      return new Uint8Array(e2);
	    }, nodebuffer: function(e2) {
	      return r.newBufferFrom(e2);
	    } }, c.arraybuffer = { string: function(e2) {
	      return s(new Uint8Array(e2));
	    }, array: function(e2) {
	      return f(new Uint8Array(e2), new Array(e2.byteLength));
	    }, arraybuffer: n, uint8array: function(e2) {
	      return new Uint8Array(e2);
	    }, nodebuffer: function(e2) {
	      return r.newBufferFrom(new Uint8Array(e2));
	    } }, c.uint8array = { string: s, array: function(e2) {
	      return f(e2, new Array(e2.length));
	    }, arraybuffer: function(e2) {
	      return e2.buffer;
	    }, uint8array: n, nodebuffer: function(e2) {
	      return r.newBufferFrom(e2);
	    } }, c.nodebuffer = { string: s, array: function(e2) {
	      return f(e2, new Array(e2.length));
	    }, arraybuffer: function(e2) {
	      return c.nodebuffer.uint8array(e2).buffer;
	    }, uint8array: function(e2) {
	      return f(e2, new Uint8Array(e2.length));
	    }, nodebuffer: n }, a.transformTo = function(e2, t2) {
	      if (t2 = t2 || "", !e2) return t2;
	      a.checkSupport(e2);
	      var r2 = a.getTypeOf(t2);
	      return c[r2][e2](t2);
	    }, a.resolve = function(e2) {
	      for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
	        var i2 = t2[n2];
	        "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
	      }
	      return r2.join("/");
	    }, a.getTypeOf = function(e2) {
	      return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
	    }, a.checkSupport = function(e2) {
	      if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
	    }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
	      var t2, r2, n2 = "";
	      for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
	      return n2;
	    }, a.delay = function(e2, t2, r2) {
	      setImmediate(function() {
	        e2.apply(r2 || null, t2 || []);
	      });
	    }, a.inherits = function(e2, t2) {
	      function r2() {
	      }
	      r2.prototype = t2.prototype, e2.prototype = new r2();
	    }, a.extend = function() {
	      var e2, t2, r2 = {};
	      for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
	      return r2;
	    }, a.prepareContent = function(r2, e2, n2, i2, s2) {
	      return u.Promise.resolve(e2).then(function(n3) {
	        return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
	          var e3 = new FileReader();
	          e3.onload = function(e4) {
	            t2(e4.target.result);
	          }, e3.onerror = function(e4) {
	            r3(e4.target.error);
	          }, e3.readAsArrayBuffer(n3);
	        }) : n3;
	      }).then(function(e3) {
	        var t2 = a.getTypeOf(e3);
	        return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
	          return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
	        }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
	      });
	    };
	  }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
	    var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
	    function h(e2) {
	      this.files = [], this.loadOptions = e2;
	    }
	    h.prototype = { checkSignature: function(e2) {
	      if (!this.reader.readAndCheckSignature(e2)) {
	        this.reader.index -= 4;
	        var t2 = this.reader.readString(4);
	        throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
	      }
	    }, isSignature: function(e2, t2) {
	      var r2 = this.reader.index;
	      this.reader.setIndex(e2);
	      var n2 = this.reader.readString(4) === t2;
	      return this.reader.setIndex(r2), n2;
	    }, readBlockEndOfCentral: function() {
	      this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
	      var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
	      this.zipComment = this.loadOptions.decodeFileName(r2);
	    }, readBlockZip64EndOfCentral: function() {
	      this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
	      for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
	    }, readBlockZip64EndOfCentralLocator: function() {
	      if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
	    }, readLocalFiles: function() {
	      var e2, t2;
	      for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
	    }, readCentralDir: function() {
	      var e2;
	      for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
	      if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
	    }, readEndOfCentral: function() {
	      var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
	      if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
	      this.reader.setIndex(e2);
	      var t2 = e2;
	      if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
	        if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
	        if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
	        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
	      }
	      var r2 = this.centralDirOffset + this.centralDirSize;
	      this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
	      var n2 = t2 - r2;
	      if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
	      else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
	    }, prepareReader: function(e2) {
	      this.reader = n(e2);
	    }, load: function(e2) {
	      this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
	    } }, t.exports = h;
	  }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
	    var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
	    function l(e2, t2) {
	      this.options = e2, this.loadOptions = t2;
	    }
	    l.prototype = { isEncrypted: function() {
	      return 1 == (1 & this.bitFlag);
	    }, useUTF8: function() {
	      return 2048 == (2048 & this.bitFlag);
	    }, readLocalPart: function(e2) {
	      var t2, r2;
	      if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
	      if (null === (t2 = function(e3) {
	        for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3) return h[t3];
	        return null;
	      }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
	      this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
	    }, readCentralPart: function(e2) {
	      this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
	      var t2 = e2.readInt(2);
	      if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
	      e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
	    }, processAttributes: function() {
	      this.unixPermissions = null, this.dosPermissions = null;
	      var e2 = this.versionMadeBy >> 8;
	      this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
	    }, parseZIP64ExtraField: function() {
	      if (this.extraFields[1]) {
	        var e2 = n(this.extraFields[1].value);
	        this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
	      }
	    }, readExtraFields: function(e2) {
	      var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
	      for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
	      e2.setIndex(i2);
	    }, handleUTF8: function() {
	      var e2 = u.uint8array ? "uint8array" : "array";
	      if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
	      else {
	        var t2 = this.findExtraFieldUnicodePath();
	        if (null !== t2) this.fileNameStr = t2;
	        else {
	          var r2 = s.transformTo(e2, this.fileName);
	          this.fileNameStr = this.loadOptions.decodeFileName(r2);
	        }
	        var n2 = this.findExtraFieldUnicodeComment();
	        if (null !== n2) this.fileCommentStr = n2;
	        else {
	          var i2 = s.transformTo(e2, this.fileComment);
	          this.fileCommentStr = this.loadOptions.decodeFileName(i2);
	        }
	      }
	    }, findExtraFieldUnicodePath: function() {
	      var e2 = this.extraFields[28789];
	      if (e2) {
	        var t2 = n(e2.value);
	        return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
	      }
	      return null;
	    }, findExtraFieldUnicodeComment: function() {
	      var e2 = this.extraFields[25461];
	      if (e2) {
	        var t2 = n(e2.value);
	        return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
	      }
	      return null;
	    } }, t.exports = l;
	  }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
	    function n(e2, t2, r2) {
	      this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
	    }
	    var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
	    n.prototype = { internalStream: function(e2) {
	      var t2 = null, r2 = "string";
	      try {
	        if (!e2) throw new Error("No output type specified.");
	        var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
	        "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
	        var i2 = !this._dataBinary;
	        i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
	      } catch (e3) {
	        (t2 = new h("error")).error(e3);
	      }
	      return new s(t2, r2, "");
	    }, async: function(e2, t2) {
	      return this.internalStream(e2).accumulate(t2);
	    }, nodeStream: function(e2, t2) {
	      return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
	    }, _compressWorker: function(e2, t2) {
	      if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
	      var r2 = this._decompressWorker();
	      return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
	    }, _decompressWorker: function() {
	      return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
	    } };
	    for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
	      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
	    }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
	    t.exports = n;
	  }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
	    (function(t2) {
	      var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
	      if (e2) {
	        var i = 0, s = new e2(u), a = t2.document.createTextNode("");
	        s.observe(a, { characterData: true }), r = function() {
	          a.data = i = ++i % 2;
	        };
	      } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
	        var e3 = t2.document.createElement("script");
	        e3.onreadystatechange = function() {
	          u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
	        }, t2.document.documentElement.appendChild(e3);
	      } : function() {
	        setTimeout(u, 0);
	      };
	      else {
	        var o = new t2.MessageChannel();
	        o.port1.onmessage = u, r = function() {
	          o.port2.postMessage(0);
	        };
	      }
	      var h = [];
	      function u() {
	        var e3, t3;
	        n = true;
	        for (var r2 = h.length; r2; ) {
	          for (t3 = h, h = [], e3 = -1; ++e3 < r2; ) t3[e3]();
	          r2 = h.length;
	        }
	        n = false;
	      }
	      l.exports = function(e3) {
	        1 !== h.push(e3) || n || r();
	      };
	    }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
	  }, {}], 37: [function(e, t, r) {
	    var i = e("immediate");
	    function u() {
	    }
	    var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
	    function o(e2) {
	      if ("function" != typeof e2) throw new TypeError("resolver must be a function");
	      this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
	    }
	    function h(e2, t2, r2) {
	      this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
	    }
	    function f(t2, r2, n2) {
	      i(function() {
	        var e2;
	        try {
	          e2 = r2(n2);
	        } catch (e3) {
	          return l.reject(t2, e3);
	        }
	        e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
	      });
	    }
	    function c(e2) {
	      var t2 = e2 && e2.then;
	      if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
	        t2.apply(e2, arguments);
	      };
	    }
	    function d(t2, e2) {
	      var r2 = false;
	      function n2(e3) {
	        r2 || (r2 = true, l.reject(t2, e3));
	      }
	      function i2(e3) {
	        r2 || (r2 = true, l.resolve(t2, e3));
	      }
	      var s2 = p(function() {
	        e2(i2, n2);
	      });
	      "error" === s2.status && n2(s2.value);
	    }
	    function p(e2, t2) {
	      var r2 = {};
	      try {
	        r2.value = e2(t2), r2.status = "success";
	      } catch (e3) {
	        r2.status = "error", r2.value = e3;
	      }
	      return r2;
	    }
	    (t.exports = o).prototype.finally = function(t2) {
	      if ("function" != typeof t2) return this;
	      var r2 = this.constructor;
	      return this.then(function(e2) {
	        return r2.resolve(t2()).then(function() {
	          return e2;
	        });
	      }, function(e2) {
	        return r2.resolve(t2()).then(function() {
	          throw e2;
	        });
	      });
	    }, o.prototype.catch = function(e2) {
	      return this.then(null, e2);
	    }, o.prototype.then = function(e2, t2) {
	      if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
	      var r2 = new this.constructor(u);
	      this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
	      return r2;
	    }, h.prototype.callFulfilled = function(e2) {
	      l.resolve(this.promise, e2);
	    }, h.prototype.otherCallFulfilled = function(e2) {
	      f(this.promise, this.onFulfilled, e2);
	    }, h.prototype.callRejected = function(e2) {
	      l.reject(this.promise, e2);
	    }, h.prototype.otherCallRejected = function(e2) {
	      f(this.promise, this.onRejected, e2);
	    }, l.resolve = function(e2, t2) {
	      var r2 = p(c, t2);
	      if ("error" === r2.status) return l.reject(e2, r2.value);
	      var n2 = r2.value;
	      if (n2) d(e2, n2);
	      else {
	        e2.state = a, e2.outcome = t2;
	        for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
	      }
	      return e2;
	    }, l.reject = function(e2, t2) {
	      e2.state = s, e2.outcome = t2;
	      for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);
	      return e2;
	    }, o.resolve = function(e2) {
	      if (e2 instanceof this) return e2;
	      return l.resolve(new this(u), e2);
	    }, o.reject = function(e2) {
	      var t2 = new this(u);
	      return l.reject(t2, e2);
	    }, o.all = function(e2) {
	      var r2 = this;
	      if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
	      var n2 = e2.length, i2 = false;
	      if (!n2) return this.resolve([]);
	      var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
	      for (; ++t2 < n2; ) h2(e2[t2], t2);
	      return o2;
	      function h2(e3, t3) {
	        r2.resolve(e3).then(function(e4) {
	          s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
	        }, function(e4) {
	          i2 || (i2 = true, l.reject(o2, e4));
	        });
	      }
	    }, o.race = function(e2) {
	      var t2 = this;
	      if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
	      var r2 = e2.length, n2 = false;
	      if (!r2) return this.resolve([]);
	      var i2 = -1, s2 = new this(u);
	      for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
	        n2 || (n2 = true, l.resolve(s2, e3));
	      }, function(e3) {
	        n2 || (n2 = true, l.reject(s2, e3));
	      });
	      var a2;
	      return s2;
	    };
	  }, { immediate: 36 }], 38: [function(e, t, r) {
	    var n = {};
	    (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
	  }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
	    var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
	    function p(e2) {
	      if (!(this instanceof p)) return new p(e2);
	      this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
	      var t2 = this.options;
	      t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
	      var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
	      if (r2 !== l) throw new Error(i[r2]);
	      if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
	        var n2;
	        if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
	        this._dict_set = true;
	      }
	    }
	    function n(e2, t2) {
	      var r2 = new p(t2);
	      if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
	      return r2.result;
	    }
	    p.prototype.push = function(e2, t2) {
	      var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
	      if (this.ended) return false;
	      n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
	      do {
	        if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
	        0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
	      } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
	      return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
	    }, p.prototype.onData = function(e2) {
	      this.chunks.push(e2);
	    }, p.prototype.onEnd = function(e2) {
	      e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
	    }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
	      return (t2 = t2 || {}).raw = true, n(e2, t2);
	    }, r.gzip = function(e2, t2) {
	      return (t2 = t2 || {}).gzip = true, n(e2, t2);
	    };
	  }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
	    var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
	    function a(e2) {
	      if (!(this instanceof a)) return new a(e2);
	      this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
	      var t2 = this.options;
	      t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
	      var r2 = c.inflateInit2(this.strm, t2.windowBits);
	      if (r2 !== m.Z_OK) throw new Error(n[r2]);
	      this.header = new s(), c.inflateGetHeader(this.strm, this.header);
	    }
	    function o(e2, t2) {
	      var r2 = new a(t2);
	      if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
	      return r2.result;
	    }
	    a.prototype.push = function(e2, t2) {
	      var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
	      if (this.ended) return false;
	      n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
	      do {
	        if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
	        h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
	      } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
	      return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
	    }, a.prototype.onData = function(e2) {
	      this.chunks.push(e2);
	    }, a.prototype.onEnd = function(e2) {
	      e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
	    }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
	      return (t2 = t2 || {}).raw = true, o(e2, t2);
	    }, r.ungzip = o;
	  }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
	    var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
	    r.assign = function(e2) {
	      for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
	        var r2 = t2.shift();
	        if (r2) {
	          if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
	          for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
	        }
	      }
	      return e2;
	    }, r.shrinkBuf = function(e2, t2) {
	      return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
	    };
	    var i = { arraySet: function(e2, t2, r2, n2, i2) {
	      if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
	      else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
	    }, flattenChunks: function(e2) {
	      var t2, r2, n2, i2, s2, a;
	      for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
	      for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
	      return a;
	    } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
	      for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
	    }, flattenChunks: function(e2) {
	      return [].concat.apply([], e2);
	    } };
	    r.setTyped = function(e2) {
	      e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
	    }, r.setTyped(n);
	  }, {}], 42: [function(e, t, r) {
	    var h = e("./common"), i = true, s = true;
	    try {
	      String.fromCharCode.apply(null, [0]);
	    } catch (e2) {
	      i = false;
	    }
	    try {
	      String.fromCharCode.apply(null, new Uint8Array(1));
	    } catch (e2) {
	      s = false;
	    }
	    for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
	    function l(e2, t2) {
	      if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
	      for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);
	      return r2;
	    }
	    u[254] = u[254] = 1, r.string2buf = function(e2) {
	      var t2, r2, n2, i2, s2, a = e2.length, o = 0;
	      for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
	      for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
	      return t2;
	    }, r.buf2binstring = function(e2) {
	      return l(e2, e2.length);
	    }, r.binstring2buf = function(e2) {
	      for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);
	      return t2;
	    }, r.buf2string = function(e2, t2) {
	      var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
	      for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
	      else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
	      else {
	        for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
	        1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
	      }
	      return l(o, n2);
	    }, r.utf8border = function(e2, t2) {
	      var r2;
	      for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
	      return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
	    };
	  }, { "./common": 41 }], 43: [function(e, t, r) {
	    t.exports = function(e2, t2, r2, n) {
	      for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
	        for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
	        i %= 65521, s %= 65521;
	      }
	      return i | s << 16 | 0;
	    };
	  }, {}], 44: [function(e, t, r) {
	    t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
	  }, {}], 45: [function(e, t, r) {
	    var o = function() {
	      for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
	        e2 = r2;
	        for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
	        t2[r2] = e2;
	      }
	      return t2;
	    }();
	    t.exports = function(e2, t2, r2, n) {
	      var i = o, s = n + r2;
	      e2 ^= -1;
	      for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
	      return -1 ^ e2;
	    };
	  }, {}], 46: [function(e, t, r) {
	    var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
	    function R(e2, t2) {
	      return e2.msg = n[t2], t2;
	    }
	    function T(e2) {
	      return (e2 << 1) - (4 < e2 ? 9 : 0);
	    }
	    function D(e2) {
	      for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
	    }
	    function F(e2) {
	      var t2 = e2.state, r2 = t2.pending;
	      r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
	    }
	    function N(e2, t2) {
	      u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
	    }
	    function U(e2, t2) {
	      e2.pending_buf[e2.pending++] = t2;
	    }
	    function P(e2, t2) {
	      e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
	    }
	    function L(e2, t2) {
	      var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
	      e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
	      do {
	        if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
	          s2 += 2, r2++;
	          do {
	          } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
	          if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
	            if (e2.match_start = t2, o2 <= (a2 = n2)) break;
	            d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
	          }
	        }
	      } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
	      return a2 <= e2.lookahead ? a2 : e2.lookahead;
	    }
	    function j(e2) {
	      var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
	      do {
	        if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
	          for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
	          for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
	          i2 += f2;
	        }
	        if (0 === e2.strm.avail_in) break;
	        if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
	      } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
	    }
	    function Z(e2, t2) {
	      for (var r2, n2; ; ) {
	        if (e2.lookahead < z) {
	          if (j(e2), e2.lookahead < z && t2 === l) return A;
	          if (0 === e2.lookahead) break;
	        }
	        if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
	          for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
	          e2.strstart++;
	        } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
	        else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
	        if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
	      }
	      return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
	    }
	    function W(e2, t2) {
	      for (var r2, n2, i2; ; ) {
	        if (e2.lookahead < z) {
	          if (j(e2), e2.lookahead < z && t2 === l) return A;
	          if (0 === e2.lookahead) break;
	        }
	        if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
	          for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
	          if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
	        } else if (e2.match_available) {
	          if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
	        } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
	      }
	      return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
	    }
	    function M(e2, t2, r2, n2, i2) {
	      this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
	    }
	    function H() {
	      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
	    }
	    function G(e2) {
	      var t2;
	      return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
	    }
	    function K(e2) {
	      var t2 = G(e2);
	      return t2 === m && function(e3) {
	        e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
	      }(e2.state), t2;
	    }
	    function Y(e2, t2, r2, n2, i2, s2) {
	      if (!e2) return _;
	      var a2 = 1;
	      if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _);
	      8 === n2 && (n2 = 9);
	      var o2 = new H();
	      return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
	    }
	    h = [new M(0, 0, 0, 0, function(e2, t2) {
	      var r2 = 65535;
	      for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
	        if (e2.lookahead <= 1) {
	          if (j(e2), 0 === e2.lookahead && t2 === l) return A;
	          if (0 === e2.lookahead) break;
	        }
	        e2.strstart += e2.lookahead, e2.lookahead = 0;
	        var n2 = e2.block_start + r2;
	        if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
	        if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;
	      }
	      return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
	    }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
	      return Y(e2, t2, v, 15, 8, 0);
	    }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
	      return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
	    }, r.deflate = function(e2, t2) {
	      var r2, n2, i2, s2;
	      if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _) : _;
	      if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);
	      if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
	      else {
	        var a2 = v + (n2.w_bits - 8 << 4) << 8;
	        a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
	      }
	      if (69 === n2.status) if (n2.gzhead.extra) {
	        for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
	        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
	      } else n2.status = 73;
	      if (73 === n2.status) if (n2.gzhead.name) {
	        i2 = n2.pending;
	        do {
	          if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
	            s2 = 1;
	            break;
	          }
	          s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
	        } while (0 !== s2);
	        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
	      } else n2.status = 91;
	      if (91 === n2.status) if (n2.gzhead.comment) {
	        i2 = n2.pending;
	        do {
	          if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
	            s2 = 1;
	            break;
	          }
	          s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
	        } while (0 !== s2);
	        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
	      } else n2.status = 103;
	      if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
	        if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
	      } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);
	      if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
	      if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
	        var o2 = 2 === n2.strategy ? function(e3, t3) {
	          for (var r3; ; ) {
	            if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
	              if (t3 === l) return A;
	              break;
	            }
	            if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
	          }
	          return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
	        }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
	          for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
	            if (e3.lookahead <= S) {
	              if (j(e3), e3.lookahead <= S && t3 === l) return A;
	              if (0 === e3.lookahead) break;
	            }
	            if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
	              s3 = e3.strstart + S;
	              do {
	              } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
	              e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
	            }
	            if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
	          }
	          return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
	        }(n2, t2) : h[n2.level].func(n2, t2);
	        if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
	        if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
	      }
	      return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
	    }, r.deflateEnd = function(e2) {
	      var t2;
	      return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
	    }, r.deflateSetDictionary = function(e2, t2) {
	      var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
	      if (!e2 || !e2.state) return _;
	      if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
	      for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
	        for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
	        r2.strstart = n2, r2.lookahead = x - 1, j(r2);
	      }
	      return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
	    }, r.deflateInfo = "pako deflate (from Nodeca project)";
	  }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
	    t.exports = function() {
	      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
	    };
	  }, {}], 48: [function(e, t, r) {
	    t.exports = function(e2, t2) {
	      var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
	      r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
	      e: do {
	        p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
	        t: for (; ; ) {
	          if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
	          else {
	            if (!(16 & y)) {
	              if (0 == (64 & y)) {
	                v = m[(65535 & v) + (d & (1 << y) - 1)];
	                continue t;
	              }
	              if (32 & y) {
	                r2.mode = 12;
	                break e;
	              }
	              e2.msg = "invalid literal/length code", r2.mode = 30;
	              break e;
	            }
	            w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
	            r: for (; ; ) {
	              if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
	                if (0 == (64 & y)) {
	                  v = _[(65535 & v) + (d & (1 << y) - 1)];
	                  continue r;
	                }
	                e2.msg = "invalid distance code", r2.mode = 30;
	                break e;
	              }
	              if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
	                e2.msg = "invalid distance too far back", r2.mode = 30;
	                break e;
	              }
	              if (d >>>= y, p -= y, (y = s - a) < k) {
	                if (l < (y = k - y) && r2.sane) {
	                  e2.msg = "invalid distance too far back", r2.mode = 30;
	                  break e;
	                }
	                if (S = c, (x = 0) === f) {
	                  if (x += u - y, y < w) {
	                    for (w -= y; C[s++] = c[x++], --y; ) ;
	                    x = s - k, S = C;
	                  }
	                } else if (f < y) {
	                  if (x += u + f - y, (y -= f) < w) {
	                    for (w -= y; C[s++] = c[x++], --y; ) ;
	                    if (x = 0, f < w) {
	                      for (w -= y = f; C[s++] = c[x++], --y; ) ;
	                      x = s - k, S = C;
	                    }
	                  }
	                } else if (x += f - y, y < w) {
	                  for (w -= y; C[s++] = c[x++], --y; ) ;
	                  x = s - k, S = C;
	                }
	                for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
	                w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
	              } else {
	                for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
	                w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
	              }
	              break;
	            }
	          }
	          break;
	        }
	      } while (n < i && s < o);
	      n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
	    };
	  }, {}], 49: [function(e, t, r) {
	    var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
	    function L(e2) {
	      return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
	    }
	    function s() {
	      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
	    }
	    function a(e2) {
	      var t2;
	      return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
	    }
	    function o(e2) {
	      var t2;
	      return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
	    }
	    function h(e2, t2) {
	      var r2, n2;
	      return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
	    }
	    function u(e2, t2) {
	      var r2, n2;
	      return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
	    }
	    var l, f, c = true;
	    function j(e2) {
	      if (c) {
	        var t2;
	        for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
	        for (; t2 < 256; ) e2.lens[t2++] = 9;
	        for (; t2 < 280; ) e2.lens[t2++] = 7;
	        for (; t2 < 288; ) e2.lens[t2++] = 8;
	        for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
	        T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
	      }
	      e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
	    }
	    function Z(e2, t2, r2, n2) {
	      var i2, s2 = e2.state;
	      return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
	    }
	    r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
	      return u(e2, 15);
	    }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
	      var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	      if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
	      12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
	      e: for (; ; ) switch (r2.mode) {
	        case P:
	          if (0 === r2.wrap) {
	            r2.mode = 13;
	            break;
	          }
	          for (; l2 < 16; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if (2 & r2.wrap && 35615 === u2) {
	            E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
	            break;
	          }
	          if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
	            e2.msg = "incorrect header check", r2.mode = 30;
	            break;
	          }
	          if (8 != (15 & u2)) {
	            e2.msg = "unknown compression method", r2.mode = 30;
	            break;
	          }
	          if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
	          else if (k > r2.wbits) {
	            e2.msg = "invalid window size", r2.mode = 30;
	            break;
	          }
	          r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
	          break;
	        case 2:
	          for (; l2 < 16; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if (r2.flags = u2, 8 != (255 & r2.flags)) {
	            e2.msg = "unknown compression method", r2.mode = 30;
	            break;
	          }
	          if (57344 & r2.flags) {
	            e2.msg = "unknown header flags set", r2.mode = 30;
	            break;
	          }
	          r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
	        case 3:
	          for (; l2 < 32; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
	        case 4:
	          for (; l2 < 16; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
	        case 5:
	          if (1024 & r2.flags) {
	            for (; l2 < 16; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
	          } else r2.head && (r2.head.extra = null);
	          r2.mode = 6;
	        case 6:
	          if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
	          r2.length = 0, r2.mode = 7;
	        case 7:
	          if (2048 & r2.flags) {
	            if (0 === o2) break e;
	            for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
	            if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
	          } else r2.head && (r2.head.name = null);
	          r2.length = 0, r2.mode = 8;
	        case 8:
	          if (4096 & r2.flags) {
	            if (0 === o2) break e;
	            for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
	            if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
	          } else r2.head && (r2.head.comment = null);
	          r2.mode = 9;
	        case 9:
	          if (512 & r2.flags) {
	            for (; l2 < 16; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            if (u2 !== (65535 & r2.check)) {
	              e2.msg = "header crc mismatch", r2.mode = 30;
	              break;
	            }
	            l2 = u2 = 0;
	          }
	          r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
	          break;
	        case 10:
	          for (; l2 < 32; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
	        case 11:
	          if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
	          e2.adler = r2.check = 1, r2.mode = 12;
	        case 12:
	          if (5 === t2 || 6 === t2) break e;
	        case 13:
	          if (r2.last) {
	            u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
	            break;
	          }
	          for (; l2 < 3; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
	            case 0:
	              r2.mode = 14;
	              break;
	            case 1:
	              if (j(r2), r2.mode = 20, 6 !== t2) break;
	              u2 >>>= 2, l2 -= 2;
	              break e;
	            case 2:
	              r2.mode = 17;
	              break;
	            case 3:
	              e2.msg = "invalid block type", r2.mode = 30;
	          }
	          u2 >>>= 2, l2 -= 2;
	          break;
	        case 14:
	          for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
	            e2.msg = "invalid stored block lengths", r2.mode = 30;
	            break;
	          }
	          if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;
	        case 15:
	          r2.mode = 16;
	        case 16:
	          if (d = r2.length) {
	            if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;
	            I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
	            break;
	          }
	          r2.mode = 12;
	          break;
	        case 17:
	          for (; l2 < 14; ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
	            e2.msg = "too many length or distance symbols", r2.mode = 30;
	            break;
	          }
	          r2.have = 0, r2.mode = 18;
	        case 18:
	          for (; r2.have < r2.ncode; ) {
	            for (; l2 < 3; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
	          }
	          for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
	          if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
	            e2.msg = "invalid code lengths set", r2.mode = 30;
	            break;
	          }
	          r2.have = 0, r2.mode = 19;
	        case 19:
	          for (; r2.have < r2.nlen + r2.ndist; ) {
	            for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
	            else {
	              if (16 === b) {
	                for (z = _ + 2; l2 < z; ) {
	                  if (0 === o2) break e;
	                  o2--, u2 += n2[s2++] << l2, l2 += 8;
	                }
	                if (u2 >>>= _, l2 -= _, 0 === r2.have) {
	                  e2.msg = "invalid bit length repeat", r2.mode = 30;
	                  break;
	                }
	                k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
	              } else if (17 === b) {
	                for (z = _ + 3; l2 < z; ) {
	                  if (0 === o2) break e;
	                  o2--, u2 += n2[s2++] << l2, l2 += 8;
	                }
	                l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
	              } else {
	                for (z = _ + 7; l2 < z; ) {
	                  if (0 === o2) break e;
	                  o2--, u2 += n2[s2++] << l2, l2 += 8;
	                }
	                l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
	              }
	              if (r2.have + d > r2.nlen + r2.ndist) {
	                e2.msg = "invalid bit length repeat", r2.mode = 30;
	                break;
	              }
	              for (; d--; ) r2.lens[r2.have++] = k;
	            }
	          }
	          if (30 === r2.mode) break;
	          if (0 === r2.lens[256]) {
	            e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
	            break;
	          }
	          if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
	            e2.msg = "invalid literal/lengths set", r2.mode = 30;
	            break;
	          }
	          if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
	            e2.msg = "invalid distances set", r2.mode = 30;
	            break;
	          }
	          if (r2.mode = 20, 6 === t2) break e;
	        case 20:
	          r2.mode = 21;
	        case 21:
	          if (6 <= o2 && 258 <= h2) {
	            e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
	            break;
	          }
	          for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if (g && 0 == (240 & g)) {
	            for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            u2 >>>= v, l2 -= v, r2.back += v;
	          }
	          if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
	            r2.mode = 26;
	            break;
	          }
	          if (32 & g) {
	            r2.back = -1, r2.mode = 12;
	            break;
	          }
	          if (64 & g) {
	            e2.msg = "invalid literal/length code", r2.mode = 30;
	            break;
	          }
	          r2.extra = 15 & g, r2.mode = 22;
	        case 22:
	          if (r2.extra) {
	            for (z = r2.extra; l2 < z; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
	          }
	          r2.was = r2.length, r2.mode = 23;
	        case 23:
	          for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
	            if (0 === o2) break e;
	            o2--, u2 += n2[s2++] << l2, l2 += 8;
	          }
	          if (0 == (240 & g)) {
	            for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            u2 >>>= v, l2 -= v, r2.back += v;
	          }
	          if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
	            e2.msg = "invalid distance code", r2.mode = 30;
	            break;
	          }
	          r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
	        case 24:
	          if (r2.extra) {
	            for (z = r2.extra; l2 < z; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
	          }
	          if (r2.offset > r2.dmax) {
	            e2.msg = "invalid distance too far back", r2.mode = 30;
	            break;
	          }
	          r2.mode = 25;
	        case 25:
	          if (0 === h2) break e;
	          if (d = c2 - h2, r2.offset > d) {
	            if ((d = r2.offset - d) > r2.whave && r2.sane) {
	              e2.msg = "invalid distance too far back", r2.mode = 30;
	              break;
	            }
	            p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
	          } else m = i2, p = a2 - r2.offset, d = r2.length;
	          for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
	          0 === r2.length && (r2.mode = 21);
	          break;
	        case 26:
	          if (0 === h2) break e;
	          i2[a2++] = r2.length, h2--, r2.mode = 21;
	          break;
	        case 27:
	          if (r2.wrap) {
	            for (; l2 < 32; ) {
	              if (0 === o2) break e;
	              o2--, u2 |= n2[s2++] << l2, l2 += 8;
	            }
	            if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
	              e2.msg = "incorrect data check", r2.mode = 30;
	              break;
	            }
	            l2 = u2 = 0;
	          }
	          r2.mode = 28;
	        case 28:
	          if (r2.wrap && r2.flags) {
	            for (; l2 < 32; ) {
	              if (0 === o2) break e;
	              o2--, u2 += n2[s2++] << l2, l2 += 8;
	            }
	            if (u2 !== (4294967295 & r2.total)) {
	              e2.msg = "incorrect length check", r2.mode = 30;
	              break;
	            }
	            l2 = u2 = 0;
	          }
	          r2.mode = 29;
	        case 29:
	          x = 1;
	          break e;
	        case 30:
	          x = -3;
	          break e;
	        case 31:
	          return -4;
	        case 32:
	        default:
	          return U;
	      }
	      return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
	    }, r.inflateEnd = function(e2) {
	      if (!e2 || !e2.state) return U;
	      var t2 = e2.state;
	      return t2.window && (t2.window = null), e2.state = null, N;
	    }, r.inflateGetHeader = function(e2, t2) {
	      var r2;
	      return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
	    }, r.inflateSetDictionary = function(e2, t2) {
	      var r2, n2 = t2.length;
	      return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
	    }, r.inflateInfo = "pako inflate (from Nodeca project)";
	  }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
	    var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
	    t.exports = function(e2, t2, r2, n, i, s, a, o) {
	      var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
	      for (b = 0; b <= 15; b++) O[b] = 0;
	      for (v = 0; v < n; v++) O[t2[r2 + v]]++;
	      for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
	      if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
	      for (y = 1; y < w && 0 === O[y]; y++) ;
	      for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
	      if (0 < z && (0 === e2 || 1 !== w)) return -1;
	      for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
	      for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
	      if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
	      for (; ; ) {
	        for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
	        for (h = 1 << b - 1; E & h; ) h >>= 1;
	        if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
	          if (b === w) break;
	          b = t2[r2 + a[v]];
	        }
	        if (k < b && (E & f) !== l) {
	          for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
	          if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
	          i[l = E & f] = k << 24 | x << 16 | c - s | 0;
	        }
	      }
	      return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
	    };
	  }, { "../utils/common": 41 }], 51: [function(e, t, r) {
	    t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
	  }, {}], 52: [function(e, t, r) {
	    var i = e("../utils/common"), o = 0, h = 1;
	    function n(e2) {
	      for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
	    }
	    var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
	    n(z);
	    var C = new Array(2 * f);
	    n(C);
	    var E = new Array(512);
	    n(E);
	    var A = new Array(256);
	    n(A);
	    var I = new Array(a);
	    n(I);
	    var O, B, R, T = new Array(f);
	    function D(e2, t2, r2, n2, i2) {
	      this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
	    }
	    function F(e2, t2) {
	      this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
	    }
	    function N(e2) {
	      return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
	    }
	    function U(e2, t2) {
	      e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
	    }
	    function P(e2, t2, r2) {
	      e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
	    }
	    function L(e2, t2, r2) {
	      P(e2, r2[2 * t2], r2[2 * t2 + 1]);
	    }
	    function j(e2, t2) {
	      for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
	      return r2 >>> 1;
	    }
	    function Z(e2, t2, r2) {
	      var n2, i2, s2 = new Array(g + 1), a2 = 0;
	      for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
	      for (i2 = 0; i2 <= t2; i2++) {
	        var o2 = e2[2 * i2 + 1];
	        0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
	      }
	    }
	    function W(e2) {
	      var t2;
	      for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;
	      for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
	      for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;
	      e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
	    }
	    function M(e2) {
	      8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
	    }
	    function H(e2, t2, r2, n2) {
	      var i2 = 2 * t2, s2 = 2 * r2;
	      return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
	    }
	    function G(e2, t2, r2) {
	      for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
	      e2.heap[r2] = n2;
	    }
	    function K(e2, t2, r2) {
	      var n2, i2, s2, a2, o2 = 0;
	      if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
	      L(e2, m, t2);
	    }
	    function Y(e2, t2) {
	      var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
	      for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
	      for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
	      for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
	      for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
	      e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
	        var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
	        for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
	        for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
	        if (0 !== m2) {
	          do {
	            for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
	            e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
	          } while (0 < m2);
	          for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
	        }
	      }(e2, t2), Z(s2, u2, e2.bl_count);
	    }
	    function X(e2, t2, r2) {
	      var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
	      for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
	    }
	    function V(e2, t2, r2) {
	      var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
	      for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
	        if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
	        else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
	        s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
	      }
	    }
	    n(T);
	    var q = false;
	    function J(e2, t2, r2, n2) {
	      P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
	        M(e3), (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
	      }(e2, t2, r2);
	    }
	    r._tr_init = function(e2) {
	      q || (function() {
	        var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
	        for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
	        for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
	        for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
	        for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
	        for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
	        for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;
	        for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;
	        for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
	        for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
	        O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
	      }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
	    }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
	      var i2, s2, a2 = 0;
	      0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
	        var t3, r3 = 4093624447;
	        for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
	        if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;
	        for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h;
	        return o;
	      }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
	        var t3;
	        for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;
	        return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
	      }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
	        var i3;
	        for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
	        V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
	      }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
	    }, r._tr_tally = function(e2, t2, r2) {
	      return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
	    }, r._tr_align = function(e2) {
	      P(e2, 2, 3), L(e2, m, z), function(e3) {
	        16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
	      }(e2);
	    };
	  }, { "../utils/common": 41 }], 53: [function(e, t, r) {
	    t.exports = function() {
	      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
	    };
	  }, {}], 54: [function(e, t, r) {
	    (function(e2) {
	      !function(r2, n) {
	        if (!r2.setImmediate) {
	          var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
	          e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
	            define_process_default.nextTick(function() {
	              c(e4);
	            });
	          } : function() {
	            if (r2.postMessage && !r2.importScripts) {
	              var e4 = true, t3 = r2.onmessage;
	              return r2.onmessage = function() {
	                e4 = false;
	              }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
	            }
	          }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
	            r2.postMessage(a + e4, "*");
	          }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
	            c(e4.data);
	          }, function(e4) {
	            t2.port2.postMessage(e4);
	          }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
	            var t3 = l.createElement("script");
	            t3.onreadystatechange = function() {
	              c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
	            }, s.appendChild(t3);
	          }) : function(e4) {
	            setTimeout(c, 0, e4);
	          }, e3.setImmediate = function(e4) {
	            "function" != typeof e4 && (e4 = new Function("" + e4));
	            for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
	            var n2 = { callback: e4, args: t3 };
	            return h[o] = n2, i(o), o++;
	          }, e3.clearImmediate = f;
	        }
	        function f(e4) {
	          delete h[e4];
	        }
	        function c(e4) {
	          if (u) setTimeout(c, 0, e4);
	          else {
	            var t3 = h[e4];
	            if (t3) {
	              u = true;
	              try {
	                !function(e5) {
	                  var t4 = e5.callback, r3 = e5.args;
	                  switch (r3.length) {
	                    case 0:
	                      t4();
	                      break;
	                    case 1:
	                      t4(r3[0]);
	                      break;
	                    case 2:
	                      t4(r3[0], r3[1]);
	                      break;
	                    case 3:
	                      t4(r3[0], r3[1], r3[2]);
	                      break;
	                    default:
	                      t4.apply(n, r3);
	                  }
	                }(t3);
	              } finally {
	                f(e4), u = false;
	              }
	            }
	          }
	        }
	        function d(e4) {
	          e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
	        }
	      }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
	    }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
	  }, {}] }, {}, [10])(10);
	}); 
} (jszip_min$1));

var jszip_minExports = jszip_min$1.exports;
const jszip_min_default = /*@__PURE__*/getDefaultExportFromCjs(jszip_minExports);

const jszip_min = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: jszip_min_default
}, Symbol.toStringTag, { value: 'Module' }));

export { mountApp, sendToComfyUI };
