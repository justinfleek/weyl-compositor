var cp = Object.defineProperty;
var dp = (i, e, n) => e in i ? cp(i, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : i[e] = n;
var He = (i, e, n) => dp(i, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function Wl(i) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of i.split(",")) e[n] = 1;
  return (n) => n in e;
}
const vt = {}, vi = [], Bn = () => {
}, Sd = () => !1, da = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // uppercase letter
(i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97), Ul = (i) => i.startsWith("onUpdate:"), Kt = Object.assign, Nl = (i, e) => {
  const n = i.indexOf(e);
  n > -1 && i.splice(n, 1);
}, hp = Object.prototype.hasOwnProperty, dt = (i, e) => hp.call(i, e), Ye = Array.isArray, yi = (i) => Dr(i) === "[object Map]", Di = (i) => Dr(i) === "[object Set]", Eu = (i) => Dr(i) === "[object Date]", et = (i) => typeof i == "function", Mt = (i) => typeof i == "string", An = (i) => typeof i == "symbol", yt = (i) => i !== null && typeof i == "object", Cd = (i) => (yt(i) || et(i)) && et(i.then) && et(i.catch), kd = Object.prototype.toString, Dr = (i) => kd.call(i), fp = (i) => Dr(i).slice(8, -1), Td = (i) => Dr(i) === "[object Object]", ha = (i) => Mt(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i, tr = /* @__PURE__ */ Wl(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), fa = (i) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = i(n));
}, pp = /-\w/g, yn = fa(
  (i) => i.replace(pp, (e) => e.slice(1).toUpperCase())
), mp = /\B([A-Z])/g, zs = fa(
  (i) => i.replace(mp, "-$1").toLowerCase()
), pa = fa((i) => i.charAt(0).toUpperCase() + i.slice(1)), ja = fa(
  (i) => i ? `on${pa(i)}` : ""
), As = (i, e) => !Object.is(i, e), ko = (i, ...e) => {
  for (let n = 0; n < i.length; n++)
    i[n](...e);
}, Md = (i, e, n, s = !1) => {
  Object.defineProperty(i, e, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: n
  });
}, ma = (i) => {
  const e = parseFloat(i);
  return isNaN(e) ? i : e;
};
let Pu;
const ga = () => Pu || (Pu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Xe(i) {
  if (Ye(i)) {
    const e = {};
    for (let n = 0; n < i.length; n++) {
      const s = i[n], r = Mt(s) ? bp(s) : Xe(s);
      if (r)
        for (const o in r)
          e[o] = r[o];
    }
    return e;
  } else if (Mt(i) || yt(i))
    return i;
}
const gp = /;(?![^(]*\))/g, vp = /:([^]+)/, yp = /\/\*[^]*?\*\//g;
function bp(i) {
  const e = {};
  return i.replace(yp, "").split(gp).forEach((n) => {
    if (n) {
      const s = n.split(vp);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function Ie(i) {
  let e = "";
  if (Mt(i))
    e = i;
  else if (Ye(i))
    for (let n = 0; n < i.length; n++) {
      const s = Ie(i[n]);
      s && (e += s + " ");
    }
  else if (yt(i))
    for (const n in i)
      i[n] && (e += n + " ");
  return e.trim();
}
const xp = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", _p = /* @__PURE__ */ Wl(xp);
function Od(i) {
  return !!i || i === "";
}
function wp(i, e) {
  if (i.length !== e.length) return !1;
  let n = !0;
  for (let s = 0; n && s < i.length; s++)
    n = Ar(i[s], e[s]);
  return n;
}
function Ar(i, e) {
  if (i === e) return !0;
  let n = Eu(i), s = Eu(e);
  if (n || s)
    return n && s ? i.getTime() === e.getTime() : !1;
  if (n = An(i), s = An(e), n || s)
    return i === e;
  if (n = Ye(i), s = Ye(e), n || s)
    return n && s ? wp(i, e) : !1;
  if (n = yt(i), s = yt(e), n || s) {
    if (!n || !s)
      return !1;
    const r = Object.keys(i).length, o = Object.keys(e).length;
    if (r !== o)
      return !1;
    for (const a in i) {
      const l = i.hasOwnProperty(a), u = e.hasOwnProperty(a);
      if (l && !u || !l && u || !Ar(i[a], e[a]))
        return !1;
    }
  }
  return String(i) === String(e);
}
function Hl(i, e) {
  return i.findIndex((n) => Ar(n, e));
}
const Ed = (i) => !!(i && i.__v_isRef === !0), pe = (i) => Mt(i) ? i : i == null ? "" : Ye(i) || yt(i) && (i.toString === kd || !et(i.toString)) ? Ed(i) ? pe(i.value) : JSON.stringify(i, Pd, 2) : String(i), Pd = (i, e) => Ed(e) ? Pd(i, e.value) : yi(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [s, r], o) => (n[$a(s, o) + " =>"] = r, n),
    {}
  )
} : Di(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => $a(n))
} : An(e) ? $a(e) : yt(e) && !Ye(e) && !Td(e) ? String(e) : e, $a = (i, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    An(i) ? `Symbol(${(n = i.description) != null ? n : e})` : i
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Nt;
class Dd {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Nt, !e && Nt && (this.index = (Nt.scopes || (Nt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = Nt;
      try {
        return Nt = this, e();
      } finally {
        Nt = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Nt, Nt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Nt = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, s = this.scopes.length; n < s; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Ad(i) {
  return new Dd(i);
}
function Id() {
  return Nt;
}
function Sp(i, e = !1) {
  Nt && Nt.cleanups.push(i);
}
let bt;
const Ba = /* @__PURE__ */ new WeakSet();
class Fd {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Nt && Nt.active && Nt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ba.has(this) && (Ba.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || zd(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Du(this), Rd(this);
    const e = bt, n = Pn;
    bt = this, Pn = !0;
    try {
      return this.fn();
    } finally {
      Vd(this), bt = e, Pn = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Gl(e);
      this.deps = this.depsTail = void 0, Du(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ba.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    ml(this) && this.run();
  }
  get dirty() {
    return ml(this);
  }
}
let Ld = 0, nr, sr;
function zd(i, e = !1) {
  if (i.flags |= 8, e) {
    i.next = sr, sr = i;
    return;
  }
  i.next = nr, nr = i;
}
function Xl() {
  Ld++;
}
function Yl() {
  if (--Ld > 0)
    return;
  if (sr) {
    let e = sr;
    for (sr = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let i;
  for (; nr; ) {
    let e = nr;
    for (nr = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (s) {
          i || (i = s);
        }
      e = n;
    }
  }
  if (i) throw i;
}
function Rd(i) {
  for (let e = i.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Vd(i) {
  let e, n = i.depsTail, s = n;
  for (; s; ) {
    const r = s.prevDep;
    s.version === -1 ? (s === n && (n = r), Gl(s), Cp(s)) : e = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r;
  }
  i.deps = e, i.depsTail = n;
}
function ml(i) {
  for (let e = i.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (jd(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!i._dirty;
}
function jd(i) {
  if (i.flags & 4 && !(i.flags & 16) || (i.flags &= -17, i.globalVersion === mr) || (i.globalVersion = mr, !i.isSSR && i.flags & 128 && (!i.deps && !i._dirty || !ml(i))))
    return;
  i.flags |= 2;
  const e = i.dep, n = bt, s = Pn;
  bt = i, Pn = !0;
  try {
    Rd(i);
    const r = i.fn(i._value);
    (e.version === 0 || As(r, i._value)) && (i.flags |= 128, i._value = r, e.version++);
  } catch (r) {
    throw e.version++, r;
  } finally {
    bt = n, Pn = s, Vd(i), i.flags &= -3;
  }
}
function Gl(i, e = !1) {
  const { dep: n, prevSub: s, nextSub: r } = i;
  if (s && (s.nextSub = r, i.prevSub = void 0), r && (r.prevSub = s, i.nextSub = void 0), n.subs === i && (n.subs = s, !s && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      Gl(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function Cp(i) {
  const { prevDep: e, nextDep: n } = i;
  e && (e.nextDep = n, i.prevDep = void 0), n && (n.prevDep = e, i.nextDep = void 0);
}
let Pn = !0;
const $d = [];
function cs() {
  $d.push(Pn), Pn = !1;
}
function ds() {
  const i = $d.pop();
  Pn = i === void 0 ? !0 : i;
}
function Du(i) {
  const { cleanup: e } = i;
  if (i.cleanup = void 0, e) {
    const n = bt;
    bt = void 0;
    try {
      e();
    } finally {
      bt = n;
    }
  }
}
let mr = 0;
class kp {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Kl {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!bt || !Pn || bt === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== bt)
      n = this.activeLink = new kp(bt, this), bt.deps ? (n.prevDep = bt.depsTail, bt.depsTail.nextDep = n, bt.depsTail = n) : bt.deps = bt.depsTail = n, Bd(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const s = n.nextDep;
      s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = bt.depsTail, n.nextDep = void 0, bt.depsTail.nextDep = n, bt.depsTail = n, bt.deps === n && (bt.deps = s);
    }
    return n;
  }
  trigger(e) {
    this.version++, mr++, this.notify(e);
  }
  notify(e) {
    Xl();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      Yl();
    }
  }
}
function Bd(i) {
  if (i.dep.sc++, i.sub.flags & 4) {
    const e = i.dep.computed;
    if (e && !i.dep.subs) {
      e.flags |= 20;
      for (let s = e.deps; s; s = s.nextDep)
        Bd(s);
    }
    const n = i.dep.subs;
    n !== i && (i.prevSub = n, n && (n.nextSub = i)), i.dep.subs = i;
  }
}
const Lo = /* @__PURE__ */ new WeakMap(), Js = Symbol(
  ""
), gl = Symbol(
  ""
), gr = Symbol(
  ""
);
function Xt(i, e, n) {
  if (Pn && bt) {
    let s = Lo.get(i);
    s || Lo.set(i, s = /* @__PURE__ */ new Map());
    let r = s.get(n);
    r || (s.set(n, r = new Kl()), r.map = s, r.key = n), r.track();
  }
}
function es(i, e, n, s, r, o) {
  const a = Lo.get(i);
  if (!a) {
    mr++;
    return;
  }
  const l = (u) => {
    u && u.trigger();
  };
  if (Xl(), e === "clear")
    a.forEach(l);
  else {
    const u = Ye(i), c = u && ha(n);
    if (u && n === "length") {
      const d = Number(s);
      a.forEach((f, g) => {
        (g === "length" || g === gr || !An(g) && g >= d) && l(f);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), c && l(a.get(gr)), e) {
        case "add":
          u ? c && l(a.get("length")) : (l(a.get(Js)), yi(i) && l(a.get(gl)));
          break;
        case "delete":
          u || (l(a.get(Js)), yi(i) && l(a.get(gl)));
          break;
        case "set":
          yi(i) && l(a.get(Js));
          break;
      }
  }
  Yl();
}
function Tp(i, e) {
  const n = Lo.get(i);
  return n && n.get(e);
}
function ii(i) {
  const e = lt(i);
  return e === i ? e : (Xt(e, "iterate", gr), fn(i) ? e : e.map(In));
}
function va(i) {
  return Xt(i = lt(i), "iterate", gr), i;
}
function Ms(i, e) {
  return hs(i) ? rs(i) ? ki(In(e)) : ki(e) : In(e);
}
const Mp = {
  __proto__: null,
  [Symbol.iterator]() {
    return Wa(this, Symbol.iterator, (i) => Ms(this, i));
  },
  concat(...i) {
    return ii(this).concat(
      ...i.map((e) => Ye(e) ? ii(e) : e)
    );
  },
  entries() {
    return Wa(this, "entries", (i) => (i[1] = Ms(this, i[1]), i));
  },
  every(i, e) {
    return Xn(this, "every", i, e, void 0, arguments);
  },
  filter(i, e) {
    return Xn(
      this,
      "filter",
      i,
      e,
      (n) => n.map((s) => Ms(this, s)),
      arguments
    );
  },
  find(i, e) {
    return Xn(
      this,
      "find",
      i,
      e,
      (n) => Ms(this, n),
      arguments
    );
  },
  findIndex(i, e) {
    return Xn(this, "findIndex", i, e, void 0, arguments);
  },
  findLast(i, e) {
    return Xn(
      this,
      "findLast",
      i,
      e,
      (n) => Ms(this, n),
      arguments
    );
  },
  findLastIndex(i, e) {
    return Xn(this, "findLastIndex", i, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(i, e) {
    return Xn(this, "forEach", i, e, void 0, arguments);
  },
  includes(...i) {
    return Ua(this, "includes", i);
  },
  indexOf(...i) {
    return Ua(this, "indexOf", i);
  },
  join(i) {
    return ii(this).join(i);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...i) {
    return Ua(this, "lastIndexOf", i);
  },
  map(i, e) {
    return Xn(this, "map", i, e, void 0, arguments);
  },
  pop() {
    return Wi(this, "pop");
  },
  push(...i) {
    return Wi(this, "push", i);
  },
  reduce(i, ...e) {
    return Au(this, "reduce", i, e);
  },
  reduceRight(i, ...e) {
    return Au(this, "reduceRight", i, e);
  },
  shift() {
    return Wi(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(i, e) {
    return Xn(this, "some", i, e, void 0, arguments);
  },
  splice(...i) {
    return Wi(this, "splice", i);
  },
  toReversed() {
    return ii(this).toReversed();
  },
  toSorted(i) {
    return ii(this).toSorted(i);
  },
  toSpliced(...i) {
    return ii(this).toSpliced(...i);
  },
  unshift(...i) {
    return Wi(this, "unshift", i);
  },
  values() {
    return Wa(this, "values", (i) => Ms(this, i));
  }
};
function Wa(i, e, n) {
  const s = va(i), r = s[e]();
  return s !== i && !fn(i) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.done || (o.value = n(o.value)), o;
  }), r;
}
const Op = Array.prototype;
function Xn(i, e, n, s, r, o) {
  const a = va(i), l = a !== i && !fn(i), u = a[e];
  if (u !== Op[e]) {
    const f = u.apply(i, o);
    return l ? In(f) : f;
  }
  let c = n;
  a !== i && (l ? c = function(f, g) {
    return n.call(this, Ms(i, f), g, i);
  } : n.length > 2 && (c = function(f, g) {
    return n.call(this, f, g, i);
  }));
  const d = u.call(a, c, s);
  return l && r ? r(d) : d;
}
function Au(i, e, n, s) {
  const r = va(i);
  let o = n;
  return r !== i && (fn(i) ? n.length > 3 && (o = function(a, l, u) {
    return n.call(this, a, l, u, i);
  }) : o = function(a, l, u) {
    return n.call(this, a, Ms(i, l), u, i);
  }), r[e](o, ...s);
}
function Ua(i, e, n) {
  const s = lt(i);
  Xt(s, "iterate", gr);
  const r = s[e](...n);
  return (r === -1 || r === !1) && ya(n[0]) ? (n[0] = lt(n[0]), s[e](...n)) : r;
}
function Wi(i, e, n = []) {
  cs(), Xl();
  const s = lt(i)[e].apply(i, n);
  return Yl(), ds(), s;
}
const Ep = /* @__PURE__ */ Wl("__proto__,__v_isRef,__isVue"), Wd = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((i) => i !== "arguments" && i !== "caller").map((i) => Symbol[i]).filter(An)
);
function Pp(i) {
  An(i) || (i = String(i));
  const e = lt(this);
  return Xt(e, "has", i), e.hasOwnProperty(i);
}
class Ud {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, s) {
    if (n === "__v_skip") return e.__v_skip;
    const r = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return s === (r ? o ? $p : Yd : o ? Xd : Hd).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0;
    const a = Ye(e);
    if (!r) {
      let u;
      if (a && (u = Mp[n]))
        return u;
      if (n === "hasOwnProperty")
        return Pp;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Tt(e) ? e : s
    );
    if ((An(n) ? Wd.has(n) : Ep(n)) || (r || Xt(e, "get", n), o))
      return l;
    if (Tt(l)) {
      const u = a && ha(n) ? l : l.value;
      return r && yt(u) ? yl(u) : u;
    }
    return yt(l) ? r ? yl(l) : Ai(l) : l;
  }
}
class Nd extends Ud {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, s, r) {
    let o = e[n];
    const a = Ye(e) && ha(n);
    if (!this._isShallow) {
      const c = hs(o);
      if (!fn(s) && !hs(s) && (o = lt(o), s = lt(s)), !a && Tt(o) && !Tt(s))
        return c || (o.value = s), !0;
    }
    const l = a ? Number(n) < e.length : dt(e, n), u = Reflect.set(
      e,
      n,
      s,
      Tt(e) ? e : r
    );
    return e === lt(r) && (l ? As(s, o) && es(e, "set", n, s) : es(e, "add", n, s)), u;
  }
  deleteProperty(e, n) {
    const s = dt(e, n);
    e[n];
    const r = Reflect.deleteProperty(e, n);
    return r && s && es(e, "delete", n, void 0), r;
  }
  has(e, n) {
    const s = Reflect.has(e, n);
    return (!An(n) || !Wd.has(n)) && Xt(e, "has", n), s;
  }
  ownKeys(e) {
    return Xt(
      e,
      "iterate",
      Ye(e) ? "length" : Js
    ), Reflect.ownKeys(e);
  }
}
class Dp extends Ud {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const Ap = /* @__PURE__ */ new Nd(), Ip = /* @__PURE__ */ new Dp(), Fp = /* @__PURE__ */ new Nd(!0);
const vl = (i) => i, Wr = (i) => Reflect.getPrototypeOf(i);
function Lp(i, e, n) {
  return function(...s) {
    const r = this.__v_raw, o = lt(r), a = yi(o), l = i === "entries" || i === Symbol.iterator && a, u = i === "keys" && a, c = r[i](...s), d = n ? vl : e ? ki : In;
    return !e && Xt(
      o,
      "iterate",
      u ? gl : Js
    ), {
      // iterator protocol
      next() {
        const { value: f, done: g } = c.next();
        return g ? { value: f, done: g } : {
          value: l ? [d(f[0]), d(f[1])] : d(f),
          done: g
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ur(i) {
  return function(...e) {
    return i === "delete" ? !1 : i === "clear" ? void 0 : this;
  };
}
function zp(i, e) {
  const n = {
    get(r) {
      const o = this.__v_raw, a = lt(o), l = lt(r);
      i || (As(r, l) && Xt(a, "get", r), Xt(a, "get", l));
      const { has: u } = Wr(a), c = e ? vl : i ? ki : In;
      if (u.call(a, r))
        return c(o.get(r));
      if (u.call(a, l))
        return c(o.get(l));
      o !== a && o.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !i && Xt(lt(r), "iterate", Js), r.size;
    },
    has(r) {
      const o = this.__v_raw, a = lt(o), l = lt(r);
      return i || (As(r, l) && Xt(a, "has", r), Xt(a, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l);
    },
    forEach(r, o) {
      const a = this, l = a.__v_raw, u = lt(l), c = e ? vl : i ? ki : In;
      return !i && Xt(u, "iterate", Js), l.forEach((d, f) => r.call(o, c(d), c(f), a));
    }
  };
  return Kt(
    n,
    i ? {
      add: Ur("add"),
      set: Ur("set"),
      delete: Ur("delete"),
      clear: Ur("clear")
    } : {
      add(r) {
        !e && !fn(r) && !hs(r) && (r = lt(r));
        const o = lt(this);
        return Wr(o).has.call(o, r) || (o.add(r), es(o, "add", r, r)), this;
      },
      set(r, o) {
        !e && !fn(o) && !hs(o) && (o = lt(o));
        const a = lt(this), { has: l, get: u } = Wr(a);
        let c = l.call(a, r);
        c || (r = lt(r), c = l.call(a, r));
        const d = u.call(a, r);
        return a.set(r, o), c ? As(o, d) && es(a, "set", r, o) : es(a, "add", r, o), this;
      },
      delete(r) {
        const o = lt(this), { has: a, get: l } = Wr(o);
        let u = a.call(o, r);
        u || (r = lt(r), u = a.call(o, r)), l && l.call(o, r);
        const c = o.delete(r);
        return u && es(o, "delete", r, void 0), c;
      },
      clear() {
        const r = lt(this), o = r.size !== 0, a = r.clear();
        return o && es(
          r,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = Lp(r, i, e);
  }), n;
}
function ql(i, e) {
  const n = zp(i, e);
  return (s, r, o) => r === "__v_isReactive" ? !i : r === "__v_isReadonly" ? i : r === "__v_raw" ? s : Reflect.get(
    dt(n, r) && r in s ? n : s,
    r,
    o
  );
}
const Rp = {
  get: /* @__PURE__ */ ql(!1, !1)
}, Vp = {
  get: /* @__PURE__ */ ql(!1, !0)
}, jp = {
  get: /* @__PURE__ */ ql(!0, !1)
};
const Hd = /* @__PURE__ */ new WeakMap(), Xd = /* @__PURE__ */ new WeakMap(), Yd = /* @__PURE__ */ new WeakMap(), $p = /* @__PURE__ */ new WeakMap();
function Bp(i) {
  switch (i) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Wp(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : Bp(fp(i));
}
function Ai(i) {
  return hs(i) ? i : Zl(
    i,
    !1,
    Ap,
    Rp,
    Hd
  );
}
function Up(i) {
  return Zl(
    i,
    !1,
    Fp,
    Vp,
    Xd
  );
}
function yl(i) {
  return Zl(
    i,
    !0,
    Ip,
    jp,
    Yd
  );
}
function Zl(i, e, n, s, r) {
  if (!yt(i) || i.__v_raw && !(e && i.__v_isReactive))
    return i;
  const o = Wp(i);
  if (o === 0)
    return i;
  const a = r.get(i);
  if (a)
    return a;
  const l = new Proxy(
    i,
    o === 2 ? s : n
  );
  return r.set(i, l), l;
}
function rs(i) {
  return hs(i) ? rs(i.__v_raw) : !!(i && i.__v_isReactive);
}
function hs(i) {
  return !!(i && i.__v_isReadonly);
}
function fn(i) {
  return !!(i && i.__v_isShallow);
}
function ya(i) {
  return i ? !!i.__v_raw : !1;
}
function lt(i) {
  const e = i && i.__v_raw;
  return e ? lt(e) : i;
}
function Zn(i) {
  return !dt(i, "__v_skip") && Object.isExtensible(i) && Md(i, "__v_skip", !0), i;
}
const In = (i) => yt(i) ? Ai(i) : i, ki = (i) => yt(i) ? yl(i) : i;
function Tt(i) {
  return i ? i.__v_isRef === !0 : !1;
}
function me(i) {
  return Np(i, !1);
}
function Np(i, e) {
  return Tt(i) ? i : new Hp(i, e);
}
class Hp {
  constructor(e, n) {
    this.dep = new Kl(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : lt(e), this._value = n ? e : In(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, s = this.__v_isShallow || fn(e) || hs(e);
    e = s ? e : lt(e), As(e, n) && (this._rawValue = e, this._value = s ? e : In(e), this.dep.trigger());
  }
}
function Fe(i) {
  return Tt(i) ? i.value : i;
}
const Xp = {
  get: (i, e, n) => e === "__v_raw" ? i : Fe(Reflect.get(i, e, n)),
  set: (i, e, n, s) => {
    const r = i[e];
    return Tt(r) && !Tt(n) ? (r.value = n, !0) : Reflect.set(i, e, n, s);
  }
};
function Gd(i) {
  return rs(i) ? i : new Proxy(i, Xp);
}
function Yp(i) {
  const e = Ye(i) ? new Array(i.length) : {};
  for (const n in i)
    e[n] = Kp(i, n);
  return e;
}
class Gp {
  constructor(e, n, s) {
    this._object = e, this._key = n, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0, this._raw = lt(e);
    let r = !0, o = e;
    if (!Ye(e) || !ha(String(n)))
      do
        r = !ya(o) || fn(o);
      while (r && (o = o.__v_raw));
    this._shallow = r;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = Fe(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && Tt(this._raw[this._key])) {
      const n = this._object[this._key];
      if (Tt(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return Tp(this._raw, this._key);
  }
}
function Kp(i, e, n) {
  return new Gp(i, e, n);
}
class qp {
  constructor(e, n, s) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new Kl(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = mr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    bt !== this)
      return zd(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return jd(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function Zp(i, e, n = !1) {
  let s, r;
  return et(i) ? s = i : (s = i.get, r = i.set), new qp(s, r, n);
}
const Nr = {}, zo = /* @__PURE__ */ new WeakMap();
let Ns;
function Jp(i, e = !1, n = Ns) {
  if (n) {
    let s = zo.get(n);
    s || zo.set(n, s = []), s.push(i);
  }
}
function Qp(i, e, n = vt) {
  const { immediate: s, deep: r, once: o, scheduler: a, augmentJob: l, call: u } = n, c = (_) => r ? _ : fn(_) || r === !1 || r === 0 ? ts(_, 1) : ts(_);
  let d, f, g, p, y = !1, v = !1;
  if (Tt(i) ? (f = () => i.value, y = fn(i)) : rs(i) ? (f = () => c(i), y = !0) : Ye(i) ? (v = !0, y = i.some((_) => rs(_) || fn(_)), f = () => i.map((_) => {
    if (Tt(_))
      return _.value;
    if (rs(_))
      return c(_);
    if (et(_))
      return u ? u(_, 2) : _();
  })) : et(i) ? e ? f = u ? () => u(i, 2) : i : f = () => {
    if (g) {
      cs();
      try {
        g();
      } finally {
        ds();
      }
    }
    const _ = Ns;
    Ns = d;
    try {
      return u ? u(i, 3, [p]) : i(p);
    } finally {
      Ns = _;
    }
  } : f = Bn, e && r) {
    const _ = f, C = r === !0 ? 1 / 0 : r;
    f = () => ts(_(), C);
  }
  const m = Id(), b = () => {
    d.stop(), m && m.active && Nl(m.effects, d);
  };
  if (o && e) {
    const _ = e;
    e = (...C) => {
      _(...C), b();
    };
  }
  let S = v ? new Array(i.length).fill(Nr) : Nr;
  const x = (_) => {
    if (!(!(d.flags & 1) || !d.dirty && !_))
      if (e) {
        const C = d.run();
        if (r || y || (v ? C.some((k, M) => As(k, S[M])) : As(C, S))) {
          g && g();
          const k = Ns;
          Ns = d;
          try {
            const M = [
              C,
              // pass undefined as the old value when it's changed for the first time
              S === Nr ? void 0 : v && S[0] === Nr ? [] : S,
              p
            ];
            S = C, u ? u(e, 3, M) : (
              // @ts-expect-error
              e(...M)
            );
          } finally {
            Ns = k;
          }
        }
      } else
        d.run();
  };
  return l && l(x), d = new Fd(f), d.scheduler = a ? () => a(x, !1) : x, p = (_) => Jp(_, !1, d), g = d.onStop = () => {
    const _ = zo.get(d);
    if (_) {
      if (u)
        u(_, 4);
      else
        for (const C of _) C();
      zo.delete(d);
    }
  }, e ? s ? x(!0) : S = d.run() : a ? a(x.bind(null, !0), !0) : d.run(), b.pause = d.pause.bind(d), b.resume = d.resume.bind(d), b.stop = b, b;
}
function ts(i, e = 1 / 0, n) {
  if (e <= 0 || !yt(i) || i.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(i) || 0) >= e))
    return i;
  if (n.set(i, e), e--, Tt(i))
    ts(i.value, e, n);
  else if (Ye(i))
    for (let s = 0; s < i.length; s++)
      ts(i[s], e, n);
  else if (Di(i) || yi(i))
    i.forEach((s) => {
      ts(s, e, n);
    });
  else if (Td(i)) {
    for (const s in i)
      ts(i[s], e, n);
    for (const s of Object.getOwnPropertySymbols(i))
      Object.prototype.propertyIsEnumerable.call(i, s) && ts(i[s], e, n);
  }
  return i;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Ir(i, e, n, s) {
  try {
    return s ? i(...s) : i();
  } catch (r) {
    ba(r, e, n);
  }
}
function Un(i, e, n, s) {
  if (et(i)) {
    const r = Ir(i, e, n, s);
    return r && Cd(r) && r.catch((o) => {
      ba(o, e, n);
    }), r;
  }
  if (Ye(i)) {
    const r = [];
    for (let o = 0; o < i.length; o++)
      r.push(Un(i[o], e, n, s));
    return r;
  }
}
function ba(i, e, n, s = !0) {
  const r = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || vt;
  if (e) {
    let l = e.parent;
    const u = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let f = 0; f < d.length; f++)
          if (d[f](i, u, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      cs(), Ir(o, null, 10, [
        i,
        u,
        c
      ]), ds();
      return;
    }
  }
  em(i, n, r, s, a);
}
function em(i, e, n, s = !0, r = !1) {
  if (r)
    throw i;
  console.error(i);
}
const Jt = [];
let Rn = -1;
const bi = [];
let Os = null, ui = 0;
const Kd = /* @__PURE__ */ Promise.resolve();
let Ro = null;
function Wn(i) {
  const e = Ro || Kd;
  return i ? e.then(this ? i.bind(this) : i) : e;
}
function tm(i) {
  let e = Rn + 1, n = Jt.length;
  for (; e < n; ) {
    const s = e + n >>> 1, r = Jt[s], o = vr(r);
    o < i || o === i && r.flags & 2 ? e = s + 1 : n = s;
  }
  return e;
}
function Jl(i) {
  if (!(i.flags & 1)) {
    const e = vr(i), n = Jt[Jt.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(i.flags & 2) && e >= vr(n) ? Jt.push(i) : Jt.splice(tm(e), 0, i), i.flags |= 1, qd();
  }
}
function qd() {
  Ro || (Ro = Kd.then(Jd));
}
function nm(i) {
  Ye(i) ? bi.push(...i) : Os && i.id === -1 ? Os.splice(ui + 1, 0, i) : i.flags & 1 || (bi.push(i), i.flags |= 1), qd();
}
function Iu(i, e, n = Rn + 1) {
  for (; n < Jt.length; n++) {
    const s = Jt[n];
    if (s && s.flags & 2) {
      if (i && s.id !== i.uid)
        continue;
      Jt.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function Zd(i) {
  if (bi.length) {
    const e = [...new Set(bi)].sort(
      (n, s) => vr(n) - vr(s)
    );
    if (bi.length = 0, Os) {
      Os.push(...e);
      return;
    }
    for (Os = e, ui = 0; ui < Os.length; ui++) {
      const n = Os[ui];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    Os = null, ui = 0;
  }
}
const vr = (i) => i.id == null ? i.flags & 2 ? -1 : 1 / 0 : i.id;
function Jd(i) {
  try {
    for (Rn = 0; Rn < Jt.length; Rn++) {
      const e = Jt[Rn];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), Ir(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; Rn < Jt.length; Rn++) {
      const e = Jt[Rn];
      e && (e.flags &= -2);
    }
    Rn = -1, Jt.length = 0, Zd(), Ro = null, (Jt.length || bi.length) && Jd();
  }
}
let Bt = null, Qd = null;
function Vo(i) {
  const e = Bt;
  return Bt = i, Qd = i && i.type.__scopeId || null, e;
}
function Sn(i, e = Bt, n) {
  if (!e || i._n)
    return i;
  const s = (...r) => {
    s._d && Bo(-1);
    const o = Vo(e);
    let a;
    try {
      a = i(...r);
    } finally {
      Vo(o), s._d && Bo(1);
    }
    return a;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function tt(i, e) {
  if (Bt === null)
    return i;
  const n = Ca(Bt), s = i.dirs || (i.dirs = []);
  for (let r = 0; r < e.length; r++) {
    let [o, a, l, u = vt] = e[r];
    o && (et(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && ts(a), s.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return i;
}
function Vs(i, e, n, s) {
  const r = i.dirs, o = e && e.dirs;
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    o && (l.oldValue = o[a].value);
    let u = l.dir[s];
    u && (cs(), Un(u, n, 8, [
      i.el,
      l,
      i,
      e
    ]), ds());
  }
}
const eh = Symbol("_vte"), sm = (i) => i.__isTeleport, ir = (i) => i && (i.disabled || i.disabled === ""), Fu = (i) => i && (i.defer || i.defer === ""), Lu = (i) => typeof SVGElement < "u" && i instanceof SVGElement, zu = (i) => typeof MathMLElement == "function" && i instanceof MathMLElement, bl = (i, e) => {
  const n = i && i.to;
  return Mt(n) ? e ? e(n) : null : n;
}, th = {
  name: "Teleport",
  __isTeleport: !0,
  process(i, e, n, s, r, o, a, l, u, c) {
    const {
      mc: d,
      pc: f,
      pbc: g,
      o: { insert: p, querySelector: y, createText: v, createComment: m }
    } = c, b = ir(e.props);
    let { shapeFlag: S, children: x, dynamicChildren: _ } = e;
    if (i == null) {
      const C = e.el = v(""), k = e.anchor = v("");
      p(C, n, s), p(k, n, s);
      const M = (F, $) => {
        S & 16 && d(
          x,
          F,
          $,
          r,
          o,
          a,
          l,
          u
        );
      }, O = () => {
        const F = e.target = bl(e.props, y), $ = nh(F, e, v, p);
        F && (a !== "svg" && Lu(F) ? a = "svg" : a !== "mathml" && zu(F) && (a = "mathml"), r && r.isCE && (r.ce._teleportTargets || (r.ce._teleportTargets = /* @__PURE__ */ new Set())).add(F), b || (M(F, $), To(e, !1)));
      };
      b && (M(n, k), To(e, !0)), Fu(e.props) ? (e.el.__isMounted = !1, Zt(() => {
        O(), delete e.el.__isMounted;
      }, o)) : O();
    } else {
      if (Fu(e.props) && i.el.__isMounted === !1) {
        Zt(() => {
          th.process(
            i,
            e,
            n,
            s,
            r,
            o,
            a,
            l,
            u,
            c
          );
        }, o);
        return;
      }
      e.el = i.el, e.targetStart = i.targetStart;
      const C = e.anchor = i.anchor, k = e.target = i.target, M = e.targetAnchor = i.targetAnchor, O = ir(i.props), F = O ? n : k, $ = O ? C : M;
      if (a === "svg" || Lu(k) ? a = "svg" : (a === "mathml" || zu(k)) && (a = "mathml"), _ ? (g(
        i.dynamicChildren,
        _,
        F,
        r,
        o,
        a,
        l
      ), su(i, e, !0)) : u || f(
        i,
        e,
        F,
        $,
        r,
        o,
        a,
        l,
        !1
      ), b)
        O ? e.props && i.props && e.props.to !== i.props.to && (e.props.to = i.props.to) : Hr(
          e,
          n,
          C,
          c,
          1
        );
      else if ((e.props && e.props.to) !== (i.props && i.props.to)) {
        const ne = e.target = bl(
          e.props,
          y
        );
        ne && Hr(
          e,
          ne,
          null,
          c,
          0
        );
      } else O && Hr(
        e,
        k,
        M,
        c,
        1
      );
      To(e, b);
    }
  },
  remove(i, e, n, { um: s, o: { remove: r } }, o) {
    const {
      shapeFlag: a,
      children: l,
      anchor: u,
      targetStart: c,
      targetAnchor: d,
      target: f,
      props: g
    } = i;
    if (f && (r(c), r(d)), o && r(u), a & 16) {
      const p = o || !ir(g);
      for (let y = 0; y < l.length; y++) {
        const v = l[y];
        s(
          v,
          e,
          n,
          p,
          !!v.dynamicChildren
        );
      }
    }
  },
  move: Hr,
  hydrate: im
};
function Hr(i, e, n, { o: { insert: s }, m: r }, o = 2) {
  o === 0 && s(i.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: u, children: c, props: d } = i, f = o === 2;
  if (f && s(a, e, n), (!f || ir(d)) && u & 16)
    for (let g = 0; g < c.length; g++)
      r(
        c[g],
        e,
        n,
        2
      );
  f && s(l, e, n);
}
function im(i, e, n, s, r, o, {
  o: { nextSibling: a, parentNode: l, querySelector: u, insert: c, createText: d }
}, f) {
  function g(v, m, b, S) {
    m.anchor = f(
      a(v),
      m,
      l(v),
      n,
      s,
      r,
      o
    ), m.targetStart = b, m.targetAnchor = S;
  }
  const p = e.target = bl(
    e.props,
    u
  ), y = ir(e.props);
  if (p) {
    const v = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (y)
        g(
          i,
          e,
          v,
          v && a(v)
        );
      else {
        e.anchor = a(i);
        let m = v;
        for (; m; ) {
          if (m && m.nodeType === 8) {
            if (m.data === "teleport start anchor")
              e.targetStart = m;
            else if (m.data === "teleport anchor") {
              e.targetAnchor = m, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          m = a(m);
        }
        e.targetAnchor || nh(p, e, d, c), f(
          v && a(v),
          e,
          p,
          n,
          s,
          r,
          o
        );
      }
    To(e, y);
  } else y && e.shapeFlag & 16 && g(i, e, i, a(i));
  return e.anchor && a(e.anchor);
}
const rm = th;
function To(i, e) {
  const n = i.ctx;
  if (n && n.ut) {
    let s, r;
    for (e ? (s = i.el, r = i.anchor) : (s = i.targetStart, r = i.targetAnchor); s && s !== r; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", n.uid), s = s.nextSibling;
    n.ut();
  }
}
function nh(i, e, n, s) {
  const r = e.targetStart = n(""), o = e.targetAnchor = n("");
  return r[eh] = o, i && (s(r, i), s(o, i)), o;
}
const om = Symbol("_leaveCb");
function Ql(i, e) {
  i.shapeFlag & 6 && i.component ? (i.transition = e, Ql(i.component.subTree, e)) : i.shapeFlag & 128 ? (i.ssContent.transition = e.clone(i.ssContent), i.ssFallback.transition = e.clone(i.ssFallback)) : i.transition = e;
}
// @__NO_SIDE_EFFECTS__
function pt(i, e) {
  return et(i) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Kt({ name: i.name }, e, { setup: i })
  ) : i;
}
function sh(i) {
  i.ids = [i.ids[0] + i.ids[2]++ + "-", 0, 0];
}
const jo = /* @__PURE__ */ new WeakMap();
function rr(i, e, n, s, r = !1) {
  if (Ye(i)) {
    i.forEach(
      (y, v) => rr(
        y,
        e && (Ye(e) ? e[v] : e),
        n,
        s,
        r
      )
    );
    return;
  }
  if (xi(s) && !r) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && rr(i, e, n, s.component.subTree);
    return;
  }
  const o = s.shapeFlag & 4 ? Ca(s.component) : s.el, a = r ? null : o, { i: l, r: u } = i, c = e && e.r, d = l.refs === vt ? l.refs = {} : l.refs, f = l.setupState, g = lt(f), p = f === vt ? Sd : (y) => dt(g, y);
  if (c != null && c !== u) {
    if (Ru(e), Mt(c))
      d[c] = null, p(c) && (f[c] = null);
    else if (Tt(c)) {
      c.value = null;
      const y = e;
      y.k && (d[y.k] = null);
    }
  }
  if (et(u))
    Ir(u, l, 12, [a, d]);
  else {
    const y = Mt(u), v = Tt(u);
    if (y || v) {
      const m = () => {
        if (i.f) {
          const b = y ? p(u) ? f[u] : d[u] : u.value;
          if (r)
            Ye(b) && Nl(b, o);
          else if (Ye(b))
            b.includes(o) || b.push(o);
          else if (y)
            d[u] = [o], p(u) && (f[u] = d[u]);
          else {
            const S = [o];
            u.value = S, i.k && (d[i.k] = S);
          }
        } else y ? (d[u] = a, p(u) && (f[u] = a)) : v && (u.value = a, i.k && (d[i.k] = a));
      };
      if (a) {
        const b = () => {
          m(), jo.delete(i);
        };
        b.id = -1, jo.set(i, b), Zt(b, n);
      } else
        Ru(i), m();
    }
  }
}
function Ru(i) {
  const e = jo.get(i);
  e && (e.flags |= 8, jo.delete(i));
}
ga().requestIdleCallback;
ga().cancelIdleCallback;
const xi = (i) => !!i.type.__asyncLoader, ih = (i) => i.type.__isKeepAlive;
function am(i, e) {
  rh(i, "a", e);
}
function lm(i, e) {
  rh(i, "da", e);
}
function rh(i, e, n = Yt) {
  const s = i.__wdc || (i.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return i();
  });
  if (xa(e, s, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      ih(r.parent.vnode) && um(s, e, n, r), r = r.parent;
  }
}
function um(i, e, n, s) {
  const r = xa(
    e,
    i,
    s,
    !0
    /* prepend */
  );
  pn(() => {
    Nl(s[e], r);
  }, n);
}
function xa(i, e, n = Yt, s = !1) {
  if (n) {
    const r = n[i] || (n[i] = []), o = e.__weh || (e.__weh = (...a) => {
      cs();
      const l = Fr(n), u = Un(e, n, i, a);
      return l(), ds(), u;
    });
    return s ? r.unshift(o) : r.push(o), o;
  }
}
const ys = (i) => (e, n = Yt) => {
  (!_r || i === "sp") && xa(i, (...s) => e(...s), n);
}, cm = ys("bm"), Rt = ys("m"), dm = ys(
  "bu"
), hm = ys("u"), eu = ys(
  "bum"
), pn = ys("um"), fm = ys(
  "sp"
), pm = ys("rtg"), mm = ys("rtc");
function gm(i, e = Yt) {
  xa("ec", i, e);
}
const vm = "components", oh = Symbol.for("v-ndc");
function ah(i) {
  return Mt(i) ? ym(vm, i, !1) || i : i || oh;
}
function ym(i, e, n = !0, s = !1) {
  const r = Bt || Yt;
  if (r) {
    const o = r.type;
    {
      const l = lg(
        o,
        !1
      );
      if (l && (l === e || l === yn(e) || l === pa(yn(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Vu(r[i] || o[i], e) || // global registration
      Vu(r.appContext[i], e)
    );
    return !a && s ? o : a;
  }
}
function Vu(i, e) {
  return i && (i[e] || i[yn(e)] || i[pa(yn(e))]);
}
function Ue(i, e, n, s) {
  let r;
  const o = n, a = Ye(i);
  if (a || Mt(i)) {
    const l = a && rs(i);
    let u = !1, c = !1;
    l && (u = !fn(i), c = hs(i), i = va(i)), r = new Array(i.length);
    for (let d = 0, f = i.length; d < f; d++)
      r[d] = e(
        u ? c ? ki(In(i[d])) : In(i[d]) : i[d],
        d,
        void 0,
        o
      );
  } else if (typeof i == "number") {
    r = new Array(i);
    for (let l = 0; l < i; l++)
      r[l] = e(l + 1, l, void 0, o);
  } else if (yt(i))
    if (i[Symbol.iterator])
      r = Array.from(
        i,
        (l, u) => e(l, u, void 0, o)
      );
    else {
      const l = Object.keys(i);
      r = new Array(l.length);
      for (let u = 0, c = l.length; u < c; u++) {
        const d = l[u];
        r[u] = e(i[d], d, u, o);
      }
    }
  else
    r = [];
  return r;
}
function bm(i, e, n = {}, s, r) {
  if (Bt.ce || Bt.parent && xi(Bt.parent) && Bt.parent.ce) {
    const c = Object.keys(n).length > 0;
    return V(), ot(
      Re,
      null,
      [Ae("slot", n, s)],
      c ? -2 : 64
    );
  }
  let o = i[e];
  o && o._c && (o._d = !1), V();
  const a = o && lh(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, u = ot(
    Re,
    {
      key: (l && !An(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && s ? "_fb" : "")
    },
    a || [],
    a && i._ === 1 ? 64 : -2
  );
  return u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]), o && o._c && (o._d = !0), u;
}
function lh(i) {
  return i.some((e) => br(e) ? !(e.type === fs || e.type === Re && !lh(e.children)) : !0) ? i : null;
}
const xl = (i) => i ? Mh(i) ? Ca(i) : xl(i.parent) : null, or = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Kt(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => xl(i.parent),
    $root: (i) => xl(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => ch(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      Jl(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = Wn.bind(i.proxy)),
    $watch: (i) => Im.bind(i)
  })
), Na = (i, e) => i !== vt && !i.__isScriptSetup && dt(i, e), xm = {
  get({ _: i }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: s, data: r, props: o, accessCache: a, type: l, appContext: u } = i;
    if (e[0] !== "$") {
      const g = a[e];
      if (g !== void 0)
        switch (g) {
          case 1:
            return s[e];
          case 2:
            return r[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (Na(s, e))
          return a[e] = 1, s[e];
        if (r !== vt && dt(r, e))
          return a[e] = 2, r[e];
        if (dt(o, e))
          return a[e] = 3, o[e];
        if (n !== vt && dt(n, e))
          return a[e] = 4, n[e];
        _l && (a[e] = 0);
      }
    }
    const c = or[e];
    let d, f;
    if (c)
      return e === "$attrs" && Xt(i.attrs, "get", ""), c(i);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== vt && dt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      f = u.config.globalProperties, dt(f, e)
    )
      return f[e];
  },
  set({ _: i }, e, n) {
    const { data: s, setupState: r, ctx: o } = i;
    return Na(r, e) ? (r[e] = n, !0) : s !== vt && dt(s, e) ? (s[e] = n, !0) : dt(i.props, e) || e[0] === "$" && e.slice(1) in i ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: i, setupState: e, accessCache: n, ctx: s, appContext: r, props: o, type: a }
  }, l) {
    let u;
    return !!(n[l] || i !== vt && l[0] !== "$" && dt(i, l) || Na(e, l) || dt(o, l) || dt(s, l) || dt(or, l) || dt(r.config.globalProperties, l) || (u = a.__cssModules) && u[l]);
  },
  defineProperty(i, e, n) {
    return n.get != null ? i._.accessCache[e] = 0 : dt(n, "value") && this.set(i, e, n.value, null), Reflect.defineProperty(i, e, n);
  }
};
function _m() {
  return wm().slots;
}
function wm(i) {
  const e = Sa();
  return e.setupContext || (e.setupContext = Eh(e));
}
function ju(i) {
  return Ye(i) ? i.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : i;
}
let _l = !0;
function Sm(i) {
  const e = ch(i), n = i.proxy, s = i.ctx;
  _l = !1, e.beforeCreate && $u(e.beforeCreate, i, "bc");
  const {
    // state
    data: r,
    computed: o,
    methods: a,
    watch: l,
    provide: u,
    inject: c,
    // lifecycle
    created: d,
    beforeMount: f,
    mounted: g,
    beforeUpdate: p,
    updated: y,
    activated: v,
    deactivated: m,
    beforeDestroy: b,
    beforeUnmount: S,
    destroyed: x,
    unmounted: _,
    render: C,
    renderTracked: k,
    renderTriggered: M,
    errorCaptured: O,
    serverPrefetch: F,
    // public API
    expose: $,
    inheritAttrs: ne,
    // assets
    components: oe,
    directives: z,
    filters: X
  } = e;
  if (c && Cm(c, s, null), a)
    for (const ge in a) {
      const K = a[ge];
      et(K) && (s[ge] = K.bind(n));
    }
  if (r) {
    const ge = r.call(n, n);
    yt(ge) && (i.data = Ai(ge));
  }
  if (_l = !0, o)
    for (const ge in o) {
      const K = o[ge], re = et(K) ? K.bind(n, n) : et(K.get) ? K.get.bind(n, n) : Bn, ie = !et(K) && et(K.set) ? K.set.bind(n) : Bn, be = Oe({
        get: re,
        set: ie
      });
      Object.defineProperty(s, ge, {
        enumerable: !0,
        configurable: !0,
        get: () => be.value,
        set: (J) => be.value = J
      });
    }
  if (l)
    for (const ge in l)
      uh(l[ge], s, n, ge);
  if (u) {
    const ge = et(u) ? u.call(n) : u;
    Reflect.ownKeys(ge).forEach((K) => {
      ks(K, ge[K]);
    });
  }
  d && $u(d, i, "c");
  function H(ge, K) {
    Ye(K) ? K.forEach((re) => ge(re.bind(n))) : K && ge(K.bind(n));
  }
  if (H(cm, f), H(Rt, g), H(dm, p), H(hm, y), H(am, v), H(lm, m), H(gm, O), H(mm, k), H(pm, M), H(eu, S), H(pn, _), H(fm, F), Ye($))
    if ($.length) {
      const ge = i.exposed || (i.exposed = {});
      $.forEach((K) => {
        Object.defineProperty(ge, K, {
          get: () => n[K],
          set: (re) => n[K] = re,
          enumerable: !0
        });
      });
    } else i.exposed || (i.exposed = {});
  C && i.render === Bn && (i.render = C), ne != null && (i.inheritAttrs = ne), oe && (i.components = oe), z && (i.directives = z), F && sh(i);
}
function Cm(i, e, n = Bn) {
  Ye(i) && (i = wl(i));
  for (const s in i) {
    const r = i[s];
    let o;
    yt(r) ? "default" in r ? o = Tn(
      r.from || s,
      r.default,
      !0
    ) : o = Tn(r.from || s) : o = Tn(r), Tt(o) ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[s] = o;
  }
}
function $u(i, e, n) {
  Un(
    Ye(i) ? i.map((s) => s.bind(e.proxy)) : i.bind(e.proxy),
    e,
    n
  );
}
function uh(i, e, n, s) {
  let r = s.includes(".") ? fh(n, s) : () => n[s];
  if (Mt(i)) {
    const o = e[i];
    et(o) && ut(r, o);
  } else if (et(i))
    ut(r, i.bind(n));
  else if (yt(i))
    if (Ye(i))
      i.forEach((o) => uh(o, e, n, s));
    else {
      const o = et(i.handler) ? i.handler.bind(n) : e[i.handler];
      et(o) && ut(r, o, i);
    }
}
function ch(i) {
  const e = i.type, { mixins: n, extends: s } = e, {
    mixins: r,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = i.appContext, l = o.get(e);
  let u;
  return l ? u = l : !r.length && !n && !s ? u = e : (u = {}, r.length && r.forEach(
    (c) => $o(u, c, a, !0)
  ), $o(u, e, a)), yt(e) && o.set(e, u), u;
}
function $o(i, e, n, s = !1) {
  const { mixins: r, extends: o } = e;
  o && $o(i, o, n, !0), r && r.forEach(
    (a) => $o(i, a, n, !0)
  );
  for (const a in e)
    if (!(s && a === "expose")) {
      const l = km[a] || n && n[a];
      i[a] = l ? l(i[a], e[a]) : e[a];
    }
  return i;
}
const km = {
  data: Bu,
  props: Wu,
  emits: Wu,
  // objects
  methods: Qi,
  computed: Qi,
  // lifecycle
  beforeCreate: qt,
  created: qt,
  beforeMount: qt,
  mounted: qt,
  beforeUpdate: qt,
  updated: qt,
  beforeDestroy: qt,
  beforeUnmount: qt,
  destroyed: qt,
  unmounted: qt,
  activated: qt,
  deactivated: qt,
  errorCaptured: qt,
  serverPrefetch: qt,
  // assets
  components: Qi,
  directives: Qi,
  // watch
  watch: Mm,
  // provide / inject
  provide: Bu,
  inject: Tm
};
function Bu(i, e) {
  return e ? i ? function() {
    return Kt(
      et(i) ? i.call(this, this) : i,
      et(e) ? e.call(this, this) : e
    );
  } : e : i;
}
function Tm(i, e) {
  return Qi(wl(i), wl(e));
}
function wl(i) {
  if (Ye(i)) {
    const e = {};
    for (let n = 0; n < i.length; n++)
      e[i[n]] = i[n];
    return e;
  }
  return i;
}
function qt(i, e) {
  return i ? [...new Set([].concat(i, e))] : e;
}
function Qi(i, e) {
  return i ? Kt(/* @__PURE__ */ Object.create(null), i, e) : e;
}
function Wu(i, e) {
  return i ? Ye(i) && Ye(e) ? [.../* @__PURE__ */ new Set([...i, ...e])] : Kt(
    /* @__PURE__ */ Object.create(null),
    ju(i),
    ju(e ?? {})
  ) : e;
}
function Mm(i, e) {
  if (!i) return e;
  if (!e) return i;
  const n = Kt(/* @__PURE__ */ Object.create(null), i);
  for (const s in e)
    n[s] = qt(i[s], e[s]);
  return n;
}
function dh() {
  return {
    app: null,
    config: {
      isNativeTag: Sd,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Om = 0;
function Em(i, e) {
  return function(s, r = null) {
    et(s) || (s = Kt({}, s)), r != null && !yt(r) && (r = null);
    const o = dh(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let u = !1;
    const c = o.app = {
      _uid: Om++,
      _component: s,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: dg,
      get config() {
        return o.config;
      },
      set config(d) {
      },
      use(d, ...f) {
        return a.has(d) || (d && et(d.install) ? (a.add(d), d.install(c, ...f)) : et(d) && (a.add(d), d(c, ...f))), c;
      },
      mixin(d) {
        return o.mixins.includes(d) || o.mixins.push(d), c;
      },
      component(d, f) {
        return f ? (o.components[d] = f, c) : o.components[d];
      },
      directive(d, f) {
        return f ? (o.directives[d] = f, c) : o.directives[d];
      },
      mount(d, f, g) {
        if (!u) {
          const p = c._ceVNode || Ae(s, r);
          return p.appContext = o, g === !0 ? g = "svg" : g === !1 && (g = void 0), i(p, d, g), u = !0, c._container = d, d.__vue_app__ = c, Ca(p.component);
        }
      },
      onUnmount(d) {
        l.push(d);
      },
      unmount() {
        u && (Un(
          l,
          c._instance,
          16
        ), i(null, c._container), delete c._container.__vue_app__);
      },
      provide(d, f) {
        return o.provides[d] = f, c;
      },
      runWithContext(d) {
        const f = Qs;
        Qs = c;
        try {
          return d();
        } finally {
          Qs = f;
        }
      }
    };
    return c;
  };
}
let Qs = null;
function ks(i, e) {
  if (Yt) {
    let n = Yt.provides;
    const s = Yt.parent && Yt.parent.provides;
    s === n && (n = Yt.provides = Object.create(s)), n[i] = e;
  }
}
function Tn(i, e, n = !1) {
  const s = Sa();
  if (s || Qs) {
    let r = Qs ? Qs._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (r && i in r)
      return r[i];
    if (arguments.length > 1)
      return n && et(e) ? e.call(s && s.proxy) : e;
  }
}
function Pm() {
  return !!(Sa() || Qs);
}
const Dm = Symbol.for("v-scx"), Am = () => Tn(Dm);
function ut(i, e, n) {
  return hh(i, e, n);
}
function hh(i, e, n = vt) {
  const { immediate: s, deep: r, flush: o, once: a } = n, l = Kt({}, n), u = e && s || !e && o !== "post";
  let c;
  if (_r) {
    if (o === "sync") {
      const p = Am();
      c = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!u) {
      const p = () => {
      };
      return p.stop = Bn, p.resume = Bn, p.pause = Bn, p;
    }
  }
  const d = Yt;
  l.call = (p, y, v) => Un(p, d, y, v);
  let f = !1;
  o === "post" ? l.scheduler = (p) => {
    Zt(p, d && d.suspense);
  } : o !== "sync" && (f = !0, l.scheduler = (p, y) => {
    y ? p() : Jl(p);
  }), l.augmentJob = (p) => {
    e && (p.flags |= 4), f && (p.flags |= 2, d && (p.id = d.uid, p.i = d));
  };
  const g = Qp(i, e, l);
  return _r && (c ? c.push(g) : u && g()), g;
}
function Im(i, e, n) {
  const s = this.proxy, r = Mt(i) ? i.includes(".") ? fh(s, i) : () => s[i] : i.bind(s, s);
  let o;
  et(e) ? o = e : (o = e.handler, n = e);
  const a = Fr(this), l = hh(r, o.bind(s), n);
  return a(), l;
}
function fh(i, e) {
  const n = e.split(".");
  return () => {
    let s = i;
    for (let r = 0; r < n.length && s; r++)
      s = s[n[r]];
    return s;
  };
}
const Fm = (i, e) => e === "modelValue" || e === "model-value" ? i.modelModifiers : i[`${e}Modifiers`] || i[`${yn(e)}Modifiers`] || i[`${zs(e)}Modifiers`];
function Lm(i, e, ...n) {
  if (i.isUnmounted) return;
  const s = i.vnode.props || vt;
  let r = n;
  const o = e.startsWith("update:"), a = o && Fm(s, e.slice(7));
  a && (a.trim && (r = n.map((d) => Mt(d) ? d.trim() : d)), a.number && (r = n.map(ma)));
  let l, u = s[l = ja(e)] || // also try camelCase event handler (#2249)
  s[l = ja(yn(e))];
  !u && o && (u = s[l = ja(zs(e))]), u && Un(
    u,
    i,
    6,
    r
  );
  const c = s[l + "Once"];
  if (c) {
    if (!i.emitted)
      i.emitted = {};
    else if (i.emitted[l])
      return;
    i.emitted[l] = !0, Un(
      c,
      i,
      6,
      r
    );
  }
}
const zm = /* @__PURE__ */ new WeakMap();
function ph(i, e, n = !1) {
  const s = n ? zm : e.emitsCache, r = s.get(i);
  if (r !== void 0)
    return r;
  const o = i.emits;
  let a = {}, l = !1;
  if (!et(i)) {
    const u = (c) => {
      const d = ph(c, e, !0);
      d && (l = !0, Kt(a, d));
    };
    !n && e.mixins.length && e.mixins.forEach(u), i.extends && u(i.extends), i.mixins && i.mixins.forEach(u);
  }
  return !o && !l ? (yt(i) && s.set(i, null), null) : (Ye(o) ? o.forEach((u) => a[u] = null) : Kt(a, o), yt(i) && s.set(i, a), a);
}
function _a(i, e) {
  return !i || !da(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), dt(i, e[0].toLowerCase() + e.slice(1)) || dt(i, zs(e)) || dt(i, e));
}
function Uu(i) {
  const {
    type: e,
    vnode: n,
    proxy: s,
    withProxy: r,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: u,
    render: c,
    renderCache: d,
    props: f,
    data: g,
    setupState: p,
    ctx: y,
    inheritAttrs: v
  } = i, m = Vo(i);
  let b, S;
  try {
    if (n.shapeFlag & 4) {
      const _ = r || s, C = _;
      b = Vn(
        c.call(
          C,
          _,
          d,
          f,
          p,
          g,
          y
        )
      ), S = l;
    } else {
      const _ = e;
      b = Vn(
        _.length > 1 ? _(
          f,
          { attrs: l, slots: a, emit: u }
        ) : _(
          f,
          null
        )
      ), S = e.props ? l : Rm(l);
    }
  } catch (_) {
    ar.length = 0, ba(_, i, 1), b = Ae(fs);
  }
  let x = b;
  if (S && v !== !1) {
    const _ = Object.keys(S), { shapeFlag: C } = x;
    _.length && C & 7 && (o && _.some(Ul) && (S = Vm(
      S,
      o
    )), x = Ti(x, S, !1, !0));
  }
  return n.dirs && (x = Ti(x, null, !1, !0), x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs), n.transition && Ql(x, n.transition), b = x, Vo(m), b;
}
const Rm = (i) => {
  let e;
  for (const n in i)
    (n === "class" || n === "style" || da(n)) && ((e || (e = {}))[n] = i[n]);
  return e;
}, Vm = (i, e) => {
  const n = {};
  for (const s in i)
    (!Ul(s) || !(s.slice(9) in e)) && (n[s] = i[s]);
  return n;
};
function jm(i, e, n) {
  const { props: s, children: r, component: o } = i, { props: a, children: l, patchFlag: u } = e, c = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return s ? Nu(s, a, c) : !!a;
    if (u & 8) {
      const d = e.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        const g = d[f];
        if (a[g] !== s[g] && !_a(c, g))
          return !0;
      }
    }
  } else
    return (r || l) && (!l || !l.$stable) ? !0 : s === a ? !1 : s ? a ? Nu(s, a, c) : !0 : !!a;
  return !1;
}
function Nu(i, e, n) {
  const s = Object.keys(e);
  if (s.length !== Object.keys(i).length)
    return !0;
  for (let r = 0; r < s.length; r++) {
    const o = s[r];
    if (e[o] !== i[o] && !_a(n, o))
      return !0;
  }
  return !1;
}
function $m({ vnode: i, parent: e }, n) {
  for (; e; ) {
    const s = e.subTree;
    if (s.suspense && s.suspense.activeBranch === i && (s.el = i.el), s === i)
      (i = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const mh = {}, gh = () => Object.create(mh), vh = (i) => Object.getPrototypeOf(i) === mh;
function Bm(i, e, n, s = !1) {
  const r = {}, o = gh();
  i.propsDefaults = /* @__PURE__ */ Object.create(null), yh(i, e, r, o);
  for (const a in i.propsOptions[0])
    a in r || (r[a] = void 0);
  n ? i.props = s ? r : Up(r) : i.type.props ? i.props = r : i.props = o, i.attrs = o;
}
function Wm(i, e, n, s) {
  const {
    props: r,
    attrs: o,
    vnode: { patchFlag: a }
  } = i, l = lt(r), [u] = i.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (s || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const d = i.vnode.dynamicProps;
      for (let f = 0; f < d.length; f++) {
        let g = d[f];
        if (_a(i.emitsOptions, g))
          continue;
        const p = e[g];
        if (u)
          if (dt(o, g))
            p !== o[g] && (o[g] = p, c = !0);
          else {
            const y = yn(g);
            r[y] = Sl(
              u,
              l,
              y,
              p,
              i,
              !1
            );
          }
        else
          p !== o[g] && (o[g] = p, c = !0);
      }
    }
  } else {
    yh(i, e, r, o) && (c = !0);
    let d;
    for (const f in l)
      (!e || // for camelCase
      !dt(e, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = zs(f)) === f || !dt(e, d))) && (u ? n && // for camelCase
      (n[f] !== void 0 || // for kebab-case
      n[d] !== void 0) && (r[f] = Sl(
        u,
        l,
        f,
        void 0,
        i,
        !0
      )) : delete r[f]);
    if (o !== l)
      for (const f in o)
        (!e || !dt(e, f)) && (delete o[f], c = !0);
  }
  c && es(i.attrs, "set", "");
}
function yh(i, e, n, s) {
  const [r, o] = i.propsOptions;
  let a = !1, l;
  if (e)
    for (let u in e) {
      if (tr(u))
        continue;
      const c = e[u];
      let d;
      r && dt(r, d = yn(u)) ? !o || !o.includes(d) ? n[d] = c : (l || (l = {}))[d] = c : _a(i.emitsOptions, u) || (!(u in s) || c !== s[u]) && (s[u] = c, a = !0);
    }
  if (o) {
    const u = lt(n), c = l || vt;
    for (let d = 0; d < o.length; d++) {
      const f = o[d];
      n[f] = Sl(
        r,
        u,
        f,
        c[f],
        i,
        !dt(c, f)
      );
    }
  }
  return a;
}
function Sl(i, e, n, s, r, o) {
  const a = i[n];
  if (a != null) {
    const l = dt(a, "default");
    if (l && s === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && et(u)) {
        const { propsDefaults: c } = r;
        if (n in c)
          s = c[n];
        else {
          const d = Fr(r);
          s = c[n] = u.call(
            null,
            e
          ), d();
        }
      } else
        s = u;
      r.ce && r.ce._setProp(n, s);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? s = !1 : a[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === zs(n)) && (s = !0));
  }
  return s;
}
const Um = /* @__PURE__ */ new WeakMap();
function bh(i, e, n = !1) {
  const s = n ? Um : e.propsCache, r = s.get(i);
  if (r)
    return r;
  const o = i.props, a = {}, l = [];
  let u = !1;
  if (!et(i)) {
    const d = (f) => {
      u = !0;
      const [g, p] = bh(f, e, !0);
      Kt(a, g), p && l.push(...p);
    };
    !n && e.mixins.length && e.mixins.forEach(d), i.extends && d(i.extends), i.mixins && i.mixins.forEach(d);
  }
  if (!o && !u)
    return yt(i) && s.set(i, vi), vi;
  if (Ye(o))
    for (let d = 0; d < o.length; d++) {
      const f = yn(o[d]);
      Hu(f) && (a[f] = vt);
    }
  else if (o)
    for (const d in o) {
      const f = yn(d);
      if (Hu(f)) {
        const g = o[d], p = a[f] = Ye(g) || et(g) ? { type: g } : Kt({}, g), y = p.type;
        let v = !1, m = !0;
        if (Ye(y))
          for (let b = 0; b < y.length; ++b) {
            const S = y[b], x = et(S) && S.name;
            if (x === "Boolean") {
              v = !0;
              break;
            } else x === "String" && (m = !1);
          }
        else
          v = et(y) && y.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = v, p[
          1
          /* shouldCastTrue */
        ] = m, (v || dt(p, "default")) && l.push(f);
      }
    }
  const c = [a, l];
  return yt(i) && s.set(i, c), c;
}
function Hu(i) {
  return i[0] !== "$" && !tr(i);
}
const tu = (i) => i === "_" || i === "_ctx" || i === "$stable", nu = (i) => Ye(i) ? i.map(Vn) : [Vn(i)], Nm = (i, e, n) => {
  if (e._n)
    return e;
  const s = Sn((...r) => nu(e(...r)), n);
  return s._c = !1, s;
}, xh = (i, e, n) => {
  const s = i._ctx;
  for (const r in i) {
    if (tu(r)) continue;
    const o = i[r];
    if (et(o))
      e[r] = Nm(r, o, s);
    else if (o != null) {
      const a = nu(o);
      e[r] = () => a;
    }
  }
}, _h = (i, e) => {
  const n = nu(e);
  i.slots.default = () => n;
}, wh = (i, e, n) => {
  for (const s in e)
    (n || !tu(s)) && (i[s] = e[s]);
}, Hm = (i, e, n) => {
  const s = i.slots = gh();
  if (i.vnode.shapeFlag & 32) {
    const r = e._;
    r ? (wh(s, e, n), n && Md(s, "_", r, !0)) : xh(e, s);
  } else e && _h(i, e);
}, Xm = (i, e, n) => {
  const { vnode: s, slots: r } = i;
  let o = !0, a = vt;
  if (s.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : wh(r, e, n) : (o = !e.$stable, xh(e, r)), a = e;
  } else e && (_h(i, e), a = { default: 1 });
  if (o)
    for (const l in r)
      !tu(l) && a[l] == null && delete r[l];
}, Zt = Zm;
function Ym(i) {
  return Gm(i);
}
function Gm(i, e) {
  const n = ga();
  n.__VUE__ = !0;
  const {
    insert: s,
    remove: r,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: u,
    setText: c,
    setElementText: d,
    parentNode: f,
    nextSibling: g,
    setScopeId: p = Bn,
    insertStaticContent: y
  } = i, v = (P, Y, U, w = null, L = null, A = null, E = void 0, I = null, j = !!Y.dynamicChildren) => {
    if (P === Y)
      return;
    P && !Ui(P, Y) && (w = te(P), J(P, L, A, !0), P = null), Y.patchFlag === -2 && (j = !1, Y.dynamicChildren = null);
    const { type: Q, ref: ce, shapeFlag: Z } = Y;
    switch (Q) {
      case wa:
        m(P, Y, U, w);
        break;
      case fs:
        b(P, Y, U, w);
        break;
      case Mo:
        P == null && S(Y, U, w, E);
        break;
      case Re:
        oe(
          P,
          Y,
          U,
          w,
          L,
          A,
          E,
          I,
          j
        );
        break;
      default:
        Z & 1 ? C(
          P,
          Y,
          U,
          w,
          L,
          A,
          E,
          I,
          j
        ) : Z & 6 ? z(
          P,
          Y,
          U,
          w,
          L,
          A,
          E,
          I,
          j
        ) : (Z & 64 || Z & 128) && Q.process(
          P,
          Y,
          U,
          w,
          L,
          A,
          E,
          I,
          j,
          D
        );
    }
    ce != null && L ? rr(ce, P && P.ref, A, Y || P, !Y) : ce == null && P && P.ref != null && rr(P.ref, null, A, P, !0);
  }, m = (P, Y, U, w) => {
    if (P == null)
      s(
        Y.el = l(Y.children),
        U,
        w
      );
    else {
      const L = Y.el = P.el;
      Y.children !== P.children && c(L, Y.children);
    }
  }, b = (P, Y, U, w) => {
    P == null ? s(
      Y.el = u(Y.children || ""),
      U,
      w
    ) : Y.el = P.el;
  }, S = (P, Y, U, w) => {
    [P.el, P.anchor] = y(
      P.children,
      Y,
      U,
      w,
      P.el,
      P.anchor
    );
  }, x = ({ el: P, anchor: Y }, U, w) => {
    let L;
    for (; P && P !== Y; )
      L = g(P), s(P, U, w), P = L;
    s(Y, U, w);
  }, _ = ({ el: P, anchor: Y }) => {
    let U;
    for (; P && P !== Y; )
      U = g(P), r(P), P = U;
    r(Y);
  }, C = (P, Y, U, w, L, A, E, I, j) => {
    if (Y.type === "svg" ? E = "svg" : Y.type === "math" && (E = "mathml"), P == null)
      k(
        Y,
        U,
        w,
        L,
        A,
        E,
        I,
        j
      );
    else {
      const Q = P.el && P.el._isVueCE ? P.el : null;
      try {
        Q && Q._beginPatch(), F(
          P,
          Y,
          L,
          A,
          E,
          I,
          j
        );
      } finally {
        Q && Q._endPatch();
      }
    }
  }, k = (P, Y, U, w, L, A, E, I) => {
    let j, Q;
    const { props: ce, shapeFlag: Z, transition: xe, dirs: Me } = P;
    if (j = P.el = a(
      P.type,
      A,
      ce && ce.is,
      ce
    ), Z & 8 ? d(j, P.children) : Z & 16 && O(
      P.children,
      j,
      null,
      w,
      L,
      Ha(P, A),
      E,
      I
    ), Me && Vs(P, null, w, "created"), M(j, P, P.scopeId, E, w), ce) {
      for (const q in ce)
        q !== "value" && !tr(q) && o(j, q, null, ce[q], A, w);
      "value" in ce && o(j, "value", null, ce.value, A), (Q = ce.onVnodeBeforeMount) && Fn(Q, w, P);
    }
    Me && Vs(P, null, w, "beforeMount");
    const Se = Km(L, xe);
    Se && xe.beforeEnter(j), s(j, Y, U), ((Q = ce && ce.onVnodeMounted) || Se || Me) && Zt(() => {
      Q && Fn(Q, w, P), Se && xe.enter(j), Me && Vs(P, null, w, "mounted");
    }, L);
  }, M = (P, Y, U, w, L) => {
    if (U && p(P, U), w)
      for (let A = 0; A < w.length; A++)
        p(P, w[A]);
    if (L) {
      let A = L.subTree;
      if (Y === A || Ch(A.type) && (A.ssContent === Y || A.ssFallback === Y)) {
        const E = L.vnode;
        M(
          P,
          E,
          E.scopeId,
          E.slotScopeIds,
          L.parent
        );
      }
    }
  }, O = (P, Y, U, w, L, A, E, I, j = 0) => {
    for (let Q = j; Q < P.length; Q++) {
      const ce = P[Q] = I ? Es(P[Q]) : Vn(P[Q]);
      v(
        null,
        ce,
        Y,
        U,
        w,
        L,
        A,
        E,
        I
      );
    }
  }, F = (P, Y, U, w, L, A, E) => {
    const I = Y.el = P.el;
    let { patchFlag: j, dynamicChildren: Q, dirs: ce } = Y;
    j |= P.patchFlag & 16;
    const Z = P.props || vt, xe = Y.props || vt;
    let Me;
    if (U && js(U, !1), (Me = xe.onVnodeBeforeUpdate) && Fn(Me, U, Y, P), ce && Vs(Y, P, U, "beforeUpdate"), U && js(U, !0), (Z.innerHTML && xe.innerHTML == null || Z.textContent && xe.textContent == null) && d(I, ""), Q ? $(
      P.dynamicChildren,
      Q,
      I,
      U,
      w,
      Ha(Y, L),
      A
    ) : E || K(
      P,
      Y,
      I,
      null,
      U,
      w,
      Ha(Y, L),
      A,
      !1
    ), j > 0) {
      if (j & 16)
        ne(I, Z, xe, U, L);
      else if (j & 2 && Z.class !== xe.class && o(I, "class", null, xe.class, L), j & 4 && o(I, "style", Z.style, xe.style, L), j & 8) {
        const Se = Y.dynamicProps;
        for (let q = 0; q < Se.length; q++) {
          const de = Se[q], ye = Z[de], Ee = xe[de];
          (Ee !== ye || de === "value") && o(I, de, ye, Ee, L, U);
        }
      }
      j & 1 && P.children !== Y.children && d(I, Y.children);
    } else !E && Q == null && ne(I, Z, xe, U, L);
    ((Me = xe.onVnodeUpdated) || ce) && Zt(() => {
      Me && Fn(Me, U, Y, P), ce && Vs(Y, P, U, "updated");
    }, w);
  }, $ = (P, Y, U, w, L, A, E) => {
    for (let I = 0; I < Y.length; I++) {
      const j = P[I], Q = Y[I], ce = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        j.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (j.type === Re || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Ui(j, Q) || // - In the case of a component, it could contain anything.
        j.shapeFlag & 198) ? f(j.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          U
        )
      );
      v(
        j,
        Q,
        ce,
        null,
        w,
        L,
        A,
        E,
        !0
      );
    }
  }, ne = (P, Y, U, w, L) => {
    if (Y !== U) {
      if (Y !== vt)
        for (const A in Y)
          !tr(A) && !(A in U) && o(
            P,
            A,
            Y[A],
            null,
            L,
            w
          );
      for (const A in U) {
        if (tr(A)) continue;
        const E = U[A], I = Y[A];
        E !== I && A !== "value" && o(P, A, I, E, L, w);
      }
      "value" in U && o(P, "value", Y.value, U.value, L);
    }
  }, oe = (P, Y, U, w, L, A, E, I, j) => {
    const Q = Y.el = P ? P.el : l(""), ce = Y.anchor = P ? P.anchor : l("");
    let { patchFlag: Z, dynamicChildren: xe, slotScopeIds: Me } = Y;
    Me && (I = I ? I.concat(Me) : Me), P == null ? (s(Q, U, w), s(ce, U, w), O(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      Y.children || [],
      U,
      ce,
      L,
      A,
      E,
      I,
      j
    )) : Z > 0 && Z & 64 && xe && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    P.dynamicChildren ? ($(
      P.dynamicChildren,
      xe,
      U,
      L,
      A,
      E,
      I
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (Y.key != null || L && Y === L.subTree) && su(
      P,
      Y,
      !0
      /* shallow */
    )) : K(
      P,
      Y,
      U,
      ce,
      L,
      A,
      E,
      I,
      j
    );
  }, z = (P, Y, U, w, L, A, E, I, j) => {
    Y.slotScopeIds = I, P == null ? Y.shapeFlag & 512 ? L.ctx.activate(
      Y,
      U,
      w,
      E,
      j
    ) : X(
      Y,
      U,
      w,
      L,
      A,
      E,
      j
    ) : T(P, Y, j);
  }, X = (P, Y, U, w, L, A, E) => {
    const I = P.component = ig(
      P,
      w,
      L
    );
    if (ih(P) && (I.ctx.renderer = D), rg(I, !1, E), I.asyncDep) {
      if (L && L.registerDep(I, H, E), !P.el) {
        const j = I.subTree = Ae(fs);
        b(null, j, Y, U), P.placeholder = j.el;
      }
    } else
      H(
        I,
        P,
        Y,
        U,
        L,
        A,
        E
      );
  }, T = (P, Y, U) => {
    const w = Y.component = P.component;
    if (jm(P, Y, U))
      if (w.asyncDep && !w.asyncResolved) {
        ge(w, Y, U);
        return;
      } else
        w.next = Y, w.update();
    else
      Y.el = P.el, w.vnode = Y;
  }, H = (P, Y, U, w, L, A, E) => {
    const I = () => {
      if (P.isMounted) {
        let { next: Z, bu: xe, u: Me, parent: Se, vnode: q } = P;
        {
          const ze = Sh(P);
          if (ze) {
            Z && (Z.el = q.el, ge(P, Z, E)), ze.asyncDep.then(() => {
              P.isUnmounted || I();
            });
            return;
          }
        }
        let de = Z, ye;
        js(P, !1), Z ? (Z.el = q.el, ge(P, Z, E)) : Z = q, xe && ko(xe), (ye = Z.props && Z.props.onVnodeBeforeUpdate) && Fn(ye, Se, Z, q), js(P, !0);
        const Ee = Uu(P), Le = P.subTree;
        P.subTree = Ee, v(
          Le,
          Ee,
          // parent may have changed if it's in a teleport
          f(Le.el),
          // anchor may have changed if it's in a fragment
          te(Le),
          P,
          L,
          A
        ), Z.el = Ee.el, de === null && $m(P, Ee.el), Me && Zt(Me, L), (ye = Z.props && Z.props.onVnodeUpdated) && Zt(
          () => Fn(ye, Se, Z, q),
          L
        );
      } else {
        let Z;
        const { el: xe, props: Me } = Y, { bm: Se, m: q, parent: de, root: ye, type: Ee } = P, Le = xi(Y);
        js(P, !1), Se && ko(Se), !Le && (Z = Me && Me.onVnodeBeforeMount) && Fn(Z, de, Y), js(P, !0);
        {
          ye.ce && // @ts-expect-error _def is private
          ye.ce._def.shadowRoot !== !1 && ye.ce._injectChildStyle(Ee);
          const ze = P.subTree = Uu(P);
          v(
            null,
            ze,
            U,
            w,
            P,
            L,
            A
          ), Y.el = ze.el;
        }
        if (q && Zt(q, L), !Le && (Z = Me && Me.onVnodeMounted)) {
          const ze = Y;
          Zt(
            () => Fn(Z, de, ze),
            L
          );
        }
        (Y.shapeFlag & 256 || de && xi(de.vnode) && de.vnode.shapeFlag & 256) && P.a && Zt(P.a, L), P.isMounted = !0, Y = U = w = null;
      }
    };
    P.scope.on();
    const j = P.effect = new Fd(I);
    P.scope.off();
    const Q = P.update = j.run.bind(j), ce = P.job = j.runIfDirty.bind(j);
    ce.i = P, ce.id = P.uid, j.scheduler = () => Jl(ce), js(P, !0), Q();
  }, ge = (P, Y, U) => {
    Y.component = P;
    const w = P.vnode.props;
    P.vnode = Y, P.next = null, Wm(P, Y.props, w, U), Xm(P, Y.children, U), cs(), Iu(P), ds();
  }, K = (P, Y, U, w, L, A, E, I, j = !1) => {
    const Q = P && P.children, ce = P ? P.shapeFlag : 0, Z = Y.children, { patchFlag: xe, shapeFlag: Me } = Y;
    if (xe > 0) {
      if (xe & 128) {
        ie(
          Q,
          Z,
          U,
          w,
          L,
          A,
          E,
          I,
          j
        );
        return;
      } else if (xe & 256) {
        re(
          Q,
          Z,
          U,
          w,
          L,
          A,
          E,
          I,
          j
        );
        return;
      }
    }
    Me & 8 ? (ce & 16 && N(Q, L, A), Z !== Q && d(U, Z)) : ce & 16 ? Me & 16 ? ie(
      Q,
      Z,
      U,
      w,
      L,
      A,
      E,
      I,
      j
    ) : N(Q, L, A, !0) : (ce & 8 && d(U, ""), Me & 16 && O(
      Z,
      U,
      w,
      L,
      A,
      E,
      I,
      j
    ));
  }, re = (P, Y, U, w, L, A, E, I, j) => {
    P = P || vi, Y = Y || vi;
    const Q = P.length, ce = Y.length, Z = Math.min(Q, ce);
    let xe;
    for (xe = 0; xe < Z; xe++) {
      const Me = Y[xe] = j ? Es(Y[xe]) : Vn(Y[xe]);
      v(
        P[xe],
        Me,
        U,
        null,
        L,
        A,
        E,
        I,
        j
      );
    }
    Q > ce ? N(
      P,
      L,
      A,
      !0,
      !1,
      Z
    ) : O(
      Y,
      U,
      w,
      L,
      A,
      E,
      I,
      j,
      Z
    );
  }, ie = (P, Y, U, w, L, A, E, I, j) => {
    let Q = 0;
    const ce = Y.length;
    let Z = P.length - 1, xe = ce - 1;
    for (; Q <= Z && Q <= xe; ) {
      const Me = P[Q], Se = Y[Q] = j ? Es(Y[Q]) : Vn(Y[Q]);
      if (Ui(Me, Se))
        v(
          Me,
          Se,
          U,
          null,
          L,
          A,
          E,
          I,
          j
        );
      else
        break;
      Q++;
    }
    for (; Q <= Z && Q <= xe; ) {
      const Me = P[Z], Se = Y[xe] = j ? Es(Y[xe]) : Vn(Y[xe]);
      if (Ui(Me, Se))
        v(
          Me,
          Se,
          U,
          null,
          L,
          A,
          E,
          I,
          j
        );
      else
        break;
      Z--, xe--;
    }
    if (Q > Z) {
      if (Q <= xe) {
        const Me = xe + 1, Se = Me < ce ? Y[Me].el : w;
        for (; Q <= xe; )
          v(
            null,
            Y[Q] = j ? Es(Y[Q]) : Vn(Y[Q]),
            U,
            Se,
            L,
            A,
            E,
            I,
            j
          ), Q++;
      }
    } else if (Q > xe)
      for (; Q <= Z; )
        J(P[Q], L, A, !0), Q++;
    else {
      const Me = Q, Se = Q, q = /* @__PURE__ */ new Map();
      for (Q = Se; Q <= xe; Q++) {
        const Pe = Y[Q] = j ? Es(Y[Q]) : Vn(Y[Q]);
        Pe.key != null && q.set(Pe.key, Q);
      }
      let de, ye = 0;
      const Ee = xe - Se + 1;
      let Le = !1, ze = 0;
      const ke = new Array(Ee);
      for (Q = 0; Q < Ee; Q++) ke[Q] = 0;
      for (Q = Me; Q <= Z; Q++) {
        const Pe = P[Q];
        if (ye >= Ee) {
          J(Pe, L, A, !0);
          continue;
        }
        let je;
        if (Pe.key != null)
          je = q.get(Pe.key);
        else
          for (de = Se; de <= xe; de++)
            if (ke[de - Se] === 0 && Ui(Pe, Y[de])) {
              je = de;
              break;
            }
        je === void 0 ? J(Pe, L, A, !0) : (ke[je - Se] = Q + 1, je >= ze ? ze = je : Le = !0, v(
          Pe,
          Y[je],
          U,
          null,
          L,
          A,
          E,
          I,
          j
        ), ye++);
      }
      const Ce = Le ? qm(ke) : vi;
      for (de = Ce.length - 1, Q = Ee - 1; Q >= 0; Q--) {
        const Pe = Se + Q, je = Y[Pe], Ge = Y[Pe + 1], ct = Pe + 1 < ce ? (
          // #13559, fallback to el placeholder for unresolved async component
          Ge.el || Ge.placeholder
        ) : w;
        ke[Q] === 0 ? v(
          null,
          je,
          U,
          ct,
          L,
          A,
          E,
          I,
          j
        ) : Le && (de < 0 || Q !== Ce[de] ? be(je, U, ct, 2) : de--);
      }
    }
  }, be = (P, Y, U, w, L = null) => {
    const { el: A, type: E, transition: I, children: j, shapeFlag: Q } = P;
    if (Q & 6) {
      be(P.component.subTree, Y, U, w);
      return;
    }
    if (Q & 128) {
      P.suspense.move(Y, U, w);
      return;
    }
    if (Q & 64) {
      E.move(P, Y, U, D);
      return;
    }
    if (E === Re) {
      s(A, Y, U);
      for (let Z = 0; Z < j.length; Z++)
        be(j[Z], Y, U, w);
      s(P.anchor, Y, U);
      return;
    }
    if (E === Mo) {
      x(P, Y, U);
      return;
    }
    if (w !== 2 && Q & 1 && I)
      if (w === 0)
        I.beforeEnter(A), s(A, Y, U), Zt(() => I.enter(A), L);
      else {
        const { leave: Z, delayLeave: xe, afterLeave: Me } = I, Se = () => {
          P.ctx.isUnmounted ? r(A) : s(A, Y, U);
        }, q = () => {
          A._isLeaving && A[om](
            !0
            /* cancelled */
          ), Z(A, () => {
            Se(), Me && Me();
          });
        };
        xe ? xe(A, Se, q) : q();
      }
    else
      s(A, Y, U);
  }, J = (P, Y, U, w = !1, L = !1) => {
    const {
      type: A,
      props: E,
      ref: I,
      children: j,
      dynamicChildren: Q,
      shapeFlag: ce,
      patchFlag: Z,
      dirs: xe,
      cacheIndex: Me
    } = P;
    if (Z === -2 && (L = !1), I != null && (cs(), rr(I, null, U, P, !0), ds()), Me != null && (Y.renderCache[Me] = void 0), ce & 256) {
      Y.ctx.deactivate(P);
      return;
    }
    const Se = ce & 1 && xe, q = !xi(P);
    let de;
    if (q && (de = E && E.onVnodeBeforeUnmount) && Fn(de, Y, P), ce & 6)
      G(P.component, U, w);
    else {
      if (ce & 128) {
        P.suspense.unmount(U, w);
        return;
      }
      Se && Vs(P, null, Y, "beforeUnmount"), ce & 64 ? P.type.remove(
        P,
        Y,
        U,
        D,
        w
      ) : Q && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !Q.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (A !== Re || Z > 0 && Z & 64) ? N(
        Q,
        Y,
        U,
        !1,
        !0
      ) : (A === Re && Z & 384 || !L && ce & 16) && N(j, Y, U), w && ee(P);
    }
    (q && (de = E && E.onVnodeUnmounted) || Se) && Zt(() => {
      de && Fn(de, Y, P), Se && Vs(P, null, Y, "unmounted");
    }, U);
  }, ee = (P) => {
    const { type: Y, el: U, anchor: w, transition: L } = P;
    if (Y === Re) {
      ve(U, w);
      return;
    }
    if (Y === Mo) {
      _(P);
      return;
    }
    const A = () => {
      r(U), L && !L.persisted && L.afterLeave && L.afterLeave();
    };
    if (P.shapeFlag & 1 && L && !L.persisted) {
      const { leave: E, delayLeave: I } = L, j = () => E(U, A);
      I ? I(P.el, A, j) : j();
    } else
      A();
  }, ve = (P, Y) => {
    let U;
    for (; P !== Y; )
      U = g(P), r(P), P = U;
    r(Y);
  }, G = (P, Y, U) => {
    const { bum: w, scope: L, job: A, subTree: E, um: I, m: j, a: Q } = P;
    Xu(j), Xu(Q), w && ko(w), L.stop(), A && (A.flags |= 8, J(E, P, Y, U)), I && Zt(I, Y), Zt(() => {
      P.isUnmounted = !0;
    }, Y);
  }, N = (P, Y, U, w = !1, L = !1, A = 0) => {
    for (let E = A; E < P.length; E++)
      J(P[E], Y, U, w, L);
  }, te = (P) => {
    if (P.shapeFlag & 6)
      return te(P.component.subTree);
    if (P.shapeFlag & 128)
      return P.suspense.next();
    const Y = g(P.anchor || P.el), U = Y && Y[eh];
    return U ? g(U) : Y;
  };
  let fe = !1;
  const ae = (P, Y, U) => {
    P == null ? Y._vnode && J(Y._vnode, null, null, !0) : v(
      Y._vnode || null,
      P,
      Y,
      null,
      null,
      null,
      U
    ), Y._vnode = P, fe || (fe = !0, Iu(), Zd(), fe = !1);
  }, D = {
    p: v,
    um: J,
    m: be,
    r: ee,
    mt: X,
    mc: O,
    pc: K,
    pbc: $,
    n: te,
    o: i
  };
  return {
    render: ae,
    hydrate: void 0,
    createApp: Em(ae)
  };
}
function Ha({ type: i, props: e }, n) {
  return n === "svg" && i === "foreignObject" || n === "mathml" && i === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function js({ effect: i, job: e }, n) {
  n ? (i.flags |= 32, e.flags |= 4) : (i.flags &= -33, e.flags &= -5);
}
function Km(i, e) {
  return (!i || i && !i.pendingBranch) && e && !e.persisted;
}
function su(i, e, n = !1) {
  const s = i.children, r = e.children;
  if (Ye(s) && Ye(r))
    for (let o = 0; o < s.length; o++) {
      const a = s[o];
      let l = r[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = Es(r[o]), l.el = a.el), !n && l.patchFlag !== -2 && su(a, l)), l.type === wa && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === fs && !l.el && (l.el = a.el);
    }
}
function qm(i) {
  const e = i.slice(), n = [0];
  let s, r, o, a, l;
  const u = i.length;
  for (s = 0; s < u; s++) {
    const c = i[s];
    if (c !== 0) {
      if (r = n[n.length - 1], i[r] < c) {
        e[s] = r, n.push(s);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, i[n[l]] < c ? o = l + 1 : a = l;
      c < i[n[o]] && (o > 0 && (e[s] = n[o - 1]), n[o] = s);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function Sh(i) {
  const e = i.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Sh(e);
}
function Xu(i) {
  if (i)
    for (let e = 0; e < i.length; e++)
      i[e].flags |= 8;
}
const Ch = (i) => i.__isSuspense;
function Zm(i, e) {
  e && e.pendingBranch ? Ye(i) ? e.effects.push(...i) : e.effects.push(i) : nm(i);
}
const Re = Symbol.for("v-fgt"), wa = Symbol.for("v-txt"), fs = Symbol.for("v-cmt"), Mo = Symbol.for("v-stc"), ar = [];
let hn = null;
function V(i = !1) {
  ar.push(hn = i ? null : []);
}
function Jm() {
  ar.pop(), hn = ar[ar.length - 1] || null;
}
let yr = 1;
function Bo(i, e = !1) {
  yr += i, i < 0 && hn && e && (hn.hasOnce = !0);
}
function kh(i) {
  return i.dynamicChildren = yr > 0 ? hn || vi : null, Jm(), yr > 0 && hn && hn.push(i), i;
}
function B(i, e, n, s, r, o) {
  return kh(
    h(
      i,
      e,
      n,
      s,
      r,
      o,
      !0
    )
  );
}
function ot(i, e, n, s, r) {
  return kh(
    Ae(
      i,
      e,
      n,
      s,
      r,
      !0
    )
  );
}
function br(i) {
  return i ? i.__v_isVNode === !0 : !1;
}
function Ui(i, e) {
  return i.type === e.type && i.key === e.key;
}
const Th = ({ key: i }) => i ?? null, Oo = ({
  ref: i,
  ref_key: e,
  ref_for: n
}) => (typeof i == "number" && (i = "" + i), i != null ? Mt(i) || Tt(i) || et(i) ? { i: Bt, r: i, k: e, f: !!n } : i : null);
function h(i, e = null, n = null, s = 0, r = null, o = i === Re ? 0 : 1, a = !1, l = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i,
    props: e,
    key: e && Th(e),
    ref: e && Oo(e),
    scopeId: Qd,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: s,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Bt
  };
  return l ? (iu(u, n), o & 128 && i.normalize(u)) : n && (u.shapeFlag |= Mt(n) ? 8 : 16), yr > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  hn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && hn.push(u), u;
}
const Ae = Qm;
function Qm(i, e = null, n = null, s = 0, r = null, o = !1) {
  if ((!i || i === oh) && (i = fs), br(i)) {
    const l = Ti(
      i,
      e,
      !0
      /* mergeRef: true */
    );
    return n && iu(l, n), yr > 0 && !o && hn && (l.shapeFlag & 6 ? hn[hn.indexOf(i)] = l : hn.push(l)), l.patchFlag = -2, l;
  }
  if (ug(i) && (i = i.__vccOpts), e) {
    e = eg(e);
    let { class: l, style: u } = e;
    l && !Mt(l) && (e.class = Ie(l)), yt(u) && (ya(u) && !Ye(u) && (u = Kt({}, u)), e.style = Xe(u));
  }
  const a = Mt(i) ? 1 : Ch(i) ? 128 : sm(i) ? 64 : yt(i) ? 4 : et(i) ? 2 : 0;
  return h(
    i,
    e,
    n,
    s,
    r,
    a,
    o,
    !0
  );
}
function eg(i) {
  return i ? ya(i) || vh(i) ? Kt({}, i) : i : null;
}
function Ti(i, e, n = !1, s = !1) {
  const { props: r, ref: o, patchFlag: a, children: l, transition: u } = i, c = e ? tg(r || {}, e) : r, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i.type,
    props: c,
    key: c && Th(c),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? Ye(o) ? o.concat(Oo(e)) : [o, Oo(e)] : Oo(e)
    ) : o,
    scopeId: i.scopeId,
    slotScopeIds: i.slotScopeIds,
    children: l,
    target: i.target,
    targetStart: i.targetStart,
    targetAnchor: i.targetAnchor,
    staticCount: i.staticCount,
    shapeFlag: i.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && i.type !== Re ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: i.dynamicProps,
    dynamicChildren: i.dynamicChildren,
    appContext: i.appContext,
    dirs: i.dirs,
    transition: u,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: i.component,
    suspense: i.suspense,
    ssContent: i.ssContent && Ti(i.ssContent),
    ssFallback: i.ssFallback && Ti(i.ssFallback),
    placeholder: i.placeholder,
    el: i.el,
    anchor: i.anchor,
    ctx: i.ctx,
    ce: i.ce
  };
  return u && s && Ql(
    d,
    u.clone(d)
  ), d;
}
function qe(i = " ", e = 0) {
  return Ae(wa, null, i, e);
}
function xr(i, e) {
  const n = Ae(Mo, null, i);
  return n.staticCount = e, n;
}
function Te(i = "", e = !1) {
  return e ? (V(), ot(fs, null, i)) : Ae(fs, null, i);
}
function Vn(i) {
  return i == null || typeof i == "boolean" ? Ae(fs) : Ye(i) ? Ae(
    Re,
    null,
    // #3666, avoid reference pollution when reusing vnode
    i.slice()
  ) : br(i) ? Es(i) : Ae(wa, null, String(i));
}
function Es(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : Ti(i);
}
function iu(i, e) {
  let n = 0;
  const { shapeFlag: s } = i;
  if (e == null)
    e = null;
  else if (Ye(e))
    n = 16;
  else if (typeof e == "object")
    if (s & 65) {
      const r = e.default;
      r && (r._c && (r._d = !1), iu(i, r()), r._c && (r._d = !0));
      return;
    } else {
      n = 32;
      const r = e._;
      !r && !vh(e) ? e._ctx = Bt : r === 3 && Bt && (Bt.slots._ === 1 ? e._ = 1 : (e._ = 2, i.patchFlag |= 1024));
    }
  else et(e) ? (e = { default: e, _ctx: Bt }, n = 32) : (e = String(e), s & 64 ? (n = 16, e = [qe(e)]) : n = 8);
  i.children = e, i.shapeFlag |= n;
}
function tg(...i) {
  const e = {};
  for (let n = 0; n < i.length; n++) {
    const s = i[n];
    for (const r in s)
      if (r === "class")
        e.class !== s.class && (e.class = Ie([e.class, s.class]));
      else if (r === "style")
        e.style = Xe([e.style, s.style]);
      else if (da(r)) {
        const o = e[r], a = s[r];
        a && o !== a && !(Ye(o) && o.includes(a)) && (e[r] = o ? [].concat(o, a) : a);
      } else r !== "" && (e[r] = s[r]);
  }
  return e;
}
function Fn(i, e, n, s = null) {
  Un(i, e, 7, [
    n,
    s
  ]);
}
const ng = dh();
let sg = 0;
function ig(i, e, n) {
  const s = i.type, r = (e ? e.appContext : i.appContext) || ng, o = {
    uid: sg++,
    vnode: i,
    type: s,
    parent: e,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Dd(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(r.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: bh(s, r),
    emitsOptions: ph(s, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: vt,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: vt,
    data: vt,
    props: vt,
    attrs: vt,
    slots: vt,
    refs: vt,
    setupState: vt,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = Lm.bind(null, o), i.ce && i.ce(o), o;
}
let Yt = null;
const Sa = () => Yt || Bt;
let Wo, Cl;
{
  const i = ga(), e = (n, s) => {
    let r;
    return (r = i[n]) || (r = i[n] = []), r.push(s), (o) => {
      r.length > 1 ? r.forEach((a) => a(o)) : r[0](o);
    };
  };
  Wo = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Yt = n
  ), Cl = e(
    "__VUE_SSR_SETTERS__",
    (n) => _r = n
  );
}
const Fr = (i) => {
  const e = Yt;
  return Wo(i), i.scope.on(), () => {
    i.scope.off(), Wo(e);
  };
}, Yu = () => {
  Yt && Yt.scope.off(), Wo(null);
};
function Mh(i) {
  return i.vnode.shapeFlag & 4;
}
let _r = !1;
function rg(i, e = !1, n = !1) {
  e && Cl(e);
  const { props: s, children: r } = i.vnode, o = Mh(i);
  Bm(i, s, o, e), Hm(i, r, n || e);
  const a = o ? og(i, e) : void 0;
  return e && Cl(!1), a;
}
function og(i, e) {
  const n = i.type;
  i.accessCache = /* @__PURE__ */ Object.create(null), i.proxy = new Proxy(i.ctx, xm);
  const { setup: s } = n;
  if (s) {
    cs();
    const r = i.setupContext = s.length > 1 ? Eh(i) : null, o = Fr(i), a = Ir(
      s,
      i,
      0,
      [
        i.props,
        r
      ]
    ), l = Cd(a);
    if (ds(), o(), (l || i.sp) && !xi(i) && sh(i), l) {
      if (a.then(Yu, Yu), e)
        return a.then((u) => {
          Gu(i, u);
        }).catch((u) => {
          ba(u, i, 0);
        });
      i.asyncDep = a;
    } else
      Gu(i, a);
  } else
    Oh(i);
}
function Gu(i, e, n) {
  et(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : yt(e) && (i.setupState = Gd(e)), Oh(i);
}
function Oh(i, e, n) {
  const s = i.type;
  i.render || (i.render = s.render || Bn);
  {
    const r = Fr(i);
    cs();
    try {
      Sm(i);
    } finally {
      ds(), r();
    }
  }
}
const ag = {
  get(i, e) {
    return Xt(i, "get", ""), i[e];
  }
};
function Eh(i) {
  const e = (n) => {
    i.exposed = n || {};
  };
  return {
    attrs: new Proxy(i.attrs, ag),
    slots: i.slots,
    emit: i.emit,
    expose: e
  };
}
function Ca(i) {
  return i.exposed ? i.exposeProxy || (i.exposeProxy = new Proxy(Gd(Zn(i.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in or)
        return or[n](i);
    },
    has(e, n) {
      return n in e || n in or;
    }
  })) : i.proxy;
}
function lg(i, e = !0) {
  return et(i) ? i.displayName || i.name : i.name || e && i.__name;
}
function ug(i) {
  return et(i) && "__vccOpts" in i;
}
const Oe = (i, e) => Zp(i, e, _r);
function cg(i, e, n) {
  try {
    Bo(-1);
    const s = arguments.length;
    return s === 2 ? yt(e) && !Ye(e) ? br(e) ? Ae(i, null, [e]) : Ae(i, e) : Ae(i, null, e) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && br(n) && (n = [n]), Ae(i, e, n));
  } finally {
    Bo(1);
  }
}
const dg = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let kl;
const Ku = typeof window < "u" && window.trustedTypes;
if (Ku)
  try {
    kl = /* @__PURE__ */ Ku.createPolicy("vue", {
      createHTML: (i) => i
    });
  } catch {
  }
const Ph = kl ? (i) => kl.createHTML(i) : (i) => i, hg = "http://www.w3.org/2000/svg", fg = "http://www.w3.org/1998/Math/MathML", qn = typeof document < "u" ? document : null, qu = qn && /* @__PURE__ */ qn.createElement("template"), pg = {
  insert: (i, e, n) => {
    e.insertBefore(i, n || null);
  },
  remove: (i) => {
    const e = i.parentNode;
    e && e.removeChild(i);
  },
  createElement: (i, e, n, s) => {
    const r = e === "svg" ? qn.createElementNS(hg, i) : e === "mathml" ? qn.createElementNS(fg, i) : n ? qn.createElement(i, { is: n }) : qn.createElement(i);
    return i === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r;
  },
  createText: (i) => qn.createTextNode(i),
  createComment: (i) => qn.createComment(i),
  setText: (i, e) => {
    i.nodeValue = e;
  },
  setElementText: (i, e) => {
    i.textContent = e;
  },
  parentNode: (i) => i.parentNode,
  nextSibling: (i) => i.nextSibling,
  querySelector: (i) => qn.querySelector(i),
  setScopeId(i, e) {
    i.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(i, e, n, s, r, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (r && (r === o || r.nextSibling))
      for (; e.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling)); )
        ;
    else {
      qu.innerHTML = Ph(
        s === "svg" ? `<svg>${i}</svg>` : s === "mathml" ? `<math>${i}</math>` : i
      );
      const l = qu.content;
      if (s === "svg" || s === "mathml") {
        const u = l.firstChild;
        for (; u.firstChild; )
          l.appendChild(u.firstChild);
        l.removeChild(u);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, mg = Symbol("_vtc");
function gg(i, e, n) {
  const s = i[mg];
  s && (e = (e ? [e, ...s] : [...s]).join(" ")), e == null ? i.removeAttribute("class") : n ? i.setAttribute("class", e) : i.className = e;
}
const Uo = Symbol("_vod"), Dh = Symbol("_vsh"), $s = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(i, { value: e }, { transition: n }) {
    i[Uo] = i.style.display === "none" ? "" : i.style.display, n && e ? n.beforeEnter(i) : Ni(i, e);
  },
  mounted(i, { value: e }, { transition: n }) {
    n && e && n.enter(i);
  },
  updated(i, { value: e, oldValue: n }, { transition: s }) {
    !e != !n && (s ? e ? (s.beforeEnter(i), Ni(i, !0), s.enter(i)) : s.leave(i, () => {
      Ni(i, !1);
    }) : Ni(i, e));
  },
  beforeUnmount(i, { value: e }) {
    Ni(i, e);
  }
};
function Ni(i, e) {
  i.style.display = e ? i[Uo] : "none", i[Dh] = !e;
}
const vg = Symbol(""), yg = /(?:^|;)\s*display\s*:/;
function bg(i, e, n) {
  const s = i.style, r = Mt(n);
  let o = !1;
  if (n && !r) {
    if (e)
      if (Mt(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && Eo(s, l, "");
        }
      else
        for (const a in e)
          n[a] == null && Eo(s, a, "");
    for (const a in n)
      a === "display" && (o = !0), Eo(s, a, n[a]);
  } else if (r) {
    if (e !== n) {
      const a = s[vg];
      a && (n += ";" + a), s.cssText = n, o = yg.test(n);
    }
  } else e && i.removeAttribute("style");
  Uo in i && (i[Uo] = o ? s.display : "", i[Dh] && (s.display = "none"));
}
const Zu = /\s*!important$/;
function Eo(i, e, n) {
  if (Ye(n))
    n.forEach((s) => Eo(i, e, s));
  else if (n == null && (n = ""), e.startsWith("--"))
    i.setProperty(e, n);
  else {
    const s = xg(i, e);
    Zu.test(n) ? i.setProperty(
      zs(s),
      n.replace(Zu, ""),
      "important"
    ) : i[s] = n;
  }
}
const Ju = ["Webkit", "Moz", "ms"], Xa = {};
function xg(i, e) {
  const n = Xa[e];
  if (n)
    return n;
  let s = yn(e);
  if (s !== "filter" && s in i)
    return Xa[e] = s;
  s = pa(s);
  for (let r = 0; r < Ju.length; r++) {
    const o = Ju[r] + s;
    if (o in i)
      return Xa[e] = o;
  }
  return e;
}
const Qu = "http://www.w3.org/1999/xlink";
function ec(i, e, n, s, r, o = _p(e)) {
  s && e.startsWith("xlink:") ? n == null ? i.removeAttributeNS(Qu, e.slice(6, e.length)) : i.setAttributeNS(Qu, e, n) : n == null || o && !Od(n) ? i.removeAttribute(e) : i.setAttribute(
    e,
    o ? "" : An(n) ? String(n) : n
  );
}
function tc(i, e, n, s, r) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (i[e] = e === "innerHTML" ? Ph(n) : n);
    return;
  }
  const o = i.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? i.getAttribute("value") || "" : i.value, u = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      i.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== u || !("_value" in i)) && (i.value = u), n == null && i.removeAttribute(e), i._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof i[e];
    l === "boolean" ? n = Od(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    i[e] = n;
  } catch {
  }
  a && i.removeAttribute(r || e);
}
function Ps(i, e, n, s) {
  i.addEventListener(e, n, s);
}
function _g(i, e, n, s) {
  i.removeEventListener(e, n, s);
}
const nc = Symbol("_vei");
function wg(i, e, n, s, r = null) {
  const o = i[nc] || (i[nc] = {}), a = o[e];
  if (s && a)
    a.value = s;
  else {
    const [l, u] = Sg(e);
    if (s) {
      const c = o[e] = Tg(
        s,
        r
      );
      Ps(i, l, c, u);
    } else a && (_g(i, l, a, u), o[e] = void 0);
  }
}
const sc = /(?:Once|Passive|Capture)$/;
function Sg(i) {
  let e;
  if (sc.test(i)) {
    e = {};
    let s;
    for (; s = i.match(sc); )
      i = i.slice(0, i.length - s[0].length), e[s[0].toLowerCase()] = !0;
  }
  return [i[2] === ":" ? i.slice(3) : zs(i.slice(2)), e];
}
let Ya = 0;
const Cg = /* @__PURE__ */ Promise.resolve(), kg = () => Ya || (Cg.then(() => Ya = 0), Ya = Date.now());
function Tg(i, e) {
  const n = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= n.attached)
      return;
    Un(
      Mg(s, n.value),
      e,
      5,
      [s]
    );
  };
  return n.value = i, n.attached = kg(), n;
}
function Mg(i, e) {
  if (Ye(e)) {
    const n = i.stopImmediatePropagation;
    return i.stopImmediatePropagation = () => {
      n.call(i), i._stopped = !0;
    }, e.map(
      (s) => (r) => !r._stopped && s && s(r)
    );
  } else
    return e;
}
const ic = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // lowercase letter
i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123, Og = (i, e, n, s, r, o) => {
  const a = r === "svg";
  e === "class" ? gg(i, s, a) : e === "style" ? bg(i, n, s) : da(e) ? Ul(e) || wg(i, e, n, s, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : Eg(i, e, s, a)) ? (tc(i, e, s), !i.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && ec(i, e, s, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ i._isVueCE && (/[A-Z]/.test(e) || !Mt(s)) ? tc(i, yn(e), s, o, e) : (e === "true-value" ? i._trueValue = s : e === "false-value" && (i._falseValue = s), ec(i, e, s, a));
};
function Eg(i, e, n, s) {
  if (s)
    return !!(e === "innerHTML" || e === "textContent" || e in i && ic(e) && et(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && i.tagName === "IFRAME" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const r = i.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return !1;
  }
  return ic(e) && Mt(n) ? !1 : e in i;
}
const Mi = (i) => {
  const e = i.props["onUpdate:modelValue"] || !1;
  return Ye(e) ? (n) => ko(e, n) : e;
};
function Pg(i) {
  i.target.composing = !0;
}
function rc(i) {
  const e = i.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const os = Symbol("_assign");
function oc(i, e, n) {
  return e && (i = i.trim()), n && (i = ma(i)), i;
}
const $t = {
  created(i, { modifiers: { lazy: e, trim: n, number: s } }, r) {
    i[os] = Mi(r);
    const o = s || r.props && r.props.type === "number";
    Ps(i, e ? "change" : "input", (a) => {
      a.target.composing || i[os](oc(i.value, n, o));
    }), (n || o) && Ps(i, "change", () => {
      i.value = oc(i.value, n, o);
    }), e || (Ps(i, "compositionstart", Pg), Ps(i, "compositionend", rc), Ps(i, "change", rc));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(i, { value: e }) {
    i.value = e ?? "";
  },
  beforeUpdate(i, { value: e, oldValue: n, modifiers: { lazy: s, trim: r, number: o } }, a) {
    if (i[os] = Mi(a), i.composing) return;
    const l = (o || i.type === "number") && !/^0\d/.test(i.value) ? ma(i.value) : i.value, u = e ?? "";
    l !== u && (document.activeElement === i && i.type !== "range" && (s && e === n || r && i.value.trim() === u) || (i.value = u));
  }
}, No = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(i, e, n) {
    i[os] = Mi(n), Ps(i, "change", () => {
      const s = i._modelValue, r = wr(i), o = i.checked, a = i[os];
      if (Ye(s)) {
        const l = Hl(s, r), u = l !== -1;
        if (o && !u)
          a(s.concat(r));
        else if (!o && u) {
          const c = [...s];
          c.splice(l, 1), a(c);
        }
      } else if (Di(s)) {
        const l = new Set(s);
        o ? l.add(r) : l.delete(r), a(l);
      } else
        a(Ah(i, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: ac,
  beforeUpdate(i, e, n) {
    i[os] = Mi(n), ac(i, e, n);
  }
};
function ac(i, { value: e, oldValue: n }, s) {
  i._modelValue = e;
  let r;
  if (Ye(e))
    r = Hl(e, s.props.value) > -1;
  else if (Di(e))
    r = e.has(s.props.value);
  else {
    if (e === n) return;
    r = Ar(e, Ah(i, !0));
  }
  i.checked !== r && (i.checked = r);
}
const nn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(i, { value: e, modifiers: { number: n } }, s) {
    const r = Di(e);
    Ps(i, "change", () => {
      const o = Array.prototype.filter.call(i.options, (a) => a.selected).map(
        (a) => n ? ma(wr(a)) : wr(a)
      );
      i[os](
        i.multiple ? r ? new Set(o) : o : o[0]
      ), i._assigning = !0, Wn(() => {
        i._assigning = !1;
      });
    }), i[os] = Mi(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(i, { value: e }) {
    lc(i, e);
  },
  beforeUpdate(i, e, n) {
    i[os] = Mi(n);
  },
  updated(i, { value: e }) {
    i._assigning || lc(i, e);
  }
};
function lc(i, e) {
  const n = i.multiple, s = Ye(e);
  if (!(n && !s && !Di(e))) {
    for (let r = 0, o = i.options.length; r < o; r++) {
      const a = i.options[r], l = wr(a);
      if (n)
        if (s) {
          const u = typeof l;
          u === "string" || u === "number" ? a.selected = e.some((c) => String(c) === String(l)) : a.selected = Hl(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (Ar(wr(a), e)) {
        i.selectedIndex !== r && (i.selectedIndex = r);
        return;
      }
    }
    !n && i.selectedIndex !== -1 && (i.selectedIndex = -1);
  }
}
function wr(i) {
  return "_value" in i ? i._value : i.value;
}
function Ah(i, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in i ? i[n] : e;
}
const Dg = ["ctrl", "shift", "alt", "meta"], Ag = {
  stop: (i) => i.stopPropagation(),
  prevent: (i) => i.preventDefault(),
  self: (i) => i.target !== i.currentTarget,
  ctrl: (i) => !i.ctrlKey,
  shift: (i) => !i.shiftKey,
  alt: (i) => !i.altKey,
  meta: (i) => !i.metaKey,
  left: (i) => "button" in i && i.button !== 0,
  middle: (i) => "button" in i && i.button !== 1,
  right: (i) => "button" in i && i.button !== 2,
  exact: (i, e) => Dg.some((n) => i[`${n}Key`] && !e.includes(n))
}, Je = (i, e) => {
  const n = i._withMods || (i._withMods = {}), s = e.join(".");
  return n[s] || (n[s] = (r, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = Ag[e[a]];
      if (l && l(r, e)) return;
    }
    return i(r, ...o);
  });
}, Ig = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, ru = (i, e) => {
  const n = i._withKeys || (i._withKeys = {}), s = e.join(".");
  return n[s] || (n[s] = (r) => {
    if (!("key" in r))
      return;
    const o = zs(r.key);
    if (e.some(
      (a) => a === o || Ig[a] === o
    ))
      return i(r);
  });
}, Fg = /* @__PURE__ */ Kt({ patchProp: Og }, pg);
let uc;
function Lg() {
  return uc || (uc = Ym(Fg));
}
const zg = (...i) => {
  const e = Lg().createApp(...i), { mount: n } = e;
  return e.mount = (s) => {
    const r = Vg(s);
    if (!r) return;
    const o = e._component;
    !et(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const a = n(r, !1, Rg(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), a;
  }, e;
};
function Rg(i) {
  if (i instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && i instanceof MathMLElement)
    return "mathml";
}
function Vg(i) {
  return Mt(i) ? document.querySelector(i) : i;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Ih;
const ka = (i) => Ih = i, Fh = (
  /* istanbul ignore next */
  Symbol()
);
function Tl(i) {
  return i && typeof i == "object" && Object.prototype.toString.call(i) === "[object Object]" && typeof i.toJSON != "function";
}
var lr;
(function(i) {
  i.direct = "direct", i.patchObject = "patch object", i.patchFunction = "patch function";
})(lr || (lr = {}));
function jg() {
  const i = Ad(!0), e = i.run(() => me({}));
  let n = [], s = [];
  const r = Zn({
    install(o) {
      ka(r), r._a = o, o.provide(Fh, r), o.config.globalProperties.$pinia = r, s.forEach((a) => n.push(a)), s = [];
    },
    use(o) {
      return this._a ? n.push(o) : s.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: i,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return r;
}
const Lh = () => {
};
function cc(i, e, n, s = Lh) {
  i.push(e);
  const r = () => {
    const o = i.indexOf(e);
    o > -1 && (i.splice(o, 1), s());
  };
  return !n && Id() && Sp(r), r;
}
function ri(i, ...e) {
  i.slice().forEach((n) => {
    n(...e);
  });
}
const $g = (i) => i(), dc = Symbol(), Ga = Symbol();
function Ml(i, e) {
  i instanceof Map && e instanceof Map ? e.forEach((n, s) => i.set(s, n)) : i instanceof Set && e instanceof Set && e.forEach(i.add, i);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const s = e[n], r = i[n];
    Tl(r) && Tl(s) && i.hasOwnProperty(n) && !Tt(s) && !rs(s) ? i[n] = Ml(r, s) : i[n] = s;
  }
  return i;
}
const Bg = (
  /* istanbul ignore next */
  Symbol()
);
function Wg(i) {
  return !Tl(i) || !i.hasOwnProperty(Bg);
}
const { assign: Ts } = Object;
function Ug(i) {
  return !!(Tt(i) && i.effect);
}
function Ng(i, e, n, s) {
  const { state: r, actions: o, getters: a } = e, l = n.state.value[i];
  let u;
  function c() {
    l || (n.state.value[i] = r ? r() : {});
    const d = Yp(n.state.value[i]);
    return Ts(d, o, Object.keys(a || {}).reduce((f, g) => (f[g] = Zn(Oe(() => {
      ka(n);
      const p = n._s.get(i);
      return a[g].call(p, p);
    })), f), {}));
  }
  return u = zh(i, c, e, n, s, !0), u;
}
function zh(i, e, n = {}, s, r, o) {
  let a;
  const l = Ts({ actions: {} }, n), u = { deep: !0 };
  let c, d, f = [], g = [], p;
  const y = s.state.value[i];
  !o && !y && (s.state.value[i] = {}), me({});
  let v;
  function m(O) {
    let F;
    c = d = !1, typeof O == "function" ? (O(s.state.value[i]), F = {
      type: lr.patchFunction,
      storeId: i,
      events: p
    }) : (Ml(s.state.value[i], O), F = {
      type: lr.patchObject,
      payload: O,
      storeId: i,
      events: p
    });
    const $ = v = Symbol();
    Wn().then(() => {
      v === $ && (c = !0);
    }), d = !0, ri(f, F, s.state.value[i]);
  }
  const b = o ? function() {
    const { state: F } = n, $ = F ? F() : {};
    this.$patch((ne) => {
      Ts(ne, $);
    });
  } : (
    /* istanbul ignore next */
    Lh
  );
  function S() {
    a.stop(), f = [], g = [], s._s.delete(i);
  }
  const x = (O, F = "") => {
    if (dc in O)
      return O[Ga] = F, O;
    const $ = function() {
      ka(s);
      const ne = Array.from(arguments), oe = [], z = [];
      function X(ge) {
        oe.push(ge);
      }
      function T(ge) {
        z.push(ge);
      }
      ri(g, {
        args: ne,
        name: $[Ga],
        store: C,
        after: X,
        onError: T
      });
      let H;
      try {
        H = O.apply(this && this.$id === i ? this : C, ne);
      } catch (ge) {
        throw ri(z, ge), ge;
      }
      return H instanceof Promise ? H.then((ge) => (ri(oe, ge), ge)).catch((ge) => (ri(z, ge), Promise.reject(ge))) : (ri(oe, H), H);
    };
    return $[dc] = !0, $[Ga] = F, $;
  }, _ = {
    _p: s,
    // _s: scope,
    $id: i,
    $onAction: cc.bind(null, g),
    $patch: m,
    $reset: b,
    $subscribe(O, F = {}) {
      const $ = cc(f, O, F.detached, () => ne()), ne = a.run(() => ut(() => s.state.value[i], (oe) => {
        (F.flush === "sync" ? d : c) && O({
          storeId: i,
          type: lr.direct,
          events: p
        }, oe);
      }, Ts({}, u, F)));
      return $;
    },
    $dispose: S
  }, C = Ai(_);
  s._s.set(i, C);
  const M = (s._a && s._a.runWithContext || $g)(() => s._e.run(() => (a = Ad()).run(() => e({ action: x }))));
  for (const O in M) {
    const F = M[O];
    if (Tt(F) && !Ug(F) || rs(F))
      o || (y && Wg(F) && (Tt(F) ? F.value = y[O] : Ml(F, y[O])), s.state.value[i][O] = F);
    else if (typeof F == "function") {
      const $ = x(F, O);
      M[O] = $, l.actions[O] = F;
    }
  }
  return Ts(C, M), Ts(lt(C), M), Object.defineProperty(C, "$state", {
    get: () => s.state.value[i],
    set: (O) => {
      m((F) => {
        Ts(F, O);
      });
    }
  }), s._p.forEach((O) => {
    Ts(C, a.run(() => O({
      store: C,
      app: s._a,
      pinia: s,
      options: l
    })));
  }), y && o && n.hydrate && n.hydrate(C.$state, y), c = !0, d = !0, C;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Hg(i, e, n) {
  let s, r;
  const o = typeof e == "function";
  s = i, r = o ? n : e;
  function a(l, u) {
    const c = Pm();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (c ? Tn(Fh, null) : null), l && ka(l), l = Ih, l._s.has(s) || (o ? zh(s, e, r, l) : Ng(s, r, l)), l._s.get(s);
  }
  return a.$id = s, a;
}
const Ka = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(i, { emit: e }) {
    const n = e, s = i, r = _m(), o = me([]), a = Oe(() => o.value.reduce((te, fe) => (te[~~fe.id] = fe) && te, {})), l = Oe(() => o.value.length), u = me(null), c = me(!1), d = me({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), f = me({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), g = Oe(() => ({
      [`splitpanes splitpanes--${s.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": d.value.dragging
    })), p = () => {
      document.addEventListener("mousemove", m, { passive: !1 }), document.addEventListener("mouseup", b), "ontouchstart" in window && (document.addEventListener("touchmove", m, { passive: !1 }), document.addEventListener("touchend", b));
    }, y = () => {
      document.removeEventListener("mousemove", m, { passive: !1 }), document.removeEventListener("mouseup", b), "ontouchstart" in window && (document.removeEventListener("touchmove", m, { passive: !1 }), document.removeEventListener("touchend", b));
    }, v = (te, fe) => {
      const ae = te.target.closest(".splitpanes__splitter");
      if (ae) {
        const { left: D, top: R } = ae.getBoundingClientRect(), { clientX: P, clientY: Y } = "ontouchstart" in window && te.touches ? te.touches[0] : te;
        d.value.cursorOffset = s.horizontal ? Y - R : P - D;
      }
      p(), d.value.mouseDown = !0, d.value.activeSplitter = fe;
    }, m = (te) => {
      d.value.mouseDown && (te.preventDefault(), d.value.dragging = !0, requestAnimationFrame(() => {
        M(C(te)), G("resize", { event: te }, !0);
      }));
    }, b = (te) => {
      d.value.dragging && (window.getSelection().removeAllRanges(), G("resized", { event: te }, !0)), d.value.mouseDown = !1, d.value.activeSplitter = null, setTimeout(() => {
        d.value.dragging = !1, y();
      }, 100);
    }, S = (te, fe) => {
      "ontouchstart" in window && (te.preventDefault(), f.value.splitter === fe ? (clearTimeout(f.value.timeoutId), f.value.timeoutId = null, x(te, fe), f.value.splitter = null) : (f.value.splitter = fe, f.value.timeoutId = setTimeout(() => f.value.splitter = null, 500))), d.value.dragging || G("splitter-click", { event: te, index: fe }, !0);
    }, x = (te, fe) => {
      if (G("splitter-dblclick", { event: te, index: fe }, !0), s.maximizePanes) {
        let ae = 0;
        o.value = o.value.map((D, R) => (D.size = R === fe ? D.max : D.min, R !== fe && (ae += D.min), D)), o.value[fe].size -= ae, G("pane-maximize", { event: te, index: fe, pane: o.value[fe] }), G("resized", { event: te, index: fe }, !0);
      }
    }, _ = (te, fe) => {
      G("pane-click", {
        event: te,
        index: a.value[fe].index,
        pane: a.value[fe]
      });
    }, C = (te) => {
      const fe = u.value.getBoundingClientRect(), { clientX: ae, clientY: D } = "ontouchstart" in window && te.touches ? te.touches[0] : te;
      return {
        x: ae - (s.horizontal ? 0 : d.value.cursorOffset) - fe.left,
        y: D - (s.horizontal ? d.value.cursorOffset : 0) - fe.top
      };
    }, k = (te) => {
      te = te[s.horizontal ? "y" : "x"];
      const fe = u.value[s.horizontal ? "clientHeight" : "clientWidth"];
      return s.rtl && !s.horizontal && (te = fe - te), te * 100 / fe;
    }, M = (te) => {
      const fe = d.value.activeSplitter;
      let ae = {
        prevPanesSize: F(fe),
        nextPanesSize: $(fe),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const D = 0 + (s.pushOtherPanes ? 0 : ae.prevPanesSize), R = 100 - (s.pushOtherPanes ? 0 : ae.nextPanesSize), P = Math.max(Math.min(k(te), R), D);
      let Y = [fe, fe + 1], U = o.value[Y[0]] || null, w = o.value[Y[1]] || null;
      const L = U.max < 100 && P >= U.max + ae.prevPanesSize, A = w.max < 100 && P <= 100 - (w.max + $(fe + 1));
      if (L || A) {
        L ? (U.size = U.max, w.size = Math.max(100 - U.max - ae.prevPanesSize - ae.nextPanesSize, 0)) : (U.size = Math.max(100 - w.max - ae.prevPanesSize - $(fe + 1), 0), w.size = w.max);
        return;
      }
      if (s.pushOtherPanes) {
        const E = O(ae, P);
        if (!E) return;
        ({ sums: ae, panesToResize: Y } = E), U = o.value[Y[0]] || null, w = o.value[Y[1]] || null;
      }
      U !== null && (U.size = Math.min(Math.max(P - ae.prevPanesSize - ae.prevReachedMinPanes, U.min), U.max)), w !== null && (w.size = Math.min(Math.max(100 - P - ae.nextPanesSize - ae.nextReachedMinPanes, w.min), w.max));
    }, O = (te, fe) => {
      const ae = d.value.activeSplitter, D = [ae, ae + 1];
      return fe < te.prevPanesSize + o.value[D[0]].min && (D[0] = ne(ae).index, te.prevReachedMinPanes = 0, D[0] < ae && o.value.forEach((R, P) => {
        P > D[0] && P <= ae && (R.size = R.min, te.prevReachedMinPanes += R.min);
      }), te.prevPanesSize = F(D[0]), D[0] === void 0) ? (te.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((R, P) => {
        P > 0 && P <= ae && (R.size = R.min, te.prevReachedMinPanes += R.min);
      }), o.value[D[1]].size = 100 - te.prevReachedMinPanes - o.value[0].min - te.prevPanesSize - te.nextPanesSize, null) : fe > 100 - te.nextPanesSize - o.value[D[1]].min && (D[1] = oe(ae).index, te.nextReachedMinPanes = 0, D[1] > ae + 1 && o.value.forEach((R, P) => {
        P > ae && P < D[1] && (R.size = R.min, te.nextReachedMinPanes += R.min);
      }), te.nextPanesSize = $(D[1] - 1), D[1] === void 0) ? (te.nextReachedMinPanes = 0, o.value.forEach((R, P) => {
        P < l.value - 1 && P >= ae + 1 && (R.size = R.min, te.nextReachedMinPanes += R.min);
      }), o.value[D[0]].size = 100 - te.prevPanesSize - $(D[0] - 1), null) : { sums: te, panesToResize: D };
    }, F = (te) => o.value.reduce((fe, ae, D) => fe + (D < te ? ae.size : 0), 0), $ = (te) => o.value.reduce((fe, ae, D) => fe + (D > te + 1 ? ae.size : 0), 0), ne = (te) => [...o.value].reverse().find((fe) => fe.index < te && fe.size > fe.min) || {}, oe = (te) => o.value.find((fe) => fe.index > te + 1 && fe.size > fe.min) || {}, z = () => {
      var te;
      const fe = Array.from(((te = u.value) == null ? void 0 : te.children) || []);
      for (const ae of fe) {
        const D = ae.classList.contains("splitpanes__pane"), R = ae.classList.contains("splitpanes__splitter");
        !D && !R && (ae.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, X = (te, fe, ae = !1) => {
      const D = te - 1, R = document.createElement("div");
      R.classList.add("splitpanes__splitter"), ae || (R.onmousedown = (P) => v(P, D), typeof window < "u" && "ontouchstart" in window && (R.ontouchstart = (P) => v(P, D)), R.onclick = (P) => S(P, D + 1)), R.ondblclick = (P) => x(P, D + 1), fe.parentNode.insertBefore(R, fe);
    }, T = (te) => {
      te.onmousedown = void 0, te.onclick = void 0, te.ondblclick = void 0, te.remove();
    }, H = () => {
      var te;
      const fe = Array.from(((te = u.value) == null ? void 0 : te.children) || []);
      for (const D of fe)
        D.className.includes("splitpanes__splitter") && T(D);
      let ae = 0;
      for (const D of fe)
        D.className.includes("splitpanes__pane") && (!ae && s.firstSplitter ? X(ae, D, !0) : ae && X(ae, D), ae++);
    }, ge = ({ uid: te, ...fe }) => {
      const ae = a.value[te];
      for (const [D, R] of Object.entries(fe)) ae[D] = R;
    }, K = (te) => {
      var fe;
      let ae = -1;
      Array.from(((fe = u.value) == null ? void 0 : fe.children) || []).some((D) => (D.className.includes("splitpanes__pane") && ae++, D.isSameNode(te.el))), o.value.splice(ae, 0, { ...te, index: ae }), o.value.forEach((D, R) => D.index = R), c.value && Wn(() => {
        H(), ie({ addedPane: o.value[ae] }), G("pane-add", { pane: o.value[ae] });
      });
    }, re = (te) => {
      const fe = o.value.findIndex((D) => D.id === te);
      o.value[fe].el = null;
      const ae = o.value.splice(fe, 1)[0];
      o.value.forEach((D, R) => D.index = R), Wn(() => {
        H(), G("pane-remove", { pane: ae }), ie({ removedPane: { ...ae } });
      });
    }, ie = (te = {}) => {
      !te.addedPane && !te.removedPane ? J() : o.value.some((fe) => fe.givenSize !== null || fe.min || fe.max < 100) ? ee(te) : be(), c.value && G("resized");
    }, be = () => {
      const te = 100 / l.value;
      let fe = 0;
      const ae = [], D = [];
      for (const R of o.value)
        R.size = Math.max(Math.min(te, R.max), R.min), fe -= R.size, R.size >= R.max && ae.push(R.id), R.size <= R.min && D.push(R.id);
      fe > 0.1 && ve(fe, ae, D);
    }, J = () => {
      let te = 100;
      const fe = [], ae = [];
      let D = 0;
      for (const P of o.value)
        te -= P.size, P.givenSize !== null && D++, P.size >= P.max && fe.push(P.id), P.size <= P.min && ae.push(P.id);
      let R = 100;
      if (te > 0.1) {
        for (const P of o.value)
          P.givenSize === null && (P.size = Math.max(Math.min(te / (l.value - D), P.max), P.min)), R -= P.size;
        R > 0.1 && ve(R, fe, ae);
      }
    }, ee = ({ addedPane: te, removedPane: fe } = {}) => {
      let ae = 100 / l.value, D = 0;
      const R = [], P = [];
      ((te == null ? void 0 : te.givenSize) ?? null) !== null && (ae = (100 - te.givenSize) / (l.value - 1));
      for (const Y of o.value)
        D -= Y.size, Y.size >= Y.max && R.push(Y.id), Y.size <= Y.min && P.push(Y.id);
      if (!(Math.abs(D) < 0.1)) {
        for (const Y of o.value)
          (te == null ? void 0 : te.givenSize) !== null && (te == null ? void 0 : te.id) === Y.id || (Y.size = Math.max(Math.min(ae, Y.max), Y.min)), D -= Y.size, Y.size >= Y.max && R.push(Y.id), Y.size <= Y.min && P.push(Y.id);
        D > 0.1 && ve(D, R, P);
      }
    }, ve = (te, fe, ae) => {
      let D;
      te > 0 ? D = te / (l.value - fe.length) : D = te / (l.value - ae.length), o.value.forEach((R, P) => {
        if (te > 0 && !fe.includes(R.id)) {
          const Y = Math.max(Math.min(R.size + D, R.max), R.min), U = Y - R.size;
          te -= U, R.size = Y;
        } else if (!ae.includes(R.id)) {
          const Y = Math.max(Math.min(R.size + D, R.max), R.min), U = Y - R.size;
          te -= U, R.size = Y;
        }
      }), Math.abs(te) > 0.1 && Wn(() => {
        c.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, G = (te, fe = void 0, ae = !1) => {
      const D = (fe == null ? void 0 : fe.index) ?? d.value.activeSplitter ?? null;
      n(te, {
        ...fe,
        ...D !== null && { index: D },
        ...ae && D !== null && {
          prevPane: o.value[D - (s.firstSplitter ? 1 : 0)],
          nextPane: o.value[D + (s.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((R) => ({ min: R.min, max: R.max, size: R.size }))
      });
    };
    ut(() => s.firstSplitter, () => H()), Rt(() => {
      z(), H(), ie(), G("ready"), c.value = !0;
    }), eu(() => c.value = !1);
    const N = () => {
      var te;
      return cg(
        "div",
        { ref: u, class: g.value },
        (te = r.default) == null ? void 0 : te.call(r)
      );
    };
    return ks("panes", o), ks("indexedPanes", a), ks("horizontal", Oe(() => s.horizontal)), ks("requestUpdate", ge), ks("onPaneAdd", K), ks("onPaneRemove", re), ks("onPaneClick", _), (te, fe) => (V(), ot(ah(N)));
  }
}, Bs = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(i) {
    var e;
    const n = i, s = Tn("requestUpdate"), r = Tn("onPaneAdd"), o = Tn("horizontal"), a = Tn("onPaneRemove"), l = Tn("onPaneClick"), u = (e = Sa()) == null ? void 0 : e.uid, c = Tn("indexedPanes"), d = Oe(() => c.value[u]), f = me(null), g = Oe(() => {
      const m = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(m, y.value), p.value);
    }), p = Oe(() => {
      const m = parseFloat(n.minSize);
      return isNaN(m) ? 0 : m;
    }), y = Oe(() => {
      const m = parseFloat(n.maxSize);
      return isNaN(m) ? 100 : m;
    }), v = Oe(() => {
      var m;
      return `${o.value ? "height" : "width"}: ${(m = d.value) == null ? void 0 : m.size}%`;
    });
    return ut(() => g.value, (m) => s({ uid: u, size: m })), ut(() => p.value, (m) => s({ uid: u, min: m })), ut(() => y.value, (m) => s({ uid: u, max: m })), Rt(() => {
      r({
        id: u,
        el: f.value,
        min: p.value,
        max: y.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : g.value,
        size: g.value
        // The computed current size at any time.
      });
    }), eu(() => a(u)), (m, b) => (V(), B("div", {
      ref_key: "paneEl",
      ref: f,
      class: "splitpanes__pane",
      onClick: b[0] || (b[0] = (S) => Fe(l)(S, m._.uid)),
      style: Xe(v.value)
    }, [
      bm(m.$slots, "default")
    ], 4));
  }
}, Xg = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function Rh(i, e, n) {
  const s = e / 2, r = n / 2;
  return {
    id: i,
    name: "Camera 1",
    type: "two-node",
    position: { x: s, y: r, z: -1500 },
    pointOfInterest: { x: s, y: r, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function Vh() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function Yg() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function Ho(i, e, n) {
  const s = Math.max(0, Math.min(n, i.frameCount - 1));
  switch (e) {
    case "amplitude":
      return i.amplitudeEnvelope[s] ?? 0;
    case "rms":
      return i.rmsEnergy[s] ?? 0;
    case "spectralCentroid":
      return i.spectralCentroid[s] ?? 0;
    case "sub":
      return i.frequencyBands.sub[s] ?? 0;
    case "bass":
      return i.frequencyBands.bass[s] ?? 0;
    case "lowMid":
      return i.frequencyBands.lowMid[s] ?? 0;
    case "mid":
      return i.frequencyBands.mid[s] ?? 0;
    case "highMid":
      return i.frequencyBands.highMid[s] ?? 0;
    case "high":
      return i.frequencyBands.high[s] ?? 0;
    case "onsets":
      return i.onsets.includes(s) ? 1 : 0;
    default:
      return 0;
  }
}
function jh(i, e) {
  const { threshold: n, minPeaksDistance: s, multiply: r } = e, o = i.map((d) => Math.min(1, d * r)), a = [];
  for (let d = 1; d < o.length - 1; d++) {
    const f = o[d - 1], g = o[d], p = o[d + 1];
    g > f && g > p && g >= n && a.push({ index: d, value: g });
  }
  const l = [];
  for (const d of a) {
    const f = l.findIndex(
      (g) => Math.abs(g.index - d.index) < s
    );
    f === -1 ? l.push(d) : d.value > l[f].value && (l[f] = d);
  }
  l.sort((d, f) => d.index - f.index);
  const u = new Array(i.length).fill(0);
  let c = 0;
  for (let d = 0; d < i.length; d++)
    l.some((g) => g.index === d) && (c = 1 - c), u[d] = c;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: u
  };
}
function hc(i, e) {
  return i.onsets.includes(e);
}
function Gg(i, e) {
  return i.indices.includes(e);
}
let Hs = null, Sr = null, di = null, Xo = null;
function Kg() {
  return Hs || (Hs = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), Hs.onmessage = (i) => {
    const e = i.data;
    switch (e.type) {
      case "progress":
        Xo && Xo({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        Sr && (Sr(e.payload), qa());
        break;
      case "error":
        di && (di(new Error(e.payload.message)), qa());
        break;
    }
  }, Hs.onerror = (i) => {
    console.error("[AudioWorker] Worker error:", i), di && (di(new Error(`Worker error: ${i.message}`)), qa());
  }), Hs;
}
function qa() {
  Sr = null, di = null, Xo = null;
}
function qg() {
  Hs && Hs.postMessage({ type: "cancel" });
}
async function Zg(i, e, n = {}) {
  const s = Kg();
  if (Sr)
    throw new Error("Analysis already in progress. Cancel it first.");
  const r = i.getChannelData(0), o = new Float32Array(r);
  return new Promise((a, l) => {
    Sr = a, di = l, Xo = n.onProgress || null, s.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: o,
          sampleRate: i.sampleRate,
          fps: e
        }
      },
      [o.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function Jg(i, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const s = await i.arrayBuffer(), r = new AudioContext();
  let o;
  try {
    o = await r.decodeAudioData(s);
  } finally {
    await r.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const a = await Zg(o, e, n);
  return { buffer: o, analysis: a };
}
function gt(i, e, n = "number", s) {
  return {
    id: `prop_${i}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: i,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: s
  };
}
function fc() {
  return {
    position: gt("position", { x: 0, y: 0 }, "position"),
    anchorPoint: gt("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: gt("scale", { x: 100, y: 100 }, "position"),
    rotation: gt("rotation", 0, "number")
  };
}
function Qg(i, e) {
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    composition: {
      width: i,
      height: e,
      frameCount: 81,
      fps: 16,
      duration: 81 / 16,
      backgroundColor: "#000000"
    },
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
const ur = Math.PI, Yo = 1.70158, Xr = Yo * 1.525, pc = Yo + 1, mc = 2 * ur / 3, gc = 2 * ur / 4.5, ei = {
  // Linear - no easing
  linear: (i) => i,
  // Sine easing
  easeInSine: (i) => 1 - Math.cos(i * ur / 2),
  easeOutSine: (i) => Math.sin(i * ur / 2),
  easeInOutSine: (i) => -(Math.cos(ur * i) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (i) => i * i,
  easeOutQuad: (i) => 1 - (1 - i) * (1 - i),
  easeInOutQuad: (i) => i < 0.5 ? 2 * i * i : 1 - Math.pow(-2 * i + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (i) => i * i * i,
  easeOutCubic: (i) => 1 - Math.pow(1 - i, 3),
  easeInOutCubic: (i) => i < 0.5 ? 4 * i * i * i : 1 - Math.pow(-2 * i + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (i) => i * i * i * i,
  easeOutQuart: (i) => 1 - Math.pow(1 - i, 4),
  easeInOutQuart: (i) => i < 0.5 ? 8 * i * i * i * i : 1 - Math.pow(-2 * i + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (i) => i * i * i * i * i,
  easeOutQuint: (i) => 1 - Math.pow(1 - i, 5),
  easeInOutQuint: (i) => i < 0.5 ? 16 * i * i * i * i * i : 1 - Math.pow(-2 * i + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (i) => i === 0 ? 0 : Math.pow(2, 10 * i - 10),
  easeOutExpo: (i) => i === 1 ? 1 : 1 - Math.pow(2, -10 * i),
  easeInOutExpo: (i) => i === 0 ? 0 : i === 1 ? 1 : i < 0.5 ? Math.pow(2, 20 * i - 10) / 2 : (2 - Math.pow(2, -20 * i + 10)) / 2,
  // Circ (circular)
  easeInCirc: (i) => 1 - Math.sqrt(1 - Math.pow(i, 2)),
  easeOutCirc: (i) => Math.sqrt(1 - Math.pow(i - 1, 2)),
  easeInOutCirc: (i) => i < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * i, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * i + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (i) => pc * i * i * i - Yo * i * i,
  easeOutBack: (i) => 1 + pc * Math.pow(i - 1, 3) + Yo * Math.pow(i - 1, 2),
  easeInOutBack: (i) => i < 0.5 ? Math.pow(2 * i, 2) * ((Xr + 1) * 2 * i - Xr) / 2 : (Math.pow(2 * i - 2, 2) * ((Xr + 1) * (i * 2 - 2) + Xr) + 2) / 2,
  // Elastic
  easeInElastic: (i) => i === 0 ? 0 : i === 1 ? 1 : -Math.pow(2, 10 * i - 10) * Math.sin((i * 10 - 10.75) * mc),
  easeOutElastic: (i) => i === 0 ? 0 : i === 1 ? 1 : Math.pow(2, -10 * i) * Math.sin((i * 10 - 0.75) * mc) + 1,
  easeInOutElastic: (i) => i === 0 ? 0 : i === 1 ? 1 : i < 0.5 ? -(Math.pow(2, 20 * i - 10) * Math.sin((20 * i - 11.125) * gc)) / 2 : Math.pow(2, -20 * i + 10) * Math.sin((20 * i - 11.125) * gc) / 2 + 1,
  // Bounce
  easeOutBounce: (i) => i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375,
  easeInBounce: (i) => 1 - ei.easeOutBounce(1 - i),
  easeInOutBounce: (i) => i < 0.5 ? (1 - ei.easeOutBounce(1 - 2 * i)) / 2 : (1 + ei.easeOutBounce(2 * i - 1)) / 2
};
function ev(i) {
  return i in ei ? ei[i] : ei.linear;
}
function tv(i, e) {
  if (typeof i == "number" && typeof e == "number")
    return e - i;
  if (typeof i == "object" && i !== null && "x" in i && "y" in i && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - i.x, s = e.y - i.y;
    return Math.sqrt(n * n + s * s) || 1;
  }
  return 1;
}
function ns(i, e) {
  if (!i.animated || i.keyframes.length === 0)
    return i.value;
  const n = i.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  let s = n[0], r = n[1];
  for (let c = 0; c < n.length - 1; c++)
    if (e >= n[c].frame && e <= n[c + 1].frame) {
      s = n[c], r = n[c + 1];
      break;
    }
  const o = r.frame - s.frame, a = e - s.frame;
  let l = o > 0 ? a / o : 0;
  const u = s.interpolation || "linear";
  if (u === "hold")
    return s.value;
  if (u === "bezier") {
    const c = tv(s.value, r.value);
    l = nv(l, s.outHandle, r.inHandle, o, c);
  } else u === "linear" || (u in ei ? l = ev(u)(l) : console.warn(`Unknown interpolation type: ${u}, using linear`));
  return iv(s.value, r.value, l);
}
function nv(i, e, n, s = 1, r = 1) {
  if (!e.enabled && !n.enabled)
    return i;
  const o = s > 0 ? Math.abs(e.frame) / s : 0.33, a = r !== 0 ? e.value / r : 0.33, l = s > 0 ? 1 - Math.abs(n.frame) / s : 0.67, u = r !== 0 ? 1 - n.value / r : 0.67;
  let c = i;
  for (let d = 0; d < 8; d++) {
    const f = Go(c, 0, o, l, 1), g = sv(c, 0, o, l, 1);
    if (Math.abs(g) < 1e-6) break;
    const p = f - i;
    c -= p / g, c = Math.max(0, Math.min(1, c));
  }
  return Go(c, 0, a, u, 1);
}
function Go(i, e, n, s, r) {
  const o = 1 - i;
  return o * o * o * e + 3 * o * o * i * n + 3 * o * i * i * s + i * i * i * r;
}
function sv(i, e, n, s, r) {
  const o = 1 - i;
  return 3 * o * o * (n - e) + 6 * o * i * (s - n) + 3 * i * i * (r - s);
}
function iv(i, e, n) {
  if (typeof i == "number" && typeof e == "number")
    return i + (e - i) * n;
  if (typeof i == "object" && i !== null && typeof e == "object" && e !== null && "x" in i && "y" in i && "x" in e && "y" in e) {
    const s = i, r = e, o = {
      x: s.x + (r.x - s.x) * n,
      y: s.y + (r.y - s.y) * n
    };
    return "z" in s && "z" in r ? o.z = s.z + (r.z - s.z) * n : "z" in s ? o.z = s.z * (1 - n) : "z" in r && (o.z = r.z * n), o;
  }
  return typeof i == "string" && typeof e == "string" && i.startsWith("#") && e.startsWith("#") ? rv(i, e, n) : n < 0.5 ? i : e;
}
function rv(i, e, n) {
  const s = parseInt(i.slice(1, 3), 16), r = parseInt(i.slice(3, 5), 16), o = parseInt(i.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), u = parseInt(e.slice(5, 7), 16), c = Math.round(s + (a - s) * n), d = Math.round(r + (l - r) * n), f = Math.round(o + (u - o) * n);
  return `#${c.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${f.toString(16).padStart(2, "0")}`;
}
const ov = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, Ko = ov;
function av(i, e, n) {
  const s = e.x, r = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: Go(i, 0, s, o, 1),
    y: Go(i, 0, r, a, 1)
  };
}
function lv(i, e) {
  const n = Math.max(0, Math.min(1, i));
  return av(n, e.outHandle, e.inHandle).y;
}
function uv(i, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: i || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0
  };
}
class cv {
  constructor(e) {
    He(this, "analysis");
    He(this, "mappings", /* @__PURE__ */ new Map());
    He(this, "smoothedValues", /* @__PURE__ */ new Map());
    He(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const s = this.mappings.get(e);
    s && Object.assign(s, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && Gg(this.peakData, n) ? 1 : 0 : Ho(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const s = this.mappings.get(e);
    if (!s || !s.enabled) return 0;
    let r = this.getFeatureAtFrame(s.feature, n);
    r < s.threshold && (r = 0), s.invert && (r = 1 - r), r *= s.sensitivity, r += s.offset, r = Math.max(s.min, Math.min(s.max, r));
    const a = (this.smoothedValues.get(e) || 0) * s.smoothing + r * (1 - s.smoothing);
    return this.smoothedValues.set(e, a), a;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const s of this.mappings.values()) {
      if (!s.enabled) continue;
      const r = this.getValueAtFrame(s.id, e), o = n.get(s.target);
      o !== void 0 ? n.set(s.target, o + r) : n.set(s.target, r);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const s = /* @__PURE__ */ new Map();
    for (const r of this.mappings.values()) {
      if (!r.enabled || r.targetLayerId && r.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(r.id, n), a = s.get(r.target);
      a !== void 0 ? s.set(r.target, a + o) : s.set(r.target, o);
    }
    return s;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function Za(i) {
  return {
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    onsets: "Beat Onsets",
    peaks: "Detected Peaks"
  }[i] || i;
}
function vc(i) {
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[i] || i;
}
function dv() {
  return [
    "amplitude",
    "rms",
    "spectralCentroid",
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    "onsets",
    "peaks"
  ];
}
function hv() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
  };
}
const fv = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class pv {
  // For amplitude mode release tracking
  constructor(e = {}) {
    He(this, "config");
    He(this, "state");
    He(this, "pathSegments", []);
    He(this, "totalLength", 0);
    He(this, "releaseState", 0);
    this.config = { ...fv, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], s = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let r = 0, o = 0;
    for (const a of s) {
      const l = a[0].toUpperCase(), u = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((c) => !isNaN(c));
      switch (l) {
        case "M":
          r = u[0] || 0, o = u[1] || 0, n.push({
            type: "M",
            points: [r, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [r, o, u[0], u[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = u[0], o = u[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [r, o, u[0], u[1], u[2], u[3], u[4], u[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = u[4], o = u[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [r, o, u[0], u[1], u[2], u[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = u[2], o = u[3];
          break;
        case "Z":
          const c = n.find((d) => d.type === "M");
          c && n.push({
            type: "L",
            points: [r, o, c.points[0], c.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], s = e[3] - e[1];
    return Math.sqrt(n * n + s * s);
  }
  bezierLength(e, n) {
    let r = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const u = l / 20, { x: c, y: d } = this.getBezierPoint(e, u, n), f = c - o, g = d - a;
      r += Math.sqrt(f * f + g * g), o = c, a = d;
    }
    return r;
  }
  getBezierPoint(e, n, s) {
    if (s === 2) {
      const r = 1 - n;
      return {
        x: r * r * e[0] + 2 * r * n * e[2] + n * n * e[4],
        y: r * r * e[1] + 2 * r * n * e[3] + n * n * e[5]
      };
    } else {
      const r = 1 - n, o = r * r, a = n * n;
      return {
        x: o * r * e[0] + 3 * o * n * e[2] + 3 * r * a * e[4] + a * n * e[6],
        y: o * r * e[1] + 3 * o * n * e[3] + 3 * r * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const s = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = s, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(s) : this.updateAccumulateMode(s, n);
    const r = this.getPositionOnPath(this.state.position);
    return this.state.x = r.x, this.state.y = r.y, this.state.angle = r.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const r = 1 - this.config.release * 0.95;
      this.releaseState *= r;
    }
    const s = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, s * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const s = e * this.config.sensitivity * 0.02 * this.state.direction;
    let r = this.state.position + s;
    r > 1 ? (r = 2 - r, this.state.direction = -1) : r < 0 && (r = -r, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, r));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const c of this.pathSegments)
      if (c.type !== "M" && e >= c.startT && e <= c.endT) {
        n = c;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const s = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let r, o, a, l;
    switch (n.type) {
      case "L":
        r = n.points[0] + (n.points[2] - n.points[0]) * s, o = n.points[1] + (n.points[3] - n.points[1]) * s, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const c = this.getBezierPoint(n.points, s, 2);
        r = c.x, o = c.y;
        const d = 1 - s;
        a = 2 * d * (n.points[2] - n.points[0]) + 2 * s * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * s * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const c = this.getBezierPoint(n.points, s, 3);
        r = c.x, o = c.y;
        const d = 1 - s, f = d * d, g = s * s;
        a = 3 * f * (n.points[2] - n.points[0]) + 6 * d * s * (n.points[4] - n.points[2]) + 3 * g * (n.points[6] - n.points[4]), l = 3 * f * (n.points[3] - n.points[1]) + 6 * d * s * (n.points[5] - n.points[3]) + 3 * g * (n.points[7] - n.points[5]);
        break;
      }
      default:
        r = 0, o = 0, a = 1, l = 0;
    }
    const u = Math.atan2(l, a);
    return { x: r, y: o, angle: u };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], s = this.state.previousPosition, r = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = s + (r - s) * (o / e), l = this.getPositionOnPath(a), u = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: u });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function mv(i) {
  switch (i) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const Cr = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Ol = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function gv(i) {
  const e = Cr[i];
  return e ? {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: e.parameters.map((n, s) => ({
      ...n,
      id: `param-${s}`,
      value: n.defaultValue
    })),
    fragmentShader: e.fragmentShader
  } : null;
}
function vv(i) {
  const e = Cr[i];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((s, r) => {
    const o = s.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[o] = {
      id: `${i}-${o}-${r}`,
      name: s.name,
      type: mv(s.type),
      value: s.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: i,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const yv = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
], Ot = /* @__PURE__ */ Hg("compositor", {
  state: () => ({
    project: Qg(1024, 1024),
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: Vh(),
    viewOptions: Yg()
  }),
  getters: {
    // Project info
    hasProject: (i) => i.sourceImage !== null,
    width: (i) => i.project.composition.width,
    height: (i) => i.project.composition.height,
    frameCount: (i) => i.project.composition.frameCount,
    fps: (i) => i.project.composition.fps,
    duration: (i) => i.project.composition.duration,
    // Current frame
    currentFrame: (i) => i.project.currentFrame,
    currentTime: (i) => i.project.currentFrame / i.project.composition.fps,
    // Layers
    layers: (i) => i.project.layers,
    visibleLayers: (i) => i.project.layers.filter((e) => e.visible),
    // Selection
    selectedLayers: (i) => i.project.layers.filter((e) => i.selectedLayerIds.includes(e.id)),
    selectedLayer: (i) => i.selectedLayerIds.length !== 1 ? null : i.project.layers.find((e) => e.id === i.selectedLayerIds[0]) || null,
    // Assets
    assets: (i) => i.project.assets,
    // History
    canUndo: (i) => i.historyIndex > 0,
    canRedo: (i) => i.historyIndex < i.historyStack.length - 1,
    // Camera
    activeCamera: (i) => i.activeCameraId && i.cameras.get(i.activeCameraId) || null,
    allCameras: (i) => Array.from(i.cameras.values()),
    cameraLayers: (i) => i.project.layers.filter((e) => e.type === "camera")
  },
  actions: {
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(i) {
      this.comfyuiNodeId = i.node_id, this.sourceImage = i.source_image, this.depthMap = i.depth_map, this.project.composition.width = i.width, this.project.composition.height = i.height, this.project.composition.frameCount = i.frame_count, this.project.composition.duration = i.frame_count / this.project.composition.fps, i.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: i.node_id,
        width: i.width,
        height: i.height,
        data: i.source_image
      }), i.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: i.node_id,
        width: i.width,
        height: i.height,
        data: i.depth_map
      }), this.project.currentFrame = 0, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[Weyl] Loaded inputs from ComfyUI:", {
        width: i.width,
        height: i.height,
        frameCount: i.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(i, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let s = null;
      switch (i) {
        case "text":
          s = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 48,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          s = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          s = {
            size: 40
          };
          break;
        case "spline":
          s = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          s = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          s = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          s = {
            lightType: "point",
            color: "#ffffff",
            intensity: 1,
            radius: 500,
            falloff: "quadratic",
            castShadows: !1
          };
          break;
        case "camera":
          s = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          s = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          s = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let r;
      (i === "video" || i === "audio") && (r = {
        level: gt("Audio Levels", 0, "number")
        // 0dB default
      });
      const o = {
        id: n,
        name: e || `${i.charAt(0).toUpperCase() + i.slice(1)} ${this.project.layers.length + 1}`,
        type: i,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        parentId: null,
        blendMode: "normal",
        opacity: gt("opacity", 100, "number"),
        transform: fc(),
        audio: r,
        properties: [],
        effects: [],
        data: s
      };
      return i === "camera" && console.warn("Use createCameraLayer() for camera layers"), this.project.layers.unshift(o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), o;
    },
    /**
     * Delete a layer
     */
    deleteLayer(i) {
      const e = this.project.layers.findIndex((n) => n.id === i);
      e !== -1 && (this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((n) => n !== i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update layer properties
     */
    updateLayer(i, e) {
      const n = this.project.layers.find((s) => s.id === i);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(i) {
      const e = this.project.layers.find((n) => n.id === i);
      e && (e.threeD = !e.threeD, e.threeD ? (e.transform.position.value.z === void 0 && (e.transform.position.value = { ...e.transform.position.value, z: 0 }), e.transform.anchorPoint.value.z === void 0 && (e.transform.anchorPoint.value = { ...e.transform.anchorPoint.value, z: 0 }), e.transform.scale.value.z === void 0 && (e.transform.scale.value = { ...e.transform.scale.value, z: 100 }), e.transform.orientation || (e.transform.orientation = gt("orientation", { x: 0, y: 0, z: 0 }, "vector3")), e.transform.rotationX || (e.transform.rotationX = gt("rotationX", 0, "number")), e.transform.rotationY || (e.transform.rotationY = gt("rotationY", 0, "number")), e.transform.rotationZ || (e.transform.rotationZ = gt("rotationZ", 0, "number"), e.transform.rotationZ.value = e.transform.rotation.value)) : e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder layers
     */
    moveLayer(i, e) {
      const n = this.project.layers.findIndex((r) => r.id === i);
      if (n === -1) return;
      const [s] = this.project.layers.splice(n, 1);
      this.project.layers.splice(e, 0, s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(i, e = !1) {
      e ? this.selectedLayerIds.includes(i) || this.selectedLayerIds.push(i) : this.selectedLayerIds = [i];
    },
    deselectLayer(i) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== i);
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [];
    },
    /**
     * Playback controls
     */
    play() {
      this.isPlaying || (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = this.project.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const i = performance.now() - (this.playbackStartTime || 0), e = this.project.composition.fps, n = this.project.composition.frameCount, s = Math.floor(i / 1e3 * e);
      let r = this.playbackStartFrame + s;
      r >= n && (r = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), this.project.currentFrame = r, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(i) {
      this.project.currentFrame = Math.max(0, Math.min(i, this.project.composition.frameCount - 1));
    },
    nextFrame() {
      this.project.currentFrame < this.project.composition.frameCount - 1 && this.project.currentFrame++;
    },
    prevFrame() {
      this.project.currentFrame > 0 && this.project.currentFrame--;
    },
    goToStart() {
      this.project.currentFrame = 0;
    },
    goToEnd() {
      this.project.currentFrame = this.project.composition.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(i) {
      this.currentTool = i;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const i = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(i), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(i) {
      try {
        const e = JSON.parse(i);
        this.project = e, this.pushHistory();
      } catch (e) {
        console.error("[Weyl] Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(i) {
      return ns(i, this.project.currentFrame);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(i, e, n) {
      console.log("[Store] addKeyframe called:", { layerId: i, propertyName: e, value: n, frame: this.project.currentFrame });
      const s = this.project.layers.find((l) => l.id === i);
      if (!s)
        return console.log("[Store] addKeyframe: layer not found"), null;
      let r;
      if (e === "position" || e === "transform.position" ? r = s.transform.position : e === "scale" || e === "transform.scale" ? r = s.transform.scale : e === "rotation" || e === "transform.rotation" ? r = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = s.transform.anchorPoint : e === "opacity" ? r = s.opacity : r = s.properties.find((l) => l.name === e), !r)
        return console.log("[Store] addKeyframe: property not found:", e), null;
      r.animated = !0;
      const o = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: this.project.currentFrame,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, a = r.keyframes.findIndex((l) => l.frame === this.project.currentFrame);
      return a >= 0 ? (r.keyframes[a] = o, console.log("[Store] addKeyframe: replaced existing keyframe at frame", this.project.currentFrame)) : (r.keyframes.push(o), r.keyframes.sort((l, u) => l.frame - u.frame), console.log("[Store] addKeyframe: added new keyframe at frame", this.project.currentFrame, "total keyframes:", r.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), o;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(i, e, n) {
      const s = this.project.layers.find((a) => a.id === i);
      if (!s) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = s.transform.position : e === "scale" || e === "transform.scale" ? r = s.transform.scale : e === "rotation" || e === "transform.rotation" ? r = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = s.transform.anchorPoint : e === "opacity" ? r = s.opacity : r = s.properties.find((a) => a.name === e), !r) return;
      const o = r.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (r.keyframes.splice(o, 1), r.keyframes.length === 0 && (r.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(i, e, n) {
      const s = this.project.layers.find((o) => o.id === i);
      if (!s) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = s.transform.position : e === "scale" || e === "transform.scale" ? r = s.transform.scale : e === "rotation" || e === "transform.rotation" ? r = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = s.transform.anchorPoint : e === "opacity" ? r = s.opacity : r = s.properties.find((o) => o.name === e), !!r) {
        if (r.value = n, r.animated && r.keyframes.length > 0) {
          const o = r.keyframes.find((a) => a.frame === this.project.currentFrame);
          o && (o.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(i, e, n) {
      const s = this.project.layers.find((o) => o.id === i);
      if (!s) return;
      let r;
      e === "position" || e === "transform.position" ? r = s.transform.position : e === "scale" || e === "transform.scale" ? r = s.transform.scale : e === "rotation" || e === "transform.rotation" ? r = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = s.transform.anchorPoint : e === "opacity" ? r = s.opacity : r = s.properties.find((o) => o.name === e), r && (r.animated = n, n && r.keyframes.length === 0 && this.addKeyframe(i, e, r.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(i, e, n, s) {
      const r = this.project.layers.find((u) => u.id === i);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((u) => u.name === e), !o) return;
      const a = o.keyframes.find((u) => u.id === n);
      if (!a) return;
      const l = o.keyframes.find((u) => u.frame === s && u.id !== n);
      l && (o.keyframes = o.keyframes.filter((u) => u.id !== l.id)), a.frame = s, o.keyframes.sort((u, c) => u.frame - c.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(i, e, n, s) {
      const r = this.project.layers.find((l) => l.id === i);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (a.interpolation = s, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(i, e, n, s, r) {
      const o = this.project.layers.find((u) => u.id === i);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((u) => u.id === e || u.name === e), !a) return;
      const l = a.keyframes.find((u) => u.id === n);
      l && (s === "in" ? l.inHandle = { ...r } : l.outHandle = { ...r }, r.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(i = "Text") {
      const e = this.createLayer("text", i.substring(0, 20)), n = {
        text: i,
        fontFamily: "Arial",
        fontSize: 48,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options
        pathLayerId: null,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(gt("Font Size", 48, "number", "Text")), e.properties.push(gt("Fill Color", "#ffffff", "color", "Text")), e.properties.push(gt("Stroke Color", "#000000", "color", "Text")), e.properties.push(gt("Stroke Width", 0, "number", "Text")), e.properties.push(gt("Path Offset", 0, "number", "Path Options")), e.properties.push(gt("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(gt("Tracking", 0, "number", "Advanced")), e.properties.push(gt("Line Spacing", 0, "number", "Advanced")), e.properties.push(gt("Character Offset", 0, "number", "Advanced")), e.properties.push(gt("Character Value", 0, "number", "Advanced")), e.properties.push(gt("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const i = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return i.data = e, i;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const i = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return i.data = e, i;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || n.type !== "particles") return;
      const s = n.data;
      Object.assign(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(i, e, n) {
      const s = this.project.layers.find((a) => a.id === i);
      if (!s || s.type !== "particles") return;
      const o = s.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || n.type !== "particles") return;
      const s = n.data;
      s.emitters = s.emitters.filter((r) => r.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(i = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), s = {
        sourceLayerId: i,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: gt("zoom", 1, "number"),
        animatedOffsetX: gt("offsetX", 0, "number"),
        animatedOffsetY: gt("offsetY", 0, "number"),
        animatedRotation: gt("rotation", 0, "number"),
        animatedDepthScale: gt("depthScale", 1, "number")
      };
      return n.data = s, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || n.type !== "depthflow") return;
      const s = n.data;
      Object.assign(s.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n) return;
      const s = vv(e);
      s && (n.effects || (n.effects = []), n.effects.push(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || !n.effects) return;
      const s = n.effects.findIndex((r) => r.id === e);
      s >= 0 && (n.effects.splice(s, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(i, e, n, s) {
      const r = this.project.layers.find((a) => a.id === i);
      if (!r || !r.effects) return;
      const o = r.effects.find((a) => a.id === e);
      !o || !o.parameters[n] || (o.parameters[n].value = s, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      if (!n || !n.effects) return;
      const s = n.effects.find((r) => r.id === e);
      s && (s.enabled = !s.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(i, e, n) {
      const s = this.project.layers.find((o) => o.id === i);
      if (!s || !s.effects || e < 0 || e >= s.effects.length || n < 0 || n >= s.effects.length) return;
      const [r] = s.effects.splice(e, 1);
      s.effects.splice(n, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(i, e, n, s) {
      const r = this.project.layers.find((u) => u.id === i);
      if (!r || !r.effects) return null;
      const o = r.effects.find((u) => u.id === e);
      if (!o || !o.parameters[n]) return null;
      const a = o.parameters[n], l = s ?? this.project.currentFrame;
      return a.animated && a.keyframes.length > 0 ? ns(a, l) : a.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(i) {
      const e = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, n = i || `Camera ${this.cameras.size + 1}`, s = Rh(
        e,
        this.project.composition.width,
        this.project.composition.height
      );
      s.name = n, this.cameras.set(e, s), this.activeCameraId || (this.activeCameraId = e);
      const r = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: r,
        name: n,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        parentId: null,
        blendMode: "normal",
        opacity: gt("opacity", 100, "number"),
        transform: fc(),
        properties: [],
        effects: [],
        data: {
          cameraId: e,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === e
        }
      };
      return this.project.layers.unshift(o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(r), { camera: s, layer: o };
    },
    /**
     * Get a camera by ID
     */
    getCamera(i) {
      return this.cameras.get(i) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(i, e) {
      const n = this.cameras.get(i);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(i) {
      if (this.cameras.has(i)) {
        this.activeCameraId = i;
        for (const e of this.project.layers)
          if (e.type === "camera" && e.data) {
            const n = e.data;
            n.isActiveCamera = n.cameraId === i;
          }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(i) {
      const e = this.project.layers.findIndex(
        (n) => {
          var s;
          return n.type === "camera" && ((s = n.data) == null ? void 0 : s.cameraId) === i;
        }
      );
      if (e !== -1) {
        const n = this.project.layers[e].id;
        this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((s) => s !== n);
      }
      if (this.cameras.delete(i), this.activeCameraId === i) {
        const n = Array.from(this.cameras.keys());
        this.activeCameraId = n.length > 0 ? n[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update viewport state
     */
    updateViewportState(i) {
      Object.assign(this.viewportState, i);
    },
    /**
     * Update view options
     */
    updateViewOptions(i) {
      Object.assign(this.viewOptions, i);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(i) {
      this.audioFile = i, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await Jg(
          i,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), console.log("[Weyl] Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        console.error("[Weyl] Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      qg(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(i, e) {
      return this.audioAnalysis ? Ho(this.audioAnalysis, i, e ?? this.project.currentFrame) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(i, e) {
      const n = this.audioMappings.get(i) || [];
      n.push(e), this.audioMappings.set(i, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(i, e) {
      const n = this.audioMappings.get(i);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(i));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(i) {
      return this.audioMappings.get(i) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(i) {
      this.peakData = i, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(i);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(i) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = jh(e, i);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(i) {
      this.audioReactiveMappings.push(i), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(i);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(i) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === i);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(i);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(i, e) {
      const n = this.audioReactiveMappings.find((s) => s.id === i);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(i, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(i, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(i, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(i) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(i ?? this.project.currentFrame) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(i) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === i || e.targetLayerId === void 0)
      );
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      return this.audioAnalysis ? hc(this.audioAnalysis, this.project.currentFrame) : !1;
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(i, e = {}) {
      const n = new pv(e);
      this.pathAnimators.set(i, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(i, e) {
      const n = this.pathAnimators.get(i);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(i, e) {
      const n = this.pathAnimators.get(i);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(i) {
      this.pathAnimators.delete(i);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(i) {
      return this.pathAnimators.get(i);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      if (!this.audioAnalysis) return;
      const i = this.project.currentFrame, e = Ho(this.audioAnalysis, "amplitude", i), n = hc(this.audioAnalysis, i);
      for (const [s, r] of this.pathAnimators)
        r.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const i of this.pathAnimators.values())
        i.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new cv(this.audioAnalysis);
        for (const i of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(i);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    }
  }
});
async function yc(i) {
  try {
    const e = await i.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function bv() {
  if ("gpu" in navigator)
    try {
      const s = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (s) {
        let r = "";
        if ("info" in s) {
          const o = s.info;
          r = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return r.includes("RTX 50") || r.toLowerCase().includes("blackwell") || r.includes("B100") || r.includes("B200") ? {
          tier: "blackwell",
          vram: await yc(s),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await yc(s),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      console.warn("[Weyl] WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), s = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return console.log("[Weyl] WebGL renderer:", s), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const xv = { class: "project-panel" }, _v = { class: "panel-header" }, wv = { class: "header-actions" }, Sv = {
  key: 0,
  class: "search-bar"
}, Cv = { class: "panel-content" }, kv = { class: "folder-tree" }, Tv = ["onClick", "onDblclick"], Mv = ["onClick"], Ov = { class: "folder-name" }, Ev = { class: "item-count" }, Pv = {
  key: 0,
  class: "folder-contents"
}, Dv = ["onClick", "onDblclick", "onDragstart"], Av = { class: "item-icon" }, Iv = { class: "item-name" }, Fv = { class: "item-info" }, Lv = ["onClick", "onDblclick", "onDragstart"], zv = { class: "item-icon" }, Rv = { class: "item-name" }, Vv = { class: "item-info" }, jv = {
  key: 0,
  class: "empty-state"
}, $v = {
  key: 1,
  class: "panel-footer"
}, Bv = { class: "item-details" }, Wv = { class: "detail-label" }, Uv = { class: "detail-info" }, Nv = /* @__PURE__ */ pt({
  __name: "ProjectPanel",
  setup(i) {
    const e = Ot(), n = me(null), s = me(!1), r = me(""), o = me(null), a = me(["compositions", "footage"]), l = me([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), u = me([]), c = Oe(() => {
      if (!r.value) return l.value;
      const k = r.value.toLowerCase();
      return l.value.map((M) => ({
        ...M,
        items: M.items.filter(
          (O) => O.name.toLowerCase().includes(k)
        )
      })).filter((M) => M.items.length > 0 || M.name.toLowerCase().includes(k));
    }), d = Oe(() => {
      if (!r.value) return u.value;
      const k = r.value.toLowerCase();
      return u.value.filter(
        (M) => M.name.toLowerCase().includes(k)
      );
    }), f = Oe(() => {
      if (!o.value) return null;
      for (const M of l.value) {
        const O = M.items.find((F) => F.id === o.value);
        if (O)
          return {
            name: O.name,
            info: _(O)
          };
      }
      const k = u.value.find((M) => M.id === o.value);
      return k ? {
        name: k.name,
        info: _(k)
      } : null;
    });
    function g(k) {
      const M = a.value.indexOf(k);
      M >= 0 ? a.value.splice(M, 1) : a.value.push(k);
    }
    function p(k) {
      o.value = k;
    }
    function y(k) {
      k.type === "composition" && console.log("Opening composition:", k.name);
    }
    function v() {
      console.log("Create new item");
    }
    function m() {
      var k;
      (k = n.value) == null || k.click();
    }
    function b(k) {
      const M = k.target, O = M.files;
      if (!(!O || O.length === 0)) {
        for (const F of Array.from(O)) {
          const $ = S(F), ne = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: F.name,
            type: $
          };
          $ === "audio" && e.loadAudio(F);
          const oe = l.value.find(
            (z) => z.id === "footage"
          );
          oe ? oe.items.push(ne) : u.value.push(ne), console.log("[ProjectPanel] Imported:", F.name, $);
        }
        M.value = "";
      }
    }
    function S(k) {
      const M = k.type;
      return M.startsWith("audio/") ? "audio" : (M.startsWith("video/") || M.startsWith("image/"), "footage");
    }
    function x(k) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[k] || "";
    }
    function _(k) {
      if (k.type === "composition" || k.type === "footage") {
        const M = [];
        if (k.width && k.height && M.push(`${k.width}${k.height}`), k.fps && M.push(`${k.fps}fps`), k.duration) {
          const O = k.duration / (k.fps || 30);
          M.push(`${O.toFixed(1)}s`);
        }
        return M.join("  ");
      }
      return "";
    }
    function C(k, M) {
      var O;
      (O = M.dataTransfer) == null || O.setData("application/project-item", JSON.stringify(k));
    }
    return (k, M) => (V(), B("div", xv, [
      h("div", _v, [
        M[2] || (M[2] = h("span", { class: "panel-title" }, "Project", -1)),
        h("div", wv, [
          h("button", {
            onClick: m,
            title: "Import File (Ctrl+I)"
          }, ""),
          h("button", {
            onClick: v,
            title: "New Item"
          }, "+"),
          h("button", {
            onClick: M[0] || (M[0] = (O) => s.value = !s.value),
            title: "Search"
          }, "")
        ])
      ]),
      h("input", {
        ref_key: "fileInputRef",
        ref: n,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: b
      }, null, 544),
      s.value ? (V(), B("div", Sv, [
        tt(h("input", {
          type: "text",
          "onUpdate:modelValue": M[1] || (M[1] = (O) => r.value = O),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [$t, r.value]
        ])
      ])) : Te("", !0),
      h("div", Cv, [
        h("div", kv, [
          (V(!0), B(Re, null, Ue(c.value, (O) => (V(), B("div", {
            key: O.id,
            class: "folder-item"
          }, [
            h("div", {
              class: Ie(["folder-header", { selected: o.value === O.id }]),
              onClick: (F) => p(O.id),
              onDblclick: (F) => g(O.id)
            }, [
              h("span", {
                class: "expand-icon",
                onClick: Je((F) => g(O.id), ["stop"])
              }, pe(a.value.includes(O.id) ? "" : ""), 9, Mv),
              M[3] || (M[3] = h("span", { class: "folder-icon" }, "", -1)),
              h("span", Ov, pe(O.name), 1),
              h("span", Ev, pe(O.items.length), 1)
            ], 42, Tv),
            a.value.includes(O.id) ? (V(), B("div", Pv, [
              (V(!0), B(Re, null, Ue(O.items, (F) => (V(), B("div", {
                key: F.id,
                class: Ie(["project-item", { selected: o.value === F.id }]),
                onClick: ($) => p(F.id),
                onDblclick: ($) => y(F),
                draggable: "true",
                onDragstart: ($) => C(F, $)
              }, [
                h("span", Av, pe(x(F.type)), 1),
                h("span", Iv, pe(F.name), 1),
                h("span", Fv, pe(_(F)), 1)
              ], 42, Dv))), 128))
            ])) : Te("", !0)
          ]))), 128)),
          (V(!0), B(Re, null, Ue(d.value, (O) => (V(), B("div", {
            key: O.id,
            class: Ie(["project-item", { selected: o.value === O.id }]),
            onClick: (F) => p(O.id),
            onDblclick: (F) => y(O),
            draggable: "true",
            onDragstart: (F) => C(O, F)
          }, [
            h("span", zv, pe(x(O.type)), 1),
            h("span", Rv, pe(O.name), 1),
            h("span", Vv, pe(_(O)), 1)
          ], 42, Lv))), 128))
        ]),
        u.value.length === 0 ? (V(), B("div", jv, [...M[4] || (M[4] = [
          h("p", null, "No items in project", -1),
          h("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Te("", !0)
      ]),
      f.value ? (V(), B("div", $v, [
        h("div", Bv, [
          h("span", Wv, pe(f.value.name), 1),
          h("span", Uv, pe(f.value.info), 1)
        ])
      ])) : Te("", !0)
    ]));
  }
}), mt = (i, e) => {
  const n = i.__vccOpts || i;
  for (const [s, r] of e)
    n[s] = r;
  return n;
}, Hv = /* @__PURE__ */ mt(Nv, [["__scopeId", "data-v-4bd45b37"]]), Xv = { class: "effects-panel" }, Yv = { class: "panel-header" }, Gv = { class: "header-actions" }, Kv = { class: "panel-content" }, qv = { class: "tabs" }, Zv = {
  key: 0,
  class: "effects-list"
}, Jv = ["onClick"], Qv = { class: "expand-icon" }, e0 = { class: "category-icon" }, t0 = { class: "category-name" }, n0 = { class: "effect-count" }, s0 = {
  key: 0,
  class: "category-effects"
}, i0 = ["onDblclick", "onDragstart"], r0 = { class: "effect-name" }, o0 = ["onClick", "title"], a0 = {
  key: 1,
  class: "presets-list"
}, l0 = ["onClick"], u0 = { class: "expand-icon" }, c0 = { class: "category-name" }, d0 = { class: "preset-count" }, h0 = {
  key: 0,
  class: "category-presets"
}, f0 = ["onDblclick", "onDragstart"], p0 = { class: "preset-info" }, m0 = { class: "preset-name" }, g0 = { class: "preset-description" }, v0 = {
  key: 2,
  class: "favorites-list"
}, y0 = {
  key: 0,
  class: "empty-favorites"
}, b0 = ["onDblclick", "onDragstart"], x0 = { class: "category-badge" }, _0 = { class: "effect-name" }, w0 = ["onClick"], S0 = /* @__PURE__ */ pt({
  __name: "EffectsPanel",
  setup(i) {
    const e = Ot(), n = me("effects"), s = me(""), r = me(["blur-sharpen", "color-correction"]), o = me(["Fade", "Scale"]), a = me([]);
    Rt(() => {
      const _ = localStorage.getItem("effect-favorites");
      if (_)
        try {
          a.value = JSON.parse(_);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const u = Oe(() => Object.entries(Cr).map(([_, C]) => ({
      key: _,
      name: C.name,
      category: C.category,
      description: C.description
    }))), c = Oe(() => {
      const _ = s.value.toLowerCase();
      return Object.entries(Ol).map(([C, k]) => {
        const M = u.value.filter((O) => !(O.category !== C || _ && !O.name.toLowerCase().includes(_)));
        return {
          key: C,
          label: k.label,
          icon: k.icon,
          effects: M
        };
      }).filter((C) => C.effects.length > 0);
    }), d = Oe(() => {
      const _ = s.value.toLowerCase(), C = {};
      for (const k of yv)
        _ && !k.name.toLowerCase().includes(_) || (C[k.category] || (C[k.category] = []), C[k.category].push(k));
      return Object.entries(C).map(([k, M]) => ({
        category: k,
        presets: M
      }));
    }), f = Oe(() => u.value.filter((_) => a.value.includes(_.key)));
    function g(_) {
      const C = r.value.indexOf(_);
      C >= 0 ? r.value.splice(C, 1) : r.value.push(_);
    }
    function p(_) {
      const C = o.value.indexOf(_);
      C >= 0 ? o.value.splice(C, 1) : o.value.push(_);
    }
    function y(_) {
      const C = a.value.indexOf(_);
      C >= 0 ? a.value.splice(C, 1) : a.value.push(_), l();
    }
    function v(_) {
      var C;
      return ((C = Ol[_]) == null ? void 0 : C.icon) || "?";
    }
    function m(_) {
      const C = gv(_);
      if (!C) return;
      const k = e.selectedLayer;
      if (!k) {
        console.warn("No layer selected to apply effect");
        return;
      }
      k.effects || (k.effects = []), k.effects.push(C);
    }
    function b(_) {
      if (!e.selectedLayer) {
        console.warn("No layer selected to apply preset");
        return;
      }
      console.log("Applying preset:", _.name);
    }
    function S(_, C) {
      var k;
      (k = C.dataTransfer) == null || k.setData("application/effect", _);
    }
    function x(_, C) {
      var k;
      (k = C.dataTransfer) == null || k.setData("application/preset", JSON.stringify(_));
    }
    return (_, C) => (V(), B("div", Xv, [
      h("div", Yv, [
        C[4] || (C[4] = h("span", { class: "panel-title" }, "Effects & Presets", -1)),
        h("div", Gv, [
          tt(h("input", {
            type: "text",
            "onUpdate:modelValue": C[0] || (C[0] = (k) => s.value = k),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [$t, s.value]
          ])
        ])
      ]),
      h("div", Kv, [
        h("div", qv, [
          h("button", {
            class: Ie({ active: n.value === "effects" }),
            onClick: C[1] || (C[1] = (k) => n.value = "effects")
          }, " Effects ", 2),
          h("button", {
            class: Ie({ active: n.value === "presets" }),
            onClick: C[2] || (C[2] = (k) => n.value = "presets")
          }, " Presets ", 2),
          h("button", {
            class: Ie({ active: n.value === "favorites" }),
            onClick: C[3] || (C[3] = (k) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (V(), B("div", Zv, [
          (V(!0), B(Re, null, Ue(c.value, (k) => (V(), B("div", {
            key: k.key,
            class: "effect-category"
          }, [
            h("div", {
              class: "category-header",
              onClick: (M) => g(k.key)
            }, [
              h("span", Qv, pe(r.value.includes(k.key) ? "" : ""), 1),
              h("span", e0, pe(k.icon), 1),
              h("span", t0, pe(k.label), 1),
              h("span", n0, pe(k.effects.length), 1)
            ], 8, Jv),
            r.value.includes(k.key) ? (V(), B("div", s0, [
              (V(!0), B(Re, null, Ue(k.effects, (M) => (V(), B("div", {
                key: M.key,
                class: Ie(["effect-item", { favorite: a.value.includes(M.key) }]),
                onDblclick: (O) => m(M.key),
                onDragstart: (O) => S(M.key, O),
                draggable: "true"
              }, [
                h("span", r0, pe(M.name), 1),
                h("button", {
                  class: "favorite-btn",
                  onClick: Je((O) => y(M.key), ["stop"]),
                  title: a.value.includes(M.key) ? "Remove from favorites" : "Add to favorites"
                }, pe(a.value.includes(M.key) ? "" : ""), 9, o0)
              ], 42, i0))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (V(), B("div", a0, [
          (V(!0), B(Re, null, Ue(d.value, (k) => (V(), B("div", {
            key: k.category,
            class: "preset-category"
          }, [
            h("div", {
              class: "category-header",
              onClick: (M) => p(k.category)
            }, [
              h("span", u0, pe(o.value.includes(k.category) ? "" : ""), 1),
              h("span", c0, pe(k.category), 1),
              h("span", d0, pe(k.presets.length), 1)
            ], 8, l0),
            o.value.includes(k.category) ? (V(), B("div", h0, [
              (V(!0), B(Re, null, Ue(k.presets, (M) => (V(), B("div", {
                key: M.id,
                class: "preset-item",
                onDblclick: (O) => b(M),
                onDragstart: (O) => x(M, O),
                draggable: "true"
              }, [
                C[5] || (C[5] = h("div", { class: "preset-preview" }, [
                  h("span", { class: "preview-icon" }, "")
                ], -1)),
                h("div", p0, [
                  h("span", m0, pe(M.name), 1),
                  h("span", g0, pe(M.description), 1)
                ])
              ], 40, f0))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (V(), B("div", v0, [
          f.value.length === 0 ? (V(), B("div", y0, [...C[6] || (C[6] = [
            h("p", null, "No favorites yet", -1),
            h("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Te("", !0),
          (V(!0), B(Re, null, Ue(f.value, (k) => (V(), B("div", {
            key: k.key,
            class: "effect-item",
            onDblclick: (M) => m(k.key),
            onDragstart: (M) => S(k.key, M),
            draggable: "true"
          }, [
            h("span", x0, pe(v(k.category)), 1),
            h("span", _0, pe(k.name), 1),
            h("button", {
              class: "favorite-btn active",
              onClick: Je((M) => y(k.key), ["stop"])
            }, "  ", 8, w0)
          ], 40, b0))), 128))
        ])) : Te("", !0)
      ]),
      C[7] || (C[7] = h("div", { class: "panel-footer" }, [
        h("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), C0 = /* @__PURE__ */ mt(S0, [["__scopeId", "data-v-b66ebaa1"]]), k0 = ["value", "min", "max", "step", "disabled"], T0 = {
  key: 1,
  class: "scrub-unit"
}, M0 = /* @__PURE__ */ pt({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = me(!1), o = me(0), a = me(0), l = Oe(() => n.default ?? n.modelValue), u = Oe(() => n.default !== void 0), c = Oe(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(x) {
      return Math.max(n.min, Math.min(n.max, x));
    }
    function f(x) {
      const _ = Math.pow(10, n.precision);
      return Math.round(x * _) / _;
    }
    function g(x) {
      n.disabled || (r.value = !0, o.value = x.clientX, a.value = n.modelValue, document.addEventListener("mousemove", p), document.addEventListener("mouseup", y), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function p(x) {
      const _ = x.clientX - o.value;
      let C = n.sensitivity;
      x.shiftKey && (C *= 10), (x.ctrlKey || x.metaKey) && (C *= 0.1);
      const k = _ * n.step * C * 0.5, M = f(d(a.value + k));
      M !== n.modelValue && s("update:modelValue", M);
    }
    function y() {
      r.value = !1, document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", y), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function v(x) {
      const _ = x.target, C = parseFloat(_.value);
      isNaN(C) || s("update:modelValue", f(d(C)));
    }
    function m(x) {
      if (n.disabled) return;
      let _ = 0;
      x.key === "ArrowUp" ? _ = n.step : x.key === "ArrowDown" && (_ = -n.step), _ !== 0 && (x.preventDefault(), x.shiftKey && (_ *= 10), (x.ctrlKey || x.metaKey) && (_ *= 0.1), s("update:modelValue", f(d(n.modelValue + _))));
    }
    function b(x) {
      const _ = x.target, C = parseFloat(_.value);
      isNaN(C) && (_.value = c.value.toString());
    }
    function S() {
      n.default !== void 0 && s("update:modelValue", n.default);
    }
    return (x, _) => (V(), B("div", {
      class: Ie(["scrubable-number", { disabled: i.disabled }])
    }, [
      i.label ? (V(), B("label", {
        key: 0,
        class: Ie(["scrub-label", { scrubbing: r.value }]),
        onMousedown: g
      }, pe(i.label), 35)) : Te("", !0),
      h("input", {
        type: "number",
        class: "scrub-input",
        value: c.value,
        min: i.min,
        max: i.max,
        step: i.step,
        disabled: i.disabled,
        onInput: v,
        onKeydown: m,
        onBlur: b
      }, null, 40, k0),
      i.unit ? (V(), B("span", T0, pe(i.unit), 1)) : Te("", !0),
      u.value && i.modelValue !== l.value ? (V(), B("button", {
        key: 2,
        class: "reset-btn",
        onClick: S,
        title: "Reset to default"
      }, [..._[0] || (_[0] = [
        h("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Te("", !0)
    ], 2));
  }
}), Ne = /* @__PURE__ */ mt(M0, [["__scopeId", "data-v-2a930cf0"]]), O0 = ["value", "min", "max", "step", "disabled"], E0 = {
  key: 2,
  class: "slider-unit"
}, P0 = /* @__PURE__ */ pt({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = me(null), o = me(!1), a = me(!1), l = me(0), u = me(0), c = Oe(() => {
      const k = n.max - n.min;
      return k === 0 ? 0 : (n.modelValue - n.min) / k * 100;
    }), d = Oe(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function f(k) {
      return Math.max(n.min, Math.min(n.max, k));
    }
    function g(k) {
      const M = Math.pow(10, n.precision);
      return Math.round(k * M) / M;
    }
    function p(k) {
      n.disabled || (o.value = !0, l.value = k.clientX, u.value = n.modelValue, document.addEventListener("mousemove", y), document.addEventListener("mouseup", v), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function y(k) {
      const M = k.clientX - l.value, O = n.max - n.min;
      let F = 1;
      k.shiftKey && (F *= 10), (k.ctrlKey || k.metaKey) && (F *= 0.1);
      const $ = M / 200 * O * F, ne = g(f(u.value + $));
      ne !== n.modelValue && s("update:modelValue", ne);
    }
    function v() {
      o.value = !1, document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", v), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function m(k) {
      if (n.disabled || !r.value) return;
      const M = r.value.getBoundingClientRect(), O = (k.clientX - M.left) / M.width, F = n.min + O * (n.max - n.min);
      s("update:modelValue", g(f(F)));
    }
    function b(k) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", S), document.addEventListener("mouseup", x), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function S(k) {
      if (!r.value) return;
      const M = r.value.getBoundingClientRect(), O = (k.clientX - M.left) / M.width, F = n.min + Math.max(0, Math.min(1, O)) * (n.max - n.min);
      s("update:modelValue", g(f(F)));
    }
    function x() {
      a.value = !1, document.removeEventListener("mousemove", S), document.removeEventListener("mouseup", x), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(k) {
      const M = k.target, O = parseFloat(M.value);
      isNaN(O) || s("update:modelValue", g(f(O)));
    }
    function C(k) {
      const M = k.target, O = parseFloat(M.value);
      isNaN(O) && (M.value = d.value.toString());
    }
    return (k, M) => (V(), B("div", {
      class: Ie(["slider-input", { disabled: i.disabled }])
    }, [
      i.label ? (V(), B("label", {
        key: 0,
        class: Ie(["slider-label", { scrubbing: o.value }]),
        onMousedown: p
      }, pe(i.label), 35)) : Te("", !0),
      h("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: r,
        onMousedown: m
      }, [
        h("div", {
          class: "slider-fill",
          style: Xe({ width: c.value + "%", background: i.gradient || void 0 })
        }, null, 4),
        h("div", {
          class: "slider-thumb",
          style: Xe({ left: c.value + "%" }),
          onMousedown: Je(b, ["stop"])
        }, null, 36)
      ], 544),
      i.showValue ? (V(), B("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: i.min,
        max: i.max,
        step: i.step,
        disabled: i.disabled,
        onInput: _,
        onBlur: C
      }, null, 40, O0)) : Te("", !0),
      i.unit ? (V(), B("span", E0, pe(i.unit), 1)) : Te("", !0)
    ], 2));
  }
}), cn = /* @__PURE__ */ mt(P0, [["__scopeId", "data-v-9dd40416"]]), D0 = { class: "dial-marks" }, A0 = {
  key: 0,
  class: "angle-value"
}, I0 = ["value", "disabled"], F0 = /* @__PURE__ */ pt({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = me(null), o = me(!1), a = Oe(() => Math.round(n.modelValue * 10) / 10);
    function l(y) {
      return (y % 360 + 360) % 360;
    }
    function u(y) {
      n.disabled || (o.value = !0, d(y), document.addEventListener("mousemove", c), document.addEventListener("mouseup", f), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function c(y) {
      o.value && d(y);
    }
    function d(y) {
      if (!r.value) return;
      const v = r.value.getBoundingClientRect(), m = v.left + v.width / 2, b = v.top + v.height / 2, S = y.clientX - m, x = y.clientY - b;
      let _ = Math.atan2(S, -x) * (180 / Math.PI);
      _ = l(_), y.shiftKey && (_ = Math.round(_ / 45) * 45), s("update:modelValue", _);
    }
    function f() {
      o.value = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", f), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function g(y) {
      const v = y.target, m = parseFloat(v.value);
      isNaN(m) || s("update:modelValue", l(m));
    }
    function p(y) {
      const v = y.target, m = parseFloat(v.value);
      isNaN(m) && (v.value = a.value.toString());
    }
    return (y, v) => (V(), B("div", {
      class: Ie(["angle-dial", { disabled: i.disabled }])
    }, [
      h("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: r,
        style: Xe({ width: i.size + "px", height: i.size + "px" }),
        onMousedown: u
      }, [
        v[0] || (v[0] = h("div", { class: "dial-ring" }, null, -1)),
        v[1] || (v[1] = h("div", { class: "dial-center" }, null, -1)),
        h("div", {
          class: "dial-indicator",
          style: Xe({ transform: `rotate(${i.modelValue}deg)` })
        }, null, 4),
        h("div", D0, [
          (V(), B(Re, null, Ue(8, (m) => h("div", {
            class: "dial-mark",
            key: m,
            style: Xe({ transform: `rotate(${m * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      i.showValue ? (V(), B("div", A0, [
        h("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: i.disabled,
          onInput: g,
          onBlur: p
        }, null, 40, I0),
        v[2] || (v[2] = h("span", { class: "angle-unit" }, "", -1))
      ])) : Te("", !0)
    ], 2));
  }
}), ou = /* @__PURE__ */ mt(F0, [["__scopeId", "data-v-04a5caf6"]]);
function bc(i, e, n) {
  i = (i % 360 + 360) % 360;
  const s = n * e, r = s * (1 - Math.abs(i / 60 % 2 - 1)), o = n - s;
  let a = 0, l = 0, u = 0;
  return i < 60 ? (a = s, l = r, u = 0) : i < 120 ? (a = r, l = s, u = 0) : i < 180 ? (a = 0, l = s, u = r) : i < 240 ? (a = 0, l = r, u = s) : i < 300 ? (a = r, l = 0, u = s) : (a = s, l = 0, u = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((u + o) * 255)
  ];
}
function Yn(i, e, n) {
  i /= 255, e /= 255, n /= 255;
  const s = Math.max(i, e, n), r = Math.min(i, e, n), o = s - r;
  let a = 0;
  const l = s === 0 ? 0 : o / s, u = s;
  if (o !== 0)
    switch (s) {
      case i:
        a = ((e - n) / o + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - i) / o + 2) * 60;
        break;
      case n:
        a = ((i - e) / o + 4) * 60;
        break;
    }
  return [a, l, u];
}
function Yr(i, e, n) {
  i = (i % 360 + 360) % 360;
  const s = (1 - Math.abs(2 * n - 1)) * e, r = s * (1 - Math.abs(i / 60 % 2 - 1)), o = n - s / 2;
  let a = 0, l = 0, u = 0;
  return i < 60 ? (a = s, l = r, u = 0) : i < 120 ? (a = r, l = s, u = 0) : i < 180 ? (a = 0, l = s, u = r) : i < 240 ? (a = 0, l = r, u = s) : i < 300 ? (a = r, l = 0, u = s) : (a = s, l = 0, u = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((u + o) * 255)
  ];
}
function Ws(i, e, n) {
  i /= 255, e /= 255, n /= 255;
  const s = Math.max(i, e, n), r = Math.min(i, e, n), o = (s + r) / 2;
  let a = 0, l = 0;
  if (s !== r) {
    const u = s - r;
    switch (l = o > 0.5 ? u / (2 - s - r) : u / (s + r), s) {
      case i:
        a = ((e - n) / u + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - i) / u + 2) * 60;
        break;
      case n:
        a = ((i - e) / u + 4) * 60;
        break;
    }
  }
  return [a, l, o];
}
function L0(i) {
  if (i = i.replace(/^#/, ""), i.length === 3 && (i = i[0] + i[0] + i[1] + i[1] + i[2] + i[2]), i.length === 6 || i.length === 8) {
    const e = parseInt(i.slice(0, 2), 16), n = parseInt(i.slice(2, 4), 16), s = parseInt(i.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(s))
      return [e, n, s];
  }
  return null;
}
function z0(i) {
  if (i = i.replace(/^#/, ""), i.length === 3 && (i = i[0] + i[0] + i[1] + i[1] + i[2] + i[2] + "ff"), i.length === 6 && (i = i + "ff"), i.length === 8) {
    const e = parseInt(i.slice(0, 2), 16), n = parseInt(i.slice(2, 4), 16), s = parseInt(i.slice(4, 6), 16), r = parseInt(i.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(s) && !isNaN(r))
      return [e, n, s, r];
  }
  return null;
}
function R0(i, e, n) {
  const s = (r) => Math.max(0, Math.min(255, Math.round(r))).toString(16).padStart(2, "0");
  return `#${s(i)}${s(e)}${s(n)}`;
}
function V0(i, e, n, s) {
  const r = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${r(i)}${r(e)}${r(n)}${r(s * 255)}`;
}
const j0 = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], $0 = {
  key: 0,
  class: "checkerboard"
}, B0 = ["value"], W0 = { class: "mode-tabs" }, U0 = ["onClick"], N0 = {
  key: 1,
  class: "rgb-sliders"
}, H0 = { class: "color-slider" }, X0 = ["value"], Y0 = { class: "color-slider" }, G0 = ["value"], K0 = { class: "color-slider" }, q0 = ["value"], Z0 = {
  key: 2,
  class: "hsl-sliders"
}, J0 = { class: "color-slider" }, Q0 = ["value"], ey = { class: "color-slider" }, ty = ["value"], ny = { class: "color-slider" }, sy = ["value"], iy = {
  key: 3,
  class: "alpha-slider"
}, ry = ["value"], oy = { class: "swatches-section" }, ay = { class: "swatches-grid" }, ly = ["onClick"], uy = {
  key: 4,
  class: "recent-section"
}, cy = { class: "swatches-grid" }, dy = ["onClick"], hy = /* @__PURE__ */ pt({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = ["hsv", "rgb", "hsl"], o = me(null), a = me(null), l = me(null), u = me(null), c = me(null), d = me(!1), f = me("hsv"), g = me(1), p = me([]), y = me([255, 255, 255]), v = me([0, 0, 1]), m = me([0, 0, 1]), b = Oe(() => n.swatches || j0), S = Oe(() => {
      if (!o.value || !n.teleport) return {};
      const L = o.value.getBoundingClientRect();
      return {
        top: `${L.bottom + 4}px`,
        left: `${L.left}px`
      };
    });
    function x(L) {
      const A = L0(L);
      A && (y.value = A, v.value = Yn(A[0], A[1], A[2]), m.value = Ws(A[0], A[1], A[2]));
    }
    function _() {
      const L = R0(y.value[0], y.value[1], y.value[2]);
      s("update:modelValue", L);
    }
    function C() {
      d.value = !d.value;
    }
    function k() {
      d.value && (d.value = !1, M(n.modelValue));
    }
    function M(L) {
      const A = p.value.indexOf(L);
      A !== -1 && p.value.splice(A, 1), p.value.unshift(L), p.value.length > n.recentCount && p.value.pop();
    }
    function O(L) {
      s("update:modelValue", L);
    }
    let F = !1;
    function $(L) {
      F = !0, oe(L), document.addEventListener("mousemove", ne), document.addEventListener("mouseup", z);
    }
    function ne(L) {
      F && oe(L);
    }
    function oe(L) {
      if (!l.value) return;
      const A = l.value.getBoundingClientRect(), E = Math.max(0, Math.min(1, (L.clientX - A.left) / A.width)), I = Math.max(0, Math.min(1, 1 - (L.clientY - A.top) / A.height));
      v.value = [v.value[0], E, I], y.value = bc(v.value[0], v.value[1], v.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]), _();
    }
    function z() {
      F = !1, document.removeEventListener("mousemove", ne), document.removeEventListener("mouseup", z);
    }
    let X = !1;
    function T(L) {
      X = !0, ge(L), document.addEventListener("mousemove", H), document.addEventListener("mouseup", K);
    }
    function H(L) {
      X && ge(L);
    }
    function ge(L) {
      if (!u.value) return;
      const A = u.value.getBoundingClientRect(), E = Math.max(0, Math.min(360, (L.clientX - A.left) / A.width * 360));
      v.value = [E, v.value[1], v.value[2]], y.value = bc(v.value[0], v.value[1], v.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]), _();
    }
    function K() {
      X = !1, document.removeEventListener("mousemove", H), document.removeEventListener("mouseup", K);
    }
    let re = null, ie = null;
    function be(L, A) {
      re = L;
      const E = A.target.closest(".slider-track");
      E && (ie = E.getBoundingClientRect(), ee(A), document.addEventListener("mousemove", J), document.addEventListener("mouseup", ve));
    }
    function J(L) {
      re && ee(L);
    }
    function ee(L) {
      if (!ie || !re) return;
      const A = Math.max(0, Math.min(1, (L.clientX - ie.left) / ie.width));
      switch (re) {
        case "r":
          y.value = [Math.round(A * 255), y.value[1], y.value[2]], v.value = Yn(y.value[0], y.value[1], y.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]);
          break;
        case "g":
          y.value = [y.value[0], Math.round(A * 255), y.value[2]], v.value = Yn(y.value[0], y.value[1], y.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]);
          break;
        case "b":
          y.value = [y.value[0], y.value[1], Math.round(A * 255)], v.value = Yn(y.value[0], y.value[1], y.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]);
          break;
        case "h":
          m.value = [A * 360, m.value[1], m.value[2]], y.value = Yr(m.value[0], m.value[1], m.value[2]), v.value = Yn(y.value[0], y.value[1], y.value[2]);
          break;
        case "s":
          m.value = [m.value[0], A, m.value[2]], y.value = Yr(m.value[0], m.value[1], m.value[2]), v.value = Yn(y.value[0], y.value[1], y.value[2]);
          break;
        case "l":
          m.value = [m.value[0], m.value[1], A], y.value = Yr(m.value[0], m.value[1], m.value[2]), v.value = Yn(y.value[0], y.value[1], y.value[2]);
          break;
      }
      _();
    }
    function ve() {
      re = null, ie = null, document.removeEventListener("mousemove", J), document.removeEventListener("mouseup", ve);
    }
    let G = !1;
    function N(L) {
      G = !0, fe(L), document.addEventListener("mousemove", te), document.addEventListener("mouseup", ae);
    }
    function te(L) {
      G && fe(L);
    }
    function fe(L) {
      if (!c.value) return;
      const A = c.value.getBoundingClientRect();
      g.value = Math.max(0, Math.min(1, (L.clientX - A.left) / A.width));
    }
    function ae() {
      G = !1, document.removeEventListener("mousemove", te), document.removeEventListener("mouseup", ae);
    }
    function D(L) {
      let E = L.target.value.trim();
      E.startsWith("#") || (E = "#" + E), /^#[0-9a-f]{6}$/i.test(E) && s("update:modelValue", E.toLowerCase());
    }
    function R(L) {
      const A = L.target;
      A.value = n.modelValue;
    }
    function P(L, A) {
      const E = A.target, I = Math.max(0, Math.min(255, parseInt(E.value) || 0)), j = [...y.value];
      j[L] = I, y.value = j, v.value = Yn(y.value[0], y.value[1], y.value[2]), m.value = Ws(y.value[0], y.value[1], y.value[2]), _();
    }
    function Y(L, A) {
      const E = A.target;
      let I = parseFloat(E.value) || 0;
      L === 0 ? (I = Math.max(0, Math.min(360, I)), m.value = [I, m.value[1], m.value[2]]) : (I = Math.max(0, Math.min(100, I)) / 100, L === 1 ? m.value = [m.value[0], I, m.value[2]] : m.value = [m.value[0], m.value[1], I]), y.value = Yr(m.value[0], m.value[1], m.value[2]), v.value = Yn(y.value[0], y.value[1], y.value[2]), _();
    }
    function U(L) {
      const A = L.target;
      g.value = Math.max(0, Math.min(100, parseInt(A.value) || 0)) / 100;
    }
    function w(L) {
      o.value && !o.value.contains(L.target) && a.value && !a.value.contains(L.target) && k();
    }
    return ut(() => n.modelValue, (L) => {
      x(L);
    }, { immediate: !0 }), Rt(() => {
      document.addEventListener("mousedown", w);
    }), pn(() => {
      document.removeEventListener("mousedown", w);
    }), (L, A) => (V(), B("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: o
    }, [
      h("button", {
        class: "color-swatch",
        style: Xe({ backgroundColor: i.modelValue }),
        onClick: C
      }, [
        i.alpha ? (V(), B("span", $0)) : Te("", !0)
      ], 4),
      h("input", {
        type: "text",
        class: "hex-input",
        value: i.modelValue,
        onInput: D,
        onBlur: R,
        onKeydown: A[0] || (A[0] = ru((E) => E.target.blur(), ["enter"]))
      }, null, 40, B0),
      (V(), ot(rm, {
        to: "body",
        disabled: !i.teleport
      }, [
        d.value ? (V(), B("div", {
          key: 0,
          class: "picker-panel",
          style: Xe(S.value),
          ref_key: "panelRef",
          ref: a
        }, [
          h("div", W0, [
            (V(), B(Re, null, Ue(r, (E) => h("button", {
              key: E,
              class: Ie({ active: f.value === E }),
              onClick: (I) => f.value = E
            }, pe(E.toUpperCase()), 11, U0)), 64))
          ]),
          f.value === "hsv" ? (V(), B(Re, { key: 0 }, [
            h("div", {
              class: "sv-square",
              style: Xe({ backgroundColor: `hsl(${v.value[0]}, 100%, 50%)` }),
              onMousedown: $,
              ref_key: "svSquareRef",
              ref: l
            }, [
              A[13] || (A[13] = h("div", { class: "sv-white" }, null, -1)),
              A[14] || (A[14] = h("div", { class: "sv-black" }, null, -1)),
              h("div", {
                class: "sv-cursor",
                style: Xe({ left: v.value[1] * 100 + "%", top: (1 - v.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            h("div", {
              class: "hue-slider",
              onMousedown: T,
              ref_key: "hueSliderRef",
              ref: u
            }, [
              h("div", {
                class: "hue-cursor",
                style: Xe({ left: v.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : f.value === "rgb" ? (V(), B("div", N0, [
            h("div", H0, [
              A[15] || (A[15] = h("label", null, "R", -1)),
              h("div", {
                class: "slider-track r-track",
                onMousedown: A[1] || (A[1] = (E) => be("r", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: y.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              h("input", {
                type: "number",
                value: y.value[0],
                min: "0",
                max: "255",
                onInput: A[2] || (A[2] = (E) => P(0, E))
              }, null, 40, X0)
            ]),
            h("div", Y0, [
              A[16] || (A[16] = h("label", null, "G", -1)),
              h("div", {
                class: "slider-track g-track",
                onMousedown: A[3] || (A[3] = (E) => be("g", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: y.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              h("input", {
                type: "number",
                value: y.value[1],
                min: "0",
                max: "255",
                onInput: A[4] || (A[4] = (E) => P(1, E))
              }, null, 40, G0)
            ]),
            h("div", K0, [
              A[17] || (A[17] = h("label", null, "B", -1)),
              h("div", {
                class: "slider-track b-track",
                onMousedown: A[5] || (A[5] = (E) => be("b", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: y.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              h("input", {
                type: "number",
                value: y.value[2],
                min: "0",
                max: "255",
                onInput: A[6] || (A[6] = (E) => P(2, E))
              }, null, 40, q0)
            ])
          ])) : f.value === "hsl" ? (V(), B("div", Z0, [
            h("div", J0, [
              A[18] || (A[18] = h("label", null, "H", -1)),
              h("div", {
                class: "slider-track hue-track",
                onMousedown: A[7] || (A[7] = (E) => be("h", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: m.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              h("input", {
                type: "number",
                value: Math.round(m.value[0]),
                min: "0",
                max: "360",
                onInput: A[8] || (A[8] = (E) => Y(0, E))
              }, null, 40, Q0)
            ]),
            h("div", ey, [
              A[19] || (A[19] = h("label", null, "S", -1)),
              h("div", {
                class: "slider-track sat-track",
                style: Xe({ "--hue": m.value[0] }),
                onMousedown: A[9] || (A[9] = (E) => be("s", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: m.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              h("input", {
                type: "number",
                value: Math.round(m.value[1] * 100),
                min: "0",
                max: "100",
                onInput: A[10] || (A[10] = (E) => Y(1, E))
              }, null, 40, ty)
            ]),
            h("div", ny, [
              A[20] || (A[20] = h("label", null, "L", -1)),
              h("div", {
                class: "slider-track light-track",
                style: Xe({ "--hue": m.value[0] }),
                onMousedown: A[11] || (A[11] = (E) => be("l", E))
              }, [
                h("div", {
                  class: "slider-cursor",
                  style: Xe({ left: m.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              h("input", {
                type: "number",
                value: Math.round(m.value[2] * 100),
                min: "0",
                max: "100",
                onInput: A[12] || (A[12] = (E) => Y(2, E))
              }, null, 40, sy)
            ])
          ])) : Te("", !0),
          i.alpha ? (V(), B("div", iy, [
            A[21] || (A[21] = h("label", null, "A", -1)),
            h("div", {
              class: "slider-track alpha-track",
              style: Xe({ "--color": i.modelValue }),
              onMousedown: N,
              ref_key: "alphaSliderRef",
              ref: c
            }, [
              h("div", {
                class: "slider-cursor",
                style: Xe({ left: g.value * 100 + "%" })
              }, null, 4)
            ], 36),
            h("input", {
              type: "number",
              value: Math.round(g.value * 100),
              min: "0",
              max: "100",
              onInput: U
            }, null, 40, ry)
          ])) : Te("", !0),
          h("div", oy, [
            A[22] || (A[22] = h("div", { class: "swatches-label" }, "Swatches", -1)),
            h("div", ay, [
              (V(!0), B(Re, null, Ue(b.value, (E) => (V(), B("button", {
                key: E,
                class: "swatch",
                style: Xe({ backgroundColor: E }),
                onClick: (I) => O(E)
              }, null, 12, ly))), 128))
            ])
          ]),
          p.value.length > 0 ? (V(), B("div", uy, [
            A[23] || (A[23] = h("div", { class: "swatches-label" }, "Recent", -1)),
            h("div", cy, [
              (V(!0), B(Re, null, Ue(p.value, (E) => (V(), B("button", {
                key: E,
                class: "swatch",
                style: Xe({ backgroundColor: E }),
                onClick: (I) => O(E)
              }, null, 12, dy))), 128))
            ])
          ])) : Te("", !0)
        ], 4)) : Te("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), Oi = /* @__PURE__ */ mt(hy, [["__scopeId", "data-v-05165efb"]]), fy = { class: "effect-controls" }, py = { class: "panel-header" }, my = { class: "header-row" }, gy = {
  key: 0,
  class: "layer-badge"
}, vy = { class: "layer-type-icon" }, yy = ["disabled"], by = {
  key: 0,
  class: "effect-menu"
}, xy = { class: "category-label" }, _y = { class: "cat-icon" }, wy = { class: "category-items" }, Sy = ["onClick"], Cy = { class: "panel-content" }, ky = {
  key: 0,
  class: "empty-state"
}, Ty = {
  key: 1,
  class: "empty-state"
}, My = {
  key: 2,
  class: "effects-list"
}, Oy = ["onClick"], Ey = { class: "header-left" }, Py = { class: "arrow" }, Dy = ["onClick"], Ay = { class: "effect-name" }, Iy = { class: "header-right" }, Fy = ["onClick"], Ly = {
  key: 0,
  class: "effect-params"
}, zy = { class: "param-header" }, Ry = ["title"], Vy = ["onClick"], jy = { class: "param-control" }, $y = {
  key: 0,
  class: "control-group"
}, By = {
  key: 1,
  class: "control-group"
}, Wy = {
  key: 2,
  class: "control-group point-group"
}, Uy = ["checked", "onChange"], Ny = ["value", "onChange"], Hy = ["value"], Xy = /* @__PURE__ */ pt({
  __name: "EffectControlsPanel",
  setup(i) {
    const e = Ot(), n = me(!1), s = me(null), r = Oe(() => e.selectedLayer), o = Ol;
    function a(M) {
      return Object.entries(Cr).filter(([O, F]) => F.category === M).map(([O, F]) => ({ key: O, ...F }));
    }
    function l(M, O) {
      const F = Cr[M];
      return F == null ? void 0 : F.parameters.find(($) => u($.name) === O);
    }
    function u(M) {
      return M.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function c(M, O) {
      const F = l(M, O);
      return F && (F.min !== void 0 || F.max !== void 0);
    }
    function d(M, O) {
      const F = l(M, O);
      return (F == null ? void 0 : F.type) === "checkbox";
    }
    function f(M, O) {
      const F = l(M, O);
      return (F == null ? void 0 : F.options) || [];
    }
    function g(M) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[M] || "";
    }
    function p(M) {
      r.value && (e.addEffectToLayer(r.value.id, M), n.value = !1);
    }
    function y(M) {
      r.value && e.removeEffectFromLayer(r.value.id, M.id);
    }
    function v(M) {
      r.value && e.toggleEffect(r.value.id, M.id);
    }
    function m(M) {
      M.expanded = !M.expanded;
    }
    function b(M, O, F) {
      r.value && e.updateEffectParameter(r.value.id, M, O, F);
    }
    function S(M, O, F, $) {
      if (!r.value) return;
      const ne = r.value.effects.find((X) => X.id === M);
      if (!ne) return;
      const z = { ...ne.parameters[O].value, [F]: $ };
      e.updateEffectParameter(r.value.id, M, O, z);
    }
    function x(M) {
      return typeof M == "string" ? M : V0(M.r, M.g, M.b, M.a ?? 1);
    }
    function _(M, O, F) {
      const $ = z0(F);
      if ($ && r.value) {
        const ne = { r: $[0], g: $[1], b: $[2], a: $[3] };
        e.updateEffectParameter(r.value.id, M, O, ne);
      }
    }
    function C(M, O) {
      if (!r.value) return;
      const F = r.value.effects.find((ne) => ne.id === M), $ = F == null ? void 0 : F.parameters[O];
      $ && ($.animated = !$.animated, $.animated && $.keyframes.length === 0 && e.addKeyframe(r.value.id, $.id, $.value));
    }
    function k(M) {
      s.value && !s.value.contains(M.target) && (n.value = !1);
    }
    return Rt(() => window.addEventListener("mousedown", k)), pn(() => window.removeEventListener("mousedown", k)), (M, O) => (V(), B("div", fy, [
      h("div", py, [
        h("div", my, [
          O[1] || (O[1] = h("h3", null, "Effect Controls", -1)),
          r.value ? (V(), B("div", gy, [
            h("span", vy, pe(g(r.value.type)), 1),
            qe(" " + pe(r.value.name), 1)
          ])) : Te("", !0)
        ]),
        h("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: s
        }, [
          h("button", {
            class: "add-btn",
            onClick: O[0] || (O[0] = (F) => n.value = !n.value),
            disabled: !r.value
          }, [...O[2] || (O[2] = [
            h("span", { class: "icon" }, "+", -1),
            qe(" Add Effect ", -1)
          ])], 8, yy),
          n.value ? (V(), B("div", by, [
            (V(!0), B(Re, null, Ue(Fe(o), (F, $) => (V(), B("div", {
              key: $,
              class: "effect-category"
            }, [
              h("div", xy, [
                h("span", _y, pe(F.icon), 1),
                qe(" " + pe(F.label), 1)
              ]),
              h("div", wy, [
                (V(!0), B(Re, null, Ue(a($), (ne) => (V(), B("button", {
                  key: ne.key,
                  onClick: (oe) => p(ne.key)
                }, pe(ne.name), 9, Sy))), 128))
              ])
            ]))), 128))
          ])) : Te("", !0)
        ], 512)
      ]),
      h("div", Cy, [
        r.value ? !r.value.effects || r.value.effects.length === 0 ? (V(), B("div", Ty, " No effects applied ")) : (V(), B("div", My, [
          (V(!0), B(Re, null, Ue(r.value.effects, (F, $) => (V(), B("div", {
            key: F.id,
            class: Ie(["effect-item", { collapsed: !F.expanded }])
          }, [
            h("div", {
              class: "effect-header",
              onClick: (ne) => m(F)
            }, [
              h("div", Ey, [
                h("span", Py, pe(F.expanded ? "" : ""), 1),
                h("button", {
                  class: "icon-btn",
                  onClick: Je((ne) => v(F), ["stop"])
                }, [
                  h("span", {
                    class: Ie(["fx-icon", { disabled: !F.enabled }])
                  }, "fx", 2)
                ], 8, Dy),
                h("span", Ay, pe(F.name), 1)
              ]),
              h("div", Iy, [
                h("button", {
                  class: "icon-btn delete",
                  onClick: Je((ne) => y(F), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, Fy)
              ])
            ], 8, Oy),
            F.expanded ? (V(), B("div", Ly, [
              (V(!0), B(Re, null, Ue(F.parameters, (ne, oe) => {
                var z, X, T, H;
                return V(), B("div", {
                  key: oe,
                  class: "param-row"
                }, [
                  h("div", zy, [
                    h("span", {
                      class: "param-name",
                      title: String(oe)
                    }, pe(ne.name), 9, Ry),
                    h("button", {
                      class: Ie(["stopwatch", { active: ne.animated }]),
                      onClick: (ge) => C(F.id, String(oe)),
                      title: "Toggle Animation"
                    }, "", 10, Vy)
                  ]),
                  h("div", jy, [
                    ne.type === "number" ? (V(), B("div", $y, [
                      c(F.effectKey, String(oe)) ? (V(), ot(cn, {
                        key: 0,
                        modelValue: ne.value,
                        "onUpdate:modelValue": (ge) => b(F.id, String(oe), ge),
                        min: ((z = l(F.effectKey, String(oe))) == null ? void 0 : z.min) ?? 0,
                        max: ((X = l(F.effectKey, String(oe))) == null ? void 0 : X.max) ?? 100,
                        step: ((T = l(F.effectKey, String(oe))) == null ? void 0 : T.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Te("", !0),
                      Ae(Ne, {
                        modelValue: ne.value,
                        "onUpdate:modelValue": (ge) => b(F.id, String(oe), ge),
                        step: ((H = l(F.effectKey, String(oe))) == null ? void 0 : H.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : ne.type === "angle" ? (V(), B("div", By, [
                      Ae(ou, {
                        modelValue: ne.value,
                        "onUpdate:modelValue": (ge) => b(F.id, String(oe), ge),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ae(Ne, {
                        modelValue: ne.value,
                        "onUpdate:modelValue": (ge) => b(F.id, String(oe), ge),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : ne.type === "position" ? (V(), B("div", Wy, [
                      Ae(Ne, {
                        modelValue: ne.value.x,
                        "onUpdate:modelValue": (ge) => S(F.id, String(oe), "x", ge),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ae(Ne, {
                        modelValue: ne.value.y,
                        "onUpdate:modelValue": (ge) => S(F.id, String(oe), "y", ge),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : ne.type === "color" ? (V(), ot(Oi, {
                      key: 3,
                      modelValue: x(ne.value),
                      "onUpdate:modelValue": (ge) => _(F.id, String(oe), ge),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : ne.type === "enum" && d(F.effectKey, String(oe)) ? (V(), B("input", {
                      key: 4,
                      type: "checkbox",
                      checked: ne.value,
                      onChange: (ge) => b(F.id, String(oe), ge.target.checked)
                    }, null, 40, Uy)) : ne.type === "enum" ? (V(), B("select", {
                      key: 5,
                      value: ne.value,
                      onChange: (ge) => b(F.id, String(oe), ge.target.value),
                      class: "param-select"
                    }, [
                      (V(!0), B(Re, null, Ue(f(F.effectKey, String(oe)), (ge) => (V(), B("option", {
                        key: ge.value,
                        value: ge.value
                      }, pe(ge.label), 9, Hy))), 128))
                    ], 40, Ny)) : Te("", !0)
                  ])
                ]);
              }), 128))
            ])) : Te("", !0)
          ], 2))), 128))
        ])) : (V(), B("div", ky, " Select a layer to edit effects "))
      ])
    ]));
  }
}), Yy = /* @__PURE__ */ mt(Xy, [["__scopeId", "data-v-e8948500"]]), Gy = ["title"], Ky = /* @__PURE__ */ pt({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = Oe(() => n.property.animated ? n.property.keyframes.some((g) => g.frame === r.currentFrame) : !1), a = Oe(() => n.property.animated && n.property.keyframes.find((g) => g.frame === r.currentFrame) || null), l = Oe(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), u = Oe(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function c() {
      o.value ? f() : d();
    }
    function d() {
      const g = { frame: 0, value: 0, enabled: !1 }, p = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...g },
        outHandle: { ...g },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, s("animationToggled", !0)), n.property.keyframes.push(p), n.property.keyframes.sort((y, v) => y.frame - v.frame), s("keyframeAdded", p);
    }
    function f() {
      const g = a.value;
      if (!g) return;
      const p = n.property.keyframes.findIndex((y) => y.id === g.id);
      p >= 0 && (n.property.keyframes.splice(p, 1), s("keyframeRemoved", g.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, s("animationToggled", !1));
    }
    return (g, p) => (V(), B("button", {
      class: Ie(["keyframe-toggle", {
        animated: i.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: c,
      title: u.value
    }, [
      h("i", {
        class: Ie(["pi", l.value])
      }, null, 2)
    ], 10, Gy));
  }
}), dn = /* @__PURE__ */ mt(Ky, [["__scopeId", "data-v-b9271c8f"]]), Gr = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], Kr = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class qy {
  constructor() {
    He(this, "systemFonts", []);
    He(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    He(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const s of e)
        (!n.has(s.family) || s.style === "Regular") && n.set(s.family, {
          family: s.family,
          fullName: s.fullName,
          style: s.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((s, r) => s.family.localeCompare(r.family)), console.log(`[FontService] Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? console.log("[FontService] User denied font access permission") : console.error("[FontService] Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: Gr
    }), e.push({
      name: "Google Fonts",
      fonts: Kr.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return Gr.forEach((n) => e.add(n.family)), Kr.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const s = n.join(";"), r = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${s}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = r, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), console.log(`[FontService] Loaded Google Font: ${e}`);
    } catch (a) {
      console.error(`[FontService] Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return Gr.some((n) => n.family === e) ? !0 : Kr.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", r = document.createElement("canvas").getContext("2d");
    r.font = "72px monospace";
    const o = r.measureText(n).width;
    r.font = `72px "${e}", monospace`;
    const a = r.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return Gr;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return Kr;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (console.log("[FontService] Local Font Access API not available"), !1);
  }
}
const xc = new qy(), Zy = { class: "text-properties" }, Jy = { class: "property-section" }, Qy = { class: "section-content" }, e1 = { class: "property-group" }, t1 = { class: "property-group" }, n1 = { class: "font-row" }, s1 = { class: "property-row" }, i1 = { class: "control-with-keyframe" }, r1 = { class: "property-row" }, o1 = { class: "property-row" }, a1 = { class: "stroke-row" }, l1 = { class: "property-row" }, u1 = { class: "icon-toggle-group" }, c1 = { class: "property-section" }, d1 = { class: "expand-icon" }, h1 = {
  key: 0,
  class: "section-content"
}, f1 = { class: "property-row" }, p1 = ["value"], m1 = { class: "property-row" }, g1 = { class: "control-with-keyframe" }, v1 = { class: "property-row" }, y1 = { class: "property-section" }, b1 = { class: "expand-icon" }, x1 = {
  key: 0,
  class: "section-content"
}, _1 = { class: "property-row" }, w1 = { class: "property-row" }, S1 = { class: "multi-value" }, C1 = { class: "property-row" }, k1 = { class: "property-row" }, T1 = { class: "property-section" }, M1 = { class: "expand-icon" }, O1 = {
  key: 0,
  class: "section-content"
}, E1 = { class: "property-row checkbox-row" }, P1 = { class: "property-row" }, D1 = { class: "control-with-keyframe" }, A1 = { class: "property-row" }, I1 = { class: "control-with-keyframe" }, F1 = { class: "property-row" }, L1 = { class: "property-row" }, z1 = { class: "control-with-keyframe" }, R1 = { class: "property-row" }, V1 = { class: "multi-value" }, j1 = /* @__PURE__ */ pt({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = me(/* @__PURE__ */ new Set(["pathOptions", "moreOptions", "advanced"])), a = Oe(() => n.layer.data || {
      text: "Text",
      fontFamily: "Arial",
      fontSize: 48,
      fontWeight: "400",
      fontStyle: "normal",
      fill: "#ffffff",
      stroke: "",
      strokeWidth: 0,
      tracking: 0,
      lineSpacing: 0,
      lineAnchor: 0,
      characterOffset: 0,
      characterValue: 0,
      blur: { x: 0, y: 0 },
      letterSpacing: 0,
      lineHeight: 1.2,
      textAlign: "left",
      pathLayerId: null,
      pathOffset: 0,
      pathAlign: "left",
      anchorPointGrouping: "character",
      groupingAlignment: { x: 0, y: 0 },
      fillAndStroke: "fill-over-stroke",
      interCharacterBlending: "normal",
      perCharacter3D: !1
    }), l = Oe(() => r.layers.filter((y) => y.type === "spline"));
    function u(y) {
      o.value.has(y) ? o.value.delete(y) : o.value.add(y);
    }
    function c(y) {
      return n.layer.properties.find((v) => v.name === y);
    }
    function d(y, v) {
      const m = c(y);
      m && (m.value = v, r.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
      const S = {
        "Font Size": "fontSize",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Character Value": "characterValue",
        "Path Offset": "pathOffset",
        "Stroke Width": "strokeWidth"
      }[y];
      S && a.value[S] !== void 0 && (a.value[S] = v), s("update");
    }
    function f(y, v, m) {
      const b = c(y);
      b && typeof b.value == "object" && (b.value = { ...b.value, [v]: m }, r.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), y === "Grouping Alignment" ? a.value.groupingAlignment[v] = m : y === "Blur" && (a.value.blur[v] = m), s("update"));
    }
    function g() {
      xc.ensureFont(a.value.fontFamily), s("update");
    }
    function p(y) {
      a.value.textAlign = y, s("update");
    }
    return Rt(async () => {
      await xc.initialize();
    }), (y, v) => (V(), B("div", Zy, [
      h("div", Jy, [
        v[50] || (v[50] = h("div", { class: "section-header" }, [
          h("span", { class: "expand-icon" }, ""),
          h("span", null, "Text")
        ], -1)),
        h("div", Qy, [
          h("div", e1, [
            v[42] || (v[42] = h("label", null, "Source Text", -1)),
            tt(h("textarea", {
              "onUpdate:modelValue": v[0] || (v[0] = (m) => a.value.text = m),
              class: "text-input",
              rows: "2",
              onInput: v[1] || (v[1] = (m) => s("update"))
            }, null, 544), [
              [$t, a.value.text]
            ])
          ]),
          h("div", t1, [
            v[45] || (v[45] = h("label", null, "Font", -1)),
            h("div", n1, [
              tt(h("select", {
                "onUpdate:modelValue": v[2] || (v[2] = (m) => a.value.fontFamily = m),
                class: "font-select",
                onChange: g
              }, [...v[43] || (v[43] = [
                xr('<option value="Arial" data-v-53fb6379>Arial</option><option value="Helvetica" data-v-53fb6379>Helvetica</option><option value="Times New Roman" data-v-53fb6379>Times New Roman</option><option value="Courier New" data-v-53fb6379>Courier New</option><option value="Georgia" data-v-53fb6379>Georgia</option><option value="Verdana" data-v-53fb6379>Verdana</option>', 6)
              ])], 544), [
                [nn, a.value.fontFamily]
              ]),
              tt(h("select", {
                "onUpdate:modelValue": v[3] || (v[3] = (m) => a.value.fontWeight = m),
                class: "weight-select",
                onChange: v[4] || (v[4] = (m) => s("update"))
              }, [...v[44] || (v[44] = [
                h("option", { value: "400" }, "Regular", -1),
                h("option", { value: "500" }, "Medium", -1),
                h("option", { value: "600" }, "Semibold", -1),
                h("option", { value: "700" }, "Bold", -1)
              ])], 544), [
                [nn, a.value.fontWeight]
              ])
            ])
          ]),
          h("div", s1, [
            v[46] || (v[46] = h("label", null, "Size", -1)),
            h("div", i1, [
              Ae(Fe(Ne), {
                modelValue: a.value.fontSize,
                "onUpdate:modelValue": [
                  v[5] || (v[5] = (m) => a.value.fontSize = m),
                  v[6] || (v[6] = (m) => d("Font Size", m))
                ],
                min: 1,
                max: 500,
                unit: "px"
              }, null, 8, ["modelValue"]),
              Ae(dn, {
                property: c("Font Size"),
                layerId: i.layer.id
              }, null, 8, ["property", "layerId"])
            ])
          ]),
          h("div", r1, [
            v[47] || (v[47] = h("label", null, "Fill", -1)),
            Ae(Fe(Oi), {
              modelValue: a.value.fill,
              "onUpdate:modelValue": v[7] || (v[7] = (m) => {
                a.value.fill = m, s("update");
              })
            }, null, 8, ["modelValue"])
          ]),
          h("div", o1, [
            v[48] || (v[48] = h("label", null, "Stroke", -1)),
            h("div", a1, [
              Ae(Fe(Oi), {
                modelValue: a.value.stroke || "#000000",
                "onUpdate:modelValue": v[8] || (v[8] = (m) => {
                  a.value.stroke = m, s("update");
                })
              }, null, 8, ["modelValue"]),
              Ae(Fe(Ne), {
                modelValue: a.value.strokeWidth,
                "onUpdate:modelValue": [
                  v[9] || (v[9] = (m) => a.value.strokeWidth = m),
                  v[10] || (v[10] = (m) => s("update"))
                ],
                min: 0,
                max: 100,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ]),
          h("div", l1, [
            v[49] || (v[49] = h("label", null, "Alignment", -1)),
            h("div", u1, [
              h("button", {
                class: Ie({ active: a.value.textAlign === "left" }),
                onClick: v[11] || (v[11] = (m) => p("left")),
                title: "Left"
              }, "", 2),
              h("button", {
                class: Ie({ active: a.value.textAlign === "center" }),
                onClick: v[12] || (v[12] = (m) => p("center")),
                title: "Center"
              }, "", 2),
              h("button", {
                class: Ie({ active: a.value.textAlign === "right" }),
                onClick: v[13] || (v[13] = (m) => p("right")),
                title: "Right"
              }, "", 2)
            ])
          ])
        ])
      ]),
      h("div", c1, [
        h("div", {
          class: "section-header",
          onClick: v[14] || (v[14] = (m) => u("pathOptions"))
        }, [
          h("span", d1, pe(o.value.has("pathOptions") ? "" : ""), 1),
          v[51] || (v[51] = h("span", null, "Path Options", -1))
        ]),
        o.value.has("pathOptions") ? (V(), B("div", h1, [
          h("div", f1, [
            v[53] || (v[53] = h("label", null, "Path", -1)),
            tt(h("select", {
              "onUpdate:modelValue": v[15] || (v[15] = (m) => a.value.pathLayerId = m),
              class: "full-select",
              onChange: v[16] || (v[16] = (m) => s("update"))
            }, [
              v[52] || (v[52] = h("option", { value: null }, "None", -1)),
              (V(!0), B(Re, null, Ue(l.value, (m) => (V(), B("option", {
                key: m.id,
                value: m.id
              }, pe(m.name), 9, p1))), 128))
            ], 544), [
              [nn, a.value.pathLayerId]
            ])
          ]),
          a.value.pathLayerId ? (V(), B(Re, { key: 0 }, [
            h("div", m1, [
              v[54] || (v[54] = h("label", null, "Path Offset", -1)),
              h("div", g1, [
                Ae(Fe(Ne), {
                  modelValue: (a.value.pathOffset || 0) * 100,
                  "onUpdate:modelValue": v[17] || (v[17] = (m) => {
                    a.value.pathOffset = m / 100, d("Path Offset", m / 100);
                  }),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"]),
                Ae(dn, {
                  property: c("Path Offset"),
                  layerId: i.layer.id
                }, null, 8, ["property", "layerId"])
              ])
            ]),
            h("div", v1, [
              v[56] || (v[56] = h("label", null, "Path Align", -1)),
              tt(h("select", {
                "onUpdate:modelValue": v[18] || (v[18] = (m) => a.value.pathAlign = m),
                class: "full-select",
                onChange: v[19] || (v[19] = (m) => s("update"))
              }, [...v[55] || (v[55] = [
                h("option", { value: "left" }, "Left", -1),
                h("option", { value: "center" }, "Center", -1),
                h("option", { value: "right" }, "Right", -1)
              ])], 544), [
                [nn, a.value.pathAlign]
              ])
            ])
          ], 64)) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", y1, [
        h("div", {
          class: "section-header",
          onClick: v[20] || (v[20] = (m) => u("moreOptions"))
        }, [
          h("span", b1, pe(o.value.has("moreOptions") ? "" : ""), 1),
          v[57] || (v[57] = h("span", null, "More Options", -1))
        ]),
        o.value.has("moreOptions") ? (V(), B("div", x1, [
          h("div", _1, [
            v[59] || (v[59] = h("label", null, "Grouping", -1)),
            tt(h("select", {
              "onUpdate:modelValue": v[21] || (v[21] = (m) => a.value.anchorPointGrouping = m),
              class: "full-select",
              onChange: v[22] || (v[22] = (m) => s("update"))
            }, [...v[58] || (v[58] = [
              h("option", { value: "character" }, "Character", -1),
              h("option", { value: "word" }, "Word", -1),
              h("option", { value: "line" }, "Line", -1),
              h("option", { value: "all" }, "All", -1)
            ])], 544), [
              [nn, a.value.anchorPointGrouping]
            ])
          ]),
          h("div", w1, [
            v[60] || (v[60] = h("label", null, "Alignment", -1)),
            h("div", S1, [
              Ae(Fe(Ne), {
                modelValue: a.value.groupingAlignment.x,
                min: -100,
                max: 100,
                unit: "X%",
                "onUpdate:modelValue": v[23] || (v[23] = (m) => f("Grouping Alignment", "x", m))
              }, null, 8, ["modelValue"]),
              Ae(Fe(Ne), {
                modelValue: a.value.groupingAlignment.y,
                min: -100,
                max: 100,
                unit: "Y%",
                "onUpdate:modelValue": v[24] || (v[24] = (m) => f("Grouping Alignment", "y", m))
              }, null, 8, ["modelValue"])
            ]),
            Ae(dn, {
              property: c("Grouping Alignment"),
              layerId: i.layer.id
            }, null, 8, ["property", "layerId"])
          ]),
          h("div", C1, [
            v[62] || (v[62] = h("label", null, "Fill & Stroke", -1)),
            tt(h("select", {
              "onUpdate:modelValue": v[25] || (v[25] = (m) => a.value.fillAndStroke = m),
              class: "full-select",
              onChange: v[26] || (v[26] = (m) => s("update"))
            }, [...v[61] || (v[61] = [
              h("option", { value: "fill-over-stroke" }, "Fill Over Stroke", -1),
              h("option", { value: "stroke-over-fill" }, "Stroke Over Fill", -1)
            ])], 544), [
              [nn, a.value.fillAndStroke]
            ])
          ]),
          h("div", k1, [
            v[64] || (v[64] = h("label", null, "Blending", -1)),
            tt(h("select", {
              "onUpdate:modelValue": v[27] || (v[27] = (m) => a.value.interCharacterBlending = m),
              class: "full-select",
              onChange: v[28] || (v[28] = (m) => s("update"))
            }, [...v[63] || (v[63] = [
              h("option", { value: "normal" }, "Normal", -1),
              h("option", { value: "multiply" }, "Multiply", -1),
              h("option", { value: "screen" }, "Screen", -1),
              h("option", { value: "overlay" }, "Overlay", -1)
            ])], 544), [
              [nn, a.value.interCharacterBlending]
            ])
          ])
        ])) : Te("", !0)
      ]),
      h("div", T1, [
        h("div", {
          class: "section-header",
          onClick: v[29] || (v[29] = (m) => u("advanced"))
        }, [
          h("span", M1, pe(o.value.has("advanced") ? "" : ""), 1),
          v[65] || (v[65] = h("span", null, "Advanced", -1))
        ]),
        o.value.has("advanced") ? (V(), B("div", O1, [
          h("div", E1, [
            h("label", null, [
              tt(h("input", {
                type: "checkbox",
                "onUpdate:modelValue": v[30] || (v[30] = (m) => a.value.perCharacter3D = m),
                onChange: v[31] || (v[31] = (m) => s("update"))
              }, null, 544), [
                [No, a.value.perCharacter3D]
              ]),
              v[66] || (v[66] = qe(" Enable Per-character 3D ", -1))
            ])
          ]),
          h("div", P1, [
            v[67] || (v[67] = h("label", null, "Tracking", -1)),
            h("div", D1, [
              Ae(Fe(Ne), {
                modelValue: a.value.tracking,
                "onUpdate:modelValue": [
                  v[32] || (v[32] = (m) => a.value.tracking = m),
                  v[33] || (v[33] = (m) => d("Tracking", m))
                ],
                unit: "em"
              }, null, 8, ["modelValue"]),
              Ae(dn, {
                property: c("Tracking"),
                layerId: i.layer.id
              }, null, 8, ["property", "layerId"])
            ])
          ]),
          h("div", A1, [
            v[68] || (v[68] = h("label", null, "Line Spacing", -1)),
            h("div", I1, [
              Ae(Fe(Ne), {
                modelValue: a.value.lineSpacing,
                "onUpdate:modelValue": [
                  v[34] || (v[34] = (m) => a.value.lineSpacing = m),
                  v[35] || (v[35] = (m) => d("Line Spacing", m))
                ],
                unit: "px"
              }, null, 8, ["modelValue"]),
              Ae(dn, {
                property: c("Line Spacing"),
                layerId: i.layer.id
              }, null, 8, ["property", "layerId"])
            ])
          ]),
          h("div", F1, [
            v[69] || (v[69] = h("label", null, "Line Anchor", -1)),
            Ae(Fe(Ne), {
              modelValue: a.value.lineAnchor,
              "onUpdate:modelValue": [
                v[36] || (v[36] = (m) => a.value.lineAnchor = m),
                v[37] || (v[37] = (m) => s("update"))
              ],
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"])
          ]),
          h("div", L1, [
            v[70] || (v[70] = h("label", null, "Char Offset", -1)),
            h("div", z1, [
              Ae(Fe(Ne), {
                modelValue: a.value.characterOffset,
                "onUpdate:modelValue": [
                  v[38] || (v[38] = (m) => a.value.characterOffset = m),
                  v[39] || (v[39] = (m) => d("Character Offset", m))
                ],
                precision: 0
              }, null, 8, ["modelValue"]),
              Ae(dn, {
                property: c("Character Offset"),
                layerId: i.layer.id
              }, null, 8, ["property", "layerId"])
            ])
          ]),
          h("div", R1, [
            v[71] || (v[71] = h("label", null, "Blur", -1)),
            h("div", V1, [
              Ae(Fe(Ne), {
                modelValue: a.value.blur.x,
                unit: "X",
                "onUpdate:modelValue": v[40] || (v[40] = (m) => f("Blur", "x", m))
              }, null, 8, ["modelValue"]),
              Ae(Fe(Ne), {
                modelValue: a.value.blur.y,
                unit: "Y",
                "onUpdate:modelValue": v[41] || (v[41] = (m) => f("Blur", "y", m))
              }, null, 8, ["modelValue"])
            ]),
            Ae(dn, {
              property: c("Blur"),
              layerId: i.layer.id
            }, null, 8, ["property", "layerId"])
          ])
        ])) : Te("", !0)
      ])
    ]));
  }
}), $1 = /* @__PURE__ */ mt(j1, [["__scopeId", "data-v-53fb6379"]]), B1 = { class: "particle-properties" }, W1 = { class: "property-section" }, U1 = {
  key: 0,
  class: "section-content"
}, N1 = { class: "property-row" }, H1 = ["value"], X1 = { class: "value-display" }, Y1 = { class: "property-row" }, G1 = ["value"], K1 = { class: "value-display" }, q1 = { class: "property-row" }, Z1 = ["value"], J1 = { class: "value-display" }, Q1 = { class: "property-row" }, eb = ["value"], tb = { class: "value-display" }, nb = { class: "property-row" }, sb = ["value"], ib = { class: "value-display" }, rb = { class: "property-row" }, ob = ["value"], ab = { class: "property-section" }, lb = {
  key: 0,
  class: "section-content"
}, ub = ["onClick"], cb = ["value", "onInput"], db = { class: "enabled-toggle" }, hb = ["checked", "onChange"], fb = ["onClick"], pb = {
  key: 0,
  class: "emitter-content"
}, mb = { class: "property-row" }, gb = ["value", "onInput"], vb = { class: "value-display" }, yb = { class: "property-row" }, bb = ["value", "onInput"], xb = { class: "value-display" }, _b = { class: "property-row" }, wb = ["value", "onInput"], Sb = { class: "value-display" }, Cb = { class: "property-row" }, kb = ["value", "onInput"], Tb = { class: "value-display" }, Mb = { class: "property-row" }, Ob = ["value", "onInput"], Eb = { class: "value-display" }, Pb = { class: "property-row" }, Db = ["value", "onInput"], Ab = { class: "value-display" }, Ib = { class: "property-row" }, Fb = ["value", "onInput"], Lb = { class: "value-display" }, zb = { class: "property-row" }, Rb = ["value", "onInput"], Vb = { class: "value-display" }, jb = { class: "property-row" }, $b = ["value", "onInput"], Bb = { class: "property-row" }, Wb = ["value", "onInput"], Ub = { class: "value-display" }, Nb = { class: "property-row" }, Hb = ["value", "onInput"], Xb = { class: "value-display" }, Yb = { class: "property-row" }, Gb = ["value", "onInput"], Kb = { class: "value-display" }, qb = { class: "property-row checkbox-row" }, Zb = ["checked", "onChange"], Jb = {
  key: 0,
  class: "property-row"
}, Qb = ["value", "onInput"], ex = { class: "value-display" }, tx = {
  key: 0,
  class: "empty-message"
}, nx = { class: "property-section" }, sx = {
  key: 0,
  class: "section-content"
}, ix = { class: "force-tabs" }, rx = {
  key: 0,
  class: "force-list"
}, ox = { class: "force-header" }, ax = ["value", "onInput"], lx = { class: "enabled-toggle" }, ux = ["checked", "onChange"], cx = ["onClick"], dx = { class: "property-row" }, hx = ["value", "onInput"], fx = { class: "value-display" }, px = { class: "property-row" }, mx = ["value", "onInput"], gx = { class: "value-display" }, vx = { class: "property-row" }, yx = ["value", "onInput"], bx = { class: "value-display" }, xx = { class: "property-row" }, _x = ["value", "onInput"], wx = { class: "value-display" }, Sx = { class: "property-row" }, Cx = ["value", "onChange"], kx = {
  key: 1,
  class: "force-list"
}, Tx = { class: "force-header" }, Mx = ["value", "onInput"], Ox = { class: "enabled-toggle" }, Ex = ["checked", "onChange"], Px = ["onClick"], Dx = { class: "property-row" }, Ax = ["value", "onInput"], Ix = { class: "value-display" }, Fx = { class: "property-row" }, Lx = ["value", "onInput"], zx = { class: "value-display" }, Rx = { class: "property-row" }, Vx = ["value", "onInput"], jx = { class: "value-display" }, $x = { class: "property-row" }, Bx = ["value", "onInput"], Wx = { class: "value-display" }, Ux = { class: "property-row" }, Nx = ["value", "onInput"], Hx = { class: "value-display" }, Xx = { class: "property-row" }, Yx = ["value", "onInput"], Gx = { class: "value-display" }, Kx = { class: "property-section" }, qx = {
  key: 0,
  class: "section-content"
}, Zx = { class: "force-header" }, Jx = { class: "enabled-toggle" }, Qx = ["checked", "onChange"], e_ = ["onClick"], t_ = { class: "property-row" }, n_ = ["value", "onInput"], s_ = { class: "value-display" }, i_ = { class: "property-row" }, r_ = ["value", "onInput"], o_ = { class: "value-display" }, a_ = { class: "property-row" }, l_ = ["value", "onInput"], u_ = { class: "value-display" }, c_ = {
  key: 0,
  class: "empty-message"
}, d_ = { class: "property-section" }, h_ = {
  key: 0,
  class: "section-content"
}, f_ = { class: "force-header" }, p_ = ["value", "onChange"], m_ = ["value"], g_ = { class: "enabled-toggle" }, v_ = ["checked", "onChange"], y_ = ["onClick"], b_ = { class: "property-row" }, x_ = ["value", "onChange"], __ = { class: "property-row" }, w_ = ["value", "onInput"], S_ = { class: "value-display" }, C_ = { class: "property-row" }, k_ = ["value", "onInput"], T_ = { class: "value-display" }, M_ = { class: "property-row" }, O_ = ["value", "onInput"], E_ = { class: "value-display" }, P_ = { class: "property-row" }, D_ = ["value", "onInput"], A_ = { class: "value-display" }, I_ = { class: "property-row" }, F_ = ["value", "onInput"], L_ = { class: "value-display" }, z_ = { class: "property-row" }, R_ = ["value", "onInput"], V_ = { class: "value-display" }, j_ = { class: "property-row" }, $_ = ["value", "onInput"], B_ = {
  key: 0,
  class: "empty-message"
}, W_ = { class: "property-section" }, U_ = {
  key: 0,
  class: "section-content"
}, N_ = { class: "modulation-header" }, H_ = ["value", "onChange"], X_ = ["value"], Y_ = ["onClick"], G_ = { class: "property-row" }, K_ = ["value", "onChange"], q_ = { class: "property-row" }, Z_ = ["value", "onInput"], J_ = { class: "property-row" }, Q_ = ["value", "onInput"], ew = { class: "property-row" }, tw = ["value", "onChange"], nw = {
  key: 0,
  class: "empty-message"
}, sw = { class: "property-section" }, iw = {
  key: 0,
  class: "section-content"
}, rw = { class: "property-row" }, ow = ["value"], aw = { class: "property-row" }, lw = ["value"], uw = { class: "property-row checkbox-row" }, cw = ["checked"], dw = {
  key: 0,
  class: "property-row"
}, hw = ["value"], fw = { class: "value-display" }, pw = { class: "property-row checkbox-row" }, mw = ["checked"], gw = {
  key: 1,
  class: "property-row"
}, vw = ["value"], yw = { class: "value-display" }, bw = {
  key: 2,
  class: "property-row"
}, xw = ["value"], _w = { class: "value-display" }, ww = { class: "property-row checkbox-row" }, Sw = ["checked"], Cw = {
  key: 3,
  class: "property-row"
}, kw = ["value"], Tw = { class: "value-display" }, Mw = {
  key: 4,
  class: "property-row"
}, Ow = ["value"], Ew = { class: "value-display" }, Pw = {
  key: 5,
  class: "property-row"
}, Dw = ["value"], Aw = { class: "value-display" }, Iw = {
  key: 6,
  class: "property-row"
}, Fw = ["value"], Lw = { class: "value-display" }, zw = {
  key: 7,
  class: "property-row checkbox-row"
}, Rw = ["checked"], Vw = { class: "particle-count" }, jw = /* @__PURE__ */ pt({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = me(/* @__PURE__ */ new Set(["system", "emitters"])), o = me(/* @__PURE__ */ new Set()), a = me("wells"), l = Oe(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), u = Oe(() => l.value.systemConfig), c = Oe(() => l.value.emitters), d = Oe(() => l.value.gravityWells), f = Oe(() => l.value.vortices), g = Oe(() => l.value.modulations), p = Oe(() => l.value.renderOptions), y = Oe(() => l.value.turbulenceFields || []), v = Oe(() => l.value.subEmitters || []), m = Oe(() => p.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), b = Oe(() => n.particleCount);
    function S(ae) {
      r.value.has(ae) ? r.value.delete(ae) : r.value.add(ae);
    }
    function x(ae) {
      o.value.has(ae) ? o.value.delete(ae) : o.value.add(ae);
    }
    function _(ae, D) {
      s("update", {
        systemConfig: { ...u.value, [ae]: D }
      });
    }
    function C(ae, D, R) {
      const P = c.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { emitters: P });
    }
    function k(ae, D) {
      const R = fe(D);
      C(ae, "color", R);
    }
    function M() {
      const ae = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${c.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      s("update", { emitters: [...c.value, ae] }), o.value.add(ae.id);
    }
    function O(ae) {
      s("update", { emitters: c.value.filter((D) => D.id !== ae) });
    }
    function F(ae, D, R) {
      const P = d.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { gravityWells: P });
    }
    function $() {
      const ae = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      s("update", { gravityWells: [...d.value, ae] });
    }
    function ne(ae) {
      s("update", { gravityWells: d.value.filter((D) => D.id !== ae) });
    }
    function oe(ae, D, R) {
      const P = f.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { vortices: P });
    }
    function z() {
      const ae = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${f.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      s("update", { vortices: [...f.value, ae] });
    }
    function X(ae) {
      s("update", { vortices: f.value.filter((D) => D.id !== ae) });
    }
    function T(ae, D, R) {
      const P = g.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { modulations: P });
    }
    function H() {
      const ae = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      s("update", { modulations: [...g.value, ae] });
    }
    function ge(ae) {
      s("update", { modulations: g.value.filter((D) => D.id !== ae) });
    }
    function K(ae, D) {
      s("update", {
        renderOptions: { ...p.value, [ae]: D }
      });
    }
    function re(ae, D) {
      s("update", {
        renderOptions: {
          ...p.value,
          connections: { ...m.value, [ae]: D }
        }
      });
    }
    function ie(ae, D, R) {
      const P = y.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { turbulenceFields: P });
    }
    function be() {
      const ae = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      s("update", { turbulenceFields: [...y.value, ae] });
    }
    function J(ae) {
      s("update", { turbulenceFields: y.value.filter((D) => D.id !== ae) });
    }
    function ee(ae, D, R) {
      const P = v.value.map(
        (Y) => Y.id === ae ? { ...Y, [D]: R } : Y
      );
      s("update", { subEmitters: P });
    }
    function ve(ae, D) {
      const R = fe(D);
      ee(ae, "color", R);
    }
    function G() {
      const ae = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      s("update", { subEmitters: [...v.value, ae] });
    }
    function N(ae) {
      s("update", { subEmitters: v.value.filter((D) => D.id !== ae) });
    }
    function te(ae) {
      return "#" + ae.map((D) => D.toString(16).padStart(2, "0")).join("");
    }
    function fe(ae) {
      const D = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(ae);
      return D ? [parseInt(D[1], 16), parseInt(D[2], 16), parseInt(D[3], 16)] : [255, 255, 255];
    }
    return (ae, D) => (V(), B("div", B1, [
      h("div", W1, [
        h("div", {
          class: "section-header",
          onClick: D[0] || (D[0] = (R) => S("system"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[30] || (D[30] = h("span", null, "System Settings", -1))
        ]),
        r.value.has("system") ? (V(), B("div", U1, [
          h("div", N1, [
            D[31] || (D[31] = h("label", null, "Max Particles", -1)),
            h("input", {
              type: "range",
              value: u.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: D[1] || (D[1] = (R) => _("maxParticles", Number(R.target.value)))
            }, null, 40, H1),
            h("span", X1, pe(u.value.maxParticles), 1)
          ]),
          h("div", Y1, [
            D[32] || (D[32] = h("label", null, "Gravity", -1)),
            h("input", {
              type: "range",
              value: u.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: D[2] || (D[2] = (R) => _("gravity", Number(R.target.value)))
            }, null, 40, G1),
            h("span", K1, pe(u.value.gravity), 1)
          ]),
          h("div", q1, [
            D[33] || (D[33] = h("label", null, "Wind Strength", -1)),
            h("input", {
              type: "range",
              value: u.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: D[3] || (D[3] = (R) => _("windStrength", Number(R.target.value)))
            }, null, 40, Z1),
            h("span", J1, pe(u.value.windStrength), 1)
          ]),
          h("div", Q1, [
            D[34] || (D[34] = h("label", null, "Wind Direction", -1)),
            h("input", {
              type: "range",
              value: u.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: D[4] || (D[4] = (R) => _("windDirection", Number(R.target.value)))
            }, null, 40, eb),
            h("span", tb, pe(u.value.windDirection) + "", 1)
          ]),
          h("div", nb, [
            D[35] || (D[35] = h("label", null, "Friction", -1)),
            h("input", {
              type: "range",
              value: u.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: D[5] || (D[5] = (R) => _("friction", Number(R.target.value)))
            }, null, 40, sb),
            h("span", ib, pe(u.value.friction.toFixed(2)), 1)
          ]),
          h("div", rb, [
            D[37] || (D[37] = h("label", null, "Boundary", -1)),
            h("select", {
              value: u.value.boundaryBehavior,
              onChange: D[6] || (D[6] = (R) => _("boundaryBehavior", R.target.value))
            }, [...D[36] || (D[36] = [
              h("option", { value: "kill" }, "Kill", -1),
              h("option", { value: "bounce" }, "Bounce", -1),
              h("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, ob)
          ])
        ])) : Te("", !0)
      ]),
      h("div", ab, [
        h("div", {
          class: "section-header",
          onClick: D[7] || (D[7] = (R) => S("emitters"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[39] || (D[39] = h("span", null, "Emitters", -1)),
          h("button", {
            class: "add-btn",
            onClick: Je(M, ["stop"]),
            title: "Add Emitter"
          }, [...D[38] || (D[38] = [
            h("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("emitters") ? (V(), B("div", lb, [
          (V(!0), B(Re, null, Ue(c.value, (R) => (V(), B("div", {
            key: R.id,
            class: "emitter-item"
          }, [
            h("div", {
              class: "emitter-header",
              onClick: (P) => x(R.id)
            }, [
              h("i", {
                class: Ie(["pi", o.value.has(R.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              h("input", {
                type: "text",
                value: R.name,
                onInput: (P) => C(R.id, "name", P.target.value),
                onClick: D[8] || (D[8] = Je(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, cb),
              h("label", db, [
                h("input", {
                  type: "checkbox",
                  checked: R.enabled,
                  onChange: (P) => C(R.id, "enabled", P.target.checked),
                  onClick: D[9] || (D[9] = Je(() => {
                  }, ["stop"]))
                }, null, 40, hb)
              ]),
              h("button", {
                class: "remove-btn",
                onClick: Je((P) => O(R.id), ["stop"]),
                title: "Remove"
              }, [...D[40] || (D[40] = [
                h("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, fb)
            ], 8, ub),
            o.value.has(R.id) ? (V(), B("div", pb, [
              h("div", mb, [
                D[41] || (D[41] = h("label", null, "Position X", -1)),
                h("input", {
                  type: "range",
                  value: R.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => C(R.id, "x", Number(P.target.value))
                }, null, 40, gb),
                h("span", vb, pe(R.x.toFixed(2)), 1)
              ]),
              h("div", yb, [
                D[42] || (D[42] = h("label", null, "Position Y", -1)),
                h("input", {
                  type: "range",
                  value: R.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => C(R.id, "y", Number(P.target.value))
                }, null, 40, bb),
                h("span", xb, pe(R.y.toFixed(2)), 1)
              ]),
              h("div", _b, [
                D[43] || (D[43] = h("label", null, "Direction", -1)),
                h("input", {
                  type: "range",
                  value: R.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (P) => C(R.id, "direction", Number(P.target.value))
                }, null, 40, wb),
                h("span", Sb, pe(R.direction) + "", 1)
              ]),
              h("div", Cb, [
                D[44] || (D[44] = h("label", null, "Spread", -1)),
                h("input", {
                  type: "range",
                  value: R.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (P) => C(R.id, "spread", Number(P.target.value))
                }, null, 40, kb),
                h("span", Tb, pe(R.spread) + "", 1)
              ]),
              h("div", Mb, [
                D[45] || (D[45] = h("label", null, "Speed", -1)),
                h("input", {
                  type: "range",
                  value: R.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (P) => C(R.id, "speed", Number(P.target.value))
                }, null, 40, Ob),
                h("span", Eb, pe(R.speed), 1)
              ]),
              h("div", Pb, [
                D[46] || (D[46] = h("label", null, "Speed Variance", -1)),
                h("input", {
                  type: "range",
                  value: R.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (P) => C(R.id, "speedVariance", Number(P.target.value))
                }, null, 40, Db),
                h("span", Ab, pe(R.speedVariance), 1)
              ]),
              h("div", Ib, [
                D[47] || (D[47] = h("label", null, "Size", -1)),
                h("input", {
                  type: "range",
                  value: R.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (P) => C(R.id, "size", Number(P.target.value))
                }, null, 40, Fb),
                h("span", Lb, pe(R.size) + "px", 1)
              ]),
              h("div", zb, [
                D[48] || (D[48] = h("label", null, "Size Variance", -1)),
                h("input", {
                  type: "range",
                  value: R.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (P) => C(R.id, "sizeVariance", Number(P.target.value))
                }, null, 40, Rb),
                h("span", Vb, pe(R.sizeVariance), 1)
              ]),
              h("div", jb, [
                D[49] || (D[49] = h("label", null, "Color", -1)),
                h("input", {
                  type: "color",
                  value: te(R.color),
                  onInput: (P) => k(R.id, P.target.value)
                }, null, 40, $b)
              ]),
              h("div", Bb, [
                D[50] || (D[50] = h("label", null, "Emission Rate", -1)),
                h("input", {
                  type: "range",
                  value: R.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (P) => C(R.id, "emissionRate", Number(P.target.value))
                }, null, 40, Wb),
                h("span", Ub, pe(R.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              h("div", Nb, [
                D[51] || (D[51] = h("label", null, "Lifetime", -1)),
                h("input", {
                  type: "range",
                  value: R.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (P) => C(R.id, "particleLifetime", Number(P.target.value))
                }, null, 40, Hb),
                h("span", Xb, pe(R.particleLifetime) + "f", 1)
              ]),
              h("div", Yb, [
                D[52] || (D[52] = h("label", null, "Initial Burst", -1)),
                h("input", {
                  type: "range",
                  value: R.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (P) => C(R.id, "initialBurst", Number(P.target.value))
                }, null, 40, Gb),
                h("span", Kb, pe((R.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              h("div", qb, [
                h("label", null, [
                  h("input", {
                    type: "checkbox",
                    checked: R.burstOnBeat,
                    onChange: (P) => C(R.id, "burstOnBeat", P.target.checked)
                  }, null, 40, Zb),
                  D[53] || (D[53] = qe(" Burst on Beat ", -1))
                ])
              ]),
              R.burstOnBeat ? (V(), B("div", Jb, [
                D[54] || (D[54] = h("label", null, "Burst Count", -1)),
                h("input", {
                  type: "range",
                  value: R.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (P) => C(R.id, "burstCount", Number(P.target.value))
                }, null, 40, Qb),
                h("span", ex, pe(R.burstCount), 1)
              ])) : Te("", !0)
            ])) : Te("", !0)
          ]))), 128)),
          c.value.length === 0 ? (V(), B("div", tx, " No emitters. Click + to add one. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", nx, [
        h("div", {
          class: "section-header",
          onClick: D[10] || (D[10] = (R) => S("forces"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[55] || (D[55] = h("span", null, "Force Fields", -1))
        ]),
        r.value.has("forces") ? (V(), B("div", sx, [
          h("div", ix, [
            h("button", {
              class: Ie({ active: a.value === "wells" }),
              onClick: D[11] || (D[11] = (R) => a.value = "wells")
            }, " Gravity Wells ", 2),
            h("button", {
              class: Ie({ active: a.value === "vortices" }),
              onClick: D[12] || (D[12] = (R) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (V(), B("div", rx, [
            h("button", {
              class: "add-btn full-width",
              onClick: $
            }, [...D[56] || (D[56] = [
              h("i", { class: "pi pi-plus" }, null, -1),
              qe(" Add Gravity Well ", -1)
            ])]),
            (V(!0), B(Re, null, Ue(d.value, (R) => (V(), B("div", {
              key: R.id,
              class: "force-item"
            }, [
              h("div", ox, [
                h("input", {
                  type: "text",
                  value: R.name,
                  onInput: (P) => F(R.id, "name", P.target.value),
                  class: "force-name"
                }, null, 40, ax),
                h("label", lx, [
                  h("input", {
                    type: "checkbox",
                    checked: R.enabled,
                    onChange: (P) => F(R.id, "enabled", P.target.checked)
                  }, null, 40, ux)
                ]),
                h("button", {
                  class: "remove-btn",
                  onClick: (P) => ne(R.id)
                }, [...D[57] || (D[57] = [
                  h("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, cx)
              ]),
              h("div", dx, [
                D[58] || (D[58] = h("label", null, "Position X", -1)),
                h("input", {
                  type: "range",
                  value: R.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => F(R.id, "x", Number(P.target.value))
                }, null, 40, hx),
                h("span", fx, pe(R.x.toFixed(2)), 1)
              ]),
              h("div", px, [
                D[59] || (D[59] = h("label", null, "Position Y", -1)),
                h("input", {
                  type: "range",
                  value: R.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => F(R.id, "y", Number(P.target.value))
                }, null, 40, mx),
                h("span", gx, pe(R.y.toFixed(2)), 1)
              ]),
              h("div", vx, [
                D[60] || (D[60] = h("label", null, "Strength", -1)),
                h("input", {
                  type: "range",
                  value: R.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (P) => F(R.id, "strength", Number(P.target.value))
                }, null, 40, yx),
                h("span", bx, pe(R.strength), 1)
              ]),
              h("div", xx, [
                D[61] || (D[61] = h("label", null, "Radius", -1)),
                h("input", {
                  type: "range",
                  value: R.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => F(R.id, "radius", Number(P.target.value))
                }, null, 40, _x),
                h("span", wx, pe(R.radius.toFixed(2)), 1)
              ]),
              h("div", Sx, [
                D[63] || (D[63] = h("label", null, "Falloff", -1)),
                h("select", {
                  value: R.falloff,
                  onChange: (P) => F(R.id, "falloff", P.target.value)
                }, [...D[62] || (D[62] = [
                  h("option", { value: "linear" }, "Linear", -1),
                  h("option", { value: "quadratic" }, "Quadratic", -1),
                  h("option", { value: "constant" }, "Constant", -1)
                ])], 40, Cx)
              ])
            ]))), 128))
          ])) : Te("", !0),
          a.value === "vortices" ? (V(), B("div", kx, [
            h("button", {
              class: "add-btn full-width",
              onClick: z
            }, [...D[64] || (D[64] = [
              h("i", { class: "pi pi-plus" }, null, -1),
              qe(" Add Vortex ", -1)
            ])]),
            (V(!0), B(Re, null, Ue(f.value, (R) => (V(), B("div", {
              key: R.id,
              class: "force-item"
            }, [
              h("div", Tx, [
                h("input", {
                  type: "text",
                  value: R.name,
                  onInput: (P) => oe(R.id, "name", P.target.value),
                  class: "force-name"
                }, null, 40, Mx),
                h("label", Ox, [
                  h("input", {
                    type: "checkbox",
                    checked: R.enabled,
                    onChange: (P) => oe(R.id, "enabled", P.target.checked)
                  }, null, 40, Ex)
                ]),
                h("button", {
                  class: "remove-btn",
                  onClick: (P) => X(R.id)
                }, [...D[65] || (D[65] = [
                  h("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, Px)
              ]),
              h("div", Dx, [
                D[66] || (D[66] = h("label", null, "Position X", -1)),
                h("input", {
                  type: "range",
                  value: R.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => oe(R.id, "x", Number(P.target.value))
                }, null, 40, Ax),
                h("span", Ix, pe(R.x.toFixed(2)), 1)
              ]),
              h("div", Fx, [
                D[67] || (D[67] = h("label", null, "Position Y", -1)),
                h("input", {
                  type: "range",
                  value: R.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => oe(R.id, "y", Number(P.target.value))
                }, null, 40, Lx),
                h("span", zx, pe(R.y.toFixed(2)), 1)
              ]),
              h("div", Rx, [
                D[68] || (D[68] = h("label", null, "Strength", -1)),
                h("input", {
                  type: "range",
                  value: R.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (P) => oe(R.id, "strength", Number(P.target.value))
                }, null, 40, Vx),
                h("span", jx, pe(R.strength), 1)
              ]),
              h("div", $x, [
                D[69] || (D[69] = h("label", null, "Radius", -1)),
                h("input", {
                  type: "range",
                  value: R.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (P) => oe(R.id, "radius", Number(P.target.value))
                }, null, 40, Bx),
                h("span", Wx, pe(R.radius.toFixed(2)), 1)
              ]),
              h("div", Ux, [
                D[70] || (D[70] = h("label", null, "Rotation Speed", -1)),
                h("input", {
                  type: "range",
                  value: R.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (P) => oe(R.id, "rotationSpeed", Number(P.target.value))
                }, null, 40, Nx),
                h("span", Hx, pe(R.rotationSpeed) + "/f", 1)
              ]),
              h("div", Xx, [
                D[71] || (D[71] = h("label", null, "Inward Pull", -1)),
                h("input", {
                  type: "range",
                  value: R.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (P) => oe(R.id, "inwardPull", Number(P.target.value))
                }, null, 40, Yx),
                h("span", Gx, pe(R.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", Kx, [
        h("div", {
          class: "section-header",
          onClick: D[13] || (D[13] = (R) => S("turbulence"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[73] || (D[73] = h("span", null, "Turbulence", -1)),
          h("button", {
            class: "add-btn",
            onClick: Je(be, ["stop"]),
            title: "Add Turbulence Field"
          }, [...D[72] || (D[72] = [
            h("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("turbulence") ? (V(), B("div", qx, [
          (V(!0), B(Re, null, Ue(y.value, (R) => (V(), B("div", {
            key: R.id,
            class: "force-item"
          }, [
            h("div", Zx, [
              D[75] || (D[75] = h("span", { class: "force-label" }, "Turbulence Field", -1)),
              h("label", Jx, [
                h("input", {
                  type: "checkbox",
                  checked: R.enabled,
                  onChange: (P) => ie(R.id, "enabled", P.target.checked)
                }, null, 40, Qx)
              ]),
              h("button", {
                class: "remove-btn",
                onClick: (P) => J(R.id)
              }, [...D[74] || (D[74] = [
                h("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, e_)
            ]),
            h("div", t_, [
              D[76] || (D[76] = h("label", null, "Scale", -1)),
              h("input", {
                type: "range",
                value: R.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (P) => ie(R.id, "scale", Number(P.target.value))
              }, null, 40, n_),
              h("span", s_, pe(R.scale.toFixed(3)), 1)
            ]),
            h("div", i_, [
              D[77] || (D[77] = h("label", null, "Strength", -1)),
              h("input", {
                type: "range",
                value: R.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (P) => ie(R.id, "strength", Number(P.target.value))
              }, null, 40, r_),
              h("span", o_, pe(R.strength), 1)
            ]),
            h("div", a_, [
              D[78] || (D[78] = h("label", null, "Evolution", -1)),
              h("input", {
                type: "range",
                value: R.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (P) => ie(R.id, "evolutionSpeed", Number(P.target.value))
              }, null, 40, l_),
              h("span", u_, pe(R.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          y.value.length === 0 ? (V(), B("div", c_, " No turbulence fields. Add one for organic particle motion. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", d_, [
        h("div", {
          class: "section-header",
          onClick: D[14] || (D[14] = (R) => S("subEmitters"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[80] || (D[80] = h("span", null, "Sub-Emitters", -1)),
          h("button", {
            class: "add-btn",
            onClick: Je(G, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...D[79] || (D[79] = [
            h("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("subEmitters") ? (V(), B("div", h_, [
          (V(!0), B(Re, null, Ue(v.value, (R) => (V(), B("div", {
            key: R.id,
            class: "force-item"
          }, [
            h("div", f_, [
              h("select", {
                value: R.parentEmitterId,
                onChange: (P) => ee(R.id, "parentEmitterId", P.target.value),
                class: "sub-emitter-parent"
              }, [
                D[81] || (D[81] = h("option", { value: "*" }, "All Emitters", -1)),
                (V(!0), B(Re, null, Ue(c.value, (P) => (V(), B("option", {
                  key: P.id,
                  value: P.id
                }, pe(P.name), 9, m_))), 128))
              ], 40, p_),
              h("label", g_, [
                h("input", {
                  type: "checkbox",
                  checked: R.enabled,
                  onChange: (P) => ee(R.id, "enabled", P.target.checked)
                }, null, 40, v_)
              ]),
              h("button", {
                class: "remove-btn",
                onClick: (P) => N(R.id)
              }, [...D[82] || (D[82] = [
                h("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, y_)
            ]),
            h("div", b_, [
              D[84] || (D[84] = h("label", null, "Trigger", -1)),
              h("select", {
                value: R.trigger,
                onChange: (P) => ee(R.id, "trigger", P.target.value)
              }, [...D[83] || (D[83] = [
                h("option", { value: "death" }, "On Death", -1)
              ])], 40, x_)
            ]),
            h("div", __, [
              D[85] || (D[85] = h("label", null, "Spawn Count", -1)),
              h("input", {
                type: "range",
                value: R.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (P) => ee(R.id, "spawnCount", Number(P.target.value))
              }, null, 40, w_),
              h("span", S_, pe(R.spawnCount), 1)
            ]),
            h("div", C_, [
              D[86] || (D[86] = h("label", null, "Inherit Velocity", -1)),
              h("input", {
                type: "range",
                value: R.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (P) => ee(R.id, "inheritVelocity", Number(P.target.value))
              }, null, 40, k_),
              h("span", T_, pe((R.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            h("div", M_, [
              D[87] || (D[87] = h("label", null, "Size", -1)),
              h("input", {
                type: "range",
                value: R.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (P) => ee(R.id, "size", Number(P.target.value))
              }, null, 40, O_),
              h("span", E_, pe(R.size) + "px", 1)
            ]),
            h("div", P_, [
              D[88] || (D[88] = h("label", null, "Lifetime", -1)),
              h("input", {
                type: "range",
                value: R.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (P) => ee(R.id, "lifetime", Number(P.target.value))
              }, null, 40, D_),
              h("span", A_, pe(R.lifetime) + "f", 1)
            ]),
            h("div", I_, [
              D[89] || (D[89] = h("label", null, "Speed", -1)),
              h("input", {
                type: "range",
                value: R.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (P) => ee(R.id, "speed", Number(P.target.value))
              }, null, 40, F_),
              h("span", L_, pe(R.speed), 1)
            ]),
            h("div", z_, [
              D[90] || (D[90] = h("label", null, "Spread", -1)),
              h("input", {
                type: "range",
                value: R.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (P) => ee(R.id, "spread", Number(P.target.value))
              }, null, 40, R_),
              h("span", V_, pe(R.spread) + "", 1)
            ]),
            h("div", j_, [
              D[91] || (D[91] = h("label", null, "Color", -1)),
              h("input", {
                type: "color",
                value: te(R.color),
                onInput: (P) => ve(R.id, P.target.value)
              }, null, 40, $_)
            ])
          ]))), 128)),
          v.value.length === 0 ? (V(), B("div", B_, " No sub-emitters. Add one for particle death effects. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", W_, [
        h("div", {
          class: "section-header",
          onClick: D[15] || (D[15] = (R) => S("modulations"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[93] || (D[93] = h("span", null, "Modulations", -1)),
          h("button", {
            class: "add-btn",
            onClick: Je(H, ["stop"]),
            title: "Add Modulation"
          }, [...D[92] || (D[92] = [
            h("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("modulations") ? (V(), B("div", U_, [
          (V(!0), B(Re, null, Ue(g.value, (R) => (V(), B("div", {
            key: R.id,
            class: "modulation-item"
          }, [
            h("div", N_, [
              h("select", {
                value: R.emitterId,
                onChange: (P) => T(R.id, "emitterId", P.target.value)
              }, [
                D[94] || (D[94] = h("option", { value: "*" }, "All Emitters", -1)),
                (V(!0), B(Re, null, Ue(c.value, (P) => (V(), B("option", {
                  key: P.id,
                  value: P.id
                }, pe(P.name), 9, X_))), 128))
              ], 40, H_),
              h("button", {
                class: "remove-btn",
                onClick: (P) => ge(R.id)
              }, [...D[95] || (D[95] = [
                h("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, Y_)
            ]),
            h("div", G_, [
              D[97] || (D[97] = h("label", null, "Property", -1)),
              h("select", {
                value: R.property,
                onChange: (P) => T(R.id, "property", P.target.value)
              }, [...D[96] || (D[96] = [
                xr('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, K_)
            ]),
            h("div", q_, [
              D[98] || (D[98] = h("label", null, "Start Value", -1)),
              h("input", {
                type: "number",
                value: R.startValue,
                step: "0.1",
                onInput: (P) => T(R.id, "startValue", Number(P.target.value))
              }, null, 40, Z_)
            ]),
            h("div", J_, [
              D[99] || (D[99] = h("label", null, "End Value", -1)),
              h("input", {
                type: "number",
                value: R.endValue,
                step: "0.1",
                onInput: (P) => T(R.id, "endValue", Number(P.target.value))
              }, null, 40, Q_)
            ]),
            h("div", ew, [
              D[101] || (D[101] = h("label", null, "Easing", -1)),
              h("select", {
                value: R.easing,
                onChange: (P) => T(R.id, "easing", P.target.value)
              }, [...D[100] || (D[100] = [
                xr('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, tw)
            ])
          ]))), 128)),
          g.value.length === 0 ? (V(), B("div", nw, " No modulations. Add one to animate particle properties over lifetime. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", sw, [
        h("div", {
          class: "section-header",
          onClick: D[16] || (D[16] = (R) => S("render"))
        }, [
          h("i", {
            class: Ie(["pi", r.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          D[102] || (D[102] = h("span", null, "Render Options", -1))
        ]),
        r.value.has("render") ? (V(), B("div", iw, [
          h("div", rw, [
            D[104] || (D[104] = h("label", null, "Blend Mode", -1)),
            h("select", {
              value: p.value.blendMode,
              onChange: D[17] || (D[17] = (R) => K("blendMode", R.target.value))
            }, [...D[103] || (D[103] = [
              h("option", { value: "normal" }, "Normal", -1),
              h("option", { value: "additive" }, "Additive", -1),
              h("option", { value: "multiply" }, "Multiply", -1),
              h("option", { value: "screen" }, "Screen", -1)
            ])], 40, ow)
          ]),
          h("div", aw, [
            D[106] || (D[106] = h("label", null, "Shape", -1)),
            h("select", {
              value: p.value.particleShape,
              onChange: D[18] || (D[18] = (R) => K("particleShape", R.target.value))
            }, [...D[105] || (D[105] = [
              h("option", { value: "circle" }, "Circle", -1),
              h("option", { value: "square" }, "Square", -1),
              h("option", { value: "triangle" }, "Triangle", -1),
              h("option", { value: "star" }, "Star", -1)
            ])], 40, lw)
          ]),
          h("div", uw, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: p.value.renderTrails,
                onChange: D[19] || (D[19] = (R) => K("renderTrails", R.target.checked))
              }, null, 40, cw),
              D[107] || (D[107] = qe(" Render Trails ", -1))
            ])
          ]),
          p.value.renderTrails ? (V(), B("div", dw, [
            D[108] || (D[108] = h("label", null, "Trail Length", -1)),
            h("input", {
              type: "range",
              value: p.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: D[20] || (D[20] = (R) => K("trailLength", Number(R.target.value)))
            }, null, 40, hw),
            h("span", fw, pe(p.value.trailLength), 1)
          ])) : Te("", !0),
          h("div", pw, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: p.value.glowEnabled,
                onChange: D[21] || (D[21] = (R) => K("glowEnabled", R.target.checked))
              }, null, 40, mw),
              D[109] || (D[109] = qe(" Enable Glow ", -1))
            ])
          ]),
          p.value.glowEnabled ? (V(), B("div", gw, [
            D[110] || (D[110] = h("label", null, "Glow Radius", -1)),
            h("input", {
              type: "range",
              value: p.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: D[22] || (D[22] = (R) => K("glowRadius", Number(R.target.value)))
            }, null, 40, vw),
            h("span", yw, pe(p.value.glowRadius) + "px", 1)
          ])) : Te("", !0),
          p.value.glowEnabled ? (V(), B("div", bw, [
            D[111] || (D[111] = h("label", null, "Glow Intensity", -1)),
            h("input", {
              type: "range",
              value: p.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: D[23] || (D[23] = (R) => K("glowIntensity", Number(R.target.value)))
            }, null, 40, xw),
            h("span", _w, pe(p.value.glowIntensity.toFixed(2)), 1)
          ])) : Te("", !0),
          D[118] || (D[118] = h("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          h("div", ww, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: m.value.enabled,
                onChange: D[24] || (D[24] = (R) => re("enabled", R.target.checked))
              }, null, 40, Sw),
              D[112] || (D[112] = qe(" Enable Connections ", -1))
            ])
          ]),
          m.value.enabled ? (V(), B("div", Cw, [
            D[113] || (D[113] = h("label", null, "Max Distance", -1)),
            h("input", {
              type: "range",
              value: m.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: D[25] || (D[25] = (R) => re("maxDistance", Number(R.target.value)))
            }, null, 40, kw),
            h("span", Tw, pe(m.value.maxDistance) + "px", 1)
          ])) : Te("", !0),
          m.value.enabled ? (V(), B("div", Mw, [
            D[114] || (D[114] = h("label", null, "Max Connections", -1)),
            h("input", {
              type: "range",
              value: m.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: D[26] || (D[26] = (R) => re("maxConnections", Number(R.target.value)))
            }, null, 40, Ow),
            h("span", Ew, pe(m.value.maxConnections), 1)
          ])) : Te("", !0),
          m.value.enabled ? (V(), B("div", Pw, [
            D[115] || (D[115] = h("label", null, "Line Width", -1)),
            h("input", {
              type: "range",
              value: m.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: D[27] || (D[27] = (R) => re("lineWidth", Number(R.target.value)))
            }, null, 40, Dw),
            h("span", Aw, pe(m.value.lineWidth.toFixed(1)), 1)
          ])) : Te("", !0),
          m.value.enabled ? (V(), B("div", Iw, [
            D[116] || (D[116] = h("label", null, "Line Opacity", -1)),
            h("input", {
              type: "range",
              value: m.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: D[28] || (D[28] = (R) => re("lineOpacity", Number(R.target.value)))
            }, null, 40, Fw),
            h("span", Lw, pe(m.value.lineOpacity.toFixed(2)), 1)
          ])) : Te("", !0),
          m.value.enabled ? (V(), B("div", zw, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: m.value.fadeByDistance,
                onChange: D[29] || (D[29] = (R) => re("fadeByDistance", R.target.checked))
              }, null, 40, Rw),
              D[117] || (D[117] = qe(" Fade by Distance ", -1))
            ])
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", Vw, [
        D[119] || (D[119] = h("i", { class: "pi pi-circle-fill" }, null, -1)),
        h("span", null, pe(b.value) + " particles", 1)
      ])
    ]));
  }
}), $w = /* @__PURE__ */ mt(jw, [["__scopeId", "data-v-60b9bdc8"]]), Bw = { class: "depthflow-properties" }, Ww = { class: "property-section" }, Uw = {
  key: 0,
  class: "section-content"
}, Nw = { class: "property-row" }, Hw = ["value"], Xw = ["value"], Yw = { class: "property-row" }, Gw = ["value"], Kw = ["value"], qw = { class: "property-section" }, Zw = {
  key: 0,
  class: "section-content"
}, Jw = { class: "preset-grid" }, Qw = ["onClick"], eS = {
  key: 0,
  class: "property-row"
}, tS = ["value"], nS = { class: "value-display" }, sS = { class: "property-section" }, iS = {
  key: 0,
  class: "section-content"
}, rS = { class: "property-row" }, oS = ["value"], aS = { class: "value-display" }, lS = { class: "property-row" }, uS = ["value"], cS = { class: "value-display" }, dS = { class: "property-row" }, hS = ["value"], fS = { class: "value-display" }, pS = { class: "property-row" }, mS = ["value"], gS = { class: "value-display" }, vS = { class: "property-section" }, yS = {
  key: 0,
  class: "section-content"
}, bS = { class: "property-row" }, xS = ["value"], _S = { class: "value-display" }, wS = { class: "property-row" }, SS = ["value"], CS = { class: "value-display" }, kS = {
  key: 0,
  class: "property-section"
}, TS = {
  key: 0,
  class: "section-content"
}, MS = { class: "property-row" }, OS = ["value"], ES = { class: "value-display" }, PS = { class: "property-row" }, DS = ["value"], AS = { class: "value-display" }, IS = { class: "property-row" }, FS = ["value"], LS = { class: "value-display" }, zS = { class: "property-row" }, RS = ["value"], VS = { class: "value-display" }, jS = {
  key: 2,
  class: "property-row"
}, $S = ["value"], BS = { class: "value-display" }, WS = { class: "property-section" }, US = {
  key: 0,
  class: "section-content"
}, NS = { class: "property-row" }, HS = ["value"], XS = { class: "value-display" }, YS = { class: "property-row checkbox-row" }, GS = ["checked"], KS = { class: "property-section" }, qS = {
  key: 0,
  class: "section-content"
}, ZS = { class: "preview-container" }, JS = { class: "preview-controls" }, QS = { class: "frame-indicator" }, Ln = 200, eC = /* @__PURE__ */ pt({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = me(null), a = me(!1), l = me(0), u = me(null), c = me(/* @__PURE__ */ new Set(["source", "preset", "camera"])), d = me(1), f = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], g = Oe(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), p = Oe(() => g.value.config), y = Oe(() => r.frameCount), v = Oe(
      () => r.layers.filter((X) => X.type === "image" || X.type === "generated")
    ), m = Oe(
      () => r.layers.filter((X) => X.type === "depth" || X.type === "generated")
    ), b = Oe(
      () => ["circle_cw", "circle_ccw"].includes(p.value.preset)
    ), S = Oe(
      () => ["horizontal_swing", "vertical_swing"].includes(p.value.preset)
    ), x = Oe(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(p.value.preset)
    ), _ = Oe(
      () => b.value || S.value || x.value
    ), C = Oe(() => b.value ? "Orbit Settings" : S.value ? "Swing Settings" : x.value ? "Dolly Zoom Settings" : "Preset Settings");
    function k(X) {
      c.value.has(X) ? c.value.delete(X) : c.value.add(X);
    }
    function M(X, T) {
      s("update", { [X]: T });
    }
    function O(X, T) {
      s("update", {
        config: { ...p.value, [X]: T }
      });
    }
    function F(X) {
      O("preset", X);
    }
    function $(X) {
      d.value = X, b.value ? O("orbitRadius", 0.1 * X) : S.value ? O("swingAmplitude", 0.1 * X) : O("depthScale", 1 * X);
    }
    function ne() {
      a.value = !a.value, a.value ? oe() : u.value !== null && (cancelAnimationFrame(u.value), u.value = null);
    }
    function oe() {
      a.value && (l.value = (l.value + 1) % y.value, z(), u.value = requestAnimationFrame(() => {
        setTimeout(oe, 1e3 / r.fps);
      }));
    }
    function z() {
      const X = o.value;
      if (!X) return;
      const T = X.getContext("2d");
      T && (T.fillStyle = "#1e1e1e", T.fillRect(0, 0, Ln, Ln), T.fillStyle = "#333", T.fillRect(10, 10, Ln - 20, Ln - 20), T.fillStyle = "#666", T.font = "12px sans-serif", T.textAlign = "center", T.fillText("Depthflow Preview", Ln / 2, Ln / 2), T.fillText(`Frame ${l.value}`, Ln / 2, Ln / 2 + 16));
    }
    return Rt(() => {
      z();
    }), pn(() => {
      u.value !== null && cancelAnimationFrame(u.value);
    }), (X, T) => (V(), B("div", Bw, [
      h("div", Ww, [
        h("div", {
          class: "section-header",
          onClick: T[0] || (T[0] = (H) => k("source"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[23] || (T[23] = h("span", null, "Source Selection", -1))
        ]),
        c.value.has("source") ? (V(), B("div", Uw, [
          h("div", Nw, [
            T[25] || (T[25] = h("label", null, "Source Layer", -1)),
            h("select", {
              value: g.value.sourceLayerId,
              onChange: T[1] || (T[1] = (H) => M("sourceLayerId", H.target.value))
            }, [
              T[24] || (T[24] = h("option", { value: "" }, "Select source...", -1)),
              (V(!0), B(Re, null, Ue(v.value, (H) => (V(), B("option", {
                key: H.id,
                value: H.id
              }, pe(H.name), 9, Xw))), 128))
            ], 40, Hw)
          ]),
          h("div", Yw, [
            T[27] || (T[27] = h("label", null, "Depth Layer", -1)),
            h("select", {
              value: g.value.depthLayerId,
              onChange: T[2] || (T[2] = (H) => M("depthLayerId", H.target.value))
            }, [
              T[26] || (T[26] = h("option", { value: "" }, "Select depth map...", -1)),
              (V(!0), B(Re, null, Ue(m.value, (H) => (V(), B("option", {
                key: H.id,
                value: H.id
              }, pe(H.name), 9, Kw))), 128))
            ], 40, Gw)
          ])
        ])) : Te("", !0)
      ]),
      h("div", qw, [
        h("div", {
          class: "section-header",
          onClick: T[3] || (T[3] = (H) => k("preset"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[28] || (T[28] = h("span", null, "Motion Preset", -1))
        ]),
        c.value.has("preset") ? (V(), B("div", Zw, [
          h("div", Jw, [
            (V(), B(Re, null, Ue(f, (H) => h("button", {
              key: H.value,
              class: Ie(["preset-btn", { active: p.value.preset === H.value }]),
              onClick: (ge) => F(H.value)
            }, [
              h("i", {
                class: Ie(H.icon)
              }, null, 2),
              h("span", null, pe(H.label), 1)
            ], 10, Qw)), 64))
          ]),
          p.value.preset !== "static" ? (V(), B("div", eS, [
            T[29] || (T[29] = h("label", null, "Intensity", -1)),
            h("input", {
              type: "range",
              value: d.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: T[4] || (T[4] = (H) => $(Number(H.target.value)))
            }, null, 40, tS),
            h("span", nS, pe(d.value.toFixed(1)) + "x", 1)
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      h("div", sS, [
        h("div", {
          class: "section-header",
          onClick: T[5] || (T[5] = (H) => k("camera"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[30] || (T[30] = h("span", null, "Camera Controls", -1))
        ]),
        c.value.has("camera") ? (V(), B("div", iS, [
          h("div", rS, [
            T[31] || (T[31] = h("label", null, "Zoom", -1)),
            g.value.animatedZoom ? (V(), ot(dn, {
              key: 0,
              property: g.value.animatedZoom,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            h("input", {
              type: "range",
              value: p.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: T[6] || (T[6] = (H) => O("zoom", Number(H.target.value)))
            }, null, 40, oS),
            h("span", aS, pe(p.value.zoom.toFixed(2)), 1)
          ]),
          h("div", lS, [
            T[32] || (T[32] = h("label", null, "Offset X", -1)),
            g.value.animatedOffsetX ? (V(), ot(dn, {
              key: 0,
              property: g.value.animatedOffsetX,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            h("input", {
              type: "range",
              value: p.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: T[7] || (T[7] = (H) => O("offsetX", Number(H.target.value)))
            }, null, 40, uS),
            h("span", cS, pe(p.value.offsetX.toFixed(2)), 1)
          ]),
          h("div", dS, [
            T[33] || (T[33] = h("label", null, "Offset Y", -1)),
            g.value.animatedOffsetY ? (V(), ot(dn, {
              key: 0,
              property: g.value.animatedOffsetY,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            h("input", {
              type: "range",
              value: p.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: T[8] || (T[8] = (H) => O("offsetY", Number(H.target.value)))
            }, null, 40, hS),
            h("span", fS, pe(p.value.offsetY.toFixed(2)), 1)
          ]),
          h("div", pS, [
            T[34] || (T[34] = h("label", null, "Rotation", -1)),
            g.value.animatedRotation ? (V(), ot(dn, {
              key: 0,
              property: g.value.animatedRotation,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            h("input", {
              type: "range",
              value: p.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: T[9] || (T[9] = (H) => O("rotation", Number(H.target.value)))
            }, null, 40, mS),
            h("span", gS, pe(p.value.rotation) + "", 1)
          ])
        ])) : Te("", !0)
      ]),
      h("div", vS, [
        h("div", {
          class: "section-header",
          onClick: T[10] || (T[10] = (H) => k("depth"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[35] || (T[35] = h("span", null, "Depth Settings", -1))
        ]),
        c.value.has("depth") ? (V(), B("div", yS, [
          h("div", bS, [
            T[36] || (T[36] = h("label", null, "Depth Scale", -1)),
            g.value.animatedDepthScale ? (V(), ot(dn, {
              key: 0,
              property: g.value.animatedDepthScale,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            h("input", {
              type: "range",
              value: p.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: T[11] || (T[11] = (H) => O("depthScale", Number(H.target.value)))
            }, null, 40, xS),
            h("span", _S, pe(p.value.depthScale.toFixed(2)), 1)
          ]),
          h("div", wS, [
            T[37] || (T[37] = h("label", null, "Focus Depth", -1)),
            h("input", {
              type: "range",
              value: p.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: T[12] || (T[12] = (H) => O("focusDepth", Number(H.target.value)))
            }, null, 40, SS),
            h("span", CS, pe(p.value.focusDepth.toFixed(2)), 1)
          ]),
          T[38] || (T[38] = h("div", { class: "depth-hint" }, [
            qe(" Objects at focus depth stay stationary."),
            h("br"),
            qe(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Te("", !0)
      ]),
      _.value ? (V(), B("div", kS, [
        h("div", {
          class: "section-header",
          onClick: T[13] || (T[13] = (H) => k("presetSettings"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          h("span", null, pe(C.value), 1)
        ]),
        c.value.has("presetSettings") ? (V(), B("div", TS, [
          b.value ? (V(), B(Re, { key: 0 }, [
            h("div", MS, [
              T[39] || (T[39] = h("label", null, "Orbit Radius", -1)),
              h("input", {
                type: "range",
                value: p.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: T[14] || (T[14] = (H) => O("orbitRadius", Number(H.target.value)))
              }, null, 40, OS),
              h("span", ES, pe(p.value.orbitRadius.toFixed(2)), 1)
            ]),
            h("div", PS, [
              T[40] || (T[40] = h("label", null, "Orbit Speed", -1)),
              h("input", {
                type: "range",
                value: p.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: T[15] || (T[15] = (H) => O("orbitSpeed", Number(H.target.value)))
              }, null, 40, DS),
              h("span", AS, pe(p.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Te("", !0),
          S.value ? (V(), B(Re, { key: 1 }, [
            h("div", IS, [
              T[41] || (T[41] = h("label", null, "Amplitude", -1)),
              h("input", {
                type: "range",
                value: p.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: T[16] || (T[16] = (H) => O("swingAmplitude", Number(H.target.value)))
              }, null, 40, FS),
              h("span", LS, pe(p.value.swingAmplitude.toFixed(2)), 1)
            ]),
            h("div", zS, [
              T[42] || (T[42] = h("label", null, "Frequency", -1)),
              h("input", {
                type: "range",
                value: p.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: T[17] || (T[17] = (H) => O("swingFrequency", Number(H.target.value)))
              }, null, 40, RS),
              h("span", VS, pe(p.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Te("", !0),
          x.value ? (V(), B("div", jS, [
            T[43] || (T[43] = h("label", null, "Dolly Rate", -1)),
            h("input", {
              type: "range",
              value: p.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: T[18] || (T[18] = (H) => O("dollyZoom", Number(H.target.value)))
            }, null, 40, $S),
            h("span", BS, pe(p.value.dollyZoom.toFixed(2)), 1)
          ])) : Te("", !0)
        ])) : Te("", !0)
      ])) : Te("", !0),
      h("div", WS, [
        h("div", {
          class: "section-header",
          onClick: T[19] || (T[19] = (H) => k("quality"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[44] || (T[44] = h("span", null, "Quality", -1))
        ]),
        c.value.has("quality") ? (V(), B("div", US, [
          h("div", NS, [
            T[45] || (T[45] = h("label", null, "Edge Dilation", -1)),
            h("input", {
              type: "range",
              value: p.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: T[20] || (T[20] = (H) => O("edgeDilation", Number(H.target.value)))
            }, null, 40, HS),
            h("span", XS, pe(p.value.edgeDilation) + "px", 1)
          ]),
          h("div", YS, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: p.value.inpaintEdges,
                onChange: T[21] || (T[21] = (H) => O("inpaintEdges", H.target.checked))
              }, null, 40, GS),
              T[46] || (T[46] = qe(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Te("", !0)
      ]),
      h("div", KS, [
        h("div", {
          class: "section-header",
          onClick: T[22] || (T[22] = (H) => k("preview"))
        }, [
          h("i", {
            class: Ie(["pi", c.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[47] || (T[47] = h("span", null, "Preview", -1))
        ]),
        c.value.has("preview") ? (V(), B("div", qS, [
          h("div", ZS, [
            h("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Ln,
              height: Ln
            }, null, 512)
          ]),
          h("div", JS, [
            h("button", {
              class: Ie(["preview-btn", { active: a.value }]),
              onClick: ne
            }, [
              h("i", {
                class: Ie(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              qe(" " + pe(a.value ? "Pause" : "Play"), 1)
            ], 2),
            h("span", QS, " Frame " + pe(l.value) + " / " + pe(y.value - 1), 1)
          ])
        ])) : Te("", !0)
      ])
    ]));
  }
}), tC = /* @__PURE__ */ mt(eC, [["__scopeId", "data-v-ffaf4c8a"]]), nC = { class: "light-properties" }, sC = { class: "property-section" }, iC = { class: "section-content" }, rC = { class: "property-row" }, oC = ["value"], aC = { class: "property-group" }, lC = { class: "property-group" }, uC = { class: "control-row" }, cC = { class: "property-group" }, dC = { class: "control-row" }, hC = { class: "property-group" }, fC = {
  key: 1,
  class: "property-group"
}, pC = { class: "property-group checkbox-row" }, mC = ["checked"], gC = /* @__PURE__ */ pt({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = Oe(() => n.layer.data || {
      lightType: "point",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "quadratic",
      castShadows: !1
    });
    function a(l, u) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [l]: u }
      }), s("update");
    }
    return (l, u) => (V(), B("div", nC, [
      h("div", sC, [
        u[16] || (u[16] = h("div", { class: "section-header" }, "Light Settings", -1)),
        h("div", iC, [
          h("div", rC, [
            u[9] || (u[9] = h("label", null, "Type", -1)),
            h("select", {
              value: o.value.lightType,
              onChange: u[0] || (u[0] = (c) => a("lightType", c.target.value)),
              class: "type-select"
            }, [...u[8] || (u[8] = [
              h("option", { value: "point" }, "Point", -1),
              h("option", { value: "spot" }, "Spot", -1),
              h("option", { value: "ambient" }, "Ambient", -1),
              h("option", { value: "directional" }, "Directional", -1)
            ])], 40, oC)
          ]),
          h("div", aC, [
            u[10] || (u[10] = h("label", null, "Color", -1)),
            Ae(Fe(Oi), {
              modelValue: o.value.color,
              "onUpdate:modelValue": u[1] || (u[1] = (c) => a("color", c))
            }, null, 8, ["modelValue"])
          ]),
          h("div", lC, [
            u[11] || (u[11] = h("label", null, "Intensity", -1)),
            h("div", uC, [
              Ae(Fe(cn), {
                modelValue: o.value.intensity,
                "onUpdate:modelValue": u[2] || (u[2] = (c) => a("intensity", c)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          o.value.lightType === "spot" ? (V(), B(Re, { key: 0 }, [
            h("div", cC, [
              u[12] || (u[12] = h("label", null, "Cone Angle", -1)),
              h("div", dC, [
                Ae(Fe(ou), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": u[3] || (u[3] = (c) => a("coneAngle", c)),
                  size: 32
                }, null, 8, ["modelValue"]),
                Ae(Fe(Ne), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": u[4] || (u[4] = (c) => a("coneAngle", c)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            h("div", hC, [
              u[13] || (u[13] = h("label", null, "Cone Feather", -1)),
              Ae(Fe(cn), {
                modelValue: o.value.coneFeather ?? 50,
                "onUpdate:modelValue": u[5] || (u[5] = (c) => a("coneFeather", c)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Te("", !0),
          o.value.lightType !== "ambient" && o.value.lightType !== "directional" ? (V(), B("div", fC, [
            u[14] || (u[14] = h("label", null, "Falloff Radius", -1)),
            Ae(Fe(Ne), {
              modelValue: o.value.radius,
              "onUpdate:modelValue": u[6] || (u[6] = (c) => a("radius", c)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Te("", !0),
          h("div", pC, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: o.value.castShadows,
                onChange: u[7] || (u[7] = (c) => a("castShadows", c.target.checked))
              }, null, 40, mC),
              u[15] || (u[15] = qe(" Casts Shadows ", -1))
            ])
          ])
        ])
      ])
    ]));
  }
}), vC = /* @__PURE__ */ mt(gC, [["__scopeId", "data-v-a33ec34d"]]), yC = { class: "shape-properties" }, bC = { class: "property-section" }, xC = { class: "section-content" }, _C = { class: "property-group" }, wC = { class: "group-header" }, SC = ["checked"], CC = {
  key: 0,
  class: "control-row"
}, kC = { class: "property-group" }, TC = { class: "group-header" }, MC = ["checked"], OC = {
  key: 0,
  class: "stroke-controls"
}, EC = { class: "control-row" }, PC = { class: "property-row" }, DC = { class: "property-row" }, AC = { class: "icon-toggle-group" }, IC = { class: "property-group" }, FC = { class: "control-row checkbox-row" }, LC = ["checked"], zC = /* @__PURE__ */ pt({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = Oe(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), a = Oe(() => !!o.value.fill && o.value.fill !== "transparent"), l = Oe(() => !!o.value.stroke && o.value.strokeWidth > 0), u = Oe(() => o.value.strokeLineCap || "round");
    function c(g, p) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [g]: p }
      }), s("update");
    }
    function d(g) {
      const p = g.target.checked;
      c("fill", p ? "#ffffff" : "");
    }
    function f(g) {
      g.target.checked ? (c("stroke", "#ffffff"), c("strokeWidth", 2)) : c("strokeWidth", 0);
    }
    return (g, p) => (V(), B("div", yC, [
      h("div", bC, [
        p[13] || (p[13] = h("div", { class: "section-header" }, "Shape Appearance", -1)),
        h("div", xC, [
          h("div", _C, [
            h("div", wC, [
              p[7] || (p[7] = h("label", null, "Fill", -1)),
              h("input", {
                type: "checkbox",
                checked: a.value,
                onChange: d
              }, null, 40, SC)
            ]),
            a.value ? (V(), B("div", CC, [
              Ae(Fe(Oi), {
                modelValue: o.value.fill || "#ffffff",
                "onUpdate:modelValue": p[0] || (p[0] = (y) => c("fill", y)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Te("", !0)
          ]),
          h("div", kC, [
            h("div", TC, [
              p[8] || (p[8] = h("label", null, "Stroke", -1)),
              h("input", {
                type: "checkbox",
                checked: l.value,
                onChange: f
              }, null, 40, MC)
            ]),
            l.value ? (V(), B("div", OC, [
              h("div", EC, [
                Ae(Fe(Oi), {
                  modelValue: o.value.stroke || "#ffffff",
                  "onUpdate:modelValue": p[1] || (p[1] = (y) => c("stroke", y)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              h("div", PC, [
                p[9] || (p[9] = h("label", { class: "sub-label" }, "Width", -1)),
                Ae(Fe(Ne), {
                  modelValue: o.value.strokeWidth || 0,
                  "onUpdate:modelValue": p[2] || (p[2] = (y) => c("strokeWidth", y)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              h("div", DC, [
                p[10] || (p[10] = h("label", { class: "sub-label" }, "Cap", -1)),
                h("div", AC, [
                  h("button", {
                    class: Ie({ active: u.value === "butt" }),
                    onClick: p[3] || (p[3] = (y) => c("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  h("button", {
                    class: Ie({ active: u.value === "round" }),
                    onClick: p[4] || (p[4] = (y) => c("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  h("button", {
                    class: Ie({ active: u.value === "square" }),
                    onClick: p[5] || (p[5] = (y) => c("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Te("", !0)
          ]),
          h("div", IC, [
            p[12] || (p[12] = h("label", null, "Path", -1)),
            h("div", FC, [
              h("label", null, [
                h("input", {
                  type: "checkbox",
                  checked: o.value.closed,
                  onChange: p[6] || (p[6] = (y) => c("closed", y.target.checked))
                }, null, 40, LC),
                p[11] || (p[11] = qe(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), RC = /* @__PURE__ */ mt(zC, [["__scopeId", "data-v-e2af8c92"]]), VC = { class: "video-properties" }, jC = { class: "property-section" }, $C = { class: "section-content" }, BC = { class: "property-row" }, WC = { class: "control-with-keyframe" }, UC = { class: "property-section" }, NC = { class: "section-content" }, HC = { class: "property-row checkbox-row" }, XC = ["checked"], YC = { class: "property-row" }, GC = /* @__PURE__ */ pt({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Oe(() => n.layer.data || {
      assetId: null,
      loop: !1,
      startTime: 0,
      speed: 1
    }), o = Oe(() => {
      var c;
      return (c = n.layer.audio) == null ? void 0 : c.level;
    });
    function a(c) {
      var d;
      (d = n.layer.audio) != null && d.level && (n.layer.audio.level.value = c, s("update"));
    }
    function l(c) {
      const d = c.target;
      n.layer.data.loop = d.checked, s("update");
    }
    function u(c) {
      n.layer.data.speed = c, s("update");
    }
    return (c, d) => (V(), B("div", VC, [
      h("div", jC, [
        d[2] || (d[2] = h("div", { class: "section-header" }, "Audio", -1)),
        h("div", $C, [
          h("div", BC, [
            d[0] || (d[0] = h("label", null, "Audio Levels", -1)),
            h("div", WC, [
              o.value ? (V(), ot(Fe(Ne), {
                key: 0,
                modelValue: o.value.value,
                "onUpdate:modelValue": a,
                unit: "dB",
                min: -48,
                max: 12,
                precision: 2
              }, null, 8, ["modelValue"])) : Te("", !0),
              o.value ? (V(), ot(dn, {
                key: 1,
                property: o.value,
                layerId: i.layer.id
              }, null, 8, ["property", "layerId"])) : Te("", !0)
            ])
          ]),
          d[1] || (d[1] = h("div", { class: "waveform-container" }, [
            h("div", { class: "waveform-placeholder" }, "Waveform Visual")
          ], -1))
        ])
      ]),
      h("div", UC, [
        d[5] || (d[5] = h("div", { class: "section-header" }, "Video Options", -1)),
        h("div", NC, [
          h("div", HC, [
            h("label", null, [
              h("input", {
                type: "checkbox",
                checked: r.value.loop,
                onChange: l
              }, null, 40, XC),
              d[3] || (d[3] = qe(" Loop Video ", -1))
            ])
          ]),
          h("div", YC, [
            d[4] || (d[4] = h("label", null, "Speed", -1)),
            Ae(Fe(Ne), {
              modelValue: r.value.speed,
              "onUpdate:modelValue": u,
              min: 0.1,
              max: 10,
              step: 0.1,
              precision: 1,
              unit: "x"
            }, null, 8, ["modelValue"])
          ])
        ])
      ])
    ]));
  }
}), KC = /* @__PURE__ */ mt(GC, [["__scopeId", "data-v-8323cde0"]]), qC = { class: "properties-panel" }, ZC = {
  key: 0,
  class: "panel-content"
}, JC = { class: "property-section" }, QC = { class: "property-row" }, e2 = { class: "property-section" }, t2 = { class: "expand-icon" }, n2 = {
  key: 0,
  class: "section-content"
}, s2 = { class: "property-row" }, i2 = { class: "multi-value" }, r2 = { class: "property-row" }, o2 = { class: "multi-value" }, a2 = { class: "property-row" }, l2 = { class: "multi-value orientation-row" }, u2 = { class: "property-row" }, c2 = { class: "single-value" }, d2 = { class: "property-row" }, h2 = { class: "single-value" }, f2 = { class: "property-row" }, p2 = { class: "single-value" }, m2 = {
  key: 1,
  class: "property-row"
}, g2 = { class: "single-value" }, v2 = { class: "property-row" }, y2 = { class: "multi-value" }, b2 = { class: "property-row" }, x2 = { class: "single-value" }, _2 = { class: "property-section" }, w2 = { class: "property-row" }, S2 = ["value"], C2 = {
  key: 1,
  class: "empty-state"
}, k2 = /* @__PURE__ */ pt({
  __name: "PropertiesPanel",
  setup(i) {
    const e = Ot(), n = me(["transform"]), s = me(!0), r = me(""), o = me({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), a = me("normal"), l = me([]), u = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], c = Oe(() => e.selectedLayer), d = Oe(() => {
      if (!c.value) return null;
      switch (c.value.type) {
        case "text":
          return Zn($1);
        case "particles":
          return Zn($w);
        case "depthflow":
          return Zn(tC);
        case "light":
          return Zn(vC);
        case "spline":
          return Zn(RC);
        case "video":
          return Zn(KC);
        default:
          return null;
      }
    });
    ut(c, (S) => {
      var x, _, C, k, M, O, F, $, ne, oe, z, X, T, H, ge, K, re, ie, be, J, ee, ve, G, N, te;
      if (S) {
        r.value = S.name;
        const fe = S.transform;
        o.value = {
          position: {
            x: ((_ = (x = fe == null ? void 0 : fe.position) == null ? void 0 : x.value) == null ? void 0 : _.x) || 0,
            y: ((k = (C = fe == null ? void 0 : fe.position) == null ? void 0 : C.value) == null ? void 0 : k.y) || 0,
            z: ((O = (M = fe == null ? void 0 : fe.position) == null ? void 0 : M.value) == null ? void 0 : O.z) || 0
          },
          scale: { x: (($ = (F = fe == null ? void 0 : fe.scale) == null ? void 0 : F.value) == null ? void 0 : $.x) || 100, y: ((oe = (ne = fe == null ? void 0 : fe.scale) == null ? void 0 : ne.value) == null ? void 0 : oe.y) || 100 },
          rotation: ((z = fe == null ? void 0 : fe.rotation) == null ? void 0 : z.value) || 0,
          anchorPoint: { x: ((T = (X = fe == null ? void 0 : fe.anchorPoint) == null ? void 0 : X.value) == null ? void 0 : T.x) || 0, y: ((ge = (H = fe == null ? void 0 : fe.anchorPoint) == null ? void 0 : H.value) == null ? void 0 : ge.y) || 0 },
          opacity: ((K = S.opacity) == null ? void 0 : K.value) || 100,
          // 3D properties
          orientationX: ((ie = (re = fe == null ? void 0 : fe.orientation) == null ? void 0 : re.value) == null ? void 0 : ie.x) || 0,
          orientationY: ((J = (be = fe == null ? void 0 : fe.orientation) == null ? void 0 : be.value) == null ? void 0 : J.y) || 0,
          orientationZ: ((ve = (ee = fe == null ? void 0 : fe.orientation) == null ? void 0 : ee.value) == null ? void 0 : ve.z) || 0,
          rotationX: ((G = fe == null ? void 0 : fe.rotationX) == null ? void 0 : G.value) || 0,
          rotationY: ((N = fe == null ? void 0 : fe.rotationY) == null ? void 0 : N.value) || 0,
          rotationZ: ((te = fe == null ? void 0 : fe.rotationZ) == null ? void 0 : te.value) || 0
        }, a.value = S.blendMode || "normal";
      }
    }, { immediate: !0 }), ut(() => o.value.scale.x, (S, x) => {
      if (s.value && S !== x) {
        const _ = S / x;
        o.value.scale.y = Math.round(o.value.scale.y * _ * 10) / 10;
      }
    });
    function f(S) {
      const x = n.value.indexOf(S);
      x >= 0 ? n.value.splice(x, 1) : n.value.push(S);
    }
    function g() {
      c.value && r.value && (c.value.name = r.value);
    }
    function p() {
      if (!c.value) return;
      const S = c.value.transform, x = o.value;
      S != null && S.position && (S.position.value = { x: x.position.x, y: x.position.y, z: x.position.z }), S != null && S.scale && (S.scale.value = { x: x.scale.x, y: x.scale.y }), S != null && S.rotation && (S.rotation.value = x.rotation), S != null && S.anchorPoint && (S.anchorPoint.value = { x: x.anchorPoint.x, y: x.anchorPoint.y }), c.value.opacity && (c.value.opacity.value = x.opacity), c.value.threeD && (S != null && S.orientation && (S.orientation.value = { x: x.orientationX, y: x.orientationY, z: x.orientationZ }), S != null && S.rotationX && (S.rotationX.value = x.rotationX), S != null && S.rotationY && (S.rotationY.value = x.rotationY), S != null && S.rotationZ && (S.rotationZ.value = x.rotationZ)), b();
    }
    function y() {
      c.value && (c.value.blendMode = a.value);
    }
    function v(S) {
      return l.value.includes(S);
    }
    function m(S) {
      const x = l.value.indexOf(S);
      x >= 0 ? l.value.splice(x, 1) : (l.value.push(S), console.log(`Added keyframe for ${S} at frame ${e.currentFrame}`));
    }
    function b() {
      e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    }
    return (S, x) => {
      var _, C;
      return V(), B("div", qC, [
        x[40] || (x[40] = h("div", { class: "panel-header" }, [
          h("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        c.value ? (V(), B("div", ZC, [
          h("div", JC, [
            h("div", QC, [
              tt(h("input", {
                type: "text",
                "onUpdate:modelValue": x[0] || (x[0] = (k) => r.value = k),
                class: "layer-name-input",
                onBlur: g,
                onKeydown: x[1] || (x[1] = ru((k) => k.target.blur(), ["enter"]))
              }, null, 544), [
                [$t, r.value]
              ])
            ])
          ]),
          h("div", e2, [
            h("div", {
              class: "section-header",
              onClick: x[2] || (x[2] = (k) => f("transform"))
            }, [
              h("span", t2, pe(n.value.includes("transform") ? "" : ""), 1),
              x[28] || (x[28] = h("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (V(), B("div", n2, [
              h("div", s2, [
                x[29] || (x[29] = h("label", null, "Position", -1)),
                h("div", i2, [
                  Ae(Fe(Ne), {
                    modelValue: o.value.position.x,
                    "onUpdate:modelValue": [
                      x[3] || (x[3] = (k) => o.value.position.x = k),
                      p
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: o.value.position.y,
                    "onUpdate:modelValue": [
                      x[4] || (x[4] = (k) => o.value.position.y = k),
                      p
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"]),
                  (_ = c.value) != null && _.threeD ? (V(), ot(Fe(Ne), {
                    key: 0,
                    modelValue: o.value.position.z,
                    "onUpdate:modelValue": [
                      x[5] || (x[5] = (k) => o.value.position.z = k),
                      p
                    ],
                    precision: 1,
                    unit: "Z"
                  }, null, 8, ["modelValue"])) : Te("", !0)
                ]),
                h("button", {
                  class: Ie(["keyframe-btn", { active: v("position") }]),
                  onClick: x[6] || (x[6] = (k) => m("position"))
                }, "", 2)
              ]),
              h("div", r2, [
                x[30] || (x[30] = h("label", null, "Scale", -1)),
                h("div", o2, [
                  Ae(Fe(Ne), {
                    modelValue: o.value.scale.x,
                    "onUpdate:modelValue": [
                      x[7] || (x[7] = (k) => o.value.scale.x = k),
                      p
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%"
                  }, null, 8, ["modelValue"]),
                  h("button", {
                    class: Ie(["link-btn", { active: s.value }]),
                    onClick: x[8] || (x[8] = (k) => s.value = !s.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  Ae(Fe(Ne), {
                    modelValue: o.value.scale.y,
                    "onUpdate:modelValue": [
                      x[9] || (x[9] = (k) => o.value.scale.y = k),
                      p
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%"
                  }, null, 8, ["modelValue"])
                ]),
                h("button", {
                  class: Ie(["keyframe-btn", { active: v("scale") }]),
                  onClick: x[10] || (x[10] = (k) => m("scale"))
                }, "", 2)
              ]),
              (C = c.value) != null && C.threeD ? (V(), B(Re, { key: 0 }, [
                h("div", a2, [
                  x[31] || (x[31] = h("label", null, "Orientation", -1)),
                  h("div", l2, [
                    Ae(Fe(Ne), {
                      modelValue: o.value.orientationX,
                      "onUpdate:modelValue": [
                        x[11] || (x[11] = (k) => o.value.orientationX = k),
                        p
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    Ae(Fe(Ne), {
                      modelValue: o.value.orientationY,
                      "onUpdate:modelValue": [
                        x[12] || (x[12] = (k) => o.value.orientationY = k),
                        p
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    Ae(Fe(Ne), {
                      modelValue: o.value.orientationZ,
                      "onUpdate:modelValue": [
                        x[13] || (x[13] = (k) => o.value.orientationZ = k),
                        p
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                h("div", u2, [
                  x[32] || (x[32] = h("label", null, "X Rotation", -1)),
                  h("div", c2, [
                    Ae(Fe(Ne), {
                      modelValue: o.value.rotationX,
                      "onUpdate:modelValue": [
                        x[14] || (x[14] = (k) => o.value.rotationX = k),
                        p
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  h("button", {
                    class: Ie(["keyframe-btn", { active: v("rotationX") }]),
                    onClick: x[15] || (x[15] = (k) => m("rotationX"))
                  }, "", 2)
                ]),
                h("div", d2, [
                  x[33] || (x[33] = h("label", null, "Y Rotation", -1)),
                  h("div", h2, [
                    Ae(Fe(Ne), {
                      modelValue: o.value.rotationY,
                      "onUpdate:modelValue": [
                        x[16] || (x[16] = (k) => o.value.rotationY = k),
                        p
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  h("button", {
                    class: Ie(["keyframe-btn", { active: v("rotationY") }]),
                    onClick: x[17] || (x[17] = (k) => m("rotationY"))
                  }, "", 2)
                ]),
                h("div", f2, [
                  x[34] || (x[34] = h("label", null, "Z Rotation", -1)),
                  h("div", p2, [
                    Ae(Fe(Ne), {
                      modelValue: o.value.rotationZ,
                      "onUpdate:modelValue": [
                        x[18] || (x[18] = (k) => o.value.rotationZ = k),
                        p
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  h("button", {
                    class: Ie(["keyframe-btn", { active: v("rotationZ") }]),
                    onClick: x[19] || (x[19] = (k) => m("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (V(), B("div", m2, [
                x[35] || (x[35] = h("label", null, "Rotation", -1)),
                h("div", g2, [
                  Ae(Fe(Ne), {
                    modelValue: o.value.rotation,
                    "onUpdate:modelValue": [
                      x[20] || (x[20] = (k) => o.value.rotation = k),
                      p
                    ],
                    min: -360,
                    max: 360,
                    unit: ""
                  }, null, 8, ["modelValue"])
                ]),
                h("button", {
                  class: Ie(["keyframe-btn", { active: v("rotation") }]),
                  onClick: x[21] || (x[21] = (k) => m("rotation"))
                }, "", 2)
              ])),
              h("div", v2, [
                x[36] || (x[36] = h("label", null, "Anchor Point", -1)),
                h("div", y2, [
                  Ae(Fe(Ne), {
                    modelValue: o.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      x[22] || (x[22] = (k) => o.value.anchorPoint.x = k),
                      p
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: o.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      x[23] || (x[23] = (k) => o.value.anchorPoint.y = k),
                      p
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                h("button", {
                  class: Ie(["keyframe-btn", { active: v("anchorPoint") }]),
                  onClick: x[24] || (x[24] = (k) => m("anchorPoint"))
                }, "", 2)
              ]),
              h("div", b2, [
                x[37] || (x[37] = h("label", null, "Opacity", -1)),
                h("div", x2, [
                  Ae(Fe(cn), {
                    modelValue: o.value.opacity,
                    "onUpdate:modelValue": [
                      x[25] || (x[25] = (k) => o.value.opacity = k),
                      p
                    ],
                    min: 0,
                    max: 100,
                    unit: "%"
                  }, null, 8, ["modelValue"])
                ]),
                h("button", {
                  class: Ie(["keyframe-btn", { active: v("opacity") }]),
                  onClick: x[26] || (x[26] = (k) => m("opacity"))
                }, "", 2)
              ])
            ])) : Te("", !0)
          ]),
          h("div", _2, [
            h("div", w2, [
              x[38] || (x[38] = h("label", null, "Blend Mode", -1)),
              tt(h("select", {
                "onUpdate:modelValue": x[27] || (x[27] = (k) => a.value = k),
                class: "blend-select",
                onChange: y
              }, [
                (V(), B(Re, null, Ue(u, (k) => h("option", {
                  key: k.value,
                  value: k.value
                }, pe(k.label), 9, S2)), 64))
              ], 544), [
                [nn, a.value]
              ])
            ])
          ]),
          d.value ? (V(), ot(ah(d.value), {
            key: 0,
            layer: c.value,
            onUpdate: b
          }, null, 40, ["layer"])) : Te("", !0)
        ])) : (V(), B("div", C2, [...x[39] || (x[39] = [
          h("p", null, "No layer selected", -1),
          h("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), T2 = /* @__PURE__ */ mt(k2, [["__scopeId", "data-v-be5bab91"]]);
function Ke(i, e, n) {
  return { x: i, y: e, z: n };
}
function nt(i, e) {
  return { x: i.x + e.x, y: i.y + e.y, z: i.z + e.z };
}
function au(i, e) {
  return { x: i.x - e.x, y: i.y - e.y, z: i.z - e.z };
}
function rt(i, e) {
  return { x: i.x * e, y: i.y * e, z: i.z * e };
}
function M2(i) {
  return Math.sqrt(i.x * i.x + i.y * i.y + i.z * i.z);
}
function as(i) {
  const e = M2(i);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: i.x / e, y: i.y / e, z: i.z / e };
}
function Ei(i, e) {
  return {
    x: i.y * e.z - i.z * e.y,
    y: i.z * e.x - i.x * e.z,
    z: i.x * e.y - i.y * e.x
  };
}
function Ja(i, e) {
  return i.x * e.x + i.y * e.y + i.z * e.z;
}
function O2(i, e, n, s) {
  const r = new Float32Array(16), o = 1 / Math.tan(i / 2), a = 1 / (n - s);
  return r[0] = o / e, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = (s + n) * a, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = 2 * s * n * a, r[15] = 0, { elements: r };
}
function E2(i, e, n, s, r, o) {
  const a = new Float32Array(16), l = 1 / (e - i), u = 1 / (s - n), c = 1 / (o - r);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * u, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * c, a[11] = 0, a[12] = -(e + i) * l, a[13] = -(s + n) * u, a[14] = -10001 * c, a[15] = 1, { elements: a };
}
function zn(i, e, n) {
  const s = new Float32Array(16);
  let r = i.x - e.x, o = i.y - e.y, a = i.z - e.z, l = Math.sqrt(r * r + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, r *= l, o *= l, a *= l);
  let u = n.y * a - n.z * o, c = n.z * r - n.x * a, d = n.x * o - n.y * r;
  l = Math.sqrt(u * u + c * c + d * d), l === 0 ? (u = 0, c = 0, d = 0) : (l = 1 / l, u *= l, c *= l, d *= l);
  let f = o * d - a * c, g = a * u - r * d, p = r * c - o * u;
  return l = Math.sqrt(f * f + g * g + p * p), l === 0 ? (f = 0, g = 0, p = 0) : (l = 1 / l, f *= l, g *= l, p *= l), s[0] = u, s[4] = c, s[8] = d, s[12] = -Ja({ x: u, y: c, z: d }, i), s[1] = f, s[5] = g, s[9] = p, s[13] = -Ja({ x: f, y: g, z: p }, i), s[2] = r, s[6] = o, s[10] = a, s[14] = -Ja({ x: r, y: o, z: a }, i), s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, { elements: s };
}
function P2(i, e) {
  const n = i.elements, s = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / s,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / s,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / s
  };
}
function lu(i, e) {
  return 2 * Math.atan(e / (2 * i));
}
function D2(i, e) {
  return e / (2 * Math.tan(i / 2));
}
const A2 = { class: "camera-properties" }, I2 = { class: "panel-header" }, F2 = { class: "camera-name" }, L2 = {
  key: 0,
  class: "properties-content"
}, z2 = { class: "property-section" }, R2 = { class: "property-row" }, V2 = ["value"], j2 = { class: "property-section" }, $2 = { class: "toggle-icon" }, B2 = { class: "section-content" }, W2 = { class: "property-group" }, U2 = { class: "xyz-inputs" }, N2 = {
  key: 0,
  class: "property-group"
}, H2 = { class: "xyz-inputs" }, X2 = { class: "property-group" }, Y2 = { class: "xyz-inputs" }, G2 = { class: "property-group" }, K2 = { class: "property-group" }, q2 = { class: "property-group" }, Z2 = { class: "property-section" }, J2 = { class: "toggle-icon" }, Q2 = { class: "section-content" }, ek = { class: "preset-row" }, tk = ["onClick"], nk = { class: "property-group" }, sk = { class: "property-group" }, ik = { class: "property-group" }, rk = { class: "property-group" }, ok = ["value"], ak = { class: "property-section" }, lk = { class: "toggle-icon" }, uk = { class: "section-content" }, ck = { class: "property-group checkbox-group" }, dk = ["checked"], hk = { class: "property-group" }, fk = { class: "property-group" }, pk = { class: "property-group" }, mk = { class: "property-group checkbox-group" }, gk = ["checked"], vk = { class: "property-section" }, yk = { class: "toggle-icon" }, bk = { class: "section-content" }, xk = { class: "property-group" }, _k = { class: "property-group" }, wk = { class: "property-group" }, Sk = { class: "property-group" }, Ck = { class: "property-group" }, kk = { class: "property-section" }, Tk = { class: "toggle-icon" }, Mk = { class: "section-content" }, Ok = { class: "property-group" }, Ek = { class: "property-group" }, Pk = { class: "property-group" }, Dk = { class: "property-section" }, Ak = { class: "toggle-icon" }, Ik = { class: "section-content" }, Fk = { class: "property-group" }, Lk = ["value"], zk = { class: "property-section" }, Rk = { class: "toggle-icon" }, Vk = { class: "section-content" }, jk = { class: "property-group" }, $k = { class: "property-group" }, Bk = {
  key: 1,
  class: "no-camera"
}, Wk = /* @__PURE__ */ pt({
  __name: "CameraProperties",
  setup(i) {
    const e = Ot(), n = Oe(() => {
      const m = e.selectedLayer;
      if ((m == null ? void 0 : m.type) === "camera" && m.data) {
        const b = m.data;
        return e.getCamera(b.cameraId);
      }
      return e.activeCamera;
    }), s = Ai({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1
    });
    function r(m) {
      s[m] = !s[m];
    }
    function o(m, b) {
      n.value && e.updateCamera(n.value.id, { [m]: b });
    }
    function a(m, b) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [m]: b }
      });
    }
    function l(m, b) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [m]: b }
      });
    }
    function u(m, b) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [m]: b }
      });
    }
    function c(m) {
      if (!n.value) return;
      const b = lu(m, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: m,
        angleOfView: b
      });
    }
    function d(m) {
      if (!n.value) return;
      const b = D2(m, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: m,
        focalLength: b
      });
    }
    function f(m, b) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [m]: b }
      });
    }
    function g(m, b) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [m]: b }
      });
    }
    function p(m, b) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [m]: b }
      });
    }
    function y(m) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: m.focalLength,
        angleOfView: m.angleOfView,
        zoom: m.zoom
      });
    }
    function v() {
      e.createCameraLayer();
    }
    return (m, b) => {
      var S;
      return V(), B("div", A2, [
        h("div", I2, [
          b[38] || (b[38] = h("span", { class: "panel-title" }, "Camera", -1)),
          h("span", F2, pe(((S = n.value) == null ? void 0 : S.name) ?? "No Camera"), 1)
        ]),
        n.value ? (V(), B("div", L2, [
          h("div", z2, [
            b[40] || (b[40] = h("div", { class: "section-header" }, "Type", -1)),
            h("div", R2, [
              h("select", {
                value: n.value.type,
                onChange: b[0] || (b[0] = (x) => o("type", x.target.value)),
                class: "type-select"
              }, [...b[39] || (b[39] = [
                h("option", { value: "one-node" }, "One-Node Camera", -1),
                h("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, V2)
            ])
          ]),
          h("div", j2, [
            h("div", {
              class: "section-header",
              onClick: b[1] || (b[1] = (x) => r("transform"))
            }, [
              h("span", $2, pe(s.transform ? "" : ""), 1),
              b[41] || (b[41] = qe(" Transform ", -1))
            ]),
            tt(h("div", B2, [
              h("div", W2, [
                b[42] || (b[42] = h("label", null, "Position", -1)),
                h("div", U2, [
                  Ae(Fe(Ne), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": b[2] || (b[2] = (x) => a("x", x)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": b[3] || (b[3] = (x) => a("y", x)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": b[4] || (b[4] = (x) => a("z", x)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (V(), B("div", N2, [
                b[43] || (b[43] = h("label", null, "Point of Interest", -1)),
                h("div", H2, [
                  Ae(Fe(Ne), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": b[5] || (b[5] = (x) => l("x", x)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": b[6] || (b[6] = (x) => l("y", x)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": b[7] || (b[7] = (x) => l("z", x)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Te("", !0),
              h("div", X2, [
                b[44] || (b[44] = h("label", null, "Orientation", -1)),
                h("div", Y2, [
                  Ae(Fe(Ne), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": b[8] || (b[8] = (x) => u("x", x)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": b[9] || (b[9] = (x) => u("y", x)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ae(Fe(Ne), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": b[10] || (b[10] = (x) => u("z", x)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              h("div", G2, [
                b[45] || (b[45] = h("label", null, "X Rotation", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": b[11] || (b[11] = (x) => o("xRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", K2, [
                b[46] || (b[46] = h("label", null, "Y Rotation", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": b[12] || (b[12] = (x) => o("yRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", q2, [
                b[47] || (b[47] = h("label", null, "Z Rotation", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": b[13] || (b[13] = (x) => o("zRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [$s, s.transform]
            ])
          ]),
          h("div", Z2, [
            h("div", {
              class: "section-header",
              onClick: b[14] || (b[14] = (x) => r("lens"))
            }, [
              h("span", J2, pe(s.lens ? "" : ""), 1),
              b[48] || (b[48] = qe(" Lens ", -1))
            ]),
            tt(h("div", Q2, [
              h("div", ek, [
                (V(!0), B(Re, null, Ue(Fe(Xg), (x) => (V(), B("button", {
                  key: x.name,
                  class: Ie({ active: Math.abs(n.value.focalLength - x.focalLength) < 0.5 }),
                  onClick: (_) => y(x)
                }, pe(x.name), 11, tk))), 128))
              ]),
              h("div", nk, [
                b[49] || (b[49] = h("label", null, "Focal Length", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": c,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", sk, [
                b[50] || (b[50] = h("label", null, "Angle of View", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": d,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", ik, [
                b[51] || (b[51] = h("label", null, "Film Size", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": b[15] || (b[15] = (x) => o("filmSize", x)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", rk, [
                b[53] || (b[53] = h("label", null, "Measure Film Size", -1)),
                h("select", {
                  value: n.value.measureFilmSize,
                  onChange: b[16] || (b[16] = (x) => o("measureFilmSize", x.target.value))
                }, [...b[52] || (b[52] = [
                  h("option", { value: "horizontal" }, "Horizontal", -1),
                  h("option", { value: "vertical" }, "Vertical", -1),
                  h("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, ok)
              ])
            ], 512), [
              [$s, s.lens]
            ])
          ]),
          h("div", ak, [
            h("div", {
              class: "section-header",
              onClick: b[17] || (b[17] = (x) => r("dof"))
            }, [
              h("span", lk, pe(s.dof ? "" : ""), 1),
              b[54] || (b[54] = qe(" Depth of Field ", -1))
            ]),
            tt(h("div", uk, [
              h("div", ck, [
                h("label", null, [
                  h("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: b[18] || (b[18] = (x) => f("enabled", x.target.checked))
                  }, null, 40, dk),
                  b[55] || (b[55] = qe(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (V(), B(Re, { key: 0 }, [
                h("div", hk, [
                  b[56] || (b[56] = h("label", null, "Focus Distance", -1)),
                  Ae(Fe(Ne), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": b[19] || (b[19] = (x) => f("focusDistance", x)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                h("div", fk, [
                  b[57] || (b[57] = h("label", null, "f-Stop", -1)),
                  Ae(Fe(Ne), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": b[20] || (b[20] = (x) => f("fStop", x)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                h("div", pk, [
                  b[58] || (b[58] = h("label", null, "Blur Level", -1)),
                  Ae(Fe(cn), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": b[21] || (b[21] = (x) => f("blurLevel", x)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                h("div", mk, [
                  h("label", null, [
                    h("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: b[22] || (b[22] = (x) => f("lockToZoom", x.target.checked))
                    }, null, 40, gk),
                    b[59] || (b[59] = qe(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Te("", !0)
            ], 512), [
              [$s, s.dof]
            ])
          ]),
          h("div", vk, [
            h("div", {
              class: "section-header",
              onClick: b[23] || (b[23] = (x) => r("iris"))
            }, [
              h("span", yk, pe(s.iris ? "" : ""), 1),
              b[60] || (b[60] = qe(" Iris ", -1))
            ]),
            tt(h("div", bk, [
              h("div", xk, [
                h("label", null, "Shape (" + pe(Math.round(n.value.iris.shape)) + "-gon)", 1),
                Ae(Fe(cn), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": b[24] || (b[24] = (x) => g("shape", x)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", _k, [
                b[61] || (b[61] = h("label", null, "Rotation", -1)),
                Ae(Fe(ou), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": b[25] || (b[25] = (x) => g("rotation", x)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              h("div", wk, [
                b[62] || (b[62] = h("label", null, "Roundness", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": b[26] || (b[26] = (x) => g("roundness", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              h("div", Sk, [
                b[63] || (b[63] = h("label", null, "Aspect Ratio", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": b[27] || (b[27] = (x) => g("aspectRatio", x)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              h("div", Ck, [
                b[64] || (b[64] = h("label", null, "Diffraction Fringe", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": b[28] || (b[28] = (x) => g("diffractionFringe", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [$s, s.iris]
            ])
          ]),
          h("div", kk, [
            h("div", {
              class: "section-header",
              onClick: b[29] || (b[29] = (x) => r("highlight"))
            }, [
              h("span", Tk, pe(s.highlight ? "" : ""), 1),
              b[65] || (b[65] = qe(" Highlight ", -1))
            ]),
            tt(h("div", Mk, [
              h("div", Ok, [
                b[66] || (b[66] = h("label", null, "Gain", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": b[30] || (b[30] = (x) => p("gain", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              h("div", Ek, [
                b[67] || (b[67] = h("label", null, "Threshold", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": b[31] || (b[31] = (x) => p("threshold", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              h("div", Pk, [
                b[68] || (b[68] = h("label", null, "Saturation", -1)),
                Ae(Fe(cn), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": b[32] || (b[32] = (x) => p("saturation", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [$s, s.highlight]
            ])
          ]),
          h("div", Dk, [
            h("div", {
              class: "section-header",
              onClick: b[33] || (b[33] = (x) => r("autoOrient"))
            }, [
              h("span", Ak, pe(s.autoOrient ? "" : ""), 1),
              b[69] || (b[69] = qe(" Auto-Orient ", -1))
            ]),
            tt(h("div", Ik, [
              h("div", Fk, [
                h("select", {
                  value: n.value.autoOrient,
                  onChange: b[34] || (b[34] = (x) => o("autoOrient", x.target.value))
                }, [...b[70] || (b[70] = [
                  h("option", { value: "off" }, "Off", -1),
                  h("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  h("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, Lk)
              ])
            ], 512), [
              [$s, s.autoOrient]
            ])
          ]),
          h("div", zk, [
            h("div", {
              class: "section-header",
              onClick: b[35] || (b[35] = (x) => r("clipping"))
            }, [
              h("span", Rk, pe(s.clipping ? "" : ""), 1),
              b[71] || (b[71] = qe(" Clipping ", -1))
            ]),
            tt(h("div", Vk, [
              h("div", jk, [
                b[72] || (b[72] = h("label", null, "Near Clip", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": b[36] || (b[36] = (x) => o("nearClip", x)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              h("div", $k, [
                b[73] || (b[73] = h("label", null, "Far Clip", -1)),
                Ae(Fe(Ne), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": b[37] || (b[37] = (x) => o("farClip", x)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [$s, s.clipping]
            ])
          ])
        ])) : (V(), B("div", Bk, [
          b[74] || (b[74] = h("p", null, "No camera selected", -1)),
          h("button", { onClick: v }, "Create Camera")
        ]))
      ]);
    };
  }
}), Uk = /* @__PURE__ */ mt(Wk, [["__scopeId", "data-v-15ec84e3"]]), Nk = { class: "audio-properties" }, Hk = { class: "property-section" }, Xk = {
  key: 0,
  class: "section-content"
}, Yk = { class: "property-row" }, Gk = { class: "value-display" }, Kk = { class: "property-row" }, qk = { class: "value-display" }, Zk = { class: "property-row" }, Jk = { class: "value-display" }, Qk = { class: "property-row" }, e5 = {
  key: 0,
  class: "peak-count"
}, t5 = { class: "property-section" }, n5 = { class: "mapping-count" }, s5 = {
  key: 0,
  class: "section-content"
}, i5 = { class: "mapping-header" }, r5 = { class: "mapping-enabled" }, o5 = ["onUpdate:modelValue"], a5 = { class: "mapping-name" }, l5 = ["onClick"], u5 = {
  key: 0,
  class: "mapping-details"
}, c5 = { class: "property-row" }, d5 = ["onUpdate:modelValue"], h5 = ["value"], f5 = { class: "property-row" }, p5 = ["onUpdate:modelValue"], m5 = ["label"], g5 = ["value"], v5 = { class: "property-row" }, y5 = ["onUpdate:modelValue"], b5 = { class: "value-display" }, x5 = { class: "property-row" }, _5 = ["onUpdate:modelValue"], w5 = { class: "value-display" }, S5 = { class: "property-row" }, C5 = ["onUpdate:modelValue"], k5 = { class: "value-display" }, T5 = { class: "property-row" }, M5 = ["onUpdate:modelValue"], O5 = ["onUpdate:modelValue"], E5 = { class: "property-row" }, P5 = ["onUpdate:modelValue"], D5 = ["onClick"], A5 = { class: "property-section" }, I5 = {
  key: 0,
  class: "section-content"
}, F5 = { class: "property-row" }, L5 = ["value"], z5 = { class: "visualizer-canvas-container" }, R5 = { class: "visualizer-value" }, V5 = /* @__PURE__ */ pt({
  __name: "AudioProperties",
  setup(i) {
    const e = Ot(), n = me(/* @__PURE__ */ new Set(["peaks", "mappings"])), s = me(/* @__PURE__ */ new Set()), r = me({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), o = me(null), a = me([]), l = me("amplitude"), u = me(null), c = Oe(() => dv()), d = Oe(() => hv()), f = Oe(
      () => e.currentFrame / e.frameCount * 100
    ), g = Oe(() => e.audioAnalysis ? Ho(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function p(x) {
      n.value.has(x) ? n.value.delete(x) : n.value.add(x);
    }
    function y(x) {
      s.value.has(x) ? s.value.delete(x) : s.value.add(x);
    }
    function v() {
      if (!e.audioAnalysis) return;
      const x = e.audioAnalysis.amplitudeEnvelope;
      o.value = jh(x, r.value), e.setPeakData(o.value);
    }
    function m() {
      const x = uv();
      a.value.push(x), s.value.add(x.id), e.addAudioMapping(x);
    }
    function b(x) {
      const _ = a.value.findIndex((C) => C.id === x);
      _ >= 0 && (a.value.splice(_, 1), s.value.delete(x), e.removeAudioMapping(x));
    }
    function S() {
      const x = u.value;
      if (!x || !e.audioAnalysis) return;
      const _ = x.getContext("2d");
      if (!_) return;
      const C = x.width, k = x.height;
      _.fillStyle = "#1e1e1e", _.fillRect(0, 0, C, k);
      let M = [];
      const O = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          M = O.amplitudeEnvelope;
          break;
        case "rms":
          M = O.rmsEnergy;
          break;
        case "spectralCentroid":
          M = O.spectralCentroid;
          break;
        case "bass":
          M = O.frequencyBands.bass;
          break;
        case "mid":
          M = O.frequencyBands.mid;
          break;
        case "high":
          M = O.frequencyBands.high;
          break;
        case "sub":
          M = O.frequencyBands.sub;
          break;
        case "lowMid":
          M = O.frequencyBands.lowMid;
          break;
        case "highMid":
          M = O.frequencyBands.highMid;
          break;
        case "onsets":
          M = new Array(O.frameCount).fill(0);
          for (const F of O.onsets)
            F < M.length && (M[F] = 1);
          break;
        case "peaks":
          if (o.value) {
            M = new Array(O.frameCount).fill(0);
            for (const F of o.value.indices)
              F < M.length && (M[F] = 1);
          }
          break;
      }
      if (M.length !== 0) {
        _.strokeStyle = "#4a90d9", _.lineWidth = 1.5, _.beginPath();
        for (let F = 0; F < M.length; F++) {
          const $ = F / M.length * C, ne = k - M[F] * k * 0.9 - 5;
          F === 0 ? _.moveTo($, ne) : _.lineTo($, ne);
        }
        if (_.stroke(), o.value && l.value !== "peaks") {
          _.fillStyle = "#ff6b6b";
          for (const F of o.value.indices) {
            const $ = F / M.length * C;
            _.beginPath(), _.moveTo($, 0), _.lineTo($, k), _.strokeStyle = "rgba(255, 107, 107, 0.3)", _.stroke();
          }
        }
      }
    }
    return ut(
      () => [e.audioAnalysis, l.value, o.value],
      () => {
        S();
      }
    ), ut(
      a,
      (x) => {
        for (const _ of x)
          e.updateAudioMapping(_.id, _);
      },
      { deep: !0 }
    ), Rt(() => {
      S();
      const x = e.getAudioMappings();
      x.length > 0 && (a.value = [...x]);
    }), (x, _) => (V(), B("div", Nk, [
      h("div", Hk, [
        h("div", {
          class: "section-header",
          onClick: _[0] || (_[0] = (C) => p("peaks"))
        }, [
          h("i", {
            class: Ie(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          _[7] || (_[7] = h("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (V(), B("div", Xk, [
          h("div", Yk, [
            _[8] || (_[8] = h("label", null, "Threshold", -1)),
            tt(h("input", {
              type: "range",
              "onUpdate:modelValue": _[1] || (_[1] = (C) => r.value.threshold = C),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                $t,
                r.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            h("span", Gk, pe(r.value.threshold.toFixed(2)), 1)
          ]),
          h("div", Kk, [
            _[9] || (_[9] = h("label", null, "Min Peak Distance", -1)),
            tt(h("input", {
              type: "range",
              "onUpdate:modelValue": _[2] || (_[2] = (C) => r.value.minPeaksDistance = C),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                $t,
                r.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            h("span", qk, pe(r.value.minPeaksDistance) + " frames", 1)
          ]),
          h("div", Zk, [
            _[10] || (_[10] = h("label", null, "Multiply", -1)),
            tt(h("input", {
              type: "range",
              "onUpdate:modelValue": _[3] || (_[3] = (C) => r.value.multiply = C),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                $t,
                r.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            h("span", Jk, pe(r.value.multiply.toFixed(1)) + "x", 1)
          ]),
          h("div", Qk, [
            h("button", {
              class: "action-btn",
              onClick: v
            }, [..._[11] || (_[11] = [
              h("i", { class: "pi pi-bolt" }, null, -1),
              qe(" Detect Peaks ", -1)
            ])]),
            o.value ? (V(), B("span", e5, pe(o.value.count) + " peaks found ", 1)) : Te("", !0)
          ])
        ])) : Te("", !0)
      ]),
      h("div", t5, [
        h("div", {
          class: "section-header",
          onClick: _[4] || (_[4] = (C) => p("mappings"))
        }, [
          h("i", {
            class: Ie(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          _[12] || (_[12] = h("span", null, "Audio Mappings", -1)),
          h("span", n5, pe(a.value.length), 1)
        ]),
        n.value.has("mappings") ? (V(), B("div", s5, [
          h("button", {
            class: "action-btn add-mapping-btn",
            onClick: m
          }, [..._[13] || (_[13] = [
            h("i", { class: "pi pi-plus" }, null, -1),
            qe(" Add Mapping ", -1)
          ])]),
          (V(!0), B(Re, null, Ue(a.value, (C) => (V(), B("div", {
            key: C.id,
            class: "mapping-item"
          }, [
            h("div", i5, [
              h("label", r5, [
                tt(h("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": (k) => C.enabled = k
                }, null, 8, o5), [
                  [No, C.enabled]
                ])
              ]),
              h("span", a5, pe(Fe(Za)(C.feature)) + "  " + pe(Fe(vc)(C.target)), 1),
              h("button", {
                class: "delete-btn",
                onClick: (k) => b(C.id)
              }, [..._[14] || (_[14] = [
                h("i", { class: "pi pi-times" }, null, -1)
              ])], 8, l5)
            ]),
            s.value.has(C.id) ? (V(), B("div", u5, [
              h("div", c5, [
                _[15] || (_[15] = h("label", null, "Feature", -1)),
                tt(h("select", {
                  "onUpdate:modelValue": (k) => C.feature = k
                }, [
                  (V(!0), B(Re, null, Ue(c.value, (k) => (V(), B("option", {
                    key: k,
                    value: k
                  }, pe(Fe(Za)(k)), 9, h5))), 128))
                ], 8, d5), [
                  [nn, C.feature]
                ])
              ]),
              h("div", f5, [
                _[16] || (_[16] = h("label", null, "Target", -1)),
                tt(h("select", {
                  "onUpdate:modelValue": (k) => C.target = k
                }, [
                  (V(!0), B(Re, null, Ue(d.value, (k, M) => (V(), B("optgroup", {
                    key: M,
                    label: M
                  }, [
                    (V(!0), B(Re, null, Ue(k, (O) => (V(), B("option", {
                      key: O,
                      value: O
                    }, pe(Fe(vc)(O)), 9, g5))), 128))
                  ], 8, m5))), 128))
                ], 8, p5), [
                  [nn, C.target]
                ])
              ]),
              h("div", v5, [
                _[17] || (_[17] = h("label", null, "Sensitivity", -1)),
                tt(h("input", {
                  type: "range",
                  "onUpdate:modelValue": (k) => C.sensitivity = k,
                  min: "0.1",
                  max: "5",
                  step: "0.1"
                }, null, 8, y5), [
                  [
                    $t,
                    C.sensitivity,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                h("span", b5, pe(C.sensitivity.toFixed(1)) + "x", 1)
              ]),
              h("div", x5, [
                _[18] || (_[18] = h("label", null, "Threshold", -1)),
                tt(h("input", {
                  type: "range",
                  "onUpdate:modelValue": (k) => C.threshold = k,
                  min: "0",
                  max: "1",
                  step: "0.01"
                }, null, 8, _5), [
                  [
                    $t,
                    C.threshold,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                h("span", w5, pe(C.threshold.toFixed(2)), 1)
              ]),
              h("div", S5, [
                _[19] || (_[19] = h("label", null, "Smoothing", -1)),
                tt(h("input", {
                  type: "range",
                  "onUpdate:modelValue": (k) => C.smoothing = k,
                  min: "0",
                  max: "0.99",
                  step: "0.01"
                }, null, 8, C5), [
                  [
                    $t,
                    C.smoothing,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                h("span", k5, pe(C.smoothing.toFixed(2)), 1)
              ]),
              h("div", T5, [
                _[20] || (_[20] = h("label", null, "Min/Max", -1)),
                tt(h("input", {
                  type: "number",
                  "onUpdate:modelValue": (k) => C.min = k,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, M5), [
                  [
                    $t,
                    C.min,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                _[21] || (_[21] = h("span", { class: "separator" }, "-", -1)),
                tt(h("input", {
                  type: "number",
                  "onUpdate:modelValue": (k) => C.max = k,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, O5), [
                  [
                    $t,
                    C.max,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              h("div", E5, [
                h("label", null, [
                  tt(h("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (k) => C.invert = k
                  }, null, 8, P5), [
                    [No, C.invert]
                  ]),
                  _[22] || (_[22] = qe(" Invert ", -1))
                ])
              ])
            ])) : Te("", !0),
            h("button", {
              class: "expand-btn",
              onClick: (k) => y(C.id)
            }, [
              h("i", {
                class: Ie(["pi", s.value.has(C.id) ? "pi-chevron-up" : "pi-chevron-down"])
              }, null, 2)
            ], 8, D5)
          ]))), 128))
        ])) : Te("", !0)
      ]),
      h("div", A5, [
        h("div", {
          class: "section-header",
          onClick: _[5] || (_[5] = (C) => p("visualizer"))
        }, [
          h("i", {
            class: Ie(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          _[23] || (_[23] = h("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (V(), B("div", I5, [
          h("div", F5, [
            _[24] || (_[24] = h("label", null, "Feature", -1)),
            tt(h("select", {
              "onUpdate:modelValue": _[6] || (_[6] = (C) => l.value = C)
            }, [
              (V(!0), B(Re, null, Ue(c.value, (C) => (V(), B("option", {
                key: C,
                value: C
              }, pe(Fe(Za)(C)), 9, L5))), 128))
            ], 512), [
              [nn, l.value]
            ])
          ]),
          h("div", z5, [
            h("canvas", {
              ref_key: "visualizerCanvas",
              ref: u,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            h("div", {
              class: "visualizer-playhead",
              style: Xe({ left: `${f.value}%` })
            }, null, 4)
          ]),
          h("div", R5, " Current: " + pe(g.value.toFixed(3)), 1)
        ])) : Te("", !0)
      ])
    ]));
  }
}), j5 = /* @__PURE__ */ mt(V5, [["__scopeId", "data-v-f0f6c1bb"]]), $5 = { class: "audio-panel" }, B5 = {
  key: 0,
  class: "panel-content"
}, W5 = { class: "audio-info" }, U5 = { class: "file-info" }, N5 = { class: "file-details" }, H5 = { class: "file-name" }, X5 = { class: "file-meta" }, Y5 = { class: "control-section" }, G5 = { class: "control-row" }, K5 = { class: "waveform-section" }, q5 = { class: "waveform-display" }, Z5 = { class: "linker-section" }, J5 = {
  key: 1,
  class: "empty-state"
}, Q5 = /* @__PURE__ */ pt({
  __name: "AudioPanel",
  setup(i) {
    const e = Ot(), n = me(null), s = me(null), r = me(100), o = me(!1), a = Oe(() => !!e.audioBuffer), l = Oe(() => {
      var v;
      return ((v = e.audioFile) == null ? void 0 : v.name) || "Unknown";
    }), u = Oe(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), c = Oe(() => {
      if (!e.audioBuffer) return "0:00";
      const v = Math.floor(e.audioBuffer.duration / 60), m = Math.floor(e.audioBuffer.duration % 60);
      return `${v}:${m.toString().padStart(2, "0")}`;
    });
    function d() {
      var v;
      (v = n.value) == null || v.click();
    }
    async function f(v) {
      var b;
      const m = v.target;
      (b = m.files) != null && b.length && await e.loadAudio(m.files[0]), m.value = "";
    }
    function g() {
      e.clearAudio();
    }
    function p() {
      o.value = !o.value;
    }
    function y() {
      if (!s.value || !e.audioBuffer) return;
      const v = s.value, m = v.getContext("2d");
      if (!m) return;
      const b = v.getBoundingClientRect();
      v.width = b.width * window.devicePixelRatio, v.height = 60 * window.devicePixelRatio, m.scale(window.devicePixelRatio, window.devicePixelRatio);
      const S = e.audioBuffer.getChannelData(0), x = Math.ceil(S.length / b.width), _ = 30;
      m.fillStyle = "#1a1a1a", m.fillRect(0, 0, b.width, 60), m.beginPath(), m.strokeStyle = "#4a90d9", m.lineWidth = 1;
      for (let k = 0; k < b.width; k++) {
        let M = 1, O = -1;
        for (let F = 0; F < x; F++) {
          const $ = S[k * x + F];
          $ < M && (M = $), $ > O && (O = $);
        }
        m.moveTo(k, (1 + M) * _), m.lineTo(k, (1 + O) * _);
      }
      m.stroke();
      const C = e.currentFrame / e.frameCount * b.width;
      m.fillStyle = "#fff", m.fillRect(C, 0, 1, 60);
    }
    return ut(() => [e.audioBuffer, e.currentFrame], y), Rt(() => {
      a.value && setTimeout(y, 100);
    }), (v, m) => (V(), B("div", $5, [
      h("div", { class: "panel-header" }, [
        m[2] || (m[2] = h("span", { class: "panel-title" }, "Audio Source", -1)),
        h("div", { class: "header-actions" }, [
          h("button", {
            onClick: d,
            title: "Load Audio"
          }, [...m[1] || (m[1] = [
            h("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      a.value ? (V(), B("div", B5, [
        h("div", W5, [
          h("div", U5, [
            m[3] || (m[3] = h("span", { class: "file-icon" }, "", -1)),
            h("div", N5, [
              h("span", H5, pe(l.value), 1),
              h("span", X5, pe(c.value) + "  " + pe(u.value), 1)
            ]),
            h("button", {
              class: "remove-btn",
              onClick: g,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        h("div", Y5, [
          h("div", G5, [
            m[4] || (m[4] = h("label", null, "Master Vol", -1)),
            Ae(Fe(cn), {
              modelValue: r.value,
              "onUpdate:modelValue": m[0] || (m[0] = (b) => r.value = b),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            h("button", {
              class: Ie(["mute-btn", { active: o.value }]),
              onClick: p,
              title: "Mute"
            }, pe(o.value ? "" : ""), 3)
          ])
        ]),
        h("div", K5, [
          m[5] || (m[5] = h("div", { class: "section-header" }, [
            h("span", { class: "section-title" }, "Waveform")
          ], -1)),
          h("div", q5, [
            h("canvas", {
              ref_key: "waveformCanvas",
              ref: s,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        h("div", Z5, [
          m[6] || (m[6] = h("div", { class: "linker-header" }, "Audio Linker", -1)),
          Ae(j5)
        ])
      ])) : (V(), B("div", J5, [
        m[7] || (m[7] = h("div", { class: "empty-icon" }, "", -1)),
        m[8] || (m[8] = h("p", null, "No audio loaded", -1)),
        h("button", {
          class: "load-btn",
          onClick: d
        }, "Load Audio File"),
        m[9] || (m[9] = h("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      h("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: f
      }, null, 544)
    ]));
  }
}), eT = /* @__PURE__ */ mt(Q5, [["__scopeId", "data-v-66384e06"]]), _c = 40, tT = 30;
function nT(i) {
  const e = [], n = "#ffcc00", s = i.position;
  let r;
  if (i.type === "two-node")
    r = as(au(i.pointOfInterest, s));
  else {
    const p = i.orientation.x * Math.PI / 180, y = i.orientation.y * Math.PI / 180;
    r = Ke(
      Math.sin(y) * Math.cos(p),
      -Math.sin(p),
      Math.cos(y) * Math.cos(p)
    );
  }
  const o = Ke(0, -1, 0);
  let a = as(Ei(r, o));
  isNaN(a.x) && (a = Ke(1, 0, 0));
  const l = as(Ei(a, r)), u = _c / 2, c = nt(s, rt(r, -_c)), d = [];
  for (let p = 0; p < 2; p++) {
    const y = p === 0 ? s : c;
    for (let v = -1; v <= 1; v += 2)
      for (let m = -1; m <= 1; m += 2)
        d.push(nt(
          nt(y, rt(a, v * u)),
          rt(l, m * u)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const f = nt(s, rt(r, tT)), g = 8;
  for (let p = 0; p < g; p++) {
    const y = p / g * Math.PI * 2, v = (p + 1) / g * Math.PI * 2, m = nt(
      nt(s, rt(a, Math.cos(y) * u * 0.5)),
      rt(l, Math.sin(y) * u * 0.5)
    ), b = nt(
      nt(s, rt(a, Math.cos(v) * u * 0.5)),
      rt(l, Math.sin(v) * u * 0.5)
    );
    e.push({ start: m, end: b, color: n }), e.push({ start: m, end: f, color: n });
  }
  return e;
}
function sT(i, e, n, s = 2e3) {
  const r = [], o = "#7c9cff", a = lu(i.focalLength, i.filmSize), l = e / n, u = i.position;
  let c;
  if (i.type === "two-node")
    c = as(au(i.pointOfInterest, u));
  else {
    const M = i.orientation.x * Math.PI / 180, O = i.orientation.y * Math.PI / 180;
    c = Ke(
      Math.sin(O) * Math.cos(M),
      -Math.sin(M),
      Math.cos(O) * Math.cos(M)
    );
  }
  const d = Ke(0, -1, 0);
  let f = as(Ei(c, d));
  isNaN(f.x) && (f = Ke(1, 0, 0));
  const g = as(Ei(f, c)), p = i.nearClip, y = Math.min(i.farClip, s), v = p * Math.tan(a * Math.PI / 360), m = v * l, b = y * Math.tan(a * Math.PI / 360), S = b * l, x = nt(u, rt(c, p)), _ = [
    nt(nt(x, rt(f, -m)), rt(g, v)),
    nt(nt(x, rt(f, m)), rt(g, v)),
    nt(nt(x, rt(f, m)), rt(g, -v)),
    nt(nt(x, rt(f, -m)), rt(g, -v))
  ], C = nt(u, rt(c, y)), k = [
    nt(nt(C, rt(f, -S)), rt(g, b)),
    nt(nt(C, rt(f, S)), rt(g, b)),
    nt(nt(C, rt(f, S)), rt(g, -b)),
    nt(nt(C, rt(f, -S)), rt(g, -b))
  ];
  for (let M = 0; M < 4; M++)
    r.push({ start: _[M], end: _[(M + 1) % 4], color: o });
  for (let M = 0; M < 4; M++)
    r.push({ start: k[M], end: k[(M + 1) % 4], color: o });
  for (let M = 0; M < 4; M++)
    r.push({ start: _[M], end: k[M], color: o });
  return r;
}
function iT(i, e) {
  const n = "#00ff88", s = [
    Ke(0, 0, 0),
    Ke(i, 0, 0),
    Ke(i, e, 0),
    Ke(0, e, 0)
  ], r = [];
  for (let o = 0; o < 4; o++)
    r.push({ start: s[o], end: s[(o + 1) % 4], color: n });
  return r.push({ start: s[0], end: s[2], color: "#005533" }), r.push({ start: s[1], end: s[3], color: "#005533" }), r;
}
function rT(i) {
  return i.type !== "two-node" ? null : {
    start: i.position,
    end: i.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function oT(i, e, n) {
  if (!i.depthOfField.enabled)
    return [];
  const s = "#ff00ff", r = [], o = i.position, a = i.depthOfField.focusDistance;
  let l;
  if (i.type === "two-node")
    l = as(au(i.pointOfInterest, o));
  else {
    const v = i.orientation.x * Math.PI / 180, m = i.orientation.y * Math.PI / 180;
    l = Ke(
      Math.sin(m) * Math.cos(v),
      -Math.sin(v),
      Math.cos(m) * Math.cos(v)
    );
  }
  const u = Ke(0, -1, 0);
  let c = as(Ei(l, u));
  isNaN(c.x) && (c = Ke(1, 0, 0));
  const d = as(Ei(c, l)), f = nt(o, rt(l, a)), g = e / 4, p = n / 4, y = [
    nt(nt(f, rt(c, -g)), rt(d, p)),
    nt(nt(f, rt(c, g)), rt(d, p)),
    nt(nt(f, rt(c, g)), rt(d, -p)),
    nt(nt(f, rt(c, -g)), rt(d, -p))
  ];
  for (let v = 0; v < 4; v++)
    r.push({ start: y[v], end: y[(v + 1) % 4], color: s });
  return r;
}
function wc(i, e, n, s = !0, r = !0, o = !1) {
  return {
    body: nT(i),
    frustum: s ? sT(i, e, n) : [],
    compositionBounds: r ? iT(e, n) : [],
    poiLine: rT(i),
    focalPlane: o ? oT(i, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function aT(i, e, n) {
  const s = e / n, r = lu(i.focalLength, i.filmSize);
  let o;
  if (i.type === "two-node")
    o = i.pointOfInterest;
  else {
    const c = i.orientation.x * Math.PI / 180, d = i.orientation.y * Math.PI / 180, f = Ke(
      Math.sin(d) * Math.cos(c),
      -Math.sin(c),
      Math.cos(d) * Math.cos(c)
    );
    o = nt(i.position, rt(f, 1e3));
  }
  const a = zn(i.position, o, Ke(0, -1, 0)), l = O2(r, s, i.nearClip, i.farClip), u = $h(l, a);
  return { view: a, projection: l, viewProjection: u };
}
function Sc(i, e, n, s) {
  const r = e / n;
  let o, a = 1e3;
  const l = e / 2, u = n / 2;
  switch (i) {
    case "front":
      o = zn(
        Ke(l, u, -2e3),
        Ke(l, u, 0),
        Ke(0, -1, 0)
      );
      break;
    case "back":
      o = zn(
        Ke(l, u, 2e3),
        Ke(l, u, 0),
        Ke(0, -1, 0)
      );
      break;
    case "left":
      o = zn(
        Ke(-2e3, u, 0),
        Ke(l, u, 0),
        Ke(0, -1, 0)
      );
      break;
    case "right":
      o = zn(
        Ke(l + 2e3, u, 0),
        Ke(l, u, 0),
        Ke(0, -1, 0)
      );
      break;
    case "top":
      o = zn(
        Ke(l, -2e3, 0),
        Ke(l, u, 0),
        Ke(0, 0, 1)
      );
      break;
    case "bottom":
      o = zn(
        Ke(l, u + 2e3, 0),
        Ke(l, u, 0),
        Ke(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (s) {
        const f = s.orbitPhi * Math.PI / 180, g = s.orbitTheta * Math.PI / 180, p = s.orbitDistance, y = Ke(
          s.orbitCenter.x + p * Math.sin(f) * Math.sin(g),
          s.orbitCenter.y + p * Math.cos(f),
          s.orbitCenter.z + p * Math.sin(f) * Math.cos(g)
        );
        o = zn(
          y,
          s.orbitCenter,
          Ke(0, -1, 0)
        ), a = 1e3 / s.orthoZoom;
      } else
        o = zn(
          Ke(l, u, -2e3),
          Ke(l, u, 0),
          Ke(0, -1, 0)
        );
      break;
    default:
      o = zn(
        Ke(l, u, -2e3),
        Ke(l, u, 0),
        Ke(0, -1, 0)
      );
  }
  const c = E2(
    -a * r,
    a * r,
    -a,
    a,
    1,
    1e4
  ), d = $h(c, o);
  return { view: o, projection: c, viewProjection: d };
}
function $h(i, e) {
  const n = i.elements, s = e.elements, r = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let u = 0; u < 4; u++)
        l += n[o + u * 4] * s[u + a * 4];
      r[o + a * 4] = l;
    }
  return { elements: r };
}
function Qa(i, e, n, s) {
  const r = P2(e, i), o = e.elements, a = i.x * o[3] + i.y * o[7] + i.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: r.z, visible: !1 };
  const l = (r.x / a * 0.5 + 0.5) * n, u = (-r.y / a * 0.5 + 0.5) * s;
  return {
    x: l,
    y: u,
    z: r.z / a,
    visible: !0
  };
}
function lT(i, e = 100) {
  return [
    { start: i, end: nt(i, Ke(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: i, end: nt(i, Ke(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: i, end: nt(i, Ke(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function uT(i, e, n = 100) {
  const s = [], r = "#333333", o = "#444444", a = i / 2, l = e / 2, u = Math.max(i, e);
  for (let c = -u; c <= u + i; c += n) {
    const d = Math.abs(c - a) < n / 2;
    s.push({
      start: Ke(c, -u, 0),
      end: Ke(c, u + e, 0),
      color: d ? o : r
    });
  }
  for (let c = -u; c <= u + e; c += n) {
    const d = Math.abs(c - l) < n / 2;
    s.push({
      start: Ke(-u, c, 0),
      end: Ke(u + i, c, 0),
      color: d ? o : r
    });
  }
  return s;
}
const cT = ["onClick"], dT = { class: "view-header" }, hT = ["value", "onChange"], fT = { class: "view-tools" }, pT = ["onClick"], mT = ["onMousedown", "onWheel"], gT = { class: "view-info" }, vT = { class: "view-name" }, yT = {
  key: 0,
  class: "view-coords"
}, bT = { class: "layout-controls" }, xT = ["onClick", "title"], _T = /* @__PURE__ */ pt({
  __name: "ViewportRenderer",
  setup(i) {
    const e = Ot(), n = Oe(() => e.activeCamera), s = Oe(() => e.width), r = Oe(() => e.height), o = Oe(() => e.viewportState), a = Oe(() => e.viewOptions), l = Oe(() => e.layers.filter((re) => re.type !== "camera").map((re) => ({
      id: re.id,
      name: re.name,
      position: {
        x: re.transform.position.value.x,
        y: re.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(re.id)
    }))), u = me([null, null, null, null]), c = me([null, null, null, null]), d = me(!1), f = me({ x: 0, y: 0 }), g = me(0), p = me(0), y = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], v = Oe(() => o.value.layout), m = Oe(() => o.value.activeViewIndex), b = Oe(() => o.value.customViews), S = Oe(() => {
      switch (o.value.layout) {
        case "1-view":
          return [o.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return o.value.views.slice(0, 2);
        case "4-view":
          return o.value.views.slice(0, 4);
        default:
          return [o.value.views[0]];
      }
    });
    function x(re, ie) {
      u.value[ie] = re, re && (c.value[ie] = re.getContext("2d"));
    }
    function _(re) {
      return re.startsWith("custom-");
    }
    function C(re) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[re];
    }
    function k(re) {
      e.updateViewportState({
        activeViewIndex: re
      });
    }
    function M(re, ie) {
      const be = [...o.value.views];
      be[re] = ie, e.updateViewportState({
        views: be
      });
    }
    function O(re) {
      const ie = ["active-camera", "top", "front", "right"];
      let be = [...o.value.views];
      for (; be.length < 4; )
        be.push(ie[be.length] || "front");
      e.updateViewportState({
        layout: re,
        views: be,
        activeViewIndex: Math.min(o.value.activeViewIndex, F(re) - 1)
      });
    }
    function F(re) {
      switch (re) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function $(re) {
      const ie = {
        orbitCenter: { x: s.value / 2, y: r.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...o.value.customViews,
          [re]: ie
        }
      });
    }
    function ne(re, ie) {
      d.value = !0, f.value = { x: re.clientX, y: re.clientY }, g.value = ie, p.value = re.button, document.addEventListener("mousemove", oe), document.addEventListener("mouseup", z);
    }
    function oe(re) {
      if (!d.value) return;
      const ie = re.clientX - f.value.x, be = re.clientY - f.value.y;
      f.value = { x: re.clientX, y: re.clientY };
      const J = S.value[g.value];
      if (_(J)) {
        const ee = b.value[J];
        if (p.value === 0) {
          const ve = ee.orbitTheta + ie * 0.5, G = Math.max(1, Math.min(179, ee.orbitPhi + be * 0.5));
          e.updateViewportState({
            customViews: {
              ...o.value.customViews,
              [J]: {
                ...ee,
                orbitTheta: ve,
                orbitPhi: G
              }
            }
          });
        } else (p.value === 1 || p.value === 2) && e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [J]: {
              ...ee,
              orthoOffset: {
                x: ee.orthoOffset.x + ie,
                y: ee.orthoOffset.y + be
              }
            }
          }
        });
      }
    }
    function z() {
      d.value = !1, document.removeEventListener("mousemove", oe), document.removeEventListener("mouseup", z);
    }
    function X(re, ie) {
      re.preventDefault();
      const be = S.value[ie];
      if (_(be)) {
        const J = b.value[be], ee = re.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [be]: {
              ...J,
              orbitDistance: J.orbitDistance * ee
            }
          }
        });
      }
    }
    function T() {
      S.value.forEach((re, ie) => {
        const be = u.value[ie], J = c.value[ie];
        if (!be || !J) return;
        const ee = be.getBoundingClientRect(), ve = window.devicePixelRatio || 1;
        be.width = ee.width * ve, be.height = ee.height * ve, J.scale(ve, ve), J.fillStyle = "#1a1a1a", J.fillRect(0, 0, ee.width, ee.height);
        let G;
        re === "active-camera" && n.value ? G = aT(n.value, s.value, r.value) : _(re) ? G = Sc(re, s.value, r.value, b.value[re]) : G = Sc(re, s.value, r.value);
        const N = [];
        if (a.value.showGrid && N.push(...uT(s.value, r.value)), a.value.show3DReferenceAxes && N.push(...lT(Ke(s.value / 2, r.value / 2, 0))), a.value.showCompositionBounds) {
          const te = wc(
            n.value ?? H(),
            s.value,
            r.value,
            !1,
            !0,
            !1
          );
          N.push(...te.compositionBounds);
        }
        if (re !== "active-camera" && n.value && (a.value.cameraWireframes === "always" || a.value.cameraWireframes === "selected")) {
          const fe = wc(
            n.value,
            s.value,
            r.value,
            !0,
            !1,
            a.value.showFocalPlane
          );
          N.push(...fe.body), N.push(...fe.frustum), N.push(...fe.focalPlane), fe.poiLine && N.push(fe.poiLine);
        }
        for (const te of N) {
          const fe = Qa(te.start, G.viewProjection, ee.width, ee.height), ae = Qa(te.end, G.viewProjection, ee.width, ee.height);
          !fe.visible && !ae.visible || (J.beginPath(), J.strokeStyle = te.color, J.lineWidth = 1, J.moveTo(fe.x, fe.y), J.lineTo(ae.x, ae.y), J.stroke());
        }
        if (a.value.showLayerHandles)
          for (const te of l.value) {
            const fe = Qa(te.position, G.viewProjection, ee.width, ee.height);
            fe.visible && (J.beginPath(), J.fillStyle = te.selected ? "#ffcc00" : "#888888", J.arc(fe.x, fe.y, te.selected ? 6 : 4, 0, Math.PI * 2), J.fill(), J.fillStyle = "#ffffff", J.font = "10px sans-serif", J.fillText(te.name, fe.x + 8, fe.y + 4));
          }
      });
    }
    function H() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: s.value / 2, y: r.value / 2, z: -1500 },
        pointOfInterest: { x: s.value / 2, y: r.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let ge;
    function K() {
      T(), ge = requestAnimationFrame(K);
    }
    return Rt(() => {
      K();
    }), pn(() => {
      cancelAnimationFrame(ge);
    }), ut([n, o, a, l], () => {
    }, { deep: !0 }), (re, ie) => (V(), B("div", {
      class: Ie(["viewport-renderer", [`layout-${v.value}`]])
    }, [
      (V(!0), B(Re, null, Ue(S.value, (be, J) => {
        var ee, ve;
        return V(), B("div", {
          key: J,
          class: Ie(["view-panel", { active: J === m.value }]),
          onClick: (G) => k(J)
        }, [
          h("div", dT, [
            h("select", {
              value: be,
              onChange: (G) => M(J, G.target.value),
              class: "view-select"
            }, [...ie[1] || (ie[1] = [
              xr('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, hT),
            h("div", fT, [
              _(be) ? (V(), B("button", {
                key: 0,
                onClick: Je((G) => $(be), ["stop"]),
                title: "Reset View"
              }, [...ie[2] || (ie[2] = [
                h("span", { class: "icon" }, "", -1)
              ])], 8, pT)) : Te("", !0)
            ])
          ]),
          h("canvas", {
            ref_for: !0,
            ref: (G) => x(G, J),
            class: "view-canvas",
            onMousedown: (G) => ne(G, J),
            onWheel: (G) => X(G, J),
            onContextmenu: ie[0] || (ie[0] = Je(() => {
            }, ["prevent"]))
          }, null, 40, mT),
          h("div", gT, [
            h("span", vT, pe(C(be)), 1),
            _(be) ? (V(), B("span", yT, " : " + pe(Math.round(((ee = b.value[be]) == null ? void 0 : ee.orbitTheta) ?? 0)) + " : " + pe(Math.round(((ve = b.value[be]) == null ? void 0 : ve.orbitPhi) ?? 0)) + " ", 1)) : Te("", !0)
          ])
        ], 10, cT);
      }), 128)),
      h("div", bT, [
        (V(), B(Re, null, Ue(y, (be) => h("button", {
          key: be.value,
          class: Ie({ active: v.value === be.value }),
          onClick: (J) => O(be.value),
          title: be.label
        }, pe(be.icon), 11, xT)), 64))
      ])
    ], 2));
  }
}), wT = /* @__PURE__ */ mt(_T, [["__scopeId", "data-v-cdf0e094"]]);
function le(i, e, n) {
  return (e = function(s) {
    var r = function(o, a) {
      if (typeof o != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var u = l.call(o, a);
        if (typeof u != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(o);
    }(s, "string");
    return typeof r == "symbol" ? r : r + "";
  }(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function Cc(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    e && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function ue(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Cc(Object(n), !0).forEach(function(s) {
      le(i, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Cc(Object(n)).forEach(function(s) {
      Object.defineProperty(i, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return i;
}
function _t(i, e) {
  if (i == null) return {};
  var n, s, r = function(a, l) {
    if (a == null) return {};
    var u = {};
    for (var c in a) if ({}.hasOwnProperty.call(a, c)) {
      if (l.indexOf(c) >= 0) continue;
      u[c] = a[c];
    }
    return u;
  }(i, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(i);
    for (s = 0; s < o.length; s++) n = o[s], e.indexOf(n) >= 0 || {}.propertyIsEnumerable.call(i, n) && (r[n] = i[n]);
  }
  return r;
}
function Hn(i, e) {
  return e || (e = i.slice(0)), Object.freeze(Object.defineProperties(i, { raw: { value: Object.freeze(e) } }));
}
class kc {
  constructor() {
    le(this, "browserShadowBlurConstant", 1), le(this, "DPI", 96), le(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), le(this, "perfLimitSizeTotal", 2097152), le(this, "maxCacheSideLimit", 4096), le(this, "minCacheSideLimit", 256), le(this, "disableStyleCopyPaste", !1), le(this, "enableGLFiltering", !0), le(this, "textureSize", 4096), le(this, "forceGLPutImageData", !1), le(this, "cachesBoundsOfCurve", !1), le(this, "fontPaths", {}), le(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const at = new class extends kc {
  constructor(i) {
    super(), this.configure(i);
  }
  configure() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, i);
  }
  addFonts() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = ue(ue({}, this.fontPaths), i);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((i) => {
      delete this.fontPaths[i];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(i) {
    const e = new kc(), n = (i == null ? void 0 : i.reduce((s, r) => (s[r] = e[r], s), {})) || e;
    this.configure(n);
  }
}(), Fs = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return console[i]("fabric", ...n);
};
class $n extends Error {
  constructor(e, n) {
    super("fabric: ".concat(e), n);
  }
}
class ST extends $n {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class CT {
}
class kT extends CT {
  testPrecision(e, n) {
    const s = "precision ".concat(n, ` float;
void main(){}`), r = e.createShader(e.FRAGMENT_SHADER);
    return !!r && (e.shaderSource(r, s), e.compileShader(r), !!e.getShaderParameter(r, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const n = e.getContext("webgl");
    n && (this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((s) => this.testPrecision(n, s)), n.getExtension("WEBGL_lose_context").loseContext(), Fs("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const TT = {};
let Tc;
const Nn = () => Tc || (Tc = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new kT(), dispose() {
}, copyPasteData: TT }), Ii = () => Nn().document, Ta = () => Nn().window, Bh = () => {
  var i;
  return Math.max((i = at.devicePixelRatio) !== null && i !== void 0 ? i : Ta().devicePixelRatio, 1);
}, cr = new class {
  constructor() {
    le(this, "boundsOfCurveCache", {}), this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  getFontCache(i) {
    let { fontFamily: e, fontStyle: n, fontWeight: s } = i;
    e = e.toLowerCase();
    const r = this.charWidthsCache;
    r.has(e) || r.set(e, /* @__PURE__ */ new Map());
    const o = r.get(e), a = "".concat(n.toLowerCase(), "_").concat((s + "").toLowerCase());
    return o.has(a) || o.set(a, /* @__PURE__ */ new Map()), o.get(a);
  }
  clearFontCache(i) {
    i ? this.charWidthsCache.delete((i || "").toLowerCase()) : this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  limitDimsByArea(i) {
    const { perfLimitSizeTotal: e } = at, n = Math.sqrt(e * i);
    return [Math.floor(n), Math.floor(e / n)];
  }
}(), El = "6.9.0";
function Po() {
}
const Lr = Math.PI / 2, qo = 2 * Math.PI, uu = Math.PI / 180, en = Object.freeze([1, 0, 0, 1, 0, 0]), cu = 16, _s = 0.4477152502, st = "center", ht = "left", rn = "top", Pl = "bottom", Et = "right", on = "none", du = /\r?\n/, Wh = "moving", Ma = "scaling", Uh = "rotating", hu = "rotate", Nh = "skewing", kr = "resizing", MT = "modifyPoly", OT = "modifyPath", Zo = "changed", Oa = "scale", ln = "scaleX", bn = "scaleY", Fi = "skewX", Li = "skewY", Ft = "fill", an = "stroke", Jo = "modified", oi = "json", el = "svg", We = new class {
  constructor() {
    this[oi] = /* @__PURE__ */ new Map(), this[el] = /* @__PURE__ */ new Map();
  }
  has(i) {
    return this[oi].has(i);
  }
  getClass(i) {
    const e = this[oi].get(i);
    if (!e) throw new $n("No class registered for ".concat(i));
    return e;
  }
  setClass(i, e) {
    e ? this[oi].set(e, i) : (this[oi].set(i.type, i), this[oi].set(i.type.toLowerCase(), i));
  }
  getSVGClass(i) {
    return this[el].get(i);
  }
  setSVGClass(i, e) {
    this[el].set(e ?? i.type.toLowerCase(), i);
  }
}(), Qo = new class extends Array {
  remove(i) {
    const e = this.indexOf(i);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const i = this.splice(0);
    return i.forEach((e) => e.abort()), i;
  }
  cancelByCanvas(i) {
    if (!i) return [];
    const e = this.filter((n) => {
      var s;
      return n.target === i || typeof n.target == "object" && ((s = n.target) === null || s === void 0 ? void 0 : s.canvas) === i;
    });
    return e.forEach((n) => n.abort()), e;
  }
  cancelByTarget(i) {
    if (!i) return [];
    const e = this.filter((n) => n.target === i);
    return e.forEach((n) => n.abort()), e;
  }
}();
class ET {
  constructor() {
    le(this, "__eventListeners", {});
  }
  on(e, n) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((s) => {
      let [r, o] = s;
      this.on(r, o);
    }), () => this.off(e);
    if (n) {
      const s = e;
      return this.__eventListeners[s] || (this.__eventListeners[s] = []), this.__eventListeners[s].push(n), () => this.off(s, n);
    }
    return () => !1;
  }
  once(e, n) {
    if (typeof e == "object") {
      const s = [];
      return Object.entries(e).forEach((r) => {
        let [o, a] = r;
        s.push(this.once(o, a));
      }), () => s.forEach((r) => r());
    }
    if (n) {
      const s = this.on(e, function() {
        for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++) o[a] = arguments[a];
        n.call(this, ...o), s();
      });
      return s;
    }
    return () => !1;
  }
  _removeEventListener(e, n) {
    if (this.__eventListeners[e]) if (n) {
      const s = this.__eventListeners[e], r = s.indexOf(n);
      r > -1 && s.splice(r, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, n) {
    if (this.__eventListeners) if (e === void 0) for (const s in this.__eventListeners) this._removeEventListener(s);
    else typeof e == "object" ? Object.entries(e).forEach((s) => {
      let [r, o] = s;
      this._removeEventListener(r, o);
    }) : this._removeEventListener(e, n);
  }
  fire(e, n) {
    var s;
    if (!this.__eventListeners) return;
    const r = (s = this.__eventListeners[e]) === null || s === void 0 ? void 0 : s.concat();
    if (r) for (let o = 0; o < r.length; o++) r[o].call(this, n || {});
  }
}
const ci = (i, e) => {
  const n = i.indexOf(e);
  return n !== -1 && i.splice(n, 1), i;
}, ps = (i) => {
  if (i === 0) return 1;
  switch (Math.abs(i) / Lr) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(i);
}, ms = (i) => {
  if (i === 0) return 0;
  const e = i / Lr, n = Math.sign(i);
  switch (e) {
    case 1:
      return n;
    case 2:
      return 0;
    case 3:
      return -n;
  }
  return Math.sin(i);
};
class we {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = n);
  }
  add(e) {
    return new we(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new we(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new we(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new we(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new we(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new we(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new we(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new we(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return n = Math.max(Math.min(1, n), 0), new we(this.x + (e.x - this.x) * n, this.y + (e.y - this.y) * n);
  }
  distanceFrom(e) {
    const n = this.x - e.x, s = this.y - e.y;
    return Math.sqrt(n * n + s * s);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new we(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new we(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, n) {
    return this.x = e, this.y = n, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const n = this.x, s = this.y;
    this.x = e.x, this.y = e.y, e.x = n, e.y = s;
  }
  clone() {
    return new we(this.x, this.y);
  }
  rotate(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fu;
    const s = ms(e), r = ps(e), o = this.subtract(n);
    return new we(o.x * r - o.y * s, o.x * s + o.y * r).add(n);
  }
  transform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new we(e[0] * this.x + e[2] * this.y + (n ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (n ? 0 : e[5]));
  }
}
const fu = new we(0, 0), Do = (i) => !!i && Array.isArray(i._objects);
function Hh(i) {
  class e extends i {
    constructor() {
      super(...arguments), le(this, "_objects", []);
    }
    _onObjectAdded(s) {
    }
    _onObjectRemoved(s) {
    }
    _onStackOrderChanged(s) {
    }
    add() {
      for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++) r[o] = arguments[o];
      const a = this._objects.push(...r);
      return r.forEach((l) => this._onObjectAdded(l)), a;
    }
    insertAt(s) {
      for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) o[a - 1] = arguments[a];
      return this._objects.splice(s, 0, ...o), o.forEach((l) => this._onObjectAdded(l)), this._objects.length;
    }
    remove() {
      const s = this._objects, r = [];
      for (var o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
      return a.forEach((u) => {
        const c = s.indexOf(u);
        c !== -1 && (s.splice(c, 1), r.push(u), this._onObjectRemoved(u));
      }), r;
    }
    forEachObject(s) {
      this.getObjects().forEach((r, o, a) => s(r, o, a));
    }
    getObjects() {
      for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++) r[o] = arguments[o];
      return r.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...r));
    }
    item(s) {
      return this._objects[s];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(s, r) {
      return !!this._objects.includes(s) || !!r && this._objects.some((o) => o instanceof e && o.contains(s, !0));
    }
    complexity() {
      return this._objects.reduce((s, r) => s += r.complexity ? r.complexity() : 0, 0);
    }
    sendObjectToBack(s) {
      return !(!s || s === this._objects[0]) && (ci(this._objects, s), this._objects.unshift(s), this._onStackOrderChanged(s), !0);
    }
    bringObjectToFront(s) {
      return !(!s || s === this._objects[this._objects.length - 1]) && (ci(this._objects, s), this._objects.push(s), this._onStackOrderChanged(s), !0);
    }
    sendObjectBackwards(s, r) {
      if (!s) return !1;
      const o = this._objects.indexOf(s);
      if (o !== 0) {
        const a = this.findNewLowerIndex(s, o, r);
        return ci(this._objects, s), this._objects.splice(a, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    bringObjectForward(s, r) {
      if (!s) return !1;
      const o = this._objects.indexOf(s);
      if (o !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(s, o, r);
        return ci(this._objects, s), this._objects.splice(a, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    moveObjectTo(s, r) {
      return s !== this._objects[r] && (ci(this._objects, s), this._objects.splice(r, 0, s), this._onStackOrderChanged(s), !0);
    }
    findNewLowerIndex(s, r, o) {
      let a;
      if (o) {
        a = r;
        for (let l = r - 1; l >= 0; --l) if (s.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = r - 1;
      return a;
    }
    findNewUpperIndex(s, r, o) {
      let a;
      if (o) {
        a = r;
        for (let l = r + 1; l < this._objects.length; ++l) if (s.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = r + 1;
      return a;
    }
    collectObjects(s) {
      let { left: r, top: o, width: a, height: l } = s, { includeIntersecting: u = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const c = [], d = new we(r, o), f = d.add(new we(a, l));
      for (let g = this._objects.length - 1; g >= 0; g--) {
        const p = this._objects[g];
        p.selectable && p.visible && (u && p.intersectsWithRect(d, f) || p.isContainedWithinRect(d, f) || u && p.containsPoint(d) || u && p.containsPoint(f)) && c.push(p);
      }
      return c;
    }
  }
  return e;
}
class Xh extends ET {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const n in e) this.set(n, e[n]);
  }
  _setObject(e) {
    for (const n in e) this._set(n, e[n]);
  }
  set(e, n) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, n), this;
  }
  _set(e, n) {
    this[e] = n;
  }
  toggle(e) {
    const n = this.get(e);
    return typeof n == "boolean" && this.set(e, !n), this;
  }
  get(e) {
    return this[e];
  }
}
function Ao(i) {
  return Ta().requestAnimationFrame(i);
}
function PT(i) {
  return Ta().cancelAnimationFrame(i);
}
let DT = 0;
const Ls = () => DT++, gs = () => {
  const i = Ii().createElement("canvas");
  if (!i || i.getContext === void 0) throw new $n("Failed to create `canvas` element");
  return i;
}, AT = () => Ii().createElement("img"), xn = (i) => {
  const e = gs();
  return e.width = i.width, e.height = i.height, e;
}, Yh = (i, e, n) => i.toDataURL("image/".concat(e), n), Gh = (i, e, n) => new Promise((s, r) => {
  i.toBlob(s, "image/".concat(e), n);
}), Pt = (i) => i * uu, vs = (i) => i / uu, IT = (i) => i.every((e, n) => e === en[n]), tn = (i, e, n) => new we(i).transform(e, n), On = (i) => {
  const e = 1 / (i[0] * i[3] - i[1] * i[2]), n = [e * i[3], -e * i[1], -e * i[2], e * i[0], 0, 0], { x: s, y: r } = new we(i[4], i[5]).transform(n, !0);
  return n[4] = -s, n[5] = -r, n;
}, Wt = (i, e, n) => [i[0] * e[0] + i[2] * e[1], i[1] * e[0] + i[3] * e[1], i[0] * e[2] + i[2] * e[3], i[1] * e[2] + i[3] * e[3], n ? 0 : i[0] * e[4] + i[2] * e[5] + i[4], n ? 0 : i[1] * e[4] + i[3] * e[5] + i[5]], pu = (i, e) => i.reduceRight((n, s) => s && n ? Wt(s, n, e) : s || n, void 0) || en.concat(), Kh = (i) => {
  let [e, n] = i;
  return Math.atan2(n, e);
}, ea = (i) => {
  const e = Kh(i), n = Math.pow(i[0], 2) + Math.pow(i[1], 2), s = Math.sqrt(n), r = (i[0] * i[3] - i[2] * i[1]) / s, o = Math.atan2(i[0] * i[2] + i[1] * i[3], n);
  return { angle: vs(e), scaleX: s, scaleY: r, skewX: vs(o), skewY: 0, translateX: i[4] || 0, translateY: i[5] || 0 };
}, zr = function(i) {
  return [1, 0, 0, 1, i, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function zi() {
  let { angle: i = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: n = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const s = Pt(i), r = ps(s), o = ms(s);
  return [r, o, -o, r, e ? e - (r * e - o * n) : 0, n ? n - (o * e + r * n) : 0];
}
const mu = function(i) {
  return [i, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i, 0, 0];
}, qh = (i) => Math.tan(Pt(i)), Zh = (i) => [1, 0, qh(i), 1, 0, 0], Jh = (i) => [1, qh(i), 0, 1, 0, 0], Ea = (i) => {
  let { scaleX: e = 1, scaleY: n = 1, flipX: s = !1, flipY: r = !1, skewX: o = 0, skewY: a = 0 } = i, l = mu(s ? -e : e, r ? -n : n);
  return o && (l = Wt(l, Zh(o), !0)), a && (l = Wt(l, Jh(a), !0)), l;
}, FT = (i) => {
  const { translateX: e = 0, translateY: n = 0, angle: s = 0 } = i;
  let r = zr(e, n);
  s && (r = Wt(r, zi({ angle: s })));
  const o = Ea(i);
  return IT(o) || (r = Wt(r, o)), r;
}, Io = function(i) {
  let { signal: e, crossOrigin: n = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(s, r) {
    if (e && e.aborted) return r(new ST("loadImage"));
    const o = AT();
    let a;
    e && (a = function(u) {
      o.src = "", r(u);
    }, e.addEventListener("abort", a, { once: !0 }));
    const l = function() {
      o.onload = o.onerror = null, a && (e == null || e.removeEventListener("abort", a)), s(o);
    };
    i ? (o.onload = l, o.onerror = function() {
      a && (e == null || e.removeEventListener("abort", a)), r(new $n("Error loading ".concat(o.src)));
    }, n && (o.crossOrigin = n), o.src = i) : l();
  });
}, Tr = function(i) {
  let { signal: e, reviver: n = Po } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((s, r) => {
    const o = [];
    e && e.addEventListener("abort", r, { once: !0 }), Promise.all(i.map((a) => We.getClass(a.type).fromObject(a, { signal: e }).then((l) => (n(a, l), o.push(l), l)))).then(s).catch((a) => {
      o.forEach((l) => {
        l.dispose && l.dispose();
      }), r(a);
    }).finally(() => {
      e && e.removeEventListener("abort", r);
    });
  });
}, Pa = function(i) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, s) => {
    const r = [];
    e && e.addEventListener("abort", s, { once: !0 });
    const o = Object.values(i).map((l) => l && l.type && We.has(l.type) ? Tr([l], { signal: e }).then((u) => {
      let [c] = u;
      return r.push(c), c;
    }) : l), a = Object.keys(i);
    Promise.all(o).then((l) => l.reduce((u, c, d) => (u[a[d]] = c, u), {})).then(n).catch((l) => {
      r.forEach((u) => {
        u.dispose && u.dispose();
      }), s(l);
    }).finally(() => {
      e && e.removeEventListener("abort", s);
    });
  });
}, Ri = function(i) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, n) => (n in i && (e[n] = i[n]), e), {});
}, gu = (i, e) => Object.keys(i).reduce((n, s) => (e(i[s], s, i) && (n[s] = i[s]), n), {}), xt = (i, e) => parseFloat(Number(i).toFixed(e)), Mr = (i) => "matrix(" + i.map((e) => xt(e, at.NUM_FRACTION_DIGITS)).join(" ") + ")", vn = (i) => !!i && i.toLive !== void 0, Mc = (i) => !!i && typeof i.toObject == "function", Oc = (i) => !!i && i.offsetX !== void 0 && "source" in i, Xs = (i) => !!i && "multiSelectionStacking" in i;
function Qh(i) {
  const e = i && Mn(i);
  let n = 0, s = 0;
  if (!i || !e) return { left: n, top: s };
  let r = i;
  const o = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; r && (r.parentNode || r.host) && (r = r.parentNode || r.host, r === e ? (n = a.scrollLeft || o.scrollLeft || 0, s = a.scrollTop || o.scrollTop || 0) : (n += r.scrollLeft || 0, s += r.scrollTop || 0), r.nodeType !== 1 || r.style.position !== "fixed"); ) ;
  return { left: n, top: s };
}
const Mn = (i) => i.ownerDocument || null, ef = (i) => {
  var e;
  return ((e = i.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, tf = function(i, e, n) {
  let { width: s, height: r } = n, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  i.width = s, i.height = r, o > 1 && (i.setAttribute("width", (s * o).toString()), i.setAttribute("height", (r * o).toString()), e.scale(o, o));
}, Dl = (i, e) => {
  let { width: n, height: s } = e;
  n && (i.style.width = typeof n == "number" ? "".concat(n, "px") : n), s && (i.style.height = typeof s == "number" ? "".concat(s, "px") : s);
};
function Ec(i) {
  return i.onselectstart !== void 0 && (i.onselectstart = () => !1), i.style.userSelect = on, i;
}
class nf {
  constructor(e) {
    le(this, "_originalCanvasStyle", void 0), le(this, "lower", void 0);
    const n = this.createLowerCanvas(e);
    this.lower = { el: n, ctx: n.getContext("2d") };
  }
  createLowerCanvas(e) {
    const n = (s = e) && s.getContext !== void 0 ? e : e && Ii().getElementById(e) || gs();
    var s;
    if (n.hasAttribute("data-fabric")) throw new $n("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = n.style.cssText, n.setAttribute("data-fabric", "main"), n.classList.add("lower-canvas"), n;
  }
  cleanupDOM(e) {
    let { width: n, height: s } = e;
    const { el: r } = this.lower;
    r.classList.remove("lower-canvas"), r.removeAttribute("data-fabric"), r.setAttribute("width", "".concat(n)), r.setAttribute("height", "".concat(s)), r.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, n) {
    const { el: s, ctx: r } = this.lower;
    tf(s, r, e, n);
  }
  setCSSDimensions(e) {
    Dl(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var n;
      const s = e && Mn(e), r = { left: 0, top: 0 };
      if (!s) return r;
      const o = ((n = ef(e)) === null || n === void 0 ? void 0 : n.getComputedStyle(e, null)) || {};
      r.left += parseInt(o.borderLeftWidth, 10) || 0, r.top += parseInt(o.borderTopWidth, 10) || 0, r.left += parseInt(o.paddingLeft, 10) || 0, r.top += parseInt(o.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const l = s.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const u = Qh(e);
      return { left: a.left + u.left - (l.clientLeft || 0) + r.left, top: a.top + u.top - (l.clientTop || 0) + r.top };
    }(this.lower.el);
  }
  dispose() {
    Nn().dispose(this.lower.el), delete this.lower;
  }
}
const LT = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...en] }, zT = ["objects"];
class Rr extends Hh(Xh) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return Rr.ownDefaults;
  }
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(n), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new nf(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r];
    const o = super.insertAt(e, ...s);
    return s.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), o;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (Fs("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? Bh() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, n) {
    return this.setDimensions({ width: e }, n);
  }
  setHeight(e, n) {
    return this.setDimensions({ height: e }, n);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: n = !1, backstoreOnly: s = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!n) {
      const r = ue({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(r, this.getRetinaScaling()), this.hasLostContext = !0, this.width = r.width, this.height = r.height;
    }
    s || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, n) {
    this._setDimensionsImpl(e, n), n && n.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, n) {
    const s = e, r = [...this.viewportTransform], o = tn(e, On(r));
    r[0] = n, r[3] = n;
    const a = tn(o, r);
    r[4] += s.x - a.x, r[5] += s.y - a.y, this.setViewportTransform(r);
  }
  setZoom(e) {
    this.zoomToPoint(new we(0, 0), e);
  }
  absolutePan(e) {
    const n = [...this.viewportTransform];
    return n[4] = -e.x, n[5] = -e.y, this.setViewportTransform(n);
  }
  relativePan(e) {
    return this.absolutePan(new we(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = Ao(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, n = this.height, s = On(this.viewportTransform), r = tn({ x: 0, y: 0 }, s), o = tn({ x: e, y: n }, s), a = r.min(o), l = r.max(o);
    return this.vptCoords = { tl: a, tr: new we(l.x, a.y), bl: new we(a.x, l.y), br: l };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (PT(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, n) {
    if (this.destroyed) return;
    const s = this.viewportTransform, r = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._renderObjects(e, n), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), r && (r._set("canvas", this), r.shouldCache(), r._transformDone = !0, r.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, r)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, n) {
    const s = this.viewportTransform;
    e.save(), e.transform(...s), e.globalCompositeOperation = "destination-in", n.transform(e), e.scale(1 / n.zoomX, 1 / n.zoomY), e.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), e.restore();
  }
  _renderObjects(e, n) {
    for (let s = 0, r = n.length; s < r; ++s) n[s] && n[s].render(e);
  }
  _renderBackgroundOrOverlay(e, n) {
    const s = this["".concat(n, "Color")], r = this["".concat(n, "Image")], o = this.viewportTransform, a = this["".concat(n, "Vpt")];
    if (!s && !r) return;
    const l = vn(s);
    if (s) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = l ? s.toLive(e) : s, a && e.transform(...o), l) {
        e.transform(1, 0, 0, 1, s.offsetX || 0, s.offsetY || 0);
        const u = s.gradientTransform || s.patternTransform;
        u && e.transform(...u);
      }
      e.fill(), e.restore();
    }
    if (r) {
      e.save();
      const { skipOffscreen: u } = this;
      this.skipOffscreen = a, a && e.transform(...o), r.render(e), this.skipOffscreen = u, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new we(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new we(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new we(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new we(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new we(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return tn(this.getCenterPoint(), On(this.viewportTransform));
  }
  _centerObject(e, n) {
    e.setXY(n, st, st), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, n) {
    const s = this.clipPath, r = s && !s.excludeFromExport ? this._toObject(s, e, n) : null;
    return ue(ue(ue({ version: El }, Ri(this, n)), {}, { objects: this._objects.filter((o) => !o.excludeFromExport).map((o) => this._toObject(o, e, n)) }, this.__serializeBgOverlay(e, n)), r ? { clipPath: r } : null);
  }
  _toObject(e, n, s) {
    let r;
    this.includeDefaultValues || (r = e.includeDefaultValues, e.includeDefaultValues = !1);
    const o = e[n](s);
    return this.includeDefaultValues || (e.includeDefaultValues = !!r), o;
  }
  __serializeBgOverlay(e, n) {
    const s = {}, r = this.backgroundImage, o = this.overlayImage, a = this.backgroundColor, l = this.overlayColor;
    return vn(a) ? a.excludeFromExport || (s.background = a.toObject(n)) : a && (s.background = a), vn(l) ? l.excludeFromExport || (s.overlay = l.toObject(n)) : l && (s.overlay = l), r && !r.excludeFromExport && (s.backgroundImage = this._toObject(r, e, n)), o && !o.excludeFromExport && (s.overlayImage = this._toObject(o, e, n)), s;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = n;
    const s = [];
    return this._setSVGPreamble(s, e), this._setSVGHeader(s, e), this.clipPath && s.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(s, "background"), this._setSVGBgOverlayImage(s, "backgroundImage", n), this._setSVGObjects(s, n), this.clipPath && s.push(`</g>
`), this._setSVGBgOverlayColor(s, "overlay"), this._setSVGBgOverlayImage(s, "overlayImage", n), s.push("</svg>"), s.join("");
  }
  _setSVGPreamble(e, n) {
    n.suppressPreamble || e.push('<?xml version="1.0" encoding="', n.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, n) {
    const s = n.width || "".concat(this.width), r = n.height || "".concat(this.height), o = at.NUM_FRACTION_DIGITS, a = n.viewBox;
    let l;
    if (a) l = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const u = this.viewportTransform;
      l = 'viewBox="'.concat(xt(-u[4] / u[0], o), " ").concat(xt(-u[5] / u[3], o), " ").concat(xt(this.width / u[0], o), " ").concat(xt(this.height / u[3], o), '" ');
    } else l = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', s, '" ', 'height="', r, '" ', l, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", El, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(n), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const n = this.clipPath;
    return n ? (n.clipPathId = "CLIPPATH_".concat(Ls()), '<clipPath id="'.concat(n.clipPathId, `" >
`).concat(n.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const n = this["".concat(e, "Color")];
      if (vn(n)) {
        const s = this["".concat(e, "Vpt")], r = this.viewportTransform, o = { isType: () => !1, width: this.width / (s ? r[0] : 1), height: this.height / (s ? r[3] : 1) };
        return n.toSVG(o, { additionalTransform: s ? Mr(r) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], n = {}, s = at.fontPaths;
    this._objects.forEach(function o(a) {
      e.push(a), Do(a) && a._objects.forEach(o);
    }), e.forEach((o) => {
      if (!(a = o) || typeof a._renderText != "function") return;
      var a;
      const { styles: l, fontFamily: u } = o;
      !n[u] && s[u] && (n[u] = !0, l && Object.values(l).forEach((c) => {
        Object.values(c).forEach((d) => {
          let { fontFamily: f = "" } = d;
          !n[f] && s[f] && (n[f] = !0);
        });
      }));
    });
    const r = Object.keys(n).map((o) => `		@font-face {
			font-family: '`.concat(o, `';
			src: url('`).concat(s[o], `');
		}
`)).join("");
    return r ? `	<style type="text/css"><![CDATA[
`.concat(r, `]]></style>
`) : "";
  }
  _setSVGObjects(e, n) {
    this.forEachObject((s) => {
      s.excludeFromExport || this._setSVGObject(e, s, n);
    });
  }
  _setSVGObject(e, n, s) {
    e.push(n.toSVG(s));
  }
  _setSVGBgOverlayImage(e, n, s) {
    const r = this[n];
    r && !r.excludeFromExport && r.toSVG && e.push(r.toSVG(s));
  }
  _setSVGBgOverlayColor(e, n) {
    const s = this["".concat(n, "Color")];
    if (s) if (vn(s)) {
      const r = s.repeat || "", o = this.width, a = this.height, l = this["".concat(n, "Vpt")] ? Mr(On(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(l, " translate(").concat(o / 2, ",").concat(a / 2, ')" x="').concat(s.offsetX - o / 2, '" y="').concat(s.offsetY - a / 2, '" width="').concat(r !== "repeat-y" && r !== "no-repeat" || !Oc(s) ? o : s.source.width, '" height="').concat(r !== "repeat-x" && r !== "no-repeat" || !Oc(s) ? a : s.source.height, '" fill="url(#SVGID_').concat(s.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', s, '"', `></rect>
`);
  }
  loadFromJSON(e, n) {
    let { signal: s } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new $n("`json` is undefined"));
    const r = typeof e == "string" ? JSON.parse(e) : e, { objects: o = [] } = r, a = _t(r, zT), { backgroundImage: l, background: u, overlayImage: c, overlay: d, clipPath: f } = a, g = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([Tr(o, { reviver: n, signal: s }), Pa({ backgroundImage: l, backgroundColor: u, overlayImage: c, overlayColor: d, clipPath: f }, { signal: s })]).then((p) => {
      let [y, v] = p;
      return this.clear(), this.add(...y), this.set(a), this.set(v), this.renderOnAddRemove = g, this;
    });
  }
  clone(e) {
    const n = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(n);
  }
  cloneWithoutData() {
    const e = xn(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: s = 1, multiplier: r = 1, enableRetinaScaling: o = !1 } = e, a = r * (o ? this.getRetinaScaling() : 1);
    return Yh(this.toCanvasElement(a, e), n, s);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: s = 1, multiplier: r = 1, enableRetinaScaling: o = !1 } = e, a = r * (o ? this.getRetinaScaling() : 1);
    return Gh(this.toCanvasElement(a, e), n, s);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: n, height: s, left: r, top: o, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const l = (n || this.width) * e, u = (s || this.height) * e, c = this.getZoom(), d = this.width, f = this.height, g = this.skipControlsDrawing, p = c * e, y = this.viewportTransform, v = [p, 0, 0, p, (y[4] - (r || 0)) * e, (y[5] - (o || 0)) * e], m = this.enableRetinaScaling, b = xn({ width: l, height: u }), S = a ? this._objects.filter((x) => a(x)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = v, this.width = l, this.height = u, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(b.getContext("2d"), S), this.viewportTransform = y, this.width = d, this.height = f, this.calcViewportBoundaries(), this.enableRetinaScaling = m, this.skipControlsDrawing = g, b;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), Qo.cancelByCanvas(this), this.disposed = !0, new Promise((e, n) => {
      const s = () => {
        this.destroy(), e(!0);
      };
      s.kill = n, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = s : s();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
le(Rr, "ownDefaults", LT);
const RT = ["touchstart", "touchmove", "touchend"], VT = (i) => {
  const e = Qh(i.target), n = function(s) {
    const r = s.changedTouches;
    return r && r[0] ? r[0] : s;
  }(i);
  return new we(n.clientX + e.left, n.clientY + e.top);
}, Al = (i) => RT.includes(i.type) || i.pointerType === "touch", Pc = (i) => {
  i.preventDefault(), i.stopPropagation();
}, ls = (i) => {
  let e = 0, n = 0, s = 0, r = 0;
  for (let o = 0, a = i.length; o < a; o++) {
    const { x: l, y: u } = i[o];
    (l > s || !o) && (s = l), (l < e || !o) && (e = l), (u > r || !o) && (r = u), (u < n || !o) && (n = u);
  }
  return { left: e, top: n, width: s - e, height: r - n };
}, jT = ["translateX", "translateY", "scaleX", "scaleY"], $T = (i, e) => ta(i, Wt(e, i.calcOwnMatrix())), ta = (i, e) => {
  const n = ea(e), { translateX: s, translateY: r, scaleX: o, scaleY: a } = n, l = _t(n, jT), u = new we(s, r);
  i.flipX = !1, i.flipY = !1, Object.assign(i, l), i.set({ scaleX: o, scaleY: a }), i.setPositionByOrigin(u, st, st);
}, BT = (i) => {
  i.scaleX = 1, i.scaleY = 1, i.skewX = 0, i.skewY = 0, i.flipX = !1, i.flipY = !1, i.rotate(0);
}, sf = (i) => ({ scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, angle: i.angle, left: i.left, flipX: i.flipX, flipY: i.flipY, top: i.top }), vu = (i, e, n) => {
  const s = i / 2, r = e / 2, o = [new we(-s, -r), new we(s, -r), new we(-s, r), new we(s, r)].map((l) => l.transform(n)), a = ls(o);
  return new we(a.width, a.height);
}, Da = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : en;
  return Wt(On(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : en), i);
}, _i = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : en, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : en;
  return i.transform(Da(e, n));
}, WT = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : en, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : en;
  return i.transform(Da(e, n), !0);
}, UT = (i, e, n) => {
  const s = Da(e, n);
  return ta(i, Wt(s, i.calcOwnMatrix())), s;
}, rf = (i, e) => {
  var n;
  const { transform: { target: s } } = e;
  (n = s.canvas) === null || n === void 0 || n.fire("object:".concat(i), ue(ue({}, e), {}, { target: s })), s.fire(i, e);
}, NT = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, It = (i) => typeof i == "string" ? NT[i] : i - 0.5, na = "not-allowed";
function of(i) {
  return It(i.originX) === It(st) && It(i.originY) === It(st);
}
function Dc(i) {
  return 0.5 - It(i);
}
const Dn = (i, e) => i[e], af = (i, e, n, s) => ({ e: i, transform: e, pointer: new we(n, s) });
function lf(i, e) {
  const n = i.getTotalAngle() + vs(Math.atan2(e.y, e.x)) + 360;
  return Math.round(n % 360 / 45);
}
function yu(i, e, n, s, r) {
  var o;
  let { target: a, corner: l } = i;
  const u = a.controls[l], c = ((o = a.canvas) === null || o === void 0 ? void 0 : o.getZoom()) || 1, d = a.padding / c, f = function(g, p, y, v) {
    const m = g.getRelativeCenterPoint(), b = y !== void 0 && v !== void 0 ? g.translateToGivenOrigin(m, st, st, y, v) : new we(g.left, g.top);
    return (g.angle ? p.rotate(-Pt(g.angle), m) : p).subtract(b);
  }(a, new we(s, r), e, n);
  return f.x >= d && (f.x -= d), f.x <= -d && (f.x += d), f.y >= d && (f.y -= d), f.y <= d && (f.y += d), f.x -= u.offsetX, f.y -= u.offsetY, f;
}
const HT = (i, e, n, s) => {
  const { target: r, offsetX: o, offsetY: a } = e, l = n - o, u = s - a, c = !Dn(r, "lockMovementX") && r.left !== l, d = !Dn(r, "lockMovementY") && r.top !== u;
  return c && r.set(ht, l), d && r.set(rn, u), (c || d) && rf(Wh, af(i, e, n, s)), c || d;
}, sa = (i) => i.replace(/\s+/g, " "), Ac = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, tl = (i, e, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + 6 * (e - i) * n : n < 0.5 ? e : n < 2 / 3 ? i + (e - i) * (2 / 3 - n) * 6 : i), Ic = (i, e, n, s) => {
  i /= 255, e /= 255, n /= 255;
  const r = Math.max(i, e, n), o = Math.min(i, e, n);
  let a, l;
  const u = (r + o) / 2;
  if (r === o) a = l = 0;
  else {
    const c = r - o;
    switch (l = u > 0.5 ? c / (2 - r - o) : c / (r + o), r) {
      case i:
        a = (e - n) / c + (e < n ? 6 : 0);
        break;
      case e:
        a = (n - i) / c + 2;
        break;
      case n:
        a = (i - e) / c + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * l), Math.round(100 * u), s];
}, Fc = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(i) / (i.endsWith("%") ? 100 : 1);
}, qr = (i) => Math.min(Math.round(i), 255).toString(16).toUpperCase().padStart(2, "0"), Lc = (i) => {
  let [e, n, s, r = 1] = i;
  const o = Math.round(0.3 * e + 0.59 * n + 0.11 * s);
  return [o, o, o, r];
};
class ft {
  constructor(e) {
    if (le(this, "isUnrecognised", !1), e) if (e instanceof ft) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [n, s, r, o = 1] = e;
      this.setSource([n, s, r, o]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in Ac && (e = Ac[e]), e === "transparent" ? [255, 255, 255, 0] : ft.sourceFromHex(e) || ft.sourceFromRgb(e) || ft.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, n, s] = this.getSource();
    return "rgb(".concat(e, ",").concat(n, ",").concat(s, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, n, s] = Ic(...this.getSource());
    return "hsl(".concat(e, ",").concat(n, "%,").concat(s, "%)");
  }
  toHsla() {
    const [e, n, s, r] = Ic(...this.getSource());
    return "hsla(".concat(e, ",").concat(n, "%,").concat(s, "%,").concat(r, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, n, s, r] = this.getSource();
    return "".concat(qr(e)).concat(qr(n)).concat(qr(s)).concat(qr(Math.round(255 * r)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(Lc(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [n, , , s] = Lc(this.getSource()), r = n < (e || 127) ? 0 : 255;
    return this.setSource([r, r, r, s]), this;
  }
  overlayWith(e) {
    e instanceof ft || (e = new ft(e));
    const n = this.getSource(), s = e.getSource(), [r, o, a] = n.map((l, u) => Math.round(0.5 * l + 0.5 * s[u]));
    return this.setSource([r, o, a, n[3]]), this;
  }
  static fromRgb(e) {
    return ft.fromRgba(e);
  }
  static fromRgba(e) {
    return new ft(ft.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const n = sa(e).match(/^rgba?\(\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d{0,3}(?:\.\d+)?%?)\s?)?\)$/i);
    if (n) {
      const [s, r, o] = n.slice(1, 4).map((a) => {
        const l = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * l) : l;
      });
      return [s, r, o, Fc(n[4])];
    }
  }
  static fromHsl(e) {
    return ft.fromHsla(e);
  }
  static fromHsla(e) {
    return new ft(ft.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const n = sa(e).match(/^hsla?\(\s?([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d*(?:\.\d+)?%?)\s?)?\)$/i);
    if (!n) return;
    const s = (ft.parseAngletoDegrees(n[1]) % 360 + 360) % 360 / 360, r = parseFloat(n[2]) / 100, o = parseFloat(n[3]) / 100;
    let a, l, u;
    if (r === 0) a = l = u = o;
    else {
      const c = o <= 0.5 ? o * (r + 1) : o + r - o * r, d = 2 * o - c;
      a = tl(d, c, s + 1 / 3), l = tl(d, c, s), u = tl(d, c, s - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * l), Math.round(255 * u), Fc(n[4])];
  }
  static fromHex(e) {
    return new ft(ft.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const n = e.slice(e.indexOf("#") + 1);
      let s;
      s = n.length <= 4 ? n.split("").map((u) => u + u) : n.match(/.{2}/g);
      const [r, o, a, l = 255] = s.map((u) => parseInt(u, 16));
      return [r, o, a, l / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const n = e.toLowerCase(), s = parseFloat(n);
    return n.includes("rad") ? vs(s) : n.includes("turn") ? 360 * s : s;
  }
}
const wi = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : cu;
  const n = /\D{0,2}$/.exec(i), s = parseFloat(i), r = at.DPI;
  switch (n == null ? void 0 : n[0]) {
    case "mm":
      return s * r / 25.4;
    case "cm":
      return s * r / 2.54;
    case "in":
      return s * r;
    case "pt":
      return s * r / 72;
    case "pc":
      return s * r / 72 * 12;
    case "em":
      return s * e;
    default:
      return s;
  }
}, XT = (i) => {
  const [e, n] = i.trim().split(" "), [s, r] = (o = e) && o !== on ? [o.slice(1, 4), o.slice(5, 8)] : o === on ? [o, o] : ["Mid", "Mid"];
  var o;
  return { meetOrSlice: n || "meet", alignX: s, alignY: r };
}, Or = function(i, e) {
  let n, s, r = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) n = "url(#SVGID_".concat(e.id, ")");
  else {
    const o = new ft(e), a = o.getAlpha();
    n = o.toRgb(), a !== 1 && (s = a.toString());
  }
  else n = "none";
  return r ? "".concat(i, ": ").concat(n, "; ").concat(s ? "".concat(i, "-opacity: ").concat(s, "; ") : "") : "".concat(i, '="').concat(n, '" ').concat(s ? "".concat(i, '-opacity="').concat(s, '" ') : "");
};
class uf {
  getSvgStyles(e) {
    const n = this.fillRule ? this.fillRule : "nonzero", s = this.strokeWidth ? this.strokeWidth : "0", r = this.strokeDashArray ? this.strokeDashArray.join(" ") : on, o = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", l = this.strokeLineJoin ? this.strokeLineJoin : "miter", u = this.strokeMiterLimit ? this.strokeMiterLimit : "4", c = this.opacity !== void 0 ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", f = e ? "" : this.getSvgFilter(), g = Or(Ft, this.fill);
    return [Or(an, this.stroke), "stroke-width: ", s, "; ", "stroke-dasharray: ", r, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", o, "; ", "stroke-linejoin: ", l, "; ", "stroke-miterlimit: ", u, "; ", g, "fill-rule: ", n, "; ", "opacity: ", c, ";", f, d].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), r = 'transform="'.concat(Mr(s));
    return "".concat(r).concat(n, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: n, additionalTransform: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = [this.getSvgTransform(!0, s), this.getSvgCommons()].join(""), o = e.indexOf("COMMON_PARTS");
    return e[o] = r, n ? n(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: n, reviver: s, withShadow: r, additionalTransform: o } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = n ? "" : 'style="'.concat(this.getSvgStyles(), '" '), l = r ? 'style="'.concat(this.getSvgFilter(), '" ') : "", u = this.clipPath, c = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, f = this.stroke, g = this.fill, p = this.shadow, y = [], v = e.indexOf("COMMON_PARTS");
    let m;
    u && (u.clipPathId = "CLIPPATH_".concat(Ls()), m = '<clipPath id="'.concat(u.clipPathId, `" >
`).concat(u.toClipPathSVG(s), `</clipPath>
`)), d && y.push("<g ", l, this.getSvgCommons(), ` >
`), y.push("<g ", this.getSvgTransform(!1), d ? "" : l + this.getSvgCommons(), ` >
`);
    const b = [a, c, n ? "" : this.addPaintOrder(), " ", o ? 'transform="'.concat(o, '" ') : ""].join("");
    return e[v] = b, vn(g) && y.push(g.toSVG(this)), vn(f) && y.push(f.toSVG(this)), p && y.push(p.toSVG(this)), u && y.push(m), y.push(e.join("")), y.push(`</g>
`), d && y.push(`</g>
`), s ? s(y.join("")) : y.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Ft ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function Aa(i) {
  return new RegExp("^(" + i.join("|") + ")\\b", "i");
}
const ti = "textDecorationThickness", cf = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], df = ["underline", "overline", "linethrough"], hf = [...cf, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], ff = [...hf, ...df, "textBackgroundColor", "direction", ti], YT = [...cf, ...df, an, "strokeWidth", Ft, "deltaY", "textBackgroundColor", ti], GT = { _reNewline: du, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: ht, fontStyle: "normal", lineHeight: 1.16, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: ht, pathAlign: "baseline", charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.28167, overline: -0.81333 }, _fontSizeMult: 1.13, [ti]: 66.667 }, jn = "justify", ia = "justify-left", dr = "justify-right", hr = "justify-center";
var zc, Rc, Vc;
const En = String.raw(zc || (zc = Hn(["[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"], ["[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"]))), nl = String.raw(Rc || (Rc = Hn(["(?:s*,?s+|s*,s*)"], ["(?:\\s*,?\\s+|\\s*,\\s*)"]))), KT = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + En + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + En + "))?\\s+(.*)"), qT = { cx: ht, x: ht, r: "radius", cy: rn, y: rn, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing", "text-decoration-thickness": ti }, sl = "font-size", il = "clip-path";
Aa(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
Aa(["symbol", "image", "marker", "pattern", "view", "svg"]);
const jc = Aa(["symbol", "g", "a", "svg", "clipPath", "defs"]);
new RegExp(String.raw(Vc || (Vc = Hn(["^s*(", ")", "(", ")", "(", ")", "(", ")s*$"], ["^\\s*(", ")", "(", ")", "(", ")", "(", ")\\s*$"])), En, nl, En, nl, En, nl, En));
const ZT = new we(1, 0), pf = new we(), mf = (i, e) => i.rotate(e), Il = (i, e) => new we(e).subtract(i), Fl = (i) => i.distanceFrom(pf), Ll = (i, e) => Math.atan2(fr(i, e), QT(i, e)), JT = (i) => Ll(ZT, i), bu = (i) => i.eq(pf) ? i : i.scalarDivide(Fl(i)), gf = function(i) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return bu(new we(-i.y, i.x).scalarMultiply(e ? 1 : -1));
}, fr = (i, e) => i.x * e.y - i.y * e.x, QT = (i, e) => i.x * e.x + i.y * e.y, $c = (i, e, n) => {
  if (i.eq(e) || i.eq(n)) return !0;
  const s = fr(e, n), r = fr(e, i), o = fr(n, i);
  return s >= 0 ? r >= 0 && o <= 0 : !(r <= 0 && o >= 0);
}, Bc = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", Wc = new RegExp("(?:\\s|^)" + Bc + Bc + "(" + En + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class us {
  constructor(e) {
    const n = typeof e == "string" ? us.parseShadow(e) : e;
    Object.assign(this, us.ownDefaults, n), this.id = Ls();
  }
  static parseShadow(e) {
    const n = e.trim(), [, s = 0, r = 0, o = 0] = (Wc.exec(n) || []).map((a) => parseFloat(a) || 0);
    return { color: (n.replace(Wc, "") || "rgb(0,0,0)").trim(), offsetX: s, offsetY: r, blur: o };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const n = mf(new we(this.offsetX, this.offsetY), Pt(-e.angle)), s = new ft(this.color);
    let r = 40, o = 40;
    return e.width && e.height && (r = 100 * xt((Math.abs(n.x) + this.blur) / e.width, at.NUM_FRACTION_DIGITS) + 20, o = 100 * xt((Math.abs(n.y) + this.blur) / e.height, at.NUM_FRACTION_DIGITS) + 20), e.flipX && (n.x *= -1), e.flipY && (n.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(o, '%" height="').concat(100 + 2 * o, '%" x="-').concat(r, '%" width="').concat(100 + 2 * r, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(xt(this.blur ? this.blur / 2 : 0, at.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(xt(n.x, at.NUM_FRACTION_DIGITS), '" dy="').concat(xt(n.y, at.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(s.toRgb(), '" flood-opacity="').concat(s.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, n = us.ownDefaults;
    return this.includeDefaultValues ? e : gu(e, (s, r) => s !== n[r]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
le(us, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), le(us, "type", "shadow"), We.setClass(us, "shadow");
const Pi = (i, e, n) => Math.max(i, Math.min(e, n)), eM = [rn, ht, ln, bn, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", Fi, Li], bs = [Ft, an, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], tM = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: ht, originY: rn, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Ft, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, nM = (i, e, n, s) => -n * Math.cos(i / s * Lr) + n + e, sM = () => !1;
class xu {
  constructor(e) {
    let { startValue: n, byValue: s, duration: r = 500, delay: o = 0, easing: a = nM, onStart: l = Po, onChange: u = Po, onComplete: c = Po, abort: d = sM, target: f } = e;
    le(this, "_state", "pending"), le(this, "durationProgress", 0), le(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = r, this.delay = o, this.easing = a, this._onStart = l, this._onChange = u, this._onComplete = c, this._abort = d, this.target = f, this.startValue = n, this.byValue = s, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (n) => {
      this._state === "pending" && (this.startTime = n || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => Ao(e), this.delay) : Ao(e);
  }
  tick(e) {
    const n = (e || +/* @__PURE__ */ new Date()) - this.startTime, s = Math.min(n, this.duration);
    this.durationProgress = s / this.duration;
    const { value: r, valueProgress: o } = this.calculate(s);
    this.value = Object.freeze(r), this.valueProgress = o, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : n >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), Ao(this.tick)));
  }
  register() {
    Qo.push(this);
  }
  unregister() {
    Qo.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const iM = ["startValue", "endValue"];
class rM extends xu {
  constructor(e) {
    let { startValue: n = 0, endValue: s = 100 } = e;
    super(ue(ue({}, _t(e, iM)), {}, { startValue: n, byValue: s - n }));
  }
  calculate(e) {
    const n = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: n, valueProgress: Math.abs((n - this.startValue) / this.byValue) };
  }
}
const oM = ["startValue", "endValue"];
class aM extends xu {
  constructor(e) {
    let { startValue: n = [0], endValue: s = [100] } = e;
    super(ue(ue({}, _t(e, oM)), {}, { startValue: n, byValue: s.map((r, o) => r - n[o]) }));
  }
  calculate(e) {
    const n = this.startValue.map((s, r) => this.easing(e, s, this.byValue[r], this.duration, r));
    return { value: n, valueProgress: Math.abs((n[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const lM = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], uM = (i, e, n, s) => e + n * (1 - Math.cos(i / s * Lr)), rl = (i) => i && ((e, n, s) => i(new ft(e).toRgba(), n, s));
class cM extends xu {
  constructor(e) {
    let { startValue: n, endValue: s, easing: r = uM, onChange: o, onComplete: a, abort: l } = e, u = _t(e, lM);
    const c = new ft(n).getSource(), d = new ft(s).getSource();
    super(ue(ue({}, u), {}, { startValue: c, byValue: d.map((f, g) => f - c[g]), easing: r, onChange: rl(o), onComplete: rl(a), abort: rl(l) }));
  }
  calculate(e) {
    const [n, s, r, o] = this.startValue.map((l, u) => this.easing(e, l, this.byValue[u], this.duration, u)), a = [...[n, s, r].map(Math.round), Pi(0, o, 1)];
    return { value: a, valueProgress: a.map((l, u) => this.byValue[u] !== 0 ? Math.abs((l - this.startValue[u]) / this.byValue[u]) : 0).find((l) => l !== 0) || 0 };
  }
}
function vf(i) {
  const e = ((n) => Array.isArray(n.startValue) || Array.isArray(n.endValue))(i) ? new aM(i) : new rM(i);
  return e.start(), e;
}
function dM(i) {
  const e = new cM(i);
  return e.start(), e;
}
class Ct {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((n) => n.eq(e));
  }
  append() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    return this.points = this.points.concat(n.filter((r) => !this.includes(r))), this;
  }
  static isPointContained(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (n.eq(s)) return e.eq(n);
    if (n.x === s.x) return e.x === n.x && (r || e.y >= Math.min(n.y, s.y) && e.y <= Math.max(n.y, s.y));
    if (n.y === s.y) return e.y === n.y && (r || e.x >= Math.min(n.x, s.x) && e.x <= Math.max(n.x, s.x));
    {
      const o = Il(n, s), a = Il(n, e).divide(o);
      return r ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, n) {
    const s = new we(e).setX(Math.min(e.x - 1, ...n.map((o) => o.x)));
    let r = 0;
    for (let o = 0; o < n.length; o++) {
      const a = this.intersectSegmentSegment(n[o], n[(o + 1) % n.length], e, s);
      if (a.includes(e)) return !0;
      r += +(a.status === "Intersection");
    }
    return r % 2 == 1;
  }
  static intersectLineLine(e, n, s, r) {
    let o = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const l = n.x - e.x, u = n.y - e.y, c = r.x - s.x, d = r.y - s.y, f = e.x - s.x, g = e.y - s.y, p = c * g - d * f, y = l * g - u * f, v = d * l - c * u;
    if (v !== 0) {
      const m = p / v, b = y / v;
      return (o || 0 <= m && m <= 1) && (a || 0 <= b && b <= 1) ? new Ct("Intersection").append(new we(e.x + m * l, e.y + m * u)) : new Ct();
    }
    if (p === 0 || y === 0) {
      const m = o || a || Ct.isPointContained(e, s, r) || Ct.isPointContained(n, s, r) || Ct.isPointContained(s, e, n) || Ct.isPointContained(r, e, n);
      return new Ct(m ? "Coincident" : void 0);
    }
    return new Ct("Parallel");
  }
  static intersectSegmentLine(e, n, s, r) {
    return Ct.intersectLineLine(e, n, s, r, !1, !0);
  }
  static intersectSegmentSegment(e, n, s, r) {
    return Ct.intersectLineLine(e, n, s, r, !1, !1);
  }
  static intersectLinePolygon(e, n, s) {
    let r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const o = new Ct(), a = s.length;
    for (let l, u, c, d = 0; d < a; d++) {
      if (l = s[d], u = s[(d + 1) % a], c = Ct.intersectLineLine(e, n, l, u, r, !1), c.status === "Coincident") return c;
      o.append(...c.points);
    }
    return o.points.length > 0 && (o.status = "Intersection"), o;
  }
  static intersectSegmentPolygon(e, n, s) {
    return Ct.intersectLinePolygon(e, n, s, !1);
  }
  static intersectPolygonPolygon(e, n) {
    const s = new Ct(), r = e.length, o = [];
    for (let a = 0; a < r; a++) {
      const l = e[a], u = e[(a + 1) % r], c = Ct.intersectSegmentPolygon(l, u, n);
      c.status === "Coincident" ? (o.push(c), s.append(l, u)) : s.append(...c.points);
    }
    return o.length > 0 && o.length === e.length ? new Ct("Coincident") : (s.points.length > 0 && (s.status = "Intersection"), s);
  }
  static intersectPolygonRectangle(e, n, s) {
    const r = n.min(s), o = n.max(s), a = new we(o.x, r.y), l = new we(r.x, o.y);
    return Ct.intersectPolygonPolygon(e, [r, a, o, l]);
  }
}
class hM extends Xh {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? tn(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, n, s) {
    this.group && (e = tn(e, On(this.group.calcTransformMatrix()))), this.setRelativeXY(e, n, s);
  }
  getRelativeXY() {
    return new we(this.left, this.top);
  }
  setRelativeXY(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, n, s);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: n, br: s, bl: r } = this.aCoords || (this.aCoords = this.calcACoords()), o = [e, n, s, r];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return o.map((l) => tn(l, a));
    }
    return o;
  }
  intersectsWithRect(e, n) {
    return Ct.intersectPolygonRectangle(this.getCoords(), e, n).status === "Intersection";
  }
  intersectsWithObject(e) {
    const n = Ct.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return n.status === "Intersection" || n.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((n) => e.containsPoint(n));
  }
  isContainedWithinRect(e, n) {
    const { left: s, top: r, width: o, height: a } = this.getBoundingRect();
    return s >= e.x && s + o <= n.x && r >= e.y && r + a <= n.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return Ct.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return !!this.getCoords().some((s) => s.x <= n.x && s.x >= e.x && s.y <= n.y && s.y >= e.y) || !!this.intersectsWithRect(e, n) || this.containsPoint(e.midPointFrom(n));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, n) ? !0 : this.getCoords().every((s) => (s.x >= n.x || s.x <= e.x) && (s.y >= n.y || s.y <= e.y)) && this.containsPoint(e.midPointFrom(n));
  }
  getBoundingRect() {
    return ls(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(ln, e), this._set(bn, e), this.setCoords();
  }
  scaleToWidth(e) {
    const n = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / n);
  }
  scaleToHeight(e) {
    const n = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / n);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? vs(Kh(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || en.concat();
  }
  calcACoords() {
    const e = zi({ angle: this.angle }), { x: n, y: s } = this.getRelativeCenterPoint(), r = zr(n, s), o = Wt(r, e), a = this._getTransformedDimensions(), l = a.x / 2, u = a.y / 2;
    return { tl: tn({ x: -l, y: -u }, o), tr: tn({ x: l, y: -u }, o), bl: tn({ x: -l, y: u }, o), br: tn({ x: l, y: u }, o) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = [];
    return !e && this.group && (n = this.group.transformMatrixKey(e)), n.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, It(this.originX), It(this.originY)), n;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = this.calcOwnMatrix();
    if (e || !this.group) return n;
    const s = this.transformMatrixKey(e), r = this.matrixCache;
    return r && r.key.every((o, a) => o === s[a]) ? r.value : (this.group && (n = Wt(this.group.calcTransformMatrix(!1), n)), this.matrixCache = { key: s, value: n }, n);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), n = this.ownMatrixCache;
    if (n && n.key === e) return n.value;
    const s = this.getRelativeCenterPoint(), r = { angle: this.angle, translateX: s.x, translateY: s.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, o = FT(r);
    return this.ownMatrixCache = { key: e, value: o }, o;
  }
  _getNonTransformedDimensions() {
    return new we(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ue({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), s = n.strokeWidth;
    let r = s, o = 0;
    this.strokeUniform && (r = 0, o = s);
    const a = n.width + r, l = n.height + r;
    let u;
    return u = n.skewX === 0 && n.skewY === 0 ? new we(a * n.scaleX, l * n.scaleY) : vu(a, l, Ea(n)), u.scalarAdd(o);
  }
  translateToGivenOrigin(e, n, s, r, o) {
    let a = e.x, l = e.y;
    const u = It(r) - It(n), c = It(o) - It(s);
    if (u || c) {
      const d = this._getTransformedDimensions();
      a += u * d.x, l += c * d.y;
    }
    return new we(a, l);
  }
  translateToCenterPoint(e, n, s) {
    if (n === st && s === st) return e;
    const r = this.translateToGivenOrigin(e, n, s, st, st);
    return this.angle ? r.rotate(Pt(this.angle), e) : r;
  }
  translateToOriginPoint(e, n, s) {
    const r = this.translateToGivenOrigin(e, st, st, n, s);
    return this.angle ? r.rotate(Pt(this.angle), e) : r;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? tn(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new we(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, n) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, n);
  }
  setPositionByOrigin(e, n, s) {
    const r = this.translateToCenterPoint(e, n, s), o = this.translateToOriginPoint(r, this.originX, this.originY);
    this.set({ left: o.x, top: o.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), ht, rn);
  }
}
const fM = ["type"], pM = ["extraParam"];
let Kn = class Fo extends hM {
  static getDefaults() {
    return Fo.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    Fs("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), le(this, "_cacheContext", null), Object.assign(this, Fo.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = gs(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const n = e.width, s = e.height, r = at.maxCacheSideLimit, o = at.minCacheSideLimit;
    if (n <= r && s <= r && n * s <= at.perfLimitSizeTotal) return n < o && (e.width = o), s < o && (e.height = o), e;
    const a = n / s, [l, u] = cr.limitDimsByArea(a), c = Pi(o, l, r), d = Pi(o, u, r);
    return n > c && (e.zoomX /= n / c, e.width = c, e.capped = !0), s > d && (e.zoomY /= s / d, e.height = d, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), n = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), s = n.x * e.x / this.scaleX, r = n.y * e.y / this.scaleY;
    return { width: Math.ceil(s + 2), height: Math.ceil(r + 2), zoomX: e.x, zoomY: e.y, x: s, y: r };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, n = this._cacheContext, { width: s, height: r, zoomX: o, zoomY: a, x: l, y: u } = this._limitCacheSize(this._getCacheCanvasDimensions()), c = s !== e.width || r !== e.height, d = this.zoomX !== o || this.zoomY !== a;
    if (!e || !n) return !1;
    if (c || d) {
      s !== e.width || r !== e.height ? (e.width = s, e.height = r) : (n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, e.width, e.height));
      const f = l / 2, g = u / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - f) + f, this.cacheTranslationY = Math.round(e.height / 2 - g) + g, n.translate(this.cacheTranslationX, this.cacheTranslationY), n.scale(o, a), this.zoomX = o, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const n = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, s = this.calcTransformMatrix(!n);
    e.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
  }
  getObjectScaling() {
    if (!this.group) return new we(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = ea(this.calcTransformMatrix());
    return new we(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const n = this.canvas.getZoom(), s = this.getCanvasRetinaScaling();
      return e.scalarMultiply(n * s);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, n) {
    e !== ln && e !== bn || (n = this._constrainScale(n)), e === ln && n < 0 ? (this.flipX = !this.flipX, n *= -1) : e === "scaleY" && n < 0 ? (this.flipY = !this.flipY, n *= -1) : e !== "shadow" || !n || n instanceof us || (n = new us(n));
    const s = this[e] !== n;
    return this[e] = n, s && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || s && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: n, zoomY: s, cacheTranslationX: r, cacheTranslationY: o } = this, { width: a, height: l } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: n, zoomY: s, cacheTranslationX: r, cacheTranslationY: o, width: a, height: l, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === an && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, n, s) {
    e.save(), n.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s, 0, 0), e.restore();
  }
  drawObject(e, n, s) {
    const r = this.fill, o = this.stroke;
    n ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, s), this.fill = r, this.stroke = o;
  }
  createClipPathLayer(e, n) {
    const s = xn(n), r = s.getContext("2d");
    if (r.translate(n.cacheTranslationX, n.cacheTranslationY), r.scale(n.zoomX, n.zoomY), e._cacheCanvas = s, n.parentClipPaths.forEach((o) => {
      o.transform(r);
    }), n.parentClipPaths.push(e), e.absolutePositioned) {
      const o = On(this.calcTransformMatrix());
      r.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
    }
    return e.transform(r), e.drawObject(r, !0, n), s;
  }
  _drawClipPath(e, n, s) {
    if (!n) return;
    n._transformDone = !0;
    const r = this.createClipPathLayer(n, s);
    this.drawClipPathOnCache(e, n, r);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const n = this._cacheCanvas, s = this._cacheContext;
    return !(!n || !s || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (n && s && !e && (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, n.width, n.height), s.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const n = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, n) {
    const s = n.stroke;
    s && (e.lineWidth = n.strokeWidth, e.lineCap = n.strokeLineCap, e.lineDashOffset = n.strokeDashOffset, e.lineJoin = n.strokeLineJoin, e.miterLimit = n.strokeMiterLimit, vn(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? this._applyPatternForTransformedGradient(e, s) : (e.strokeStyle = s.toLive(e), this._applyPatternGradientTransform(e, s)) : e.strokeStyle = n.stroke);
  }
  _setFillStyles(e, n) {
    let { fill: s } = n;
    s && (vn(s) ? (e.fillStyle = s.toLive(e), this._applyPatternGradientTransform(e, s)) : e.fillStyle = s);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, n) {
    n && n.length !== 0 && e.setLineDash(n);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const n = this.shadow, s = this.canvas, r = this.getCanvasRetinaScaling(), [o, , , a] = (s == null ? void 0 : s.viewportTransform) || en, l = o * r, u = a * r, c = n.nonScaling ? new we(1, 1) : this.getObjectScaling();
    e.shadowColor = n.color, e.shadowBlur = n.blur * at.browserShadowBlurConstant * (l + u) * (c.x + c.y) / 4, e.shadowOffsetX = n.offsetX * l * c.x, e.shadowOffsetY = n.offsetY * u * c.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, n) {
    if (!vn(n)) return { offsetX: 0, offsetY: 0 };
    const s = n.gradientTransform || n.patternTransform, r = -this.width / 2 + n.offsetX || 0, o = -this.height / 2 + n.offsetY || 0;
    return n.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, r, o) : e.transform(1, 0, 0, 1, r, o), s && e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), { offsetX: r, offsetY: o };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === an ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const n = this.getObjectScaling();
        e.scale(1 / n.x, 1 / n.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, n) {
    var s;
    const r = this._limitCacheSize(this._getCacheCanvasDimensions()), o = this.getCanvasRetinaScaling(), a = r.x / this.scaleX / o, l = r.y / this.scaleY / o, u = xn({ width: Math.ceil(a), height: Math.ceil(l) }), c = u.getContext("2d");
    c && (c.beginPath(), c.moveTo(0, 0), c.lineTo(a, 0), c.lineTo(a, l), c.lineTo(0, l), c.closePath(), c.translate(a / 2, l / 2), c.scale(r.zoomX / this.scaleX / o, r.zoomY / this.scaleY / o), this._applyPatternGradientTransform(c, n), c.fillStyle = n.toLive(e), c.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(o * this.scaleX / r.zoomX, o * this.scaleY / r.zoomY), e.strokeStyle = (s = c.createPattern(u, "no-repeat")) !== null && s !== void 0 ? s : "");
  }
  _findCenterFromElement() {
    return new we(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const n = this.toObject(e);
    return this.constructor.fromObject(n);
  }
  cloneAsImage(e) {
    const n = this.toCanvasElement(e);
    return new (We.getClass("image"))(n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = sf(this), s = this.group, r = this.shadow, o = Math.abs, a = e.enableRetinaScaling ? Bh() : 1, l = (e.multiplier || 1) * a, u = e.canvasProvider || ((S) => new Rr(S, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && BT(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && UT(this, this.getViewportTransform()), this.setCoords();
    const c = gs(), d = this.getBoundingRect(), f = this.shadow, g = new we();
    if (f) {
      const S = f.blur, x = f.nonScaling ? new we(1, 1) : this.getObjectScaling();
      g.x = 2 * Math.round(o(f.offsetX) + S) * o(x.x), g.y = 2 * Math.round(o(f.offsetY) + S) * o(x.y);
    }
    const p = d.width + g.x, y = d.height + g.y;
    c.width = Math.ceil(p), c.height = Math.ceil(y);
    const v = u(c);
    e.format === "jpeg" && (v.backgroundColor = "#fff"), this.setPositionByOrigin(new we(v.width / 2, v.height / 2), st, st);
    const m = this.canvas;
    v._objects = [this], this.set("canvas", v), this.setCoords();
    const b = v.toCanvasElement(l || 1, e);
    return this.set("canvas", m), this.shadow = r, s && (this.group = s), this.set(n), this.setCoords(), v._objects = [], v.destroy(), b;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Yh(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Gh(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    return n.includes(this.constructor.type) || n.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: n, originX: s, originY: r } = this;
    if (n) {
      const { x: o, y: a } = this.getRelativeCenterPoint();
      this.originX = st, this.originY = st, this.left = o, this.top = a;
    }
    if (this.set("angle", e), n) {
      const { x: o, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s, r);
      this.left = o, this.top = a, this.originX = s, this.originY = r;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    Qo.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && Nn().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, n) {
    return Object.entries(e).reduce((s, r) => {
      let [o, a] = r;
      return s[o] = this._animate(o, a, n), s;
    }, {});
  }
  _animate(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = e.split("."), o = this.constructor.colorProperties.includes(r[r.length - 1]), { abort: a, startValue: l, onChange: u, onComplete: c } = s, d = ue(ue({}, s), {}, { target: this, startValue: l ?? r.reduce((f, g) => f[g], this), endValue: n, abort: a == null ? void 0 : a.bind(this), onChange: (f, g, p) => {
      r.reduce((y, v, m) => (m === r.length - 1 && (y[v] = f), y[v]), this), u && u(f, g, p);
    }, onComplete: (f, g, p) => {
      this.setCoords(), c && c(f, g, p);
    } });
    return o ? dM(d) : vf(d);
  }
  isDescendantOf(e) {
    const { parent: n, group: s } = this;
    return n === e || s === e || !!n && n.isDescendantOf(e) || !!s && s !== n && s.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let n = this;
    do
      n = n.parent, n && e.push(n);
    while (n);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const n = this.getAncestors(), s = e.getAncestors();
    if (n.length === 0 && s.length > 0 && this === s[s.length - 1]) return { fork: [], otherFork: [e, ...s.slice(0, s.length - 1)], common: [this] };
    for (let r, o = 0; o < n.length; o++) {
      if (r = n[o], r === e) return { fork: [this, ...n.slice(0, o)], otherFork: [], common: n.slice(o) };
      for (let a = 0; a < s.length; a++) {
        if (this === s[a]) return { fork: [], otherFork: [e, ...s.slice(0, a)], common: [this, ...n] };
        if (r === s[a]) return { fork: [this, ...n.slice(0, o)], otherFork: [e, ...s.slice(0, a)], common: n.slice(o) };
      }
    }
    return { fork: [this, ...n], otherFork: [e, ...s], common: [] };
  }
  hasCommonAncestors(e) {
    const n = this.findCommonAncestors(e);
    return n && !!n.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const n = this.findCommonAncestors(e);
    if (n.fork.includes(e)) return !0;
    if (n.otherFork.includes(this)) return !1;
    const s = n.common[0] || this.canvas;
    if (!s) return;
    const r = n.fork.pop(), o = n.otherFork.pop(), a = s._objects.indexOf(r), l = s._objects.indexOf(o);
    return a > -1 && a > l;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(Fo.customProperties, this.constructor.customProperties || []);
    let n;
    const s = at.NUM_FRACTION_DIGITS, { clipPath: r, fill: o, stroke: a, shadow: l, strokeDashArray: u, left: c, top: d, originX: f, originY: g, width: p, height: y, strokeWidth: v, strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: x, strokeMiterLimit: _, scaleX: C, scaleY: k, angle: M, flipX: O, flipY: F, opacity: $, visible: ne, backgroundColor: oe, fillRule: z, paintFirst: X, globalCompositeOperation: T, skewX: H, skewY: ge } = this;
    r && !r.excludeFromExport && (n = r.toObject(e.concat("inverted", "absolutePositioned")));
    const K = (ie) => xt(ie, s), re = ue(ue({}, Ri(this, e)), {}, { type: this.constructor.type, version: El, originX: f, originY: g, left: K(c), top: K(d), width: K(p), height: K(y), fill: Mc(o) ? o.toObject() : o, stroke: Mc(a) ? a.toObject() : a, strokeWidth: K(v), strokeDashArray: u && u.concat(), strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: x, strokeMiterLimit: K(_), scaleX: K(C), scaleY: K(k), angle: K(M), flipX: O, flipY: F, opacity: K($), shadow: l && l.toObject(), visible: ne, backgroundColor: oe, fillRule: z, paintFirst: X, globalCompositeOperation: T, skewX: K(H), skewY: K(ge) }, n ? { clipPath: n } : null);
    return this.includeDefaultValues ? re : this._removeDefaultValues(re);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const n = this.constructor.getDefaults(), s = Object.keys(n).length > 0 ? n : Object.getPrototypeOf(this);
    return gu(e, (r, o) => {
      if (o === ht || o === rn || o === "type") return !0;
      const a = s[o];
      return r !== a && !(Array.isArray(r) && Array.isArray(a) && r.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let n = _t(e, fM), s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: r } = s, o = _t(s, pM);
    return Pa(n, o).then((a) => r ? (delete a[r], new this(n[r], a)) : new this(a));
  }
  static fromObject(e, n) {
    return this._fromObject(e, n);
  }
};
le(Kn, "stateProperties", eM), le(Kn, "cacheProperties", bs), le(Kn, "ownDefaults", tM), le(Kn, "type", "FabricObject"), le(Kn, "colorProperties", [Ft, an, "backgroundColor"]), le(Kn, "customProperties", []), We.setClass(Kn), We.setClass(Kn, "object");
const Vi = (i, e, n) => (s, r, o, a) => {
  const l = e(s, r, o, a);
  return l && rf(i, ue(ue({}, af(s, r, o, a)), n)), l;
};
function ji(i) {
  return (e, n, s, r) => {
    const { target: o, originX: a, originY: l } = n, u = o.getRelativeCenterPoint(), c = o.translateToOriginPoint(u, a, l), d = i(e, n, s, r);
    return o.setPositionByOrigin(c, n.originX, n.originY), d;
  };
}
const Uc = Vi(kr, ji((i, e, n, s) => {
  const r = yu(e, e.originX, e.originY, n, s);
  if (It(e.originX) === It(st) || It(e.originX) === It(Et) && r.x < 0 || It(e.originX) === It(ht) && r.x > 0) {
    const { target: o } = e, a = o.strokeWidth / (o.strokeUniform ? o.scaleX : 1), l = of(e) ? 2 : 1, u = o.width, c = Math.abs(r.x * l / o.scaleX) - a;
    return o.set("width", Math.max(c, 1)), u !== o.width;
  }
  return !1;
}));
function mM(i, e, n, s, r) {
  s = s || {};
  const o = this.sizeX || s.cornerSize || r.cornerSize, a = this.sizeY || s.cornerSize || r.cornerSize, l = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, u = l ? an : Ft, c = !l && (s.cornerStrokeColor || r.cornerStrokeColor);
  let d, f = e, g = n;
  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || "", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || "", o > a ? (d = o, i.scale(1, a / o), g = n * o / a) : a > o ? (d = a, i.scale(o / a, 1), f = e * a / o) : d = o, i.beginPath(), i.arc(f, g, d / 2, 0, qo, !1), i[u](), c && i.stroke(), i.restore();
}
function gM(i, e, n, s, r) {
  s = s || {};
  const o = this.sizeX || s.cornerSize || r.cornerSize, a = this.sizeY || s.cornerSize || r.cornerSize, l = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, u = l ? an : Ft, c = !l && (s.cornerStrokeColor || r.cornerStrokeColor), d = o / 2, f = a / 2;
  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || "", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || "", i.translate(e, n);
  const g = r.getTotalAngle();
  i.rotate(Pt(g)), i["".concat(u, "Rect")](-d, -f, o, a), c && i.strokeRect(-d, -f, o, a), i.restore();
}
class Cn {
  constructor(e) {
    le(this, "visible", !0), le(this, "actionName", Oa), le(this, "angle", 0), le(this, "x", 0), le(this, "y", 0), le(this, "offsetX", 0), le(this, "offsetY", 0), le(this, "sizeX", 0), le(this, "sizeY", 0), le(this, "touchSizeX", 0), le(this, "touchSizeY", 0), le(this, "cursorStyle", "crosshair"), le(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, n, s, r) {
    var o;
    let { tl: a, tr: l, br: u, bl: c } = r;
    return ((o = n.canvas) === null || o === void 0 ? void 0 : o.getActiveObject()) === n && n.isControlVisible(e) && Ct.isPointInPolygon(s, [a, l, u, c]);
  }
  getActionHandler(e, n, s) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, n, s) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, n, s) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, n, s) {
    return n.cursorStyle;
  }
  getActionName(e, n, s) {
    return n.actionName;
  }
  getVisibility(e, n) {
    var s, r;
    return (s = (r = e._controlsVisibility) === null || r === void 0 ? void 0 : r[n]) !== null && s !== void 0 ? s : this.visible;
  }
  setVisibility(e, n, s) {
    this.visible = e;
  }
  positionHandler(e, n, s, r) {
    return new we(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(n);
  }
  calcCornerCoords(e, n, s, r, o, a) {
    const l = pu([zr(s, r), zi({ angle: e }), mu((o ? this.touchSizeX : this.sizeX) || n, (o ? this.touchSizeY : this.sizeY) || n)]);
    return { tl: new we(-0.5, -0.5).transform(l), tr: new we(0.5, -0.5).transform(l), br: new we(0.5, 0.5).transform(l), bl: new we(-0.5, 0.5).transform(l) };
  }
  render(e, n, s, r, o) {
    ((r = r || {}).cornerStyle || o.cornerStyle) === "circle" ? mM.call(this, e, n, s, r, o) : gM.call(this, e, n, s, r, o);
  }
}
const vM = (i, e, n) => n.lockRotation ? na : e.cursorStyle, yM = Vi(Uh, ji((i, e, n, s) => {
  let { target: r, ex: o, ey: a, theta: l, originX: u, originY: c } = e;
  const d = r.translateToOriginPoint(r.getRelativeCenterPoint(), u, c);
  if (Dn(r, "lockRotation")) return !1;
  const f = Math.atan2(a - d.y, o - d.x), g = Math.atan2(s - d.y, n - d.x);
  let p = vs(g - f + l);
  if (r.snapAngle && r.snapAngle > 0) {
    const v = r.snapAngle, m = r.snapThreshold || v, b = Math.ceil(p / v) * v, S = Math.floor(p / v) * v;
    Math.abs(p - S) < m ? p = S : Math.abs(p - b) < m && (p = b);
  }
  p < 0 && (p = 360 + p), p %= 360;
  const y = r.angle !== p;
  return r.angle = p, y;
}));
function yf(i, e) {
  const n = e.canvas, s = i[n.uniScaleKey];
  return n.uniformScaling && !s || !n.uniformScaling && s;
}
function bf(i, e, n) {
  const s = Dn(i, "lockScalingX"), r = Dn(i, "lockScalingY");
  if (s && r || !e && (s || r) && n || s && e === "x" || r && e === "y") return !0;
  const { width: o, height: a, strokeWidth: l } = i;
  return o === 0 && l === 0 && e !== "y" || a === 0 && l === 0 && e !== "x";
}
const bM = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], er = (i, e, n) => {
  const s = yf(i, n);
  if (bf(n, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", s)) return na;
  const r = lf(n, e);
  return "".concat(bM[r], "-resize");
};
function _u(i, e, n, s) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const o = e.target, a = r.by, l = yf(i, o);
  let u, c, d, f, g, p;
  if (bf(o, a, l)) return !1;
  if (e.gestureScale) c = e.scaleX * e.gestureScale, d = e.scaleY * e.gestureScale;
  else {
    if (u = yu(e, e.originX, e.originY, n, s), g = a !== "y" ? Math.sign(u.x || e.signX || 1) : 1, p = a !== "x" ? Math.sign(u.y || e.signY || 1) : 1, e.signX || (e.signX = g), e.signY || (e.signY = p), Dn(o, "lockScalingFlip") && (e.signX !== g || e.signY !== p)) return !1;
    if (f = o._getTransformedDimensions(), l && !a) {
      const m = Math.abs(u.x) + Math.abs(u.y), { original: b } = e, S = m / (Math.abs(f.x * b.scaleX / o.scaleX) + Math.abs(f.y * b.scaleY / o.scaleY));
      c = b.scaleX * S, d = b.scaleY * S;
    } else c = Math.abs(u.x * o.scaleX / f.x), d = Math.abs(u.y * o.scaleY / f.y);
    of(e) && (c *= 2, d *= 2), e.signX !== g && a !== "y" && (e.originX = Dc(e.originX), c *= -1, e.signX = g), e.signY !== p && a !== "x" && (e.originY = Dc(e.originY), d *= -1, e.signY = p);
  }
  const y = o.scaleX, v = o.scaleY;
  return a ? (a === "x" && o.set(ln, c), a === "y" && o.set(bn, d)) : (!Dn(o, "lockScalingX") && o.set(ln, c), !Dn(o, "lockScalingY") && o.set(bn, d)), y !== o.scaleX || v !== o.scaleY;
}
const Zr = Vi(Ma, ji((i, e, n, s) => _u(i, e, n, s))), xM = Vi(Ma, ji((i, e, n, s) => _u(i, e, n, s, { by: "x" }))), _M = Vi(Ma, ji((i, e, n, s) => _u(i, e, n, s, { by: "y" }))), wM = ["target", "ex", "ey", "skewingSide"], ol = { x: { counterAxis: "y", scale: ln, skew: Fi, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: bn, skew: Li, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, SM = ["ns", "nesw", "ew", "nwse"], CM = (i, e, n) => {
  if (e.x !== 0 && Dn(n, "lockSkewingY") || e.y !== 0 && Dn(n, "lockSkewingX")) return na;
  const s = lf(n, e) % 4;
  return "".concat(SM[s], "-resize");
};
function xf(i, e, n, s, r) {
  const { target: o } = n, { counterAxis: a, origin: l, lockSkewing: u, skew: c, flip: d } = ol[i];
  if (Dn(o, u)) return !1;
  const { origin: f, flip: g } = ol[a], p = It(n[f]) * (o[g] ? -1 : 1), y = -Math.sign(p) * (o[d] ? -1 : 1), v = 0.5 * -((o[c] === 0 && yu(n, st, st, s, r)[i] > 0 || o[c] > 0 ? 1 : -1) * y) + 0.5;
  return Vi(Nh, ji((b, S, x, _) => function(C, k, M) {
    let { target: O, ex: F, ey: $, skewingSide: ne } = k, oe = _t(k, wM);
    const { skew: z } = ol[C], X = M.subtract(new we(F, $)).divide(new we(O.scaleX, O.scaleY))[C], T = O[z], H = oe[z], ge = Math.tan(Pt(H)), K = C === "y" ? O._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : O._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, re = 2 * X * ne / Math.max(K, 1) + ge, ie = vs(Math.atan(re));
    O.set(z, ie);
    const be = T !== O[z];
    if (be && C === "y") {
      const { skewX: J, scaleX: ee } = O, ve = O._getTransformedDimensions({ skewY: T }), G = O._getTransformedDimensions(), N = J !== 0 ? ve.x / G.x : 1;
      N !== 1 && O.set(ln, N * ee);
    }
    return be;
  }(i, S, new we(x, _))))(e, ue(ue({}, n), {}, { [l]: v, skewingSide: y }), s, r);
}
const kM = (i, e, n, s) => xf("x", i, e, n, s), TM = (i, e, n, s) => xf("y", i, e, n, s);
function Ia(i, e) {
  return i[e.canvas.altActionKey];
}
const Jr = (i, e, n) => {
  const s = Ia(i, n);
  return e.x === 0 ? s ? Fi : bn : e.y === 0 ? s ? Li : ln : "";
}, hi = (i, e, n) => Ia(i, n) ? CM(0, e, n) : er(i, e, n), Nc = (i, e, n, s) => Ia(i, e.target) ? TM(i, e, n, s) : xM(i, e, n, s), Hc = (i, e, n, s) => Ia(i, e.target) ? kM(i, e, n, s) : _M(i, e, n, s), _f = () => ({ ml: new Cn({ x: -0.5, y: 0, cursorStyleHandler: hi, actionHandler: Nc, getActionName: Jr }), mr: new Cn({ x: 0.5, y: 0, cursorStyleHandler: hi, actionHandler: Nc, getActionName: Jr }), mb: new Cn({ x: 0, y: 0.5, cursorStyleHandler: hi, actionHandler: Hc, getActionName: Jr }), mt: new Cn({ x: 0, y: -0.5, cursorStyleHandler: hi, actionHandler: Hc, getActionName: Jr }), tl: new Cn({ x: -0.5, y: -0.5, cursorStyleHandler: er, actionHandler: Zr }), tr: new Cn({ x: 0.5, y: -0.5, cursorStyleHandler: er, actionHandler: Zr }), bl: new Cn({ x: -0.5, y: 0.5, cursorStyleHandler: er, actionHandler: Zr }), br: new Cn({ x: 0.5, y: 0.5, cursorStyleHandler: er, actionHandler: Zr }), mtr: new Cn({ x: 0, y: -0.5, actionHandler: yM, cursorStyleHandler: vM, offsetY: -40, withConnection: !0, actionName: hu }) }), MM = () => ({ mr: new Cn({ x: 0.5, y: 0, actionHandler: Uc, cursorStyleHandler: hi, actionName: kr }), ml: new Cn({ x: -0.5, y: 0, actionHandler: Uc, cursorStyleHandler: hi, actionName: kr }) }), OM = () => ue(ue({}, _f()), MM());
class Er extends Kn {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Er.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), Er.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: _f() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const n = e._currentTransform, s = n.target, r = n.action;
      if (this === s && r && r.startsWith(Oa)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const s = Object.entries(this.oCoords);
    for (let r = s.length - 1; r >= 0; r--) {
      const [o, a] = s[r], l = this.controls[o];
      if (l.shouldActivate(o, this, e, n ? a.touchCorner : a.corner)) return this.__corner = o, { key: o, control: l, coord: this.oCoords[o] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), n = this.getCenterPoint(), s = zr(n.x, n.y), r = zi({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), o = Wt(s, r), a = Wt(e, o), l = Wt(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), u = this.group ? ea(this.calcTransformMatrix()) : void 0;
    u && (u.scaleX = Math.abs(u.scaleX), u.scaleY = Math.abs(u.scaleY));
    const c = this._calculateCurrentDimensions(u), d = {};
    return this.forEachControl((f, g) => {
      const p = f.positionHandler(c, l, this, f);
      d[g] = Object.assign(p, this._calcCornerCoords(f, p));
    }), d;
  }
  _calcCornerCoords(e, n) {
    const s = this.getTotalAngle();
    return { corner: e.calcCornerCoords(s, this.cornerSize, n.x, n.y, !1, this), touchCorner: e.calcCornerCoords(s, this.touchCornerSize, n.x, n.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const n in this.controls) e(this.controls[n], n, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const n = this.getRelativeCenterPoint(), s = this._calculateCurrentDimensions(), r = this.getViewportTransform();
    e.translate(n.x, n.y), e.scale(1 / r[0], 1 / r[3]), e.rotate(Pt(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-s.x / 2, -s.y / 2, s.x, s.y), e.restore();
  }
  strokeBorders(e, n) {
    e.strokeRect(-n.x / 2, -n.y / 2, n.x, n.y);
  }
  _drawBorders(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = ue({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, s);
    e.save(), e.strokeStyle = r.borderColor, this._setLineDash(e, r.borderDashArray), this.strokeBorders(e, n), r.hasControls && this.drawControlsConnectingLines(e, n), e.restore();
  }
  _renderControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: s, hasControls: r } = this, o = ue({ hasBorders: s, hasControls: r }, n), a = this.getViewportTransform(), l = o.hasBorders, u = o.hasControls, c = Wt(a, this.calcTransformMatrix()), d = ea(c);
    e.save(), e.translate(d.translateX, d.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (d.angle -= 180), e.rotate(Pt(this.group ? d.angle : this.angle)), l && this.drawBorders(e, d, n), u && this.drawControls(e, n), e.restore();
  }
  drawBorders(e, n, s) {
    let r;
    if (s && s.forActiveSelection || this.group) {
      const o = vu(this.width, this.height, Ea(n)), a = this.isStrokeAccountedForInDimensions() ? fu : (this.strokeUniform ? new we().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new we(n.scaleX, n.scaleY)).scalarMultiply(this.strokeWidth);
      r = o.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else r = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, r, s);
  }
  drawControlsConnectingLines(e, n) {
    let s = !1;
    e.beginPath(), this.forEachControl((r, o) => {
      r.withConnection && r.getVisibility(this, o) && (s = !0, e.moveTo(r.x * n.x, r.y * n.y), e.lineTo(r.x * n.x + r.offsetX, r.y * n.y + r.offsetY));
    }), s && e.stroke();
  }
  drawControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const s = this.getCanvasRetinaScaling(), { cornerStrokeColor: r, cornerDashArray: o, cornerColor: a } = this, l = ue({ cornerStrokeColor: r, cornerDashArray: o, cornerColor: a }, n);
    e.setTransform(s, 0, 0, s, 0, 0), e.strokeStyle = e.fillStyle = l.cornerColor, this.transparentCorners || (e.strokeStyle = l.cornerStrokeColor), this._setLineDash(e, l.cornerDashArray), this.forEachControl((u, c) => {
      if (u.getVisibility(this, c)) {
        const d = this.oCoords[c];
        u.render(e, d.x, d.y, l, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, n) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = n;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((n) => {
      let [s, r] = n;
      return this.setControlVisible(s, r);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const n = this.canvas.contextTop;
    if (!n) return;
    const s = this.canvas.viewportTransform;
    n.save(), n.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this.transform(n);
    const r = this.width + 4, o = this.height + 4;
    return n.clearRect(-r / 2, -o / 2, r, o), e || n.restore(), n;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function wf(i, e) {
  return e.forEach((n) => {
    Object.getOwnPropertyNames(n.prototype).forEach((s) => {
      s !== "constructor" && Object.defineProperty(i.prototype, s, Object.getOwnPropertyDescriptor(n.prototype, s) || /* @__PURE__ */ Object.create(null));
    });
  }), i;
}
le(Er, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class Gt extends Er {
}
wf(Gt, [uf]), We.setClass(Gt), We.setClass(Gt, "object");
const EM = (i, e, n, s) => {
  const r = 2 * (s = Math.round(s)) + 1, { data: o } = i.getImageData(e - s, n - s, r, r);
  for (let a = 3; a < o.length; a += 4)
    if (o[a] > 0) return !1;
  return !0;
};
class Sf {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new we(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new we(1 / this.options.scaleX, 1 / this.options.scaleY) : new we(1, 1);
  }
  createSideVector(e, n) {
    const s = Il(e, n);
    return this.options.strokeUniform ? s.multiply(this.scale) : s;
  }
  projectOrthogonally(e, n, s) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, n, s)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const n = new we(e);
    return n.y += n.x * Math.tan(Pt(this.options.skewY)), n.x += n.y * Math.tan(Pt(this.options.skewX)), n;
  }
  scaleUnitVector(e, n) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(n);
  }
}
const PM = new we();
class Si extends Sf {
  static getOrthogonalRotationFactor(e, n) {
    const s = n ? Ll(e, n) : JT(e);
    return Math.abs(s) < Lr ? -1 : 1;
  }
  constructor(e, n, s, r) {
    super(r), le(this, "AB", void 0), le(this, "AC", void 0), le(this, "alpha", void 0), le(this, "bisector", void 0), this.A = new we(e), this.B = new we(n), this.C = new we(s), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = Ll(this.AB, this.AC), this.bisector = bu(mf(this.AB.eq(PM) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const r = this.createSideVector(e, n), o = gf(r), a = Si.getOrthogonalRotationFactor(o, this.bisector);
    return this.scaleUnitVector(o, s * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % qo == 0 ? [this.B] : [this.B, this.C]).forEach((n) => {
      e.push(this.projectOrthogonally(this.A, n)), e.push(this.projectOrthogonally(this.A, n, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], n = Math.abs(this.alpha), s = 1 / Math.sin(n / 2), r = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s), o = this.options.strokeUniform ? Fl(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return Fl(r) / this.strokeProjectionMagnitude <= o && e.push(this.applySkew(this.A.add(r))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, n) {
    const s = [], r = new we(Si.getOrthogonalRotationFactor(this.bisector), Si.getOrthogonalRotationFactor(new we(this.bisector.y, this.bisector.x)));
    return [new we(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r), new we(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r)].forEach((o) => {
      $c(o, e, n) && s.push(this.A.add(o));
    }), s;
  }
  projectRoundWithSkew(e, n) {
    const s = [], { skewX: r, skewY: o, scaleX: a, scaleY: l, strokeUniform: u } = this.options, c = new we(Math.tan(Pt(r)), Math.tan(Pt(o))), d = this.strokeProjectionMagnitude, f = u ? d / l / Math.sqrt(1 / l ** 2 + 1 / a ** 2 * c.y ** 2) : d / Math.sqrt(1 + c.y ** 2), g = new we(Math.sqrt(Math.max(d ** 2 - f ** 2, 0)), f), p = u ? d / Math.sqrt(1 + c.x ** 2 * (1 / l) ** 2 / (1 / a + 1 / a * c.x * c.y) ** 2) : d / Math.sqrt(1 + c.x ** 2 / (1 + c.x * c.y) ** 2), y = new we(p, Math.sqrt(Math.max(d ** 2 - p ** 2, 0)));
    return [y, y.scalarMultiply(-1), g, g.scalarMultiply(-1)].map((v) => this.applySkew(u ? v.multiply(this.strokeUniformScalar) : v)).forEach((v) => {
      $c(v, e, n) && s.push(this.applySkew(this.A).add(v));
    }), s;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const n = this.alpha % qo == 0, s = this.applySkew(this.A), r = e[n ? 0 : 2].subtract(s), o = e[n ? 1 : 0].subtract(s), a = n ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), l = fr(r, a) > 0, u = l ? r : o, c = l ? o : r;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(u, c)) : e.push(...this.projectRoundNoSkew(u, c)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class Xc extends Sf {
  constructor(e, n, s) {
    super(s), this.A = new we(e), this.T = new we(n);
  }
  calcOrthogonalProjection(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const r = this.createSideVector(e, n);
    return this.scaleUnitVector(gf(r), s);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const n = new we(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(n)), this.applySkew(this.A.subtract(n)));
    } else e.push(...new Si(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const n = new we(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(n), this.A.subtract(n));
    } else {
      const n = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s = this.scaleUnitVector(bu(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), r = this.A.add(s);
      e.push(r.add(n), r.subtract(n));
    }
    return e.map((n) => this.applySkew(n));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const DM = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const s = [];
  if (i.length === 0) return s;
  const r = i.reduce((o, a) => (o[o.length - 1].eq(a) || o.push(new we(a)), o), [new we(i[0])]);
  if (r.length === 1) n = !0;
  else if (!n) {
    const o = r[0], a = ((l, u) => {
      for (let c = l.length - 1; c >= 0; c--) if (u(l[c], c, l)) return c;
      return -1;
    })(r, (l) => !l.eq(o));
    r.splice(a + 1);
  }
  return r.forEach((o, a, l) => {
    let u, c;
    a === 0 ? (c = l[1], u = n ? o : l[l.length - 1]) : a === l.length - 1 ? (u = l[a - 1], c = n ? o : l[0]) : (u = l[a - 1], c = l[a + 1]), n && l.length === 1 ? s.push(...new Xc(o, o, e).project()) : !n || a !== 0 && a !== l.length - 1 ? s.push(...new Si(o, u, c, e).project()) : s.push(...new Xc(o, a === 0 ? c : u, e).project());
  }), s;
}, wu = (i) => {
  const e = {};
  return Object.keys(i).forEach((n) => {
    e[n] = {}, Object.keys(i[n]).forEach((s) => {
      e[n][s] = ue({}, i[n][s]);
    });
  }), e;
}, AM = (i) => i.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
let Hi;
const Su = (i) => {
  if (Hi || Hi || (Hi = "Intl" in Ta() && "Segmenter" in Intl && new Intl.Segmenter(void 0, { granularity: "grapheme" })), Hi) {
    const e = Hi.segment(i);
    return Array.from(e).map((n) => {
      let { segment: s } = n;
      return s;
    });
  }
  return IM(i);
}, IM = (i) => {
  const e = [];
  for (let n, s = 0; s < i.length; s++) (n = FM(i, s)) !== !1 && e.push(n);
  return e;
}, FM = (i, e) => {
  const n = i.charCodeAt(e);
  if (isNaN(n)) return "";
  if (n < 55296 || n > 57343) return i.charAt(e);
  if (55296 <= n && n <= 56319) {
    if (i.length <= e + 1) throw "High surrogate without following low surrogate";
    const r = i.charCodeAt(e + 1);
    if (56320 > r || r > 57343) throw "High surrogate without following low surrogate";
    return i.charAt(e) + i.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const s = i.charCodeAt(e - 1);
  if (55296 > s || s > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
}, Cu = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return i.fill !== e.fill || i.stroke !== e.stroke || i.strokeWidth !== e.strokeWidth || i.fontSize !== e.fontSize || i.fontFamily !== e.fontFamily || i.fontWeight !== e.fontWeight || i.fontStyle !== e.fontStyle || i.textDecorationThickness !== e.textDecorationThickness || i.textBackgroundColor !== e.textBackgroundColor || i.deltaY !== e.deltaY || n && (i.overline !== e.overline || i.underline !== e.underline || i.linethrough !== e.linethrough);
}, LM = (i, e) => {
  const n = e.split(`
`), s = [];
  let r = -1, o = {};
  i = wu(i);
  for (let a = 0; a < n.length; a++) {
    const l = Su(n[a]);
    if (i[a]) for (let u = 0; u < l.length; u++) {
      r++;
      const c = i[a][u];
      c && Object.keys(c).length > 0 && (Cu(o, c, !0) ? s.push({ start: r, end: r + 1, style: c }) : s[s.length - 1].end++), o = c || {};
    }
    else r += l.length, o = {};
  }
  return s;
}, zM = (i, e) => {
  if (!Array.isArray(i)) return wu(i);
  const n = e.split(du), s = {};
  let r = -1, o = 0;
  for (let a = 0; a < n.length; a++) {
    const l = Su(n[a]);
    for (let u = 0; u < l.length; u++) r++, i[o] && i[o].start <= r && r < i[o].end && (s[a] = s[a] || {}, s[a][u] = ue({}, i[o].style), r === i[o].end - 1 && o++);
  }
  return s;
}, Rs = ["display", "transform", Ft, "fill-opacity", "fill-rule", "opacity", an, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function Yc(i, e) {
  const n = i.nodeName, s = i.getAttribute("class"), r = i.getAttribute("id"), o = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + n, "i"), e = e.replace(a, ""), r && e.length && (a = new RegExp("#" + r + o, "i"), e = e.replace(a, "")), s && e.length) {
    const l = s.split(" ");
    for (let u = l.length; u--; ) a = new RegExp("\\." + l[u] + o, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function RM(i, e) {
  let n = !0;
  const s = Yc(i, e.pop());
  return s && e.length && (n = function(r, o) {
    let a, l = !0;
    for (; r.parentElement && r.parentElement.nodeType === 1 && o.length; ) l && (a = o.pop()), l = Yc(r = r.parentElement, a);
    return o.length === 0;
  }(i, e)), s && n && e.length === 0;
}
const VM = (i) => {
  var e;
  return (e = qT[i]) !== null && e !== void 0 ? e : i;
}, jM = new RegExp("(".concat(En, ")"), "gi"), $M = (i) => sa(i.replace(jM, " $1 ").replace(/,/gi, " "));
var Gc, Kc, qc, Zc, Jc, Qc, ed;
const Qt = "(".concat(En, ")"), BM = String.raw(Gc || (Gc = Hn(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), Qt), WM = String.raw(Kc || (Kc = Hn(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), Qt), UM = String.raw(qc || (qc = Hn(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), Qt, Qt, Qt), NM = String.raw(Zc || (Zc = Hn(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), Qt, Qt), HM = String.raw(Jc || (Jc = Hn(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), Qt, Qt), XM = String.raw(Qc || (Qc = Hn(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), Qt, Qt, Qt, Qt, Qt, Qt), ku = "(?:".concat(XM, "|").concat(HM, "|").concat(UM, "|").concat(NM, "|").concat(BM, "|").concat(WM, ")"), YM = "(?:".concat(ku, "*)"), GM = String.raw(ed || (ed = Hn(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), YM), KM = new RegExp(GM), qM = new RegExp(ku), ZM = new RegExp(ku, "g");
function zl(i) {
  const e = [];
  if (!(i = $M(i).replace(/\s*([()])\s*/gi, "$1")) || i && !KM.test(i)) return [...en];
  for (const n of i.matchAll(ZM)) {
    const s = qM.exec(n[0]);
    if (!s) continue;
    let r = en;
    const o = s.filter((y) => !!y), [, a, ...l] = o, [u, c, d, f, g, p] = l.map((y) => parseFloat(y));
    switch (a) {
      case "translate":
        r = zr(u, c);
        break;
      case hu:
        r = zi({ angle: u }, { x: c, y: d });
        break;
      case Oa:
        r = mu(u, c);
        break;
      case Fi:
        r = Zh(u);
        break;
      case Li:
        r = Jh(u);
        break;
      case "matrix":
        r = [u, c, d, f, g, p];
    }
    e.push(r);
  }
  return pu(e);
}
function JM(i, e, n, s) {
  const r = Array.isArray(e);
  let o, a = e;
  if (i !== Ft && i !== an || e !== on) {
    if (i === "strokeUniform") return e === "non-scaling-stroke";
    if (i === "strokeDashArray") a = e === on ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (i === "transformMatrix") a = n && n.transformMatrix ? Wt(n.transformMatrix, zl(e)) : zl(e);
    else if (i === "visible") a = e !== on && e !== "hidden", n && n.visible === !1 && (a = !1);
    else if (i === "opacity") a = parseFloat(e), n && n.opacity !== void 0 && (a *= n.opacity);
    else if (i === "textAnchor") a = e === "start" ? ht : e === "end" ? Et : st;
    else if (i === "charSpacing" || i === ti) o = wi(e, s) / s * 1e3;
    else if (i === "paintFirst") {
      const l = e.indexOf(Ft), u = e.indexOf(an);
      a = Ft, (l > -1 && u > -1 && u < l || l === -1 && u > -1) && (a = an);
    } else {
      if (i === "href" || i === "xlink:href" || i === "font" || i === "id") return e;
      if (i === "imageSmoothing") return e === "optimizeQuality";
      o = r ? e.map(wi) : wi(e, s);
    }
  } else a = "";
  return !r && isNaN(o) ? a : o;
}
function QM(i, e) {
  const n = i.match(KT);
  if (!n) return;
  const s = n[1], r = n[3], o = n[4], a = n[5], l = n[6];
  s && (e.fontStyle = s), r && (e.fontWeight = isNaN(parseFloat(r)) ? r : parseFloat(r)), o && (e.fontSize = wi(o)), l && (e.fontFamily = l), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function e4(i, e) {
  i.replace(/;\s*$/, "").split(";").forEach((n) => {
    if (!n) return;
    const [s, r] = n.split(":");
    e[s.trim().toLowerCase()] = r.trim();
  });
}
function t4(i) {
  const e = {}, n = i.getAttribute("style");
  return n && (typeof n == "string" ? e4(n, e) : function(s, r) {
    Object.entries(s).forEach((o) => {
      let [a, l] = o;
      l !== void 0 && (r[a.toLowerCase()] = l);
    });
  }(n, e)), e;
}
const n4 = { stroke: "strokeOpacity", fill: "fillOpacity" };
function xs(i, e, n) {
  if (!i) return {};
  let s, r = {}, o = cu;
  i.parentNode && jc.test(i.parentNode.nodeName) && (r = xs(i.parentElement, e, n), r.fontSize && (s = o = wi(r.fontSize)));
  const a = ue(ue(ue({}, e.reduce((c, d) => {
    const f = i.getAttribute(d);
    return f && (c[d] = f), c;
  }, {})), function(c) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = {};
    for (const g in d) RM(c, g.split(" ")) && (f = ue(ue({}, f), d[g]));
    return f;
  }(i, n)), t4(i));
  a[il] && i.setAttribute(il, a[il]), a[sl] && (s = wi(a[sl], o), a[sl] = "".concat(s));
  const l = {};
  for (const c in a) {
    const d = VM(c), f = JM(d, a[c], r, s);
    l[d] = f;
  }
  l && l.font && QM(l.font, l);
  const u = ue(ue({}, r), l);
  return jc.test(i.nodeName) ? u : function(c) {
    const d = Gt.getDefaults();
    return Object.entries(n4).forEach((f) => {
      let [g, p] = f;
      if (c[p] === void 0 || c[g] === "") return;
      if (c[g] === void 0) {
        if (!d[g]) return;
        c[g] = d[g];
      }
      if (c[g].indexOf("url(") === 0) return;
      const y = new ft(c[g]);
      c[g] = y.setAlpha(xt(y.getAlpha() * c[p], 2)).toRgba();
    }), c;
  }(u);
}
const s4 = ["left", "top", "width", "height", "visible"], Cf = ["rx", "ry"];
class At extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), At.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, At.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: n } = this;
    e && !n ? this.ry = e : n && !e && (this.rx = n);
  }
  _render(e) {
    const { width: n, height: s } = this, r = -n / 2, o = -s / 2, a = this.rx ? Math.min(this.rx, n / 2) : 0, l = this.ry ? Math.min(this.ry, s / 2) : 0, u = a !== 0 || l !== 0;
    e.beginPath(), e.moveTo(r + a, o), e.lineTo(r + n - a, o), u && e.bezierCurveTo(r + n - _s * a, o, r + n, o + _s * l, r + n, o + l), e.lineTo(r + n, o + s - l), u && e.bezierCurveTo(r + n, o + s - _s * l, r + n - _s * a, o + s, r + n - a, o + s), e.lineTo(r + a, o + s), u && e.bezierCurveTo(r + _s * a, o + s, r, o + s - _s * l, r, o + s - l), e.lineTo(r, o + l), u && e.bezierCurveTo(r, o + _s * l, r + _s * a, o, r + a, o), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Cf, ...e]);
  }
  _toSVG() {
    const { width: e, height: n, rx: s, ry: r } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-n / 2, '" rx="').concat(s, '" ry="').concat(r, '" width="').concat(e, '" height="').concat(n, `" />
`)];
  }
  static async fromElement(e, n, s) {
    const r = xs(e, this.ATTRIBUTE_NAMES, s), { left: o = 0, top: a = 0, width: l = 0, height: u = 0, visible: c = !0 } = r, d = _t(r, s4);
    return new this(ue(ue(ue({}, n), d), {}, { left: o, top: a, width: l, height: u, visible: !!(c && l && u) }));
  }
}
le(At, "type", "Rect"), le(At, "cacheProperties", [...bs, ...Cf]), le(At, "ownDefaults", { rx: 0, ry: 0 }), le(At, "ATTRIBUTE_NAMES", [...Rs, "x", "y", "rx", "ry", "width", "height"]), We.setClass(At), We.setSVGClass(At);
const ss = "initialization", ra = "added", Tu = "removed", oa = "imperative", kf = (i, e) => {
  const { strokeUniform: n, strokeWidth: s, width: r, height: o, group: a } = e, l = a && a !== i ? Da(a.calcTransformMatrix(), i.calcTransformMatrix()) : null, u = l ? e.getRelativeCenterPoint().transform(l) : e.getRelativeCenterPoint(), c = !e.isStrokeAccountedForInDimensions(), d = n && c ? WT(new we(s, s), void 0, i.calcTransformMatrix()) : fu, f = !n && c ? s : 0, g = vu(r + f, o + f, pu([l, e.calcOwnMatrix()], !0)).add(d).scalarDivide(2);
  return [u.subtract(g), u.add(g)];
};
class Fa {
  calcLayoutResult(e, n) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(n, e);
  }
  shouldPerformLayout(e) {
    let { type: n, prevStrategy: s, strategy: r } = e;
    return n === ss || n === oa || !!s && r !== s;
  }
  shouldLayoutClipPath(e) {
    let { type: n, target: { clipPath: s } } = e;
    return n !== ss && s && !s.absolutePositioned;
  }
  getInitialSize(e, n) {
    return n.size;
  }
  calcBoundingBox(e, n) {
    const { type: s, target: r } = n;
    if (s === oa && n.overrides) return n.overrides;
    if (e.length === 0) return;
    const { left: o, top: a, width: l, height: u } = ls(e.map((f) => kf(r, f)).reduce((f, g) => f.concat(g), [])), c = new we(l, u), d = new we(o, a).add(c.scalarDivide(2));
    if (s === ss) {
      const f = this.getInitialSize(n, { size: c, center: d });
      return { center: d, relativeCorrection: new we(0, 0), size: f };
    }
    return { center: d.transform(r.calcOwnMatrix()), size: c };
  }
}
le(Fa, "type", "strategy");
class Rl extends Fa {
  shouldPerformLayout(e) {
    return !0;
  }
}
le(Rl, "type", "fit-content"), We.setClass(Rl);
const i4 = ["strategy"], r4 = ["target", "strategy", "bubbles", "prevStrategy"], Tf = "layoutManager";
class Pr {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Rl();
    le(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const n = ue(ue({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(n);
    const s = this.getLayoutResult(n);
    s && this.commitLayout(n, s), this.onAfterLayout(n, s), this._prevLayoutStrategy = n.strategy;
  }
  attachHandlers(e, n) {
    const { target: s } = n;
    return [Jo, Wh, kr, Uh, Ma, Nh, Zo, MT, OT].map((r) => e.on(r, (o) => this.performLayout(r === Jo ? { type: "object_modified", trigger: r, e: o, target: s } : { type: "object_modifying", trigger: r, e: o, target: s })));
  }
  subscribe(e, n) {
    this.unsubscribe(e, n);
    const s = this.attachHandlers(e, n);
    this._subscriptions.set(e, s);
  }
  unsubscribe(e, n) {
    (this._subscriptions.get(e) || []).forEach((s) => s()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((n) => this.unsubscribe(n, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((n) => this.subscribe(n, e));
  }
  onBeforeLayout(e) {
    const { target: n, type: s } = e, { canvas: r } = n;
    if (s === ss || s === ra ? this.subscribeTargets(e) : s === Tu && this.unsubscribeTargets(e), n.fire("layout:before", { context: e }), r && r.fire("object:layout:before", { target: n, context: e }), s === oa && e.deep) {
      const o = _t(e, i4);
      n.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(ue(ue({}, o), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: n, strategy: s, type: r } = e, o = s.calcLayoutResult(e, n.getObjects());
    if (!o) return;
    const a = r === ss ? new we() : n.getRelativeCenterPoint(), { center: l, correction: u = new we(), relativeCorrection: c = new we() } = o, d = a.subtract(l).add(u).transform(r === ss ? en : On(n.calcOwnMatrix()), !0).add(c);
    return { result: o, prevCenter: a, nextCenter: l, offset: d };
  }
  commitLayout(e, n) {
    const { target: s } = e, { result: { size: r }, nextCenter: o } = n;
    var a, l;
    s.set({ width: r.x, height: r.y }), this.layoutObjects(e, n), e.type === ss ? s.set({ left: (a = e.x) !== null && a !== void 0 ? a : o.x + r.x * It(s.originX), top: (l = e.y) !== null && l !== void 0 ? l : o.y + r.y * It(s.originY) }) : (s.setPositionByOrigin(o, st, st), s.setCoords(), s.set("dirty", !0));
  }
  layoutObjects(e, n) {
    const { target: s } = e;
    s.forEachObject((r) => {
      r.group === s && this.layoutObject(e, n, r);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, n, s.clipPath);
  }
  layoutObject(e, n, s) {
    let { offset: r } = n;
    s.set({ left: s.left + r.x, top: s.top + r.y });
  }
  onAfterLayout(e, n) {
    const { target: s, strategy: r, bubbles: o, prevStrategy: a } = e, l = _t(e, r4), { canvas: u } = s;
    s.fire("layout:after", { context: e, result: n }), u && u.fire("object:layout:after", { context: e, result: n, target: s });
    const c = s.parent;
    o && c != null && c.layoutManager && ((l.path || (l.path = [])).push(s), c.layoutManager.performLayout(ue(ue({}, l), {}, { target: c }))), s.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((n) => n.forEach((s) => s())), e.clear();
  }
  toObject() {
    return { type: Tf, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
We.setClass(Pr, Tf);
const o4 = ["type", "objects", "layoutManager"];
class a4 extends Pr {
  performLayout() {
  }
}
class Is extends Hh(Gt) {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Is.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), le(this, "_activeObjects", []), le(this, "__objectSelectionTracker", void 0), le(this, "__objectSelectionDisposer", void 0), Object.assign(this, Is.ownDefaults), this.setOptions(n), this.groupInit(e, n);
  }
  groupInit(e, n) {
    var s;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((r) => {
      this.enterGroup(r, !1);
    }), this.layoutManager = (s = n.layoutManager) !== null && s !== void 0 ? s : new Pr(), this.layoutManager.performLayout({ type: ss, target: this, targets: [...e], x: n.left, y: n.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (Fs("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (Fs("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((n, s, r) => this.canEnterGroup(n) && r.indexOf(n) === s);
  }
  add() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    const r = this._filterObjectsBeforeEnteringGroup(n), o = super.add(...r);
    return this._onAfterObjectsChange(ra, r), o;
  }
  insertAt(e) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r];
    const o = this._filterObjectsBeforeEnteringGroup(s), a = super.insertAt(e, ...o);
    return this._onAfterObjectsChange(ra, o), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(Tu, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, n) {
    this.exitGroup(e, n), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, n) {
    this.layoutManager.performLayout({ type: e, targets: n, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, n) {
    const s = this[e];
    return super._set(e, n), e === "canvas" && s !== n && (this._objects || []).forEach((r) => {
      r._set(e, n);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, n) {
    let { target: s } = n;
    const r = this._activeObjects;
    if (e) r.push(s), this._set("dirty", !0);
    else if (r.length > 0) {
      const o = r.indexOf(s);
      o > -1 && (r.splice(o, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, n) {
    e && this._watchObject(!1, n), e ? (n.on("selected", this.__objectSelectionTracker), n.on("deselected", this.__objectSelectionDisposer)) : (n.off("selected", this.__objectSelectionTracker), n.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, n) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, n);
  }
  _enterGroup(e, n) {
    n && ta(e, Wt(On(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const s = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    s && (s === e || e.isDescendantOf(s)) && this._activeObjects.push(e);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, n) {
    e._set("group", void 0), n || (ta(e, Wt(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const s = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    s > -1 && this._activeObjects.splice(s, 1);
  }
  shouldCache() {
    const e = Gt.prototype.shouldCache.call(this);
    if (e) {
      for (let n = 0; n < this._objects.length; n++) if (this._objects[n].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, n, s) {
    this._renderBackground(e);
    for (let o = 0; o < this._objects.length; o++) {
      var r;
      const a = this._objects[o];
      (r = this.canvas) !== null && r !== void 0 && r.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...On(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, s);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(ue({ target: this, type: oa }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, n) {
    const s = this.includeDefaultValues;
    return this._objects.filter(function(r) {
      return !r.excludeFromExport;
    }).map(function(r) {
      const o = r.includeDefaultValues;
      r.includeDefaultValues = s;
      const a = r[e || "toObject"](n);
      return r.includeDefaultValues = o, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.layoutManager.toObject();
    return ue(ue(ue({}, super.toObject(["subTargetCheck", "interactive", ...e])), n.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: n } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const n = At.prototype._toSVG.call(this), s = n.indexOf("COMMON_PARTS");
    n[s] = 'for="group" ';
    const r = n.join("");
    return e ? e(r) : r;
  }
  _toSVG(e) {
    const n = ["<g ", "COMMON_PARTS", ` >
`], s = this._createSVGBgRect(e);
    s && n.push("		", s);
    for (let r = 0; r < this._objects.length; r++) n.push("		", this._objects[r].toSVG(e));
    return n.push(`</g>
`), n;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", n = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), n].join("");
  }
  toClipPathSVG(e) {
    const n = [], s = this._createSVGBgRect(e);
    s && n.push("	", s);
    for (let r = 0; r < this._objects.length; r++) n.push("	", this._objects[r].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(n, { reviver: e });
  }
  static fromObject(e, n) {
    let { type: s, objects: r = [], layoutManager: o } = e, a = _t(e, o4);
    return Promise.all([Tr(r, n), Pa(a, n)]).then((l) => {
      let [u, c] = l;
      const d = new this(u, ue(ue(ue({}, a), c), {}, { layoutManager: new a4() }));
      if (o) {
        const f = We.getClass(o.type), g = We.getClass(o.strategy);
        d.layoutManager = new f(new g());
      } else d.layoutManager = new Pr();
      return d.layoutManager.subscribeTargets({ type: ss, target: d, targets: d.getObjects() }), d.setCoords(), d;
    });
  }
}
le(Is, "type", "Group"), le(Is, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), We.setClass(Is);
const l4 = (i, e) => Math.min(e.width / i.width, e.height / i.height), u4 = (i, e) => Math.max(e.width / i.width, e.height / i.height), Vl = "\\s*,?\\s*", Xi = "".concat(Vl, "(").concat(En, ")"), c4 = "".concat(Xi).concat(Xi).concat(Xi).concat(Vl, "([01])").concat(Vl, "([01])").concat(Xi).concat(Xi), d4 = { m: "l", M: "L" }, h4 = (i, e, n, s, r, o, a, l, u, c, d) => {
  const f = ps(i), g = ms(i), p = ps(e), y = ms(e), v = n * r * p - s * o * y + a, m = s * r * p + n * o * y + l;
  return ["C", c + u * (-n * r * g - s * o * f), d + u * (-s * r * g + n * o * f), v + u * (n * r * y + s * o * p), m + u * (s * r * y - n * o * p), v, m];
}, td = (i, e, n, s) => {
  const r = Math.atan2(e, i), o = Math.atan2(s, n);
  return o >= r ? o - r : 2 * Math.PI - (r - o);
};
function nd(i, e, n, s, r, o, a, l) {
  let u;
  if (at.cachesBoundsOfCurve && (u = [...arguments].join(), cr.boundsOfCurveCache[u])) return cr.boundsOfCurveCache[u];
  const c = Math.sqrt, d = Math.abs, f = [], g = [[0, 0], [0, 0]];
  let p = 6 * i - 12 * n + 6 * r, y = -3 * i + 9 * n - 9 * r + 3 * a, v = 3 * n - 3 * i;
  for (let _ = 0; _ < 2; ++_) {
    if (_ > 0 && (p = 6 * e - 12 * s + 6 * o, y = -3 * e + 9 * s - 9 * o + 3 * l, v = 3 * s - 3 * e), d(y) < 1e-12) {
      if (d(p) < 1e-12) continue;
      const F = -v / p;
      0 < F && F < 1 && f.push(F);
      continue;
    }
    const C = p * p - 4 * v * y;
    if (C < 0) continue;
    const k = c(C), M = (-p + k) / (2 * y);
    0 < M && M < 1 && f.push(M);
    const O = (-p - k) / (2 * y);
    0 < O && O < 1 && f.push(O);
  }
  let m = f.length;
  const b = m, S = Mf(i, e, n, s, r, o, a, l);
  for (; m--; ) {
    const { x: _, y: C } = S(f[m]);
    g[0][m] = _, g[1][m] = C;
  }
  g[0][b] = i, g[1][b] = e, g[0][b + 1] = a, g[1][b + 1] = l;
  const x = [new we(Math.min(...g[0]), Math.min(...g[1])), new we(Math.max(...g[0]), Math.max(...g[1]))];
  return at.cachesBoundsOfCurve && (cr.boundsOfCurveCache[u] = x), x;
}
const f4 = (i, e, n) => {
  let [s, r, o, a, l, u, c, d] = n;
  const f = ((g, p, y, v, m, b, S) => {
    if (y === 0 || v === 0) return [];
    let x = 0, _ = 0, C = 0;
    const k = Math.PI, M = S * uu, O = ms(M), F = ps(M), $ = 0.5 * (-F * g - O * p), ne = 0.5 * (-F * p + O * g), oe = y ** 2, z = v ** 2, X = ne ** 2, T = $ ** 2, H = oe * z - oe * X - z * T;
    let ge = Math.abs(y), K = Math.abs(v);
    if (H < 0) {
      const D = Math.sqrt(1 - H / (oe * z));
      ge *= D, K *= D;
    } else C = (m === b ? -1 : 1) * Math.sqrt(H / (oe * X + z * T));
    const re = C * ge * ne / K, ie = -C * K * $ / ge, be = F * re - O * ie + 0.5 * g, J = O * re + F * ie + 0.5 * p;
    let ee = td(1, 0, ($ - re) / ge, (ne - ie) / K), ve = td(($ - re) / ge, (ne - ie) / K, (-$ - re) / ge, (-ne - ie) / K);
    b === 0 && ve > 0 ? ve -= 2 * k : b === 1 && ve < 0 && (ve += 2 * k);
    const G = Math.ceil(Math.abs(ve / k * 2)), N = [], te = ve / G, fe = 8 / 3 * Math.sin(te / 4) * Math.sin(te / 4) / Math.sin(te / 2);
    let ae = ee + te;
    for (let D = 0; D < G; D++) N[D] = h4(ee, ae, F, O, ge, K, be, J, fe, x, _), x = N[D][5], _ = N[D][6], ee = ae, ae += te;
    return N;
  })(c - i, d - e, r, o, l, u, a);
  for (let g = 0, p = f.length; g < p; g++) f[g][1] += i, f[g][2] += e, f[g][3] += i, f[g][4] += e, f[g][5] += i, f[g][6] += e;
  return f;
}, p4 = (i) => {
  let e = 0, n = 0, s = 0, r = 0;
  const o = [];
  let a, l = 0, u = 0;
  for (const c of i) {
    const d = [...c];
    let f;
    switch (d[0]) {
      case "l":
        d[1] += e, d[2] += n;
      case "L":
        e = d[1], n = d[2], f = ["L", e, n];
        break;
      case "h":
        d[1] += e;
      case "H":
        e = d[1], f = ["L", e, n];
        break;
      case "v":
        d[1] += n;
      case "V":
        n = d[1], f = ["L", e, n];
        break;
      case "m":
        d[1] += e, d[2] += n;
      case "M":
        e = d[1], n = d[2], s = d[1], r = d[2], f = ["M", e, n];
        break;
      case "c":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n, d[5] += e, d[6] += n;
      case "C":
        l = d[3], u = d[4], e = d[5], n = d[6], f = ["C", d[1], d[2], l, u, e, n];
        break;
      case "s":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n;
      case "S":
        a === "C" ? (l = 2 * e - l, u = 2 * n - u) : (l = e, u = n), e = d[3], n = d[4], f = ["C", l, u, d[1], d[2], e, n], l = f[3], u = f[4];
        break;
      case "q":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n;
      case "Q":
        l = d[1], u = d[2], e = d[3], n = d[4], f = ["Q", l, u, e, n];
        break;
      case "t":
        d[1] += e, d[2] += n;
      case "T":
        a === "Q" ? (l = 2 * e - l, u = 2 * n - u) : (l = e, u = n), e = d[1], n = d[2], f = ["Q", l, u, e, n];
        break;
      case "a":
        d[6] += e, d[7] += n;
      case "A":
        f4(e, n, d).forEach((g) => o.push(g)), e = d[6], n = d[7];
        break;
      case "z":
      case "Z":
        e = s, n = r, f = ["Z"];
    }
    f ? (o.push(f), a = f[0]) : a = "";
  }
  return o;
}, aa = (i, e, n, s) => Math.sqrt((n - i) ** 2 + (s - e) ** 2), Mf = (i, e, n, s, r, o, a, l) => (u) => {
  const c = u ** 3, d = ((p) => 3 * p ** 2 * (1 - p))(u), f = ((p) => 3 * p * (1 - p) ** 2)(u), g = ((p) => (1 - p) ** 3)(u);
  return new we(a * c + r * d + n * f + i * g, l * c + o * d + s * f + e * g);
}, Of = (i) => i ** 2, Ef = (i) => 2 * i * (1 - i), Pf = (i) => (1 - i) ** 2, m4 = (i, e, n, s, r, o, a, l) => (u) => {
  const c = Of(u), d = Ef(u), f = Pf(u), g = 3 * (f * (n - i) + d * (r - n) + c * (a - r)), p = 3 * (f * (s - e) + d * (o - s) + c * (l - o));
  return Math.atan2(p, g);
}, g4 = (i, e, n, s, r, o) => (a) => {
  const l = Of(a), u = Ef(a), c = Pf(a);
  return new we(r * l + n * u + i * c, o * l + s * u + e * c);
}, v4 = (i, e, n, s, r, o) => (a) => {
  const l = 1 - a, u = 2 * (l * (n - i) + a * (r - n)), c = 2 * (l * (s - e) + a * (o - s));
  return Math.atan2(c, u);
}, sd = (i, e, n) => {
  let s = new we(e, n), r = 0;
  for (let o = 1; o <= 100; o += 1) {
    const a = i(o / 100);
    r += aa(s.x, s.y, a.x, a.y), s = a;
  }
  return r;
}, y4 = (i, e) => {
  let n, s = 0, r = 0, o = { x: i.x, y: i.y }, a = ue({}, o), l = 0.01, u = 0;
  const c = i.iterator, d = i.angleFinder;
  for (; r < e && l > 1e-4; ) a = c(s), u = s, n = aa(o.x, o.y, a.x, a.y), n + r > e ? (s -= l, l /= 2) : (o = a, s += l, r += n);
  return ue(ue({}, a), {}, { angle: d(u) });
}, Df = (i) => {
  let e, n, s = 0, r = 0, o = 0, a = 0, l = 0;
  const u = [];
  for (const c of i) {
    const d = { x: r, y: o, command: c[0], length: 0 };
    switch (c[0]) {
      case "M":
        n = d, n.x = a = r = c[1], n.y = l = o = c[2];
        break;
      case "L":
        n = d, n.length = aa(r, o, c[1], c[2]), r = c[1], o = c[2];
        break;
      case "C":
        e = Mf(r, o, c[1], c[2], c[3], c[4], c[5], c[6]), n = d, n.iterator = e, n.angleFinder = m4(r, o, c[1], c[2], c[3], c[4], c[5], c[6]), n.length = sd(e, r, o), r = c[5], o = c[6];
        break;
      case "Q":
        e = g4(r, o, c[1], c[2], c[3], c[4]), n = d, n.iterator = e, n.angleFinder = v4(r, o, c[1], c[2], c[3], c[4]), n.length = sd(e, r, o), r = c[3], o = c[4];
        break;
      case "Z":
        n = d, n.destX = a, n.destY = l, n.length = aa(r, o, a, l), r = a, o = l;
    }
    s += n.length, u.push(n);
  }
  return u.push({ length: s, x: r, y: o }), u;
}, b4 = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Df(i), s = 0;
  for (; e - n[s].length > 0 && s < n.length - 2; ) e -= n[s].length, s++;
  const r = n[s], o = e / r.length, a = i[s];
  switch (r.command) {
    case "M":
      return { x: r.x, y: r.y, angle: 0 };
    case "Z":
      return ue(ue({}, new we(r.x, r.y).lerp(new we(r.destX, r.destY), o)), {}, { angle: Math.atan2(r.destY - r.y, r.destX - r.x) });
    case "L":
      return ue(ue({}, new we(r.x, r.y).lerp(new we(a[1], a[2]), o)), {}, { angle: Math.atan2(a[2] - r.y, a[1] - r.x) });
    case "C":
    case "Q":
      return y4(r, e);
  }
}, x4 = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), id = new RegExp(c4, "g"), _4 = new RegExp(En, "gi"), w4 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, S4 = (i) => {
  var e;
  const n = [], s = (e = i.match(x4)) !== null && e !== void 0 ? e : [];
  for (const r of s) {
    const o = r[0];
    if (o === "z" || o === "Z") {
      n.push([o]);
      continue;
    }
    const a = w4[o.toLowerCase()];
    let l = [];
    if (o === "a" || o === "A") {
      id.lastIndex = 0;
      for (let u = null; u = id.exec(r); ) l.push(...u.slice(1));
    } else l = r.match(_4) || [];
    for (let u = 0; u < l.length; u += a) {
      const c = new Array(a), d = d4[o];
      c[0] = u > 0 && d ? d : o;
      for (let f = 0; f < a; f++) c[f + 1] = parseFloat(l[u + f]);
      n.push(c);
    }
  }
  return n;
}, C4 = (i, e) => i.map((n) => n.map((s, r) => r === 0 || e === void 0 ? s : xt(s, e)).join(" ")).join(" ");
function jl(i, e) {
  const n = i.style;
  n && e && (typeof e == "string" ? n.cssText += ";" + e : Object.entries(e).forEach((s) => {
    let [r, o] = s;
    return n.setProperty(r, o);
  }));
}
class k4 extends nf {
  constructor(e) {
    let { allowTouchScrolling: n = !1, containerClass: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), le(this, "upper", void 0), le(this, "container", void 0);
    const { el: r } = this.lower, o = this.createUpperCanvas();
    this.upper = { el: o, ctx: o.getContext("2d") }, this.applyCanvasStyle(r, { allowTouchScrolling: n }), this.applyCanvasStyle(o, { allowTouchScrolling: n, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(s), r.parentNode && r.parentNode.replaceChild(a, r), a.append(r, o), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, n = gs();
    return n.className = e.className, n.classList.remove("lower-canvas"), n.classList.add("upper-canvas"), n.setAttribute("data-fabric", "top"), n.style.cssText = e.style.cssText, n.setAttribute("draggable", "true"), n;
  }
  createContainerElement() {
    const e = Ii().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), jl(e, { position: "relative" }), Ec(e), e;
  }
  applyCanvasStyle(e, n) {
    const { styles: s, allowTouchScrolling: r } = n;
    jl(e, ue(ue({}, s), {}, { "touch-action": r ? "manipulation" : on })), Ec(e);
  }
  setDimensions(e, n) {
    super.setDimensions(e, n);
    const { el: s, ctx: r } = this.upper;
    tf(s, r, e, n);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), Dl(this.upper.el, e), Dl(this.container, e);
  }
  cleanupDOM(e) {
    const n = this.container, { el: s } = this.lower, { el: r } = this.upper;
    super.cleanupDOM(e), n.removeChild(r), n.removeChild(s), n.parentNode && n.parentNode.replaceChild(s, n);
  }
  dispose() {
    super.dispose(), Nn().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class La extends Rr {
  constructor() {
    super(...arguments), le(this, "targets", []), le(this, "_hoveredTargets", []), le(this, "_currentTransform", null), le(this, "_groupSelector", null), le(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), La.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new k4(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((n) => !n.group && n !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const n = this.getRetinaScaling(), s = Math.ceil((2 * e + 1) * n);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s, this.pixelFindContext.scale(n, n);
  }
  isTargetTransparent(e, n, s) {
    const r = this.targetFindTolerance, o = this.pixelFindContext;
    this.clearContext(o), o.save(), o.translate(-n + r, -s + r), o.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(o), e.selectionBackgroundColor = a, o.restore();
    const l = Math.round(r * this.getRetinaScaling());
    return EM(o, l, l, l);
  }
  _isSelectionKeyPressed(e) {
    const n = this.selectionKey;
    return !!n && (Array.isArray(n) ? !!n.find((s) => !!s && e[s] === !0) : e[n]);
  }
  _shouldClearSelection(e, n) {
    const s = this.getActiveObjects(), r = this._activeObject;
    return !!(!n || n && r && s.length > 1 && s.indexOf(n) === -1 && r !== n && !this._isSelectionKeyPressed(e) || n && !n.evented || n && !n.selectable && r && r !== n);
  }
  _shouldCenterTransform(e, n, s) {
    if (!e) return;
    let r;
    return n === Oa || n === ln || n === bn || n === kr ? r = this.centeredScaling || e.centeredScaling : n === hu && (r = this.centeredRotation || e.centeredRotation), r ? !s : s;
  }
  _getOriginFromCorner(e, n) {
    const s = { x: e.originX, y: e.originY };
    return n && (["ml", "tl", "bl"].includes(n) ? s.x = Et : ["mr", "tr", "br"].includes(n) && (s.x = ht), ["tl", "mt", "tr"].includes(n) ? s.y = Pl : ["bl", "mb", "br"].includes(n) && (s.y = rn)), s;
  }
  _setupCurrentTransform(e, n, s) {
    var r;
    const o = n.group ? _i(this.getScenePoint(e), void 0, n.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: l } = n.getActiveControl() || {}, u = s && l ? (r = l.getActionHandler(e, n, l)) === null || r === void 0 ? void 0 : r.bind(l) : HT, c = ((p, y, v, m) => {
      if (!y || !p) return "drag";
      const b = m.controls[y];
      return b.getActionName(v, b, m);
    })(s, a, e, n), d = e[this.centeredKey], f = this._shouldCenterTransform(n, c, d) ? { x: st, y: st } : this._getOriginFromCorner(n, a), g = { target: n, action: c, actionHandler: u, actionPerformed: !1, corner: a, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, offsetX: o.x - n.left, offsetY: o.y - n.top, originX: f.x, originY: f.y, ex: o.x, ey: o.y, lastX: o.x, lastY: o.y, theta: Pt(n.angle), width: n.width, height: n.height, shiftKey: e.shiftKey, altKey: d, original: ue(ue({}, sf(n)), {}, { originX: f.x, originY: f.y }) };
    this._currentTransform = g, this.fire("before:transform", { e, transform: g });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: n, y: s, deltaX: r, deltaY: o } = this._groupSelector, a = new we(n, s).transform(this.viewportTransform), l = new we(n + r, s + o).transform(this.viewportTransform), u = this.selectionLineWidth / 2;
    let c = Math.min(a.x, l.x), d = Math.min(a.y, l.y), f = Math.max(a.x, l.x), g = Math.max(a.y, l.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(c, d, f - c, g - d)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, c += u, d += u, f -= u, g -= u, Gt.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(c, d, f - c, g - d));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const n = this.getViewportPoint(e), s = this._activeObject, r = this.getActiveObjects();
    if (this.targets = [], s && r.length >= 1) {
      if (s.findControl(n, Al(e)) || r.length > 1 && this.searchPossibleTargets([s], n)) return s;
      if (s === this.searchPossibleTargets([s], n)) {
        if (this.preserveObjectStacking) {
          const o = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, n);
          return e[this.altSelectionKey] && a && a !== s ? (this.targets = o, s) : a;
        }
        return s;
      }
    }
    return this.searchPossibleTargets(this._objects, n);
  }
  _pointIsInObjectSelectionArea(e, n) {
    let s = e.getCoords();
    const r = this.getZoom(), o = e.padding / r;
    if (o) {
      const [a, l, u, c] = s, d = Math.atan2(l.y - a.y, l.x - a.x), f = ps(d) * o, g = ms(d) * o, p = f + g, y = f - g;
      s = [new we(a.x - y, a.y - p), new we(l.x + p, l.y - y), new we(u.x + y, u.y + p), new we(c.x - p, c.y + y)];
    }
    return Ct.isPointInPolygon(n, s);
  }
  _checkTarget(e, n) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, _i(n, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, n.x, n.y)));
  }
  _searchPossibleTargets(e, n) {
    let s = e.length;
    for (; s--; ) {
      const r = e[s];
      if (this._checkTarget(r, n)) {
        if (Do(r) && r.subTargetCheck) {
          const o = this._searchPossibleTargets(r._objects, n);
          o && this.targets.push(o);
        }
        return r;
      }
    }
  }
  searchPossibleTargets(e, n) {
    const s = this._searchPossibleTargets(e, n);
    if (s && Do(s) && s.interactive && this.targets[0]) {
      const r = this.targets;
      for (let o = r.length - 1; o > 0; o--) {
        const a = r[o];
        if (!Do(a) || !a.interactive) return a;
      }
      return r[0];
    }
    return s;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const s = this.upperCanvasEl, r = s.getBoundingClientRect();
    let o = VT(e), a = r.width || 0, l = r.height || 0;
    a && l || (rn in r && Pl in r && (l = Math.abs(r.top - r.bottom)), Et in r && ht in r && (a = Math.abs(r.right - r.left))), this.calcOffset(), o.x = o.x - this._offset.left, o.y = o.y - this._offset.top, n || (o = _i(o, void 0, this.viewportTransform));
    const u = this.getRetinaScaling();
    u !== 1 && (o.x /= u, o.y /= u);
    const c = a === 0 || l === 0 ? new we(1, 1) : new we(s.width / a, s.height / l);
    return o.multiply(c);
  }
  _setDimensionsImpl(e, n) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, n), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = gs(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return Xs(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, n) {
    let s = !1, r = !1;
    const o = this.getActiveObjects(), a = [], l = [];
    e.forEach((u) => {
      o.includes(u) || (s = !0, u.fire("deselected", { e: n, target: u }), l.push(u));
    }), o.forEach((u) => {
      e.includes(u) || (s = !0, u.fire("selected", { e: n, target: u }), a.push(u));
    }), e.length > 0 && o.length > 0 ? (r = !0, s && this.fire("selection:updated", { e: n, selected: a, deselected: l })) : o.length > 0 ? (r = !0, this.fire("selection:created", { e: n, selected: a })) : e.length > 0 && (r = !0, this.fire("selection:cleared", { e: n, deselected: l })), r && (this._objectsToRender = void 0);
  }
  setActiveObject(e, n) {
    const s = this.getActiveObjects(), r = this._setActiveObject(e, n);
    return this._fireSelectionEvents(s, n), r;
  }
  _setActiveObject(e, n) {
    const s = this._activeObject;
    return s !== e && !(!this._discardActiveObject(n, e) && this._activeObject) && !e.onSelect({ e: n }) && (this._activeObject = e, Xs(e) && s !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, n) {
    const s = this._activeObject;
    return !!s && !s.onDeselect({ e, object: n }) && (this._currentTransform && this._currentTransform.target === s && this.endCurrentTransform(e), Xs(s) && s === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const n = this.getActiveObjects(), s = this.getActiveObject();
    n.length && this.fire("before:selection:cleared", { e, deselected: [s] });
    const r = this._discardActiveObject(e);
    return this._fireSelectionEvents(n, e), r;
  }
  endCurrentTransform(e) {
    const n = this._currentTransform;
    this._finalizeCurrentTransform(e), n && n.target && (n.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const n = this._currentTransform, s = n.target, r = { e, target: s, transform: n, action: n.action };
    s._scaling && (s._scaling = !1), s.setCoords(), n.actionPerformed && (this.fire("object:modified", r), s.fire(Jo, r));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const n = this._activeObject;
    n && n.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    Xs(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const n = this._activeObject;
    n && n._renderControls(e);
  }
  _toObject(e, n, s) {
    const r = this._realizeGroupTransformOnObject(e), o = super._toObject(e, n, s);
    return e.set(r), o;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: n } = e;
    if (n && Xs(n) && this._activeObject === n) {
      const s = Ri(e, ["angle", "flipX", "flipY", ht, ln, bn, Fi, Li, rn]);
      return $T(e, n.calcOwnMatrix()), s;
    }
    return {};
  }
  _setSVGObject(e, n, s) {
    const r = this._realizeGroupTransformOnObject(n);
    super._setSVGObject(e, n, s), n.set(r);
  }
}
le(La, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class T4 {
  constructor(e) {
    le(this, "targets", []), le(this, "__disposer", void 0);
    const n = () => {
      const { hiddenTextarea: r } = e.getActiveObject() || {};
      r && r.focus();
    }, s = e.upperCanvasEl;
    s.addEventListener("click", n), this.__disposer = () => s.removeEventListener("click", n);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), ci(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var n;
    !((n = this.target) === null || n === void 0) && n.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const M4 = ["target", "oldTarget", "fireCanvas", "e"], un = { passive: !1 }, ai = (i, e) => {
  const n = i.getViewportPoint(e), s = i.getScenePoint(e);
  return { viewportPoint: n, scenePoint: s, pointer: n, absolutePointer: s };
}, ws = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return i.addEventListener(...n);
}, mn = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return i.removeEventListener(...n);
}, O4 = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class $l extends La {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), le(this, "_isClick", void 0), le(this, "textEditingManager", new T4(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((n) => {
      this[n] = this[n].bind(this);
    }), this.addOrRemove(ws, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, n) {
    const s = this.upperCanvasEl, r = this._getEventPrefix();
    e(ef(s), "resize", this._onResize), e(s, r + "down", this._onMouseDown), e(s, "".concat(r, "move"), this._onMouseMove, un), e(s, "".concat(r, "out"), this._onMouseOut), e(s, "".concat(r, "enter"), this._onMouseEnter), e(s, "wheel", this._onMouseWheel, { passive: !1 }), e(s, "contextmenu", this._onContextMenu), e(s, "click", this._onClick), e(s, "dblclick", this._onClick), e(s, "dragstart", this._onDragStart), e(s, "dragend", this._onDragEnd), e(s, "dragover", this._onDragOver), e(s, "dragenter", this._onDragEnter), e(s, "dragleave", this._onDragLeave), e(s, "drop", this._onDrop), this.enablePointerEvents || e(s, "touchstart", this._onTouchStart, un);
  }
  removeListeners() {
    this.addOrRemove(mn, "remove");
    const e = this._getEventPrefix(), n = Mn(this.upperCanvasEl);
    mn(n, "".concat(e, "up"), this._onMouseUp), mn(n, "touchend", this._onTouchEnd, un), mn(n, "".concat(e, "move"), this._onMouseMove, un), mn(n, "touchmove", this._onMouseMove, un), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const n = this._hoveredTarget, s = ue({ e }, ai(this, e));
    this.fire("mouse:out", ue(ue({}, s), {}, { target: n })), this._hoveredTarget = void 0, n && n.fire("mouseout", ue({}, s)), this._hoveredTargets.forEach((r) => {
      this.fire("mouse:out", ue(ue({}, s), {}, { target: r })), r && r.fire("mouseout", ue({}, s));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", ue({ e }, ai(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const n = this.getActiveObject();
    if (n && n.onDragStart(e)) {
      this._dragSource = n;
      const s = { e, target: n };
      return this.fire("dragstart", s), n.fire("dragstart", s), void ws(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    Pc(e);
  }
  _renderDragEffects(e, n, s) {
    let r = !1;
    const o = this._dropTarget;
    o && o !== n && o !== s && (o.clearContextTop(), r = !0), n == null || n.clearContextTop(), s !== n && (s == null || s.clearContextTop());
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), n && (a.save(), n.transform(a), n.renderDragSourceEffect(e), a.restore(), r = !0), s && (a.save(), s.transform(a), s.renderDropTargetEffect(e), a.restore(), r = !0), a.restore(), r && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const n = !!e.dataTransfer && e.dataTransfer.dropEffect !== on, s = n ? this._activeObject : void 0, r = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: n, dropTarget: s };
    mn(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", r), this._dragSource && this._dragSource.fire("dragend", r), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const n = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", n), this._dragSource && this._dragSource.fire("drag", n);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const n = "dragover", { target: s, targets: r } = this.findDragTargets(e), o = this._dragSource, a = { e, target: s, subTargets: r, dragSource: o, canDrop: !1, dropTarget: void 0 };
    let l;
    this.fire(n, a), this._fireEnterLeaveEvents(s, a), s && (s.canDrop(e) && (l = s), s.fire(n, a));
    for (let u = 0; u < r.length; u++) {
      const c = r[u];
      c.canDrop(e) && (l = c), c.fire(n, a);
    }
    this._renderDragEffects(e, o, l), this._dropTarget = l;
  }
  _onDragEnter(e) {
    const { target: n, targets: s } = this.findDragTargets(e), r = { e, target: n, subTargets: s, dragSource: this._dragSource };
    this.fire("dragenter", r), this._fireEnterLeaveEvents(n, r);
  }
  _onDragLeave(e) {
    const n = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", n), this._fireEnterLeaveEvents(void 0, n), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: n, targets: s } = this.findDragTargets(e), r = this._basicEventHandler("drop:before", ue({ e, target: n, subTargets: s, dragSource: this._dragSource }, ai(this, e)));
    r.didDrop = !1, r.dropTarget = void 0, this._basicEventHandler("drop", r), this.fire("drop:after", r);
  }
  _onContextMenu(e) {
    const n = this.findTarget(e), s = this.targets || [], r = this._basicEventHandler("contextmenu:before", { e, target: n, subTargets: s });
    return this.stopContextMenu && Pc(e), this._basicEventHandler("contextmenu", r), !1;
  }
  _onClick(e) {
    const n = e.detail;
    n > 3 || n < 2 || (this._cacheTransformEventData(e), n == 2 && e.type === "dblclick" && this._handleEvent(e, "dblclick"), n == 3 && this._handleEvent(e, "tripleclick"), this._resetTransformEventData());
  }
  getPointerId(e) {
    const n = e.changedTouches;
    return n ? n[0] && n[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let n = !this.allowTouchScrolling;
    const s = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || s && this._target === s) && (n = !0), n && e.preventDefault(), this._resetTransformEventData();
    const r = this.upperCanvasEl, o = this._getEventPrefix(), a = Mn(r);
    ws(a, "touchend", this._onTouchEnd, un), n && ws(a, "touchmove", this._onMouseMove, un), mn(r, "".concat(o, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, s = this._getEventPrefix();
    mn(n, "".concat(s, "move"), this._onMouseMove, un);
    const r = Mn(n);
    ws(r, "".concat(s, "up"), this._onMouseUp), ws(r, "".concat(s, "move"), this._onMouseMove, un);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const n = this._getEventPrefix(), s = Mn(this.upperCanvasEl);
    mn(s, "touchend", this._onTouchEnd, un), mn(s, "touchmove", this._onMouseMove, un), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      ws(this.upperCanvasEl, "".concat(n, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, s = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const r = Mn(this.upperCanvasEl);
      mn(r, "".concat(s, "up"), this._onMouseUp), mn(r, "".concat(s, "move"), this._onMouseMove, un), ws(n, "".concat(s, "move"), this._onMouseMove, un);
    }
  }
  _onMouseMove(e) {
    const n = this.getActiveObject();
    !this.allowTouchScrolling && (!n || !n.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const n = this.getActiveObject();
    return !!n != !!e || n && e && n !== e;
  }
  __onMouseUp(e) {
    var n;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const s = this._currentTransform, r = this._isClick, o = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let l, u, c = !1;
    if (s && (this._finalizeCurrentTransform(e), c = s.actionPerformed), !r) {
      const d = o === this._activeObject;
      this.handleSelection(e), c || (c = this._shouldRender(o) || !d && o === this._activeObject);
    }
    if (o) {
      const d = o.findControl(this.getViewportPoint(e), Al(e)), { key: f, control: g } = d || {};
      if (u = f, o.selectable && o !== this._activeObject && o.activeOn === "up") this.setActiveObject(o, e), c = !0;
      else if (g) {
        const p = g.getMouseUpHandler(e, o, g);
        p && (l = this.getScenePoint(e), p.call(g, e, s, l.x, l.y));
      }
      o.isMoving = !1;
    }
    if (s && (s.target !== o || s.corner !== u)) {
      const d = s.target && s.target.controls[s.corner], f = d && d.getMouseUpHandler(e, s.target, d);
      l = l || this.getScenePoint(e), f && f.call(d, e, s, l.x, l.y);
    }
    this._setCursorFromEvent(e, o), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, o && (o.__corner = void 0), c ? this.requestRenderAll() : r || (n = this._activeObject) !== null && n !== void 0 && n.isEditing || this.renderTop();
  }
  _basicEventHandler(e, n) {
    const { target: s, subTargets: r = [] } = n;
    this.fire(e, n), s && s.fire(e, n);
    for (let o = 0; o < r.length; o++) r[o] !== s && r[o].fire(e, n);
    return n;
  }
  _handleEvent(e, n, s) {
    const r = this._target, o = this.targets || [], a = ue(ue(ue({ e, target: r, subTargets: o }, ai(this, e)), {}, { transform: this._currentTransform }, n === "up:before" || n === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {}), n === "down:before" || n === "down" ? s : {});
    this.fire("mouse:".concat(n), a), r && r.fire("mouse".concat(n), a);
    for (let l = 0; l < o.length; l++) o[l] !== r && o[l].fire("mouse".concat(n), a);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const n = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(n, { e, pointer: n }), this._handleEvent(e, "down", { alreadySelected: !1 });
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const n = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(n, { e, pointer: n });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const n = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: n }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let n = this._target, s = !!n && n === this._activeObject;
    const { button: r } = e;
    if (r) return (this.fireMiddleClick && r === 1 || this.fireRightClick && r === 2) && this._handleEvent(e, "down", { alreadySelected: s }), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let o = this._shouldRender(n), a = !1;
    if (this.handleMultiSelection(e, n) ? (n = this._activeObject, a = !0, o = !0) : this._shouldClearSelection(e, n) && this.discardActiveObject(e), this.selection && (!n || !n.selectable && !n.isEditing && n !== this._activeObject)) {
      const l = this.getScenePoint(e);
      this._groupSelector = { x: l.x, y: l.y, deltaY: 0, deltaX: 0 };
    }
    if (s = !!n && n === this._activeObject, n) {
      n.selectable && n.activeOn === "down" && this.setActiveObject(n, e);
      const l = n.findControl(this.getViewportPoint(e), Al(e));
      if (n === this._activeObject && (l || !a)) {
        this._setupCurrentTransform(e, n, s);
        const u = l ? l.control : void 0, c = this.getScenePoint(e), d = u && u.getMouseDownHandler(e, n, u);
        d && d.call(u, e, this._currentTransform, c.x, c.y);
      }
    }
    o && (this._objectsToRender = void 0), this._handleEvent(e, "down", { alreadySelected: s }), o && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = _i(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const n = this._groupSelector;
    if (n) {
      const s = this.getScenePoint(e);
      n.deltaX = s.x - n.x, n.deltaY = s.y - n.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const s = this.findTarget(e);
      this._setCursorFromEvent(e, s), this._fireOverOutEvents(e, s);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, n) {
    const s = this._hoveredTarget, r = this._hoveredTargets, o = this.targets, a = Math.max(r.length, o.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: n, oldTarget: s, fireCanvas: !0 });
    for (let l = 0; l < a; l++) o[l] === n || r[l] && r[l] === s || this.fireSyntheticInOutEvents("mouse", { e, target: o[l], oldTarget: r[l] });
    this._hoveredTarget = n, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, n) {
    const s = this._draggedoverTarget, r = this._hoveredTargets, o = this.targets, a = Math.max(r.length, o.length);
    this.fireSyntheticInOutEvents("drag", ue(ue({}, n), {}, { target: e, oldTarget: s, fireCanvas: !0 }));
    for (let l = 0; l < a; l++) this.fireSyntheticInOutEvents("drag", ue(ue({}, n), {}, { target: o[l], oldTarget: r[l] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, n) {
    let { target: s, oldTarget: r, fireCanvas: o, e: a } = n, l = _t(n, M4);
    const { targetIn: u, targetOut: c, canvasIn: d, canvasOut: f } = O4[e], g = r !== s;
    if (r && g) {
      const p = ue(ue({}, l), {}, { e: a, target: r, nextTarget: s }, ai(this, a));
      o && this.fire(f, p), r.fire(c, p);
    }
    if (s && g) {
      const p = ue(ue({}, l), {}, { e: a, target: s, previousTarget: r }, ai(this, a));
      o && this.fire(d, p), s.fire(u, p);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const n = this.getScenePoint(e), s = this._currentTransform, r = s.target, o = r.group ? _i(n, void 0, r.group.calcTransformMatrix()) : n;
    s.shiftKey = e.shiftKey, s.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, s, o), s.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, n, s) {
    const { action: r, actionHandler: o, target: a } = n, l = !!o && o(e, n, s.x, s.y);
    l && a.setCoords(), r === "drag" && l && (n.target.isMoving = !0, this.setCursor(n.target.moveCursor || this.moveCursor)), n.actionPerformed = n.actionPerformed || l;
  }
  _setCursorFromEvent(e, n) {
    if (!n) return void this.setCursor(this.defaultCursor);
    let s = n.hoverCursor || this.hoverCursor;
    const r = Xs(this._activeObject) ? this._activeObject : null, o = (!r || n.group !== r) && n.findControl(this.getViewportPoint(e));
    if (o) {
      const a = o.control;
      this.setCursor(a.cursorStyleHandler(e, a, n));
    } else n.subTargetCheck && this.targets.concat().reverse().map((a) => {
      s = a.hoverCursor || s;
    }), this.setCursor(s);
  }
  handleMultiSelection(e, n) {
    const s = this._activeObject, r = Xs(s);
    if (s && this._isSelectionKeyPressed(e) && this.selection && n && n.selectable && (s !== n || r) && (r || !n.isDescendantOf(s) && !s.isDescendantOf(n)) && !n.onSelect({ e }) && !s.getActiveControl()) {
      if (r) {
        const o = s.getObjects();
        if (n === s) {
          const a = this.getViewportPoint(e);
          if (!(n = this.searchPossibleTargets(o, a) || this.searchPossibleTargets(this._objects, a)) || !n.selectable) return !1;
        }
        n.group === s ? (s.remove(n), this._hoveredTarget = n, this._hoveredTargets = [...this.targets], s.size() === 1 && this._setActiveObject(s.item(0), e)) : (s.multiSelectAdd(n), this._hoveredTarget = s, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(o, e);
      } else {
        s.isEditing && s.exitEditing();
        const o = new (We.getClass("ActiveSelection"))([], { canvas: this });
        o.multiSelectAdd(s, n), this._hoveredTarget = o, this._setActiveObject(o, e), this._fireSelectionEvents([s], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: n, y: s, deltaX: r, deltaY: o } = this._groupSelector, a = new we(n, s), l = a.add(new we(r, o)), u = a.min(l), c = a.max(l).subtract(u), d = this.collectObjects({ left: u.x, top: u.y, width: c.x, height: c.y }, { includeIntersecting: !this.selectionFullyContained }), f = a.eq(l) ? d[0] ? [d[0]] : [] : d.length > 1 ? d.filter((g) => !g.onSelect({ e })).reverse() : d;
    if (f.length === 1) this.setActiveObject(f[0], e);
    else if (f.length > 1) {
      const g = We.getClass("ActiveSelection");
      this.setActiveObject(new g(f, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const Af = { x1: 0, y1: 0, x2: 0, y2: 0 }, E4 = ue(ue({}, Af), {}, { r1: 0, r2: 0 }), fi = (i, e) => isNaN(i) && typeof e == "number" ? e : i;
function If(i) {
  return i && /%$/.test(i) && Number.isFinite(parseFloat(i));
}
function Ff(i, e) {
  const n = typeof i == "number" ? i : typeof i == "string" ? parseFloat(i) / (If(i) ? 100 : 1) : NaN;
  return Pi(0, fi(n, e), 1);
}
const P4 = /\s*;\s*/, D4 = /\s*:\s*/;
function A4(i, e) {
  let n, s;
  const r = i.getAttribute("style");
  if (r) {
    const a = r.split(P4);
    a[a.length - 1] === "" && a.pop();
    for (let l = a.length; l--; ) {
      const [u, c] = a[l].split(D4).map((d) => d.trim());
      u === "stop-color" ? n = c : u === "stop-opacity" && (s = c);
    }
  }
  const o = new ft(n || i.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: Ff(i.getAttribute("offset"), 0), color: o.toRgb(), opacity: fi(parseFloat(s || i.getAttribute("stop-opacity") || ""), 1) * o.getAlpha() * e };
}
function I4(i, e) {
  const n = [], s = i.getElementsByTagName("stop"), r = Ff(e, 1);
  for (let o = s.length; o--; ) n.push(A4(s[o], r));
  return n;
}
function Lf(i) {
  return i.nodeName === "linearGradient" || i.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function zf(i) {
  return i.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function wn(i, e) {
  return i.getAttribute(e);
}
function F4(i, e) {
  return function(n, s) {
    let r, { width: o, height: a, gradientUnits: l } = s;
    return Object.entries(n).reduce((u, c) => {
      let [d, f] = c;
      if (f === "Infinity") r = 1;
      else if (f === "-Infinity") r = 0;
      else {
        const g = typeof f == "string";
        r = g ? parseFloat(f) : f, g && If(f) && (r *= 0.01, l === "pixels" && (d !== "x1" && d !== "x2" && d !== "r2" || (r *= o), d !== "y1" && d !== "y2" || (r *= a)));
      }
      return u[d] = r, u;
    }, {});
  }(Lf(i) === "linear" ? function(n) {
    return { x1: wn(n, "x1") || 0, y1: wn(n, "y1") || 0, x2: wn(n, "x2") || "100%", y2: wn(n, "y2") || 0 };
  }(i) : function(n) {
    return { x1: wn(n, "fx") || wn(n, "cx") || "50%", y1: wn(n, "fy") || wn(n, "cy") || "50%", r1: 0, x2: wn(n, "cx") || "50%", y2: wn(n, "cy") || "50%", r2: wn(n, "r") || "50%" };
  }(i), ue(ue({}, e), {}, { gradientUnits: zf(i) }));
}
class Qr {
  constructor(e) {
    const { type: n = "linear", gradientUnits: s = "pixels", coords: r = {}, colorStops: o = [], offsetX: a = 0, offsetY: l = 0, gradientTransform: u, id: c } = e || {};
    Object.assign(this, { type: n, gradientUnits: s, coords: ue(ue({}, n === "radial" ? E4 : Af), r), colorStops: o, offsetX: a, offsetY: l, gradientTransform: u, id: c ? "".concat(c, "_").concat(Ls()) : Ls() });
  }
  addColorStop(e) {
    for (const n in e) {
      const s = new ft(e[n]);
      this.colorStops.push({ offset: parseFloat(n), color: s.toRgb(), opacity: s.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return ue(ue({}, Ri(this, e)), {}, { type: this.type, coords: ue({}, this.coords), colorStops: this.colorStops.map((n) => ue({}, n)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = [], r = this.gradientTransform ? this.gradientTransform.concat() : en.concat(), o = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((f) => ue({}, f)).sort((f, g) => f.offset - g.offset);
    let l = -this.offsetX, u = -this.offsetY;
    var c;
    o === "objectBoundingBox" ? (l /= e.width, u /= e.height) : (l += e.width / 2, u += e.height / 2), (c = e) && typeof c._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (l -= e.pathOffset.x, u -= e.pathOffset.y), r[4] -= l, r[5] -= u;
    const d = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(o, '"'), 'gradientTransform="'.concat(n ? n + " " : "").concat(Mr(r), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: f, y1: g, x2: p, y2: y } = this.coords;
      s.push("<linearGradient ", d, ' x1="', f, '" y1="', g, '" x2="', p, '" y2="', y, `">
`);
    } else if (this.type === "radial") {
      const { x1: f, y1: g, x2: p, y2: y, r1: v, r2: m } = this.coords, b = v > m;
      s.push("<radialGradient ", d, ' cx="', b ? f : p, '" cy="', b ? g : y, '" r="', b ? v : m, '" fx="', b ? p : f, '" fy="', b ? y : g, `">
`), b && (a.reverse(), a.forEach((x) => {
        x.offset = 1 - x.offset;
      }));
      const S = Math.min(v, m);
      if (S > 0) {
        const x = S / Math.max(v, m);
        a.forEach((_) => {
          _.offset += x * (1 - _.offset);
        });
      }
    }
    return a.forEach((f) => {
      let { color: g, offset: p, opacity: y } = f;
      s.push("<stop ", 'offset="', 100 * p + "%", '" style="stop-color:', g, y !== void 0 ? ";stop-opacity: " + y : ";", `"/>
`);
    }), s.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), s.join("");
  }
  toLive(e) {
    const { x1: n, y1: s, x2: r, y2: o, r1: a, r2: l } = this.coords, u = this.type === "linear" ? e.createLinearGradient(n, s, r, o) : e.createRadialGradient(n, s, a, r, o, l);
    return this.colorStops.forEach((c) => {
      let { color: d, opacity: f, offset: g } = c;
      u.addColorStop(g, f !== void 0 ? new ft(d).setAlpha(f).toRgba() : d);
    }), u;
  }
  static async fromObject(e) {
    const { colorStops: n, gradientTransform: s } = e;
    return new this(ue(ue({}, e), {}, { colorStops: n ? n.map((r) => ue({}, r)) : void 0, gradientTransform: s ? [...s] : void 0 }));
  }
  static fromElement(e, n, s) {
    const r = zf(e), o = n._findCenterFromElement();
    return new this(ue({ id: e.getAttribute("id") || void 0, type: Lf(e), coords: F4(e, { width: s.viewBoxWidth || s.width, height: s.viewBoxHeight || s.height }), colorStops: I4(e, s.opacity), gradientUnits: r, gradientTransform: zl(e.getAttribute("gradientTransform") || "") }, r === "pixels" ? { offsetX: n.width / 2 - o.x, offsetY: n.height / 2 - o.y } : { offsetX: 0, offsetY: 0 }));
  }
}
le(Qr, "type", "Gradient"), We.setClass(Qr, "gradient"), We.setClass(Qr, "linear"), We.setClass(Qr, "radial");
const L4 = ["type", "source", "patternTransform"];
class al {
  get type() {
    return "pattern";
  }
  set type(e) {
    Fs("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    le(this, "repeat", "repeat"), le(this, "offsetX", 0), le(this, "offsetY", 0), le(this, "crossOrigin", ""), this.id = Ls(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: n, crossOrigin: s } = this;
    return ue(ue({}, Ri(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: n, crossOrigin: s, offsetX: xt(this.offsetX, at.NUM_FRACTION_DIGITS), offsetY: xt(this.offsetY, at.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: n, height: s } = e;
    const { source: r, repeat: o, id: a } = this, l = fi(this.offsetX / n, 0), u = fi(this.offsetY / s, 0), c = o === "repeat-y" || o === "no-repeat" ? 1 + Math.abs(l || 0) : fi(r.width / n, 0), d = o === "repeat-x" || o === "no-repeat" ? 1 + Math.abs(u || 0) : fi(r.height / s, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(l, '" y="').concat(u, '" width="').concat(c, '" height="').concat(d, '">'), '<image x="0" y="0" width="'.concat(r.width, '" height="').concat(r.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, n) {
    let { type: s, source: r, patternTransform: o } = e, a = _t(e, L4);
    const l = await Io(r, ue(ue({}, n), {}, { crossOrigin: a.crossOrigin }));
    return new this(ue(ue({}, a), {}, { patternTransform: o && o.slice(0), source: l }));
  }
}
le(al, "type", "Pattern"), We.setClass(al), We.setClass(al, "pattern");
const z4 = ["path", "left", "top"], R4 = ["d"];
class Ds extends Gt {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: s, left: r, top: o } = n, a = _t(n, z4);
    super(), Object.assign(this, Ds.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof r == "number" && this.set(ht, r), typeof o == "number" && this.set(rn, o);
  }
  _setPath(e, n) {
    this.path = p4(Array.isArray(e) ? e : S4(e)), this.setBoundingBox(n);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new we(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const n = -this.pathOffset.x, s = -this.pathOffset.y;
    e.beginPath();
    for (const r of this.path) switch (r[0]) {
      case "L":
        e.lineTo(r[1] + n, r[2] + s);
        break;
      case "M":
        e.moveTo(r[1] + n, r[2] + s);
        break;
      case "C":
        e.bezierCurveTo(r[1] + n, r[2] + s, r[3] + n, r[4] + s, r[5] + n, r[6] + s);
        break;
      case "Q":
        e.quadraticCurveTo(r[1] + n, r[2] + s, r[3] + n, r[4] + s);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return ue(ue({}, super.toObject(e)), {}, { path: this.path.map((n) => n.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.toObject(e);
    return this.sourcePath && (delete n.path, n.sourcePath = this.sourcePath), n;
  }
  _toSVG() {
    const e = C4(this.path, at.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = at.NUM_FRACTION_DIGITS;
    return " translate(".concat(xt(-this.pathOffset.x, e), ", ").concat(xt(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const n = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  toSVG(e) {
    const n = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: n, height: s, pathOffset: r } = this._calcDimensions();
    this.set({ width: n, height: s, pathOffset: r }), e && this.setPositionByOrigin(r, st, st);
  }
  _calcBoundsFromPath() {
    const e = [];
    let n = 0, s = 0, r = 0, o = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        r = a[1], o = a[2], e.push({ x: n, y: s }, { x: r, y: o });
        break;
      case "M":
        r = a[1], o = a[2], n = r, s = o;
        break;
      case "C":
        e.push(...nd(r, o, a[1], a[2], a[3], a[4], a[5], a[6])), r = a[5], o = a[6];
        break;
      case "Q":
        e.push(...nd(r, o, a[1], a[2], a[1], a[2], a[3], a[4])), r = a[3], o = a[4];
        break;
      case "Z":
        r = n, o = s;
    }
    return ls(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return ue(ue({}, e), {}, { pathOffset: new we(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, n, s) {
    const r = xs(e, this.ATTRIBUTE_NAMES, s), { d: o } = r;
    return new this(o, ue(ue(ue({}, _t(r, R4)), n), {}, { left: void 0, top: void 0 }));
  }
}
le(Ds, "type", "Path"), le(Ds, "cacheProperties", [...bs, "path", "fillRule"]), le(Ds, "ATTRIBUTE_NAMES", [...Rs, "d"]), We.setClass(Ds), We.setSVGClass(Ds);
const V4 = ["left", "top", "radius"], Rf = ["radius", "startAngle", "endAngle", "counterClockwise"];
class Jn extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Jn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Jn.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    return super._set(e, n), e === "radius" && this.setRadius(n), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, Pt(this.startAngle), Pt(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(ln);
  }
  getRadiusY() {
    return this.get("radius") * this.get(bn);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Rf, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: n } = this, s = Pt(this.startAngle), r = Pt(this.endAngle), o = ps(s) * n, a = ms(s) * n, l = ps(r) * n, u = ms(r) * n, c = e > 180 ? 1 : 0, d = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(o, " ").concat(a, " A ").concat(n, " ").concat(n, " 0 ").concat(c, " ").concat(d, " ").concat(l, " ").concat(u, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, n, s) {
    const r = xs(e, this.ATTRIBUTE_NAMES, s), { left: o = 0, top: a = 0, radius: l = 0 } = r;
    return new this(ue(ue({}, _t(r, V4)), {}, { radius: l, left: o - l, top: a - l }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
le(Jn, "type", "Circle"), le(Jn, "cacheProperties", [...bs, ...Rf]), le(Jn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), le(Jn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Rs]), We.setClass(Jn), We.setSVGClass(Jn);
const j4 = ["x1", "y1", "x2", "y2"], $4 = ["x1", "y1", "x2", "y2"], Bl = ["x1", "x2", "y1", "y2"];
class Ys extends Gt {
  constructor() {
    let [e, n, s, r] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Ys.ownDefaults), this.setOptions(o), this.x1 = e, this.x2 = s, this.y1 = n, this.y2 = r, this._setWidthHeight();
    const { left: a, top: l } = o;
    typeof a == "number" && this.set(ht, a), typeof l == "number" && this.set(rn, l);
  }
  _setWidthHeight() {
    const { x1: e, y1: n, x2: s, y2: r } = this;
    this.width = Math.abs(s - e), this.height = Math.abs(r - n);
    const { left: o, top: a, width: l, height: u } = ls([{ x: e, y: n }, { x: s, y: r }]), c = new we(o + l / 2, a + u / 2);
    this.setPositionByOrigin(c, st, st);
  }
  _set(e, n) {
    return super._set(e, n), Bl.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const n = this.calcLinePoints();
    e.moveTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineWidth = this.strokeWidth;
    const s = e.strokeStyle;
    var r;
    vn(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (r = this.stroke) !== null && r !== void 0 ? r : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = s;
  }
  _findCenterFromElement() {
    return new we((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return ue(ue({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: n, y1: s, y2: r, width: o, height: a } = this, l = e <= n ? -1 : 1, u = s <= r ? -1 : 1;
    return { x1: l * o / 2, x2: l * -o / 2, y1: u * a / 2, y2: u * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: n, y1: s, y2: r } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(s, '" x2="').concat(n, '" y2="').concat(r, `" />
`)];
  }
  static async fromElement(e, n, s) {
    const r = xs(e, this.ATTRIBUTE_NAMES, s), { x1: o = 0, y1: a = 0, x2: l = 0, y2: u = 0 } = r;
    return new this([o, a, l, u], _t(r, j4));
  }
  static fromObject(e) {
    let { x1: n, y1: s, x2: r, y2: o } = e, a = _t(e, $4);
    return this._fromObject(ue(ue({}, a), {}, { points: [n, s, r, o] }), { extraParam: "points" });
  }
}
le(Ys, "type", "Line"), le(Ys, "cacheProperties", [...bs, ...Bl]), le(Ys, "ATTRIBUTE_NAMES", Rs.concat(Bl)), We.setClass(Ys), We.setSVGClass(Ys);
class Ks extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Ks.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Ks.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const n = this.width / 2, s = this.height / 2;
    e.beginPath(), e.moveTo(-n, s), e.lineTo(0, -s), e.lineTo(n, s), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, n = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(n, ",0 ").concat(-n, ",").concat(e, " ").concat(n), '" />'];
  }
}
le(Ks, "type", "Triangle"), le(Ks, "ownDefaults", { width: 100, height: 100 }), We.setClass(Ks), We.setSVGClass(Ks);
const Vf = ["rx", "ry"];
class Qn extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Qn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Qn.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    switch (super._set(e, n), e) {
      case "rx":
        this.rx = n, this.set("width", 2 * n);
        break;
      case "ry":
        this.ry = n, this.set("height", 2 * n);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(ln);
  }
  getRy() {
    return this.get("ry") * this.get(bn);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Vf, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, qo, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, n, s) {
    const r = xs(e, this.ATTRIBUTE_NAMES, s);
    return r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, new this(r);
  }
}
function B4(i) {
  if (!i) return [];
  const e = i.replace(/,/g, " ").trim().split(/\s+/), n = [];
  for (let s = 0; s < e.length; s += 2) n.push({ x: parseFloat(e[s]), y: parseFloat(e[s + 1]) });
  return n;
}
le(Qn, "type", "Ellipse"), le(Qn, "cacheProperties", [...bs, ...Vf]), le(Qn, "ownDefaults", { rx: 0, ry: 0 }), le(Qn, "ATTRIBUTE_NAMES", [...Rs, "cx", "cy", "rx", "ry"]), We.setClass(Qn), We.setSVGClass(Qn);
const W4 = ["left", "top"], jf = { exactBoundingBox: !1 };
class kn extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), kn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), le(this, "strokeDiff", void 0), Object.assign(this, kn.ownDefaults), this.setOptions(n), this.points = e;
    const { left: s, top: r } = n;
    this.initialized = !0, this.setBoundingBox(!0), typeof s == "number" && this.set(ht, s), typeof r == "number" && this.set(rn, r);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return DM(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = ue({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const n = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((c) => c.projectedPoint) : this.points;
    if (n.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new we(), strokeOffset: new we(), strokeDiff: new we() };
    const s = ls(n), r = Ea(ue(ue({}, e), {}, { scaleX: 1, scaleY: 1 })), o = ls(this.points.map((c) => tn(c, r, !0))), a = new we(this.scaleX, this.scaleY);
    let l = s.left + s.width / 2, u = s.top + s.height / 2;
    return this.exactBoundingBox && (l -= u * Math.tan(Pt(this.skewX)), u -= l * Math.tan(Pt(this.skewY))), ue(ue({}, s), {}, { pathOffset: new we(l, u), strokeOffset: new we(o.left, o.top).subtract(new we(s.left, s.top)).multiply(a), strokeDiff: new we(s.width, s.height).subtract(new we(o.width, o.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = ls(this.points);
    return new we(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: n, top: s, width: r, height: o, pathOffset: a, strokeOffset: l, strokeDiff: u } = this._calcDimensions();
    this.set({ width: r, height: o, pathOffset: a, strokeOffset: l, strokeDiff: u }), e && this.setPositionByOrigin(new we(n + r / 2, s + o / 2), st, st);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new we(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((l) => this.strokeUniform || this.constructor.layoutProperties.includes(l))) {
        var n, s;
        const { width: l, height: u } = this._calcDimensions(e);
        a = new we((n = e.width) !== null && n !== void 0 ? n : l, (s = e.height) !== null && s !== void 0 ? s : u);
      } else {
        var r, o;
        a = new we((r = e.width) !== null && r !== void 0 ? r : this.width, (o = e.height) !== null && o !== void 0 ? o : this.height);
      }
      return a.multiply(new we(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, n) {
    const s = this.initialized && this[e] !== n, r = super._set(e, n);
    return this.exactBoundingBox && s && ((e === ln || e === bn) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), r;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return ue(ue({}, super.toObject(e)), {}, { points: this.points.map((n) => {
      let { x: s, y: r } = n;
      return { x: s, y: r };
    }) });
  }
  _toSVG() {
    const e = [], n = this.pathOffset.x, s = this.pathOffset.y, r = at.NUM_FRACTION_DIGITS;
    for (let o = 0, a = this.points.length; o < a; o++) e.push(xt(this.points[o].x - n, r), ",", xt(this.points[o].y - s, r), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const n = this.points.length, s = this.pathOffset.x, r = this.pathOffset.y;
    if (n && !isNaN(this.points[n - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - s, this.points[0].y - r);
      for (let o = 0; o < n; o++) {
        const a = this.points[o];
        e.lineTo(a.x - s, a.y - r);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, n, s) {
    return new this(B4(e.getAttribute("points")), ue(ue({}, _t(xs(e, this.ATTRIBUTE_NAMES, s), W4)), n));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
le(kn, "ownDefaults", jf), le(kn, "type", "Polyline"), le(kn, "layoutProperties", [Fi, Li, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), le(kn, "cacheProperties", [...bs, "points"]), le(kn, "ATTRIBUTE_NAMES", [...Rs]), We.setClass(kn), We.setSVGClass(kn);
class eo extends kn {
  isOpen() {
    return !1;
  }
}
le(eo, "ownDefaults", jf), le(eo, "type", "Polygon"), We.setClass(eo), We.setSVGClass(eo);
class $f extends Gt {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const n = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const s in n) for (const r in n[s]) for (const o in n[s][r]) return !1;
    return !0;
  }
  styleHas(e, n) {
    if (!this.styles || n !== void 0 && !this.styles[n]) return !1;
    const s = n === void 0 ? this.styles : { 0: this.styles[n] };
    for (const r in s) for (const o in s[r]) if (s[r][o][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const n = this.styles;
    let s, r, o = 0, a = !0, l = 0;
    for (const u in n) {
      s = 0;
      for (const c in n[u]) {
        const d = n[u][c] || {};
        o++, d[e] !== void 0 ? (r ? d[e] !== r && (a = !1) : r = d[e], d[e] === this[e] && delete d[e]) : a = !1, Object.keys(d).length !== 0 ? s++ : delete n[u][c];
      }
      s === 0 && delete n[u];
    }
    for (let u = 0; u < this._textLines.length; u++) l += this._textLines[u].length;
    a && o === l && (this[e] = r, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const n = this.styles;
    let s, r, o;
    for (r in n) {
      for (o in s = n[r], s) delete s[o][e], Object.keys(s[o]).length === 0 && delete s[o];
      Object.keys(s).length === 0 && delete n[r];
    }
  }
  _extendStyles(e, n) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(e);
    this._getLineStyle(s) || this._setLineStyle(s);
    const o = gu(ue(ue({}, this._getStyleDeclaration(s, r)), n), (a) => a !== void 0);
    this._setStyleDeclaration(s, r, o);
  }
  getSelectionStyles(e, n, s) {
    const r = [];
    for (let o = e; o < (n || e); o++) r.push(this.getStyleAtPosition(o, s));
    return r;
  }
  getStyleAtPosition(e, n) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(e);
    return n ? this.getCompleteStyleDeclaration(s, r) : this._getStyleDeclaration(s, r);
  }
  setSelectionStyles(e, n, s) {
    for (let r = n; r < (s || n); r++) this._extendStyles(r, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, n) {
    var s;
    const r = this.styles && this.styles[e];
    return r && (s = r[n]) !== null && s !== void 0 ? s : {};
  }
  getCompleteStyleDeclaration(e, n) {
    return ue(ue({}, Ri(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, n));
  }
  _setStyleDeclaration(e, n, s) {
    this.styles[e][n] = s;
  }
  _deleteStyleDeclaration(e, n) {
    delete this.styles[e][n];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
le($f, "_styleProperties", YT);
const U4 = /  +/g, N4 = /"/g;
function ll(i, e, n, s, r) {
  return "		".concat(function(o, a) {
    let { left: l, top: u, width: c, height: d } = a, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : at.NUM_FRACTION_DIGITS;
    const g = Or(Ft, o, !1), [p, y, v, m] = [l, u, c, d].map((b) => xt(b, f));
    return "<rect ".concat(g, ' x="').concat(p, '" y="').concat(y, '" width="').concat(v, '" height="').concat(m, '"></rect>');
  }(i, { left: e, top: n, width: s, height: r }), `
`);
}
const H4 = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let ul;
class Ht extends $f {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Ht.ownDefaults);
  }
  constructor(e, n) {
    super(), le(this, "__charBounds", []), Object.assign(this, Ht.ownDefaults), this.setOptions(n), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = Df(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(jn) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, n, s, r, o, a, l;
    for (let u = 0, c = this._textLines.length; u < c; u++) if ((this.textAlign === jn || u !== c - 1 && !this.isEndOfWrapping(u)) && (r = 0, o = this._textLines[u], n = this.getLineWidth(u), n < this.width && (l = this.textLines[u].match(this._reSpacesAndTabs)))) {
      s = l.length, e = (this.width - n) / s;
      for (let d = 0; d <= o.length; d++) a = this.__charBounds[u][d], this._reSpaceAndTab.test(o[d]) ? (a.width += e, a.kernedWidth += e, a.left += r, r += e) : a.left += r;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, n) {
    const s = n ? this._unwrappedTextLines : this._textLines;
    let r;
    for (r = 0; r < s.length; r++) {
      if (e <= s[r].length) return { lineIndex: r, charIndex: e };
      e -= s[r].length + this.missingNewlineOffset(r, n);
    }
    return { lineIndex: r - 1, charIndex: s[r - 1].length < e ? s[r - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), n = this.fontSize;
    return e.width += n * e.zoomX, e.height += n * e.zoomY, e;
  }
  _render(e) {
    const n = this.path;
    n && !n.isNotVisible() && n._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === an ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, n, s) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case st:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = rn;
        break;
      case "descender":
        e.textBaseline = Pl;
    }
    e.font = this._getFontDeclaration(n, s);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let n = 1, s = this._textLines.length; n < s; n++) {
      const r = this.getLineWidth(n);
      r > e && (e = r);
    }
    return e;
  }
  _renderTextLine(e, n, s, r, o, a) {
    this._renderChars(e, n, s, r, o, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const n = e.fillStyle, s = this._getLeftOffset();
    let r = this._getTopOffset();
    for (let o = 0, a = this._textLines.length; o < a; o++) {
      const l = this.getHeightOfLine(o);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", o)) {
        r += l;
        continue;
      }
      const u = this._textLines[o].length, c = this._getLineLeftOffset(o);
      let d, f, g = 0, p = 0, y = this.getValueOfPropertyAt(o, 0, "textBackgroundColor");
      const v = this.getHeightOfLineImpl(o);
      for (let m = 0; m < u; m++) {
        const b = this.__charBounds[o][m];
        f = this.getValueOfPropertyAt(o, m, "textBackgroundColor"), this.path ? (e.save(), e.translate(b.renderLeft, b.renderTop), e.rotate(b.angle), e.fillStyle = f, f && e.fillRect(-b.width / 2, -v * (1 - this._fontSizeFraction), b.width, v), e.restore()) : f !== y ? (d = s + c + p, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = y, y && e.fillRect(d, r, g, v), p = b.left, g = b.width, y = f) : g += b.kernedWidth;
      }
      f && !this.path && (d = s + c + p, this.direction === "rtl" && (d = this.width - d - g), e.fillStyle = f, e.fillRect(d, r, g, v)), r += l;
    }
    e.fillStyle = n, this._removeShadow(e);
  }
  _measureChar(e, n, s, r) {
    const o = cr.getFontCache(n), a = this._getFontDeclaration(n), l = s + e, u = s && a === this._getFontDeclaration(r), c = n.fontSize / this.CACHE_FONT_SIZE;
    let d, f, g, p;
    if (s && o.has(s) && (g = o.get(s)), o.has(e) && (p = d = o.get(e)), u && o.has(l) && (f = o.get(l), p = f - g), d === void 0 || g === void 0 || f === void 0) {
      const y = function() {
        return ul || (ul = xn({ width: 0, height: 0 }).getContext("2d")), ul;
      }();
      this._setTextStyles(y, n, !0), d === void 0 && (p = d = y.measureText(e).width, o.set(e, d)), g === void 0 && u && s && (g = y.measureText(s).width, o.set(s, g)), u && f === void 0 && (f = y.measureText(l).width, o.set(l, f), p = f - g);
    }
    return { width: d * c, kernedWidth: p * c };
  }
  getHeightOfChar(e, n) {
    return this.getValueOfPropertyAt(e, n, "fontSize");
  }
  measureLine(e) {
    const n = this._measureLine(e);
    return this.charSpacing !== 0 && (n.width -= this._getWidthOfCharSpacing()), n.width < 0 && (n.width = 0), n;
  }
  _measureLine(e) {
    let n, s, r = 0;
    const o = this.pathSide === Et, a = this.path, l = this._textLines[e], u = l.length, c = new Array(u);
    this.__charBounds[e] = c;
    for (let d = 0; d < u; d++) {
      const f = l[d];
      s = this._getGraphemeBox(f, e, d, n), c[d] = s, r += s.kernedWidth, n = f;
    }
    if (c[u] = { left: s ? s.left + s.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let d = 0;
      const f = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case ht:
          d = o ? f - r : 0;
          break;
        case st:
          d = (f - r) / 2;
          break;
        case Et:
          d = o ? 0 : f - r;
      }
      d += this.pathStartOffset * (o ? -1 : 1);
      for (let g = o ? u - 1 : 0; o ? g >= 0 : g < u; o ? g-- : g++) s = c[g], d > f ? d %= f : d < 0 && (d += f), this._setGraphemeOnPath(d, s), d += s.kernedWidth;
    }
    return { width: r, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, n) {
    const s = e + n.kernedWidth / 2, r = this.path, o = b4(r.path, s, r.segmentsInfo);
    n.renderLeft = o.x - r.pathOffset.x, n.renderTop = o.y - r.pathOffset.y, n.angle = o.angle + (this.pathSide === Et ? Math.PI : 0);
  }
  _getGraphemeBox(e, n, s, r, o) {
    const a = this.getCompleteStyleDeclaration(n, s), l = r ? this.getCompleteStyleDeclaration(n, s - 1) : {}, u = this._measureChar(e, a, r, l);
    let c, d = u.kernedWidth, f = u.width;
    this.charSpacing !== 0 && (c = this._getWidthOfCharSpacing(), f += c, d += c);
    const g = { width: f, left: 0, height: a.fontSize, kernedWidth: d, deltaY: a.deltaY };
    if (s > 0 && !o) {
      const p = this.__charBounds[n][s - 1];
      g.left = p.left + p.width + u.kernedWidth - u.width;
    }
    return g;
  }
  getHeightOfLineImpl(e) {
    const n = this.__lineHeights;
    if (n[e]) return n[e];
    let s = this.getHeightOfChar(e, 0);
    for (let r = 1, o = this._textLines[e].length; r < o; r++) s = Math.max(this.getHeightOfChar(e, r), s);
    return n[e] = s * this._fontSizeMult;
  }
  getHeightOfLine(e) {
    return this.getHeightOfLineImpl(e) * this.lineHeight;
  }
  calcTextHeight() {
    let e = 0;
    for (let n = 0, s = this._textLines.length; n < s; n++) e += n === s - 1 ? this.getHeightOfLineImpl(n) : this.getHeightOfLine(n);
    return e;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, n) {
    e.save();
    let s = 0;
    const r = this._getLeftOffset(), o = this._getTopOffset();
    for (let a = 0, l = this._textLines.length; a < l; a++) this._renderTextLine(n, e, this._textLines[a], r + this._getLineLeftOffset(a), o + s + this.getHeightOfLineImpl(a), a), s += this.getHeightOfLine(a);
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Ft)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, n, s, r, o, a) {
    const l = this.textAlign.includes(jn), u = this.path, c = !l && this.charSpacing === 0 && this.isEmptyStyles(a) && !u, d = this.direction === "ltr", f = this.direction === "ltr" ? 1 : -1, g = n.direction;
    let p, y, v, m, b, S = "", x = 0;
    if (n.save(), g !== this.direction && (n.canvas.setAttribute("dir", d ? "ltr" : "rtl"), n.direction = d ? "ltr" : "rtl", n.textAlign = d ? ht : Et), o -= this.getHeightOfLineImpl(a) * this._fontSizeFraction, c) return this._renderChar(e, n, a, 0, s.join(""), r, o), void n.restore();
    for (let _ = 0, C = s.length - 1; _ <= C; _++) m = _ === C || this.charSpacing || u, S += s[_], v = this.__charBounds[a][_], x === 0 ? (r += f * (v.kernedWidth - v.width), x += v.width) : x += v.kernedWidth, l && !m && this._reSpaceAndTab.test(s[_]) && (m = !0), m || (p = p || this.getCompleteStyleDeclaration(a, _), y = this.getCompleteStyleDeclaration(a, _ + 1), m = Cu(p, y, !1)), m && (u ? (n.save(), n.translate(v.renderLeft, v.renderTop), n.rotate(v.angle), this._renderChar(e, n, a, _, S, -x / 2, 0), n.restore()) : (b = r, this._renderChar(e, n, a, _, S, b, o)), S = "", p = y, r += f * x, x = 0);
    n.restore();
  }
  _applyPatternGradientTransformText(e) {
    const n = this.width + this.strokeWidth, s = this.height + this.strokeWidth, r = xn({ width: n, height: s }), o = r.getContext("2d");
    return r.width = n, r.height = s, o.beginPath(), o.moveTo(0, 0), o.lineTo(n, 0), o.lineTo(n, s), o.lineTo(0, s), o.closePath(), o.translate(n / 2, s / 2), o.fillStyle = e.toLive(o), this._applyPatternGradientTransform(o, e), o.fill(), o.createPattern(r, "no-repeat");
  }
  handleFiller(e, n, s) {
    let r, o;
    return vn(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? (r = -this.width / 2, o = -this.height / 2, e.translate(r, o), e[n] = this._applyPatternGradientTransformText(s), { offsetX: r, offsetY: o }) : (e[n] = s.toLive(e), this._applyPatternGradientTransform(e, s)) : (e[n] = s, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, n) {
    let { stroke: s, strokeWidth: r } = n;
    return e.lineWidth = r, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", s);
  }
  _setFillStyles(e, n) {
    let { fill: s } = n;
    return this.handleFiller(e, "fillStyle", s);
  }
  _renderChar(e, n, s, r, o, a, l) {
    const u = this._getStyleDeclaration(s, r), c = this.getCompleteStyleDeclaration(s, r), d = e === "fillText" && c.fill, f = e === "strokeText" && c.stroke && c.strokeWidth;
    if (f || d) {
      if (n.save(), n.font = this._getFontDeclaration(c), u.textBackgroundColor && this._removeShadow(n), u.deltaY && (l += u.deltaY), d) {
        const g = this._setFillStyles(n, c);
        n.fillText(o, a - g.offsetX, l - g.offsetY);
      }
      if (f) {
        const g = this._setStrokeStyles(n, c);
        n.strokeText(o, a - g.offsetX, l - g.offsetY);
      }
      n.restore();
    }
  }
  setSuperscript(e, n) {
    this._setScript(e, n, this.superscript);
  }
  setSubscript(e, n) {
    this._setScript(e, n, this.subscript);
  }
  _setScript(e, n, s) {
    const r = this.get2DCursorLocation(e, !0), o = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "fontSize"), a = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "deltaY"), l = { fontSize: o * s.size, deltaY: a + o * s.baseline };
    this.setSelectionStyles(l, e, n);
  }
  _getLineLeftOffset(e) {
    const n = this.getLineWidth(e), s = this.width - n, r = this.textAlign, o = this.direction, a = this.isEndOfWrapping(e);
    let l = 0;
    return r === jn || r === hr && !a || r === dr && !a || r === ia && !a ? 0 : (r === st && (l = s / 2), r === Et && (l = s), r === hr && (l = s / 2), r === dr && (l = s), o === "rtl" && (r === Et || r === jn || r === dr ? l = 0 : r === ht || r === ia ? l = -s : r !== st && r !== hr || (l = -s / 2)), l);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: n } = this.measureLine(e);
    return this.__lineWidths[e] = n, n;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, n, s) {
    var r;
    return (r = this._getStyleDeclaration(e, n)[s]) !== null && r !== void 0 ? r : this[s];
  }
  _renderTextDecoration(e, n) {
    if (!this[n] && !this.styleHas(n)) return;
    let s = this._getTopOffset();
    const r = this._getLeftOffset(), o = this.path, a = this._getWidthOfCharSpacing(), l = n === "linethrough" ? 0.5 : n === "overline" ? 1 : 0, u = this.offsets[n];
    for (let c = 0, d = this._textLines.length; c < d; c++) {
      const f = this.getHeightOfLine(c);
      if (!this[n] && !this.styleHas(n, c)) {
        s += f;
        continue;
      }
      const g = this._textLines[c], p = f / this.lineHeight, y = this._getLineLeftOffset(c);
      let v = 0, m = 0, b = this.getValueOfPropertyAt(c, 0, n), S = this.getValueOfPropertyAt(c, 0, Ft), x = this.getValueOfPropertyAt(c, 0, ti), _ = b, C = S, k = x;
      const M = s + p * (1 - this._fontSizeFraction);
      let O = this.getHeightOfChar(c, 0), F = this.getValueOfPropertyAt(c, 0, "deltaY");
      for (let oe = 0, z = g.length; oe < z; oe++) {
        const X = this.__charBounds[c][oe];
        _ = this.getValueOfPropertyAt(c, oe, n), C = this.getValueOfPropertyAt(c, oe, Ft), k = this.getValueOfPropertyAt(c, oe, ti);
        const T = this.getHeightOfChar(c, oe), H = this.getValueOfPropertyAt(c, oe, "deltaY");
        if (o && _ && C) {
          const ge = this.fontSize * k / 1e3;
          e.save(), e.fillStyle = S, e.translate(X.renderLeft, X.renderTop), e.rotate(X.angle), e.fillRect(-X.kernedWidth / 2, u * T + H - l * ge, X.kernedWidth, ge), e.restore();
        } else if ((_ !== b || C !== S || T !== O || k !== x || H !== F) && m > 0) {
          const ge = this.fontSize * x / 1e3;
          let K = r + y + v;
          this.direction === "rtl" && (K = this.width - K - m), b && S && x && (e.fillStyle = S, e.fillRect(K, M + u * O + F - l * ge, m, ge)), v = X.left, m = X.width, b = _, x = k, S = C, O = T, F = H;
        } else m += X.kernedWidth;
      }
      let $ = r + y + v;
      this.direction === "rtl" && ($ = this.width - $ - m), e.fillStyle = C;
      const ne = this.fontSize * k / 1e3;
      _ && C && k && e.fillRect($, M + u * O + F - l * ne, m - a, ne), s += f;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: n = this.fontStyle, fontWeight: s = this.fontWeight, fontSize: r = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || Ht.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [n, s, "".concat(o ? this.CACHE_FONT_SIZE : r, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return Su(e);
  }
  _splitTextIntoLines(e) {
    const n = e.split(this._reNewline), s = new Array(n.length), r = [`
`];
    let o = [];
    for (let a = 0; a < n.length; a++) s[a] = this.graphemeSplit(n[a]), o = o.concat(s[a], r);
    return o.pop(), { _unwrappedLines: s, lines: n, graphemeText: o, graphemeLines: s };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return ue(ue({}, super.toObject([...ff, ...e])), {}, { styles: LM(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, n) {
    const { textLayoutProperties: s } = this.constructor;
    super.set(e, n);
    let r = !1, o = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), r = r || s.includes(a), o = o || a === "path";
    else r = s.includes(e), o = e === "path";
    return o && this.setPathInfo(), r && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, n, s) {
    const r = xs(e, Ht.ATTRIBUTE_NAMES, s), o = ue(ue({}, n), r), { textAnchor: a = ht, textDecoration: l = "", dx: u = 0, dy: c = 0, top: d = 0, left: f = 0, fontSize: g = cu, strokeWidth: p = 1 } = o, y = _t(o, H4), v = new this(sa(e.textContent || "").trim(), ue({ left: f + u, top: d + c, underline: l.includes("underline"), overline: l.includes("overline"), linethrough: l.includes("line-through"), strokeWidth: 0, fontSize: g }, y)), m = v.getScaledHeight() / v.height, b = ((v.height + v.strokeWidth) * v.lineHeight - v.height) * m, S = v.getScaledHeight() + b;
    let x = 0;
    return a === st && (x = v.getScaledWidth() / 2), a === Et && (x = v.getScaledWidth()), v.set({ left: v.left - x, top: v.top - (S - v.fontSize * (0.07 + v._fontSizeFraction)) / v.lineHeight, strokeWidth: p }), v;
  }
  static fromObject(e) {
    return this._fromObject(ue(ue({}, e), {}, { styles: zM(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
le(Ht, "textLayoutProperties", hf), le(Ht, "cacheProperties", [...bs, ...ff]), le(Ht, "ownDefaults", GT), le(Ht, "type", "Text"), le(Ht, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), le(Ht, "ATTRIBUTE_NAMES", Rs.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), wf(Ht, [class extends uf {
  _toSVG() {
    const i = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(i.textTop, i.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(i) {
    const e = this._createBaseSVGMarkup(this._toSVG(), { reviver: i, noStyle: !0, withShadow: !0 }), n = this.path;
    return n ? e + n._createBaseSVGMarkup(n._toSVG(), { reviver: i, withShadow: !0, additionalTransform: Mr(this.calcOwnMatrix()) }) : e;
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(i) {
    let { textBgRects: e, textSpans: n } = i;
    const s = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', 'font-family="'.concat(this.fontFamily.replace(N4, "'"), '" '), 'font-size="'.concat(this.fontSize, '" '), this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", s ? 'text-decoration="'.concat(s, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", n.join(""), `</text>
`];
  }
  _getSVGTextAndBg(i, e) {
    const n = [], s = [];
    let r, o = i;
    this.backgroundColor && s.push(...ll(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, l = this._textLines.length; a < l; a++) r = this._getLineLeftOffset(a), this.direction === "rtl" && (r += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(s, a, e + r, o), this._setSVGTextLineText(n, a, e + r, o), o += this.getHeightOfLine(a);
    return { textSpans: n, textBgRects: s };
  }
  _createTextCharSpan(i, e, n, s, r) {
    const o = at.NUM_FRACTION_DIGITS, a = this.getSvgSpanStyles(e, i !== i.trim() || !!i.match(U4)), l = a ? 'style="'.concat(a, '"') : "", u = e.deltaY, c = u ? ' dy="'.concat(xt(u, o), '" ') : "", { angle: d, renderLeft: f, renderTop: g, width: p } = r;
    let y = "";
    if (f !== void 0) {
      const v = p / 2;
      d && (y = ' rotate="'.concat(xt(vs(d), o), '"'));
      const m = zi({ angle: vs(d) });
      m[4] = f, m[5] = g;
      const b = new we(-v, 0).transform(m);
      n = b.x, s = b.y;
    }
    return '<tspan x="'.concat(xt(n, o), '" y="').concat(xt(s, o), '" ').concat(c).concat(y).concat(l, ">").concat(AM(i), "</tspan>");
  }
  _setSVGTextLineText(i, e, n, s) {
    const r = this.getHeightOfLine(e), o = this.textAlign.includes(jn), a = this._textLines[e];
    let l, u, c, d, f, g = "", p = 0;
    s += r * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let y = 0, v = a.length - 1; y <= v; y++) f = y === v || this.charSpacing || this.path, g += a[y], c = this.__charBounds[e][y], p === 0 ? (n += c.kernedWidth - c.width, p += c.width) : p += c.kernedWidth, o && !f && this._reSpaceAndTab.test(a[y]) && (f = !0), f || (l = l || this.getCompleteStyleDeclaration(e, y), u = this.getCompleteStyleDeclaration(e, y + 1), f = Cu(l, u, !0)), f && (d = this._getStyleDeclaration(e, y), i.push(this._createTextCharSpan(g, d, n, s, c)), g = "", l = u, this.direction === "rtl" ? n -= p : n += p, p = 0);
  }
  _setSVGTextLineBg(i, e, n, s) {
    const r = this._textLines[e], o = this.getHeightOfLine(e) / this.lineHeight;
    let a, l = 0, u = 0, c = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let d = 0; d < r.length; d++) {
      const { left: f, width: g, kernedWidth: p } = this.__charBounds[e][d];
      a = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), a !== c ? (c && i.push(...ll(c, n + u, s, l, o)), u = f, l = g, c = a) : l += p;
    }
    a && i.push(...ll(c, n + u, s, l, o));
  }
  _getSVGLineTopOffset(i) {
    let e, n = 0;
    for (e = 0; e < i; e++) n += this.getHeightOfLine(e);
    const s = this.getHeightOfLine(e);
    return { lineTop: n, offset: (this._fontSizeMult - this._fontSizeFraction) * s / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(i) {
    return "".concat(super.getSvgStyles(i), " text-decoration-thickness: ").concat(xt(this.textDecorationThickness * this.getObjectScaling().y / 10, at.NUM_FRACTION_DIGITS), "%; white-space: pre;");
  }
  getSvgSpanStyles(i, e) {
    const { fontFamily: n, strokeWidth: s, stroke: r, fill: o, fontSize: a, fontStyle: l, fontWeight: u, deltaY: c, textDecorationThickness: d, linethrough: f, overline: g, underline: p } = i, y = this.getSvgTextDecoration({ underline: p ?? this.underline, overline: g ?? this.overline, linethrough: f ?? this.linethrough }), v = d || this.textDecorationThickness;
    return [r ? Or(an, r) : "", s ? "stroke-width: ".concat(s, "; ") : "", n ? "font-family: ".concat(n.includes("'") || n.includes('"') ? n : "'".concat(n, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", l ? "font-style: ".concat(l, "; ") : "", u ? "font-weight: ".concat(u, "; ") : "", y ? "text-decoration: ".concat(y, "; text-decoration-thickness: ").concat(xt(v * this.getObjectScaling().y / 10, at.NUM_FRACTION_DIGITS), "%; ") : "", o ? Or(Ft, o) : "", c ? "baseline-shift: ".concat(-c, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(i) {
    return ["overline", "underline", "line-through"].filter((e) => i[e.replace("-", "")]).join(" ");
  }
}]), We.setClass(Ht), We.setSVGClass(Ht);
class X4 {
  constructor(e) {
    le(this, "target", void 0), le(this, "__mouseDownInPlace", !1), le(this, "__dragStartFired", !1), le(this, "__isDraggingOver", !1), le(this, "__dragStartSelection", void 0), le(this, "__dragImageDisposer", void 0), le(this, "_dispose", void 0), this.target = e;
    const n = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      n.forEach((s) => s()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const n = this.target, s = n.getSelectionStartFromPointer(e);
    return n.isEditing && s >= n.selectionStart && s <= n.selectionEnd && n.selectionStart < n.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const n = this.isActive();
    return n && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, n;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, n) {
    var s;
    let { selectionStart: r, selectionEnd: o } = n;
    const a = this.target, l = a.canvas, u = new we(a.flipX ? -1 : 1, a.flipY ? -1 : 1), c = a._getCursorBoundaries(r), d = new we(c.left + c.leftOffset, c.top + c.topOffset).multiply(u).transform(a.calcTransformMatrix()), f = l.getScenePoint(e).subtract(d), g = a.getCanvasRetinaScaling(), p = a.getBoundingRect(), y = d.subtract(new we(p.left, p.top)), v = l.viewportTransform, m = y.add(f).transform(v, !0), b = a.backgroundColor, S = wu(a.styles);
    a.backgroundColor = "";
    const x = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(x, 0, r), a.setSelectionStyles(x, o, a.text.length), a.dirty = !0;
    const _ = a.toCanvasElement({ enableRetinaScaling: l.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = b, a.styles = S, a.dirty = !0, jl(_, { position: "fixed", left: "".concat(-_.width, "px"), border: on, width: "".concat(_.width / g, "px"), height: "".concat(_.height / g, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      _.remove();
    }, Mn(e.target || this.target.hiddenTextarea).body.appendChild(_), (s = e.dataTransfer) === null || s === void 0 || s.setDragImage(_, m.x, m.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const n = this.target, s = this.isActive();
    if (s && e.dataTransfer) {
      const r = this.__dragStartSelection = { selectionStart: n.selectionStart, selectionEnd: n.selectionEnd }, o = n._text.slice(r.selectionStart, r.selectionEnd).join(""), a = ue({ text: n.text, value: o }, r);
      e.dataTransfer.setData("text/plain", o), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: o, styles: n.getSelectionStyles(r.selectionStart, r.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return n.abortCursorAnimation(), s;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const n = this.target.getSelectionStartFromPointer(e), s = this.__dragStartSelection;
        return n < s.selectionStart || n > s.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: n } = e;
    const s = this.targetCanDrop(n);
    !this.__isDraggingOver && s && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: n } = e, s = this.targetCanDrop(n);
    !this.__isDraggingOver && s ? this.__isDraggingOver = !0 : this.__isDraggingOver && !s && (this.__isDraggingOver = !1), this.__isDraggingOver && (n.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var n;
    const { e: s } = e, r = s.defaultPrevented;
    this.__isDraggingOver = !1, s.preventDefault();
    let o = (n = s.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain");
    if (o && !r) {
      const a = this.target, l = a.canvas;
      let u = a.getSelectionStartFromPointer(s);
      const { styles: c } = s.dataTransfer.types.includes("application/fabric") ? JSON.parse(s.dataTransfer.getData("application/fabric")) : {}, d = o[Math.max(0, o.length - 1)], f = 0;
      if (this.__dragStartSelection) {
        const g = this.__dragStartSelection.selectionStart, p = this.__dragStartSelection.selectionEnd;
        u > g && u <= p ? u = g : u > p && (u -= p - g), a.removeChars(g, p), delete this.__dragStartSelection;
      }
      a._reNewline.test(d) && (a._reNewline.test(a._text[u]) || u === a._text.length) && (o = o.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(o, c, u), l.setActiveObject(a), a.enterEditing(s), a.selectionStart = Math.min(u + f, a._text.length), a.selectionEnd = Math.min(a.selectionStart + o.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(Zo, { index: u + f, action: "drop" }), l.fire("text:changed", { target: a }), l.contextTopDirty = !0, l.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: n } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var s;
      const r = this.target, o = this.target.canvas, { selectionStart: a, selectionEnd: l } = this.__dragStartSelection, u = ((s = n.dataTransfer) === null || s === void 0 ? void 0 : s.dropEffect) || on;
      u === on ? (r.selectionStart = a, r.selectionEnd = l, r._updateTextarea(), r.hiddenTextarea.focus()) : (r.clearContextTop(), u === "move" && (r.removeChars(a, l), r.selectionStart = r.selectionEnd = a, r.hiddenTextarea && (r.hiddenTextarea.value = r.text), r._updateTextarea(), r.fire(Zo, { index: a, action: "dragend" }), o.fire("text:changed", { target: r }), o.requestRenderAll()), r.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const rd = /[ \n\.,;!\?\-]/;
class Y4 extends Ht {
  constructor() {
    super(...arguments), le(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: n, duration: s, delay: r, onComplete: o } = e;
    return vf({ startValue: this._currentCursorOpacity, endValue: n, duration: s, delay: r, onComplete: o, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((n) => {
      n && !n.isDone() && (e = !0, n.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  cmdAll() {
    this.selectAll(), this.renderCursorOrSelection();
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let n = 0, s = e - 1;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) n++, s--;
    for (; /\S/.test(this._text[s]) && s > -1; ) n++, s--;
    return e - n;
  }
  findWordBoundaryRight(e) {
    let n = 0, s = e;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) n++, s++;
    for (; /\S/.test(this._text[s]) && s < this._text.length; ) n++, s++;
    return e + n;
  }
  findLineBoundaryLeft(e) {
    let n = 0, s = e - 1;
    for (; !/\n/.test(this._text[s]) && s > -1; ) n++, s--;
    return e - n;
  }
  findLineBoundaryRight(e) {
    let n = 0, s = e;
    for (; !/\n/.test(this._text[s]) && s < this._text.length; ) n++, s++;
    return e + n;
  }
  searchWordBoundary(e, n) {
    const s = this._text;
    let r = e > 0 && this._reSpace.test(s[e]) && (n === -1 || !du.test(s[e - 1])) ? e - 1 : e, o = s[r];
    for (; r > 0 && r < s.length && !rd.test(o); ) r += n, o = s[r];
    return n === -1 && rd.test(o) && r++, r;
  }
  selectWord(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const s = this.searchWordBoundary(e, -1), r = Math.max(s, this.searchWordBoundary(e, 1));
    this.selectionStart = s, this.selectionEnd = r, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const s = this.findLineBoundaryLeft(e), r = this.findLineBoundaryRight(e);
    this.selectionStart = s, this.selectionEnd = r, this._fireSelectionChanged(), this._updateTextarea();
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const n = this.hiddenTextarea;
    Mn(n).activeElement !== n && n.focus();
    const s = this.getSelectionStartFromPointer(e), r = this.selectionStart, o = this.selectionEnd;
    (s === this.__selectionStartOnMouseDown && r !== o || r !== s && o !== s) && (s > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s) : (this.selectionStart = s, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === r && this.selectionEnd === o || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, n, s) {
    const r = s.slice(0, e), o = this.graphemeSplit(r).length;
    if (e === n) return { selectionStart: o, selectionEnd: o };
    const a = s.slice(e, n);
    return { selectionStart: o, selectionEnd: o + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, n, s) {
    const r = s.slice(0, e).join("").length;
    return e === n ? { selectionStart: r, selectionEnd: r } : { selectionStart: r, selectionEnd: r + s.slice(e, n).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const n = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = n.selectionEnd, this.inCompositionMode || (this.selectionStart = n.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, n = this._getCursorBoundaries(e), s = this.get2DCursorLocation(e), r = s.lineIndex, o = s.charIndex, a = this.getValueOfPropertyAt(r, o, "fontSize") * this.lineHeight, l = n.leftOffset, u = this.getCanvasRetinaScaling(), c = this.canvas.upperCanvasEl, d = c.width / u, f = c.height / u, g = d - a, p = f - a, y = new we(n.left + l, n.top + n.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new we(c.clientWidth / d, c.clientHeight / f));
    return y.x < 0 && (y.x = 0), y.x > g && (y.x = g), y.y < 0 && (y.y = 0), y.y > p && (y.y = p), y.x += this.canvas._offset.left, y.y += this.canvas._offset.top, { left: "".concat(y.x, "px"), top: "".concat(y.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(Jo), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, n) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(e, !0), { lineIndex: o, charIndex: a } = this.get2DCursorLocation(n, !0);
    if (s !== o) {
      if (this.styles[s]) for (let l = r; l < this._unwrappedTextLines[s].length; l++) delete this.styles[s][l];
      if (this.styles[o]) for (let l = a; l < this._unwrappedTextLines[o].length; l++) {
        const u = this.styles[o][l];
        u && (this.styles[s] || (this.styles[s] = {}), this.styles[s][r + l - a] = u);
      }
      for (let l = s + 1; l <= o; l++) delete this.styles[l];
      this.shiftLineStyles(o, s - o);
    } else if (this.styles[s]) {
      const l = this.styles[s], u = a - r;
      for (let c = r; c < a; c++) delete l[c];
      for (const c in this.styles[s]) {
        const d = parseInt(c, 10);
        d >= a && (l[d - u] = l[c], delete l[c]);
      }
    }
  }
  shiftLineStyles(e, n) {
    const s = Object.assign({}, this.styles);
    for (const r in this.styles) {
      const o = parseInt(r, 10);
      o > e && (this.styles[o + n] = s[o], s[o - n] || delete this.styles[o]);
    }
  }
  insertNewlineStyleObject(e, n, s, r) {
    const o = {}, a = this._unwrappedTextLines[e].length, l = a === n;
    let u = !1;
    s || (s = 1), this.shiftLineStyles(e, s);
    const c = this.styles[e] ? this.styles[e][n === 0 ? n : n - 1] : void 0;
    for (const f in this.styles[e]) {
      const g = parseInt(f, 10);
      g >= n && (u = !0, o[g - n] = this.styles[e][f], l && n === 0 || delete this.styles[e][f]);
    }
    let d = !1;
    for (u && !l && (this.styles[e + s] = o, d = !0), (d || a > n) && s--; s > 0; ) r && r[s - 1] ? this.styles[e + s] = { 0: ue({}, r[s - 1]) } : c ? this.styles[e + s] = { 0: ue({}, c) } : delete this.styles[e + s], s--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, n, s, r) {
    this.styles || (this.styles = {});
    const o = this.styles[e], a = o ? ue({}, o) : {};
    s || (s = 1);
    for (const u in a) {
      const c = parseInt(u, 10);
      c >= n && (o[c + s] = a[c], a[c - s] || delete o[c]);
    }
    if (this._forceClearCache = !0, r) {
      for (; s--; ) Object.keys(r[s]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][n + s] = ue({}, r[s]));
      return;
    }
    if (!o) return;
    const l = o[n ? n - 1 : 1];
    for (; l && s--; ) this.styles[e][n + s] = ue({}, l);
  }
  insertNewStyleBlock(e, n, s) {
    const r = this.get2DCursorLocation(n, !0), o = [0];
    let a, l = 0;
    for (let u = 0; u < e.length; u++) e[u] === `
` ? (l++, o[l] = 0) : o[l]++;
    for (o[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, o[0], s), s = s && s.slice(o[0] + 1)), l && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + o[0], l), a = 1; a < l; a++) o[a] > 0 ? this.insertCharStyleObject(r.lineIndex + a, 0, o[a], s) : s && this.styles[r.lineIndex + a] && s[0] && (this.styles[r.lineIndex + a][0] = s[0]), s = s && s.slice(o[a] + 1);
    o[a] > 0 && this.insertCharStyleObject(r.lineIndex + a, 0, o[a], s);
  }
  removeChars(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, n), this._text.splice(e, n - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, n, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : s;
    r > s && this.removeStyleFromTo(s, r);
    const o = this.graphemeSplit(e);
    this.insertNewStyleBlock(o, s, n), this._text = [...this._text.slice(0, s), ...o, ...this._text.slice(r)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, n, s) {
    s <= e ? (n === e ? this._selectionDirection = ht : this._selectionDirection === Et && (this._selectionDirection = ht, this.selectionEnd = e), this.selectionStart = s) : s > e && s < n ? this._selectionDirection === Et ? this.selectionEnd = s : this.selectionStart = s : (n === e ? this._selectionDirection = Et : this._selectionDirection === ht && (this._selectionDirection = Et, this.selectionStart = n), this.selectionEnd = s);
  }
}
class G4 extends Y4 {
  initHiddenTextarea() {
    const e = this.canvas && Mn(this.canvas.getElement()) || Ii(), n = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off", name: "fabricTextarea" }).map((a) => {
      let [l, u] = a;
      return n.setAttribute(l, u);
    });
    const { top: s, left: r, fontSize: o } = this._calcTextareaPosition();
    n.style.cssText = "position: absolute; top: ".concat(s, "; left: ").concat(r, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(o, ";"), (this.hiddenTextareaContainer || e.body).appendChild(n), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [l, u] = a;
      return n.addEventListener(l, this[u].bind(this));
    }), this.hiddenTextarea = n;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const n = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in n) this[n[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const n = this.fromPaste, { value: s, selectionStart: r, selectionEnd: o } = this.hiddenTextarea;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const a = () => {
      this.updateFromTextArea(), this.fire(Zo), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void a();
    const l = this._splitTextIntoLines(s).graphemeText, u = this._text.length, c = l.length, d = this.selectionStart, f = this.selectionEnd, g = d !== f;
    let p, y, v, m, b = c - u;
    const S = this.fromStringToGraphemeSelection(r, o, s), x = d > S.selectionStart;
    g ? (y = this._text.slice(d, f), b += f - d) : c < u && (y = x ? this._text.slice(f + b, f) : this._text.slice(d, d - b));
    const _ = l.slice(S.selectionEnd - b, S.selectionEnd);
    if (y && y.length && (_.length && (p = this.getSelectionStyles(d, d + 1, !1), p = _.map(() => p[0])), g ? (v = d, m = f) : x ? (v = f - y.length, m = f) : (v = f, m = f + y.length), this.removeStyleFromTo(v, m)), _.length) {
      const { copyPasteData: C } = Nn();
      n && _.join("") === C.copiedText && !at.disableStyleCopyPaste && (p = C.copiedTextStyle), this.insertNewStyleBlock(_, d, p);
    }
    a();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: n } = e;
    const { selectionStart: s, selectionEnd: r } = n;
    this.compositionStart = s, this.compositionEnd = r, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = Nn();
    e.copiedText = this.getSelectedText(), at.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, n) {
    let s, r = this._getLineLeftOffset(e);
    return n > 0 && (s = this.__charBounds[e][n - 1], r += s.left + s.width), r;
  }
  getDownCursorOffset(e, n) {
    const s = this._getSelectionForOffset(e, n), r = this.get2DCursorLocation(s), o = r.lineIndex;
    if (o === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - s;
    const a = r.charIndex, l = this._getWidthBeforeCursor(o, a), u = this._getIndexOnLine(o + 1, l);
    return this._textLines[o].slice(a).length + u + 1 + this.missingNewlineOffset(o);
  }
  _getSelectionForOffset(e, n) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && n ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, n) {
    const s = this._getSelectionForOffset(e, n), r = this.get2DCursorLocation(s), o = r.lineIndex;
    if (o === 0 || e.metaKey || e.keyCode === 33) return -s;
    const a = r.charIndex, l = this._getWidthBeforeCursor(o, a), u = this._getIndexOnLine(o - 1, l), c = this._textLines[o].slice(0, a), d = this.missingNewlineOffset(o - 1);
    return -this._textLines[o - 1].length + u - c.length + (1 - d);
  }
  _getIndexOnLine(e, n) {
    const s = this._textLines[e];
    let r, o, a = this._getLineLeftOffset(e), l = 0;
    for (let u = 0, c = s.length; u < c; u++) if (r = this.__charBounds[e][u].width, a += r, a > n) {
      o = !0;
      const d = a - r, f = a, g = Math.abs(d - n);
      l = Math.abs(f - n) < g ? u : u - 1;
      break;
    }
    return o || (l = s.length - 1), l;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, n) {
    const s = this["get".concat(e, "CursorOffset")](n, this._selectionDirection === Et);
    if (n.shiftKey ? this.moveCursorWithShift(s) : this.moveCursorWithoutShift(s), s !== 0) {
      const r = this.text.length;
      this.selectionStart = Pi(0, this.selectionStart, r), this.selectionEnd = Pi(0, this.selectionEnd, r), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const n = this._selectionDirection === ht ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, n), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, n, s) {
    let r;
    if (e.altKey) r = this["findWordBoundary".concat(s)](this[n]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[n] += s === "Left" ? -1 : 1, !0;
      r = this["findLineBoundary".concat(s)](this[n]);
    }
    return r !== void 0 && this[n] !== r && (this[n] = r, !0);
  }
  _moveLeft(e, n) {
    return this._move(e, n, "Left");
  }
  _moveRight(e, n) {
    return this._move(e, n, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = ht, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (n = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, n;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === Et && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = ht, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, n) {
    const s = "moveCursor".concat(e).concat(n.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[s](n) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === ht && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Et, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = Et, this.selectionStart === this.selectionEnd ? (n = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, n;
  }
}
const od = (i) => !!i.button;
class K4 extends G4 {
  constructor() {
    super(...arguments), le(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("mousetripleclick", this.tripleClickHandler), this.draggableTextDelegate = new X4(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  doubleClickHandler(e) {
    this.isEditing && (this.selectWord(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  tripleClickHandler(e) {
    this.isEditing && (this.selectLine(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  _mouseDownHandler(e) {
    let { e: n, alreadySelected: s } = e;
    this.canvas && this.editable && !od(n) && !this.getActiveControl() && (this.draggableTextDelegate.start(n) || (this.canvas.textEditingManager.register(this), s && (this.inCompositionMode = !1, this.setCursorByClick(n)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()), this.selected || (this.selected = s || this.isEditing)));
  }
  mouseUpHandler(e) {
    let { e: n, transform: s } = e;
    const r = this.draggableTextDelegate.end(n);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const o = this.canvas._activeObject;
      if (o && o !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || s && s.actionPerformed || od(n) || r || this.selected && !this.getActiveControl() && (this.enterEditing(n), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection());
  }
  setCursorByClick(e) {
    const n = this.getSelectionStartFromPointer(e), s = this.selectionStart, r = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(s, r, n) : (this.selectionStart = n, this.selectionEnd = n), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const n = this.canvas.getScenePoint(e).transform(On(this.calcTransformMatrix())).add(new we(-this._getLeftOffset(), -this._getTopOffset()));
    let s = 0, r = 0, o = 0;
    for (let c = 0; c < this._textLines.length && s <= n.y; c++) s += this.getHeightOfLine(c), o = c, c > 0 && (r += this._textLines[c - 1].length + this.missingNewlineOffset(c - 1));
    let a = Math.abs(this._getLineLeftOffset(o));
    const l = this._textLines[o].length, u = this.__charBounds[o];
    for (let c = 0; c < l; c++) {
      const d = a + u[c].kernedWidth;
      if (n.x <= d) {
        Math.abs(n.x - d) <= Math.abs(n.x - a) && r++;
        break;
      }
      a = d, r++;
    }
    return Math.min(this.flipX ? l - r : r, this._text.length);
  }
}
const to = "moveCursorUp", no = "moveCursorDown", so = "moveCursorLeft", io = "moveCursorRight", ro = "exitEditing", ad = (i, e) => {
  const n = e.getRetinaScaling();
  i.setTransform(n, 0, 0, n, 0, 0);
  const s = e.viewportTransform;
  i.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
}, q4 = ue({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: ro, 27: ro, 33: to, 34: no, 35: io, 36: so, 37: so, 38: to, 39: io, 40: no }, keysMapRtl: { 9: ro, 27: ro, 33: to, 34: no, 35: so, 36: io, 37: io, 38: to, 39: so, 40: no }, ctrlKeysMapDown: { 65: "cmdAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class is extends K4 {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), is.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, n) {
    super(e, ue(ue({}, is.ownDefaults), n)), this.initBehavior();
  }
  _set(e, n) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = n, this) : (e === "canvas" && (this.canvas instanceof $l && this.canvas.textEditingManager.remove(this), n instanceof $l && n.textEditingManager.add(this)), super._set(e, n));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, n) {
    this[e] !== n && (this._fireSelectionChanged(), this[e] = n), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, s = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, n, s);
  }
  setSelectionStyles(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, n, s);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, n);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const n = this.isEditing;
    this.isEditing = !1;
    const s = super.toCanvasElement(e);
    return this.isEditing = n, s;
  }
  renderCursorOrSelection() {
    if (!this.isEditing || !this.canvas) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const n = this._getCursorBoundaries(), s = this.findAncestorsWithClipPath(), r = s.length > 0;
    let o, a = e;
    if (r) {
      o = xn(e.canvas), a = o.getContext("2d"), ad(a, this.canvas);
      const l = this.calcTransformMatrix();
      a.transform(l[0], l[1], l[2], l[3], l[4], l[5]);
    }
    if (this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(a, n) : this.renderCursor(a, n), r) for (const l of s) {
      const u = l.clipPath, c = xn(e.canvas), d = c.getContext("2d");
      if (ad(d, this.canvas), !u.absolutePositioned) {
        const f = l.calcTransformMatrix();
        d.transform(f[0], f[1], f[2], f[3], f[4], f[5]);
      }
      u.transform(d), u.drawObject(d, !0, {}), this.drawClipPathOnCache(a, u, c);
    }
    r && (e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(o, 0, 0)), this.canvas.contextTopDirty = !0, e.restore();
  }
  findAncestorsWithClipPath() {
    const e = [];
    let n = this;
    for (; n; ) n.clipPath && e.push(n), n = n.parent;
    return e;
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    const s = this._getLeftOffset(), r = this._getTopOffset(), o = this._getCursorBoundariesOffsets(e, n);
    return { left: s, top: r, leftOffset: o.left, topOffset: o.top };
  }
  _getCursorBoundariesOffsets(e, n) {
    return n ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let n = 0, s = 0;
    const { charIndex: r, lineIndex: o } = this.get2DCursorLocation(e);
    for (let c = 0; c < o; c++) n += this.getHeightOfLine(c);
    const a = this._getLineLeftOffset(o), l = this.__charBounds[o][r];
    l && (s = l.left), this.charSpacing !== 0 && r === this._textLines[o].length && (s -= this._getWidthOfCharSpacing());
    const u = { top: n, left: a + (s > 0 ? s : 0) };
    return this.direction === "rtl" && (this.textAlign === Et || this.textAlign === jn || this.textAlign === dr ? u.left *= -1 : this.textAlign === ht || this.textAlign === ia ? u.left = a - (s > 0 ? s : 0) : this.textAlign !== st && this.textAlign !== hr || (u.left = a - (s > 0 ? s : 0))), u;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, n) {
    this._renderCursor(e, n, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const s = this.get2DCursorLocation(e), r = s.lineIndex, o = s.charIndex > 0 ? s.charIndex - 1 : 0, a = this.getValueOfPropertyAt(r, o, "fontSize"), l = this.getObjectScaling().x * this.canvas.getZoom(), u = this.cursorWidth / l, c = this.getValueOfPropertyAt(r, o, "deltaY"), d = n.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(r, o, "fill"), opacity: this._currentCursorOpacity, left: n.left + n.leftOffset - u / 2, top: d + n.top + c, width: u, height: a };
  }
  _renderCursor(e, n, s) {
    const { color: r, opacity: o, left: a, top: l, width: u, height: c } = this.getCursorRenderingData(s, n);
    e.fillStyle = r, e.globalAlpha = o, e.fillRect(a, l, u, c);
  }
  renderSelection(e, n) {
    const s = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, s, n);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const n = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(n);
  }
  _renderSelection(e, n, s) {
    const r = n.selectionStart, o = n.selectionEnd, a = this.textAlign.includes(jn), l = this.get2DCursorLocation(r), u = this.get2DCursorLocation(o), c = l.lineIndex, d = u.lineIndex, f = l.charIndex < 0 ? 0 : l.charIndex, g = u.charIndex < 0 ? 0 : u.charIndex;
    for (let p = c; p <= d; p++) {
      const y = this._getLineLeftOffset(p) || 0;
      let v = this.getHeightOfLine(p), m = 0, b = 0, S = 0;
      if (p === c && (b = this.__charBounds[c][f].left), p >= c && p < d) S = a && !this.isEndOfWrapping(p) ? this.width : this.getLineWidth(p) || 5;
      else if (p === d) if (g === 0) S = this.__charBounds[d][g].left;
      else {
        const M = this._getWidthOfCharSpacing();
        S = this.__charBounds[d][g - 1].left + this.__charBounds[d][g - 1].width - M;
      }
      m = v, (this.lineHeight < 1 || p === d && this.lineHeight > 1) && (v /= this.lineHeight);
      let x = s.left + y + b, _ = v, C = 0;
      const k = S - b;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", _ = 1, C = v) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === Et || this.textAlign === jn || this.textAlign === dr ? x = this.width - x - k : this.textAlign === ht || this.textAlign === ia ? x = s.left + y - S : this.textAlign !== st && this.textAlign !== hr || (x = s.left + y - S)), e.fillRect(x, s.top + s.topOffset + C, k, _), s.topOffset += m;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Ft);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), n = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: n };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
le(is, "ownDefaults", q4), le(is, "type", "IText"), We.setClass(is), We.setClass(is, "i-text");
class qs extends is {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), qs.ownDefaults);
  }
  constructor(e, n) {
    super(e, ue(ue({}, qs.ownDefaults), n));
  }
  static createControls() {
    return { controls: OM() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(jn) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let n = 0, s = 0, r = 0;
    const o = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[r] === `
` && a > 0 ? (s = 0, r++, n++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[r]) && a > 0 && (s++, r++), o[a] = { line: n, offset: s }, r += e.graphemeLines[a].length, s += e.graphemeLines[a].length;
    return o;
  }
  styleHas(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[n];
      s && (n = s.line);
    }
    return super.styleHas(e, n);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let n, s = 0, r = e + 1, o = !1;
    const a = this._styleMap[e], l = this._styleMap[e + 1];
    a && (e = a.line, s = a.offset), l && (r = l.line, o = r === e, n = l.offset);
    const u = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const c in u) for (const d in u[c]) {
      const f = parseInt(d, 10);
      if (f >= s && (!o || f < n)) for (const g in u[c][d]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[e];
      if (!s) return {};
      e = s.line, n = s.offset + n;
    }
    return super._getStyleDeclaration(e, n);
  }
  _setStyleDeclaration(e, n, s) {
    const r = this._styleMap[e];
    super._setStyleDeclaration(r.line, r.offset + n, s);
  }
  _deleteStyleDeclaration(e, n) {
    const s = this._styleMap[e];
    super._deleteStyleDeclaration(s.line, s.offset + n);
  }
  _getLineStyle(e) {
    const n = this._styleMap[e];
    return !!this.styles[n.line];
  }
  _setLineStyle(e) {
    const n = this._styleMap[e];
    super._setLineStyle(n.line);
  }
  _wrapText(e, n) {
    this.isWrapping = !0;
    const s = this.getGraphemeDataForRender(e), r = [];
    for (let o = 0; o < s.wordsData.length; o++) r.push(...this._wrapLine(o, n, s));
    return this.isWrapping = !1, r;
  }
  getGraphemeDataForRender(e) {
    const n = this.splitByGrapheme, s = n ? "" : " ";
    let r = 0;
    return { wordsData: e.map((o, a) => {
      let l = 0;
      const u = n ? this.graphemeSplit(o) : this.wordSplit(o);
      return u.length === 0 ? [{ word: [], width: 0 }] : u.map((c) => {
        const d = n ? [c] : this.graphemeSplit(c), f = this._measureWord(d, a, l);
        return r = Math.max(f, r), l += d.length + s.length, { word: d, width: f };
      });
    }), largestWordWidth: r };
  }
  _measureWord(e, n) {
    let s, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = 0;
    for (let a = 0, l = e.length; a < l; a++)
      o += this._getGraphemeBox(e[a], n, a + r, s, !0).kernedWidth, s = e[a];
    return o;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, n, s) {
    let { largestWordWidth: r, wordsData: o } = s, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const l = this._getWidthOfCharSpacing(), u = this.splitByGrapheme, c = [], d = u ? "" : " ";
    let f = 0, g = [], p = 0, y = 0, v = !0;
    n -= a;
    const m = Math.max(n, r, this.dynamicMinWidth), b = o[e];
    let S;
    for (p = 0, S = 0; S < b.length; S++) {
      const { word: x, width: _ } = b[S];
      p += x.length, f += y + _ - l, f > m && !v ? (c.push(g), g = [], f = _, v = !0) : f += l, v || u || g.push(d), g = g.concat(x), y = u ? 0 : this._measureWord([d], e, p), p++, v = !1;
    }
    return S && c.push(g), r + a > this.dynamicMinWidth && (this.dynamicMinWidth = r - l + a), c;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, n) {
    return this.splitByGrapheme && !n ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const n = super._splitTextIntoLines(e), s = this._wrapText(n.lines, this.width), r = new Array(s.length);
    for (let o = 0; o < s.length; o++) r[o] = s[o].join("");
    return n.lines = r, n.graphemeLines = s, n;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const n in this._styleMap) {
      const s = parseInt(n, 10);
      if (this._textLines[s]) {
        const r = this._styleMap[n].line;
        e.set("".concat(r), !0);
      }
    }
    for (const n in this.styles) e.has(n) || delete this.styles[n];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
le(qs, "type", "Textbox"), le(qs, "textLayoutProperties", [...is.textLayoutProperties, "width"]), le(qs, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), We.setClass(qs);
class ld extends Fa {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, n) {
    const { target: s } = e, { clipPath: r, group: o } = s;
    if (!r || !this.shouldPerformLayout(e)) return;
    const { width: a, height: l } = ls(kf(s, r)), u = new we(a, l);
    if (r.absolutePositioned)
      return { center: _i(r.getRelativeCenterPoint(), void 0, o ? o.calcTransformMatrix() : void 0), size: u };
    {
      const c = r.getRelativeCenterPoint().transform(s.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: d = new we(), correction: f = new we() } = this.calcBoundingBox(n, e) || {};
        return { center: d.add(c), correction: f.subtract(c), size: u };
      }
      return { center: s.getRelativeCenterPoint().add(c), size: u };
    }
  }
}
le(ld, "type", "clip-path"), We.setClass(ld);
class ud extends Fa {
  getInitialSize(e, n) {
    let { target: s } = e, { size: r } = n;
    return new we(s.width || r.x, s.height || r.y);
  }
}
le(ud, "type", "fixed"), We.setClass(ud);
class Z4 extends Pr {
  subscribeTargets(e) {
    const n = e.target;
    e.targets.reduce((s, r) => (r.parent && s.add(r.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {
      s.layoutManager.subscribeTargets({ target: s, targets: [n] });
    });
  }
  unsubscribeTargets(e) {
    const n = e.target, s = n.getObjects();
    e.targets.reduce((r, o) => (o.parent && r.add(o.parent), r), /* @__PURE__ */ new Set()).forEach((r) => {
      !s.some((o) => o.parent === r) && r.layoutManager.unsubscribeTargets({ target: r, targets: [n] });
    });
  }
}
class Zs extends Is {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), Zs.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Zs.ownDefaults), this.setOptions(n);
    const { left: s, top: r, layoutManager: o } = n;
    this.groupInit(e, { left: s, top: r, layoutManager: o ?? new Z4() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    this.multiSelectionStacking === "selection-order" ? this.add(...n) : n.forEach((r) => {
      const o = this._objects.findIndex((l) => l.isInFrontOf(r)), a = o === -1 ? this.size() : o;
      this.insertAt(a, r);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((n) => n.isDescendantOf(e) || e.isDescendantOf(n)) ? (Fs("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, n) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, n);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, n) {
    super._onAfterObjectsChange(e, n);
    const s = /* @__PURE__ */ new Set();
    n.forEach((r) => {
      const { parent: o } = r;
      o && s.add(o);
    }), e === Tu ? s.forEach((r) => {
      r._onAfterObjectsChange(ra, n);
    }) : s.forEach((r) => {
      r._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, n, s) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const r = ue(ue({ hasControls: !1 }, s), {}, { forActiveSelection: !0 });
    for (let o = 0; o < this._objects.length; o++) this._objects[o]._renderControls(e, r);
    super._renderControls(e, n), e.restore();
  }
}
le(Zs, "type", "ActiveSelection"), le(Zs, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), We.setClass(Zs), We.setClass(Zs, "activeSelection");
class J4 {
  constructor() {
    le(this, "resources", {});
  }
  applyFilters(e, n, s, r, o) {
    const a = o.getContext("2d");
    if (!a) return;
    a.drawImage(n, 0, 0, s, r);
    const l = { sourceWidth: s, sourceHeight: r, imageData: a.getImageData(0, 0, s, r), originalEl: n, originalImageData: a.getImageData(0, 0, s, r), canvasEl: o, ctx: a, filterBackend: this };
    e.forEach((c) => {
      c.applyTo(l);
    });
    const { imageData: u } = l;
    return u.width === s && u.height === r || (o.width = u.width, o.height = u.height), a.putImageData(u, 0, 0), l;
  }
}
class Bf {
  constructor() {
    let { tileSize: e = at.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    le(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), le(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, n) {
    this.dispose(), this.createWebGLCanvas(e, n);
  }
  createWebGLCanvas(e, n) {
    const s = xn({ width: e, height: n }), r = s.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    r && (r.clearColor(0, 0, 0, 0), this.canvas = s, this.gl = r);
  }
  applyFilters(e, n, s, r, o, a) {
    const l = this.gl, u = o.getContext("2d");
    if (!l || !u) return;
    let c;
    a && (c = this.getCachedTexture(a, n));
    const d = { originalWidth: n.width || n.naturalWidth || 0, originalHeight: n.height || n.naturalHeight || 0, sourceWidth: s, sourceHeight: r, destinationWidth: s, destinationHeight: r, context: l, sourceTexture: this.createTexture(l, s, r, c ? void 0 : n), targetTexture: this.createTexture(l, s, r), originalTexture: c || this.createTexture(l, s, r, c ? void 0 : n), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: o }, f = l.createFramebuffer();
    return l.bindFramebuffer(l.FRAMEBUFFER, f), e.forEach((g) => {
      g && g.applyTo(d);
    }), function(g) {
      const p = g.targetCanvas, y = p.width, v = p.height, m = g.destinationWidth, b = g.destinationHeight;
      y === m && v === b || (p.width = m, p.height = b);
    }(d), this.copyGLTo2D(l, d), l.bindTexture(l.TEXTURE_2D, null), l.deleteTexture(d.sourceTexture), l.deleteTexture(d.targetTexture), l.deleteFramebuffer(f), u.setTransform(1, 0, 0, 1, 0, 0), d;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, n, s, r, o) {
    const { NEAREST: a, TEXTURE_2D: l, RGBA: u, UNSIGNED_BYTE: c, CLAMP_TO_EDGE: d, TEXTURE_MAG_FILTER: f, TEXTURE_MIN_FILTER: g, TEXTURE_WRAP_S: p, TEXTURE_WRAP_T: y } = e, v = e.createTexture();
    return e.bindTexture(l, v), e.texParameteri(l, f, o || a), e.texParameteri(l, g, o || a), e.texParameteri(l, p, d), e.texParameteri(l, y, d), r ? e.texImage2D(l, 0, u, u, c, r) : e.texImage2D(l, 0, u, n, s, 0, u, c, null), v;
  }
  getCachedTexture(e, n, s) {
    const { textureCache: r } = this;
    if (r[e]) return r[e];
    {
      const o = this.createTexture(this.gl, n.width, n.height, n, s);
      return o && (r[e] = o), o;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, n) {
    const s = e.canvas, r = n.targetCanvas, o = r.getContext("2d");
    if (!o) return;
    o.translate(0, r.height), o.scale(1, -1);
    const a = s.height - r.height;
    o.drawImage(s, 0, a, r.width, r.height, 0, 0, r.width, r.height);
  }
  copyGLTo2DPutImageData(e, n) {
    const s = n.targetCanvas.getContext("2d"), r = n.destinationWidth, o = n.destinationHeight, a = r * o * 4;
    if (!s) return;
    const l = new Uint8Array(this.imageBuffer, 0, a), u = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, r, o, e.RGBA, e.UNSIGNED_BYTE, l);
    const c = new ImageData(u, r, o);
    s.putImageData(c, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, n = { renderer: "", vendor: "" };
    if (!e) return n;
    const s = e.getExtension("WEBGL_debug_renderer_info");
    if (s) {
      const r = e.getParameter(s.UNMASKED_RENDERER_WEBGL), o = e.getParameter(s.UNMASKED_VENDOR_WEBGL);
      r && (n.renderer = r.toLowerCase()), o && (n.vendor = o.toLowerCase());
    }
    return this.gpuInfo = n, n;
  }
}
let cl;
function Q4() {
  const { WebGLProbe: i } = Nn();
  return i.queryWebGL(gs()), at.enableGLFiltering && i.isSupported(at.textureSize) ? new Bf({ tileSize: at.textureSize }) : new J4();
}
function dl() {
  return !cl && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (cl = Q4()), cl;
}
const eO = ["filters", "resizeFilter", "src", "crossOrigin", "type"], Wf = ["cropX", "cropY"];
class sn extends Gt {
  static getDefaults() {
    return ue(ue({}, super.getDefaults()), sn.ownDefaults);
  }
  constructor(e, n) {
    super(), le(this, "_lastScaleX", 1), le(this, "_lastScaleY", 1), le(this, "_filterScalingX", 1), le(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, sn.ownDefaults), this.setOptions(n), this.cacheKey = "texture".concat(Ls()), this.setElement(typeof e == "string" ? (this.canvas && Mn(this.canvas.getElement()) || Ii()).getElementById(e) : e, n);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    var n;
    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(s), (n = e.classList) === null || n === void 0 || n.add(sn.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const n = dl(!1);
    n instanceof Bf && n.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const n = this[e];
      n && Nn().dispose(n), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const n = this.width / 2, s = this.height / 2;
    e.beginPath(), e.moveTo(-n, -s), e.lineTo(n, -s), e.lineTo(n, s), e.lineTo(-n, s), e.lineTo(-n, -s), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = [];
    return this.filters.forEach((s) => {
      s && n.push(s.toObject());
    }), ue(ue({}, super.toObject([...Wf, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: n }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], n = this._element, s = -this.width / 2, r = -this.height / 2;
    let o = [], a = [], l = "", u = "";
    if (!n) return [];
    if (this.hasCrop()) {
      const c = Ls();
      o.push('<clipPath id="imageCrop_' + c + `">
`, '	<rect x="' + s + '" y="' + r + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), l = ' clip-path="url(#imageCrop_' + c + ')" ';
    }
    if (this.imageSmoothing || (u = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(s - this.cropX, '" y="').concat(r - this.cropY, '" width="').concat(n.width || n.naturalWidth, '" height="').concat(n.height || n.naturalHeight, '"').concat(u).concat(l, `></image>
`)), this.stroke || this.strokeDashArray) {
      const c = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(s, '" y="').concat(r, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = c;
    }
    return o = this.paintFirst !== Ft ? o.concat(a, e) : o.concat(e, a), o;
  }
  getSrc(e) {
    const n = e ? this._element : this._originalElement;
    return n ? n.toDataURL ? n.toDataURL() : this.srcFromAttribute ? n.getAttribute("src") || "" : n.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: n, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Io(e, { crossOrigin: n, signal: s }).then((r) => {
      n !== void 0 && this.set({ crossOrigin: n }), this.setElement(r);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, n = this.minimumScaleTrigger, s = this.getTotalObjectScaling(), r = s.x, o = s.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || r > n && o > n) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void (this._lastScaleY = o);
    const l = xn(a), { width: u, height: c } = a;
    this._element = l, this._lastScaleX = e.scaleX = r, this._lastScaleY = e.scaleY = o, dl().applyFilters([e], a, u, c, this._element), this._filterScalingX = l.width / this._originalElement.width, this._filterScalingY = l.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((o) => o && !o.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const n = this._originalElement, s = n.naturalWidth || n.width, r = n.naturalHeight || n.height;
    if (this._element === this._originalElement) {
      const o = xn({ width: s, height: r });
      this._element = o, this._filteredEl = o;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, s, r), this._lastScaleX = 1, this._lastScaleY = 1);
    dl().applyFilters(e, this._originalElement, s, r, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const n = this._element;
    if (!n) return;
    const s = this._filterScalingX, r = this._filterScalingY, o = this.width, a = this.height, l = Math.max(this.cropX, 0), u = Math.max(this.cropY, 0), c = n.naturalWidth || n.width, d = n.naturalHeight || n.height, f = l * s, g = u * r, p = Math.min(o * s, c - f), y = Math.min(a * r, d - g), v = -o / 2, m = -a / 2, b = Math.min(o, c / s - l), S = Math.min(a, d / r - u);
    n && e.drawImage(n, f, g, p, y, v, m, b, S);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: n } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const s = this.getOriginalSize();
    this.width = e || s.width, this.height = n || s.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = XT(this.preserveAspectRatio || ""), n = this.width, s = this.height, r = { width: n, height: s };
    let o, a = this._element.width, l = this._element.height, u = 1, c = 1, d = 0, f = 0, g = 0, p = 0;
    return !e || e.alignX === on && e.alignY === on ? (u = n / a, c = s / l) : (e.meetOrSlice === "meet" && (u = c = l4(this._element, r), o = (n - a * u) / 2, e.alignX === "Min" && (d = -o), e.alignX === "Max" && (d = o), o = (s - l * c) / 2, e.alignY === "Min" && (f = -o), e.alignY === "Max" && (f = o)), e.meetOrSlice === "slice" && (u = c = u4(this._element, r), o = a - n / u, e.alignX === "Mid" && (g = o / 2), e.alignX === "Max" && (g = o), o = l - s / c, e.alignY === "Mid" && (p = o / 2), e.alignY === "Max" && (p = o), a = n / u, l = s / c)), { width: a, height: l, scaleX: u, scaleY: c, offsetLeft: d, offsetTop: f, cropX: g, cropY: p };
  }
  static fromObject(e, n) {
    let { filters: s, resizeFilter: r, src: o, crossOrigin: a, type: l } = e, u = _t(e, eO);
    return Promise.all([Io(o, ue(ue({}, n), {}, { crossOrigin: a })), s && Tr(s, n), r && Tr([r], n), Pa(u, n)]).then((c) => {
      let [d, f = [], [g] = [], p = {}] = c;
      return new this(d, ue(ue({}, u), {}, { src: o, filters: f, resizeFilter: g }, p));
    });
  }
  static fromURL(e) {
    let { crossOrigin: n = null, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0;
    return Io(e, { crossOrigin: n, signal: s }).then((o) => new this(o, r));
  }
  static async fromElement(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
    const r = xs(e, this.ATTRIBUTE_NAMES, s);
    return this.fromURL(r["xlink:href"] || r.href, n, r).catch((o) => (Fs("log", "Unable to parse Image", o), null));
  }
}
le(sn, "type", "Image"), le(sn, "cacheProperties", [...bs, ...Wf]), le(sn, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), le(sn, "CSS_CANVAS", "canvas-img"), le(sn, "ATTRIBUTE_NAMES", [...Rs, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "href", "crossOrigin", "image-rendering"]), We.setClass(sn), We.setSVGClass(sn);
Aa(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const za = (i) => i.webgl !== void 0, Mu = "precision highp float", tO = `
    `.concat(Mu, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), nO = ["type"], sO = ["type"], iO = new RegExp(Mu, "g");
class Lt {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = _t(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, nO);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return tO;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: r = "highp" } } = Nn();
    r !== "highp" && (n = n.replace(iO, Mu.replace("highp", r)));
    const o = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), l = e.createProgram();
    if (!o || !a || !l) throw new $n("Vertex, fragment shader or program creation error");
    if (e.shaderSource(o, s), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS)) throw new $n("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(o)));
    if (e.shaderSource(a, n), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new $n("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(l, o), e.attachShader(l, a), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS)) throw new $n('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(l)));
    const u = this.getUniformLocations(e, l) || {};
    return u.uStepW = e.getUniformLocation(l, "uStepW"), u.uStepH = e.getUniformLocation(l, "uStepH"), { program: l, attributeLocations: this.getAttributeLocations(e, l), uniformLocations: u };
  }
  getAttributeLocations(e, n) {
    return { aPosition: e.getAttribLocation(n, "aPosition") };
  }
  getUniformLocations(e, n) {
    const s = this.constructor.uniformLocations, r = {};
    for (let o = 0; o < s.length; o++) r[s[o]] = e.getUniformLocation(n, s[o]);
    return r;
  }
  sendAttributeData(e, n, s) {
    const r = n.aPosition, o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.enableVertexAttribArray(r), e.vertexAttribPointer(r, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, s, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const n = e.context;
    if (e.passes > 1) {
      const s = e.destinationWidth, r = e.destinationHeight;
      e.sourceWidth === s && e.sourceHeight === r || (n.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(n, s, r)), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.targetTexture, 0);
    } else n.bindFramebuffer(n.FRAMEBUFFER, null), n.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const n = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = n;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    za(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const n = this.getCacheKey();
    return e.programCache[n] || (e.programCache[n] = this.createProgram(e.context)), e.programCache[n];
  }
  applyToWebGL(e) {
    const n = e.context, s = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? n.bindTexture(n.TEXTURE_2D, e.originalTexture) : n.bindTexture(n.TEXTURE_2D, e.sourceTexture), n.useProgram(s.program), this.sendAttributeData(n, s.attributeLocations, e.aPosition), n.uniform1f(s.uniformLocations.uStepW, 1 / e.sourceWidth), n.uniform1f(s.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(n, s.uniformLocations), n.viewport(0, 0, e.destinationWidth, e.destinationHeight), n.drawArrays(n.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, n, s) {
    e.activeTexture(s), e.bindTexture(e.TEXTURE_2D, n), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, n) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: n, sourceHeight: s } = e, r = xn({ width: n, height: s });
      e.helpLayer = r;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return ue({ type: this.type }, e.reduce((n, s) => (n[s] = this[s], n), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, n) {
    return new this(_t(e, sO));
  }
}
le(Lt, "type", "BaseFilter"), le(Lt, "uniformLocations", []);
const rO = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class oo extends Lt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(rO[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = new ft(this.color).getSource(), r = this.alpha, o = s[0] * r, a = s[1] * r, l = s[2] * r, u = 1 - r;
    for (let c = 0; c < n.length; c += 4) {
      const d = n[c], f = n[c + 1], g = n[c + 2];
      let p, y, v;
      switch (this.mode) {
        case "multiply":
          p = d * o / 255, y = f * a / 255, v = g * l / 255;
          break;
        case "screen":
          p = 255 - (255 - d) * (255 - o) / 255, y = 255 - (255 - f) * (255 - a) / 255, v = 255 - (255 - g) * (255 - l) / 255;
          break;
        case "add":
          p = d + o, y = f + a, v = g + l;
          break;
        case "difference":
          p = Math.abs(d - o), y = Math.abs(f - a), v = Math.abs(g - l);
          break;
        case "subtract":
          p = d - o, y = f - a, v = g - l;
          break;
        case "darken":
          p = Math.min(d, o), y = Math.min(f, a), v = Math.min(g, l);
          break;
        case "lighten":
          p = Math.max(d, o), y = Math.max(f, a), v = Math.max(g, l);
          break;
        case "overlay":
          p = o < 128 ? 2 * d * o / 255 : 255 - 2 * (255 - d) * (255 - o) / 255, y = a < 128 ? 2 * f * a / 255 : 255 - 2 * (255 - f) * (255 - a) / 255, v = l < 128 ? 2 * g * l / 255 : 255 - 2 * (255 - g) * (255 - l) / 255;
          break;
        case "exclusion":
          p = o + d - 2 * o * d / 255, y = a + f - 2 * a * f / 255, v = l + g - 2 * l * g / 255;
          break;
        case "tint":
          p = o + d * u, y = a + f * u, v = l + g * u;
      }
      n[c] = p, n[c + 1] = y, n[c + 2] = v;
    }
  }
  sendUniformData(e, n) {
    const s = new ft(this.color).getSource();
    s[0] = this.alpha * s[0] / 255, s[1] = this.alpha * s[1] / 255, s[2] = this.alpha * s[2] / 255, s[3] = this.alpha, e.uniform4fv(n.uColor, s);
  }
}
le(oo, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), le(oo, "type", "BlendColor"), le(oo, "uniformLocations", ["uColor"]), We.setClass(oo);
const oO = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, aO = ["type", "image"];
class ao extends Lt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return oO[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const n = e.context, s = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(n, s, n.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(n, n.TEXTURE1);
  }
  createTexture(e, n) {
    return e.getCachedTexture(n.cacheKey, n.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: n, height: s } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / n, -e.top / s, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: r }, filterBackend: { resources: o } } = e;
    const a = this.image;
    o.blendImage || (o.blendImage = gs());
    const l = o.blendImage, u = l.getContext("2d");
    l.width !== s || l.height !== r ? (l.width = s, l.height = r) : u.clearRect(0, 0, s, r), u.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), u.drawImage(a.getElement(), 0, 0, s, r);
    const c = u.getImageData(0, 0, s, r).data;
    for (let d = 0; d < n.length; d += 4) {
      const f = n[d], g = n[d + 1], p = n[d + 2], y = n[d + 3], v = c[d], m = c[d + 1], b = c[d + 2], S = c[d + 3];
      switch (this.mode) {
        case "multiply":
          n[d] = f * v / 255, n[d + 1] = g * m / 255, n[d + 2] = p * b / 255, n[d + 3] = y * S / 255;
          break;
        case "mask":
          n[d + 3] = S;
      }
    }
  }
  sendUniformData(e, n) {
    const s = this.calculateMatrix();
    e.uniform1i(n.uImage, 1), e.uniformMatrix3fv(n.uTransformMatrix, !1, s);
  }
  toObject() {
    return ue(ue({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, n) {
    let { type: s, image: r } = e, o = _t(e, aO);
    return sn.fromObject(r, n).then((a) => new this(ue(ue({}, o), {}, { image: a })));
  }
}
le(ao, "type", "BlendImage"), le(ao, "defaults", { mode: "multiply", alpha: 1 }), le(ao, "uniformLocations", ["uTransformMatrix", "uImage"]), We.setClass(ao);
class lo extends Lt {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float totalC = 0.0;
      float totalA = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);
        float weight = 1.0 - abs(percent);
        float alpha = weight * sample.a;
        color.rgb += sample.rgb * alpha;
        color.a += alpha;
        totalA += weight;
        totalC += alpha;
      }
      gl_FragColor.rgb = color.rgb / totalC;
      gl_FragColor.a = color.a / totalA;
    }
  `;
  }
  applyTo(e) {
    za(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: r } } = e;
    this.aspectRatio = s / r, this.horizontal = !0;
    let o = this.getBlurValue() * s;
    const a = new Uint8ClampedArray(n), l = 15, u = 4 * s;
    for (let c = 0; c < n.length; c += 4) {
      let d = 0, f = 0, g = 0, p = 0, y = 0;
      const v = c - c % u, m = v + u;
      for (let b = -14; b < l; b++) {
        const S = b / l, x = 4 * Math.floor(o * S), _ = 1 - Math.abs(S);
        let C = c + x;
        C < v ? C = v : C > m && (C = m);
        const k = n[C + 3] * _;
        d += n[C] * k, f += n[C + 1] * k, g += n[C + 2] * k, p += k, y += _;
      }
      a[c] = d / p, a[c + 1] = f / p, a[c + 2] = g / p, a[c + 3] = p / y;
    }
    this.horizontal = !1, o = this.getBlurValue() * r;
    for (let c = 0; c < a.length; c += 4) {
      let d = 0, f = 0, g = 0, p = 0, y = 0;
      const v = c % u, m = a.length - u + v;
      for (let b = -14; b < l; b++) {
        const S = b / l, x = Math.floor(o * S) * u, _ = 1 - Math.abs(S);
        let C = c + x;
        C < v ? C = v : C > m && (C = m);
        const k = a[C + 3] * _;
        d += a[C] * k, f += a[C + 1] * k, g += a[C + 2] * k, p += k, y += _;
      }
      n[c] = d / p, n[c + 1] = f / p, n[c + 2] = g / p, n[c + 3] = p / y;
    }
  }
  sendUniformData(e, n) {
    const s = this.chooseRightDelta();
    e.uniform2fv(n.uDelta, s);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  getBlurValue() {
    let e = 1;
    const { horizontal: n, aspectRatio: s } = this;
    return n ? s > 1 && (e = 1 / s) : s < 1 && (e = s), e * this.blur * 0.12;
  }
  chooseRightDelta() {
    const e = this.getBlurValue();
    return this.horizontal ? [e, 0] : [0, e];
  }
}
le(lo, "type", "Blur"), le(lo, "defaults", { blur: 0 }), le(lo, "uniformLocations", ["uDelta"]), We.setClass(lo);
class uo extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = Math.round(255 * this.brightness);
    for (let r = 0; r < n.length; r += 4) n[r] += s, n[r + 1] += s, n[r + 2] += s;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBrightness, this.brightness);
  }
}
le(uo, "type", "Brightness"), le(uo, "defaults", { brightness: 0 }), le(uo, "uniformLocations", ["uBrightness"]), We.setClass(uo);
const Uf = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class pi extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const n = e.imageData.data, s = this.matrix, r = this.colorsOnly;
    for (let o = 0; o < n.length; o += 4) {
      const a = n[o], l = n[o + 1], u = n[o + 2];
      if (n[o] = a * s[0] + l * s[1] + u * s[2] + 255 * s[4], n[o + 1] = a * s[5] + l * s[6] + u * s[7] + 255 * s[9], n[o + 2] = a * s[10] + l * s[11] + u * s[12] + 255 * s[14], !r) {
        const c = n[o + 3];
        n[o] += c * s[3], n[o + 1] += c * s[8], n[o + 2] += c * s[13], n[o + 3] = a * s[15] + l * s[16] + u * s[17] + c * s[18] + 255 * s[19];
      }
    }
  }
  sendUniformData(e, n) {
    const s = this.matrix, r = [s[0], s[1], s[2], s[3], s[5], s[6], s[7], s[8], s[10], s[11], s[12], s[13], s[15], s[16], s[17], s[18]], o = [s[4], s[9], s[14], s[19]];
    e.uniformMatrix4fv(n.uColorMatrix, !1, r), e.uniform4fv(n.uConstants, o);
  }
  toObject() {
    return ue(ue({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function ni(i, e) {
  var n;
  const s = (le(n = class extends pi {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", i), le(n, "defaults", { colorsOnly: !1, matrix: e }), n);
  return We.setClass(s, i), s;
}
le(pi, "type", "ColorMatrix"), le(pi, "defaults", Uf), le(pi, "uniformLocations", ["uColorMatrix", "uConstants"]), We.setClass(pi);
ni("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
ni("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
ni("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
ni("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
ni("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
ni("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
ni("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class cd extends Lt {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    za(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((n) => {
      n.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, n) {
    return Promise.all((e.subFilters || []).map((s) => We.getClass(s.type).fromObject(s, n))).then((s) => new this({ subFilters: s }));
  }
}
le(cd, "type", "Composed"), We.setClass(cd);
class co extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = Math.floor(255 * this.contrast), r = 259 * (s + 255) / (255 * (259 - s));
    for (let o = 0; o < n.length; o += 4) n[o] = r * (n[o] - 128) + 128, n[o + 1] = r * (n[o + 1] - 128) + 128, n[o + 2] = r * (n[o + 2] - 128) + 128;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uContrast, this.contrast);
  }
}
le(co, "type", "Contrast"), le(co, "defaults", { contrast: 0 }), le(co, "uniformLocations", ["uContrast"]), We.setClass(co);
const lO = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class ho extends Lt {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return lO[this.getCacheKey()];
  }
  applyTo2d(e) {
    const n = e.imageData, s = n.data, r = this.matrix, o = Math.round(Math.sqrt(r.length)), a = Math.floor(o / 2), l = n.width, u = n.height, c = e.ctx.createImageData(l, u), d = c.data, f = this.opaque ? 1 : 0;
    let g, p, y, v, m, b, S, x, _, C, k, M, O;
    for (k = 0; k < u; k++) for (C = 0; C < l; C++) {
      for (m = 4 * (k * l + C), g = 0, p = 0, y = 0, v = 0, O = 0; O < o; O++) for (M = 0; M < o; M++) S = k + O - a, b = C + M - a, S < 0 || S >= u || b < 0 || b >= l || (x = 4 * (S * l + b), _ = r[O * o + M], g += s[x] * _, p += s[x + 1] * _, y += s[x + 2] * _, f || (v += s[x + 3] * _));
      d[m] = g, d[m + 1] = p, d[m + 2] = y, d[m + 3] = f ? s[m + 3] : v;
    }
    e.imageData = c;
  }
  sendUniformData(e, n) {
    e.uniform1fv(n.uMatrix, this.matrix);
  }
  toObject() {
    return ue(ue({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
le(ho, "type", "Convolute"), le(ho, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), le(ho, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), We.setClass(ho);
const Nf = "Gamma";
class fo extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = this.gamma, r = 1 / s[0], o = 1 / s[1], a = 1 / s[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const l = this.rgbValues;
    for (let u = 0; u < 256; u++) l.r[u] = 255 * Math.pow(u / 255, r), l.g[u] = 255 * Math.pow(u / 255, o), l.b[u] = 255 * Math.pow(u / 255, a);
    for (let u = 0; u < n.length; u += 4) n[u] = l.r[n[u]], n[u + 1] = l.g[n[u + 1]], n[u + 2] = l.b[n[u + 2]];
  }
  sendUniformData(e, n) {
    e.uniform3fv(n.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: Nf, gamma: this.gamma.concat() };
  }
}
le(fo, "type", Nf), le(fo, "defaults", { gamma: [1, 1, 1] }), le(fo, "uniformLocations", ["uGamma"]), We.setClass(fo);
const uO = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class po extends Lt {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let s, r = 0; r < n.length; r += 4) {
      const o = n[r], a = n[r + 1], l = n[r + 2];
      switch (this.mode) {
        case "average":
          s = (o + a + l) / 3;
          break;
        case "lightness":
          s = (Math.min(o, a, l) + Math.max(o, a, l)) / 2;
          break;
        case "luminosity":
          s = 0.21 * o + 0.72 * a + 0.07 * l;
      }
      n[r + 2] = n[r + 1] = n[r] = s;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return uO[this.mode];
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
le(po, "type", "Grayscale"), le(po, "defaults", { mode: "average" }), le(po, "uniformLocations", ["uMode"]), We.setClass(po);
const cO = ue(ue({}, Uf), {}, { rotation: 0 });
class hl extends pi {
  calculateMatrix() {
    const e = this.rotation * Math.PI, n = ps(e), s = ms(e), r = 1 / 3, o = Math.sqrt(r) * s, a = 1 - n;
    this.matrix = [n + a / 3, r * a - o, r * a + o, 0, 0, r * a + o, n + r * a, r * a - o, 0, 0, r * a - o, r * a + o, n + r * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
le(hl, "type", "HueRotation"), le(hl, "defaults", cO), We.setClass(hl);
class mo extends Lt {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let s = 0; s < n.length; s += 4) n[s] = 255 - n[s], n[s + 1] = 255 - n[s + 1], n[s + 2] = 255 - n[s + 2], this.alpha && (n[s + 3] = 255 - n[s + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uInvert, Number(this.invert)), e.uniform1i(n.uAlpha, Number(this.alpha));
  }
}
le(mo, "type", "Invert"), le(mo, "defaults", { alpha: !1, invert: !0 }), le(mo, "uniformLocations", ["uInvert", "uAlpha"]), We.setClass(mo);
class go extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = this.noise;
    for (let r = 0; r < n.length; r += 4) {
      const o = (0.5 - Math.random()) * s;
      n[r] += o, n[r + 1] += o, n[r + 2] += o;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uNoise, this.noise / 255), e.uniform1f(n.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
le(go, "type", "Noise"), le(go, "defaults", { noise: 0 }), le(go, "uniformLocations", ["uNoise", "uSeed"]), We.setClass(go);
class vo extends Lt {
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: r } } = e;
    for (let o = 0; o < r; o += this.blocksize) for (let a = 0; a < s; a += this.blocksize) {
      const l = 4 * o * s + 4 * a, u = n[l], c = n[l + 1], d = n[l + 2], f = n[l + 3];
      for (let g = o; g < Math.min(o + this.blocksize, r); g++) for (let p = a; p < Math.min(a + this.blocksize, s); p++) {
        const y = 4 * g * s + 4 * p;
        n[y] = u, n[y + 1] = c, n[y + 2] = d, n[y + 3] = f;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBlocksize, this.blocksize);
  }
}
le(vo, "type", "Pixelate"), le(vo, "defaults", { blocksize: 4 }), le(vo, "uniformLocations", ["uBlocksize"]), We.setClass(vo);
class yo extends Lt {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = 255 * this.distance, r = new ft(this.color).getSource(), o = [r[0] - s, r[1] - s, r[2] - s], a = [r[0] + s, r[1] + s, r[2] + s];
    for (let l = 0; l < n.length; l += 4) {
      const u = n[l], c = n[l + 1], d = n[l + 2];
      u > o[0] && c > o[1] && d > o[2] && u < a[0] && c < a[1] && d < a[2] && (n[l + 3] = 0);
    }
  }
  sendUniformData(e, n) {
    const s = new ft(this.color).getSource(), r = this.distance, o = [0 + s[0] / 255 - r, 0 + s[1] / 255 - r, 0 + s[2] / 255 - r, 1], a = [s[0] / 255 + r, s[1] / 255 + r, s[2] / 255 + r, 1];
    e.uniform4fv(n.uLow, o), e.uniform4fv(n.uHigh, a);
  }
}
le(yo, "type", "RemoveColor"), le(yo, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), le(yo, "uniformLocations", ["uLow", "uHigh"]), We.setClass(yo);
class bo extends Lt {
  sendUniformData(e, n) {
    e.uniform2fv(n.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(n.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), n = this.tempScale, s = this.getFilterWindow(), r = new Array(s);
    for (let o = 1; o <= s; o++) r[o - 1] = e(o * n);
    return r;
  }
  generateShader(e) {
    const n = new Array(e);
    for (let s = 1; s <= e; s++) n[s - 1] = "".concat(s, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(n.map((s, r) => `
              color += texture2D(uTexture, vTexCoord + `.concat(s, ") * uTaps[").concat(r, "] + texture2D(uTexture, vTexCoord - ").concat(s, ") * uTaps[").concat(r, `];
              sum += 2.0 * uTaps[`).concat(r, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    za(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (n) => {
      if (n >= e || n <= -e) return 0;
      if (n < 11920929e-14 && n > -11920929e-14) return 1;
      const s = (n *= Math.PI) / e;
      return Math.sin(n) / n * Math.sin(s) / s;
    };
  }
  applyTo2d(e) {
    const n = e.imageData, s = this.scaleX, r = this.scaleY;
    this.rcpScaleX = 1 / s, this.rcpScaleY = 1 / r;
    const o = n.width, a = n.height, l = Math.round(o * s), u = Math.round(a * r);
    let c;
    c = this.resizeType === "sliceHack" ? this.sliceByTwo(e, o, a, l, u) : this.resizeType === "hermite" ? this.hermiteFastResize(e, o, a, l, u) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, o, a, l, u) : this.resizeType === "lanczos" ? this.lanczosResize(e, o, a, l, u) : new ImageData(l, u), e.imageData = c;
  }
  sliceByTwo(e, n, s, r, o) {
    const a = e.imageData, l = 0.5;
    let u = !1, c = !1, d = n * l, f = s * l;
    const g = e.filterBackend.resources;
    let p = 0, y = 0;
    const v = n;
    let m = 0;
    g.sliceByTwo || (g.sliceByTwo = gs());
    const b = g.sliceByTwo;
    (b.width < 1.5 * n || b.height < s) && (b.width = 1.5 * n, b.height = s);
    const S = b.getContext("2d");
    for (S.clearRect(0, 0, 1.5 * n, s), S.putImageData(a, 0, 0), r = Math.floor(r), o = Math.floor(o); !u || !c; ) n = d, s = f, r < Math.floor(d * l) ? d = Math.floor(d * l) : (d = r, u = !0), o < Math.floor(f * l) ? f = Math.floor(f * l) : (f = o, c = !0), S.drawImage(b, p, y, n, s, v, m, d, f), p = v, y = m, m += f;
    return S.getImageData(p, y, r, o);
  }
  lanczosResize(e, n, s, r, o) {
    const a = e.imageData.data, l = e.ctx.createImageData(r, o), u = l.data, c = this.lanczosCreate(this.lanczosLobes), d = this.rcpScaleX, f = this.rcpScaleY, g = 2 / this.rcpScaleX, p = 2 / this.rcpScaleY, y = Math.ceil(d * this.lanczosLobes / 2), v = Math.ceil(f * this.lanczosLobes / 2), m = {}, b = { x: 0, y: 0 }, S = { x: 0, y: 0 };
    return function x(_) {
      let C, k, M, O, F, $, ne, oe, z, X, T;
      for (b.x = (_ + 0.5) * d, S.x = Math.floor(b.x), C = 0; C < o; C++) {
        for (b.y = (C + 0.5) * f, S.y = Math.floor(b.y), F = 0, $ = 0, ne = 0, oe = 0, z = 0, k = S.x - y; k <= S.x + y; k++) if (!(k < 0 || k >= n)) {
          X = Math.floor(1e3 * Math.abs(k - b.x)), m[X] || (m[X] = {});
          for (let H = S.y - v; H <= S.y + v; H++) H < 0 || H >= s || (T = Math.floor(1e3 * Math.abs(H - b.y)), m[X][T] || (m[X][T] = c(Math.sqrt(Math.pow(X * g, 2) + Math.pow(T * p, 2)) / 1e3)), M = m[X][T], M > 0 && (O = 4 * (H * n + k), F += M, $ += M * a[O], ne += M * a[O + 1], oe += M * a[O + 2], z += M * a[O + 3]));
        }
        O = 4 * (C * r + _), u[O] = $ / F, u[O + 1] = ne / F, u[O + 2] = oe / F, u[O + 3] = z / F;
      }
      return ++_ < r ? x(_) : l;
    }(0);
  }
  bilinearFiltering(e, n, s, r, o) {
    let a, l, u, c, d, f, g, p, y, v, m, b, S, x = 0;
    const _ = this.rcpScaleX, C = this.rcpScaleY, k = 4 * (n - 1), M = e.imageData.data, O = e.ctx.createImageData(r, o), F = O.data;
    for (g = 0; g < o; g++) for (p = 0; p < r; p++) for (d = Math.floor(_ * p), f = Math.floor(C * g), y = _ * p - d, v = C * g - f, S = 4 * (f * n + d), m = 0; m < 4; m++) a = M[S + m], l = M[S + 4 + m], u = M[S + k + m], c = M[S + k + 4 + m], b = a * (1 - y) * (1 - v) + l * y * (1 - v) + u * v * (1 - y) + c * y * v, F[x++] = b;
    return O;
  }
  hermiteFastResize(e, n, s, r, o) {
    const a = this.rcpScaleX, l = this.rcpScaleY, u = Math.ceil(a / 2), c = Math.ceil(l / 2), d = e.imageData.data, f = e.ctx.createImageData(r, o), g = f.data;
    for (let p = 0; p < o; p++) for (let y = 0; y < r; y++) {
      const v = 4 * (y + p * r);
      let m = 0, b = 0, S = 0, x = 0, _ = 0, C = 0, k = 0;
      const M = (p + 0.5) * l;
      for (let O = Math.floor(p * l); O < (p + 1) * l; O++) {
        const F = Math.abs(M - (O + 0.5)) / c, $ = (y + 0.5) * a, ne = F * F;
        for (let oe = Math.floor(y * a); oe < (y + 1) * a; oe++) {
          let z = Math.abs($ - (oe + 0.5)) / u;
          const X = Math.sqrt(ne + z * z);
          X > 1 && X < -1 || (m = 2 * X * X * X - 3 * X * X + 1, m > 0 && (z = 4 * (oe + O * n), k += m * d[z + 3], S += m, d[z + 3] < 255 && (m = m * d[z + 3] / 250), x += m * d[z], _ += m * d[z + 1], C += m * d[z + 2], b += m));
        }
      }
      g[v] = x / b, g[v + 1] = _ / b, g[v + 2] = C / b, g[v + 3] = k / S;
    }
    return f;
  }
}
le(bo, "type", "Resize"), le(bo, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), le(bo, "uniformLocations", ["uDelta", "uTaps"]), We.setClass(bo);
class xo extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = -this.saturation;
    for (let r = 0; r < n.length; r += 4) {
      const o = n[r], a = n[r + 1], l = n[r + 2], u = Math.max(o, a, l);
      n[r] += u !== o ? (u - o) * s : 0, n[r + 1] += u !== a ? (u - a) * s : 0, n[r + 2] += u !== l ? (u - l) * s : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
le(xo, "type", "Saturation"), le(xo, "defaults", { saturation: 0 }), le(xo, "uniformLocations", ["uSaturation"]), We.setClass(xo);
class _o extends Lt {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = -this.vibrance;
    for (let r = 0; r < n.length; r += 4) {
      const o = n[r], a = n[r + 1], l = n[r + 2], u = Math.max(o, a, l), c = (o + a + l) / 3, d = 2 * Math.abs(u - c) / 255 * s;
      n[r] += u !== o ? (u - o) * d : 0, n[r + 1] += u !== a ? (u - a) * d : 0, n[r + 2] += u !== l ? (u - l) * d : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
le(_o, "type", "Vibrance"), le(_o, "defaults", { vibrance: 0 }), le(_o, "uniformLocations", ["uVibrance"]), We.setClass(_o);
const dd = dO(), hd = hO();
function dO() {
  const i = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, s = Math.round(255 * Ci(0.267004 + n * (4874e-6 + n * (-0.259027 + n * (2.066795 + n * (-2.131557 + n * 0.736987)))))), r = Math.round(255 * Ci(4874e-6 + n * (1.404613 + n * (-0.598103 + n * (-0.229949 + n * (0.659864 + n * -0.238132)))))), o = Math.round(255 * Ci(0.329415 + n * (1.384613 + n * (-1.860504 + n * (1.592785 + n * (-0.730173 + n * 0.13561))))));
    i[e * 4] = s, i[e * 4 + 1] = r, i[e * 4 + 2] = o, i[e * 4 + 3] = 255;
  }
  return i;
}
function hO() {
  const i = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, s = Math.round(255 * Ci(0.050383 + n * (2.689401 + n * (-1.802775 + n * (-0.391194 + n * (0.706557 + n * -0.218185)))))), r = Math.round(255 * Ci(0.029803 + n * (-0.177105 + n * (0.96833 + n * (0.419198 + n * (-0.991163 + n * 0.517737)))))), o = Math.round(255 * Ci(0.527975 + n * (1.546816 + n * (-4.246533 + n * (6.585146 + n * (-4.621553 + n * 1.205227))))));
    i[e * 4] = s, i[e * 4 + 1] = r, i[e * 4 + 2] = o, i[e * 4 + 3] = 255;
  }
  return i;
}
function Ci(i) {
  return Math.max(0, Math.min(1, i));
}
const Gs = class Gs extends sn {
  constructor(e, n = {}) {
    super(e, {
      ...Gs.ownDefaults,
      ...n
    }), this.colormap = n.colormap || "viridis", this._colorizedCanvas = null, this._webglContext = null, this._webglProgram = null, this._sourceImageData = null, this._initializeColorization();
  }
  /**
   * Initialize the colorization system (WebGL or Canvas2D fallback)
   */
  _initializeColorization() {
    const e = this.getElement();
    e && (this._colorizedCanvas = document.createElement("canvas"), this._colorizedCanvas.width = e.width || e.naturalWidth, this._colorizedCanvas.height = e.height || e.naturalHeight, this._initWebGL() ? this._applyColormapWebGL() : this._applyColormapCanvas2D());
  }
  /**
   * Initialize WebGL context and shader program
   */
  _initWebGL() {
    if (!this._colorizedCanvas) return !1;
    try {
      const e = this._colorizedCanvas.getContext("webgl", {
        preserveDrawingBuffer: !0,
        alpha: !0
      });
      if (!e) return !1;
      this._webglContext = e;
      const n = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `, s = `
        precision mediump float;
        uniform sampler2D u_image;
        uniform sampler2D u_colormap;
        varying vec2 v_texCoord;
        void main() {
          vec4 depth = texture2D(u_image, v_texCoord);
          float gray = dot(depth.rgb, vec3(0.299, 0.587, 0.114));
          vec4 color = texture2D(u_colormap, vec2(gray, 0.5));
          gl_FragColor = vec4(color.rgb, depth.a);
        }
      `, r = this._compileShader(e, e.VERTEX_SHADER, n), o = this._compileShader(e, e.FRAGMENT_SHADER, s);
      if (!r || !o) return !1;
      const a = e.createProgram();
      return a ? (e.attachShader(a, r), e.attachShader(a, o), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) ? (this._webglProgram = a, !0) : (console.error("[DepthMapImage] Program link error:", e.getProgramInfoLog(a)), !1)) : !1;
    } catch (e) {
      return console.warn("[DepthMapImage] WebGL init failed:", e), !1;
    }
  }
  _compileShader(e, n, s) {
    const r = e.createShader(n);
    return r ? (e.shaderSource(r, s), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS) ? r : (console.error("[DepthMapImage] Shader compile error:", e.getShaderInfoLog(r)), e.deleteShader(r), null)) : null;
  }
  /**
   * Apply colormap using WebGL
   */
  _applyColormapWebGL() {
    const e = this._webglContext, n = this._webglProgram;
    if (!e || !n || !this._colorizedCanvas) return;
    e.useProgram(n);
    const s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW);
    const r = e.getAttribLocation(n, "a_position");
    e.enableVertexAttribArray(r), e.vertexAttribPointer(r, 2, e.FLOAT, !1, 0, 0);
    const o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
    const a = e.getAttribLocation(n, "a_texCoord");
    e.enableVertexAttribArray(a), e.vertexAttribPointer(a, 2, e.FLOAT, !1, 0, 0);
    const l = e.createTexture();
    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, l), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.getElement());
    const u = e.createTexture();
    e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, u), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR);
    const c = this.colormap === "plasma" ? hd : dd;
    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 256, 1, 0, e.RGBA, e.UNSIGNED_BYTE, c), e.uniform1i(e.getUniformLocation(n, "u_image"), 0), e.uniform1i(e.getUniformLocation(n, "u_colormap"), 1), e.viewport(0, 0, this._colorizedCanvas.width, this._colorizedCanvas.height), e.drawArrays(e.TRIANGLES, 0, 6);
  }
  /**
   * Apply colormap using Canvas2D (fallback)
   */
  _applyColormapCanvas2D() {
    if (!this._colorizedCanvas) return;
    const e = this._colorizedCanvas.getContext("2d");
    if (!e) return;
    const n = this.getElement(), s = this._colorizedCanvas.width, r = this._colorizedCanvas.height;
    e.drawImage(n, 0, 0, s, r);
    const o = e.getImageData(0, 0, s, r), a = o.data, l = this.colormap === "plasma" ? hd : this.colormap === "viridis" ? dd : null;
    if (l) {
      for (let u = 0; u < a.length; u += 4) {
        const c = Math.round(
          a[u] * 0.299 + a[u + 1] * 0.587 + a[u + 2] * 0.114
        );
        a[u] = l[c * 4], a[u + 1] = l[c * 4 + 1], a[u + 2] = l[c * 4 + 2];
      }
      e.putImageData(o, 0, 0);
    }
  }
  /**
   * Set the colormap and re-apply
   */
  setColormap(e) {
    var n;
    this.colormap = e, this._webglContext && this._webglProgram ? this._applyColormapWebGL() : this._applyColormapCanvas2D(), this.dirty = !0, (n = this.canvas) == null || n.requestRenderAll();
  }
  /**
   * Override render to use colorized canvas
   */
  render(e) {
    if (this._colorizedCanvas && this.colormap !== "grayscale") {
      const n = this.getElement();
      this.setElement(this._colorizedCanvas), super.render(e), this.setElement(n);
    } else
      super.render(e);
  }
  /**
   * Get serializable properties including colormap
   */
  getSerializableData() {
    return {
      colormap: this.colormap
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    return new Promise((n, s) => {
      if (!e.src) {
        s(new Error("DepthMapImage requires a src property"));
        return;
      }
      const r = new Image();
      r.crossOrigin = "anonymous", r.onload = () => {
        n(new Gs(r, {
          colormap: e.colormap,
          ...e
        }));
      }, r.onerror = s, r.src = e.src;
    });
  }
  /**
   * Create from base64 data
   */
  static fromBase64(e, n = {}) {
    return new Promise((s, r) => {
      const o = new Image();
      o.crossOrigin = "anonymous", o.onload = () => {
        s(new Gs(o, n));
      }, o.onerror = r, o.src = e.startsWith("data:") ? e : `data:image/png;base64,${e}`;
    });
  }
};
He(Gs, "type", "DepthMapImage"), He(Gs, "ownDefaults", {
  colormap: "viridis",
  opacity: 0.5,
  visible: !0
});
let la = Gs;
We.setClass(la);
const mi = class mi extends Ds {
  constructor(e, n = {}) {
    super(e, {
      ...mi.ownDefaults,
      ...n
    }), this.controlPoints = n.controlPoints || [], this._animationKeyframes = [];
  }
  /**
   * Update path data from control points
   */
  updatePathFromControlPoints() {
    if (this.controlPoints.length < 2) {
      this.set("path", []);
      return;
    }
    const e = [], n = this.controlPoints;
    e.push(["M", n[0].x, n[0].y]);
    for (let s = 0; s < n.length - 1; s++) {
      const r = n[s], o = n[s + 1], a = r.handleOut || { x: r.x, y: r.y }, l = o.handleIn || { x: o.x, y: o.y };
      e.push([
        "C",
        a.x,
        a.y,
        l.x,
        l.y,
        o.x,
        o.y
      ]);
    }
    this.set("path", e), this.setCoords();
  }
  /**
   * Add a new control point at position
   */
  addControlPoint(e, n, s) {
    const r = {
      id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      x: e,
      y: n,
      depth: s,
      handleIn: null,
      handleOut: null,
      type: "corner"
    };
    return this.controlPoints.push(r), this.updatePathFromControlPoints(), r;
  }
  /**
   * Move a control point
   */
  moveControlPoint(e, n, s) {
    const r = this.controlPoints.find((l) => l.id === e);
    if (!r) return;
    const o = n - r.x, a = s - r.y;
    r.x = n, r.y = s, r.handleIn && (r.handleIn.x += o, r.handleIn.y += a), r.handleOut && (r.handleOut.x += o, r.handleOut.y += a), this.updatePathFromControlPoints();
  }
  /**
   * Set handle position for a control point
   */
  setHandle(e, n, s, r, o = !1) {
    const a = this.controlPoints.find((l) => l.id === e);
    if (a) {
      if (n === "in" ? a.handleIn = { x: s, y: r } : a.handleOut = { x: s, y: r }, !o && a.type === "smooth") {
        const l = n === "in" ? a.handleIn : a.handleOut, u = n === "in" ? "handleOut" : "handleIn";
        if (l) {
          const c = l.x - a.x, d = l.y - a.y;
          a[u] = {
            x: a.x - c,
            y: a.y - d
          };
        }
      }
      this.updatePathFromControlPoints();
    }
  }
  /**
   * Delete a control point
   */
  deleteControlPoint(e) {
    const n = this.controlPoints.findIndex((s) => s.id === e);
    n !== -1 && (this.controlPoints.splice(n, 1), this.updatePathFromControlPoints());
  }
  /**
   * Get spline data for serialization
   */
  getSplineData() {
    var e;
    return {
      pathData: ((e = this.path) == null ? void 0 : e.map((n) => n.join(" ")).join(" ")) || "",
      controlPoints: this.controlPoints,
      closed: !1,
      stroke: this.stroke,
      strokeWidth: this.strokeWidth,
      fill: this.fill
    };
  }
  /**
   * Get serializable properties
   */
  getSerializableData() {
    return {
      controlPoints: this.controlPoints,
      _animationKeyframes: this._animationKeyframes
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    var s;
    const n = ((s = e.path) == null ? void 0 : s.map((r) => r.join(" ")).join(" ")) || "";
    return Promise.resolve(new mi(n, {
      ...e,
      controlPoints: e.controlPoints || []
    }));
  }
};
// Type identifier for serialization
He(mi, "type", "SplinePath"), // Default values
He(mi, "ownDefaults", {
  stroke: "#00ff00",
  strokeWidth: 2,
  fill: "",
  selectable: !0,
  controlPoints: []
});
let ua = mi;
We.setClass(ua);
const gi = class gi extends Is {
  constructor(e = {}) {
    super([], {
      ...gi.ownDefaults,
      ...e,
      subTargetCheck: !0,
      interactive: !1
    }), this.textContent = e.text || "Text", this.fontFamily = e.fontFamily || "Arial", this.fontSize = e.fontSize || 48, this.fontWeight = e.fontWeight || "400", this.textFill = e.fill || "#ffffff", this.textStroke = e.stroke || "", this.textStrokeWidth = e.strokeWidth || 0, this.letterSpacing = e.letterSpacing || 0, this.pathLayerId = e.pathLayerId || null, this.pathOffset = e.pathOffset || 0, this._letterObjects = [], this._createLetterObjects();
  }
  /**
   * Create individual letter objects for per-character animation
   */
  _createLetterObjects() {
    this.removeAll(), this._letterObjects = [], console.log("[AnimatedText] Creating letters for text:", this.textContent, "fontSize:", this.fontSize, "fill:", this.textFill);
    const n = document.createElement("canvas").getContext("2d");
    for (const s of this.textContent) {
      const r = new Ht(s, {
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontWeight: this.fontWeight,
        fill: this.textFill,
        stroke: this.textStroke,
        strokeWidth: this.textStrokeWidth,
        originX: "center",
        originY: "center",
        selectable: !1,
        evented: !1
      });
      let o = r.width;
      (!o || o === 0) && n && (n.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`, o = n.measureText(s).width, r.set({ width: o })), console.log("[AnimatedText] Letter:", s, "width:", o, "height:", r.height || this.fontSize), this._letterObjects.push(r), this.add(r);
    }
    this._layoutLettersHorizontal();
  }
  /**
   * Layout letters horizontally and update group bounds
   */
  _layoutLettersHorizontal() {
    const n = document.createElement("canvas").getContext("2d");
    n && (n.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`);
    let s = 0;
    for (const u of this._letterObjects) {
      let c = u.width;
      (!c || c === 0) && (n ? (c = n.measureText(u.text || " ").width, u.set({ width: c })) : c = this.fontSize * 0.6), s += c + this.letterSpacing;
    }
    s -= this.letterSpacing;
    const r = -s / 2;
    let o = 0;
    for (const u of this._letterObjects) {
      const c = u.width || this.fontSize * 0.6;
      u.set({
        left: r + o + c / 2,
        top: 0,
        angle: 0
      }), o += c + this.letterSpacing;
    }
    const a = Math.max(s, 10), l = this.fontSize * 1.5;
    this.set({
      width: a,
      height: l,
      // Disable clipping
      clipPath: void 0
    }), this.setCoords(), console.log("[AnimatedText] Layout complete. Group width:", a, "height:", l, "letterCount:", this._letterObjects.length, "totalTextWidth:", s);
  }
  /**
   * Position letters along a bezier path
   */
  positionOnPath(e, n) {
    const s = e.totalLength;
    let r = n * s, o = 0, a = 0;
    for (const l of this._letterObjects) {
      const u = l.width || this.fontSize * 0.6, c = Math.max(0, Math.min(r, s)), { point: d, tangent: f } = e.getPointAtDistance(c), g = Math.atan2(f.y, f.x) * (180 / Math.PI);
      l.set({
        left: d.x,
        top: d.y,
        angle: g
      }), o = Math.max(o, d.x + u), a = Math.max(a, d.y + this.fontSize), r += u + this.letterSpacing;
    }
    this.set({ width: o || 100, height: a || this.fontSize * 1.2 }), this.setCoords(), this.dirty = !0;
  }
  setText(e) {
    this.textContent = e, this._createLetterObjects(), this.dirty = !0, this.canvas && this.canvas.requestRenderAll();
  }
  setFont(e, n, s) {
    this.fontFamily = e, this.fontSize = n, s && (this.fontWeight = s), this._createLetterObjects();
  }
  setFillColor(e) {
    this.textFill = e;
    for (const n of this._letterObjects)
      n.set("fill", e);
    this.dirty = !0;
  }
  setStroke(e, n) {
    this.textStroke = e, this.textStrokeWidth = n;
    for (const s of this._letterObjects)
      s.set({ stroke: e, strokeWidth: n });
    this.dirty = !0;
  }
  setLetterSpacing(e) {
    this.letterSpacing = e, this.pathLayerId || this._layoutLettersHorizontal();
  }
  getTextWidth() {
    let e = 0;
    for (const n of this._letterObjects)
      e += (n.width || 0) + this.letterSpacing;
    return Math.max(0, e - this.letterSpacing);
  }
  getTextData() {
    return {
      text: this.textContent,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontStyle: "normal",
      fill: this.textFill,
      stroke: this.textStroke,
      strokeWidth: this.textStrokeWidth,
      letterSpacing: this.letterSpacing,
      lineHeight: 1.2,
      textAlign: "left",
      pathLayerId: this.pathLayerId,
      pathOffset: this.pathOffset,
      pathAlign: "left"
    };
  }
  getSerializableData() {
    return {
      textContent: this.textContent,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      textFill: this.textFill,
      textStroke: this.textStroke,
      textStrokeWidth: this.textStrokeWidth,
      letterSpacing: this.letterSpacing,
      pathLayerId: this.pathLayerId,
      pathOffset: this.pathOffset
    };
  }
  static fromObject(e) {
    return Promise.resolve(new gi({
      text: e.textContent,
      fontFamily: e.fontFamily,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fill: e.textFill,
      stroke: e.textStroke,
      strokeWidth: e.textStrokeWidth,
      letterSpacing: e.letterSpacing,
      pathLayerId: e.pathLayerId,
      pathOffset: e.pathOffset
    }));
  }
};
He(gi, "type", "AnimatedText"), He(gi, "ownDefaults", {
  text: "Text",
  fontFamily: "Arial",
  fontSize: 48,
  fontWeight: "400",
  fill: "#ffffff",
  stroke: "",
  strokeWidth: 0,
  letterSpacing: 0,
  pathLayerId: null,
  pathOffset: 0,
  selectable: !0
});
let ca = gi;
We.setClass(ca);
const fO = { class: "spline-editor" }, pO = ["viewBox"], mO = ["x1", "y1", "x2", "y2"], gO = ["x1", "y1", "x2", "y2"], vO = ["cx", "cy", "onMousedown"], yO = ["cx", "cy", "onMousedown"], bO = ["cx", "cy", "onMousedown"], xO = ["cx", "cy"], _O = /* @__PURE__ */ pt({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(i, { expose: e, emit: n }) {
    const s = i, r = n, o = Ot(), a = me(null), l = me(null), u = me(null), c = Oe(() => {
      if (!s.layerId) return [];
      const S = o.layers.find((_) => _.id === s.layerId);
      return !S || S.type !== "spline" || !S.data ? [] : S.data.controlPoints || [];
    });
    function d(S, x) {
      const _ = s.viewportTransform, C = (S - _[4]) / _[0], k = (x - _[5]) / _[3];
      return { x: C, y: k };
    }
    function f(S) {
      const _ = S.currentTarget.getBoundingClientRect(), C = S.clientX - _.left, k = S.clientY - _.top;
      return d(C, k);
    }
    function g(S) {
      if (!s.isPenMode) return;
      const x = f(S);
      if (s.layerId) {
        const _ = o.layers.find((C) => C.id === s.layerId);
        if (_ && _.type === "spline") {
          const C = _.data, k = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: x.x,
            y: x.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          C.controlPoints || (C.controlPoints = []), C.controlPoints.push(k), a.value = k.id, u.value = {
            type: "handleOut",
            pointId: k.id,
            startX: x.x,
            startY: x.y
          }, r("pointAdded", k), r("pathUpdated");
        }
      }
    }
    function p(S) {
      var _;
      const x = f(S);
      if (s.isPenMode && (l.value = x), u.value) {
        const C = o.layers.find((O) => O.id === s.layerId);
        if (!C || C.type !== "spline") return;
        const M = (_ = C.data.controlPoints) == null ? void 0 : _.find((O) => O.id === u.value.pointId);
        if (!M) return;
        if (u.value.type === "point") {
          const O = x.x - M.x, F = x.y - M.y;
          M.x = x.x, M.y = x.y, M.handleIn && (M.handleIn.x += O, M.handleIn.y += F), M.handleOut && (M.handleOut.x += O, M.handleOut.y += F), r("pointMoved", M.id, x.x, x.y);
        } else if (u.value.type === "handleIn") {
          if (M.handleIn = { x: x.x, y: x.y }, M.type === "smooth") {
            const O = x.x - M.x, F = x.y - M.y;
            M.handleOut = { x: M.x - O, y: M.y - F };
          }
          r("handleMoved", M.id, "in", x.x, x.y);
        } else if (u.value.type === "handleOut") {
          if (M.handleOut = { x: x.x, y: x.y }, M.type === "smooth") {
            const O = x.x - M.x, F = x.y - M.y;
            M.handleIn = { x: M.x - O, y: M.y - F };
          }
          r("handleMoved", M.id, "out", x.x, x.y);
        }
        r("pathUpdated");
      }
    }
    function y() {
      var S;
      if (u.value) {
        const x = o.layers.find((_) => _.id === s.layerId);
        if (x && x.type === "spline") {
          const C = (S = x.data.controlPoints) == null ? void 0 : S.find((k) => k.id === u.value.pointId);
          if (C && C.handleOut) {
            const k = C.handleOut.x - C.x, M = C.handleOut.y - C.y;
            Math.sqrt(k * k + M * M) > 5 ? (C.type = "smooth", C.handleIn = { x: C.x - k, y: C.y - M }) : C.handleOut = null;
          }
        }
        u.value = null, r("pathUpdated");
      }
    }
    function v(S, x) {
      if (a.value = S, !s.isPenMode) {
        const _ = f(x);
        u.value = {
          type: "point",
          pointId: S,
          startX: _.x,
          startY: _.y
        };
      }
    }
    function m(S, x, _) {
      const C = f(_);
      u.value = {
        type: x === "in" ? "handleIn" : "handleOut",
        pointId: S,
        startX: C.x,
        startY: C.y
      };
    }
    function b(S) {
      var x, _;
      if ((S.key === "Delete" || S.key === "Backspace") && a.value && s.layerId) {
        const C = o.layers.find((k) => k.id === s.layerId);
        if (C && C.type === "spline") {
          const k = C.data, M = (x = k.controlPoints) == null ? void 0 : x.findIndex((O) => O.id === a.value);
          M !== void 0 && M >= 0 && ((_ = k.controlPoints) == null || _.splice(M, 1), r("pointDeleted", a.value), r("pathUpdated"), a.value = null);
        }
      }
    }
    return Rt(() => {
      window.addEventListener("keydown", b);
    }), pn(() => {
      window.removeEventListener("keydown", b);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (S, x) => (V(), B("div", fO, [
      (V(), B("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${i.canvasWidth} ${i.canvasHeight}`,
        onMousedown: g,
        onMousemove: p,
        onMouseup: y,
        onMouseleave: y
      }, [
        (V(!0), B(Re, null, Ue(c.value, (_) => (V(), B(Re, {
          key: `handles-${_.id}`
        }, [
          _.handleIn && a.value === _.id ? (V(), B("line", {
            key: 0,
            x1: _.x,
            y1: _.y,
            x2: _.handleIn.x,
            y2: _.handleIn.y,
            class: "handle-line"
          }, null, 8, mO)) : Te("", !0),
          _.handleOut && a.value === _.id ? (V(), B("line", {
            key: 1,
            x1: _.x,
            y1: _.y,
            x2: _.handleOut.x,
            y2: _.handleOut.y,
            class: "handle-line"
          }, null, 8, gO)) : Te("", !0)
        ], 64))), 128)),
        (V(!0), B(Re, null, Ue(c.value, (_) => {
          var C, k;
          return V(), B(Re, {
            key: `handle-points-${_.id}`
          }, [
            _.handleIn && a.value === _.id ? (V(), B("circle", {
              key: 0,
              cx: _.handleIn.x,
              cy: _.handleIn.y,
              r: "4",
              class: Ie(["handle-point", { active: ((C = u.value) == null ? void 0 : C.type) === "handleIn" && u.value.pointId === _.id }]),
              onMousedown: Je((M) => m(_.id, "in", M), ["stop"])
            }, null, 42, vO)) : Te("", !0),
            _.handleOut && a.value === _.id ? (V(), B("circle", {
              key: 1,
              cx: _.handleOut.x,
              cy: _.handleOut.y,
              r: "4",
              class: Ie(["handle-point", { active: ((k = u.value) == null ? void 0 : k.type) === "handleOut" && u.value.pointId === _.id }]),
              onMousedown: Je((M) => m(_.id, "out", M), ["stop"])
            }, null, 42, yO)) : Te("", !0)
          ], 64);
        }), 128)),
        (V(!0), B(Re, null, Ue(c.value, (_) => (V(), B("circle", {
          key: `point-${_.id}`,
          cx: _.x,
          cy: _.y,
          r: "6",
          class: Ie(["control-point", {
            selected: a.value === _.id,
            corner: _.type === "corner",
            smooth: _.type === "smooth"
          }]),
          onMousedown: Je((C) => v(_.id, C), ["stop"])
        }, null, 42, bO))), 128)),
        l.value && i.isPenMode ? (V(), B("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, xO)) : Te("", !0)
      ], 40, pO))
    ]));
  }
}), wO = /* @__PURE__ */ mt(_O, [["__scopeId", "data-v-48e73a8b"]]), Hf = /* @__PURE__ */ Math.sqrt(3), SO = 0.5 * (Hf - 1), Yi = (3 - Hf) / 6, fd = (i) => Math.floor(i) | 0, pd = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function CO(i = Math.random) {
  const e = kO(i), n = new Float64Array(e).map((r) => pd[r % 12 * 2]), s = new Float64Array(e).map((r) => pd[r % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, u = 0, c = 0;
    const d = (o + a) * SO, f = fd(o + d), g = fd(a + d), p = (f + g) * Yi, y = f - p, v = g - p, m = o - y, b = a - v;
    let S, x;
    m > b ? (S = 1, x = 0) : (S = 0, x = 1);
    const _ = m - S + Yi, C = b - x + Yi, k = m - 1 + 2 * Yi, M = b - 1 + 2 * Yi, O = f & 255, F = g & 255;
    let $ = 0.5 - m * m - b * b;
    if ($ >= 0) {
      const z = O + e[F], X = n[z], T = s[z];
      $ *= $, l = $ * $ * (X * m + T * b);
    }
    let ne = 0.5 - _ * _ - C * C;
    if (ne >= 0) {
      const z = O + S + e[F + x], X = n[z], T = s[z];
      ne *= ne, u = ne * ne * (X * _ + T * C);
    }
    let oe = 0.5 - k * k - M * M;
    if (oe >= 0) {
      const z = O + 1 + e[F + 1], X = n[z], T = s[z];
      oe *= oe, c = oe * oe * (X * k + T * M);
    }
    return 70 * (l + u + c);
  };
}
function kO(i) {
  const n = new Uint8Array(512);
  for (let s = 0; s < 512 / 2; s++)
    n[s] = s;
  for (let s = 0; s < 512 / 2 - 1; s++) {
    const r = s + ~~(i() * (256 - s)), o = n[s];
    n[s] = n[r], n[r] = o;
  }
  for (let s = 256; s < 512; s++)
    n[s] = n[s - 256];
  return n;
}
function TO() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function MO() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function md() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: TO()
  };
}
class Ra {
  constructor(e = {}) {
    He(this, "particles", []);
    He(this, "emitters", /* @__PURE__ */ new Map());
    He(this, "gravityWells", /* @__PURE__ */ new Map());
    He(this, "vortices", /* @__PURE__ */ new Map());
    He(this, "modulations", []);
    He(this, "config");
    He(this, "boundaryMask", null);
    He(this, "frameCount", 0);
    He(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    He(this, "nextParticleId", 0);
    He(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    He(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    He(this, "noise2D");
    He(this, "noiseTime", 0);
    // Render options cache for spatial grid
    He(this, "renderOptions", md());
    this.config = { ...MO(), ...e }, this.noise2D = CO();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let s = 0; s < n; s++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const s = this.emitters.get(e);
    s && Object.assign(s, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const s = this.gravityWells.get(e);
    s && Object.assign(s, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const s = this.vortices.get(e);
    s && Object.assign(s, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((s) => s.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, s) {
    const r = s ? `${s}:${e}` : `*:${e}`;
    this.featureOverrides.set(r, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((c, d) => {
      if (!c.enabled) return;
      const g = (this.getFeatureValue("emissionRate", d) ?? c.emissionRate) * e;
      let p = (this.emissionAccumulators.get(d) || 0) + g;
      for (; p >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(c), p -= 1;
      this.emissionAccumulators.set(d, p);
    });
    const n = this.config.windDirection * Math.PI / 180, s = Math.cos(n) * this.config.windStrength * 1e-3, r = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = s * (a / Math.max(1, this.config.windStrength)), u = r * (a / Math.max(1, this.config.windStrength));
    for (let c = this.particles.length - 1; c >= 0; c--) {
      const d = this.particles[c];
      if (d.prevX = d.x, d.prevY = d.y, this.trailHistory.has(d.id)) {
        const g = this.trailHistory.get(d.id);
        g.unshift({ x: d.x, y: d.y }), g.length > 20 && g.pop();
      }
      d.vy += o * 1e-3 * e, d.vx += l * e, d.vy += u * e, this.gravityWells.forEach((g) => {
        if (!g.enabled) return;
        const p = g.x - d.x, y = g.y - d.y, v = Math.sqrt(p * p + y * y);
        if (v < g.radius && v > 1e-3) {
          let m = g.strength * 1e-4;
          switch (g.falloff) {
            case "linear":
              m *= 1 - v / g.radius;
              break;
            case "quadratic":
              m *= Math.pow(1 - v / g.radius, 2);
              break;
          }
          const b = p / v, S = y / v;
          d.vx += b * m * e, d.vy += S * m * e;
        }
      }), this.vortices.forEach((g) => {
        if (!g.enabled) return;
        const p = g.x - d.x, y = g.y - d.y, v = Math.sqrt(p * p + y * y);
        if (v < g.radius && v > 1e-3) {
          const m = 1 - v / g.radius, b = g.strength * 1e-4 * m, S = p / v, x = y / v, _ = -x, C = S;
          d.vx += _ * b * e, d.vy += C * b * e;
          const k = g.inwardPull * 1e-4 * m;
          d.vx += S * k * e, d.vy += x * k * e;
        }
      }), this.applyTurbulence(d, e);
      const f = 1 - this.config.friction;
      d.vx *= f, d.vy *= f, d.x += d.vx * e, d.y += d.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(d), this.handleCanvasBoundary(d), this.applyModulations(d), d.age += e, d.age > d.lifetime && (d.isSubParticle || this.triggerSubEmitters(d), this.particles.splice(c, 1), this.trailHistory.delete(d.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, r = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), u = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), c = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(r) * a,
      vy: Math.sin(r) * a,
      age: 0,
      lifetime: u,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(c), this.trailHistory.set(c.id, [{ x: c.x, y: c.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), s = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || s < 0 || s >= this.boundaryMask.height)
      return;
    const r = (s * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[r] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const s of this.modulations) {
      if (s.emitterId !== "*" && s.emitterId !== e.emitterId) continue;
      const r = s.easing, o = Ko[r] || Ko.linear, a = lv(n, o), l = s.startValue + (s.endValue - s.startValue) * a;
      switch (s.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const u = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (u > 1e-4) {
            const c = l / Math.max(1e-4, u * 1e3);
            e.vx *= c, e.vy *= c;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const s = this.config.turbulenceFields || [];
    for (const r of s) {
      if (!r.enabled) continue;
      const o = e.x * r.scale * 1e3, a = e.y * r.scale * 1e3, l = this.noiseTime * r.evolutionSpeed, u = this.noise2D(o + l, a + l) * Math.PI * 2, c = r.strength * 1e-5;
      e.vx += Math.cos(u) * c * n, e.vy += Math.sin(u) * c * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var r;
    const s = (r = this.config.turbulenceFields) == null ? void 0 : r.find((o) => o.id === e);
    s && Object.assign(s, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const s of n)
      if (s.enabled && !(s.parentEmitterId !== "*" && s.parentEmitterId !== e.emitterId))
        for (let r = 0; r < s.spawnCount; r++) {
          const o = (Math.random() - 0.5) * s.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, u = Math.sqrt(e.vx ** 2 + e.vy ** 2) * s.inheritVelocity, c = s.speed * 1e-3 + u, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * c + e.vx * s.inheritVelocity,
            vy: Math.sin(l) * c + e.vy * s.inheritVelocity,
            age: 0,
            lifetime: s.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: s.size * (1 + (Math.random() - 0.5) * s.sizeVariance / s.size),
            baseSize: s.size,
            color: [...s.color, 255],
            baseColor: [...s.color, 255],
            emitterId: s.id,
            isSubParticle: !0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var r;
    const s = (r = this.config.subEmitters) == null ? void 0 : r.find((o) => o.id === e);
    s && Object.assign(s, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const s = this.emitters.get(e);
    if (!s || !s.enabled) return;
    const r = n ?? s.burstCount ?? 20;
    for (let o = 0; o < r; o++)
      this.spawnParticle(s);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var s;
    const e = ((s = this.renderOptions.connections) == null ? void 0 : s.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const r of this.particles) {
      const o = Math.floor(r.x * 1e3 / e), a = Math.floor(r.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(r);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const s = Math.floor(e.x * 1e3 / n.cellSize), r = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const u = `${s + a},${r + l}`, c = n.cells.get(u);
        c && o.push(...c);
      }
    return o;
  }
  renderConnections(e, n, s) {
    const r = this.renderOptions.connections;
    if (!(r != null && r.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = r.maxDistance / 1e3, l = a * a;
    e.lineWidth = r.lineWidth;
    for (const u of this.particles) {
      const c = this.getNeighborParticles(u, o);
      let d = 0;
      for (const f of c) {
        if (f.id <= u.id) continue;
        if (d >= r.maxConnections) break;
        const g = f.x - u.x, p = f.y - u.y, y = g * g + p * p;
        if (y < l) {
          const v = Math.sqrt(y);
          let m = r.lineOpacity;
          r.fadeByDistance && (m *= 1 - v / a);
          const b = Math.round((u.color[0] + f.color[0]) / 2), S = Math.round((u.color[1] + f.color[1]) / 2), x = Math.round((u.color[2] + f.color[2]) / 2);
          e.strokeStyle = `rgba(${b},${S},${x},${m})`, e.beginPath(), e.moveTo(u.x * n, u.y * s), e.lineTo(f.x * n, f.y * s), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, s, r = md()) {
    switch (this.renderOptions = r, e.save(), r.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, s);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * s, u = o.size;
      if (r.renderTrails) {
        const c = this.trailHistory.get(o.id);
        if (c && c.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const d = Math.min(c.length, r.trailLength);
          for (let f = 0; f < d; f++) {
            const g = c[f], p = o.color[3] * Math.pow(r.trailOpacityFalloff, f + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${p / 255})`, e.lineWidth = u * Math.pow(r.trailOpacityFalloff, f), e.lineTo(g.x * n, g.y * s);
          }
          e.stroke();
        }
      }
      r.glowEnabled ? (e.shadowBlur = r.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${r.glowIntensity})`) : e.shadowBlur = 0, r.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, u, n, s, r) : this.renderParticleShape(e, a, l, u, o.color, r.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, s, r, o, a, l, u) {
    const c = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (c < 1e-4) {
      this.renderParticleShape(e, s, r, o, n.color, u.particleShape);
      return;
    }
    const d = u.motionBlurStrength * c * 500, f = Math.min(u.motionBlurSamples, 16), g = n.vx / c, p = n.vy / c, y = Math.min(d * o, o * 10);
    for (let v = 0; v < f; v++) {
      const m = v / (f - 1), b = (1 - m * 0.8) / f, S = s - g * y * m, x = r - p * y * m, _ = o * (1 - m * 0.3), C = n.color[3] / 255 * b * f;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, C)})`, this.renderParticleShape(e, S, x, _, null, u.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, s, r, o, n.color, u.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, s, r, o, a) {
    switch (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, s, r / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - r / 2, s - r / 2, r, r);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, s - r / 2), e.lineTo(n - r / 2, s + r / 2), e.lineTo(n + r / 2, s + r / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, s, 5, r / 2, r / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, s, r, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let u = 0; u < r; u++) {
      const c = n + Math.cos(l) * o, d = s + Math.sin(l) * o;
      u === 0 ? e.moveTo(c, d) : e.lineTo(c, d), l += Math.PI / r;
      const f = n + Math.cos(l) * a, g = s + Math.sin(l) * a;
      e.lineTo(f, g), l += Math.PI / r;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const r = new OffscreenCanvas(e, n).getContext("2d");
    r.fillStyle = "#FFFFFF", r.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (r.strokeStyle = "#000000", r.lineWidth = o.lineWidth * 2, this.renderConnections(r, e, n)), r.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, u = a.y * n, c = a.size * 1.5;
      r.beginPath(), r.arc(l, u, c / 2, 0, Math.PI * 2), r.fill();
    }
    return r.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new Ra(e.config);
    if (e.emitters)
      for (const s of e.emitters)
        n.addEmitter(s);
    if (e.gravityWells)
      for (const s of e.gravityWells)
        n.addGravityWell(s);
    if (e.vortices)
      for (const s of e.vortices)
        n.addVortex(s);
    if (e.modulations)
      for (const s of e.modulations)
        n.addModulation(s);
    return n;
  }
}
function OO() {
  return {
    preset: "static",
    zoom: 1,
    offsetX: 0,
    offsetY: 0,
    rotation: 0,
    depthScale: 1,
    focusDepth: 0.5,
    dollyZoom: 0,
    orbitRadius: 0.1,
    orbitSpeed: 2,
    swingAmplitude: 0.1,
    swingFrequency: 0.5,
    edgeDilation: 5,
    inpaintEdges: !0
  };
}
const EO = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
  v_texCoord = a_texCoord;
}
`, PO = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_source;
uniform sampler2D u_depth;
uniform float u_zoom;
uniform vec2 u_offset;
uniform float u_rotation;
uniform float u_depthScale;
uniform float u_focusDepth;
uniform float u_edgeDilation;
uniform vec2 u_resolution;

vec2 rotate2D(vec2 p, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  return vec2(p.x * c - p.y * s, p.x * s + p.y * c);
}

void main() {
  // Get depth at current pixel
  float depth = texture(u_depth, v_texCoord).r;

  // Calculate parallax offset based on depth
  // Objects closer than focus depth move more, objects further move less
  float depthDiff = (depth - u_focusDepth) * u_depthScale;

  // Transform texture coordinates
  vec2 center = vec2(0.5, 0.5);
  vec2 coord = v_texCoord - center;

  // Apply rotation
  float rotRad = u_rotation * 3.14159265 / 180.0;
  coord = rotate2D(coord, rotRad);

  // Apply zoom
  coord /= u_zoom;

  // Apply parallax offset based on depth
  vec2 parallaxOffset = u_offset * depthDiff;
  coord += parallaxOffset;

  // Apply camera offset
  coord -= u_offset * 0.5;

  coord += center;

  // Edge handling with dilation
  float dilatePixels = u_edgeDilation / u_resolution.x;

  // Clamp coordinates
  vec2 clampedCoord = clamp(coord, vec2(dilatePixels), vec2(1.0 - dilatePixels));

  // Check if we're sampling outside bounds
  float outOfBounds = step(0.0, coord.x) * step(coord.x, 1.0) *
                      step(0.0, coord.y) * step(coord.y, 1.0);

  // Sample source texture
  vec4 color = texture(u_source, clampedCoord);

  // Fade edges if out of bounds
  if (outOfBounds < 0.5) {
    // Sample from clamped position with reduced alpha
    color = texture(u_source, clampedCoord);
    color.a *= 0.3;
  }

  outColor = color;
}
`;
class DO {
  constructor() {
    He(this, "sourceCanvas");
    He(this, "depthCanvas");
    He(this, "outputCanvas");
    He(this, "gl", null);
    He(this, "program", null);
    He(this, "useWebGL", !1);
    // WebGL resources
    He(this, "sourceTexture", null);
    He(this, "depthTexture", null);
    He(this, "positionBuffer", null);
    He(this, "texCoordBuffer", null);
    // Uniform locations
    He(this, "uniforms", {});
    // Current config
    He(this, "config", OO());
    // Source dimensions
    He(this, "width", 0);
    He(this, "height", 0);
    this.sourceCanvas = document.createElement("canvas"), this.depthCanvas = document.createElement("canvas"), this.outputCanvas = document.createElement("canvas"), this.initWebGL();
  }
  initWebGL() {
    const e = this.outputCanvas.getContext("webgl2", {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    });
    if (!e) {
      console.warn("[Depthflow] WebGL2 not available, using Canvas2D fallback"), this.useWebGL = !1;
      return;
    }
    this.gl = e, this.useWebGL = !0;
    const n = this.compileShader(e, e.VERTEX_SHADER, EO), s = this.compileShader(e, e.FRAGMENT_SHADER, PO);
    if (!n || !s) {
      this.useWebGL = !1;
      return;
    }
    const r = e.createProgram();
    if (e.attachShader(r, n), e.attachShader(r, s), e.linkProgram(r), !e.getProgramParameter(r, e.LINK_STATUS)) {
      console.error("[Depthflow] Program link error:", e.getProgramInfoLog(r)), this.useWebGL = !1;
      return;
    }
    this.program = r, this.uniforms = {
      u_source: e.getUniformLocation(r, "u_source"),
      u_depth: e.getUniformLocation(r, "u_depth"),
      u_zoom: e.getUniformLocation(r, "u_zoom"),
      u_offset: e.getUniformLocation(r, "u_offset"),
      u_rotation: e.getUniformLocation(r, "u_rotation"),
      u_depthScale: e.getUniformLocation(r, "u_depthScale"),
      u_focusDepth: e.getUniformLocation(r, "u_focusDepth"),
      u_edgeDilation: e.getUniformLocation(r, "u_edgeDilation"),
      u_resolution: e.getUniformLocation(r, "u_resolution")
    }, this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW), this.texCoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texCoordBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
  }
  compileShader(e, n, s) {
    const r = e.createShader(n);
    return e.shaderSource(r, s), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS) ? r : (console.error("[Depthflow] Shader compile error:", e.getShaderInfoLog(r)), e.deleteShader(r), null);
  }
  setSource(e) {
    e instanceof ImageData ? (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").drawImage(e, 0, 0)), this.width = this.sourceCanvas.width, this.height = this.sourceCanvas.height, this.outputCanvas.width = this.width, this.outputCanvas.height = this.height, this.useWebGL && this.gl && this.updateTexture("source");
  }
  setDepthMap(e) {
    e instanceof ImageData ? (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").drawImage(e, 0, 0)), this.useWebGL && this.gl && this.updateTexture("depth");
  }
  updateTexture(e) {
    const n = this.gl, s = e === "source" ? this.sourceCanvas : this.depthCanvas;
    e === "source" ? (this.sourceTexture && n.deleteTexture(this.sourceTexture), this.sourceTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture)) : (this.depthTexture && n.deleteTexture(this.depthTexture), this.depthTexture = n.createTexture(), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture)), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, s);
  }
  setConfig(e) {
    this.config = { ...this.config, ...e };
  }
  getConfig() {
    return { ...this.config };
  }
  /**
   * Get animated camera parameters for a specific frame based on preset
   */
  getAnimatedParams(e, n) {
    const s = n > 1 ? e / (n - 1) : 0, { preset: r, orbitRadius: o, orbitSpeed: a, swingAmplitude: l, swingFrequency: u } = this.config;
    let c = this.config.zoom, d = this.config.offsetX, f = this.config.offsetY, g = this.config.rotation, p = this.config.depthScale;
    switch (r) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + s * 0.3;
        break;
      case "zoom_out":
        c = 1 - s * 0.3;
        break;
      case "dolly_zoom_in":
        c = 1 + s * 0.4, p = this.config.depthScale * (1 - s * 0.5);
        break;
      case "dolly_zoom_out":
        c = 1 - s * 0.3, p = this.config.depthScale * (1 + s * 0.5);
        break;
      case "pan_left":
        d = -s * 0.3;
        break;
      case "pan_right":
        d = s * 0.3;
        break;
      case "pan_up":
        f = -s * 0.3;
        break;
      case "pan_down":
        f = s * 0.3;
        break;
      case "circle_cw": {
        const y = s * Math.PI * 2 * (a / 360);
        d = Math.cos(y) * o, f = Math.sin(y) * o;
        break;
      }
      case "circle_ccw": {
        const y = -s * Math.PI * 2 * (a / 360);
        d = Math.cos(y) * o, f = Math.sin(y) * o;
        break;
      }
      case "horizontal_swing":
        d = Math.sin(s * Math.PI * 2 * u) * l;
        break;
      case "vertical_swing":
        f = Math.sin(s * Math.PI * 2 * u) * l;
        break;
    }
    return { zoom: c, offsetX: d, offsetY: f, rotation: g, depthScale: p };
  }
  renderFrame(e, n) {
    const s = this.getAnimatedParams(e, n);
    return this.useWebGL && this.gl && this.program ? this.renderWebGL(s) : this.renderCanvas2D(s);
  }
  renderWebGL(e) {
    const n = this.gl;
    n.viewport(0, 0, this.width, this.height), n.useProgram(this.program), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture), n.uniform1i(this.uniforms.u_source, 0), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture), n.uniform1i(this.uniforms.u_depth, 1), n.uniform1f(this.uniforms.u_zoom, e.zoom), n.uniform2f(this.uniforms.u_offset, e.offsetX, e.offsetY), n.uniform1f(this.uniforms.u_rotation, e.rotation), n.uniform1f(this.uniforms.u_depthScale, e.depthScale), n.uniform1f(this.uniforms.u_focusDepth, this.config.focusDepth), n.uniform1f(this.uniforms.u_edgeDilation, this.config.edgeDilation), n.uniform2f(this.uniforms.u_resolution, this.width, this.height);
    const s = n.getAttribLocation(this.program, "a_position");
    n.bindBuffer(n.ARRAY_BUFFER, this.positionBuffer), n.enableVertexAttribArray(s), n.vertexAttribPointer(s, 2, n.FLOAT, !1, 0, 0);
    const r = n.getAttribLocation(this.program, "a_texCoord");
    n.bindBuffer(n.ARRAY_BUFFER, this.texCoordBuffer), n.enableVertexAttribArray(r), n.vertexAttribPointer(r, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.TRIANGLES, 0, 6);
    const o = new Uint8ClampedArray(this.width * this.height * 4);
    n.readPixels(0, 0, this.width, this.height, n.RGBA, n.UNSIGNED_BYTE, o);
    const a = new Uint8ClampedArray(o.length);
    for (let l = 0; l < this.height; l++) {
      const u = (this.height - 1 - l) * this.width * 4, c = l * this.width * 4;
      a.set(o.subarray(u, u + this.width * 4), c);
    }
    return new ImageData(a, this.width, this.height);
  }
  renderCanvas2D(e) {
    const n = this.outputCanvas.getContext("2d"), s = this.sourceCanvas.getContext("2d"), r = this.depthCanvas.getContext("2d"), o = s.getImageData(0, 0, this.width, this.height), a = r.getImageData(0, 0, this.width, this.height), l = n.createImageData(this.width, this.height), { zoom: u, offsetX: c, offsetY: d, rotation: f, depthScale: g } = e, { focusDepth: p } = this.config, y = f * Math.PI / 180, v = Math.cos(y), m = Math.sin(y);
    for (let b = 0; b < this.height; b++)
      for (let S = 0; S < this.width; S++) {
        const x = (b * this.width + S) * 4, C = (a.data[x] / 255 - p) * g;
        let k = S / this.width - 0.5, M = b / this.height - 0.5;
        const O = k * v - M * m, F = k * m + M * v;
        k = O, M = F, k /= u, M /= u, k += c * C, M += d * C, k -= c * 0.5, M -= d * 0.5, k = (k + 0.5) * this.width, M = (M + 0.5) * this.height;
        const $ = Math.floor(k), ne = Math.floor(M), oe = $ + 1, z = ne + 1, X = k - $, T = M - ne, H = Math.max(0, Math.min(this.width - 1, $)), ge = Math.max(0, Math.min(this.height - 1, ne)), K = Math.max(0, Math.min(this.width - 1, oe)), re = Math.max(0, Math.min(this.height - 1, z)), ie = (ge * this.width + H) * 4, be = (ge * this.width + K) * 4, J = (re * this.width + H) * 4, ee = (re * this.width + K) * 4;
        for (let ve = 0; ve < 4; ve++) {
          const G = o.data[ie + ve], N = o.data[be + ve], te = o.data[J + ve], fe = o.data[ee + ve], ae = G * (1 - X) + N * X, D = te * (1 - X) + fe * X;
          l.data[x + ve] = Math.round(ae * (1 - T) + D * T);
        }
        (k < 0 || k >= this.width || M < 0 || M >= this.height) && (l.data[x + 3] = Math.round(l.data[x + 3] * 0.3));
      }
    return n.putImageData(l, 0, 0), l;
  }
  renderSequence(e, n) {
    const s = [];
    for (let r = 0; r < e; r++)
      s.push(this.renderFrame(r, e)), n && n(r);
    return s;
  }
  /**
   * Get preset configuration with optional intensity modifier
   */
  getPresetConfig(e, n = 1) {
    const s = { preset: e };
    switch (e) {
      case "zoom_in":
      case "zoom_out":
        return { ...s, depthScale: 1 * n };
      case "dolly_zoom_in":
      case "dolly_zoom_out":
        return { ...s, depthScale: 1.5 * n, dollyZoom: 0.5 * n };
      case "pan_left":
      case "pan_right":
      case "pan_up":
      case "pan_down":
        return { ...s, depthScale: 0.8 * n };
      case "circle_cw":
      case "circle_ccw":
        return { ...s, orbitRadius: 0.1 * n, orbitSpeed: 360 };
      case "horizontal_swing":
      case "vertical_swing":
        return { ...s, swingAmplitude: 0.1 * n, swingFrequency: 1 };
      default:
        return s;
    }
  }
  getOutputCanvas() {
    return this.outputCanvas;
  }
  dispose() {
    this.gl && (this.sourceTexture && this.gl.deleteTexture(this.sourceTexture), this.depthTexture && this.gl.deleteTexture(this.depthTexture), this.positionBuffer && this.gl.deleteBuffer(this.positionBuffer), this.texCoordBuffer && this.gl.deleteBuffer(this.texCoordBuffer), this.program && this.gl.deleteProgram(this.program)), this.sourceTexture = null, this.depthTexture = null, this.positionBuffer = null, this.texCoordBuffer = null, this.program = null, this.gl = null;
  }
}
const Xf = /* @__PURE__ */ new Map();
function AO(i, e) {
  Xf.set(i, e);
}
function IO(i, e) {
  const n = {};
  for (const [s, r] of Object.entries(i.parameters)) {
    const o = r;
    n[s] = ns(o, e);
  }
  return n;
}
function FO(i, e, n) {
  const s = document.createElement("canvas");
  s.width = e.width, s.height = e.height;
  const r = s.getContext("2d");
  r.drawImage(e, 0, 0);
  let o = {
    canvas: s,
    ctx: r
  };
  for (const a of i) {
    if (!a.enabled)
      continue;
    const l = Xf.get(a.effectKey);
    if (!l) {
      console.warn(`No renderer registered for effect: ${a.effectKey}`);
      continue;
    }
    const u = IO(a, n);
    try {
      o = l(o, u);
    } catch (c) {
      console.error(`Error applying effect ${a.name}:`, c);
    }
  }
  return o;
}
function LO(i) {
  const e = document.createElement("canvas");
  e.width = i.width, e.height = i.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function zO(i) {
  return i.some((e) => e.enabled);
}
const RO = {
  key: 1,
  class: "overlay-controls"
}, VO = {
  key: 2,
  class: "loading-overlay"
}, jO = /* @__PURE__ */ pt({
  __name: "CompositionCanvas",
  setup(i, { expose: e }) {
    const n = Ot(), s = me(null), r = me(null), o = me(null), a = me(null), l = me(null), u = me(null), c = me(/* @__PURE__ */ new Map()), d = me(/* @__PURE__ */ new Map()), f = me(/* @__PURE__ */ new Map()), g = me(/* @__PURE__ */ new Map()), p = me(null), y = me(!1), v = me(1), m = me(!0), b = me("viridis"), S = me(50), x = me(800), _ = me(600), C = me(/* @__PURE__ */ new Map()), k = me(/* @__PURE__ */ new Map()), M = me(null), O = me(null), F = me(null), $ = me(/* @__PURE__ */ new Map()), ne = me(/* @__PURE__ */ new Map()), oe = me(!1), z = me(!1), X = Oe(() => n.depthMap !== null), T = Oe(() => n.currentTool === "pen"), H = Oe(() => {
      const q = n.selectedLayer;
      if ((q == null ? void 0 : q.type) === "spline")
        return q.id;
      if (T.value && n.layers.filter((de) => de.type === "spline").length === 0)
        return null;
      if (T.value) {
        const de = n.layers.filter((ye) => ye.type === "spline");
        return de.length > 0 ? de[de.length - 1].id : null;
      }
      return null;
    }), ge = Oe(() => {
      var de;
      const q = (de = a.value) == null ? void 0 : de.viewportTransform;
      return q ? Array.from(q) : [1, 0, 0, 1, 0, 0];
    });
    Rt(() => {
      if (!r.value || !s.value) return;
      const q = s.value, de = q.getBoundingClientRect();
      x.value = de.width, _.value = de.height, a.value = new $l(r.value, {
        width: de.width,
        height: de.height,
        backgroundColor: "#1a1a1a",
        selection: !0,
        preserveObjectStacking: !0
      }), K(), Wn(() => {
        re();
      }), new ResizeObserver(J).observe(q), ut(() => n.sourceImage, ee, { immediate: !0 }), ut(() => n.depthMap, ve, { immediate: !0 }), ut(() => n.layers, () => {
        N(), ae(), te(), fe(), U(), w();
      }, { deep: !0, immediate: !0 }), ut(() => n.currentFrame, () => {
        N(), ae(), te(), fe();
      }), ut(() => [n.width, n.height], ie, { immediate: !1 }), M.value = document.createElement("canvas"), O.value = M.value.getContext("2d"), L();
    }), pn(() => {
      var q;
      F.value !== null && cancelAnimationFrame(F.value), C.value.forEach((de) => de.reset()), C.value.clear(), k.value.forEach((de) => de.dispose()), k.value.clear(), d.value.clear(), c.value.clear(), f.value.clear(), g.value.clear(), (q = a.value) == null || q.dispose();
    });
    function K() {
      const q = a.value;
      if (!q) return;
      q.on("mouse:wheel", (Ce) => {
        const Pe = Ce.e.deltaY;
        let je = q.getZoom() * (Pe > 0 ? 0.9 : 1.1);
        je = Math.min(Math.max(je, 0.1), 10);
        const Ge = new we(Ce.e.offsetX, Ce.e.offsetY);
        q.zoomToPoint(Ge, je), v.value = je, Ce.e.preventDefault(), Ce.e.stopPropagation();
      });
      let de = !1, ye = !1, Ee = 0, Le = 0, ze = 0, ke = 1;
      q.on("mouse:down", (Ce) => {
        const Pe = Ce.e, je = n.currentTool;
        if (je === "hand" || Pe.button === 1 || Pe.button === 0 && Pe.altKey) {
          de = !0, Ee = Pe.clientX, Le = Pe.clientY, q.selection = !1, q.defaultCursor = "grabbing";
          return;
        }
        if (je === "zoom") {
          if (Pe.shiftKey) {
            const Ge = Math.max(q.getZoom() * 0.7, 0.1), ct = new we(Pe.offsetX, Pe.offsetY);
            q.zoomToPoint(ct, Ge), v.value = Ge;
          } else
            ye = !0, ze = Pe.clientY, ke = q.getZoom();
          return;
        }
        if (je === "text") {
          const Ge = q.getScenePoint(Pe), ct = n.createLayer("text");
          ct.transform && ct.transform.position && (ct.transform.position.value = { x: Ge.x, y: Ge.y }), n.updateLayer(ct.id, {
            transform: {
              ...ct.transform,
              position: {
                ...ct.transform.position,
                value: { x: Ge.x, y: Ge.y }
              }
            }
          }), n.selectLayer(ct.id), n.setTool("select"), ae();
          return;
        }
      }), q.on("mouse:move", (Ce) => {
        const Pe = Ce.e;
        if (de) {
          const Ge = q.viewportTransform;
          Ge && (Ge[4] += Pe.clientX - Ee, Ge[5] += Pe.clientY - Le, q.requestRenderAll()), Ee = Pe.clientX, Le = Pe.clientY;
          return;
        }
        if (ye) {
          const ct = 1 + (ze - Pe.clientY) * 0.01, St = Math.max(0.1, Math.min(10, ke * ct));
          q.setZoom(St), v.value = St, q.requestRenderAll();
          return;
        }
        const je = n.currentTool;
        je === "hand" ? q.defaultCursor = "grab" : je === "zoom" ? q.defaultCursor = "zoom-in" : je === "text" ? q.defaultCursor = "text" : je === "pen" ? q.defaultCursor = "crosshair" : q.defaultCursor = "default";
      }), q.on("mouse:up", () => {
        de && (de = !1, q.selection = !0, q.defaultCursor = n.currentTool === "hand" ? "grab" : "default"), ye && (ye = !1);
      }), q.on("selection:created", (Ce) => {
        var je;
        const Pe = (je = Ce.selected) == null ? void 0 : je[0];
        Pe && Pe.layerId && n.selectLayer(Pe.layerId);
      }), q.on("selection:updated", (Ce) => {
        var je;
        const Pe = (je = Ce.selected) == null ? void 0 : je[0];
        Pe && Pe.layerId && n.selectLayer(Pe.layerId);
      }), q.on("selection:cleared", () => {
        n.clearSelection();
      });
    }
    function re() {
      const q = a.value;
      if (!q) return;
      const de = n.width || 1920, ye = n.height || 1080;
      p.value && q.remove(p.value), p.value = new At({
        left: 0,
        top: 0,
        width: de,
        height: ye,
        fill: "transparent",
        stroke: "#4a90d9",
        strokeWidth: 2,
        selectable: !1,
        evented: !1,
        strokeUniform: !0
      }), q.add(p.value), q.sendObjectToBack(p.value), be(), q.requestRenderAll();
    }
    function ie() {
      const q = a.value;
      if (!q || !p.value) return;
      const de = n.width || 1920, ye = n.height || 1080;
      p.value.set({ width: de, height: ye }), p.value.setCoords(), be(), q.requestRenderAll();
    }
    function be() {
      const q = a.value, de = s.value;
      if (!q || !de) return;
      const ye = n.width || 1920, Ee = n.height || 1080, Le = de.getBoundingClientRect(), ze = 60, ke = (Le.width - ze * 2) / ye, Ce = (Le.height - ze * 2) / Ee, Pe = Math.min(ke, Ce, 1), je = q.viewportTransform;
      je && (je[0] = Pe, je[3] = Pe, je[4] = (Le.width - ye * Pe) / 2, je[5] = (Le.height - Ee * Pe) / 2), v.value = Pe;
    }
    function J(q) {
      const de = a.value;
      if (!(!de || !de.lowerCanvasEl)) {
        for (const ye of q) {
          const { width: Ee, height: Le } = ye.contentRect;
          Ee > 0 && Le > 0 && (de.setDimensions({ width: Ee, height: Le }), x.value = Ee, _.value = Le);
        }
        de.requestRenderAll();
      }
    }
    async function ee(q) {
      const de = a.value;
      if (!(!de || !q)) {
        y.value = !0;
        try {
          l.value && de.remove(l.value);
          const ye = await P(q);
          l.value = new sn(ye, { selectable: !1, evented: !1, left: 0, top: 0 }), de.add(l.value), de.sendObjectToBack(l.value), Y();
        } catch (ye) {
          console.error("[CompositionCanvas] Failed to load source image:", ye);
        } finally {
          y.value = !1;
        }
      }
    }
    async function ve(q) {
      const de = a.value;
      if (!(!de || !q))
        try {
          if (u.value && de.remove(u.value), u.value = await la.fromBase64(q, {
            colormap: b.value,
            opacity: S.value / 100,
            visible: m.value
          }), u.value.set({ selectable: !1, evented: !1, left: 0, top: 0 }), de.add(u.value), l.value) {
            const ye = de.getObjects().indexOf(l.value);
            de.moveObjectTo(u.value, ye + 1);
          }
          de.requestRenderAll();
        } catch (ye) {
          console.error("[CompositionCanvas] Failed to load depth map:", ye);
        }
    }
    function G(q, de) {
      return q ? ns(q, n.currentFrame) : de;
    }
    function N() {
      var Ee, Le, ze;
      const q = a.value;
      if (!q) return;
      const de = n.layers.filter((ke) => ke.type === "spline");
      for (const ke of de) {
        const Ce = ke.data;
        if (!Ce) continue;
        let Pe = c.value.get(ke.id);
        const je = G((Ee = ke.transform) == null ? void 0 : Ee.position, { x: 0, y: 0 }), Ge = G((Le = ke.transform) == null ? void 0 : Le.scale, { x: 1, y: 1 }), ct = G((ze = ke.transform) == null ? void 0 : ze.rotation, 0), St = G(ke.opacity, 100) / 100;
        Pe ? (Pe.controlPoints = Ce.controlPoints || [], Pe.set({
          stroke: Ce.stroke,
          strokeWidth: Ce.strokeWidth,
          fill: Ce.fill
        })) : (Pe = new ua("", {
          stroke: Ce.stroke || "#00ff00",
          strokeWidth: Ce.strokeWidth || 2,
          fill: Ce.fill || "",
          controlPoints: Ce.controlPoints || [],
          selectable: !ke.locked
        }), Pe.layerId = ke.id, c.value.set(ke.id, Pe), q.add(Pe)), Pe.set({
          left: je.x,
          top: je.y,
          scaleX: Ge.x,
          scaleY: Ge.y,
          angle: ct,
          opacity: St,
          visible: ke.visible,
          selectable: !ke.locked
        }), Pe.updatePathFromControlPoints(), Pe.setCoords();
      }
      const ye = new Set(de.map((ke) => ke.id));
      for (const [ke, Ce] of c.value)
        ye.has(ke) || (q.remove(Ce), c.value.delete(ke));
      q.requestRenderAll();
    }
    function te() {
      var Ee, Le, ze;
      const q = a.value;
      if (!q) return;
      const de = n.layers.filter((ke) => ke.type === "solid");
      f.value || (f.value = /* @__PURE__ */ new Map());
      for (const ke of de) {
        let Ce = f.value.get(ke.id);
        const Pe = G((Ee = ke.transform) == null ? void 0 : Ee.position, { x: 0, y: 0 }), je = G((Le = ke.transform) == null ? void 0 : Le.scale, { x: 1, y: 1 }), Ge = G((ze = ke.transform) == null ? void 0 : ze.rotation, 0), ct = G(ke.opacity, 100) / 100, St = ke.data, Ut = (St == null ? void 0 : St.color) || "#808080", Vt = n.width || 1920, jt = n.height || 1080;
        Ce ? Ce.set({ fill: Ut, width: Vt, height: jt }) : (Ce = new At({
          left: Pe.x,
          top: Pe.y,
          width: Vt,
          height: jt,
          fill: Ut,
          selectable: !ke.locked,
          evented: !ke.locked
        }), Ce.layerId = ke.id, f.value.set(ke.id, Ce), q.add(Ce)), Ce.set({
          left: Pe.x,
          top: Pe.y,
          scaleX: je.x,
          scaleY: je.y,
          angle: Ge,
          opacity: ct,
          visible: ke.visible,
          selectable: !ke.locked
        }), Ce.setCoords();
      }
      const ye = new Set(de.map((ke) => ke.id));
      for (const [ke, Ce] of f.value)
        ye.has(ke) || (q.remove(Ce), f.value.delete(ke));
      q.requestRenderAll();
    }
    function fe() {
      var Ee, Le, ze;
      const q = a.value;
      if (!q) return;
      const de = n.layers.filter((ke) => ke.type === "null");
      g.value || (g.value = /* @__PURE__ */ new Map());
      for (const ke of de) {
        let Ce = g.value.get(ke.id);
        const Pe = G((Ee = ke.transform) == null ? void 0 : Ee.position, { x: 0, y: 0 }), je = G((Le = ke.transform) == null ? void 0 : Le.scale, { x: 1, y: 1 }), Ge = G((ze = ke.transform) == null ? void 0 : ze.rotation, 0), ct = G(ke.opacity, 100) / 100, St = (n.width || 1920) / 2, Ut = (n.height || 1080) / 2, Vt = Pe.x !== void 0 && Pe.x !== null ? Pe.x : St, jt = Pe.y !== void 0 && Pe.y !== null ? Pe.y : Ut, Dt = 40;
        if (!Ce) {
          const _n = new At({
            left: Vt - Dt / 2,
            top: jt - 1,
            width: Dt,
            height: 2,
            fill: "#ff9900",
            selectable: !1,
            evented: !1
          }), wt = new At({
            left: Vt - 1,
            top: jt - Dt / 2,
            width: 2,
            height: Dt,
            fill: "#ff9900",
            selectable: !1,
            evented: !1
          });
          _n.layerId = ke.id, wt.layerId = ke.id, g.value.set(ke.id, { h: _n, v: wt }), q.add(_n), q.add(wt), Ce = { h: _n, v: wt };
        }
        Ce.h.set({
          left: Vt - Dt * je.x / 2,
          top: jt - 1,
          width: Dt * je.x,
          scaleX: 1,
          scaleY: je.y,
          angle: Ge,
          opacity: ct,
          visible: ke.visible
        }), Ce.v.set({
          left: Vt - 1,
          top: jt - Dt * je.y / 2,
          width: 2,
          height: Dt * je.y,
          scaleX: je.x,
          scaleY: 1,
          angle: Ge,
          opacity: ct,
          visible: ke.visible
        }), Ce.h.setCoords(), Ce.v.setCoords();
      }
      const ye = new Set(de.map((ke) => ke.id));
      for (const [ke, Ce] of g.value)
        ye.has(ke) || (q.remove(Ce.h), q.remove(Ce.v), g.value.delete(ke));
      q.requestRenderAll();
    }
    function ae() {
      var Ee, Le, ze;
      const q = a.value;
      if (!q) return;
      const de = n.layers.filter((ke) => ke.type === "text");
      for (const ke of de) {
        const Ce = ke.data;
        if (!Ce) continue;
        let Pe = d.value.get(ke.id);
        const je = G((Ee = ke.transform) == null ? void 0 : Ee.position, { x: 0, y: 0 }), Ge = G((Le = ke.transform) == null ? void 0 : Le.scale, { x: 1, y: 1 }), ct = G((ze = ke.transform) == null ? void 0 : ze.rotation, 0), St = G(ke.opacity, 100) / 100, Ut = (n.width || 1920) / 2, Vt = (n.height || 1080) / 2, jt = je.x !== void 0 && je.x !== null ? je.x : Ut, Dt = je.y !== void 0 && je.y !== null ? je.y : Vt;
        Pe ? (Ce.text !== Pe.textContent && Pe.setText(Ce.text || "Text"), (Ce.fontFamily !== Pe.fontFamily || Ce.fontSize !== Pe.fontSize || Ce.fontWeight !== Pe.fontWeight) && Pe.setFont(Ce.fontFamily || "Arial", Ce.fontSize || 48, Ce.fontWeight || "400"), Ce.fill !== Pe.textFill && Pe.setFillColor(Ce.fill || "#ffffff"), (Ce.stroke !== Pe.textStroke || Ce.strokeWidth !== Pe.textStrokeWidth) && Pe.setStroke(Ce.stroke || "", Ce.strokeWidth || 0), Ce.letterSpacing !== Pe.letterSpacing && Pe.setLetterSpacing(Ce.letterSpacing || 0), Pe.pathLayerId = Ce.pathLayerId || null, Pe.pathOffset = Ce.pathOffset || 0) : (Pe = new ca({
          text: Ce.text || "Text",
          fontFamily: Ce.fontFamily || "Arial",
          fontSize: Ce.fontSize || 48,
          fontWeight: Ce.fontWeight || "400",
          fill: Ce.fill || "#ffffff",
          stroke: Ce.stroke || "",
          strokeWidth: Ce.strokeWidth || 0,
          letterSpacing: Ce.letterSpacing || 0,
          pathLayerId: Ce.pathLayerId,
          pathOffset: Ce.pathOffset || 0,
          selectable: !ke.locked
        }), Pe.layerId = ke.id, d.value.set(ke.id, Pe), q.add(Pe), Pe.setText(Pe.textContent), q.bringObjectToFront(Pe)), Pe.set({
          left: jt,
          top: Dt,
          originX: "center",
          originY: "center",
          scaleX: Ge.x,
          scaleY: Ge.y,
          angle: ct,
          opacity: St,
          visible: ke.visible,
          selectable: !ke.locked
        }), Pe.setCoords();
      }
      const ye = new Set(de.map((ke) => ke.id));
      for (const [ke, Ce] of d.value)
        ye.has(ke) || (q.remove(Ce), d.value.delete(ke));
      q.requestRenderAll();
    }
    function D(q) {
      if (!H.value) {
        const de = n.createLayer("spline");
        n.selectLayer(de.id);
      }
    }
    function R() {
      N();
    }
    ut(m, (q) => {
      var de;
      u.value && (u.value.set("visible", q), (de = a.value) == null || de.requestRenderAll());
    }), ut(b, (q) => {
      u.value && u.value.setColormap(q);
    }), ut(S, (q) => {
      var de;
      u.value && (u.value.set("opacity", q / 100), (de = a.value) == null || de.requestRenderAll());
    });
    function P(q) {
      return new Promise((de, ye) => {
        const Ee = new Image();
        Ee.crossOrigin = "anonymous", Ee.onload = () => de(Ee), Ee.onerror = ye, Ee.src = q.startsWith("data:") ? q : `data:image/png;base64,${q}`;
      });
    }
    function Y() {
      const q = a.value, de = s.value;
      if (!q || !de || !l.value) return;
      const ye = de.getBoundingClientRect(), Ee = l.value.width || 1, Le = l.value.height || 1, ze = 40, ke = (ye.width - ze * 2) / Ee, Ce = (ye.height - ze * 2) / Le, Pe = Math.min(ke, Ce, 1), je = q.viewportTransform;
      je && (je[0] = Pe, je[3] = Pe, je[4] = (ye.width - Ee * Pe) / 2, je[5] = (ye.height - Le * Pe) / 2), v.value = Pe, q.requestRenderAll();
    }
    function U() {
      var ye;
      const q = n.layers.filter((Ee) => Ee.type === "particles"), de = new Set(q.map((Ee) => Ee.id));
      for (const Ee of q)
        if (C.value.has(Ee.id)) {
          const Le = C.value.get(Ee.id), ze = Ee.data;
          if (ze) {
            Le.setConfig(ze.systemConfig);
            const ke = Le.getEmitters();
            for (const Ce of ze.emitters)
              ke.find((je) => je.id === Ce.id) ? Le.updateEmitter(Ce.id, Ce) : Le.addEmitter(Ce);
          }
        } else {
          const Le = Ee.data;
          if (Le) {
            const ze = new Ra(Le.systemConfig);
            Le.emitters.forEach((ke) => ze.addEmitter(ke)), Le.gravityWells.forEach((ke) => ze.addGravityWell(ke)), Le.vortices.forEach((ke) => ze.addVortex(ke)), Le.modulations.forEach((ke) => ze.addModulation(ke)), C.value.set(Ee.id, ze);
          }
        }
      for (const [Ee] of C.value)
        de.has(Ee) || ((ye = C.value.get(Ee)) == null || ye.reset(), C.value.delete(Ee));
    }
    function w() {
      var ye;
      const q = n.layers.filter((Ee) => Ee.type === "depthflow"), de = new Set(q.map((Ee) => Ee.id));
      for (const Ee of q)
        if (k.value.has(Ee.id)) {
          const Le = k.value.get(Ee.id), ze = Ee.data;
          ze && Le.setConfig(ze.config);
        } else {
          const Le = Ee.data;
          if (Le) {
            const ze = new DO();
            ze.setConfig(Le.config), k.value.set(Ee.id, ze);
          }
        }
      for (const [Ee] of k.value)
        de.has(Ee) || ((ye = k.value.get(Ee)) == null || ye.dispose(), k.value.delete(Ee));
    }
    function L() {
      const q = () => {
        (n.isPlaying || n.audioAnalysis) && j(), n.isPlaying && A(), Z(), E(), Q(), F.value = requestAnimationFrame(q);
      };
      F.value = requestAnimationFrame(q);
    }
    function A() {
      var de;
      const q = ((de = n.audioAnalysis) == null ? void 0 : de.onsets.includes(n.currentFrame)) ?? !1;
      C.value.forEach((ye, Ee) => {
        const Le = n.getActiveMappingsForLayer(Ee);
        for (const ze of Le) {
          const Ce = n.getAudioFeatureAtFrame(ze.feature) * ze.sensitivity, Pe = ze.target.split("."), je = Pe.length > 1 ? Pe[1] : ze.target;
          ye.setFeatureValue(je, Ce, ze.targetEmitterId);
        }
        q && ye.triggerAllBursts(), ye.step(1);
      });
    }
    function E() {
      const q = a.value;
      if (!q || !M.value || !O.value) return;
      const de = n.layers.filter((Le) => Le.type === "particles" && Le.visible);
      if (de.length === 0) return;
      (M.value.width !== q.width || M.value.height !== q.height) && (M.value.width = q.width || 800, M.value.height = q.height || 600);
      const ye = O.value;
      ye.clearRect(0, 0, M.value.width, M.value.height);
      for (const Le of de) {
        const ze = C.value.get(Le.id), ke = Le.data;
        if (ze && ke) {
          ye.save();
          const Ce = q.viewportTransform;
          Ce && ye.transform(Ce[0], Ce[1], Ce[2], Ce[3], Ce[4], Ce[5]), ze.renderToCanvas(ye, n.width, n.height, ke.renderOptions), ye.restore();
        }
      }
      const Ee = q.getContext();
      Ee && de.length > 0 && Ee.drawImage(M.value, 0, 0);
    }
    function I(q) {
      const de = C.value.get(q);
      return (de == null ? void 0 : de.getParticleCount()) ?? 0;
    }
    function j() {
      n.updatePathAnimators();
      for (const q of n.layers) {
        const de = n.getPathAnimator(q.id);
        de && $.value.set(q.id, de.getState());
      }
    }
    function Q() {
      const q = a.value;
      if (!q || !M.value || !O.value) return;
      const de = n.layers.filter((Ee) => Ee.type === "text" && Ee.visible);
      if (de.length === 0) return;
      const ye = O.value;
      for (const Ee of de) {
        const Le = Ee.data;
        if (!(Le != null && Le.pathLayerId)) continue;
        const ze = n.getPathAnimator(Ee.id);
        if (!ze) continue;
        const ke = $.value.get(Ee.id);
        if (!ke) continue;
        const Ce = n.layers.find((St) => St.id === Le.pathLayerId);
        if (!Ce) continue;
        const Pe = Ce.data;
        if (!(Pe != null && Pe.pathData)) continue;
        ye.save();
        const je = q.viewportTransform;
        je && ye.transform(je[0], je[1], je[2], je[3], je[4], je[5]);
        const Ge = ze.getConfig(), ct = Math.abs(ke.position - ke.previousPosition);
        if (Ge.motionBlur && ct > 1e-3) {
          const St = ze.getMotionBlurTrail(8);
          ye.lineCap = "round", ye.lineJoin = "round";
          for (let Ut = 0; Ut < St.length - 1; Ut++) {
            const Vt = St[Ut], jt = St[Ut + 1], Dt = Vt.opacity * Ge.motionBlurStrength * 0.5;
            ye.strokeStyle = `rgba(255, 255, 255, ${Dt})`, ye.lineWidth = Math.max(2, (Le.fontSize || 48) * 0.1 * (1 - Ut / St.length)), ye.beginPath(), ye.moveTo(Vt.x, Vt.y), ye.lineTo(jt.x, jt.y), ye.stroke();
          }
        }
        ye.restore();
      }
    }
    function ce(q) {
      const de = n.getPathAnimator(q);
      if (!de) return null;
      const ye = $.value.get(q);
      if (!ye) return null;
      const Ee = de.getPositionOnPath(ye.position);
      return { x: Ee.x, y: Ee.y, angle: Ee.angle };
    }
    function Z() {
      if (!a.value) return;
      const de = n.currentFrame;
      for (const ye of n.layers) {
        if (!ye.visible || !ye.effects || !zO(ye.effects)) continue;
        let Ee = null;
        if (ye.type === "spline" ? Ee = c.value.get(ye.id) : ye.type === "text" && (Ee = d.value.get(ye.id)), !Ee) continue;
        const Le = xe(Ee);
        if (!Le) continue;
        const ze = FO(ye.effects, Le, de);
        ne.value.set(ye.id, ze.canvas), Me(Ee, ze.canvas);
      }
    }
    function xe(q) {
      const de = q.getBoundingRect();
      if (de.width <= 0 || de.height <= 0) return null;
      const ye = document.createElement("canvas");
      ye.width = Math.ceil(de.width), ye.height = Math.ceil(de.height);
      const Ee = ye.getContext("2d");
      if (!Ee) return null;
      const Le = q.left || 0, ze = q.top || 0;
      return q.set({ left: -de.left, top: -de.top }), q.render(Ee), q.set({ left: Le, top: ze }), ye;
    }
    function Me(q, de) {
      var ye;
      q._effectCanvas = de, (ye = a.value) == null || ye.requestRenderAll();
    }
    function Se() {
      const q = a.value;
      if (!q) return;
      const de = n.width || 1920, ye = n.height || 1080;
      if (q.getObjects().filter((Le) => Le.isGridOrGuide).forEach((Le) => q.remove(Le)), oe.value) {
        for (let ze = 0; ze <= de; ze += 100) {
          const ke = new At({ left: ze, top: 0, width: 1, height: ye, fill: "rgba(80, 80, 80, 0.4)", selectable: !1, evented: !1 });
          ke.isGridOrGuide = !0, q.add(ke), q.sendObjectToBack(ke);
        }
        for (let ze = 0; ze <= ye; ze += 100) {
          const ke = new At({ left: 0, top: ze, width: de, height: 1, fill: "rgba(80, 80, 80, 0.4)", selectable: !1, evented: !1 });
          ke.isGridOrGuide = !0, q.add(ke), q.sendObjectToBack(ke);
        }
      }
      if (z.value) {
        [de / 3, de * 2 / 3].forEach((je) => {
          const Ge = new At({ left: je, top: 0, width: 1, height: ye, fill: "rgba(0, 180, 255, 0.4)", selectable: !1, evented: !1 });
          Ge.isGridOrGuide = !0, q.add(Ge);
        }), [ye / 3, ye * 2 / 3].forEach((je) => {
          const Ge = new At({ left: 0, top: je, width: de, height: 1, fill: "rgba(0, 180, 255, 0.4)", selectable: !1, evented: !1 });
          Ge.isGridOrGuide = !0, q.add(Ge);
        });
        const Le = de / 2, ze = ye / 2, ke = 30, Ce = new At({ left: Le - ke, top: ze, width: ke * 2, height: 1, fill: "rgba(255, 100, 100, 0.6)", selectable: !1, evented: !1 }), Pe = new At({ left: Le, top: ze - ke, width: 1, height: ke * 2, fill: "rgba(255, 100, 100, 0.6)", selectable: !1, evented: !1 });
        Ce.isGridOrGuide = !0, Pe.isGridOrGuide = !0, q.add(Ce), q.add(Pe);
      }
      p.value && q.bringObjectForward(p.value), q.requestRenderAll();
    }
    return ut(oe, Se), ut(z, Se), e({
      fabricCanvas: a,
      fitToView: Y,
      zoom: v,
      showGrid: oe,
      showGuides: z,
      renderGridAndGuides: Se,
      particleSystems: C,
      depthflowRenderers: k,
      textObjects: d,
      splineObjects: c,
      solidObjects: f,
      nullObjects: g,
      getParticleCount: I,
      getTextPathPosition: ce,
      pathAnimationStates: $,
      effectCanvases: ne
    }), (q, de) => (V(), B("div", {
      class: "composition-canvas",
      ref_key: "containerRef",
      ref: s
    }, [
      h("canvas", {
        ref_key: "canvasRef",
        ref: r
      }, null, 512),
      H.value || T.value ? (V(), ot(wO, {
        key: 0,
        layerId: H.value,
        canvasWidth: x.value,
        canvasHeight: _.value,
        zoom: v.value,
        viewportTransform: ge.value,
        isPenMode: T.value,
        onPointAdded: D,
        onPathUpdated: R,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Te("", !0),
      X.value ? (V(), B("div", RO, [
        h("label", null, [
          tt(h("input", {
            type: "checkbox",
            "onUpdate:modelValue": de[0] || (de[0] = (ye) => m.value = ye)
          }, null, 512), [
            [No, m.value]
          ]),
          de[3] || (de[3] = qe(" Depth Overlay ", -1))
        ]),
        tt(h("select", {
          "onUpdate:modelValue": de[1] || (de[1] = (ye) => b.value = ye),
          class: "colormap-select"
        }, [...de[4] || (de[4] = [
          h("option", { value: "viridis" }, "Viridis", -1),
          h("option", { value: "plasma" }, "Plasma", -1),
          h("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [nn, b.value]
        ]),
        tt(h("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": de[2] || (de[2] = (ye) => S.value = ye),
          class: "opacity-slider"
        }, null, 512), [
          [
            $t,
            S.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Te("", !0),
      y.value ? (V(), B("div", VO, [...de[5] || (de[5] = [
        h("div", { class: "loading-spinner" }, null, -1),
        h("span", null, "Loading...", -1)
      ])])) : Te("", !0)
    ], 512));
  }
}), $O = /* @__PURE__ */ mt(jO, [["__scopeId", "data-v-c01c58b2"]]), BO = { class: "prop-wrapper" }, WO = { class: "prop-content" }, UO = { class: "prop-name" }, NO = { class: "prop-value-container" }, HO = {
  key: 3,
  class: "val-display"
}, XO = {
  key: 1,
  class: "prop-track"
}, YO = ["onMousedown", "onClick"], GO = /* @__PURE__ */ pt({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "viewMode", "frameCount", "selectedPropertyIds", "pixelsPerFrame", "gridStyle"],
  emits: ["selectProperty", "selectKeyframe"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = Oe(() => `${n.layerId}-${n.propertyPath}`), a = Oe(() => {
      var v;
      return (v = n.selectedPropertyIds) == null ? void 0 : v.includes(o.value);
    });
    function l(v) {
      if (typeof v == "number") return v.toFixed(1);
      if (typeof v == "object") {
        if ((v == null ? void 0 : v.z) !== void 0) return `${v.x.toFixed(0)},${v.y.toFixed(0)},${v.z.toFixed(0)}`;
        if ((v == null ? void 0 : v.x) !== void 0) return `${v.x.toFixed(0)},${v.y.toFixed(0)}`;
      }
      return String(v);
    }
    const u = Oe(() => {
      var v;
      return (v = n.property.keyframes) == null ? void 0 : v.some((m) => m.frame === r.currentFrame);
    });
    function c() {
      r.setPropertyAnimated(n.layerId, n.propertyPath, !n.property.animated);
    }
    function d() {
      r.addKeyframe(n.layerId, n.propertyPath, n.property.value);
    }
    function f(v) {
      s("selectProperty", o.value, v.shiftKey);
    }
    function g(v) {
      r.setPropertyValue(n.layerId, n.propertyPath, v);
    }
    function p(v, m) {
      let b = n.property.value;
      typeof b == "number" ? b = m : typeof b == "object" && b !== null && (b = { ...b }, v === 0 && (b.x = m), v === 1 && (b.y = m), v === 2 && b.z !== void 0 && (b.z = m)), r.setPropertyValue(n.layerId, n.propertyPath, b);
    }
    function y(v, m) {
      m.stopPropagation();
      const b = n.pixelsPerFrame || 5, S = m.clientX, x = v.frame, _ = (k) => {
        const M = k.clientX - S, O = Math.round(M / b), F = Math.max(0, Math.min(n.frameCount - 1, x + O));
        F !== v.frame && r.moveKeyframe(n.layerId, n.propertyPath, v.id, F);
      }, C = () => {
        window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", C);
      };
      window.addEventListener("mousemove", _), window.addEventListener("mouseup", C), s("selectKeyframe", v.id, !0);
    }
    return (v, m) => {
      var b, S, x;
      return V(), B("div", BO, [
        i.layoutMode === "sidebar" ? (V(), B("div", {
          key: 0,
          class: Ie(["prop-sidebar", { selected: a.value }]),
          style: Xe(i.gridStyle),
          onClick: f
        }, [
          m[6] || (m[6] = h("div", { class: "indent-spacer" }, null, -1)),
          h("div", {
            class: "icon-box",
            onClick: Je(d, ["stop"]),
            title: "Add Keyframe"
          }, [
            h("span", {
              class: Ie(["kf-btn", { active: u.value }])
            }, "", 2)
          ]),
          h("div", {
            class: "icon-box",
            onClick: Je(c, ["stop"])
          }, [
            h("span", {
              class: Ie(["stopwatch", { active: i.property.animated }])
            }, "", 2)
          ]),
          h("div", WO, [
            h("span", UO, pe(i.name), 1),
            h("div", NO, [
              typeof i.property.value == "number" ? (V(), ot(Ne, {
                key: 0,
                modelValue: i.property.value,
                "onUpdate:modelValue": m[0] || (m[0] = (_) => g(_)),
                precision: 1,
                sensitivity: 0.5
              }, null, 8, ["modelValue"])) : ((b = i.property.value) == null ? void 0 : b.x) !== void 0 && ((S = i.property.value) == null ? void 0 : S.z) === void 0 ? (V(), B(Re, { key: 1 }, [
                Ae(Ne, {
                  modelValue: i.property.value.x,
                  "onUpdate:modelValue": m[1] || (m[1] = (_) => p(0, _)),
                  precision: 0,
                  sensitivity: 1
                }, null, 8, ["modelValue"]),
                Ae(Ne, {
                  modelValue: i.property.value.y,
                  "onUpdate:modelValue": m[2] || (m[2] = (_) => p(1, _)),
                  precision: 0,
                  sensitivity: 1
                }, null, 8, ["modelValue"])
              ], 64)) : ((x = i.property.value) == null ? void 0 : x.z) !== void 0 ? (V(), B(Re, { key: 2 }, [
                Ae(Ne, {
                  modelValue: i.property.value.x,
                  "onUpdate:modelValue": m[3] || (m[3] = (_) => p(0, _)),
                  precision: 0,
                  sensitivity: 1
                }, null, 8, ["modelValue"]),
                Ae(Ne, {
                  modelValue: i.property.value.y,
                  "onUpdate:modelValue": m[4] || (m[4] = (_) => p(1, _)),
                  precision: 0,
                  sensitivity: 1
                }, null, 8, ["modelValue"]),
                Ae(Ne, {
                  modelValue: i.property.value.z,
                  "onUpdate:modelValue": m[5] || (m[5] = (_) => p(2, _)),
                  precision: 0,
                  sensitivity: 1
                }, null, 8, ["modelValue"])
              ], 64)) : (V(), B("span", HO, pe(l(i.property.value)), 1))
            ])
          ]),
          m[7] || (m[7] = h("div", { class: "col-spacer" }, null, -1)),
          m[8] || (m[8] = h("div", { class: "col-spacer" }, null, -1))
        ], 6)) : i.layoutMode === "track" ? (V(), B("div", XO, [
          m[9] || (m[9] = h("div", { class: "track-bg" }, null, -1)),
          i.viewMode === "keyframes" ? (V(!0), B(Re, { key: 0 }, Ue(i.property.keyframes, (_) => (V(), B("div", {
            key: _.id,
            class: "keyframe",
            style: Xe({ left: `${_.frame * i.pixelsPerFrame}px` }),
            onMousedown: Je((C) => y(_, C), ["stop"]),
            onClick: Je((C) => v.$emit("selectKeyframe", _.id, !0), ["stop"])
          }, null, 44, YO))), 128)) : Te("", !0)
        ])) : Te("", !0)
      ]);
    };
  }
}), gd = /* @__PURE__ */ mt(GO, [["__scopeId", "data-v-e8899cc2"]]), KO = {
  key: 0,
  class: "track-wrapper"
}, qO = { class: "arrow" }, ZO = { class: "layer-id" }, JO = { key: 0 }, QO = {
  key: 1,
  class: "dim"
}, e3 = { key: 0 }, t3 = {
  key: 1,
  class: "dim"
}, n3 = {
  key: 0,
  class: "name-text"
}, s3 = { class: "col-mode" }, i3 = ["value"], r3 = { class: "col-parent" }, o3 = ["value"], a3 = ["value"], l3 = {
  key: 0,
  class: "children-container"
}, u3 = ["onClick"], c3 = { class: "arrow-col" }, d3 = { class: "arrow" }, h3 = { class: "group-label" }, f3 = {
  key: 0,
  class: "group-properties"
}, p3 = {
  key: 1,
  class: "track-row-container"
}, m3 = { class: "track-row" }, g3 = {
  key: 0,
  class: "children-container"
}, v3 = ["onClick"], y3 = { class: "group-label-track" }, b3 = {
  key: 0,
  class: "group-properties"
}, x3 = /* @__PURE__ */ pt({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "selectedPropertyIds", "frameCount", "viewMode", "allLayers", "soloedLayerIds", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer", "selectProperty", "selectKeyframe", "toggleSolo", "setParent"],
  setup(i, { emit: e }) {
    const n = i, s = e, r = Ot(), o = me(!1), a = Oe(() => n.isExpandedExternal ?? o.value), l = Oe(() => r.selectedLayerIds.includes(n.layer.id)), u = me(!1), c = me(""), d = me(null), f = me(["Transform", "Text", "Path Options", "More Options", "Advanced"]), g = Oe(() => {
      var re;
      if (n.index !== void 0) return n.index;
      const K = (re = n.allLayers) == null ? void 0 : re.findIndex((ie) => ie.id === n.layer.id);
      return K !== void 0 && K >= 0 ? K + 1 : 1;
    }), p = Oe(() => {
      var be;
      const K = {}, re = n.layer.transform, ie = [];
      return re.anchorPoint && ie.push({ path: "transform.anchorPoint", name: "Anchor Point", property: re.anchorPoint }), re.position && ie.push({ path: "transform.position", name: "Position", property: re.position }), n.layer.threeD && ((be = re.position) == null ? void 0 : be.z) !== void 0 && ie.push({ path: "transform.position.z", name: "Position Z", property: { value: re.position.z || 0, animated: !1, keyframes: [] } }), re.scale && ie.push({ path: "transform.scale", name: "Scale", property: re.scale }), n.layer.threeD ? (re.orientation && ie.push({ path: "transform.orientation", name: "Orientation", property: re.orientation }), re.rotationX && ie.push({ path: "transform.rotationX", name: "X Rotation", property: re.rotationX }), re.rotationY && ie.push({ path: "transform.rotationY", name: "Y Rotation", property: re.rotationY }), re.rotationZ && ie.push({ path: "transform.rotationZ", name: "Z Rotation", property: re.rotationZ })) : re.rotation && ie.push({ path: "transform.rotation", name: "Rotation", property: re.rotation }), n.layer.opacity && ie.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), ie.length > 0 && (K.Transform = ie), n.layer.properties && n.layer.properties.length > 0 && n.layer.properties.forEach((J) => {
        const ee = J.group || "Properties";
        K[ee] || (K[ee] = []), K[ee].push({
          path: J.name,
          name: J.name,
          property: J
        });
      }), n.layer.type === "camera" && re.anchorPoint && !ie.find((J) => J.name === "Anchor Point") && (K.Camera || (K.Camera = []), K.Camera.push({ path: "transform.anchorPoint", name: "Point of Interest", property: re.anchorPoint })), K;
    }), y = Oe(() => {
      const K = [];
      return Object.values(p.value).forEach((re) => {
        K.push(...re);
      }), K;
    }), v = Oe(() => {
      const K = [];
      return y.value.forEach((re) => {
        var ie;
        (ie = re.property) != null && ie.animated && K.push(...re.property.keyframes || []);
      }), K;
    }), m = Oe(() => {
      const K = n.pixelsPerFrame || 5, re = n.layer.inPoint * K, ie = (n.layer.outPoint || n.frameCount) * K;
      return { left: `${re}px`, width: `${ie - re}px` };
    }), b = Oe(() => {
      var K;
      return ((K = n.allLayers) == null ? void 0 : K.filter((re) => re.id !== n.layer.id)) || [];
    });
    function S() {
      s("toggleExpand", n.layer.id, !a.value);
    }
    function x() {
      s("select", n.layer.id);
    }
    function _() {
      s("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function C() {
      s("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function k() {
      r.toggleLayer3D(n.layer.id);
    }
    function M(K) {
      s("updateLayer", n.layer.id, { parentId: K.target.value || null });
    }
    function O(K) {
      s("updateLayer", n.layer.id, { blendMode: K.target.value });
    }
    function F(K) {
      const re = f.value.indexOf(K);
      re >= 0 ? f.value.splice(re, 1) : f.value.push(K);
    }
    function $(K) {
      return {
        solid: "#e74c3c",
        text: "#f1c40f",
        spline: "#2ecc71",
        null: "#9b59b6",
        camera: "#3498db",
        light: "#f39c12",
        particles: "#e91e63",
        depthflow: "#00bcd4",
        image: "#95a5a6"
      }[K] || "#95a5a6";
    }
    function ne(K) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        depthflow: "",
        image: ""
      }[K] || "";
    }
    function oe() {
      u.value = !0, c.value = n.layer.name, Wn(() => {
        var K;
        return (K = d.value) == null ? void 0 : K.focus();
      });
    }
    function z() {
      s("updateLayer", n.layer.id, { name: c.value }), u.value = !1;
    }
    function X(K) {
      const re = n.pixelsPerFrame || 5, ie = K.clientX, be = n.layer.inPoint, ee = (n.layer.outPoint || n.frameCount) - be, ve = (N) => {
        const te = N.clientX - ie, fe = Math.round(te / re), ae = Math.max(0, Math.min(n.frameCount - ee, be + fe)), D = ae + ee;
        s("updateLayer", n.layer.id, { inPoint: ae, outPoint: D });
      }, G = () => {
        window.removeEventListener("mousemove", ve), window.removeEventListener("mouseup", G);
      };
      window.addEventListener("mousemove", ve), window.addEventListener("mouseup", G);
    }
    function T(K) {
      K.stopPropagation();
      const re = n.pixelsPerFrame || 5, ie = K.clientX, be = n.layer.inPoint, J = (ve) => {
        const G = ve.clientX - ie, N = Math.round(G / re), te = Math.max(0, Math.min((n.layer.outPoint || n.frameCount) - 1, be + N));
        s("updateLayer", n.layer.id, { inPoint: te });
      }, ee = () => {
        window.removeEventListener("mousemove", J), window.removeEventListener("mouseup", ee);
      };
      window.addEventListener("mousemove", J), window.addEventListener("mouseup", ee);
    }
    function H(K) {
      K.stopPropagation();
      const re = n.pixelsPerFrame || 5, ie = K.clientX, be = n.layer.outPoint || n.frameCount, J = (ve) => {
        const G = ve.clientX - ie, N = Math.round(G / re), te = Math.max(n.layer.inPoint + 1, Math.min(n.frameCount, be + N));
        s("updateLayer", n.layer.id, { outPoint: te });
      }, ee = () => {
        window.removeEventListener("mousemove", J), window.removeEventListener("mouseup", ee);
      };
      window.addEventListener("mousemove", J), window.addEventListener("mouseup", ee);
    }
    function ge() {
      const K = ["#e74c3c", "#f39c12", "#f1c40f", "#2ecc71", "#3498db", "#9b59b6", "#95a5a6"], re = n.layer.labelColor || "#999", ie = K.indexOf(re), be = K[(ie + 1) % K.length];
      s("updateLayer", n.layer.id, { labelColor: be });
    }
    return ut(() => n.isExpandedExternal, (K) => o.value = K), (K, re) => i.layer ? (V(), B("div", KO, [
      i.layoutMode === "sidebar" ? (V(), B(Re, { key: 0 }, [
        h("div", {
          class: Ie(["sidebar-row", { selected: l.value }]),
          style: Xe(i.gridStyle),
          onClick: x
        }, [
          h("div", {
            class: "arrow-col",
            onClick: Je(S, ["stop"])
          }, [
            h("span", qO, pe(a.value ? "" : ""), 1)
          ]),
          h("div", {
            class: "label-box",
            onClick: Je(ge, ["stop"]),
            style: Xe({ background: i.layer.labelColor || "#999" })
          }, null, 4),
          h("div", ZO, pe(g.value), 1),
          h("div", {
            class: "icon-col",
            onClick: Je(_, ["stop"])
          }, [
            i.layer.visible ? (V(), B("span", JO, "")) : (V(), B("span", QO, ""))
          ]),
          h("div", {
            class: "icon-col",
            onClick: Je(C, ["stop"])
          }, [
            i.layer.locked ? (V(), B("span", e3, "")) : (V(), B("span", t3, ""))
          ]),
          h("div", {
            class: Ie(["icon-col cube-icon", { active: i.layer.threeD }]),
            onClick: Je(k, ["stop"]),
            title: "3D Layer"
          }, [...re[3] || (re[3] = [
            h("span", null, "", -1)
          ])], 2),
          h("div", {
            class: "layer-name-col",
            onDblclick: Je(oe, ["stop"])
          }, [
            h("span", {
              class: "type-icon",
              style: Xe({ color: $(i.layer.type) })
            }, pe(ne(i.layer.type)), 5),
            u.value ? tt((V(), B("input", {
              key: 1,
              "onUpdate:modelValue": re[0] || (re[0] = (ie) => c.value = ie),
              onBlur: z,
              onKeydown: ru(z, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: d
            }, null, 544)), [
              [$t, c.value]
            ]) : (V(), B("span", n3, pe(i.layer.name), 1))
          ], 32),
          h("div", s3, [
            h("select", {
              class: "mini-select",
              value: i.layer.blendMode || "normal",
              onChange: O
            }, [...re[4] || (re[4] = [
              h("option", { value: "normal" }, "Normal", -1),
              h("option", { value: "add" }, "Add", -1),
              h("option", { value: "multiply" }, "Multiply", -1),
              h("option", { value: "screen" }, "Screen", -1)
            ])], 40, i3)
          ]),
          h("div", r3, [
            re[6] || (re[6] = h("span", { class: "pickwhip-icon" }, "@", -1)),
            h("select", {
              value: i.layer.parentId || "",
              onChange: M,
              class: "mini-select"
            }, [
              re[5] || (re[5] = h("option", { value: "" }, "None", -1)),
              (V(!0), B(Re, null, Ue(b.value, (ie) => (V(), B("option", {
                key: ie.id,
                value: ie.id
              }, pe(ie.name), 9, a3))), 128))
            ], 40, o3)
          ])
        ], 6),
        a.value ? (V(), B("div", l3, [
          (V(!0), B(Re, null, Ue(p.value, (ie, be) => (V(), B("div", {
            key: be,
            class: "property-group-section"
          }, [
            h("div", {
              class: "sidebar-row group-header",
              style: Xe(i.gridStyle),
              onClick: (J) => F(be)
            }, [
              h("div", c3, [
                h("span", d3, pe(f.value.includes(be) ? "" : ""), 1)
              ]),
              h("div", h3, pe(be), 1)
            ], 12, u3),
            f.value.includes(be) ? (V(), B("div", f3, [
              (V(!0), B(Re, null, Ue(ie, (J) => (V(), ot(gd, {
                key: J.path,
                layerId: i.layer.id,
                propertyPath: J.path,
                name: J.name,
                property: J.property,
                layoutMode: "sidebar",
                gridStyle: i.gridStyle,
                selectedPropertyIds: i.selectedPropertyIds,
                onSelectProperty: re[1] || (re[1] = (ee, ve) => K.$emit("selectProperty", ee, ve))
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "selectedPropertyIds"]))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : Te("", !0)
      ], 64)) : i.layoutMode === "track" ? (V(), B("div", p3, [
        h("div", m3, [
          h("div", {
            class: "duration-bar",
            style: Xe(m.value),
            onMousedown: Je(X, ["stop"]),
            onClick: Je(x, ["stop"])
          }, [
            h("div", {
              class: "bar-fill",
              style: Xe({ background: i.layer.labelColor || "#777", opacity: l.value ? 0.8 : 0.5 })
            }, null, 4),
            h("div", {
              class: "trim-handle trim-in",
              onMousedown: Je(T, ["stop"])
            }, null, 32),
            h("div", {
              class: "trim-handle trim-out",
              onMousedown: Je(H, ["stop"])
            }, null, 32)
          ], 36),
          (V(!0), B(Re, null, Ue(v.value, (ie) => (V(), B("div", {
            key: ie.id,
            class: "keyframe-marker",
            style: Xe({ left: `${ie.frame * i.pixelsPerFrame}px` })
          }, "", 4))), 128))
        ]),
        a.value ? (V(), B("div", g3, [
          (V(!0), B(Re, null, Ue(p.value, (ie, be) => (V(), B("div", {
            key: be,
            class: "property-group-section"
          }, [
            h("div", {
              class: "track-row group-header-track",
              onClick: (J) => F(be)
            }, [
              h("span", y3, pe(be), 1)
            ], 8, v3),
            f.value.includes(be) ? (V(), B("div", b3, [
              (V(!0), B(Re, null, Ue(ie, (J) => (V(), ot(gd, {
                key: J.path,
                layerId: i.layer.id,
                propertyPath: J.path,
                name: J.name,
                property: J.property,
                layoutMode: "track",
                viewMode: i.viewMode,
                frameCount: i.frameCount,
                pixelsPerFrame: i.pixelsPerFrame,
                selectedKeyframeIds: [],
                onSelectKeyframe: re[2] || (re[2] = (ee, ve) => K.$emit("selectKeyframe", ee, ve))
              }, null, 8, ["layerId", "propertyPath", "name", "property", "viewMode", "frameCount", "pixelsPerFrame"]))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : Te("", !0)
      ])) : Te("", !0)
    ])) : Te("", !0);
  }
}), vd = /* @__PURE__ */ mt(x3, [["__scopeId", "data-v-c7183006"]]), _3 = { class: "graph-toolbar" }, w3 = { class: "graph-mode-toggle" }, S3 = { class: "zoom-controls" }, C3 = { class: "zoom-level" }, k3 = { class: "y-axis" }, T3 = { class: "y-axis-unit" }, M3 = ["onMousedown", "onClick", "title"], O3 = ["onMousedown"], E3 = { class: "handle-line-svg" }, P3 = ["x1", "y1", "x2", "y2", "stroke"], D3 = ["onMousedown"], A3 = { class: "handle-line-svg" }, I3 = ["x1", "y1", "x2", "y2", "stroke"], F3 = /* @__PURE__ */ pt({
  __name: "GraphEditorCanvas",
  props: {
    frameCount: {},
    currentFrame: {},
    selectedPropertyIds: {},
    graphMode: {}
  },
  emits: ["selectKeyframe", "update:graphMode"],
  setup(i, { emit: e }) {
    const n = {
      "Position X": "#ff4d4d",
      // AE Red
      "Position Y": "#4dff4d",
      // AE Blue
      "Scale X": "#ffb34d",
      // Orange
      "Scale Y": "#ffff4d",
      // Yellow
      Rotation: "#d94dff",
      // Purple
      Opacity: "#4dffff"
    }, s = i, r = e, o = Ot(), a = me(null), l = me(null), u = me(null), c = me(5), d = me(0);
    function f(U) {
      return (U - d.value) * c.value;
    }
    function g(U) {
      return U / c.value + d.value;
    }
    function p(U, w) {
      const L = x.value, A = (U - L.min) / (L.max - L.min);
      return w - A * w;
    }
    function y(U, w) {
      const L = x.value, A = (w - U) / w;
      return L.min + A * (L.max - L.min);
    }
    const v = Oe(() => o.selectedKeyframeIds), m = Oe(() => f(s.currentFrame)), b = Oe(() => {
      const U = [];
      return o.layers.forEach((w) => {
        if (w.transform.position.animated && w.transform.position.keyframes.length > 0) {
          const L = w.transform.position;
          U.push({
            id: `${w.id}-position-x`,
            layerId: w.id,
            propertyPath: "transform.position",
            name: "Position X",
            color: n["Position X"],
            keyframes: L.keyframes.map((A) => ({
              ...A,
              value: typeof A.value == "object" ? A.value.x : A.value
            }))
          }), U.push({
            id: `${w.id}-position-y`,
            layerId: w.id,
            propertyPath: "transform.position",
            name: "Position Y",
            color: n["Position Y"],
            keyframes: L.keyframes.map((A) => ({
              ...A,
              value: typeof A.value == "object" ? A.value.y : A.value
            }))
          });
        }
        if (w.transform.scale.animated && w.transform.scale.keyframes.length > 0) {
          const L = w.transform.scale;
          U.push({
            id: `${w.id}-scale-x`,
            layerId: w.id,
            propertyPath: "transform.scale",
            name: "Scale X",
            color: n["Scale X"],
            keyframes: L.keyframes.map((A) => ({
              ...A,
              value: typeof A.value == "object" ? A.value.x : A.value
            }))
          }), U.push({
            id: `${w.id}-scale-y`,
            layerId: w.id,
            propertyPath: "transform.scale",
            name: "Scale Y",
            color: n["Scale Y"],
            keyframes: L.keyframes.map((A) => ({
              ...A,
              value: typeof A.value == "object" ? A.value.y : A.value
            }))
          });
        }
        w.transform.rotation.animated && w.transform.rotation.keyframes.length > 0 && U.push({
          id: `${w.id}-rotation`,
          layerId: w.id,
          propertyPath: "transform.rotation",
          name: "Rotation",
          color: n.Rotation,
          keyframes: w.transform.rotation.keyframes
        }), w.opacity.animated && w.opacity.keyframes.length > 0 && U.push({
          id: `${w.id}-opacity`,
          layerId: w.id,
          propertyPath: "opacity",
          name: "Opacity",
          color: n.Opacity,
          keyframes: w.opacity.keyframes
        });
      }), U;
    }), S = Oe(() => s.selectedPropertyIds.length === 0 ? b.value : b.value.filter((U) => s.selectedPropertyIds.includes(U.id))), x = Oe(() => {
      if (s.graphMode === "speed") {
        let E = 100;
        return S.value.forEach((I) => {
          for (let j = 0; j < s.frameCount - 1; j++) {
            const Q = k(I, j);
            E = Math.max(E, Q);
          }
        }), { min: 0, max: E * 1.2 };
      }
      const U = [];
      if (S.value.forEach((E) => {
        E.keyframes.forEach((I) => {
          const j = typeof I.value == "number" ? I.value : 0;
          U.push(j);
        });
      }), U.length === 0)
        return { min: 0, max: 100 };
      const w = Math.min(...U), L = Math.max(...U), A = Math.max((L - w) * 0.15, 20);
      return { min: w - A, max: L + A };
    }), _ = Oe(() => {
      if (s.graphMode === "speed")
        return S.value.some((A) => A.name.includes("Rotation")) ? "deg/sec" : "px/sec";
      const U = S.value.some((L) => L.name.includes("Rotation")), w = S.value.some((L) => L.name.includes("Opacity"));
      return U ? "deg" : w ? "%" : "px";
    }), C = Oe(() => {
      const U = x.value, w = [], L = 5, A = (U.max - U.min) / L;
      for (let E = 0; E <= L; E++) {
        const I = U.max - E * A;
        w.push({
          value: I,
          percent: E / L * 100,
          text: I.toFixed(0)
        });
      }
      return w;
    });
    function k(U, w) {
      const L = o.fps || 30, A = 1 / L, E = M(U, w), I = M(U, w + A);
      return Math.abs(I - E) * L;
    }
    function M(U, w) {
      var Me, Se, q, de;
      const L = [...U.keyframes].sort((ye, Ee) => ye.frame - Ee.frame);
      if (L.length === 0) return 0;
      if (L.length === 1 || w <= L[0].frame) return L[0].value;
      if (w >= L[L.length - 1].frame) return L[L.length - 1].value;
      let A = 0;
      for (; A < L.length - 1 && L[A + 1].frame < w; ) A++;
      const E = L[A], I = L[A + 1], j = I.frame - E.frame, Q = (w - E.frame) / j, ce = typeof E.value == "number" ? E.value : 0, Z = typeof I.value == "number" ? I.value : 0, xe = E.interpolation || "linear";
      return xe === "hold" ? ce : xe === "bezier" && ((Me = E.outHandle) != null && Me.enabled) && ((Se = I.inHandle) != null && Se.enabled) ? O(
        ce,
        ce + (((q = E.outHandle) == null ? void 0 : q.value) || 0),
        Z + (((de = I.inHandle) == null ? void 0 : de.value) || 0),
        Z,
        Q
      ) : ce + (Z - ce) * Q;
    }
    function O(U, w, L, A, E) {
      const I = 1 - E;
      return I * I * I * U + 3 * I * I * E * w + 3 * I * E * E * L + E * E * E * A;
    }
    function F() {
      const U = u.value, w = l.value;
      if (!U || !w) return;
      const L = U.getContext("2d");
      if (!L) return;
      const A = w.getBoundingClientRect();
      U.width = A.width, U.height = A.height;
      const E = U.width, I = U.height, j = x.value;
      L.clearRect(0, 0, E, I), $(L, E, I, j), S.value.forEach((Q) => {
        if (!(Q.keyframes.length < 1))
          for (let ce = 0; ce < 2; ce++)
            L.strokeStyle = ce === 0 ? "#000" : Q.color, L.lineWidth = ce === 0 ? 4 : 2, L.beginPath(), s.graphMode === "value" ? ne(L, Q, I) : oe(L, Q, I), L.stroke();
      });
    }
    function $(U, w, L, A) {
      U.strokeStyle = "#333", U.lineWidth = 1;
      const E = Math.max(1, Math.floor(50 / c.value)), I = Math.floor(d.value), j = Math.ceil(d.value + w / c.value);
      for (let ce = I; ce <= j; ce += E) {
        const Z = f(ce);
        U.beginPath(), U.moveTo(Z, 0), U.lineTo(Z, L), U.stroke();
      }
      const Q = (A.max - A.min) / 5;
      for (let ce = A.min; ce <= A.max; ce += Q) {
        const Z = p(ce, L);
        U.beginPath(), U.moveTo(0, Z), U.lineTo(w, Z), U.stroke();
      }
      if (A.min < 0 && A.max > 0) {
        U.strokeStyle = "#555", U.lineWidth = 1;
        const ce = p(0, L);
        U.beginPath(), U.moveTo(0, ce), U.lineTo(w, ce), U.stroke();
      }
    }
    function ne(U, w, L, A) {
      var I, j;
      const E = [...w.keyframes].sort((Q, ce) => Q.frame - ce.frame);
      for (let Q = 0; Q < E.length; Q++) {
        const ce = E[Q], Z = typeof ce.value == "number" ? ce.value : 0, xe = f(ce.frame), Me = p(Z, L);
        if (Q === 0) {
          U.moveTo(xe, Me);
          continue;
        }
        const Se = E[Q - 1], q = typeof Se.value == "number" ? Se.value : 0, de = Se.interpolation || "linear";
        if (de === "hold") {
          f(Se.frame);
          const ye = p(q, L);
          U.lineTo(xe, ye), U.lineTo(xe, Me);
        } else if (de === "bezier" && ((I = Se.outHandle) != null && I.enabled) && ((j = ce.inHandle) != null && j.enabled)) {
          const ye = f(Se.frame + Se.outHandle.frame), Ee = p(q + Se.outHandle.value, L), Le = f(ce.frame + ce.inHandle.frame), ze = p(Z + ce.inHandle.value, L);
          U.bezierCurveTo(ye, Ee, Le, ze, xe, Me);
        } else
          U.lineTo(xe, Me);
      }
    }
    function oe(U, w, L) {
      x.value;
      const A = 0.5, E = Math.max(0, d.value - 10), I = Math.min(s.frameCount, d.value + U.canvas.width / c.value + 10);
      let j = !0;
      for (let Q = E; Q <= I; Q += A) {
        const ce = k(w, Q), Z = f(Q), xe = p(ce, L);
        j ? (U.moveTo(Z, xe), j = !1) : U.lineTo(Z, xe);
      }
    }
    function z(U, w) {
      var E;
      const L = typeof w.value == "number" ? w.value : 0, A = ((E = u.value) == null ? void 0 : E.height) || 300;
      return {
        left: `${f(w.frame)}px`,
        top: `${p(L, A)}px`
      };
    }
    function X(U, w, L) {
      var ce;
      const A = L === "in" ? w.inHandle : w.outHandle;
      if (!(A != null && A.enabled)) return { display: "none" };
      const E = typeof w.value == "number" ? w.value : 0, I = w.frame + A.frame, j = E + A.value, Q = ((ce = u.value) == null ? void 0 : ce.height) || 300;
      return {
        left: `${f(I)}px`,
        top: `${p(j, Q)}px`,
        background: U.color
      };
    }
    function T(U, w, L) {
      var j;
      const A = L === "in" ? w.inHandle : w.outHandle;
      if (!(A != null && A.enabled)) return { x1: 0, y1: 0, x2: 0, y2: 0 };
      const E = typeof w.value == "number" ? w.value : 0, I = ((j = u.value) == null ? void 0 : j.height) || 300;
      return {
        x1: f(w.frame),
        y1: p(E, I),
        x2: f(w.frame + A.frame),
        y2: p(E + A.value, I)
      };
    }
    function H(U) {
      return typeof U == "number" ? U.toFixed(1) : typeof U == "object" ? JSON.stringify(U) : String(U);
    }
    function ge(U) {
      if (U.ctrlKey || U.metaKey) {
        const w = U.deltaY > 0 ? 0.9 : 1.1;
        c.value = Math.max(0.5, Math.min(50, c.value * w));
      } else
        d.value += U.deltaY / c.value, d.value = Math.max(0, d.value);
      F();
    }
    function K() {
      c.value = Math.min(50, c.value * 1.2), F();
    }
    function re() {
      c.value = Math.max(0.5, c.value / 1.2), F();
    }
    function ie() {
      var w;
      const U = ((w = u.value) == null ? void 0 : w.width) || 800;
      c.value = U / s.frameCount, d.value = 0, F();
    }
    function be(U) {
      r("update:graphMode", U);
    }
    let J = !1, ee = null, ve = null, G = null, N = null, te = { x: 0 };
    function fe(U) {
      (U.button === 1 || U.button === 0 && U.shiftKey) && (J = !0, ee = "pan", te = { x: U.clientX, y: U.clientY }, document.addEventListener("mousemove", R), document.addEventListener("mouseup", P), U.preventDefault());
    }
    function ae(U, w, L) {
      J = !0, ee = "keyframe", ve = U, G = w, document.addEventListener("mousemove", R), document.addEventListener("mouseup", P), L.preventDefault();
    }
    function D(U, w, L, A) {
      J = !0, ee = "handle", ve = U, G = w, N = L, document.addEventListener("mousemove", R), document.addEventListener("mouseup", P), A.preventDefault();
    }
    function R(U) {
      if (!J || !l.value) return;
      const w = l.value.getBoundingClientRect(), L = U.clientX - w.left, A = U.clientY - w.top, E = w.height;
      if (ee === "pan") {
        const I = U.clientX - te.x;
        d.value -= I / c.value, d.value = Math.max(0, d.value), te = { x: U.clientX, y: U.clientY };
      } else if (ee === "keyframe" && ve && G) {
        const I = Math.round(g(L)), j = Math.max(0, Math.min(s.frameCount - 1, I));
        o.moveKeyframe(ve.layerId, ve.propertyPath, G.id, j);
      } else if (ee === "handle" && ve && G && N) {
        const I = g(L), j = y(A, E), Q = typeof G.value == "number" ? G.value : 0, ce = I - G.frame, Z = j - Q;
        o.setKeyframeHandle(
          ve.layerId,
          ve.propertyPath,
          G.id,
          N,
          { frame: ce, value: Z, enabled: !0 }
        );
      }
      F();
    }
    function P() {
      J = !1, ee = null, ve = null, G = null, N = null, document.removeEventListener("mousemove", R), document.removeEventListener("mouseup", P);
    }
    function Y(U, w) {
      r("selectKeyframe", U, w.shiftKey);
    }
    return ut(
      () => [S.value, s.frameCount, s.currentFrame, s.graphMode],
      () => Wn(F),
      { deep: !0 }
    ), Rt(() => {
      Wn(F), window.addEventListener("resize", F);
    }), pn(() => {
      window.removeEventListener("resize", F);
    }), (U, w) => (V(), B("div", {
      class: "graph-editor-canvas",
      ref_key: "containerRef",
      ref: a
    }, [
      h("div", _3, [
        h("div", w3, [
          h("button", {
            class: Ie({ active: i.graphMode === "value" }),
            onClick: w[0] || (w[0] = (L) => be("value")),
            title: "Edit Value Graph"
          }, [...w[2] || (w[2] = [
            h("span", { class: "icon" }, "", -1),
            qe(" Value ", -1)
          ])], 2),
          h("button", {
            class: Ie({ active: i.graphMode === "speed" }),
            onClick: w[1] || (w[1] = (L) => be("speed")),
            title: "Edit Speed Graph"
          }, [...w[3] || (w[3] = [
            h("span", { class: "icon" }, "", -1),
            qe(" Speed ", -1)
          ])], 2)
        ]),
        h("div", S3, [
          h("button", {
            onClick: K,
            title: "Zoom In"
          }, "+"),
          h("span", C3, pe(c.value.toFixed(1)) + "px/f", 1),
          h("button", {
            onClick: re,
            title: "Zoom Out"
          }, ""),
          h("button", {
            onClick: ie,
            title: "Fit All"
          }, "")
        ])
      ]),
      h("div", k3, [
        h("div", T3, pe(_.value), 1),
        (V(!0), B(Re, null, Ue(C.value, (L) => (V(), B("div", {
          key: L.value,
          class: "y-label",
          style: Xe({ top: `${L.percent}%` })
        }, pe(L.text), 5))), 128))
      ]),
      h("div", {
        class: "canvas-area",
        ref_key: "canvasAreaRef",
        ref: l
      }, [
        h("canvas", {
          ref_key: "canvasRef",
          ref: u,
          onMousedown: fe,
          onWheel: Je(ge, ["prevent"])
        }, null, 544),
        i.graphMode === "value" ? (V(!0), B(Re, { key: 0 }, Ue(S.value, (L) => (V(), B(Re, {
          key: L.id
        }, [
          (V(!0), B(Re, null, Ue(L.keyframes, (A) => (V(), B("div", {
            key: A.id,
            class: Ie(["keyframe-point", { selected: v.value.includes(A.id) }]),
            style: Xe(z(L, A)),
            onMousedown: Je((E) => ae(L, A, E), ["stop"]),
            onClick: Je((E) => Y(A.id, E), ["stop"]),
            title: `${L.name}: ${H(A.value)} @ Frame ${A.frame}`
          }, [
            h("div", {
              class: "point-inner",
              style: Xe({ background: L.color })
            }, null, 4)
          ], 46, M3))), 128)),
          (V(!0), B(Re, null, Ue(L.keyframes, (A) => {
            var E, I;
            return V(), B(Re, {
              key: "handles-" + A.id
            }, [
              v.value.includes(A.id) && A.interpolation === "bezier" ? (V(), B(Re, { key: 0 }, [
                (E = A.inHandle) != null && E.enabled ? (V(), B(Re, { key: 0 }, [
                  h("div", {
                    class: "bezier-handle",
                    style: Xe(X(L, A, "in")),
                    onMousedown: Je((j) => D(L, A, "in", j), ["stop"])
                  }, null, 44, O3),
                  (V(), B("svg", E3, [
                    h("line", {
                      x1: T(L, A, "in").x1,
                      y1: T(L, A, "in").y1,
                      x2: T(L, A, "in").x2,
                      y2: T(L, A, "in").y2,
                      stroke: L.color,
                      "stroke-width": "1"
                    }, null, 8, P3)
                  ]))
                ], 64)) : Te("", !0),
                (I = A.outHandle) != null && I.enabled ? (V(), B(Re, { key: 1 }, [
                  h("div", {
                    class: "bezier-handle",
                    style: Xe(X(L, A, "out")),
                    onMousedown: Je((j) => D(L, A, "out", j), ["stop"])
                  }, null, 44, D3),
                  (V(), B("svg", A3, [
                    h("line", {
                      x1: T(L, A, "out").x1,
                      y1: T(L, A, "out").y1,
                      x2: T(L, A, "out").x2,
                      y2: T(L, A, "out").y2,
                      stroke: L.color,
                      "stroke-width": "1"
                    }, null, 8, I3)
                  ]))
                ], 64)) : Te("", !0)
              ], 64)) : Te("", !0)
            ], 64);
          }), 128))
        ], 64))), 128)) : Te("", !0),
        h("div", {
          class: "playhead",
          style: Xe({ left: `${m.value}px` })
        }, null, 4)
      ], 512)
    ], 512));
  }
}), L3 = /* @__PURE__ */ mt(F3, [["__scopeId", "data-v-6b8d82e8"]]), z3 = { class: "timeline-header" }, R3 = { class: "header-left" }, V3 = { class: "frame-display" }, j3 = ["value"], $3 = { class: "fps-label" }, B3 = { class: "header-center" }, W3 = {
  key: 0,
  class: "add-layer-menu"
}, U3 = { class: "tool-group" }, N3 = { class: "tool-group" }, H3 = ["disabled"], X3 = { class: "header-right" }, Y3 = { class: "playback-controls" }, G3 = {
  class: "timeline-content",
  ref: "timelineContentRef"
}, K3 = { class: "time-ruler-container" }, q3 = { class: "timeline-split-layout" }, Z3 = {
  key: 0,
  class: "layer-bars-container"
}, J3 = /* @__PURE__ */ pt({
  __name: "TimelinePanel",
  setup(i) {
    const e = Ot(), n = me("keyframes"), s = me({}), r = me(/* @__PURE__ */ new Set()), o = me(!1), a = me(null), l = me(null), u = me([]), c = me(null), d = me(400), f = me(5), g = me(!1), p = Oe(() => e.layers || []), y = Oe(() => {
      const ve = (e.frameCount + 50) * f.value;
      return l.value ? Math.max(l.value.clientWidth, ve) : Math.max(window.innerWidth - d.value - 50, ve);
    }), v = Oe(() => e.currentFrame * f.value), m = Oe(() => ({
      display: "grid",
      gridTemplateColumns: "20px 20px 30px 24px 24px 24px 1fr 60px 60px",
      alignItems: "center",
      height: "28px",
      width: "100%",
      boxSizing: "border-box"
    })), b = Oe(() => {
      const ve = [], G = f.value > 10 ? 5 : 10;
      for (let N = 0; N <= e.frameCount; N += G) ve.push(N);
      return ve;
    });
    function S(ve) {
      const G = ve.target, te = G === a.value ? l.value : a.value;
      te && (te.scrollLeft = G.scrollLeft);
    }
    function x() {
      g.value = !0, document.body.style.cursor = "col-resize";
    }
    function _() {
      g.value = !1, document.body.style.cursor = "default";
    }
    function C(ve) {
      g.value && (d.value = Math.max(250, Math.min(800, ve.clientX)));
    }
    function k(ve, G) {
      s.value[ve] = G;
    }
    function M(ve, G) {
      G ? r.value.has(ve) ? r.value.delete(ve) : r.value.add(ve) : (r.value.clear(), r.value.add(ve)), r.value = new Set(r.value);
    }
    function O() {
      o.value = !o.value;
    }
    function F(ve) {
      ve === "video" ? e.createLayer("video") : ve === "text" ? e.createTextLayer() : ve === "camera" ? e.createCameraLayer() : ve === "spline" ? e.createSplineLayer() : ve === "particles" ? e.createParticleLayer() : e.createLayer(ve), o.value = !1;
    }
    function $(ve) {
      e.selectLayer(ve);
    }
    function ne(ve, G) {
      e.updateLayer(ve, G);
    }
    function oe() {
      e.selectedLayerIds.forEach((ve) => e.deleteLayer(ve));
    }
    function z() {
      n.value = n.value === "keyframes" ? "graph" : "keyframes";
    }
    function X(ve) {
    }
    const T = me(!1);
    function H() {
      T.value = !T.value;
    }
    function ge() {
      e.setFrame(0);
    }
    function K() {
      e.setFrame(e.frameCount - 1);
    }
    function re(ve) {
      e.setFrame(parseInt(ve.target.value) || 0);
    }
    function ie(ve) {
      const G = (N) => {
        const te = a.value.getBoundingClientRect(), fe = a.value.scrollLeft, ae = N.clientX - te.left + fe, D = Math.max(0, Math.min(e.frameCount - 1, ae / f.value));
        e.setFrame(Math.round(D));
      };
      G(ve), window.addEventListener("mousemove", G), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", G), { once: !0 });
    }
    function be(ve) {
      const G = Math.floor(ve / e.fps), N = ve % e.fps;
      return `${G}:${N.toString().padStart(2, "0")}`;
    }
    function J(ve) {
      ve.target instanceof HTMLInputElement || (ve.key === "Delete" && oe(), ve.key === " " && (ve.preventDefault(), H()));
    }
    function ee(ve) {
      c.value && !c.value.contains(ve.target) && (o.value = !1);
    }
    return Rt(() => {
      window.addEventListener("keydown", J), window.addEventListener("mousedown", ee);
    }), pn(() => {
      window.removeEventListener("keydown", J), window.removeEventListener("mousedown", ee);
    }), (ve, G) => (V(), B("div", {
      class: "timeline-panel",
      onMouseup: _,
      onMouseleave: _,
      onMousemove: C
    }, [
      h("div", z3, [
        h("div", R3, [
          G[8] || (G[8] = h("span", { class: "timeline-title" }, "Timeline", -1)),
          h("div", V3, [
            h("input", {
              type: "number",
              value: Fe(e).currentFrame,
              onChange: re,
              class: "frame-input"
            }, null, 40, j3),
            h("span", $3, pe(Fe(e).fps) + " fps", 1)
          ])
        ]),
        h("div", B3, [
          h("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: c
          }, [
            h("button", {
              class: Ie(["add-layer-btn", { active: o.value }]),
              onClick: Je(O, ["stop"]),
              title: "Add New Layer"
            }, [...G[9] || (G[9] = [
              h("span", { class: "icon" }, "+", -1),
              qe(" Layer ", -1)
            ])], 2),
            o.value ? (V(), B("div", W3, [
              h("button", {
                onClick: G[0] || (G[0] = (N) => F("solid"))
              }, [...G[10] || (G[10] = [
                h("span", { class: "icon" }, "", -1),
                qe(" Solid", -1)
              ])]),
              h("button", {
                onClick: G[1] || (G[1] = (N) => F("text"))
              }, [...G[11] || (G[11] = [
                h("span", { class: "icon" }, "T", -1),
                qe(" Text", -1)
              ])]),
              h("button", {
                onClick: G[2] || (G[2] = (N) => F("spline"))
              }, [...G[12] || (G[12] = [
                h("span", { class: "icon" }, "~", -1),
                qe(" Shape", -1)
              ])]),
              h("button", {
                onClick: G[3] || (G[3] = (N) => F("null"))
              }, [...G[13] || (G[13] = [
                h("span", { class: "icon" }, "", -1),
                qe(" Null", -1)
              ])]),
              h("button", {
                onClick: G[4] || (G[4] = (N) => F("camera"))
              }, [...G[14] || (G[14] = [
                h("span", { class: "icon" }, "", -1),
                qe(" Camera", -1)
              ])]),
              h("button", {
                onClick: G[5] || (G[5] = (N) => F("light"))
              }, [...G[15] || (G[15] = [
                h("span", { class: "icon" }, "", -1),
                qe(" Light", -1)
              ])]),
              h("button", {
                onClick: G[6] || (G[6] = (N) => F("video"))
              }, [...G[16] || (G[16] = [
                h("span", { class: "icon" }, "", -1),
                qe(" Video", -1)
              ])])
            ])) : Te("", !0)
          ], 512),
          h("div", U3, [
            h("button", {
              class: Ie(["graph-toggle", { active: n.value === "graph" }]),
              onClick: z,
              title: "Toggle Graph Editor (Shift+F3)"
            }, " Graph ", 2)
          ]),
          h("div", N3, [
            h("button", {
              class: "delete-btn",
              onClick: oe,
              disabled: Fe(e).selectedLayerIds.length === 0,
              title: "Delete"
            }, "  ", 8, H3)
          ])
        ]),
        h("div", X3, [
          h("div", Y3, [
            h("button", { onClick: ge }, "|<"),
            h("button", {
              onClick: H,
              class: Ie({ active: T.value })
            }, pe(T.value ? "||" : ""), 3),
            h("button", { onClick: K }, ">|")
          ]),
          tt(h("input", {
            type: "range",
            min: "1",
            max: "50",
            "onUpdate:modelValue": G[7] || (G[7] = (N) => f.value = N),
            class: "zoom-slider",
            title: "Zoom"
          }, null, 512), [
            [
              $t,
              f.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      h("div", G3, [
        h("div", K3, [
          h("div", {
            class: "ruler-sidebar-spacer",
            style: Xe({ width: d.value + "px" })
          }, [...G[17] || (G[17] = [
            xr('<div class="column-headers" data-v-2e8022a2><span class="col-header col-arrow" data-v-2e8022a2></span><span class="col-header col-color" data-v-2e8022a2>#</span><span class="col-header col-name" data-v-2e8022a2>Layer Name</span><span class="col-header col-mode" data-v-2e8022a2>Mode</span><span class="col-header col-parent" data-v-2e8022a2>Parent</span></div>', 1)
          ])], 4),
          h("div", {
            class: "ruler-track-window",
            ref_key: "rulerTrackRef",
            ref: a,
            onScroll: S
          }, [
            h("div", {
              class: "ruler-track-content",
              style: Xe({ width: y.value + "px" }),
              onMousedown: ie
            }, [
              (V(!0), B(Re, null, Ue(b.value, (N) => (V(), B("div", {
                key: N,
                class: "ruler-mark",
                style: Xe({ left: `${N * f.value}px` })
              }, pe(be(N)), 5))), 128)),
              h("div", {
                class: "playhead-head",
                style: Xe({ left: `${v.value}px` })
              }, [...G[18] || (G[18] = [
                h("div", { class: "playhead-tri" }, null, -1),
                h("div", { class: "playhead-line-top" }, null, -1)
              ])], 4)
            ], 36)
          ], 544)
        ]),
        h("div", q3, [
          h("div", {
            class: "property-tree-sidebar",
            style: Xe({ width: d.value + "px" })
          }, [
            (V(!0), B(Re, null, Ue(p.value, (N, te) => (V(), ot(vd, {
              key: "sidebar-" + N.id,
              layer: N,
              index: te + 1,
              layoutMode: "sidebar",
              viewMode: n.value,
              isExpandedExternal: s.value[N.id],
              selectedPropertyIds: Array.from(r.value),
              allLayers: Fe(e).layers,
              soloedLayerIds: u.value,
              gridStyle: m.value,
              onSelect: $,
              onUpdateLayer: ne,
              onToggleExpand: k,
              onSelectProperty: M
            }, null, 8, ["layer", "index", "viewMode", "isExpandedExternal", "selectedPropertyIds", "allLayers", "soloedLayerIds", "gridStyle"]))), 128))
          ], 4),
          h("div", {
            class: "resize-handle",
            onMousedown: x
          }, null, 32),
          h("div", {
            class: "track-viewport",
            ref_key: "trackViewportRef",
            ref: l,
            onScroll: S
          }, [
            h("div", {
              class: "track-scroll-content",
              style: Xe({ width: y.value + "px" })
            }, [
              h("div", {
                class: "playhead-line",
                style: Xe({ left: `${v.value}px` })
              }, null, 4),
              n.value === "keyframes" ? (V(), B("div", Z3, [
                (V(!0), B(Re, null, Ue(p.value, (N) => (V(), ot(vd, {
                  key: "track-" + N.id,
                  layer: N,
                  layoutMode: "track",
                  viewMode: n.value,
                  frameCount: Fe(e).frameCount,
                  pixelsPerFrame: f.value,
                  isExpandedExternal: s.value[N.id],
                  selectedPropertyIds: Array.from(r.value),
                  onSelectKeyframe: X,
                  onUpdateLayer: ne
                }, null, 8, ["layer", "viewMode", "frameCount", "pixelsPerFrame", "isExpandedExternal", "selectedPropertyIds"]))), 128))
              ])) : n.value === "graph" ? (V(), ot(L3, {
                key: 1,
                frameCount: Fe(e).frameCount,
                currentFrame: Fe(e).currentFrame,
                selectedPropertyIds: Array.from(r.value),
                graphMode: "value"
              }, null, 8, ["frameCount", "currentFrame", "selectedPropertyIds"])) : Te("", !0)
            ], 4)
          ], 544)
        ])
      ], 512)
    ], 32));
  }
}), yd = /* @__PURE__ */ mt(J3, [["__scopeId", "data-v-2e8022a2"]]), Q3 = { class: "graph-editor" }, eE = { class: "graph-header" }, tE = { class: "mode-toggle" }, nE = { class: "preset-buttons" }, sE = ["onClick", "title"], iE = { class: "toolbar" }, rE = { class: "graph-content" }, oE = { class: "property-list" }, aE = { class: "property-list-header" }, lE = ["title"], uE = ["onClick"], cE = ["onClick"], dE = { class: "property-name" }, hE = {
  key: 0,
  class: "keyframe-count"
}, fE = {
  key: 0,
  class: "dimension-toggles"
}, pE = ["onClick"], mE = {
  key: 0,
  class: "no-properties"
}, gE = { class: "graph-main" }, vE = ["viewBox"], yE = ["onMousedown"], bE = ["x", "y", "fill", "transform"], xE = {
  key: 1,
  class: "bezier-handles"
}, _E = {
  key: 0,
  class: "handle out-handle"
}, wE = ["x1", "y1", "x2", "y2"], SE = ["cx", "cy", "onMousedown"], CE = {
  key: 1,
  class: "handle in-handle"
}, kE = ["x1", "y1", "x2", "y2"], TE = ["cx", "cy", "onMousedown"], ME = ["x1", "x2", "y2"], OE = {
  key: 0,
  class: "keyframe-info-panel"
}, EE = { class: "info-row" }, PE = ["value"], DE = { class: "info-row" }, AE = ["value"], IE = { class: "info-row" }, FE = ["value"], LE = ["disabled"], zE = ["disabled"], RE = ["disabled"], VE = /* @__PURE__ */ pt({
  __name: "GraphEditor",
  emits: ["close"],
  setup(i, { emit: e }) {
    const n = e, s = Ot(), r = me(null), o = me(null), a = me(null), l = me(null), u = me(null), c = me(null), d = me(400), f = me(200), g = me("value"), p = Ai({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), y = me([]), v = me([]), m = me({}), b = me([]), S = me(null), x = me(null), _ = me(null), C = me(null), k = me(null), M = me(!1), O = me(!0), F = { top: 10, right: 10, bottom: 10, left: 10 }, $ = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, ne = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], oe = Oe(() => {
      const W = s.selectedLayer;
      if (!W) return [];
      const se = [];
      return se.push(W.transform.position), se.push(W.transform.scale), se.push(W.transform.rotation), se.push(W.opacity), se.push(...W.properties), se;
    }), z = Oe(() => oe.value.filter(
      (W) => v.value.includes(W.id) && W.animated
    )), X = Oe(() => oe.value.every((W) => v.value.includes(W.id))), T = Oe(() => H(s.currentFrame));
    function H(W) {
      const se = d.value - F.left - F.right, he = (W - p.frameStart) / (p.frameEnd - p.frameStart);
      return F.left + he * se;
    }
    function ge(W) {
      const se = d.value - F.left - F.right, he = (W - F.left) / se;
      return p.frameStart + he * (p.frameEnd - p.frameStart);
    }
    function K(W) {
      const se = f.value - F.top - F.bottom, he = (W - p.valueMin) / (p.valueMax - p.valueMin);
      return f.value - F.bottom - he * se;
    }
    function re(W) {
      const se = f.value - F.top - F.bottom, he = (f.value - F.bottom - W) / se;
      return p.valueMin + he * (p.valueMax - p.valueMin);
    }
    function ie(W) {
      return H(W.frame);
    }
    function be(W, se) {
      const he = typeof se.value == "number" ? se.value : typeof se.value == "object" ? se.value.x ?? se.value : 0;
      return K(he);
    }
    function J(W) {
      if (!W) return 0;
      const se = W.keyframe.value;
      return typeof se == "number" ? se : typeof se == "object" ? se.x ?? 0 : 0;
    }
    function ee(W, se) {
      const he = W.keyframes[se];
      if (!he || !he.outHandle.enabled) return H(he.frame);
      const De = he.frame + he.outHandle.frame;
      return H(De);
    }
    function ve(W, se) {
      const he = W.keyframes[se];
      if (!he || !he.outHandle.enabled) return K(te(he.value));
      const De = te(he.value) + he.outHandle.value;
      return K(De);
    }
    function G(W, se) {
      const he = W.keyframes[se];
      if (!he || !he.inHandle.enabled) return H(he.frame);
      const De = he.frame + he.inHandle.frame;
      return H(De);
    }
    function N(W, se) {
      const he = W.keyframes[se];
      if (!he || !he.inHandle.enabled) return K(te(he.value));
      const De = te(he.value) + he.inHandle.value;
      return K(De);
    }
    function te(W) {
      return typeof W == "number" ? W : typeof W == "object" ? W.x ?? W.y ?? W.z ?? 0 : 0;
    }
    function fe(W) {
      const se = oe.value.find((he) => he.id === W);
      return se ? $[se.name] ?? $.default : $.default;
    }
    function ae(W) {
      return W.frame >= p.frameStart && W.frame <= p.frameEnd;
    }
    function D(W, se) {
      return b.value.some((he) => he.propId === W && he.index === se);
    }
    function R(W, se) {
      if (!W.animated || W.keyframes.length === 0) return !1;
      const he = W.keyframes[0].value;
      return typeof he == "object" && se in he;
    }
    function P(W) {
      const se = y.value.indexOf(W);
      se === -1 ? y.value.push(W) : y.value.splice(se, 1);
    }
    function Y(W) {
      const se = v.value.indexOf(W);
      se === -1 ? v.value.push(W) : v.value.splice(se, 1), A();
    }
    function U() {
      X.value ? v.value = [] : v.value = oe.value.map((W) => W.id), A();
    }
    function w(W, se) {
      m.value[W] || (m.value[W] = []);
      const he = m.value[W], De = he.indexOf(se);
      De === -1 ? he.push(se) : he.splice(De, 1);
    }
    function L() {
      const W = z.value;
      if (W.length === 0) return;
      let se = 1 / 0, he = -1 / 0, De = 1 / 0, _e = -1 / 0;
      for (const Ze of W)
        for (const it of Ze.keyframes) {
          se = Math.min(se, it.frame), he = Math.max(he, it.frame);
          const Qe = te(it.value);
          De = Math.min(De, Qe), _e = Math.max(_e, Qe);
        }
      const $e = (he - se) * 0.1 || 10, Be = (_e - De) * 0.1 || 10;
      p.frameStart = se - $e, p.frameEnd = he + $e, p.valueMin = De - Be, p.valueMax = _e + Be;
    }
    function A() {
      L();
    }
    function E() {
      O.value = !O.value;
    }
    function I(W) {
      return b.value.length === 0 || !Ko[W] ? !1 : W === "linear" ? b.value.every((he) => he.keyframe.interpolation === "linear") : b.value.every((he) => he.keyframe.interpolation === "bezier");
    }
    function j(W) {
      const se = Ko[W];
      if (se) {
        for (const he of b.value) {
          const De = oe.value.find((Qe) => Qe.id === he.propId);
          if (!De) continue;
          const _e = he.index, $e = _e > 0 ? De.keyframes[_e - 1] : null, Be = _e < De.keyframes.length - 1 ? De.keyframes[_e + 1] : null, Ze = $e ? he.keyframe.frame - $e.frame : 10, it = Be ? Be.frame - he.keyframe.frame : 10;
          W === "linear" ? (he.keyframe.interpolation = "linear", he.keyframe.outHandle = { frame: it * 0.33, value: 0, enabled: !1 }, he.keyframe.inHandle = { frame: -Ze * 0.33, value: 0, enabled: !1 }) : (he.keyframe.interpolation = "bezier", he.keyframe.outHandle = {
            frame: se.outHandle.x * it,
            value: 0,
            // Would need value delta for proper curve
            enabled: !0
          }, he.keyframe.inHandle = {
            frame: -se.inHandle.x * Ze,
            value: 0,
            // Would need value delta for proper curve
            enabled: !0
          });
        }
        wt();
      }
    }
    function Q(W) {
      var _e;
      const se = (_e = r.value) == null ? void 0 : _e.getBoundingClientRect();
      if (!se) return;
      const he = W.clientX - se.left, De = W.clientY - se.top;
      W.button === 1 || W.button === 0 && W.altKey ? x.value = { type: "pan", startX: he, startY: De } : W.button === 0 && (W.shiftKey || (b.value = []), _.value = { x: he, y: De, width: 0, height: 0 }, x.value = { type: "select", startX: he, startY: De });
    }
    function ce(W) {
      var _e;
      const se = (_e = r.value) == null ? void 0 : _e.getBoundingClientRect();
      if (!se) return;
      const he = W.clientX - se.left, De = W.clientY - se.top;
      if (Me(he, De), !!x.value)
        if (x.value.type === "pan") {
          const $e = he - (x.value.startX ?? 0), Be = De - (x.value.startY ?? 0), Ze = d.value - F.left - F.right, it = f.value - F.top - F.bottom, Qe = -$e / Ze * (p.frameEnd - p.frameStart), zt = Be / it * (p.valueMax - p.valueMin);
          p.frameStart += Qe, p.frameEnd += Qe, p.valueMin += zt, p.valueMax += zt, x.value.startX = he, x.value.startY = De, wt();
        } else if (x.value.type === "select" && _.value) {
          const $e = x.value.startX ?? 0, Be = x.value.startY ?? 0;
          _.value = {
            x: Math.min(he, $e),
            y: Math.min(De, Be),
            width: Math.abs(he - $e),
            height: Math.abs(De - Be)
          };
        } else x.value.type === "keyframe" ? de(he, De) : (x.value.type === "outHandle" || x.value.type === "inHandle") && Le(he, De);
    }
    function Z() {
      var W;
      ((W = x.value) == null ? void 0 : W.type) === "select" && _.value && q(), x.value = null, _.value = null;
    }
    function xe(W) {
      var Ze;
      W.preventDefault();
      const se = (Ze = r.value) == null ? void 0 : Ze.getBoundingClientRect();
      if (!se) return;
      const he = W.clientX - se.left, De = W.deltaY > 0 ? 1.1 : 0.9, _e = ge(he), $e = _e - (_e - p.frameStart) * De, Be = _e + (p.frameEnd - _e) * De;
      if (W.shiftKey)
        p.frameStart = $e, p.frameEnd = Be;
      else {
        p.frameStart = $e, p.frameEnd = Be;
        const it = W.clientY - se.top, Qe = re(it);
        p.valueMin = Qe - (Qe - p.valueMin) * De, p.valueMax = Qe + (p.valueMax - Qe) * De;
      }
      wt();
    }
    function Me(W, se) {
      S.value = null;
      for (const he of z.value)
        for (let De = 0; De < he.keyframes.length; De++) {
          const _e = he.keyframes[De], $e = ie(_e), Be = be(he, _e);
          if (Math.sqrt((W - $e) ** 2 + (se - Be) ** 2) < 10) {
            S.value = { propId: he.id, index: De };
            return;
          }
        }
    }
    function Se(W, se, he) {
      const De = oe.value.find(($e) => $e.id === W);
      if (!De) return;
      const _e = De.keyframes[se];
      he.shiftKey || (b.value = []), D(W, se) || b.value.push({ propId: W, index: se, keyframe: _e }), x.value = { type: "keyframe", propId: W, index: se };
    }
    function q() {
      if (!_.value) return;
      const W = _.value;
      for (const se of z.value)
        for (let he = 0; he < se.keyframes.length; he++) {
          const De = se.keyframes[he], _e = ie(De), $e = be(se, De);
          _e >= W.x && _e <= W.x + W.width && $e >= W.y && $e <= W.y + W.height && (D(se.id, he) || b.value.push({ propId: se.id, index: he, keyframe: De }));
        }
    }
    function de(W, se) {
      const he = Math.round(ge(W)), De = re(se);
      if (b.value.length > 0) {
        const _e = b.value[0];
        _e.keyframe.frame = M.value ? Math.round(he / 5) * 5 : he, typeof _e.keyframe.value == "number" && (_e.keyframe.value = De);
      }
      wt();
    }
    function ye(W, se, he, De) {
      x.value = { type: W, propId: se, index: he }, document.addEventListener("mousemove", Ee), document.addEventListener("mouseup", ke);
    }
    function Ee(W) {
      var _e;
      const se = (_e = r.value) == null ? void 0 : _e.getBoundingClientRect();
      if (!se || !x.value) return;
      const he = W.clientX - se.left, De = W.clientY - se.top;
      Le(he, De);
    }
    function Le(W, se) {
      if (!x.value || !x.value.propId) return;
      const he = oe.value.find((Ze) => Ze.id === x.value.propId);
      if (!he) return;
      const De = x.value.index, _e = he.keyframes[De];
      if (!_e) return;
      const $e = ge(W), Be = re(se);
      if (x.value.type === "outHandle") {
        const Ze = he.keyframes[De + 1];
        let it = $e - _e.frame;
        Ze ? it = Math.max(0, Math.min(Ze.frame - _e.frame, it)) : it = Math.max(0, it);
        const Qe = Be - te(_e.value);
        _e.outHandle = {
          frame: it,
          value: Qe,
          enabled: !0
        }, _e.interpolation = "bezier", ze(_e, "out");
      } else if (x.value.type === "inHandle") {
        const Ze = he.keyframes[De - 1];
        let it = $e - _e.frame;
        Ze ? it = Math.min(0, Math.max(Ze.frame - _e.frame, it)) : it = Math.min(0, it);
        const Qe = Be - te(_e.value);
        _e.inHandle = {
          frame: it,
          value: Qe,
          enabled: !0
        }, ze(_e, "in");
      }
      wt();
    }
    function ze(W, se) {
      if (!(!W.controlMode || W.controlMode === "corner") && (W.controlMode === "symmetric" && (se === "in" ? (W.outHandle.frame = -W.inHandle.frame, W.outHandle.value = -W.inHandle.value, W.outHandle.enabled = W.inHandle.enabled) : (W.inHandle.frame = -W.outHandle.frame, W.inHandle.value = -W.outHandle.value, W.inHandle.enabled = W.outHandle.enabled)), W.controlMode === "smooth")) {
        const he = se === "in" ? W.inHandle : W.outHandle, De = se === "in" ? W.outHandle : W.inHandle;
        if (he.frame !== 0 || he.value !== 0) {
          const $e = Math.atan2(he.value, he.frame) + Math.PI, Be = Math.hypot(De.frame, De.value);
          De.frame = Math.cos($e) * Be, De.value = Math.sin($e) * Be;
        }
      }
    }
    function ke() {
      x.value = null, document.removeEventListener("mousemove", Ee), document.removeEventListener("mouseup", ke);
    }
    function Ce(W) {
      C.value = { x: W.offsetX, y: W.offsetY };
    }
    function Pe() {
      if (!C.value) return;
      const W = Math.round(ge(C.value.x)), se = re(C.value.y);
      if (z.value.length > 0) {
        const he = z.value[0], De = {
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          frame: W,
          value: typeof he.value == "number" ? se : { x: se, y: se },
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: !1 },
          outHandle: { frame: 0, value: 0, enabled: !1 },
          controlMode: "smooth"
        }, _e = he.keyframes.findIndex(($e) => $e.frame > W);
        _e === -1 ? he.keyframes.push(De) : he.keyframes.splice(_e, 0, De), he.animated = !0, wt();
      }
      C.value = null;
    }
    function je() {
      for (const W of b.value) {
        const se = oe.value.find((he) => he.id === W.propId);
        if (se) {
          const he = se.keyframes.indexOf(W.keyframe);
          he !== -1 && se.keyframes.splice(he, 1), se.keyframes.length === 0 && (se.animated = !1);
        }
      }
      b.value = [], wt();
    }
    function Ge() {
      k.value = b.value.map((W) => ({ ...W.keyframe }));
    }
    function ct() {
      if (!k.value || z.value.length === 0) return;
      const W = z.value[0], se = s.currentFrame - k.value[0].frame;
      for (const he of k.value) {
        const De = {
          ...he,
          frame: he.frame + se
        }, _e = W.keyframes.findIndex(($e) => $e.frame > De.frame);
        _e === -1 ? W.keyframes.push(De) : W.keyframes.splice(_e, 0, De);
      }
      W.animated = !0, wt();
    }
    function St() {
      b.value = [];
      for (const W of z.value)
        for (let se = 0; se < W.keyframes.length; se++)
          b.value.push({ propId: W.id, index: se, keyframe: W.keyframes[se] });
    }
    function Ut() {
      const W = [];
      for (const se of z.value)
        for (let he = 0; he < se.keyframes.length; he++)
          D(se.id, he) || W.push({ propId: se.id, index: he, keyframe: se.keyframes[he] });
      b.value = W;
    }
    function Vt(W) {
      const se = parseInt(W.target.value);
      b.value.length > 0 && !isNaN(se) && (b.value[0].keyframe.frame = se, wt());
    }
    function jt(W) {
      const se = parseFloat(W.target.value);
      if (b.value.length > 0 && !isNaN(se)) {
        const he = b.value[0].keyframe;
        typeof he.value == "number" ? he.value = se : typeof he.value == "object" && (he.value.x = se), wt();
      }
    }
    function Dt(W) {
      const se = W.target.value;
      b.value.length > 0 && (b.value[0].keyframe.interpolation = se, wt());
    }
    function _n(W) {
      var _e;
      const se = (_e = l.value) == null ? void 0 : _e.getBoundingClientRect();
      if (!se) return;
      const he = W.clientX - se.left, De = Math.round(ge(he));
      s.setFrame(De);
    }
    function wt() {
      ep(), sp(), ip();
    }
    function ep() {
      const W = r.value;
      if (!W) return;
      const se = W.getContext("2d");
      if (se) {
        W.width = d.value, W.height = f.value, se.fillStyle = "#1a1a1a", se.fillRect(0, 0, d.value, f.value), tp(se);
        for (const he of z.value)
          np(se, he);
      }
    }
    function tp(W) {
      const se = d.value - F.left - F.right, he = f.value - F.top - F.bottom;
      W.strokeStyle = "#2a2a2a", W.lineWidth = 1;
      const De = p.frameEnd - p.frameStart, _e = Vr(De, se, 50), $e = p.valueMax - p.valueMin, Be = Vr($e, he, 30), Ze = Math.ceil(p.frameStart / _e) * _e;
      for (let Qe = Ze; Qe <= p.frameEnd; Qe += _e) {
        const zt = H(Qe);
        W.beginPath(), W.moveTo(zt, F.top), W.lineTo(zt, f.value - F.bottom), W.stroke();
      }
      const it = Math.ceil(p.valueMin / Be) * Be;
      for (let Qe = it; Qe <= p.valueMax; Qe += Be) {
        const zt = K(Qe);
        W.beginPath(), W.moveTo(F.left, zt), W.lineTo(d.value - F.right, zt), W.stroke();
      }
      if (W.strokeStyle = "#3a3a3a", W.lineWidth = 1, p.frameStart <= 0 && p.frameEnd >= 0) {
        const Qe = H(0);
        W.beginPath(), W.moveTo(Qe, F.top), W.lineTo(Qe, f.value - F.bottom), W.stroke();
      }
      if (p.valueMin <= 0 && p.valueMax >= 0) {
        const Qe = K(0);
        W.beginPath(), W.moveTo(F.left, Qe), W.lineTo(d.value - F.right, Qe), W.stroke();
      }
    }
    function Vr(W, se, he) {
      const De = W * he / se, _e = Math.pow(10, Math.floor(Math.log10(De))), $e = De / _e;
      return $e <= 1 ? _e : $e <= 2 ? 2 * _e : $e <= 5 ? 5 * _e : 10 * _e;
    }
    function np(W, se) {
      if (se.keyframes.length < 2) return;
      const he = fe(se.id);
      for (let De = 0; De < 2; De++) {
        De === 0 ? (W.strokeStyle = "#000", W.lineWidth = 4) : (W.strokeStyle = he, W.lineWidth = 2), W.beginPath();
        let _e = !1;
        for (let $e = 0; $e < se.keyframes.length - 1; $e++) {
          const Be = se.keyframes[$e], Ze = se.keyframes[$e + 1];
          if (Ze.frame < p.frameStart || Be.frame > p.frameEnd) continue;
          const it = ie(Be), Qe = be(se, Be), zt = ie(Ze), si = be(se, Ze);
          if (_e || (W.moveTo(it, Qe), _e = !0), Be.interpolation === "hold")
            W.lineTo(zt, Qe), W.lineTo(zt, si);
          else if (Be.interpolation === "linear" || !Be.outHandle.enabled && !Ze.inHandle.enabled)
            W.lineTo(zt, si);
          else {
            const jr = H(Be.frame + Be.outHandle.frame), $r = K(te(Be.value) + Be.outHandle.value), Br = H(Ze.frame + Ze.inHandle.frame), Bi = K(te(Ze.value) + Ze.inHandle.value);
            W.bezierCurveTo(jr, $r, Br, Bi, zt, si);
          }
        }
        W.stroke();
      }
    }
    function sp() {
      var Ze;
      const W = l.value;
      if (!W) return;
      const se = (Ze = a.value) == null ? void 0 : Ze.getBoundingClientRect();
      if (!se) return;
      W.width = se.width, W.height = 24;
      const he = W.getContext("2d");
      if (!he) return;
      he.fillStyle = "#252525", he.fillRect(0, 0, W.width, W.height);
      const De = p.frameEnd - p.frameStart, _e = Vr(De, W.width, 60);
      he.fillStyle = "#888", he.font = "10px system-ui", he.textAlign = "center";
      const $e = Math.ceil(p.frameStart / _e) * _e;
      for (let it = $e; it <= p.frameEnd; it += _e) {
        const Qe = H(it);
        he.fillText(it.toString(), Qe, 16), he.strokeStyle = "#444", he.beginPath(), he.moveTo(Qe, 20), he.lineTo(Qe, 24), he.stroke();
      }
      const Be = H(s.currentFrame);
      he.fillStyle = "#ff4444", he.beginPath(), he.moveTo(Be - 5, 0), he.lineTo(Be + 5, 0), he.lineTo(Be, 8), he.closePath(), he.fill();
    }
    function ip() {
      var Be;
      const W = c.value;
      if (!W) return;
      const se = (Be = u.value) == null ? void 0 : Be.getBoundingClientRect();
      if (!se) return;
      W.width = 40, W.height = se.height;
      const he = W.getContext("2d");
      if (!he) return;
      he.fillStyle = "#252525", he.fillRect(0, 0, W.width, W.height);
      const De = p.valueMax - p.valueMin, _e = Vr(De, W.height, 30);
      he.fillStyle = "#888", he.font = "10px system-ui", he.textAlign = "right";
      const $e = Math.ceil(p.valueMin / _e) * _e;
      for (let Ze = $e; Ze <= p.valueMax; Ze += _e) {
        const it = K(Ze);
        he.fillText(Ze.toFixed(0), 36, it + 4);
      }
    }
    function Va(W = "both") {
      for (const se of b.value) {
        const he = oe.value.find((zt) => zt.id === se.propId);
        if (!he) continue;
        const De = se.keyframe, _e = se.index, $e = _e > 0 ? he.keyframes[_e - 1] : null, Be = _e < he.keyframes.length - 1 ? he.keyframes[_e + 1] : null, Ze = $e ? De.frame - $e.frame : 10, it = Be ? Be.frame - De.frame : 10, Qe = 0.3333;
        (W === "both" || W === "in") && (De.inHandle = {
          frame: -Ze * Qe,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (W === "both" || W === "out") && (De.outHandle = {
          frame: it * Qe,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), De.interpolation = "bezier", De.controlMode = "smooth";
      }
      wt();
    }
    function rp() {
      const W = s.currentFrame, se = [];
      for (const De of z.value)
        for (const _e of De.keyframes)
          se.includes(_e.frame) || se.push(_e.frame);
      se.sort((De, _e) => De - _e);
      const he = [...se].reverse().find((De) => De < W);
      he !== void 0 && s.setFrame(he);
    }
    function op() {
      const W = s.currentFrame, se = [];
      for (const De of z.value)
        for (const _e of De.keyframes)
          se.includes(_e.frame) || se.push(_e.frame);
      se.sort((De, _e) => De - _e);
      const he = se.find((De) => De > W);
      he !== void 0 && s.setFrame(he);
    }
    function Ou(W) {
      if (W.key === "F9") {
        W.preventDefault(), W.ctrlKey && W.shiftKey ? Va("out") : W.shiftKey ? Va("in") : Va("both");
        return;
      }
      if (W.key.toLowerCase() === "j") {
        W.preventDefault(), rp();
        return;
      }
      if (W.key.toLowerCase() === "k") {
        W.preventDefault(), op();
        return;
      }
      if (W.key === "Delete" || W.key === "Backspace") {
        W.preventDefault(), je();
        return;
      }
      if (W.key.toLowerCase() === "f" && !W.ctrlKey) {
        W.preventDefault(), W.shiftKey ? L() : b.value.length > 0 ? ap() : L();
        return;
      }
      if (W.key === "=" || W.key === "+") {
        W.preventDefault(), lp();
        return;
      }
      if (W.key === "-" || W.key === "_") {
        W.preventDefault(), up();
        return;
      }
    }
    function ap() {
      if (b.value.length === 0) {
        L();
        return;
      }
      let W = 1 / 0, se = -1 / 0, he = 1 / 0, De = -1 / 0;
      for (const Be of b.value) {
        W = Math.min(W, Be.keyframe.frame), se = Math.max(se, Be.keyframe.frame);
        const Ze = te(Be.keyframe.value);
        he = Math.min(he, Ze), De = Math.max(De, Ze);
      }
      const _e = (se - W) * 0.1 || 10, $e = (De - he) * 0.1 || 10;
      p.frameStart = W - _e, p.frameEnd = se + _e, p.valueMin = he - $e, p.valueMax = De + $e, wt();
    }
    function lp() {
      const W = (p.frameStart + p.frameEnd) / 2, se = p.frameEnd - p.frameStart;
      p.frameStart = W - se * 0.4, p.frameEnd = W + se * 0.4, wt();
    }
    function up() {
      const W = (p.frameStart + p.frameEnd) / 2, se = p.frameEnd - p.frameStart;
      p.frameStart = W - se * 0.6, p.frameEnd = W + se * 0.6, wt();
    }
    let $i = null;
    return Rt(() => {
      o.value && ($i = new ResizeObserver((W) => {
        for (const se of W)
          d.value = se.contentRect.width, f.value = se.contentRect.height, wt();
      }), $i.observe(o.value)), v.value = oe.value.filter((W) => W.animated).map((W) => W.id), window.addEventListener("keydown", Ou), L(), wt();
    }), pn(() => {
      $i == null || $i.disconnect(), window.removeEventListener("keydown", Ou);
    }), ut([() => s.currentFrame, v, g], () => {
      wt();
    }), ut(oe, () => {
      L(), wt();
    }, { deep: !0 }), (W, se) => {
      var he, De;
      return V(), B("div", Q3, [
        h("div", eE, [
          se[9] || (se[9] = h("span", { class: "graph-title" }, "Graph Editor", -1)),
          h("div", tE, [
            h("button", {
              class: Ie({ active: g.value === "value" }),
              onClick: se[0] || (se[0] = (_e) => g.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            h("button", {
              class: Ie({ active: g.value === "speed" }),
              onClick: se[1] || (se[1] = (_e) => g.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          h("div", nE, [
            (V(), B(Re, null, Ue(ne, (_e) => h("button", {
              key: _e.key,
              class: Ie(["preset-btn", { active: I(_e.key) }]),
              onClick: ($e) => j(_e.key),
              title: _e.label
            }, pe(_e.shortLabel), 11, sE)), 64))
          ]),
          h("div", iE, [
            h("button", {
              onClick: L,
              title: "Fit to View"
            }, [...se[5] || (se[5] = [
              h("span", { class: "icon" }, "[ ]", -1)
            ])]),
            h("button", {
              onClick: E,
              class: Ie({ active: O.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...se[6] || (se[6] = [
              h("span", { class: "icon" }, "A", -1)
            ])], 2),
            h("button", {
              onClick: se[2] || (se[2] = (_e) => M.value = !M.value),
              class: Ie({ active: M.value }),
              title: "Snap to Grid"
            }, [...se[7] || (se[7] = [
              h("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          h("button", {
            class: "close-btn",
            onClick: se[3] || (se[3] = (_e) => n("close"))
          }, [...se[8] || (se[8] = [
            h("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        h("div", rE, [
          h("div", oE, [
            h("div", aE, [
              se[10] || (se[10] = qe(" Properties ", -1)),
              h("button", {
                class: "toggle-all-btn",
                onClick: U,
                title: X.value ? "Hide All" : "Show All"
              }, pe(X.value ? "Hide" : "Show"), 9, lE)
            ]),
            (V(!0), B(Re, null, Ue(oe.value, (_e) => (V(), B("div", {
              key: _e.id,
              class: Ie(["property-item", {
                selected: y.value.includes(_e.id),
                animated: _e.animated
              }])
            }, [
              h("div", {
                class: "property-row",
                onClick: ($e) => P(_e.id)
              }, [
                h("span", {
                  class: Ie(["visibility-toggle", { visible: v.value.includes(_e.id) }]),
                  onClick: Je(($e) => Y(_e.id), ["stop"])
                }, null, 10, cE),
                h("span", {
                  class: "property-color",
                  style: Xe({ background: fe(_e.id) })
                }, null, 4),
                h("span", dE, pe(_e.name), 1),
                _e.animated ? (V(), B("span", hE, pe(_e.keyframes.length), 1)) : Te("", !0)
              ], 8, uE),
              _e.name === "Position" || _e.name === "Scale" ? (V(), B("div", fE, [
                (V(), B(Re, null, Ue(["x", "y", "z"], ($e) => {
                  var Be;
                  return h("button", {
                    key: $e,
                    class: Ie({
                      active: (Be = m.value[_e.id]) == null ? void 0 : Be.includes($e),
                      hasValue: R(_e, $e)
                    }),
                    onClick: (Ze) => w(_e.id, $e)
                  }, pe($e.toUpperCase()), 11, pE);
                }), 64))
              ])) : Te("", !0)
            ], 2))), 128)),
            oe.value.length === 0 ? (V(), B("div", mE, " No animated properties ")) : Te("", !0)
          ]),
          h("div", gE, [
            h("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              h("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: _n
              }, null, 512)
            ], 512),
            h("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              h("canvas", {
                ref_key: "canvasRef",
                ref: r,
                onMousedown: Q,
                onMousemove: ce,
                onMouseup: Z,
                onMouseleave: Z,
                onWheel: xe,
                onContextmenu: Je(Ce, ["prevent"])
              }, null, 544),
              _.value ? (V(), B("div", {
                key: 0,
                class: "selection-box",
                style: Xe({
                  left: _.value.x + "px",
                  top: _.value.y + "px",
                  width: _.value.width + "px",
                  height: _.value.height + "px"
                })
              }, null, 4)) : Te("", !0),
              (V(), B("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${f.value}`
              }, [
                (V(!0), B(Re, null, Ue(z.value, (_e) => (V(), B("g", {
                  key: _e.id,
                  class: "property-handles"
                }, [
                  (V(!0), B(Re, null, Ue(_e.keyframes, ($e, Be) => {
                    var Ze, it, Qe, zt, si, jr, $r, Br;
                    return V(), B(Re, { key: Be }, [
                      ae($e) ? (V(), B("g", {
                        key: 0,
                        class: Ie(["keyframe-marker", {
                          selected: D(_e.id, Be),
                          hovered: ((Ze = S.value) == null ? void 0 : Ze.propId) === _e.id && ((it = S.value) == null ? void 0 : it.index) === Be
                        }]),
                        onMousedown: Je((Bi) => Se(_e.id, Be, Bi), ["stop"])
                      }, [
                        h("rect", {
                          x: ie($e) - 5,
                          y: be(_e, $e) - 5,
                          width: "10",
                          height: "10",
                          fill: fe(_e.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${ie($e)}, ${be(_e, $e)})`
                        }, null, 8, bE)
                      ], 42, yE)) : Te("", !0),
                      D(_e.id, Be) && $e.interpolation !== "hold" ? (V(), B("g", xE, [
                        _e.keyframes[Be + 1] && ($e.outHandle.enabled || $e.interpolation === "bezier") ? (V(), B("g", _E, [
                          h("line", {
                            x1: ie($e),
                            y1: be(_e, $e),
                            x2: ee(_e, Be),
                            y2: ve(_e, Be),
                            class: "handle-line"
                          }, null, 8, wE),
                          h("circle", {
                            cx: ee(_e, Be),
                            cy: ve(_e, Be),
                            r: "5",
                            class: Ie(["handle-point", { dragging: ((Qe = x.value) == null ? void 0 : Qe.type) === "outHandle" && ((zt = x.value) == null ? void 0 : zt.propId) === _e.id && ((si = x.value) == null ? void 0 : si.index) === Be }]),
                            onMousedown: Je((Bi) => ye("outHandle", _e.id, Be), ["stop"])
                          }, null, 42, SE)
                        ])) : Te("", !0),
                        Be > 0 && ($e.inHandle.enabled || $e.interpolation === "bezier") ? (V(), B("g", CE, [
                          h("line", {
                            x1: ie($e),
                            y1: be(_e, $e),
                            x2: G(_e, Be),
                            y2: N(_e, Be),
                            class: "handle-line"
                          }, null, 8, kE),
                          h("circle", {
                            cx: G(_e, Be),
                            cy: N(_e, Be),
                            r: "5",
                            class: Ie(["handle-point", { dragging: ((jr = x.value) == null ? void 0 : jr.type) === "inHandle" && (($r = x.value) == null ? void 0 : $r.propId) === _e.id && ((Br = x.value) == null ? void 0 : Br.index) === Be }]),
                            onMousedown: Je((Bi) => ye("inHandle", _e.id, Be), ["stop"])
                          }, null, 42, TE)
                        ])) : Te("", !0)
                      ])) : Te("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                h("line", {
                  x1: T.value,
                  y1: 0,
                  x2: T.value,
                  y2: f.value,
                  class: "current-time-line"
                }, null, 8, ME)
              ], 8, vE))
            ], 512),
            h("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: u
            }, [
              h("canvas", {
                ref_key: "valueAxisCanvas",
                ref: c
              }, null, 512)
            ], 512)
          ])
        ]),
        b.value.length > 0 ? (V(), B("div", OE, [
          h("div", EE, [
            se[11] || (se[11] = h("span", { class: "info-label" }, "Frame:", -1)),
            h("input", {
              type: "number",
              value: (he = b.value[0]) == null ? void 0 : he.keyframe.frame,
              onChange: Vt,
              class: "info-input"
            }, null, 40, PE)
          ]),
          h("div", DE, [
            se[12] || (se[12] = h("span", { class: "info-label" }, "Value:", -1)),
            h("input", {
              type: "number",
              value: J(b.value[0]),
              onChange: jt,
              class: "info-input",
              step: "0.1"
            }, null, 40, AE)
          ]),
          h("div", IE, [
            se[14] || (se[14] = h("span", { class: "info-label" }, "Interpolation:", -1)),
            h("select", {
              value: (De = b.value[0]) == null ? void 0 : De.keyframe.interpolation,
              onChange: Dt,
              class: "info-select"
            }, [...se[13] || (se[13] = [
              h("option", { value: "linear" }, "Linear", -1),
              h("option", { value: "bezier" }, "Bezier", -1),
              h("option", { value: "hold" }, "Hold", -1)
            ])], 40, FE)
          ])
        ])) : Te("", !0),
        C.value ? (V(), B("div", {
          key: 1,
          class: "context-menu",
          style: Xe({ left: C.value.x + "px", top: C.value.y + "px" }),
          onClick: se[4] || (se[4] = (_e) => C.value = null)
        }, [
          h("button", { onClick: Pe }, "Add Keyframe"),
          h("button", {
            onClick: je,
            disabled: b.value.length === 0
          }, "Delete Keyframe(s)", 8, LE),
          se[15] || (se[15] = h("hr", null, null, -1)),
          h("button", {
            onClick: Ge,
            disabled: b.value.length === 0
          }, "Copy", 8, zE),
          h("button", {
            onClick: ct,
            disabled: !k.value
          }, "Paste", 8, RE),
          se[16] || (se[16] = h("hr", null, null, -1)),
          h("button", { onClick: St }, "Select All"),
          h("button", { onClick: Ut }, "Invert Selection")
        ], 4)) : Te("", !0)
      ]);
    };
  }
}), jE = /* @__PURE__ */ mt(VE, [["__scopeId", "data-v-d467b4dd"]]), { abs: Gi, cos: Gn, sin: li, acos: $E, atan2: Ki, sqrt: Ss, pow: gn } = Math;
function qi(i) {
  return i < 0 ? -gn(-i, 1 / 3) : gn(i, 1 / 3);
}
const Yf = Math.PI, wo = 2 * Yf, Cs = Yf / 2, BE = 1e-6, fl = Number.MAX_SAFE_INTEGER || 9007199254740991, pl = Number.MIN_SAFE_INTEGER || -9007199254740991, WE = { x: 0, y: 0, z: 0 }, Ve = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(i, e) {
    const n = e(i);
    let s = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (s += n.z * n.z), Ss(s);
  },
  compute: function(i, e, n) {
    if (i === 0)
      return e[0].t = 0, e[0];
    const s = e.length - 1;
    if (i === 1)
      return e[s].t = 1, e[s];
    const r = 1 - i;
    let o = e;
    if (s === 0)
      return e[0].t = i, e[0];
    if (s === 1) {
      const l = {
        x: r * o[0].x + i * o[1].x,
        y: r * o[0].y + i * o[1].y,
        t: i
      };
      return n && (l.z = r * o[0].z + i * o[1].z), l;
    }
    if (s < 4) {
      let l = r * r, u = i * i, c, d, f, g = 0;
      s === 2 ? (o = [o[0], o[1], o[2], WE], c = l, d = r * i * 2, f = u) : s === 3 && (c = l * r, d = l * i * 3, f = r * u * 3, g = i * u);
      const p = {
        x: c * o[0].x + d * o[1].x + f * o[2].x + g * o[3].x,
        y: c * o[0].y + d * o[1].y + f * o[2].y + g * o[3].y,
        t: i
      };
      return n && (p.z = c * o[0].z + d * o[1].z + f * o[2].z + g * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * i,
          y: a[l].y + (a[l + 1].y - a[l].y) * i
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * i);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = i, a[0];
  },
  computeWithRatios: function(i, e, n, s) {
    const r = 1 - i, o = n, a = e;
    let l = o[0], u = o[1], c = o[2], d = o[3], f;
    if (l *= r, u *= i, a.length === 2)
      return f = l + u, {
        x: (l * a[0].x + u * a[1].x) / f,
        y: (l * a[0].y + u * a[1].y) / f,
        z: s ? (l * a[0].z + u * a[1].z) / f : !1,
        t: i
      };
    if (l *= r, u *= 2 * r, c *= i * i, a.length === 3)
      return f = l + u + c, {
        x: (l * a[0].x + u * a[1].x + c * a[2].x) / f,
        y: (l * a[0].y + u * a[1].y + c * a[2].y) / f,
        z: s ? (l * a[0].z + u * a[1].z + c * a[2].z) / f : !1,
        t: i
      };
    if (l *= r, u *= 1.5 * r, c *= 3 * r, d *= i * i * i, a.length === 4)
      return f = l + u + c + d, {
        x: (l * a[0].x + u * a[1].x + c * a[2].x + d * a[3].x) / f,
        y: (l * a[0].y + u * a[1].y + c * a[2].y + d * a[3].y) / f,
        z: s ? (l * a[0].z + u * a[1].z + c * a[2].z + d * a[3].z) / f : !1,
        t: i
      };
  },
  derive: function(i, e) {
    const n = [];
    for (let s = i, r = s.length, o = r - 1; r > 1; r--, o--) {
      const a = [];
      for (let l = 0, u; l < o; l++)
        u = {
          x: o * (s[l + 1].x - s[l].x),
          y: o * (s[l + 1].y - s[l].y)
        }, e && (u.z = o * (s[l + 1].z - s[l].z)), a.push(u);
      n.push(a), s = a;
    }
    return n;
  },
  between: function(i, e, n) {
    return e <= i && i <= n || Ve.approximately(i, e) || Ve.approximately(i, n);
  },
  approximately: function(i, e, n) {
    return Gi(i - e) <= (n || BE);
  },
  length: function(i) {
    const n = Ve.Tvalues.length;
    let s = 0;
    for (let r = 0, o; r < n; r++)
      o = 0.5 * Ve.Tvalues[r] + 0.5, s += Ve.Cvalues[r] * Ve.arcfn(o, i);
    return 0.5 * s;
  },
  map: function(i, e, n, s, r) {
    const o = n - e, a = r - s, l = i - e, u = l / o;
    return s + a * u;
  },
  lerp: function(i, e, n) {
    const s = {
      x: e.x + i * (n.x - e.x),
      y: e.y + i * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (s.z = e.z + i * (n.z - e.z)), s;
  },
  pointToString: function(i) {
    let e = i.x + "/" + i.y;
    return typeof i.z < "u" && (e += "/" + i.z), e;
  },
  pointsToString: function(i) {
    return "[" + i.map(Ve.pointToString).join(", ") + "]";
  },
  copy: function(i) {
    return JSON.parse(JSON.stringify(i));
  },
  angle: function(i, e, n) {
    const s = e.x - i.x, r = e.y - i.y, o = n.x - i.x, a = n.y - i.y, l = s * a - r * o, u = s * o + r * a;
    return Ki(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(i, e) {
    const n = "" + i, s = n.indexOf(".");
    return parseFloat(n.substring(0, s + 1 + e));
  },
  dist: function(i, e) {
    const n = i.x - e.x, s = i.y - e.y;
    return Ss(n * n + s * s);
  },
  closest: function(i, e) {
    let n = gn(2, 63), s, r;
    return i.forEach(function(o, a) {
      r = Ve.dist(e, o), r < n && (n = r, s = a);
    }), { mdist: n, mpos: s };
  },
  abcratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = gn(i, e) + gn(1 - i, e), s = n - 1;
    return Gi(s / n);
  },
  projectionratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = gn(1 - i, e), s = gn(i, e) + n;
    return n / s;
  },
  lli8: function(i, e, n, s, r, o, a, l) {
    const u = (i * s - e * n) * (r - a) - (i - n) * (r * l - o * a), c = (i * s - e * n) * (o - l) - (e - s) * (r * l - o * a), d = (i - n) * (o - l) - (e - s) * (r - a);
    return d == 0 ? !1 : { x: u / d, y: c / d };
  },
  lli4: function(i, e, n, s) {
    const r = i.x, o = i.y, a = e.x, l = e.y, u = n.x, c = n.y, d = s.x, f = s.y;
    return Ve.lli8(r, o, a, l, u, c, d, f);
  },
  lli: function(i, e) {
    return Ve.lli4(i, i.c, e, e.c);
  },
  makeline: function(i, e) {
    return new Gf(
      i.x,
      i.y,
      (i.x + e.x) / 2,
      (i.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(i) {
    let e = fl, n = fl, s = pl, r = pl;
    return i.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), s < a.x.max && (s = a.x.max), r < a.y.max && (r = a.y.max);
    }), {
      x: { min: e, mid: (e + s) / 2, max: s, size: s - e },
      y: { min: n, mid: (n + r) / 2, max: r, size: r - n }
    };
  },
  shapeintersections: function(i, e, n, s, r) {
    if (!Ve.bboxoverlap(e, s)) return [];
    const o = [], a = [i.startcap, i.forward, i.back, i.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const d = u.intersects(c, r);
        d.length > 0 && (d.c1 = u, d.c2 = c, d.s1 = i, d.s2 = n, o.push(d));
      });
    }), o;
  },
  makeshape: function(i, e, n) {
    const s = e.points.length, r = i.points.length, o = Ve.makeline(e.points[s - 1], i.points[0]), a = Ve.makeline(i.points[r - 1], e.points[0]), l = {
      startcap: o,
      forward: i,
      back: e,
      endcap: a,
      bbox: Ve.findbbox([o, i, e, a])
    };
    return l.intersections = function(u) {
      return Ve.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        n
      );
    }, l;
  },
  getminmax: function(i, e, n) {
    if (!n) return { min: 0, max: 0 };
    let s = fl, r = pl, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, u = n.length; l < u; l++)
      o = n[l], a = i.get(o), a[e] < s && (s = a[e]), a[e] > r && (r = a[e]);
    return { min: s, mid: (s + r) / 2, max: r, size: r - s };
  },
  align: function(i, e) {
    const n = e.p1.x, s = e.p1.y, r = -Ki(e.p2.y - s, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * Gn(r) - (a.y - s) * li(r),
        y: (a.x - n) * li(r) + (a.y - s) * Gn(r)
      };
    };
    return i.map(o);
  },
  roots: function(i, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = i.length - 1, s = Ve.align(i, e), r = function(M) {
      return 0 <= M && M <= 1;
    };
    if (n === 2) {
      const M = s[0].y, O = s[1].y, F = s[2].y, $ = M - 2 * O + F;
      if ($ !== 0) {
        const ne = -Ss(O * O - M * F), oe = -M + O, z = -(ne + oe) / $, X = -(-ne + oe) / $;
        return [z, X].filter(r);
      } else if (O !== F && $ === 0)
        return [(2 * O - F) / (2 * O - 2 * F)].filter(r);
      return [];
    }
    const o = s[0].y, a = s[1].y, l = s[2].y, u = s[3].y;
    let c = -o + 3 * a - 3 * l + u, d = 3 * o - 6 * a + 3 * l, f = -3 * o + 3 * a, g = o;
    if (Ve.approximately(c, 0)) {
      if (Ve.approximately(d, 0))
        return Ve.approximately(f, 0) ? [] : [-g / f].filter(r);
      const M = Ss(f * f - 4 * d * g), O = 2 * d;
      return [(M - f) / O, (-f - M) / O].filter(r);
    }
    d /= c, f /= c, g /= c;
    const p = (3 * f - d * d) / 3, y = p / 3, v = (2 * d * d * d - 9 * d * f + 27 * g) / 27, m = v / 2, b = m * m + y * y * y;
    let S, x, _, C, k;
    if (b < 0) {
      const M = -p / 3, O = M * M * M, F = Ss(O), $ = -v / (2 * F), ne = $ < -1 ? -1 : $ > 1 ? 1 : $, oe = $E(ne), z = qi(F), X = 2 * z;
      return _ = X * Gn(oe / 3) - d / 3, C = X * Gn((oe + wo) / 3) - d / 3, k = X * Gn((oe + 2 * wo) / 3) - d / 3, [_, C, k].filter(r);
    } else {
      if (b === 0)
        return S = m < 0 ? qi(-m) : -qi(m), _ = 2 * S - d / 3, C = -S - d / 3, [_, C].filter(r);
      {
        const M = Ss(b);
        return S = qi(-m + M), x = qi(m + M), [S - x - d / 3].filter(r);
      }
    }
  },
  droots: function(i) {
    if (i.length === 3) {
      const e = i[0], n = i[1], s = i[2], r = e - 2 * n + s;
      if (r !== 0) {
        const o = -Ss(n * n - e * s), a = -e + n, l = -(o + a) / r, u = -(-o + a) / r;
        return [l, u];
      } else if (n !== s && r === 0)
        return [(2 * n - s) / (2 * (n - s))];
      return [];
    }
    if (i.length === 2) {
      const e = i[0], n = i[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(i, e, n, s, r) {
    let o, a, l, u, c = 0, d = 0;
    const f = Ve.compute(i, e), g = Ve.compute(i, n), p = f.x * f.x + f.y * f.y;
    if (s ? (o = Ss(
      gn(f.y * g.z - g.y * f.z, 2) + gn(f.z * g.x - g.z * f.x, 2) + gn(f.x * g.y - g.x * f.y, 2)
    ), a = gn(p + f.z * f.z, 3 / 2)) : (o = f.x * g.y - f.y * g.x, a = gn(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (c = o / a, d = a / o, !r) {
      const y = Ve.curvature(i - 1e-3, e, n, s, !0).k, v = Ve.curvature(i + 1e-3, e, n, s, !0).k;
      u = (v - c + (c - y)) / 2, l = (Gi(v - c) + Gi(c - y)) / 2;
    }
    return { k: c, r: d, dk: u, adk: l };
  },
  inflections: function(i) {
    if (i.length < 4) return [];
    const e = Ve.align(i, { p1: i[0], p2: i.slice(-1)[0] }), n = e[2].x * e[1].y, s = e[3].x * e[1].y, r = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * s + 3 * r - o), l = 18 * (3 * n - s - 3 * r), u = 18 * (r - n);
    if (Ve.approximately(a, 0)) {
      if (!Ve.approximately(l, 0)) {
        let g = -u / l;
        if (0 <= g && g <= 1) return [g];
      }
      return [];
    }
    const c = 2 * a;
    if (Ve.approximately(c, 0)) return [];
    const d = l * l - 4 * a * u;
    if (d < 0) return [];
    const f = Math.sqrt(d);
    return [(f - l) / c, -(l + f) / c].filter(function(g) {
      return 0 <= g && g <= 1;
    });
  },
  bboxoverlap: function(i, e) {
    const n = ["x", "y"], s = n.length;
    for (let r = 0, o, a, l, u; r < s; r++)
      if (o = n[r], a = i[o].mid, l = e[o].mid, u = (i[o].size + e[o].size) / 2, Gi(a - l) >= u) return !1;
    return !0;
  },
  expandbox: function(i, e) {
    e.x.min < i.x.min && (i.x.min = e.x.min), e.y.min < i.y.min && (i.y.min = e.y.min), e.z && e.z.min < i.z.min && (i.z.min = e.z.min), e.x.max > i.x.max && (i.x.max = e.x.max), e.y.max > i.y.max && (i.y.max = e.y.max), e.z && e.z.max > i.z.max && (i.z.max = e.z.max), i.x.mid = (i.x.min + i.x.max) / 2, i.y.mid = (i.y.min + i.y.max) / 2, i.z && (i.z.mid = (i.z.min + i.z.max) / 2), i.x.size = i.x.max - i.x.min, i.y.size = i.y.max - i.y.min, i.z && (i.z.size = i.z.max - i.z.min);
  },
  pairiteration: function(i, e, n) {
    const s = i.bbox(), r = e.bbox(), o = 1e5, a = n || 0.5;
    if (s.x.size + s.y.size < a && r.x.size + r.y.size < a)
      return [
        (o * (i._t1 + i._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = i.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(f) {
      return Ve.bboxoverlap(f.left.bbox(), f.right.bbox());
    });
    let d = [];
    return c.length === 0 || (c.forEach(function(f) {
      d = d.concat(
        Ve.pairiteration(f.left, f.right, a)
      );
    }), d = d.filter(function(f, g) {
      return d.indexOf(f) === g;
    })), d;
  },
  getccenter: function(i, e, n) {
    const s = e.x - i.x, r = e.y - i.y, o = n.x - e.x, a = n.y - e.y, l = s * Gn(Cs) - r * li(Cs), u = s * li(Cs) + r * Gn(Cs), c = o * Gn(Cs) - a * li(Cs), d = o * li(Cs) + a * Gn(Cs), f = (i.x + e.x) / 2, g = (i.y + e.y) / 2, p = (e.x + n.x) / 2, y = (e.y + n.y) / 2, v = f + l, m = g + u, b = p + c, S = y + d, x = Ve.lli8(f, g, v, m, p, y, b, S), _ = Ve.dist(x, i);
    let C = Ki(i.y - x.y, i.x - x.x), k = Ki(e.y - x.y, e.x - x.x), M = Ki(n.y - x.y, n.x - x.x), O;
    return C < M ? ((C > k || k > M) && (C += wo), C > M && (O = M, M = C, C = O)) : M < k && k < C ? (O = M, M = C, C = O) : M += wo, x.s = C, x.e = M, x.r = _, x;
  },
  numberSort: function(i, e) {
    return i - e;
  }
};
class pr {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ve.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), s = 1; s < e.length; s++)
      Ve.expandbox(n, e[s].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(s) {
      n.push(...s.offset(e));
    }), new pr(n);
  }
}
const { abs: Zi, min: bd, max: xd, cos: UE, sin: NE, acos: HE, sqrt: Ji } = Math, XE = Math.PI;
let Gf = class kt {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), s = !1;
    if (typeof n[0] == "object") {
      s = n.length;
      const p = [];
      n.forEach(function(y) {
        ["x", "y", "z"].forEach(function(v) {
          typeof y[v] < "u" && p.push(y[v]);
        });
      }), n = p;
    }
    let r = !1;
    const o = n.length;
    if (s) {
      if (s > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !r && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let p = 0, y = a ? 3 : 2; p < o; p += y) {
      var u = {
        x: n[p],
        y: n[p + 1]
      };
      a && (u.z = n[p + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const f = Ve.align(l, { p1: l[0], p2: l[c] }), g = Ve.dist(l[0], l[c]);
    this._linear = f.reduce((p, y) => p + Zi(y.y), 0) < g / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, s, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new kt(n, n, s);
    if (r === 1)
      return new kt(e, n, n);
    const o = kt.getABC(2, e, n, s, r);
    return new kt(e, o.A, s);
  }
  static cubicFromPoints(e, n, s, r, o) {
    typeof r > "u" && (r = 0.5);
    const a = kt.getABC(3, e, n, s, r);
    typeof o > "u" && (o = Ve.dist(n, a.C));
    const l = o * (1 - r) / r, u = Ve.dist(e, s), c = (s.x - e.x) / u, d = (s.y - e.y) / u, f = o * c, g = o * d, p = l * c, y = l * d, v = { x: n.x - f, y: n.y - g }, m = { x: n.x + p, y: n.y + y }, b = a.A, S = { x: b.x + (v.x - b.x) / (1 - r), y: b.y + (v.y - b.y) / (1 - r) }, x = { x: b.x + (m.x - b.x) / r, y: b.y + (m.y - b.y) / r }, _ = { x: e.x + (S.x - e.x) / r, y: e.y + (S.y - e.y) / r }, C = {
      x: s.x + (x.x - s.x) / (1 - r),
      y: s.y + (x.y - s.y) / (1 - r)
    };
    return new kt(e, _, C, s);
  }
  static getUtils() {
    return Ve;
  }
  getUtils() {
    return kt.getUtils();
  }
  static get PolyBezier() {
    return pr;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ve.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, s = e[0].y, r = ["M", n, s, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      r.push(e[o].x), r.push(e[o].y);
    return r.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ve.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Ve.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Ve.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, s, r, o = 0.5) {
    const a = Ve.projectionratio(o, e), l = 1 - a, u = {
      x: a * n.x + l * r.x,
      y: a * n.y + l * r.y
    }, c = Ve.abcratio(o, e);
    return { A: {
      x: s.x + (s.x - u.x) / c,
      y: s.y + (s.y - u.y) / c
    }, B: s, C: u, S: n, E: r };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let s = this.points[0], r = this.points[this.order];
    return kt.getABC(this.order, s, n, r, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, s, r; n < e; n++)
      r = n / (e - 1), s = this.compute(r), s.t = r, this._lut.push(s);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const s = this.getLUT(), r = [];
    for (let o = 0, a, l = 0; o < s.length; o++)
      a = s[o], Ve.dist(a, e) < n && (r.push(a), l += o / s.length);
    return r.length ? t /= r.length : !1;
  }
  project(e) {
    const n = this.getLUT(), s = n.length - 1, r = Ve.closest(n, e), o = r.mpos, a = (o - 1) / s, l = (o + 1) / s, u = 0.1 / s;
    let c = r.mdist, d = a, f = d, g;
    c += 1;
    for (let p; d < l + u; d += u)
      g = this.compute(d), p = Ve.dist(e, g), p < c && (c = p, f = d);
    return f = f < 0 ? 0 : f > 1 ? 1 : f, g = this.compute(f), g.t = f, g.d = c, g;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ve.computeWithRatios(e, this.points, this.ratios, this._3d) : Ve.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], s = e.length;
    for (let r = 1, o, a; r < s; r++)
      o = e[r], a = e[r - 1], n[r] = {
        x: (s - r) / s * o.x + r / s * a.x,
        y: (s - r) / s * o.y + r / s * a.y
      };
    return n[s] = e[s - 1], new kt(n);
  }
  derivative(e) {
    return Ve.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ve.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new kt(Ve.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ve.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ve.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), s = Ji(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / s, y: n.x / s };
  }
  __normal3(e) {
    const n = this.derivative(e), s = this.derivative(e + 0.01), r = Ji(n.x * n.x + n.y * n.y + n.z * n.z), o = Ji(s.x * s.x + s.y * s.y + s.z * s.z);
    n.x /= r, n.y /= r, n.z /= r, s.x /= o, s.y /= o, s.z /= o;
    const a = {
      x: s.y * n.z - s.z * n.y,
      y: s.z * n.x - s.x * n.z,
      z: s.x * n.y - s.y * n.x
    }, l = Ji(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const u = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: u[0] * n.x + u[1] * n.y + u[2] * n.z,
      y: u[3] * n.x + u[4] * n.y + u[5] * n.z,
      z: u[6] * n.x + u[7] * n.y + u[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, s = [], r = [], o = 0;
    for (r[o++] = n[0], r[o++] = n[1], r[o++] = n[2], this.order === 3 && (r[o++] = n[3]); n.length > 1; ) {
      s = [];
      for (let a = 0, l, u = n.length - 1; a < u; a++)
        l = Ve.lerp(e, n[a], n[a + 1]), r[o++] = l, s.push(l);
      n = s;
    }
    return r;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const s = this.hull(e), r = {
      left: this.order === 2 ? new kt([s[0], s[3], s[5]]) : new kt([s[0], s[4], s[7], s[9]]),
      right: this.order === 2 ? new kt([s[5], s[4], s[2]]) : new kt([s[9], s[8], s[6], s[3]]),
      span: s
    };
    return r.left._t1 = Ve.map(0, 0, 1, this._t1, this._t2), r.left._t2 = Ve.map(e, 0, 1, this._t1, this._t2), r.right._t1 = Ve.map(e, 0, 1, this._t1, this._t2), r.right._t2 = Ve.map(1, 0, 1, this._t1, this._t2), n ? (n = Ve.map(n, e, 1, 0, 1), r.right.split(n).left) : r;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(s) {
        let r = function(a) {
          return a[s];
        }, o = this.dpoints[0].map(r);
        e[s] = Ve.droots(o), this.order === 3 && (o = this.dpoints[1].map(r), e[s] = e[s].concat(Ve.droots(o))), e[s] = e[s].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[s].sort(Ve.numberSort));
      }).bind(this)
    ), e.values = n.sort(Ve.numberSort).filter(function(s, r) {
      return n.indexOf(s) === r;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(s) {
        n[s] = Ve.getminmax(this, s, e[s]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), s = e.bbox();
    return Ve.bboxoverlap(n, s);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const s = this.get(e), r = this.normal(e), o = {
        c: s,
        n: r,
        x: s.x + r.x * n,
        y: s.y + r.y * n
      };
      return this._3d && (o.z = s.z + r.z * n), o;
    }
    if (this._linear) {
      const s = this.normal(0), r = this.points.map(function(o) {
        const a = {
          x: o.x + e * s.x,
          y: o.y + e * s.y
        };
        return o.z && s.z && (a.z = o.z + e * s.z), a;
      });
      return [new kt(r)];
    }
    return this.reduce().map(function(s) {
      return s._linear ? s.offset(e)[0] : s.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = Ve.angle(this.points[0], this.points[3], this.points[1]), o = Ve.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && o < 0 || r < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let s = e.x * n.x + e.y * n.y;
    return this._3d && (s += e.z * n.z), Zi(HE(s)) < XE / 3;
  }
  reduce() {
    let e, n = 0, s = 0, r = 0.01, o, a = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), n = u[0], e = 1; e < u.length; e++)
      s = u[e], o = this.split(n, s), o._t1 = n, o._t2 = s, a.push(o), n = s;
    return a.forEach(function(c) {
      for (n = 0, s = 0; s <= 1; )
        for (s = n + r; s <= 1 + r; s += r)
          if (o = c.split(n, s), !o.simple()) {
            if (s -= r, Zi(n - s) < r)
              return [];
            o = c.split(n, s), o._t1 = Ve.map(n, 0, 1, c._t1, c._t2), o._t2 = Ve.map(s, 0, 1, c._t1, c._t2), l.push(o), n = s;
            break;
          }
      n < 1 && (o = c.split(n, 1), o._t1 = Ve.map(n, 0, 1, c._t1, c._t2), o._t2 = c._t2, l.push(o));
    }), l;
  }
  translate(e, n, s) {
    s = typeof s == "number" ? s : n;
    const r = this.order;
    let o = this.points.map((a, l) => (1 - l / r) * n + l / r * s);
    return new kt(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let s = !1;
    if (typeof e == "function" && (s = e), s && n === 2)
      return this.raise().scale(s);
    const r = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        s ? s(0) : e,
        s ? s(1) : e
      );
    const a = s ? s(0) : e, l = s ? s(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], d = Ve.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(f) {
      const g = c[f * n] = Ve.copy(o[f * n]);
      g.x += (f ? l : a) * u[f].n.x, g.y += (f ? l : a) * u[f].n.y;
    }), s ? ([0, 1].forEach(function(f) {
      if (!(n === 2 && f)) {
        var g = o[f + 1], p = {
          x: g.x - d.x,
          y: g.y - d.y
        }, y = s ? s((f + 1) / n) : e;
        s && !r && (y = -y);
        var v = Ji(p.x * p.x + p.y * p.y);
        p.x /= v, p.y /= v, c[f + 1] = {
          x: g.x + y * p.x,
          y: g.y + y * p.y
        };
      }
    }), new kt(c)) : ([0, 1].forEach((f) => {
      if (n === 2 && f) return;
      const g = c[f * n], p = this.derivative(f), y = { x: g.x + p.x, y: g.y + p.y };
      c[f + 1] = Ve.lli4(g, y, d, o[f + 1]);
    }), new kt(c));
  }
  outline(e, n, s, r) {
    if (n = n === void 0 ? e : n, this._linear) {
      const C = this.normal(0), k = this.points[0], M = this.points[this.points.length - 1];
      let O, F, $;
      s === void 0 && (s = e, r = n), O = { x: k.x + C.x * e, y: k.y + C.y * e }, $ = { x: M.x + C.x * s, y: M.y + C.y * s }, F = { x: (O.x + $.x) / 2, y: (O.y + $.y) / 2 };
      const ne = [O, F, $];
      O = { x: k.x - C.x * n, y: k.y - C.y * n }, $ = { x: M.x - C.x * r, y: M.y - C.y * r }, F = { x: (O.x + $.x) / 2, y: (O.y + $.y) / 2 };
      const oe = [$, F, O], z = Ve.makeline(oe[2], ne[0]), X = Ve.makeline(ne[2], oe[0]), T = [z, new kt(ne), X, new kt(oe)];
      return new pr(T);
    }
    const o = this.reduce(), a = o.length, l = [];
    let u = [], c, d = 0, f = this.length();
    const g = typeof s < "u" && typeof r < "u";
    function p(C, k, M, O, F) {
      return function($) {
        const ne = O / M, oe = (O + F) / M, z = k - C;
        return Ve.map($, 0, 1, C + ne * z, C + oe * z);
      };
    }
    o.forEach(function(C) {
      const k = C.length();
      g ? (l.push(
        C.scale(p(e, s, f, d, k))
      ), u.push(
        C.scale(p(-n, -r, f, d, k))
      )) : (l.push(C.scale(e)), u.push(C.scale(-n))), d += k;
    }), u = u.map(function(C) {
      return c = C.points, c[3] ? C.points = [c[3], c[2], c[1], c[0]] : C.points = [c[2], c[1], c[0]], C;
    }).reverse();
    const y = l[0].points[0], v = l[a - 1].points[l[a - 1].points.length - 1], m = u[a - 1].points[u[a - 1].points.length - 1], b = u[0].points[0], S = Ve.makeline(m, y), x = Ve.makeline(v, b), _ = [S].concat(l).concat([x]).concat(u);
    return new pr(_);
  }
  outlineshapes(e, n, s) {
    n = n || e;
    const r = this.outline(e, n).curves, o = [];
    for (let a = 1, l = r.length; a < l / 2; a++) {
      const u = Ve.makeshape(
        r[a],
        r[l - a],
        s
      );
      u.startcap.virtual = a > 1, u.endcap.virtual = a < l / 2 - 1, o.push(u);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof kt && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = bd(e.p1.x, e.p2.x), s = bd(e.p1.y, e.p2.y), r = xd(e.p1.x, e.p2.x), o = xd(e.p1.y, e.p2.y);
    return Ve.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return Ve.between(l.x, n, r) && Ve.between(l.y, s, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), s = n.length - 2, r = [];
    for (let o = 0, a, l, u; o < s; o++)
      l = n.slice(o, o + 1), u = n.slice(o + 2), a = this.curveintersects(l, u, e), r.push(...a);
    return r;
  }
  curveintersects(e, n, s) {
    const r = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && r.push({ left: a, right: l });
      });
    });
    let o = [];
    return r.forEach(function(a) {
      const l = Ve.pairiteration(
        a.left,
        a.right,
        s
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, s, r) {
    const o = (r - s) / 4, a = this.get(s + o), l = this.get(r - o), u = Ve.dist(e, n), c = Ve.dist(e, a), d = Ve.dist(e, l);
    return Zi(c - u) + Zi(d - u);
  }
  _iterate(e, n) {
    let s = 0, r = 1, o;
    do {
      o = 0, r = 1;
      let a = this.get(s), l, u, c, d, f = !1, g = !1, p, y = r, v = 1;
      do
        if (g = f, d = c, y = (s + r) / 2, l = this.get(y), u = this.get(r), c = Ve.getccenter(a, l, u), c.interval = {
          start: s,
          end: r
        }, f = this._error(c, a, s, r) <= e, p = g && !f, p || (v = r), f) {
          if (r >= 1) {
            if (c.interval.end = v = 1, d = c, r > 1) {
              let b = {
                x: c.x + c.r * UE(c.e),
                y: c.y + c.r * NE(c.e)
              };
              c.e += Ve.angle({ x: c.x, y: c.y }, b, this.get(1));
            }
            break;
          }
          r = r + (r - s) / 2;
        } else
          r = y;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      d = d || c, n.push(d), s = v;
    } while (r < 1);
    return n;
  }
};
const YE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: Gf
}, Symbol.toStringTag, { value: "Module" })), _d = YE;
class GE {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    He(this, "curve");
    He(this, "lut");
    He(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, s = this.curve.get(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.get(o);
      if (r > 0) {
        const l = a.x - s.x, u = a.y - s.y;
        n += Math.sqrt(l * l + u * u);
      }
      this.lut.push({
        t: o,
        length: n
      }), s = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, s = this.lut.length - 1;
    for (; n < s; ) {
      const l = Math.floor((n + s) / 2);
      this.lut[l].length < e ? n = l + 1 : s = l;
    }
    const r = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (r.length === o.length)
      return r.t;
    const a = (e - o.length) / (r.length - o.length);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], s = this.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * s;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function KE(i) {
  if (!i || i.length < 2)
    return null;
  let e = null;
  for (const n of i) {
    const [s, ...r] = n;
    if (s === "M")
      e = { x: r[0], y: r[1] };
    else {
      if (s === "C" && e)
        return new _d(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point 1
          r[2],
          r[3],
          // control point 2
          r[4],
          r[5]
          // end point
        );
      if (s === "Q" && e)
        return new _d(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point
          r[2],
          r[3]
          // end point
        );
    }
  }
  return null;
}
class qE {
  constructor() {
    He(this, "offscreenCanvas", null);
    He(this, "ctx", null);
    He(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const s = Math.round(e / 8) * 8, r = Math.round(n / 8) * 8, o = Math.max(256, s), a = Math.max(256, r), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, s) {
    const { frameCount: r } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let u = 0; u < r; u++) {
      s && s({
        frame: u,
        total: r,
        percent: Math.round(u / r * 100)
      }), this.stepParticleSystemsToFrame(e, u);
      const c = await this.generateFrame(e, u, n);
      l.push(c);
    }
    return this.particleSystems.clear(), s && s({
      frame: r,
      total: r,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, s) {
    const r = this.ctx, { width: o, height: a } = s;
    if (r.fillStyle = "#FFFFFF", r.fillRect(0, 0, o, a), s.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    r.fillStyle = "#000000";
    const l = o / e.composition.width, u = a / e.composition.height, c = e.layers.filter(
      (f) => f.type === "text" && f.visible && n >= f.inPoint && n <= f.outPoint
    );
    for (const f of c)
      await this.renderTextLayerToMatte(r, f, e, n, l, u);
    const d = e.layers.filter(
      (f) => f.type === "particles" && f.visible && n >= f.inPoint && n <= f.outPoint
    );
    for (const f of d)
      this.renderParticleLayerToMatte(r, f, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, s) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== s.width || this.offscreenCanvas.height !== s.height) && (this.offscreenCanvas = new OffscreenCanvas(s.width, s.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const r = await this.generateFrame(e, n, s);
    return URL.createObjectURL(r);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, s, r, o, a) {
    const l = n.data;
    if (!l) return;
    const u = n.properties.find((f) => f.name === "fontSize"), d = (u ? ns(u, r) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, s, r, d, o, a) : this.renderTextBlockToMatte(e, n, l, r, d, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, s, r, o, a, l, u) {
    const c = r.layers.find((x) => x.id === s.pathLayerId);
    if (!c || c.type !== "spline") return;
    const d = c.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const f = this.buildPathCommands(d);
    if (!f || f.length < 2) return;
    const g = KE(f);
    if (!g) return;
    const p = new GE(g), y = n.properties.find((x) => x.name === "pathOffset"), v = y ? ns(y, o) : s.pathOffset, m = p.totalLength;
    let b = v * m;
    const S = 4 * Math.min(l, u);
    for (const x of s.text) {
      if (x === " ") {
        const ne = e.measureText(" ").width;
        b += ne + s.letterSpacing;
        continue;
      }
      const _ = e.measureText(x).width, C = Math.max(0, Math.min(b, m)), { point: k, tangent: M } = p.getPointAtDistance(C), O = Math.atan2(M.y, M.x), F = k.x * l, $ = k.y * u;
      e.save(), e.translate(F, $), e.rotate(O), e.fillRect(
        -S,
        -a - S,
        _ + S * 2,
        a + S * 2
      ), e.restore(), b += _ + s.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const s = [];
    s.push(["M", n[0].x, n[0].y]);
    for (let r = 0; r < n.length - 1; r++) {
      const o = n[r], a = n[r + 1], l = o.handleOut || { x: o.x, y: o.y }, u = a.handleIn || { x: a.x, y: a.y };
      s.push([
        "C",
        l.x,
        l.y,
        u.x,
        u.y,
        a.x,
        a.y
      ]);
    }
    return s;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, s, r, o, a, l) {
    const u = n.transform.position, c = ns(u, r), d = n.transform.rotation, f = ns(d, r), g = n.transform.scale, p = ns(g, r);
    e.save(), e.translate(c.x * a, c.y * l), e.rotate(f * Math.PI / 180), e.scale(p.x, p.y);
    const v = e.measureText(s.text).width, m = o, b = 4;
    e.fillRect(
      -b,
      -m - b,
      v + b * 2,
      m + b * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", s) {
    const r = (await Promise.resolve().then(() => gD)).default, o = new r();
    e.forEach((c, d) => {
      const f = `${n}_${String(d).padStart(4, "0")}.png`;
      o.file(f, c);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (c) => {
        s && s(Math.round(c.percent));
      }
    ), l = URL.createObjectURL(a), u = document.createElement("a");
    u.href = l, u.download = `${n}.zip`, document.body.appendChild(u), u.click(), document.body.removeChild(u), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (s) => s.type === "particles"
    );
    for (const s of n) {
      const r = s.data;
      if (!r) continue;
      const o = new Ra(r.systemConfig);
      for (const l of r.emitters)
        o.addEmitter(l);
      for (const l of r.gravityWells)
        o.addGravityWell(l);
      for (const l of r.vortices)
        o.addVortex(l);
      for (const l of r.modulations)
        o.addModulation(l);
      const a = r.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(s.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const s of e.layers) {
        if (s.type !== "particles") continue;
        const r = this.particleSystems.get(s.id);
        r && s.visible && n >= s.inPoint && n <= s.outPoint && r.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, s, r) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(s, r), l = new OffscreenCanvas(s, r);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Us = new qE(), ZE = { class: "export-dialog" }, JE = { class: "dialog-header" }, QE = { class: "dialog-content" }, eP = { class: "form-group" }, tP = { class: "resolution-presets" }, nP = ["onClick"], sP = { class: "custom-resolution" }, iP = { class: "dimension-input" }, rP = { class: "dimension-input" }, oP = {
  key: 0,
  class: "dimension-warning"
}, aP = { class: "form-group" }, lP = { class: "matte-mode-options" }, uP = { class: "form-group" }, cP = { class: "preview-container" }, dP = ["src"], hP = {
  key: 1,
  class: "preview-placeholder"
}, fP = {
  key: 0,
  class: "progress-section"
}, pP = { class: "progress-bar" }, mP = { class: "progress-text" }, gP = { class: "dialog-footer" }, vP = { class: "export-info" }, yP = ["disabled"], bP = ["disabled"], xP = /* @__PURE__ */ pt({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(i, { emit: e }) {
    const n = e, s = Ot(), r = Us.getResolutionPresets(), o = me("720p (1280x720)"), a = me(1280), l = me(720), u = me(), c = me("exclude_text"), d = me(null), f = me(!1), g = me(0), p = me(""), y = Oe(() => a.value), v = Oe(() => l.value);
    function m(_) {
      o.value = _.label, a.value = _.width, l.value = _.height, u.value = void 0;
    }
    function b() {
      const _ = Us.validateDimensions(a.value, l.value);
      if (!_.valid)
        a.value = _.correctedWidth, l.value = _.correctedHeight, u.value = _.message, o.value = "";
      else {
        u.value = void 0;
        const C = r.find(
          (k) => k.width === a.value && k.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "";
      }
    }
    async function S() {
      if (!s.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const _ = {
        width: y.value,
        height: v.value,
        matteMode: c.value
      };
      d.value = await Us.generatePreviewFrame(
        s.project,
        0,
        _
      );
    }
    async function x() {
      if (f.value || !s.hasProject) return;
      f.value = !0, g.value = 0, p.value = "Generating frames...";
      const _ = {
        width: y.value,
        height: v.value,
        matteMode: c.value
      };
      try {
        const C = await Us.generateMatteSequence(
          s.project,
          _,
          (k) => {
            g.value = k.percent, p.value = `Generating frame ${k.frame + 1} of ${k.total}...`;
          }
        );
        p.value = "Creating ZIP archive...", await Us.downloadAsZip(
          C,
          `matte_${Date.now()}`,
          (k) => {
            p.value = `Compressing... ${k}%`;
          }
        ), p.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (C) {
        console.error("[ExportDialog] Export failed:", C), p.value = `Export failed: ${C instanceof Error ? C.message : "Unknown error"}`;
      } finally {
        f.value = !1;
      }
    }
    return ut(
      [y, v, c],
      () => {
        S();
      },
      { immediate: !1 }
    ), Rt(() => {
      if (s.hasProject) {
        const _ = Us.validateDimensions(s.width, s.height);
        a.value = _.correctedWidth, l.value = _.correctedHeight;
        const C = r.find(
          (k) => k.width === a.value && k.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "", _.valid || (u.value = _.message);
      }
      S();
    }), pn(() => {
      d.value && URL.revokeObjectURL(d.value), Us.dispose();
    }), (_, C) => (V(), B("div", {
      class: "export-dialog-overlay",
      onClick: C[6] || (C[6] = Je((k) => n("close"), ["self"]))
    }, [
      h("div", ZE, [
        h("div", JE, [
          C[8] || (C[8] = h("h3", null, "Export Matte Sequence", -1)),
          h("button", {
            class: "close-btn",
            onClick: C[0] || (C[0] = (k) => n("close"))
          }, [...C[7] || (C[7] = [
            h("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        h("div", QE, [
          h("div", eP, [
            C[13] || (C[13] = h("label", null, "Resolution", -1)),
            h("div", tP, [
              (V(!0), B(Re, null, Ue(Fe(r), (k) => (V(), B("button", {
                key: k.label,
                class: Ie(["preset-btn", { active: o.value === k.label }]),
                onClick: (M) => m(k)
              }, pe(k.label), 11, nP))), 128))
            ]),
            h("div", sP, [
              h("div", iP, [
                C[9] || (C[9] = h("label", null, "Width", -1)),
                tt(h("input", {
                  "onUpdate:modelValue": C[1] || (C[1] = (k) => a.value = k),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: b
                }, null, 544), [
                  [
                    $t,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              C[11] || (C[11] = h("span", { class: "dimension-x" }, "", -1)),
              h("div", rP, [
                C[10] || (C[10] = h("label", null, "Height", -1)),
                tt(h("input", {
                  "onUpdate:modelValue": C[2] || (C[2] = (k) => l.value = k),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: b
                }, null, 544), [
                  [
                    $t,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            u.value ? (V(), B("p", oP, [
              C[12] || (C[12] = h("i", { class: "pi pi-info-circle" }, null, -1)),
              qe(" " + pe(u.value), 1)
            ])) : Te("", !0)
          ]),
          h("div", aP, [
            C[16] || (C[16] = h("label", null, "Matte Mode", -1)),
            h("div", lP, [
              h("button", {
                class: Ie(["mode-btn", { active: c.value === "exclude_text" }]),
                onClick: C[3] || (C[3] = (k) => c.value = "exclude_text")
              }, [...C[14] || (C[14] = [
                h("i", { class: "pi pi-ban" }, null, -1),
                h("span", null, "Exclude Text", -1),
                h("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              h("button", {
                class: Ie(["mode-btn", { active: c.value === "include_all" }]),
                onClick: C[4] || (C[4] = (k) => c.value = "include_all")
              }, [...C[15] || (C[15] = [
                h("i", { class: "pi pi-check-circle" }, null, -1),
                h("span", null, "Include All", -1),
                h("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          h("div", uP, [
            C[18] || (C[18] = h("label", null, "Preview (Frame 0)", -1)),
            h("div", cP, [
              d.value ? (V(), B("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, dP)) : (V(), B("div", hP, [...C[17] || (C[17] = [
                h("i", { class: "pi pi-image" }, null, -1),
                h("span", null, "Generating preview...", -1)
              ])]))
            ]),
            C[19] || (C[19] = h("p", { class: "preview-info" }, [
              qe(" White = Keep original / generate content"),
              h("br"),
              qe(" Black = Exclude from generation ")
            ], -1))
          ]),
          f.value ? (V(), B("div", fP, [
            h("div", pP, [
              h("div", {
                class: "progress-fill",
                style: Xe({ width: `${g.value}%` })
              }, null, 4)
            ]),
            h("p", mP, pe(p.value), 1)
          ])) : Te("", !0)
        ]),
        h("div", gP, [
          h("div", vP, [
            h("span", null, pe(Fe(s).frameCount) + " frames @ " + pe(y.value) + "" + pe(v.value), 1)
          ]),
          h("button", {
            class: "cancel-btn",
            onClick: C[5] || (C[5] = (k) => n("close")),
            disabled: f.value
          }, " Cancel ", 8, yP),
          h("button", {
            class: "export-btn",
            onClick: x,
            disabled: f.value || !Fe(s).hasProject
          }, [
            C[20] || (C[20] = h("i", { class: "pi pi-download" }, null, -1)),
            qe(" " + pe(f.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, bP)
        ])
      ])
    ]));
  }
}), _P = /* @__PURE__ */ mt(xP, [["__scopeId", "data-v-34eee532"]]), wP = { class: "workspace-layout" }, SP = { class: "toolbar" }, CP = { class: "tool-group" }, kP = { class: "tool-group" }, TP = ["title"], MP = { class: "icon" }, OP = { class: "timecode-display" }, EP = { class: "tool-group" }, PP = { class: "tool-group" }, DP = ["disabled"], AP = ["disabled"], IP = { class: "workspace-content" }, FP = { class: "panel left-panel" }, LP = { class: "panel-tabs" }, zP = { class: "panel-content" }, RP = { class: "panel viewport-panel" }, VP = { class: "viewport-header" }, jP = { class: "viewport-tabs" }, $P = { class: "viewport-controls" }, BP = { class: "viewport-content" }, WP = { class: "panel timeline-panel" }, UP = { class: "panel graph-editor-panel" }, NP = {
  key: 1,
  class: "panel timeline-panel"
}, HP = { class: "panel right-panel" }, XP = { class: "panel-tabs" }, YP = { class: "panel-content" }, GP = { class: "status-bar" }, KP = { class: "status-left" }, qP = { class: "status-item" }, ZP = { class: "status-item" }, JP = { class: "status-center" }, QP = {
  key: 0,
  class: "render-progress"
}, eD = { class: "status-right" }, tD = { class: "status-item" }, nD = { class: "status-item" }, sD = /* @__PURE__ */ pt({
  __name: "WorkspaceLayout",
  setup(i) {
    const e = Ot(), n = Oe({
      get: () => e.currentTool,
      set: (G) => e.setTool(G)
    }), s = me("standard"), r = me("project"), o = me("effects"), a = me("composition"), l = me("fit"), u = me(!1), c = me(!0), d = me(!1), f = me(!1), g = me(!1), p = me("cpu"), y = me(null), v = me(Rh()), m = me(Vh()), b = me({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), S = Oe(() => {
      var G, N;
      return ((N = (G = e.project) == null ? void 0 : G.composition) == null ? void 0 : N.width) || 1920;
    }), x = Oe(() => {
      var G, N;
      return ((N = (G = e.project) == null ? void 0 : G.composition) == null ? void 0 : N.height) || 1080;
    }), _ = me(60), C = me("0 MB"), k = me(0), M = Oe(() => {
      var R, P;
      const G = e.currentFrame, N = ((P = (R = e.project) == null ? void 0 : R.composition) == null ? void 0 : P.fps) || 30, te = G / N, fe = Math.floor(te / 60), ae = Math.floor(te % 60), D = G % N;
      return `${String(fe).padStart(2, "0")}:${String(ae).padStart(2, "0")}:${String(D).padStart(2, "0")}`;
    }), O = Oe(() => {
      var G, N;
      return ((N = (G = e.project) == null ? void 0 : G.meta) == null ? void 0 : N.name) || "Untitled Project";
    }), F = Oe(() => {
      var N;
      const G = (N = e.project) == null ? void 0 : N.composition;
      return G ? `${G.width}${G.height} @ ${G.fps}fps` : "No Composition";
    }), $ = Oe(() => e.canUndo), ne = Oe(() => e.canRedo);
    function oe() {
      g.value = !g.value, g.value ? e.play() : e.pause();
    }
    function z() {
      e.goToStart();
    }
    function X() {
      e.goToEnd();
    }
    function T() {
      e.setFrame(e.currentFrame + 1);
    }
    function H() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function ge() {
      e.undo();
    }
    function K() {
      e.redo();
    }
    function re(G) {
      v.value = G;
    }
    function ie() {
      console.log("[Weyl] Export completed");
    }
    ut(c, (G) => {
      y.value && (y.value.showGrid = G);
    }), ut(u, (G) => {
      y.value && (y.value.showGuides = G);
    });
    function be() {
      const G = y.value;
      if (G)
        if (l.value === "fit")
          G.fitToView();
        else {
          const N = parseInt(l.value) / 100;
          G.fabricCanvas && (G.fabricCanvas.setZoom(N), G.zoom = N, G.fabricCanvas.requestRenderAll());
        }
    }
    function J(G) {
      var N, te;
      if (!(((N = document.activeElement) == null ? void 0 : N.tagName) === "INPUT" || ((te = document.activeElement) == null ? void 0 : te.tagName) === "TEXTAREA"))
        switch (G.key.toLowerCase()) {
          case " ":
            G.preventDefault(), oe();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            G.ctrlKey || G.metaKey ? (G.preventDefault(), G.shiftKey ? K() : ge()) : n.value = "zoom";
            break;
          case "home":
            G.preventDefault(), z();
            break;
          case "end":
            G.preventDefault(), X();
            break;
          case "arrowleft":
            G.preventDefault(), H();
            break;
          case "arrowright":
            G.preventDefault(), T();
            break;
          case "g":
            G.shiftKey && (d.value = !d.value);
            break;
        }
    }
    let ee;
    function ve() {
      if ("memory" in performance) {
        const G = performance.memory, N = Math.round(G.usedJSHeapSize / 1024 / 1024);
        C.value = `${N} MB`;
      }
    }
    return Rt(async () => {
      const G = await bv();
      p.value = G.tier, window.addEventListener("keydown", J), ee = window.setInterval(ve, 1e3);
    }), pn(() => {
      window.removeEventListener("keydown", J), clearInterval(ee);
    }), (G, N) => (V(), B("div", wP, [
      h("div", SP, [
        h("div", CP, [
          h("button", {
            class: Ie({ active: n.value === "select" }),
            onClick: N[0] || (N[0] = (te) => n.value = "select"),
            title: "Select (V)"
          }, [...N[21] || (N[21] = [
            h("span", { class: "icon" }, "", -1)
          ])], 2),
          h("button", {
            class: Ie({ active: n.value === "pen" }),
            onClick: N[1] || (N[1] = (te) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...N[22] || (N[22] = [
            h("span", { class: "icon" }, "", -1)
          ])], 2),
          h("button", {
            class: Ie({ active: n.value === "text" }),
            onClick: N[2] || (N[2] = (te) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...N[23] || (N[23] = [
            h("span", { class: "icon" }, "T", -1)
          ])], 2),
          h("button", {
            class: Ie({ active: n.value === "hand" }),
            onClick: N[3] || (N[3] = (te) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...N[24] || (N[24] = [
            h("span", { class: "icon" }, "", -1)
          ])], 2),
          h("button", {
            class: Ie({ active: n.value === "zoom" }),
            onClick: N[4] || (N[4] = (te) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...N[25] || (N[25] = [
            h("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        N[34] || (N[34] = h("div", { class: "divider" }, null, -1)),
        h("div", kP, [
          h("button", {
            onClick: z,
            title: "Go to Start (Home)"
          }, [...N[26] || (N[26] = [
            h("span", { class: "icon" }, "", -1)
          ])]),
          h("button", {
            onClick: H,
            title: "Step Backward"
          }, [...N[27] || (N[27] = [
            h("span", { class: "icon" }, "", -1)
          ])]),
          h("button", {
            onClick: oe,
            title: g.value ? "Pause (Space)" : "Play (Space)"
          }, [
            h("span", MP, pe(g.value ? "" : ""), 1)
          ], 8, TP),
          h("button", {
            onClick: T,
            title: "Step Forward"
          }, [...N[28] || (N[28] = [
            h("span", { class: "icon" }, "", -1)
          ])]),
          h("button", {
            onClick: X,
            title: "Go to End (End)"
          }, [...N[29] || (N[29] = [
            h("span", { class: "icon" }, "", -1)
          ])])
        ]),
        h("div", OP, pe(M.value), 1),
        N[35] || (N[35] = h("div", { class: "divider" }, null, -1)),
        h("div", EP, [
          tt(h("select", {
            "onUpdate:modelValue": N[5] || (N[5] = (te) => s.value = te),
            class: "workspace-selector"
          }, [...N[30] || (N[30] = [
            h("option", { value: "standard" }, "Standard", -1),
            h("option", { value: "animation" }, "Animation", -1),
            h("option", { value: "effects" }, "Effects", -1),
            h("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [nn, s.value]
          ])
        ]),
        N[36] || (N[36] = h("div", { class: "spacer" }, null, -1)),
        h("div", PP, [
          h("span", {
            class: Ie(["gpu-badge", p.value])
          }, pe(p.value.toUpperCase()), 3),
          h("button", {
            onClick: ge,
            disabled: !$.value,
            title: "Undo (Ctrl+Z)"
          }, [...N[31] || (N[31] = [
            h("span", { class: "icon" }, "", -1)
          ])], 8, DP),
          h("button", {
            onClick: K,
            disabled: !ne.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...N[32] || (N[32] = [
            h("span", { class: "icon" }, "", -1)
          ])], 8, AP),
          h("button", {
            onClick: N[6] || (N[6] = (te) => f.value = !0),
            title: "Export"
          }, [...N[33] || (N[33] = [
            h("span", { class: "icon" }, "", -1),
            qe(" Export ", -1)
          ])])
        ])
      ]),
      h("div", IP, [
        Ae(Fe(Ka), { class: "default-theme horizontal-split" }, {
          default: Sn(() => [
            Ae(Fe(Bs), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: Sn(() => [
                h("div", FP, [
                  h("div", LP, [
                    h("button", {
                      class: Ie({ active: r.value === "project" }),
                      onClick: N[7] || (N[7] = (te) => r.value = "project")
                    }, " Project ", 2),
                    h("button", {
                      class: Ie({ active: r.value === "effects" }),
                      onClick: N[8] || (N[8] = (te) => r.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  h("div", zP, [
                    r.value === "project" ? (V(), ot(Hv, { key: 0 })) : r.value === "effects" ? (V(), ot(C0, { key: 1 })) : Te("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Ae(Fe(Bs), {
              size: 70,
              "min-size": 40
            }, {
              default: Sn(() => [
                Ae(Fe(Ka), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: Sn(() => [
                    Ae(Fe(Bs), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: Sn(() => [
                        h("div", RP, [
                          h("div", VP, [
                            h("div", jP, [
                              h("button", {
                                class: Ie({ active: a.value === "composition" }),
                                onClick: N[9] || (N[9] = (te) => a.value = "composition")
                              }, " Composition ", 2),
                              h("button", {
                                class: Ie({ active: a.value === "layer" }),
                                onClick: N[10] || (N[10] = (te) => a.value = "layer")
                              }, " Layer ", 2),
                              h("button", {
                                class: Ie({ active: a.value === "footage" }),
                                onClick: N[11] || (N[11] = (te) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            h("div", $P, [
                              tt(h("select", {
                                "onUpdate:modelValue": N[12] || (N[12] = (te) => l.value = te),
                                onChange: be,
                                class: "zoom-select"
                              }, [...N[37] || (N[37] = [
                                h("option", { value: "fit" }, "Fit", -1),
                                h("option", { value: "25" }, "25%", -1),
                                h("option", { value: "50" }, "50%", -1),
                                h("option", { value: "75" }, "75%", -1),
                                h("option", { value: "100" }, "100%", -1),
                                h("option", { value: "150" }, "150%", -1),
                                h("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [nn, l.value]
                              ]),
                              h("button", {
                                class: Ie({ active: u.value }),
                                onClick: N[13] || (N[13] = (te) => u.value = !u.value),
                                title: "Toggle Guides"
                              }, [...N[38] || (N[38] = [
                                h("span", { class: "icon" }, "", -1)
                              ])], 2),
                              h("button", {
                                class: Ie({ active: c.value }),
                                onClick: N[14] || (N[14] = (te) => c.value = !c.value),
                                title: "Toggle Grid"
                              }, [...N[39] || (N[39] = [
                                h("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          h("div", BP, [
                            a.value === "composition" ? (V(), ot($O, {
                              key: 0,
                              ref_key: "canvasRef",
                              ref: y
                            }, null, 512)) : (V(), ot(wT, {
                              key: 1,
                              camera: v.value,
                              viewportState: m.value,
                              viewOptions: b.value,
                              compWidth: S.value,
                              compHeight: x.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Ae(Fe(Bs), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: Sn(() => [
                        d.value ? (V(), ot(Fe(Ka), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: Sn(() => [
                            Ae(Fe(Bs), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Sn(() => [
                                h("div", WP, [
                                  Ae(yd)
                                ])
                              ]),
                              _: 1
                            }),
                            Ae(Fe(Bs), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Sn(() => [
                                h("div", UP, [
                                  Ae(jE, {
                                    onClose: N[15] || (N[15] = (te) => d.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (V(), B("div", NP, [
                          Ae(yd)
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Ae(Fe(Bs), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: Sn(() => [
                h("div", HP, [
                  h("div", XP, [
                    h("button", {
                      class: Ie({ active: o.value === "effects" }),
                      onClick: N[16] || (N[16] = (te) => o.value = "effects")
                    }, " Effects ", 2),
                    h("button", {
                      class: Ie({ active: o.value === "properties" }),
                      onClick: N[17] || (N[17] = (te) => o.value = "properties")
                    }, " Props ", 2),
                    h("button", {
                      class: Ie({ active: o.value === "camera" }),
                      onClick: N[18] || (N[18] = (te) => o.value = "camera")
                    }, " Cam ", 2),
                    h("button", {
                      class: Ie({ active: o.value === "audio" }),
                      onClick: N[19] || (N[19] = (te) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  h("div", YP, [
                    o.value === "effects" ? (V(), ot(Yy, { key: 0 })) : o.value === "properties" ? (V(), ot(T2, { key: 1 })) : o.value === "camera" ? (V(), ot(Uk, {
                      key: 2,
                      camera: v.value,
                      "onUpdate:camera": re
                    }, null, 8, ["camera"])) : o.value === "audio" ? (V(), ot(eT, { key: 3 })) : Te("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      h("div", GP, [
        h("div", KP, [
          h("span", qP, pe(O.value), 1),
          N[40] || (N[40] = h("span", { class: "status-divider" }, "|", -1)),
          h("span", ZP, pe(F.value), 1)
        ]),
        h("div", JP, [
          k.value > 0 ? (V(), B("span", QP, " Rendering: " + pe(Math.round(k.value * 100)) + "% ", 1)) : Te("", !0)
        ]),
        h("div", eD, [
          h("span", tD, pe(C.value), 1),
          N[41] || (N[41] = h("span", { class: "status-divider" }, "|", -1)),
          h("span", nD, pe(_.value) + " fps", 1)
        ])
      ]),
      f.value ? (V(), ot(_P, {
        key: 0,
        onClose: N[20] || (N[20] = (te) => f.value = !1),
        onExported: ie
      })) : Te("", !0)
    ]));
  }
}), iD = /* @__PURE__ */ mt(sD, [["__scopeId", "data-v-c9baeea6"]]), rD = /* @__PURE__ */ pt({
  __name: "App",
  setup(i) {
    return (e, n) => (V(), ot(iD));
  }
}), Kf = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], qf = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function Zf(i) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let s = 1; s < i; s++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function oD(i, e, n) {
  const s = i.data, r = i.width, o = i.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && aD(s, r, o, e), n > 0 && lD(s, r, o, n));
}
function aD(i, e, n, s) {
  const r = s + s + 1, o = e - 1, a = Kf[s], l = qf[s], u = Zf(r);
  for (let c = 0; c < n; c++) {
    let d = 0, f = 0, g = 0, p = 0, y = 0, v = 0, m = 0, b = 0, S = 0, x = 0, _ = 0, C = 0;
    const k = c * e;
    let M = u, O = u;
    const F = i[k * 4], $ = i[k * 4 + 1], ne = i[k * 4 + 2], oe = i[k * 4 + 3];
    for (let X = 0; X <= s; X++) {
      M.r = F, M.g = $, M.b = ne, M.a = oe;
      const T = s + 1 - X;
      S += F * T, x += $ * T, _ += ne * T, C += oe * T, X > 0 ? (d += F, f += $, g += ne, p += oe) : (y += F, v += $, m += ne, b += oe), M = M.next;
    }
    for (let X = 1; X <= s; X++) {
      const T = Math.min(X, o), H = (k + T) * 4, ge = i[H], K = i[H + 1], re = i[H + 2], ie = i[H + 3];
      M.r = ge, M.g = K, M.b = re, M.a = ie;
      const be = s + 1 - X;
      S += ge * be, x += K * be, _ += re * be, C += ie * be, d += ge, f += K, g += re, p += ie, M = M.next;
    }
    let z = u;
    for (let X = 0; X < s; X++)
      z = z.next;
    O = z.next;
    for (let X = 0; X < e; X++) {
      const T = (k + X) * 4;
      i[T] = S * a >>> l, i[T + 1] = x * a >>> l, i[T + 2] = _ * a >>> l, i[T + 3] = C * a >>> l, S -= y, x -= v, _ -= m, C -= b, y -= z.r, v -= z.g, m -= z.b, b -= z.a;
      const H = Math.min(X + s + 1, o), ge = (k + H) * 4;
      z.r = i[ge], z.g = i[ge + 1], z.b = i[ge + 2], z.a = i[ge + 3], d += z.r, f += z.g, g += z.b, p += z.a, S += d, x += f, _ += g, C += p, z = z.next, y += O.r, v += O.g, m += O.b, b += O.a, d -= O.r, f -= O.g, g -= O.b, p -= O.a, O = O.next;
    }
  }
}
function lD(i, e, n, s) {
  const r = s + s + 1, o = n - 1, a = Kf[s], l = qf[s], u = Zf(r);
  for (let c = 0; c < e; c++) {
    let d = 0, f = 0, g = 0, p = 0, y = 0, v = 0, m = 0, b = 0, S = 0, x = 0, _ = 0, C = 0, k = u, M = u;
    const O = i[c * 4], F = i[c * 4 + 1], $ = i[c * 4 + 2], ne = i[c * 4 + 3];
    for (let z = 0; z <= s; z++) {
      k.r = O, k.g = F, k.b = $, k.a = ne;
      const X = s + 1 - z;
      S += O * X, x += F * X, _ += $ * X, C += ne * X, z > 0 ? (d += O, f += F, g += $, p += ne) : (y += O, v += F, m += $, b += ne), k = k.next;
    }
    for (let z = 1; z <= s; z++) {
      const T = (Math.min(z, o) * e + c) * 4, H = i[T], ge = i[T + 1], K = i[T + 2], re = i[T + 3];
      k.r = H, k.g = ge, k.b = K, k.a = re;
      const ie = s + 1 - z;
      S += H * ie, x += ge * ie, _ += K * ie, C += re * ie, d += H, f += ge, g += K, p += re, k = k.next;
    }
    let oe = u;
    for (let z = 0; z < s; z++)
      oe = oe.next;
    M = oe.next;
    for (let z = 0; z < n; z++) {
      const X = (z * e + c) * 4;
      i[X] = S * a >>> l, i[X + 1] = x * a >>> l, i[X + 2] = _ * a >>> l, i[X + 3] = C * a >>> l, S -= y, x -= v, _ -= m, C -= b, y -= oe.r, v -= oe.g, m -= oe.b, b -= oe.a;
      const H = (Math.min(z + s + 1, o) * e + c) * 4;
      oe.r = i[H], oe.g = i[H + 1], oe.b = i[H + 2], oe.a = i[H + 3], d += oe.r, f += oe.g, g += oe.b, p += oe.a, S += d, x += f, _ += g, C += p, oe = oe.next, y += M.r, v += M.g, m += M.b, b += M.a, d -= M.r, f -= M.g, g -= M.b, p -= M.a, M = M.next;
    }
  }
}
function uD(i, e) {
  const n = e.blurriness ?? 10, s = e.blur_dimensions ?? "both";
  if (n <= 0)
    return i;
  const r = LO(i.canvas), o = i.ctx.getImageData(0, 0, i.canvas.width, i.canvas.height);
  let a = 0, l = 0;
  switch (s) {
    case "horizontal":
      a = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      a = n, l = n;
      break;
  }
  return oD(o, a, l), r.ctx.putImageData(o, 0, 0), r;
}
function cD() {
  AO("gaussian-blur", uD);
}
function dD() {
  cD();
}
let Jf = null;
function wd(i) {
  let e = null;
  if (typeof i == "string" ? e = document.getElementById(i) || document.querySelector(i) : i instanceof HTMLElement ? e = i : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  dD();
  const n = zg(rD);
  return n.use(jg()), n.mount(e), Jf = n, hD(), n;
}
function hD() {
  window.addEventListener("weyl:inputs-ready", (i) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: i.detail }));
  });
}
async function yD(i, e) {
  var n, s;
  return ((s = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : s.call(n, i, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => wd()) : setTimeout(() => {
  Jf || wd();
}, 0);
var So = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fD(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Co(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Qf = { exports: {} };
(function(i, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(s) {
    i.exports = s();
  })(function() {
    return function s(r, o, a) {
      function l(d, f) {
        if (!o[d]) {
          if (!r[d]) {
            var g = typeof Co == "function" && Co;
            if (!f && g) return g(d, !0);
            if (u) return u(d, !0);
            var p = new Error("Cannot find module '" + d + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var y = o[d] = { exports: {} };
          r[d][0].call(y.exports, function(v) {
            var m = r[d][1][v];
            return l(m || v);
          }, y, y.exports, s, r, o, a);
        }
        return o[d].exports;
      }
      for (var u = typeof Co == "function" && Co, c = 0; c < a.length; c++) l(a[c]);
      return l;
    }({ 1: [function(s, r, o) {
      var a = s("./utils"), l = s("./support"), u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o.encode = function(c) {
        for (var d, f, g, p, y, v, m, b = [], S = 0, x = c.length, _ = x, C = a.getTypeOf(c) !== "string"; S < c.length; ) _ = x - S, g = C ? (d = c[S++], f = S < x ? c[S++] : 0, S < x ? c[S++] : 0) : (d = c.charCodeAt(S++), f = S < x ? c.charCodeAt(S++) : 0, S < x ? c.charCodeAt(S++) : 0), p = d >> 2, y = (3 & d) << 4 | f >> 4, v = 1 < _ ? (15 & f) << 2 | g >> 6 : 64, m = 2 < _ ? 63 & g : 64, b.push(u.charAt(p) + u.charAt(y) + u.charAt(v) + u.charAt(m));
        return b.join("");
      }, o.decode = function(c) {
        var d, f, g, p, y, v, m = 0, b = 0, S = "data:";
        if (c.substr(0, S.length) === S) throw new Error("Invalid base64 input, it looks like a data url.");
        var x, _ = 3 * (c = c.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (c.charAt(c.length - 1) === u.charAt(64) && _--, c.charAt(c.length - 2) === u.charAt(64) && _--, _ % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (x = l.uint8array ? new Uint8Array(0 | _) : new Array(0 | _); m < c.length; ) d = u.indexOf(c.charAt(m++)) << 2 | (p = u.indexOf(c.charAt(m++))) >> 4, f = (15 & p) << 4 | (y = u.indexOf(c.charAt(m++))) >> 2, g = (3 & y) << 6 | (v = u.indexOf(c.charAt(m++))), x[b++] = d, y !== 64 && (x[b++] = f), v !== 64 && (x[b++] = g);
        return x;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(s, r, o) {
      var a = s("./external"), l = s("./stream/DataWorker"), u = s("./stream/Crc32Probe"), c = s("./stream/DataLengthProbe");
      function d(f, g, p, y, v) {
        this.compressedSize = f, this.uncompressedSize = g, this.crc32 = p, this.compression = y, this.compressedContent = v;
      }
      d.prototype = { getContentWorker: function() {
        var f = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new c("data_length")), g = this;
        return f.on("end", function() {
          if (this.streamInfo.data_length !== g.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), f;
      }, getCompressedWorker: function() {
        return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, d.createWorkerFrom = function(f, g, p) {
        return f.pipe(new u()).pipe(new c("uncompressedSize")).pipe(g.compressWorker(p)).pipe(new c("compressedSize")).withStreamInfo("compression", g);
      }, r.exports = d;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(s, r, o) {
      var a = s("./stream/GenericWorker");
      o.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, o.DEFLATE = s("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(s, r, o) {
      var a = s("./utils"), l = function() {
        for (var u, c = [], d = 0; d < 256; d++) {
          u = d;
          for (var f = 0; f < 8; f++) u = 1 & u ? 3988292384 ^ u >>> 1 : u >>> 1;
          c[d] = u;
        }
        return c;
      }();
      r.exports = function(u, c) {
        return u !== void 0 && u.length ? a.getTypeOf(u) !== "string" ? function(d, f, g, p) {
          var y = l, v = p + g;
          d ^= -1;
          for (var m = p; m < v; m++) d = d >>> 8 ^ y[255 & (d ^ f[m])];
          return -1 ^ d;
        }(0 | c, u, u.length, 0) : function(d, f, g, p) {
          var y = l, v = p + g;
          d ^= -1;
          for (var m = p; m < v; m++) d = d >>> 8 ^ y[255 & (d ^ f.charCodeAt(m))];
          return -1 ^ d;
        }(0 | c, u, u.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(s, r, o) {
      o.base64 = !1, o.binary = !1, o.dir = !1, o.createFolders = !0, o.date = null, o.compression = null, o.compressionOptions = null, o.comment = null, o.unixPermissions = null, o.dosPermissions = null;
    }, {}], 6: [function(s, r, o) {
      var a = null;
      a = typeof Promise < "u" ? Promise : s("lie"), r.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(s, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = s("pako"), u = s("./utils"), c = s("./stream/GenericWorker"), d = a ? "uint8array" : "array";
      function f(g, p) {
        c.call(this, "FlateWorker/" + g), this._pako = null, this._pakoAction = g, this._pakoOptions = p, this.meta = {};
      }
      o.magic = "\b\0", u.inherits(f, c), f.prototype.processChunk = function(g) {
        this.meta = g.meta, this._pako === null && this._createPako(), this._pako.push(u.transformTo(d, g.data), !1);
      }, f.prototype.flush = function() {
        c.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, f.prototype.cleanUp = function() {
        c.prototype.cleanUp.call(this), this._pako = null;
      }, f.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var g = this;
        this._pako.onData = function(p) {
          g.push({ data: p, meta: g.meta });
        };
      }, o.compressWorker = function(g) {
        return new f("Deflate", g);
      }, o.uncompressWorker = function() {
        return new f("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(s, r, o) {
      function a(y, v) {
        var m, b = "";
        for (m = 0; m < v; m++) b += String.fromCharCode(255 & y), y >>>= 8;
        return b;
      }
      function l(y, v, m, b, S, x) {
        var _, C, k = y.file, M = y.compression, O = x !== d.utf8encode, F = u.transformTo("string", x(k.name)), $ = u.transformTo("string", d.utf8encode(k.name)), ne = k.comment, oe = u.transformTo("string", x(ne)), z = u.transformTo("string", d.utf8encode(ne)), X = $.length !== k.name.length, T = z.length !== ne.length, H = "", ge = "", K = "", re = k.dir, ie = k.date, be = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        v && !m || (be.crc32 = y.crc32, be.compressedSize = y.compressedSize, be.uncompressedSize = y.uncompressedSize);
        var J = 0;
        v && (J |= 8), O || !X && !T || (J |= 2048);
        var ee = 0, ve = 0;
        re && (ee |= 16), S === "UNIX" ? (ve = 798, ee |= function(N, te) {
          var fe = N;
          return N || (fe = te ? 16893 : 33204), (65535 & fe) << 16;
        }(k.unixPermissions, re)) : (ve = 20, ee |= function(N) {
          return 63 & (N || 0);
        }(k.dosPermissions)), _ = ie.getUTCHours(), _ <<= 6, _ |= ie.getUTCMinutes(), _ <<= 5, _ |= ie.getUTCSeconds() / 2, C = ie.getUTCFullYear() - 1980, C <<= 4, C |= ie.getUTCMonth() + 1, C <<= 5, C |= ie.getUTCDate(), X && (ge = a(1, 1) + a(f(F), 4) + $, H += "up" + a(ge.length, 2) + ge), T && (K = a(1, 1) + a(f(oe), 4) + z, H += "uc" + a(K.length, 2) + K);
        var G = "";
        return G += `
\0`, G += a(J, 2), G += M.magic, G += a(_, 2), G += a(C, 2), G += a(be.crc32, 4), G += a(be.compressedSize, 4), G += a(be.uncompressedSize, 4), G += a(F.length, 2), G += a(H.length, 2), { fileRecord: g.LOCAL_FILE_HEADER + G + F + H, dirRecord: g.CENTRAL_FILE_HEADER + a(ve, 2) + G + a(oe.length, 2) + "\0\0\0\0" + a(ee, 4) + a(b, 4) + F + H + oe };
      }
      var u = s("../utils"), c = s("../stream/GenericWorker"), d = s("../utf8"), f = s("../crc32"), g = s("../signature");
      function p(y, v, m, b) {
        c.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = v, this.zipPlatform = m, this.encodeFileName = b, this.streamFiles = y, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      u.inherits(p, c), p.prototype.push = function(y) {
        var v = y.meta.percent || 0, m = this.entriesCount, b = this._sources.length;
        this.accumulate ? this.contentBuffer.push(y) : (this.bytesWritten += y.data.length, c.prototype.push.call(this, { data: y.data, meta: { currentFile: this.currentFile, percent: m ? (v + 100 * (m - b - 1)) / m : 100 } }));
      }, p.prototype.openedSource = function(y) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = y.file.name;
        var v = this.streamFiles && !y.file.dir;
        if (v) {
          var m = l(y, v, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(y) {
        this.accumulate = !1;
        var v = this.streamFiles && !y.file.dir, m = l(y, v, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), v) this.push({ data: function(b) {
          return g.DATA_DESCRIPTOR + a(b.crc32, 4) + a(b.compressedSize, 4) + a(b.uncompressedSize, 4);
        }(y), meta: { percent: 100 } });
        else for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var y = this.bytesWritten, v = 0; v < this.dirRecords.length; v++) this.push({ data: this.dirRecords[v], meta: { percent: 100 } });
        var m = this.bytesWritten - y, b = function(S, x, _, C, k) {
          var M = u.transformTo("string", k(C));
          return g.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(S, 2) + a(S, 2) + a(x, 4) + a(_, 4) + a(M.length, 2) + M;
        }(this.dirRecords.length, m, y, this.zipComment, this.encodeFileName);
        this.push({ data: b, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(y) {
        this._sources.push(y);
        var v = this;
        return y.on("data", function(m) {
          v.processChunk(m);
        }), y.on("end", function() {
          v.closedSource(v.previous.streamInfo), v._sources.length ? v.prepareNextSource() : v.end();
        }), y.on("error", function(m) {
          v.error(m);
        }), this;
      }, p.prototype.resume = function() {
        return !!c.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(y) {
        var v = this._sources;
        if (!c.prototype.error.call(this, y)) return !1;
        for (var m = 0; m < v.length; m++) try {
          v[m].error(y);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        c.prototype.lock.call(this);
        for (var y = this._sources, v = 0; v < y.length; v++) y[v].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(s, r, o) {
      var a = s("../compressions"), l = s("./ZipFileWorker");
      o.generateWorker = function(u, c, d) {
        var f = new l(c.streamFiles, d, c.platform, c.encodeFileName), g = 0;
        try {
          u.forEach(function(p, y) {
            g++;
            var v = function(x, _) {
              var C = x || _, k = a[C];
              if (!k) throw new Error(C + " is not a valid compression method !");
              return k;
            }(y.options.compression, c.compression), m = y.options.compressionOptions || c.compressionOptions || {}, b = y.dir, S = y.date;
            y._compressWorker(v, m).withStreamInfo("file", { name: p, dir: b, date: S, comment: y.comment || "", unixPermissions: y.unixPermissions, dosPermissions: y.dosPermissions }).pipe(f);
          }), f.entriesCount = g;
        } catch (p) {
          f.error(p);
        }
        return f;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(s, r, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new a();
          for (var u in this) typeof this[u] != "function" && (l[u] = this[u]);
          return l;
        };
      }
      (a.prototype = s("./object")).loadAsync = s("./load"), a.support = s("./support"), a.defaults = s("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, u) {
        return new a().loadAsync(l, u);
      }, a.external = s("./external"), r.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(s, r, o) {
      var a = s("./utils"), l = s("./external"), u = s("./utf8"), c = s("./zipEntries"), d = s("./stream/Crc32Probe"), f = s("./nodejsUtils");
      function g(p) {
        return new l.Promise(function(y, v) {
          var m = p.decompressed.getContentWorker().pipe(new d());
          m.on("error", function(b) {
            v(b);
          }).on("end", function() {
            m.streamInfo.crc32 !== p.decompressed.crc32 ? v(new Error("Corrupted zip : CRC32 mismatch")) : y();
          }).resume();
        });
      }
      r.exports = function(p, y) {
        var v = this;
        return y = a.extend(y || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: u.utf8decode }), f.isNode && f.isStream(p) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", p, !0, y.optimizedBinaryString, y.base64).then(function(m) {
          var b = new c(y);
          return b.load(m), b;
        }).then(function(m) {
          var b = [l.Promise.resolve(m)], S = m.files;
          if (y.checkCRC32) for (var x = 0; x < S.length; x++) b.push(g(S[x]));
          return l.Promise.all(b);
        }).then(function(m) {
          for (var b = m.shift(), S = b.files, x = 0; x < S.length; x++) {
            var _ = S[x], C = _.fileNameStr, k = a.resolve(_.fileNameStr);
            v.file(k, _.decompressed, { binary: !0, optimizedBinaryString: !0, date: _.date, dir: _.dir, comment: _.fileCommentStr.length ? _.fileCommentStr : null, unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions, createFolders: y.createFolders }), _.dir || (v.file(k).unsafeOriginalName = C);
          }
          return b.zipComment.length && (v.comment = b.zipComment), v;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(s, r, o) {
      var a = s("../utils"), l = s("../stream/GenericWorker");
      function u(c, d) {
        l.call(this, "Nodejs stream input adapter for " + c), this._upstreamEnded = !1, this._bindStream(d);
      }
      a.inherits(u, l), u.prototype._bindStream = function(c) {
        var d = this;
        (this._stream = c).pause(), c.on("data", function(f) {
          d.push({ data: f, meta: { percent: 0 } });
        }).on("error", function(f) {
          d.isPaused ? this.generatedError = f : d.error(f);
        }).on("end", function() {
          d.isPaused ? d._upstreamEnded = !0 : d.end();
        });
      }, u.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, u.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = u;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(s, r, o) {
      var a = s("readable-stream").Readable;
      function l(u, c, d) {
        a.call(this, c), this._helper = u;
        var f = this;
        u.on("data", function(g, p) {
          f.push(g) || f._helper.pause(), d && d(p);
        }).on("error", function(g) {
          f.emit("error", g);
        }).on("end", function() {
          f.push(null);
        });
      }
      s("../utils").inherits(l, a), l.prototype._read = function() {
        this._helper.resume();
      }, r.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(s, r, o) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
        if (typeof a == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(a, l);
      }, allocBuffer: function(a) {
        if (Buffer.alloc) return Buffer.alloc(a);
        var l = new Buffer(a);
        return l.fill(0), l;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(s, r, o) {
      function a(k, M, O) {
        var F, $ = u.getTypeOf(M), ne = u.extend(O || {}, f);
        ne.date = ne.date || /* @__PURE__ */ new Date(), ne.compression !== null && (ne.compression = ne.compression.toUpperCase()), typeof ne.unixPermissions == "string" && (ne.unixPermissions = parseInt(ne.unixPermissions, 8)), ne.unixPermissions && 16384 & ne.unixPermissions && (ne.dir = !0), ne.dosPermissions && 16 & ne.dosPermissions && (ne.dir = !0), ne.dir && (k = S(k)), ne.createFolders && (F = b(k)) && x.call(this, F, !0);
        var oe = $ === "string" && ne.binary === !1 && ne.base64 === !1;
        O && O.binary !== void 0 || (ne.binary = !oe), (M instanceof g && M.uncompressedSize === 0 || ne.dir || !M || M.length === 0) && (ne.base64 = !1, ne.binary = !0, M = "", ne.compression = "STORE", $ = "string");
        var z = null;
        z = M instanceof g || M instanceof c ? M : v.isNode && v.isStream(M) ? new m(k, M) : u.prepareContent(k, M, ne.binary, ne.optimizedBinaryString, ne.base64);
        var X = new p(k, z, ne);
        this.files[k] = X;
      }
      var l = s("./utf8"), u = s("./utils"), c = s("./stream/GenericWorker"), d = s("./stream/StreamHelper"), f = s("./defaults"), g = s("./compressedObject"), p = s("./zipObject"), y = s("./generate"), v = s("./nodejsUtils"), m = s("./nodejs/NodejsStreamInputAdapter"), b = function(k) {
        k.slice(-1) === "/" && (k = k.substring(0, k.length - 1));
        var M = k.lastIndexOf("/");
        return 0 < M ? k.substring(0, M) : "";
      }, S = function(k) {
        return k.slice(-1) !== "/" && (k += "/"), k;
      }, x = function(k, M) {
        return M = M !== void 0 ? M : f.createFolders, k = S(k), this.files[k] || a.call(this, k, null, { dir: !0, createFolders: M }), this.files[k];
      };
      function _(k) {
        return Object.prototype.toString.call(k) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(k) {
        var M, O, F;
        for (M in this.files) F = this.files[M], (O = M.slice(this.root.length, M.length)) && M.slice(0, this.root.length) === this.root && k(O, F);
      }, filter: function(k) {
        var M = [];
        return this.forEach(function(O, F) {
          k(O, F) && M.push(F);
        }), M;
      }, file: function(k, M, O) {
        if (arguments.length !== 1) return k = this.root + k, a.call(this, k, M, O), this;
        if (_(k)) {
          var F = k;
          return this.filter(function(ne, oe) {
            return !oe.dir && F.test(ne);
          });
        }
        var $ = this.files[this.root + k];
        return $ && !$.dir ? $ : null;
      }, folder: function(k) {
        if (!k) return this;
        if (_(k)) return this.filter(function($, ne) {
          return ne.dir && k.test($);
        });
        var M = this.root + k, O = x.call(this, M), F = this.clone();
        return F.root = O.name, F;
      }, remove: function(k) {
        k = this.root + k;
        var M = this.files[k];
        if (M || (k.slice(-1) !== "/" && (k += "/"), M = this.files[k]), M && !M.dir) delete this.files[k];
        else for (var O = this.filter(function($, ne) {
          return ne.name.slice(0, k.length) === k;
        }), F = 0; F < O.length; F++) delete this.files[O[F].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(k) {
        var M, O = {};
        try {
          if ((O = u.extend(k || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = O.type.toLowerCase(), O.compression = O.compression.toUpperCase(), O.type === "binarystring" && (O.type = "string"), !O.type) throw new Error("No output type specified.");
          u.checkSupport(O.type), O.platform !== "darwin" && O.platform !== "freebsd" && O.platform !== "linux" && O.platform !== "sunos" || (O.platform = "UNIX"), O.platform === "win32" && (O.platform = "DOS");
          var F = O.comment || this.comment || "";
          M = y.generateWorker(this, O, F);
        } catch ($) {
          (M = new c("error")).error($);
        }
        return new d(M, O.type || "string", O.mimeType);
      }, generateAsync: function(k, M) {
        return this.generateInternalStream(k).accumulate(M);
      }, generateNodeStream: function(k, M) {
        return (k = k || {}).type || (k.type = "nodebuffer"), this.generateInternalStream(k).toNodejsStream(M);
      } };
      r.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(s, r, o) {
      r.exports = s("stream");
    }, { stream: void 0 }], 17: [function(s, r, o) {
      var a = s("./DataReader");
      function l(u) {
        a.call(this, u);
        for (var c = 0; c < this.data.length; c++) u[c] = 255 & u[c];
      }
      s("../utils").inherits(l, a), l.prototype.byteAt = function(u) {
        return this.data[this.zero + u];
      }, l.prototype.lastIndexOfSignature = function(u) {
        for (var c = u.charCodeAt(0), d = u.charCodeAt(1), f = u.charCodeAt(2), g = u.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === c && this.data[p + 1] === d && this.data[p + 2] === f && this.data[p + 3] === g) return p - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(u) {
        var c = u.charCodeAt(0), d = u.charCodeAt(1), f = u.charCodeAt(2), g = u.charCodeAt(3), p = this.readData(4);
        return c === p[0] && d === p[1] && f === p[2] && g === p[3];
      }, l.prototype.readData = function(u) {
        if (this.checkOffset(u), u === 0) return [];
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + u);
        return this.index += u, c;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(s, r, o) {
      var a = s("../utils");
      function l(u) {
        this.data = u, this.length = u.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(u) {
        this.checkIndex(this.index + u);
      }, checkIndex: function(u) {
        if (this.length < this.zero + u || u < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + u + "). Corrupted zip ?");
      }, setIndex: function(u) {
        this.checkIndex(u), this.index = u;
      }, skip: function(u) {
        this.setIndex(this.index + u);
      }, byteAt: function() {
      }, readInt: function(u) {
        var c, d = 0;
        for (this.checkOffset(u), c = this.index + u - 1; c >= this.index; c--) d = (d << 8) + this.byteAt(c);
        return this.index += u, d;
      }, readString: function(u) {
        return a.transformTo("string", this.readData(u));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var u = this.readInt(4);
        return new Date(Date.UTC(1980 + (u >> 25 & 127), (u >> 21 & 15) - 1, u >> 16 & 31, u >> 11 & 31, u >> 5 & 63, (31 & u) << 1));
      } }, r.exports = l;
    }, { "../utils": 32 }], 19: [function(s, r, o) {
      var a = s("./Uint8ArrayReader");
      function l(u) {
        a.call(this, u);
      }
      s("../utils").inherits(l, a), l.prototype.readData = function(u) {
        this.checkOffset(u);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + u);
        return this.index += u, c;
      }, r.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(s, r, o) {
      var a = s("./DataReader");
      function l(u) {
        a.call(this, u);
      }
      s("../utils").inherits(l, a), l.prototype.byteAt = function(u) {
        return this.data.charCodeAt(this.zero + u);
      }, l.prototype.lastIndexOfSignature = function(u) {
        return this.data.lastIndexOf(u) - this.zero;
      }, l.prototype.readAndCheckSignature = function(u) {
        return u === this.readData(4);
      }, l.prototype.readData = function(u) {
        this.checkOffset(u);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + u);
        return this.index += u, c;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(s, r, o) {
      var a = s("./ArrayReader");
      function l(u) {
        a.call(this, u);
      }
      s("../utils").inherits(l, a), l.prototype.readData = function(u) {
        if (this.checkOffset(u), u === 0) return new Uint8Array(0);
        var c = this.data.subarray(this.zero + this.index, this.zero + this.index + u);
        return this.index += u, c;
      }, r.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(s, r, o) {
      var a = s("../utils"), l = s("../support"), u = s("./ArrayReader"), c = s("./StringReader"), d = s("./NodeBufferReader"), f = s("./Uint8ArrayReader");
      r.exports = function(g) {
        var p = a.getTypeOf(g);
        return a.checkSupport(p), p !== "string" || l.uint8array ? p === "nodebuffer" ? new d(g) : l.uint8array ? new f(a.transformTo("uint8array", g)) : new u(a.transformTo("array", g)) : new c(g);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(s, r, o) {
      o.LOCAL_FILE_HEADER = "PK", o.CENTRAL_FILE_HEADER = "PK", o.CENTRAL_DIRECTORY_END = "PK", o.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", o.ZIP64_CENTRAL_DIRECTORY_END = "PK", o.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(s, r, o) {
      var a = s("./GenericWorker"), l = s("../utils");
      function u(c) {
        a.call(this, "ConvertWorker to " + c), this.destType = c;
      }
      l.inherits(u, a), u.prototype.processChunk = function(c) {
        this.push({ data: l.transformTo(this.destType, c.data), meta: c.meta });
      }, r.exports = u;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(s, r, o) {
      var a = s("./GenericWorker"), l = s("../crc32");
      function u() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      s("../utils").inherits(u, a), u.prototype.processChunk = function(c) {
        this.streamInfo.crc32 = l(c.data, this.streamInfo.crc32 || 0), this.push(c);
      }, r.exports = u;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(s, r, o) {
      var a = s("../utils"), l = s("./GenericWorker");
      function u(c) {
        l.call(this, "DataLengthProbe for " + c), this.propName = c, this.withStreamInfo(c, 0);
      }
      a.inherits(u, l), u.prototype.processChunk = function(c) {
        if (c) {
          var d = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = d + c.data.length;
        }
        l.prototype.processChunk.call(this, c);
      }, r.exports = u;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(s, r, o) {
      var a = s("../utils"), l = s("./GenericWorker");
      function u(c) {
        l.call(this, "DataWorker");
        var d = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, c.then(function(f) {
          d.dataIsReady = !0, d.data = f, d.max = f && f.length || 0, d.type = a.getTypeOf(f), d.isPaused || d._tickAndRepeat();
        }, function(f) {
          d.error(f);
        });
      }
      a.inherits(u, l), u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, u.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, u.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, u.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var c = null, d = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, d);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, d);
        }
        return this.index = d, this.push({ data: c, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = u;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(s, r, o) {
      function a(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, u) {
        return this._listeners[l].push(u), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, u) {
        if (this._listeners[l]) for (var c = 0; c < this._listeners[l].length; c++) this._listeners[l][c].call(this, u);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var u = this;
        return l.on("data", function(c) {
          u.processChunk(c);
        }), l.on("end", function() {
          u.end();
        }), l.on("error", function(c) {
          u.error(c);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, u) {
        return this.extraStreamInfo[l] = u, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, r.exports = a;
    }, {}], 29: [function(s, r, o) {
      var a = s("../utils"), l = s("./ConvertWorker"), u = s("./GenericWorker"), c = s("../base64"), d = s("../support"), f = s("../external"), g = null;
      if (d.nodestream) try {
        g = s("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(v, m) {
        return new f.Promise(function(b, S) {
          var x = [], _ = v._internalType, C = v._outputType, k = v._mimeType;
          v.on("data", function(M, O) {
            x.push(M), m && m(O);
          }).on("error", function(M) {
            x = [], S(M);
          }).on("end", function() {
            try {
              var M = function(O, F, $) {
                switch (O) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", F), $);
                  case "base64":
                    return c.encode(F);
                  default:
                    return a.transformTo(O, F);
                }
              }(C, function(O, F) {
                var $, ne = 0, oe = null, z = 0;
                for ($ = 0; $ < F.length; $++) z += F[$].length;
                switch (O) {
                  case "string":
                    return F.join("");
                  case "array":
                    return Array.prototype.concat.apply([], F);
                  case "uint8array":
                    for (oe = new Uint8Array(z), $ = 0; $ < F.length; $++) oe.set(F[$], ne), ne += F[$].length;
                    return oe;
                  case "nodebuffer":
                    return Buffer.concat(F);
                  default:
                    throw new Error("concat : unsupported type '" + O + "'");
                }
              }(_, x), k);
              b(M);
            } catch (O) {
              S(O);
            }
            x = [];
          }).resume();
        });
      }
      function y(v, m, b) {
        var S = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            S = "uint8array";
            break;
          case "base64":
            S = "string";
        }
        try {
          this._internalType = S, this._outputType = m, this._mimeType = b, a.checkSupport(S), this._worker = v.pipe(new l(S)), v.lock();
        } catch (x) {
          this._worker = new u("error"), this._worker.error(x);
        }
      }
      y.prototype = { accumulate: function(v) {
        return p(this, v);
      }, on: function(v, m) {
        var b = this;
        return v === "data" ? this._worker.on(v, function(S) {
          m.call(b, S.data, S.meta);
        }) : this._worker.on(v, function() {
          a.delay(m, arguments, b);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(v) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new g(this, { objectMode: this._outputType !== "nodebuffer" }, v);
      } }, r.exports = y;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(s, r, o) {
      if (o.base64 = !0, o.array = !0, o.string = !0, o.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o.nodebuffer = typeof Buffer < "u", o.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") o.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          o.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(a), o.blob = l.getBlob("application/zip").size === 0;
          } catch {
            o.blob = !1;
          }
        }
      }
      try {
        o.nodestream = !!s("readable-stream").Readable;
      } catch {
        o.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(s, r, o) {
      for (var a = s("./utils"), l = s("./support"), u = s("./nodejsUtils"), c = s("./stream/GenericWorker"), d = new Array(256), f = 0; f < 256; f++) d[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
      d[254] = d[254] = 1;
      function g() {
        c.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        c.call(this, "utf-8 encode");
      }
      o.utf8encode = function(y) {
        return l.nodebuffer ? u.newBufferFrom(y, "utf-8") : function(v) {
          var m, b, S, x, _, C = v.length, k = 0;
          for (x = 0; x < C; x++) (64512 & (b = v.charCodeAt(x))) == 55296 && x + 1 < C && (64512 & (S = v.charCodeAt(x + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (S - 56320), x++), k += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
          for (m = l.uint8array ? new Uint8Array(k) : new Array(k), x = _ = 0; _ < k; x++) (64512 & (b = v.charCodeAt(x))) == 55296 && x + 1 < C && (64512 & (S = v.charCodeAt(x + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (S - 56320), x++), b < 128 ? m[_++] = b : (b < 2048 ? m[_++] = 192 | b >>> 6 : (b < 65536 ? m[_++] = 224 | b >>> 12 : (m[_++] = 240 | b >>> 18, m[_++] = 128 | b >>> 12 & 63), m[_++] = 128 | b >>> 6 & 63), m[_++] = 128 | 63 & b);
          return m;
        }(y);
      }, o.utf8decode = function(y) {
        return l.nodebuffer ? a.transformTo("nodebuffer", y).toString("utf-8") : function(v) {
          var m, b, S, x, _ = v.length, C = new Array(2 * _);
          for (m = b = 0; m < _; ) if ((S = v[m++]) < 128) C[b++] = S;
          else if (4 < (x = d[S])) C[b++] = 65533, m += x - 1;
          else {
            for (S &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && m < _; ) S = S << 6 | 63 & v[m++], x--;
            1 < x ? C[b++] = 65533 : S < 65536 ? C[b++] = S : (S -= 65536, C[b++] = 55296 | S >> 10 & 1023, C[b++] = 56320 | 1023 & S);
          }
          return C.length !== b && (C.subarray ? C = C.subarray(0, b) : C.length = b), a.applyFromCharCode(C);
        }(y = a.transformTo(l.uint8array ? "uint8array" : "array", y));
      }, a.inherits(g, c), g.prototype.processChunk = function(y) {
        var v = a.transformTo(l.uint8array ? "uint8array" : "array", y.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var m = v;
            (v = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), v.set(m, this.leftOver.length);
          } else v = this.leftOver.concat(v);
          this.leftOver = null;
        }
        var b = function(x, _) {
          var C;
          for ((_ = _ || x.length) > x.length && (_ = x.length), C = _ - 1; 0 <= C && (192 & x[C]) == 128; ) C--;
          return C < 0 || C === 0 ? _ : C + d[x[C]] > _ ? C : _;
        }(v), S = v;
        b !== v.length && (l.uint8array ? (S = v.subarray(0, b), this.leftOver = v.subarray(b, v.length)) : (S = v.slice(0, b), this.leftOver = v.slice(b, v.length))), this.push({ data: o.utf8decode(S), meta: y.meta });
      }, g.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: o.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, o.Utf8DecodeWorker = g, a.inherits(p, c), p.prototype.processChunk = function(y) {
        this.push({ data: o.utf8encode(y.data), meta: y.meta });
      }, o.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(s, r, o) {
      var a = s("./support"), l = s("./base64"), u = s("./nodejsUtils"), c = s("./external");
      function d(m) {
        return m;
      }
      function f(m, b) {
        for (var S = 0; S < m.length; ++S) b[S] = 255 & m.charCodeAt(S);
        return b;
      }
      s("setimmediate"), o.newBlob = function(m, b) {
        o.checkSupport("blob");
        try {
          return new Blob([m], { type: b });
        } catch {
          try {
            var S = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return S.append(m), S.getBlob(b);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var g = { stringifyByChunk: function(m, b, S) {
        var x = [], _ = 0, C = m.length;
        if (C <= S) return String.fromCharCode.apply(null, m);
        for (; _ < C; ) b === "array" || b === "nodebuffer" ? x.push(String.fromCharCode.apply(null, m.slice(_, Math.min(_ + S, C)))) : x.push(String.fromCharCode.apply(null, m.subarray(_, Math.min(_ + S, C)))), _ += S;
        return x.join("");
      }, stringifyByChar: function(m) {
        for (var b = "", S = 0; S < m.length; S++) b += String.fromCharCode(m[S]);
        return b;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, u.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(m) {
        var b = 65536, S = o.getTypeOf(m), x = !0;
        if (S === "uint8array" ? x = g.applyCanBeUsed.uint8array : S === "nodebuffer" && (x = g.applyCanBeUsed.nodebuffer), x) for (; 1 < b; ) try {
          return g.stringifyByChunk(m, S, b);
        } catch {
          b = Math.floor(b / 2);
        }
        return g.stringifyByChar(m);
      }
      function y(m, b) {
        for (var S = 0; S < m.length; S++) b[S] = m[S];
        return b;
      }
      o.applyFromCharCode = p;
      var v = {};
      v.string = { string: d, array: function(m) {
        return f(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return v.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return f(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return f(m, u.allocBuffer(m.length));
      } }, v.array = { string: p, array: d, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return u.newBufferFrom(m);
      } }, v.arraybuffer = { string: function(m) {
        return p(new Uint8Array(m));
      }, array: function(m) {
        return y(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: d, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return u.newBufferFrom(new Uint8Array(m));
      } }, v.uint8array = { string: p, array: function(m) {
        return y(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: d, nodebuffer: function(m) {
        return u.newBufferFrom(m);
      } }, v.nodebuffer = { string: p, array: function(m) {
        return y(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return v.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return y(m, new Uint8Array(m.length));
      }, nodebuffer: d }, o.transformTo = function(m, b) {
        if (b = b || "", !m) return b;
        o.checkSupport(m);
        var S = o.getTypeOf(b);
        return v[S][m](b);
      }, o.resolve = function(m) {
        for (var b = m.split("/"), S = [], x = 0; x < b.length; x++) {
          var _ = b[x];
          _ === "." || _ === "" && x !== 0 && x !== b.length - 1 || (_ === ".." ? S.pop() : S.push(_));
        }
        return S.join("/");
      }, o.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : a.nodebuffer && u.isBuffer(m) ? "nodebuffer" : a.uint8array && m instanceof Uint8Array ? "uint8array" : a.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, o.checkSupport = function(m) {
        if (!a[m.toLowerCase()]) throw new Error(m + " is not supported by this platform");
      }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(m) {
        var b, S, x = "";
        for (S = 0; S < (m || "").length; S++) x += "\\x" + ((b = m.charCodeAt(S)) < 16 ? "0" : "") + b.toString(16).toUpperCase();
        return x;
      }, o.delay = function(m, b, S) {
        setImmediate(function() {
          m.apply(S || null, b || []);
        });
      }, o.inherits = function(m, b) {
        function S() {
        }
        S.prototype = b.prototype, m.prototype = new S();
      }, o.extend = function() {
        var m, b, S = {};
        for (m = 0; m < arguments.length; m++) for (b in arguments[m]) Object.prototype.hasOwnProperty.call(arguments[m], b) && S[b] === void 0 && (S[b] = arguments[m][b]);
        return S;
      }, o.prepareContent = function(m, b, S, x, _) {
        return c.Promise.resolve(b).then(function(C) {
          return a.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new c.Promise(function(k, M) {
            var O = new FileReader();
            O.onload = function(F) {
              k(F.target.result);
            }, O.onerror = function(F) {
              M(F.target.error);
            }, O.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var k = o.getTypeOf(C);
          return k ? (k === "arraybuffer" ? C = o.transformTo("uint8array", C) : k === "string" && (_ ? C = l.decode(C) : S && x !== !0 && (C = function(M) {
            return f(M, a.uint8array ? new Uint8Array(M.length) : new Array(M.length));
          }(C))), C) : c.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(s, r, o) {
      var a = s("./reader/readerFor"), l = s("./utils"), u = s("./signature"), c = s("./zipEntry"), d = s("./support");
      function f(g) {
        this.files = [], this.loadOptions = g;
      }
      f.prototype = { checkSignature: function(g) {
        if (!this.reader.readAndCheckSignature(g)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(p) + ", expected " + l.pretty(g) + ")");
        }
      }, isSignature: function(g, p) {
        var y = this.reader.index;
        this.reader.setIndex(g);
        var v = this.reader.readString(4) === p;
        return this.reader.setIndex(y), v;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var g = this.reader.readData(this.zipCommentLength), p = d.uint8array ? "uint8array" : "array", y = l.transformTo(p, g);
        this.zipComment = this.loadOptions.decodeFileName(y);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var g, p, y, v = this.zip64EndOfCentralSize - 44; 0 < v; ) g = this.reader.readInt(2), p = this.reader.readInt(4), y = this.reader.readData(p), this.zip64ExtensibleData[g] = { id: g, length: p, value: y };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var g, p;
        for (g = 0; g < this.files.length; g++) p = this.files[g], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(u.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var g;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(u.CENTRAL_FILE_HEADER); ) (g = new c({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(g);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var g = this.reader.lastIndexOfSignature(u.CENTRAL_DIRECTORY_END);
        if (g < 0) throw this.isSignature(0, u.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(g);
        var p = g;
        if (this.checkSignature(u.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (g = this.reader.lastIndexOfSignature(u.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(g), this.checkSignature(u.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, u.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(u.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(u.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var y = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (y += 20, y += 12 + this.zip64EndOfCentralSize);
        var v = p - y;
        if (0 < v) this.isSignature(p, u.CENTRAL_FILE_HEADER) || (this.reader.zero = v);
        else if (v < 0) throw new Error("Corrupted zip: missing " + Math.abs(v) + " bytes.");
      }, prepareReader: function(g) {
        this.reader = a(g);
      }, load: function(g) {
        this.prepareReader(g), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = f;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(s, r, o) {
      var a = s("./reader/readerFor"), l = s("./utils"), u = s("./compressedObject"), c = s("./crc32"), d = s("./utf8"), f = s("./compressions"), g = s("./support");
      function p(y, v) {
        this.options = y, this.loadOptions = v;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(y) {
        var v, m;
        if (y.skip(22), this.fileNameLength = y.readInt(2), m = y.readInt(2), this.fileName = y.readData(this.fileNameLength), y.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((v = function(b) {
          for (var S in f) if (Object.prototype.hasOwnProperty.call(f, S) && f[S].magic === b) return f[S];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new u(this.compressedSize, this.uncompressedSize, this.crc32, v, y.readData(this.compressedSize));
      }, readCentralPart: function(y) {
        this.versionMadeBy = y.readInt(2), y.skip(2), this.bitFlag = y.readInt(2), this.compressionMethod = y.readString(2), this.date = y.readDate(), this.crc32 = y.readInt(4), this.compressedSize = y.readInt(4), this.uncompressedSize = y.readInt(4);
        var v = y.readInt(2);
        if (this.extraFieldsLength = y.readInt(2), this.fileCommentLength = y.readInt(2), this.diskNumberStart = y.readInt(2), this.internalFileAttributes = y.readInt(2), this.externalFileAttributes = y.readInt(4), this.localHeaderOffset = y.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        y.skip(v), this.readExtraFields(y), this.parseZIP64ExtraField(y), this.fileComment = y.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var y = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), y == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), y == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var y = a(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = y.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = y.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = y.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = y.readInt(4));
        }
      }, readExtraFields: function(y) {
        var v, m, b, S = y.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); y.index + 4 < S; ) v = y.readInt(2), m = y.readInt(2), b = y.readData(m), this.extraFields[v] = { id: v, length: m, value: b };
        y.setIndex(S);
      }, handleUTF8: function() {
        var y = g.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = d.utf8decode(this.fileName), this.fileCommentStr = d.utf8decode(this.fileComment);
        else {
          var v = this.findExtraFieldUnicodePath();
          if (v !== null) this.fileNameStr = v;
          else {
            var m = l.transformTo(y, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var b = this.findExtraFieldUnicodeComment();
          if (b !== null) this.fileCommentStr = b;
          else {
            var S = l.transformTo(y, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(S);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var y = this.extraFields[28789];
        if (y) {
          var v = a(y.value);
          return v.readInt(1) !== 1 || c(this.fileName) !== v.readInt(4) ? null : d.utf8decode(v.readData(y.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var y = this.extraFields[25461];
        if (y) {
          var v = a(y.value);
          return v.readInt(1) !== 1 || c(this.fileComment) !== v.readInt(4) ? null : d.utf8decode(v.readData(y.length - 5));
        }
        return null;
      } }, r.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(s, r, o) {
      function a(v, m, b) {
        this.name = v, this.dir = b.dir, this.date = b.date, this.comment = b.comment, this.unixPermissions = b.unixPermissions, this.dosPermissions = b.dosPermissions, this._data = m, this._dataBinary = b.binary, this.options = { compression: b.compression, compressionOptions: b.compressionOptions };
      }
      var l = s("./stream/StreamHelper"), u = s("./stream/DataWorker"), c = s("./utf8"), d = s("./compressedObject"), f = s("./stream/GenericWorker");
      a.prototype = { internalStream: function(v) {
        var m = null, b = "string";
        try {
          if (!v) throw new Error("No output type specified.");
          var S = (b = v.toLowerCase()) === "string" || b === "text";
          b !== "binarystring" && b !== "text" || (b = "string"), m = this._decompressWorker();
          var x = !this._dataBinary;
          x && !S && (m = m.pipe(new c.Utf8EncodeWorker())), !x && S && (m = m.pipe(new c.Utf8DecodeWorker()));
        } catch (_) {
          (m = new f("error")).error(_);
        }
        return new l(m, b, "");
      }, async: function(v, m) {
        return this.internalStream(v).accumulate(m);
      }, nodeStream: function(v, m) {
        return this.internalStream(v || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(v, m) {
        if (this._data instanceof d && this._data.compression.magic === v.magic) return this._data.getCompressedWorker();
        var b = this._decompressWorker();
        return this._dataBinary || (b = b.pipe(new c.Utf8EncodeWorker())), d.createWorkerFrom(b, v, m);
      }, _decompressWorker: function() {
        return this._data instanceof d ? this._data.getContentWorker() : this._data instanceof f ? this._data : new u(this._data);
      } };
      for (var g = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, y = 0; y < g.length; y++) a.prototype[g[y]] = p;
      r.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(s, r, o) {
      (function(a) {
        var l, u, c = a.MutationObserver || a.WebKitMutationObserver;
        if (c) {
          var d = 0, f = new c(v), g = a.document.createTextNode("");
          f.observe(g, { characterData: !0 }), l = function() {
            g.data = d = ++d % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
          var m = a.document.createElement("script");
          m.onreadystatechange = function() {
            v(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
          }, a.document.documentElement.appendChild(m);
        } : function() {
          setTimeout(v, 0);
        };
        else {
          var p = new a.MessageChannel();
          p.port1.onmessage = v, l = function() {
            p.port2.postMessage(0);
          };
        }
        var y = [];
        function v() {
          var m, b;
          u = !0;
          for (var S = y.length; S; ) {
            for (b = y, y = [], m = -1; ++m < S; ) b[m]();
            S = y.length;
          }
          u = !1;
        }
        r.exports = function(m) {
          y.push(m) !== 1 || u || l();
        };
      }).call(this, typeof So < "u" ? So : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(s, r, o) {
      var a = s("immediate");
      function l() {
      }
      var u = {}, c = ["REJECTED"], d = ["FULFILLED"], f = ["PENDING"];
      function g(S) {
        if (typeof S != "function") throw new TypeError("resolver must be a function");
        this.state = f, this.queue = [], this.outcome = void 0, S !== l && m(this, S);
      }
      function p(S, x, _) {
        this.promise = S, typeof x == "function" && (this.onFulfilled = x, this.callFulfilled = this.otherCallFulfilled), typeof _ == "function" && (this.onRejected = _, this.callRejected = this.otherCallRejected);
      }
      function y(S, x, _) {
        a(function() {
          var C;
          try {
            C = x(_);
          } catch (k) {
            return u.reject(S, k);
          }
          C === S ? u.reject(S, new TypeError("Cannot resolve promise with itself")) : u.resolve(S, C);
        });
      }
      function v(S) {
        var x = S && S.then;
        if (S && (typeof S == "object" || typeof S == "function") && typeof x == "function") return function() {
          x.apply(S, arguments);
        };
      }
      function m(S, x) {
        var _ = !1;
        function C(O) {
          _ || (_ = !0, u.reject(S, O));
        }
        function k(O) {
          _ || (_ = !0, u.resolve(S, O));
        }
        var M = b(function() {
          x(k, C);
        });
        M.status === "error" && C(M.value);
      }
      function b(S, x) {
        var _ = {};
        try {
          _.value = S(x), _.status = "success";
        } catch (C) {
          _.status = "error", _.value = C;
        }
        return _;
      }
      (r.exports = g).prototype.finally = function(S) {
        if (typeof S != "function") return this;
        var x = this.constructor;
        return this.then(function(_) {
          return x.resolve(S()).then(function() {
            return _;
          });
        }, function(_) {
          return x.resolve(S()).then(function() {
            throw _;
          });
        });
      }, g.prototype.catch = function(S) {
        return this.then(null, S);
      }, g.prototype.then = function(S, x) {
        if (typeof S != "function" && this.state === d || typeof x != "function" && this.state === c) return this;
        var _ = new this.constructor(l);
        return this.state !== f ? y(_, this.state === d ? S : x, this.outcome) : this.queue.push(new p(_, S, x)), _;
      }, p.prototype.callFulfilled = function(S) {
        u.resolve(this.promise, S);
      }, p.prototype.otherCallFulfilled = function(S) {
        y(this.promise, this.onFulfilled, S);
      }, p.prototype.callRejected = function(S) {
        u.reject(this.promise, S);
      }, p.prototype.otherCallRejected = function(S) {
        y(this.promise, this.onRejected, S);
      }, u.resolve = function(S, x) {
        var _ = b(v, x);
        if (_.status === "error") return u.reject(S, _.value);
        var C = _.value;
        if (C) m(S, C);
        else {
          S.state = d, S.outcome = x;
          for (var k = -1, M = S.queue.length; ++k < M; ) S.queue[k].callFulfilled(x);
        }
        return S;
      }, u.reject = function(S, x) {
        S.state = c, S.outcome = x;
        for (var _ = -1, C = S.queue.length; ++_ < C; ) S.queue[_].callRejected(x);
        return S;
      }, g.resolve = function(S) {
        return S instanceof this ? S : u.resolve(new this(l), S);
      }, g.reject = function(S) {
        var x = new this(l);
        return u.reject(x, S);
      }, g.all = function(S) {
        var x = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = S.length, C = !1;
        if (!_) return this.resolve([]);
        for (var k = new Array(_), M = 0, O = -1, F = new this(l); ++O < _; ) $(S[O], O);
        return F;
        function $(ne, oe) {
          x.resolve(ne).then(function(z) {
            k[oe] = z, ++M !== _ || C || (C = !0, u.resolve(F, k));
          }, function(z) {
            C || (C = !0, u.reject(F, z));
          });
        }
      }, g.race = function(S) {
        var x = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = S.length, C = !1;
        if (!_) return this.resolve([]);
        for (var k = -1, M = new this(l); ++k < _; ) O = S[k], x.resolve(O).then(function(F) {
          C || (C = !0, u.resolve(M, F));
        }, function(F) {
          C || (C = !0, u.reject(M, F));
        });
        var O;
        return M;
      };
    }, { immediate: 36 }], 38: [function(s, r, o) {
      var a = {};
      (0, s("./lib/utils/common").assign)(a, s("./lib/deflate"), s("./lib/inflate"), s("./lib/zlib/constants")), r.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(s, r, o) {
      var a = s("./zlib/deflate"), l = s("./utils/common"), u = s("./utils/strings"), c = s("./zlib/messages"), d = s("./zlib/zstream"), f = Object.prototype.toString, g = 0, p = -1, y = 0, v = 8;
      function m(S) {
        if (!(this instanceof m)) return new m(S);
        this.options = l.assign({ level: p, method: v, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: y, to: "" }, S || {});
        var x = this.options;
        x.raw && 0 < x.windowBits ? x.windowBits = -x.windowBits : x.gzip && 0 < x.windowBits && x.windowBits < 16 && (x.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var _ = a.deflateInit2(this.strm, x.level, x.method, x.windowBits, x.memLevel, x.strategy);
        if (_ !== g) throw new Error(c[_]);
        if (x.header && a.deflateSetHeader(this.strm, x.header), x.dictionary) {
          var C;
          if (C = typeof x.dictionary == "string" ? u.string2buf(x.dictionary) : f.call(x.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(x.dictionary) : x.dictionary, (_ = a.deflateSetDictionary(this.strm, C)) !== g) throw new Error(c[_]);
          this._dict_set = !0;
        }
      }
      function b(S, x) {
        var _ = new m(x);
        if (_.push(S, !0), _.err) throw _.msg || c[_.err];
        return _.result;
      }
      m.prototype.push = function(S, x) {
        var _, C, k = this.strm, M = this.options.chunkSize;
        if (this.ended) return !1;
        C = x === ~~x ? x : x === !0 ? 4 : 0, typeof S == "string" ? k.input = u.string2buf(S) : f.call(S) === "[object ArrayBuffer]" ? k.input = new Uint8Array(S) : k.input = S, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new l.Buf8(M), k.next_out = 0, k.avail_out = M), (_ = a.deflate(k, C)) !== 1 && _ !== g) return this.onEnd(_), !(this.ended = !0);
          k.avail_out !== 0 && (k.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(u.buf2binstring(l.shrinkBuf(k.output, k.next_out))) : this.onData(l.shrinkBuf(k.output, k.next_out)));
        } while ((0 < k.avail_in || k.avail_out === 0) && _ !== 1);
        return C === 4 ? (_ = a.deflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === g) : C !== 2 || (this.onEnd(g), !(k.avail_out = 0));
      }, m.prototype.onData = function(S) {
        this.chunks.push(S);
      }, m.prototype.onEnd = function(S) {
        S === g && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = S, this.msg = this.strm.msg;
      }, o.Deflate = m, o.deflate = b, o.deflateRaw = function(S, x) {
        return (x = x || {}).raw = !0, b(S, x);
      }, o.gzip = function(S, x) {
        return (x = x || {}).gzip = !0, b(S, x);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(s, r, o) {
      var a = s("./zlib/inflate"), l = s("./utils/common"), u = s("./utils/strings"), c = s("./zlib/constants"), d = s("./zlib/messages"), f = s("./zlib/zstream"), g = s("./zlib/gzheader"), p = Object.prototype.toString;
      function y(m) {
        if (!(this instanceof y)) return new y(m);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var b = this.options;
        b.raw && 0 <= b.windowBits && b.windowBits < 16 && (b.windowBits = -b.windowBits, b.windowBits === 0 && (b.windowBits = -15)), !(0 <= b.windowBits && b.windowBits < 16) || m && m.windowBits || (b.windowBits += 32), 15 < b.windowBits && b.windowBits < 48 && !(15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
        var S = a.inflateInit2(this.strm, b.windowBits);
        if (S !== c.Z_OK) throw new Error(d[S]);
        this.header = new g(), a.inflateGetHeader(this.strm, this.header);
      }
      function v(m, b) {
        var S = new y(b);
        if (S.push(m, !0), S.err) throw S.msg || d[S.err];
        return S.result;
      }
      y.prototype.push = function(m, b) {
        var S, x, _, C, k, M, O = this.strm, F = this.options.chunkSize, $ = this.options.dictionary, ne = !1;
        if (this.ended) return !1;
        x = b === ~~b ? b : b === !0 ? c.Z_FINISH : c.Z_NO_FLUSH, typeof m == "string" ? O.input = u.binstring2buf(m) : p.call(m) === "[object ArrayBuffer]" ? O.input = new Uint8Array(m) : O.input = m, O.next_in = 0, O.avail_in = O.input.length;
        do {
          if (O.avail_out === 0 && (O.output = new l.Buf8(F), O.next_out = 0, O.avail_out = F), (S = a.inflate(O, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && $ && (M = typeof $ == "string" ? u.string2buf($) : p.call($) === "[object ArrayBuffer]" ? new Uint8Array($) : $, S = a.inflateSetDictionary(this.strm, M)), S === c.Z_BUF_ERROR && ne === !0 && (S = c.Z_OK, ne = !1), S !== c.Z_STREAM_END && S !== c.Z_OK) return this.onEnd(S), !(this.ended = !0);
          O.next_out && (O.avail_out !== 0 && S !== c.Z_STREAM_END && (O.avail_in !== 0 || x !== c.Z_FINISH && x !== c.Z_SYNC_FLUSH) || (this.options.to === "string" ? (_ = u.utf8border(O.output, O.next_out), C = O.next_out - _, k = u.buf2string(O.output, _), O.next_out = C, O.avail_out = F - C, C && l.arraySet(O.output, O.output, _, C, 0), this.onData(k)) : this.onData(l.shrinkBuf(O.output, O.next_out)))), O.avail_in === 0 && O.avail_out === 0 && (ne = !0);
        } while ((0 < O.avail_in || O.avail_out === 0) && S !== c.Z_STREAM_END);
        return S === c.Z_STREAM_END && (x = c.Z_FINISH), x === c.Z_FINISH ? (S = a.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === c.Z_OK) : x !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), !(O.avail_out = 0));
      }, y.prototype.onData = function(m) {
        this.chunks.push(m);
      }, y.prototype.onEnd = function(m) {
        m === c.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, o.Inflate = y, o.inflate = v, o.inflateRaw = function(m, b) {
        return (b = b || {}).raw = !0, v(m, b);
      }, o.ungzip = v;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(s, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      o.assign = function(c) {
        for (var d = Array.prototype.slice.call(arguments, 1); d.length; ) {
          var f = d.shift();
          if (f) {
            if (typeof f != "object") throw new TypeError(f + "must be non-object");
            for (var g in f) f.hasOwnProperty(g) && (c[g] = f[g]);
          }
        }
        return c;
      }, o.shrinkBuf = function(c, d) {
        return c.length === d ? c : c.subarray ? c.subarray(0, d) : (c.length = d, c);
      };
      var l = { arraySet: function(c, d, f, g, p) {
        if (d.subarray && c.subarray) c.set(d.subarray(f, f + g), p);
        else for (var y = 0; y < g; y++) c[p + y] = d[f + y];
      }, flattenChunks: function(c) {
        var d, f, g, p, y, v;
        for (d = g = 0, f = c.length; d < f; d++) g += c[d].length;
        for (v = new Uint8Array(g), d = p = 0, f = c.length; d < f; d++) y = c[d], v.set(y, p), p += y.length;
        return v;
      } }, u = { arraySet: function(c, d, f, g, p) {
        for (var y = 0; y < g; y++) c[p + y] = d[f + y];
      }, flattenChunks: function(c) {
        return [].concat.apply([], c);
      } };
      o.setTyped = function(c) {
        c ? (o.Buf8 = Uint8Array, o.Buf16 = Uint16Array, o.Buf32 = Int32Array, o.assign(o, l)) : (o.Buf8 = Array, o.Buf16 = Array, o.Buf32 = Array, o.assign(o, u));
      }, o.setTyped(a);
    }, {}], 42: [function(s, r, o) {
      var a = s("./common"), l = !0, u = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        u = !1;
      }
      for (var c = new a.Buf8(256), d = 0; d < 256; d++) c[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      function f(g, p) {
        if (p < 65537 && (g.subarray && u || !g.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(g, p));
        for (var y = "", v = 0; v < p; v++) y += String.fromCharCode(g[v]);
        return y;
      }
      c[254] = c[254] = 1, o.string2buf = function(g) {
        var p, y, v, m, b, S = g.length, x = 0;
        for (m = 0; m < S; m++) (64512 & (y = g.charCodeAt(m))) == 55296 && m + 1 < S && (64512 & (v = g.charCodeAt(m + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (v - 56320), m++), x += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
        for (p = new a.Buf8(x), m = b = 0; b < x; m++) (64512 & (y = g.charCodeAt(m))) == 55296 && m + 1 < S && (64512 & (v = g.charCodeAt(m + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (v - 56320), m++), y < 128 ? p[b++] = y : (y < 2048 ? p[b++] = 192 | y >>> 6 : (y < 65536 ? p[b++] = 224 | y >>> 12 : (p[b++] = 240 | y >>> 18, p[b++] = 128 | y >>> 12 & 63), p[b++] = 128 | y >>> 6 & 63), p[b++] = 128 | 63 & y);
        return p;
      }, o.buf2binstring = function(g) {
        return f(g, g.length);
      }, o.binstring2buf = function(g) {
        for (var p = new a.Buf8(g.length), y = 0, v = p.length; y < v; y++) p[y] = g.charCodeAt(y);
        return p;
      }, o.buf2string = function(g, p) {
        var y, v, m, b, S = p || g.length, x = new Array(2 * S);
        for (y = v = 0; y < S; ) if ((m = g[y++]) < 128) x[v++] = m;
        else if (4 < (b = c[m])) x[v++] = 65533, y += b - 1;
        else {
          for (m &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && y < S; ) m = m << 6 | 63 & g[y++], b--;
          1 < b ? x[v++] = 65533 : m < 65536 ? x[v++] = m : (m -= 65536, x[v++] = 55296 | m >> 10 & 1023, x[v++] = 56320 | 1023 & m);
        }
        return f(x, v);
      }, o.utf8border = function(g, p) {
        var y;
        for ((p = p || g.length) > g.length && (p = g.length), y = p - 1; 0 <= y && (192 & g[y]) == 128; ) y--;
        return y < 0 || y === 0 ? p : y + c[g[y]] > p ? y : p;
      };
    }, { "./common": 41 }], 43: [function(s, r, o) {
      r.exports = function(a, l, u, c) {
        for (var d = 65535 & a | 0, f = a >>> 16 & 65535 | 0, g = 0; u !== 0; ) {
          for (u -= g = 2e3 < u ? 2e3 : u; f = f + (d = d + l[c++] | 0) | 0, --g; ) ;
          d %= 65521, f %= 65521;
        }
        return d | f << 16 | 0;
      };
    }, {}], 44: [function(s, r, o) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(s, r, o) {
      var a = function() {
        for (var l, u = [], c = 0; c < 256; c++) {
          l = c;
          for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[c] = l;
        }
        return u;
      }();
      r.exports = function(l, u, c, d) {
        var f = a, g = d + c;
        l ^= -1;
        for (var p = d; p < g; p++) l = l >>> 8 ^ f[255 & (l ^ u[p])];
        return -1 ^ l;
      };
    }, {}], 46: [function(s, r, o) {
      var a, l = s("../utils/common"), u = s("./trees"), c = s("./adler32"), d = s("./crc32"), f = s("./messages"), g = 0, p = 4, y = 0, v = -2, m = -1, b = 4, S = 2, x = 8, _ = 9, C = 286, k = 30, M = 19, O = 2 * C + 1, F = 15, $ = 3, ne = 258, oe = ne + $ + 1, z = 42, X = 113, T = 1, H = 2, ge = 3, K = 4;
      function re(w, L) {
        return w.msg = f[L], L;
      }
      function ie(w) {
        return (w << 1) - (4 < w ? 9 : 0);
      }
      function be(w) {
        for (var L = w.length; 0 <= --L; ) w[L] = 0;
      }
      function J(w) {
        var L = w.state, A = L.pending;
        A > w.avail_out && (A = w.avail_out), A !== 0 && (l.arraySet(w.output, L.pending_buf, L.pending_out, A, w.next_out), w.next_out += A, L.pending_out += A, w.total_out += A, w.avail_out -= A, L.pending -= A, L.pending === 0 && (L.pending_out = 0));
      }
      function ee(w, L) {
        u._tr_flush_block(w, 0 <= w.block_start ? w.block_start : -1, w.strstart - w.block_start, L), w.block_start = w.strstart, J(w.strm);
      }
      function ve(w, L) {
        w.pending_buf[w.pending++] = L;
      }
      function G(w, L) {
        w.pending_buf[w.pending++] = L >>> 8 & 255, w.pending_buf[w.pending++] = 255 & L;
      }
      function N(w, L) {
        var A, E, I = w.max_chain_length, j = w.strstart, Q = w.prev_length, ce = w.nice_match, Z = w.strstart > w.w_size - oe ? w.strstart - (w.w_size - oe) : 0, xe = w.window, Me = w.w_mask, Se = w.prev, q = w.strstart + ne, de = xe[j + Q - 1], ye = xe[j + Q];
        w.prev_length >= w.good_match && (I >>= 2), ce > w.lookahead && (ce = w.lookahead);
        do
          if (xe[(A = L) + Q] === ye && xe[A + Q - 1] === de && xe[A] === xe[j] && xe[++A] === xe[j + 1]) {
            j += 2, A++;
            do
              ;
            while (xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && xe[++j] === xe[++A] && j < q);
            if (E = ne - (q - j), j = q - ne, Q < E) {
              if (w.match_start = L, ce <= (Q = E)) break;
              de = xe[j + Q - 1], ye = xe[j + Q];
            }
          }
        while ((L = Se[L & Me]) > Z && --I != 0);
        return Q <= w.lookahead ? Q : w.lookahead;
      }
      function te(w) {
        var L, A, E, I, j, Q, ce, Z, xe, Me, Se = w.w_size;
        do {
          if (I = w.window_size - w.lookahead - w.strstart, w.strstart >= Se + (Se - oe)) {
            for (l.arraySet(w.window, w.window, Se, Se, 0), w.match_start -= Se, w.strstart -= Se, w.block_start -= Se, L = A = w.hash_size; E = w.head[--L], w.head[L] = Se <= E ? E - Se : 0, --A; ) ;
            for (L = A = Se; E = w.prev[--L], w.prev[L] = Se <= E ? E - Se : 0, --A; ) ;
            I += Se;
          }
          if (w.strm.avail_in === 0) break;
          if (Q = w.strm, ce = w.window, Z = w.strstart + w.lookahead, xe = I, Me = void 0, Me = Q.avail_in, xe < Me && (Me = xe), A = Me === 0 ? 0 : (Q.avail_in -= Me, l.arraySet(ce, Q.input, Q.next_in, Me, Z), Q.state.wrap === 1 ? Q.adler = c(Q.adler, ce, Me, Z) : Q.state.wrap === 2 && (Q.adler = d(Q.adler, ce, Me, Z)), Q.next_in += Me, Q.total_in += Me, Me), w.lookahead += A, w.lookahead + w.insert >= $) for (j = w.strstart - w.insert, w.ins_h = w.window[j], w.ins_h = (w.ins_h << w.hash_shift ^ w.window[j + 1]) & w.hash_mask; w.insert && (w.ins_h = (w.ins_h << w.hash_shift ^ w.window[j + $ - 1]) & w.hash_mask, w.prev[j & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = j, j++, w.insert--, !(w.lookahead + w.insert < $)); ) ;
        } while (w.lookahead < oe && w.strm.avail_in !== 0);
      }
      function fe(w, L) {
        for (var A, E; ; ) {
          if (w.lookahead < oe) {
            if (te(w), w.lookahead < oe && L === g) return T;
            if (w.lookahead === 0) break;
          }
          if (A = 0, w.lookahead >= $ && (w.ins_h = (w.ins_h << w.hash_shift ^ w.window[w.strstart + $ - 1]) & w.hash_mask, A = w.prev[w.strstart & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = w.strstart), A !== 0 && w.strstart - A <= w.w_size - oe && (w.match_length = N(w, A)), w.match_length >= $) if (E = u._tr_tally(w, w.strstart - w.match_start, w.match_length - $), w.lookahead -= w.match_length, w.match_length <= w.max_lazy_match && w.lookahead >= $) {
            for (w.match_length--; w.strstart++, w.ins_h = (w.ins_h << w.hash_shift ^ w.window[w.strstart + $ - 1]) & w.hash_mask, A = w.prev[w.strstart & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = w.strstart, --w.match_length != 0; ) ;
            w.strstart++;
          } else w.strstart += w.match_length, w.match_length = 0, w.ins_h = w.window[w.strstart], w.ins_h = (w.ins_h << w.hash_shift ^ w.window[w.strstart + 1]) & w.hash_mask;
          else E = u._tr_tally(w, 0, w.window[w.strstart]), w.lookahead--, w.strstart++;
          if (E && (ee(w, !1), w.strm.avail_out === 0)) return T;
        }
        return w.insert = w.strstart < $ - 1 ? w.strstart : $ - 1, L === p ? (ee(w, !0), w.strm.avail_out === 0 ? ge : K) : w.last_lit && (ee(w, !1), w.strm.avail_out === 0) ? T : H;
      }
      function ae(w, L) {
        for (var A, E, I; ; ) {
          if (w.lookahead < oe) {
            if (te(w), w.lookahead < oe && L === g) return T;
            if (w.lookahead === 0) break;
          }
          if (A = 0, w.lookahead >= $ && (w.ins_h = (w.ins_h << w.hash_shift ^ w.window[w.strstart + $ - 1]) & w.hash_mask, A = w.prev[w.strstart & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = w.strstart), w.prev_length = w.match_length, w.prev_match = w.match_start, w.match_length = $ - 1, A !== 0 && w.prev_length < w.max_lazy_match && w.strstart - A <= w.w_size - oe && (w.match_length = N(w, A), w.match_length <= 5 && (w.strategy === 1 || w.match_length === $ && 4096 < w.strstart - w.match_start) && (w.match_length = $ - 1)), w.prev_length >= $ && w.match_length <= w.prev_length) {
            for (I = w.strstart + w.lookahead - $, E = u._tr_tally(w, w.strstart - 1 - w.prev_match, w.prev_length - $), w.lookahead -= w.prev_length - 1, w.prev_length -= 2; ++w.strstart <= I && (w.ins_h = (w.ins_h << w.hash_shift ^ w.window[w.strstart + $ - 1]) & w.hash_mask, A = w.prev[w.strstart & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = w.strstart), --w.prev_length != 0; ) ;
            if (w.match_available = 0, w.match_length = $ - 1, w.strstart++, E && (ee(w, !1), w.strm.avail_out === 0)) return T;
          } else if (w.match_available) {
            if ((E = u._tr_tally(w, 0, w.window[w.strstart - 1])) && ee(w, !1), w.strstart++, w.lookahead--, w.strm.avail_out === 0) return T;
          } else w.match_available = 1, w.strstart++, w.lookahead--;
        }
        return w.match_available && (E = u._tr_tally(w, 0, w.window[w.strstart - 1]), w.match_available = 0), w.insert = w.strstart < $ - 1 ? w.strstart : $ - 1, L === p ? (ee(w, !0), w.strm.avail_out === 0 ? ge : K) : w.last_lit && (ee(w, !1), w.strm.avail_out === 0) ? T : H;
      }
      function D(w, L, A, E, I) {
        this.good_length = w, this.max_lazy = L, this.nice_length = A, this.max_chain = E, this.func = I;
      }
      function R() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = x, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * O), this.dyn_dtree = new l.Buf16(2 * (2 * k + 1)), this.bl_tree = new l.Buf16(2 * (2 * M + 1)), be(this.dyn_ltree), be(this.dyn_dtree), be(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(F + 1), this.heap = new l.Buf16(2 * C + 1), be(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * C + 1), be(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function P(w) {
        var L;
        return w && w.state ? (w.total_in = w.total_out = 0, w.data_type = S, (L = w.state).pending = 0, L.pending_out = 0, L.wrap < 0 && (L.wrap = -L.wrap), L.status = L.wrap ? z : X, w.adler = L.wrap === 2 ? 0 : 1, L.last_flush = g, u._tr_init(L), y) : re(w, v);
      }
      function Y(w) {
        var L = P(w);
        return L === y && function(A) {
          A.window_size = 2 * A.w_size, be(A.head), A.max_lazy_match = a[A.level].max_lazy, A.good_match = a[A.level].good_length, A.nice_match = a[A.level].nice_length, A.max_chain_length = a[A.level].max_chain, A.strstart = 0, A.block_start = 0, A.lookahead = 0, A.insert = 0, A.match_length = A.prev_length = $ - 1, A.match_available = 0, A.ins_h = 0;
        }(w.state), L;
      }
      function U(w, L, A, E, I, j) {
        if (!w) return v;
        var Q = 1;
        if (L === m && (L = 6), E < 0 ? (Q = 0, E = -E) : 15 < E && (Q = 2, E -= 16), I < 1 || _ < I || A !== x || E < 8 || 15 < E || L < 0 || 9 < L || j < 0 || b < j) return re(w, v);
        E === 8 && (E = 9);
        var ce = new R();
        return (w.state = ce).strm = w, ce.wrap = Q, ce.gzhead = null, ce.w_bits = E, ce.w_size = 1 << ce.w_bits, ce.w_mask = ce.w_size - 1, ce.hash_bits = I + 7, ce.hash_size = 1 << ce.hash_bits, ce.hash_mask = ce.hash_size - 1, ce.hash_shift = ~~((ce.hash_bits + $ - 1) / $), ce.window = new l.Buf8(2 * ce.w_size), ce.head = new l.Buf16(ce.hash_size), ce.prev = new l.Buf16(ce.w_size), ce.lit_bufsize = 1 << I + 6, ce.pending_buf_size = 4 * ce.lit_bufsize, ce.pending_buf = new l.Buf8(ce.pending_buf_size), ce.d_buf = 1 * ce.lit_bufsize, ce.l_buf = 3 * ce.lit_bufsize, ce.level = L, ce.strategy = j, ce.method = A, Y(w);
      }
      a = [new D(0, 0, 0, 0, function(w, L) {
        var A = 65535;
        for (A > w.pending_buf_size - 5 && (A = w.pending_buf_size - 5); ; ) {
          if (w.lookahead <= 1) {
            if (te(w), w.lookahead === 0 && L === g) return T;
            if (w.lookahead === 0) break;
          }
          w.strstart += w.lookahead, w.lookahead = 0;
          var E = w.block_start + A;
          if ((w.strstart === 0 || w.strstart >= E) && (w.lookahead = w.strstart - E, w.strstart = E, ee(w, !1), w.strm.avail_out === 0) || w.strstart - w.block_start >= w.w_size - oe && (ee(w, !1), w.strm.avail_out === 0)) return T;
        }
        return w.insert = 0, L === p ? (ee(w, !0), w.strm.avail_out === 0 ? ge : K) : (w.strstart > w.block_start && (ee(w, !1), w.strm.avail_out), T);
      }), new D(4, 4, 8, 4, fe), new D(4, 5, 16, 8, fe), new D(4, 6, 32, 32, fe), new D(4, 4, 16, 16, ae), new D(8, 16, 32, 32, ae), new D(8, 16, 128, 128, ae), new D(8, 32, 128, 256, ae), new D(32, 128, 258, 1024, ae), new D(32, 258, 258, 4096, ae)], o.deflateInit = function(w, L) {
        return U(w, L, x, 15, 8, 0);
      }, o.deflateInit2 = U, o.deflateReset = Y, o.deflateResetKeep = P, o.deflateSetHeader = function(w, L) {
        return w && w.state ? w.state.wrap !== 2 ? v : (w.state.gzhead = L, y) : v;
      }, o.deflate = function(w, L) {
        var A, E, I, j;
        if (!w || !w.state || 5 < L || L < 0) return w ? re(w, v) : v;
        if (E = w.state, !w.output || !w.input && w.avail_in !== 0 || E.status === 666 && L !== p) return re(w, w.avail_out === 0 ? -5 : v);
        if (E.strm = w, A = E.last_flush, E.last_flush = L, E.status === z) if (E.wrap === 2) w.adler = 0, ve(E, 31), ve(E, 139), ve(E, 8), E.gzhead ? (ve(E, (E.gzhead.text ? 1 : 0) + (E.gzhead.hcrc ? 2 : 0) + (E.gzhead.extra ? 4 : 0) + (E.gzhead.name ? 8 : 0) + (E.gzhead.comment ? 16 : 0)), ve(E, 255 & E.gzhead.time), ve(E, E.gzhead.time >> 8 & 255), ve(E, E.gzhead.time >> 16 & 255), ve(E, E.gzhead.time >> 24 & 255), ve(E, E.level === 9 ? 2 : 2 <= E.strategy || E.level < 2 ? 4 : 0), ve(E, 255 & E.gzhead.os), E.gzhead.extra && E.gzhead.extra.length && (ve(E, 255 & E.gzhead.extra.length), ve(E, E.gzhead.extra.length >> 8 & 255)), E.gzhead.hcrc && (w.adler = d(w.adler, E.pending_buf, E.pending, 0)), E.gzindex = 0, E.status = 69) : (ve(E, 0), ve(E, 0), ve(E, 0), ve(E, 0), ve(E, 0), ve(E, E.level === 9 ? 2 : 2 <= E.strategy || E.level < 2 ? 4 : 0), ve(E, 3), E.status = X);
        else {
          var Q = x + (E.w_bits - 8 << 4) << 8;
          Q |= (2 <= E.strategy || E.level < 2 ? 0 : E.level < 6 ? 1 : E.level === 6 ? 2 : 3) << 6, E.strstart !== 0 && (Q |= 32), Q += 31 - Q % 31, E.status = X, G(E, Q), E.strstart !== 0 && (G(E, w.adler >>> 16), G(E, 65535 & w.adler)), w.adler = 1;
        }
        if (E.status === 69) if (E.gzhead.extra) {
          for (I = E.pending; E.gzindex < (65535 & E.gzhead.extra.length) && (E.pending !== E.pending_buf_size || (E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), J(w), I = E.pending, E.pending !== E.pending_buf_size)); ) ve(E, 255 & E.gzhead.extra[E.gzindex]), E.gzindex++;
          E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), E.gzindex === E.gzhead.extra.length && (E.gzindex = 0, E.status = 73);
        } else E.status = 73;
        if (E.status === 73) if (E.gzhead.name) {
          I = E.pending;
          do {
            if (E.pending === E.pending_buf_size && (E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), J(w), I = E.pending, E.pending === E.pending_buf_size)) {
              j = 1;
              break;
            }
            j = E.gzindex < E.gzhead.name.length ? 255 & E.gzhead.name.charCodeAt(E.gzindex++) : 0, ve(E, j);
          } while (j !== 0);
          E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), j === 0 && (E.gzindex = 0, E.status = 91);
        } else E.status = 91;
        if (E.status === 91) if (E.gzhead.comment) {
          I = E.pending;
          do {
            if (E.pending === E.pending_buf_size && (E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), J(w), I = E.pending, E.pending === E.pending_buf_size)) {
              j = 1;
              break;
            }
            j = E.gzindex < E.gzhead.comment.length ? 255 & E.gzhead.comment.charCodeAt(E.gzindex++) : 0, ve(E, j);
          } while (j !== 0);
          E.gzhead.hcrc && E.pending > I && (w.adler = d(w.adler, E.pending_buf, E.pending - I, I)), j === 0 && (E.status = 103);
        } else E.status = 103;
        if (E.status === 103 && (E.gzhead.hcrc ? (E.pending + 2 > E.pending_buf_size && J(w), E.pending + 2 <= E.pending_buf_size && (ve(E, 255 & w.adler), ve(E, w.adler >> 8 & 255), w.adler = 0, E.status = X)) : E.status = X), E.pending !== 0) {
          if (J(w), w.avail_out === 0) return E.last_flush = -1, y;
        } else if (w.avail_in === 0 && ie(L) <= ie(A) && L !== p) return re(w, -5);
        if (E.status === 666 && w.avail_in !== 0) return re(w, -5);
        if (w.avail_in !== 0 || E.lookahead !== 0 || L !== g && E.status !== 666) {
          var ce = E.strategy === 2 ? function(Z, xe) {
            for (var Me; ; ) {
              if (Z.lookahead === 0 && (te(Z), Z.lookahead === 0)) {
                if (xe === g) return T;
                break;
              }
              if (Z.match_length = 0, Me = u._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++, Me && (ee(Z, !1), Z.strm.avail_out === 0)) return T;
            }
            return Z.insert = 0, xe === p ? (ee(Z, !0), Z.strm.avail_out === 0 ? ge : K) : Z.last_lit && (ee(Z, !1), Z.strm.avail_out === 0) ? T : H;
          }(E, L) : E.strategy === 3 ? function(Z, xe) {
            for (var Me, Se, q, de, ye = Z.window; ; ) {
              if (Z.lookahead <= ne) {
                if (te(Z), Z.lookahead <= ne && xe === g) return T;
                if (Z.lookahead === 0) break;
              }
              if (Z.match_length = 0, Z.lookahead >= $ && 0 < Z.strstart && (Se = ye[q = Z.strstart - 1]) === ye[++q] && Se === ye[++q] && Se === ye[++q]) {
                de = Z.strstart + ne;
                do
                  ;
                while (Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && Se === ye[++q] && q < de);
                Z.match_length = ne - (de - q), Z.match_length > Z.lookahead && (Z.match_length = Z.lookahead);
              }
              if (Z.match_length >= $ ? (Me = u._tr_tally(Z, 1, Z.match_length - $), Z.lookahead -= Z.match_length, Z.strstart += Z.match_length, Z.match_length = 0) : (Me = u._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++), Me && (ee(Z, !1), Z.strm.avail_out === 0)) return T;
            }
            return Z.insert = 0, xe === p ? (ee(Z, !0), Z.strm.avail_out === 0 ? ge : K) : Z.last_lit && (ee(Z, !1), Z.strm.avail_out === 0) ? T : H;
          }(E, L) : a[E.level].func(E, L);
          if (ce !== ge && ce !== K || (E.status = 666), ce === T || ce === ge) return w.avail_out === 0 && (E.last_flush = -1), y;
          if (ce === H && (L === 1 ? u._tr_align(E) : L !== 5 && (u._tr_stored_block(E, 0, 0, !1), L === 3 && (be(E.head), E.lookahead === 0 && (E.strstart = 0, E.block_start = 0, E.insert = 0))), J(w), w.avail_out === 0)) return E.last_flush = -1, y;
        }
        return L !== p ? y : E.wrap <= 0 ? 1 : (E.wrap === 2 ? (ve(E, 255 & w.adler), ve(E, w.adler >> 8 & 255), ve(E, w.adler >> 16 & 255), ve(E, w.adler >> 24 & 255), ve(E, 255 & w.total_in), ve(E, w.total_in >> 8 & 255), ve(E, w.total_in >> 16 & 255), ve(E, w.total_in >> 24 & 255)) : (G(E, w.adler >>> 16), G(E, 65535 & w.adler)), J(w), 0 < E.wrap && (E.wrap = -E.wrap), E.pending !== 0 ? y : 1);
      }, o.deflateEnd = function(w) {
        var L;
        return w && w.state ? (L = w.state.status) !== z && L !== 69 && L !== 73 && L !== 91 && L !== 103 && L !== X && L !== 666 ? re(w, v) : (w.state = null, L === X ? re(w, -3) : y) : v;
      }, o.deflateSetDictionary = function(w, L) {
        var A, E, I, j, Q, ce, Z, xe, Me = L.length;
        if (!w || !w.state || (j = (A = w.state).wrap) === 2 || j === 1 && A.status !== z || A.lookahead) return v;
        for (j === 1 && (w.adler = c(w.adler, L, Me, 0)), A.wrap = 0, Me >= A.w_size && (j === 0 && (be(A.head), A.strstart = 0, A.block_start = 0, A.insert = 0), xe = new l.Buf8(A.w_size), l.arraySet(xe, L, Me - A.w_size, A.w_size, 0), L = xe, Me = A.w_size), Q = w.avail_in, ce = w.next_in, Z = w.input, w.avail_in = Me, w.next_in = 0, w.input = L, te(A); A.lookahead >= $; ) {
          for (E = A.strstart, I = A.lookahead - ($ - 1); A.ins_h = (A.ins_h << A.hash_shift ^ A.window[E + $ - 1]) & A.hash_mask, A.prev[E & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = E, E++, --I; ) ;
          A.strstart = E, A.lookahead = $ - 1, te(A);
        }
        return A.strstart += A.lookahead, A.block_start = A.strstart, A.insert = A.lookahead, A.lookahead = 0, A.match_length = A.prev_length = $ - 1, A.match_available = 0, w.next_in = ce, w.input = Z, w.avail_in = Q, A.wrap = j, y;
      }, o.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(s, r, o) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(s, r, o) {
      r.exports = function(a, l) {
        var u, c, d, f, g, p, y, v, m, b, S, x, _, C, k, M, O, F, $, ne, oe, z, X, T, H;
        u = a.state, c = a.next_in, T = a.input, d = c + (a.avail_in - 5), f = a.next_out, H = a.output, g = f - (l - a.avail_out), p = f + (a.avail_out - 257), y = u.dmax, v = u.wsize, m = u.whave, b = u.wnext, S = u.window, x = u.hold, _ = u.bits, C = u.lencode, k = u.distcode, M = (1 << u.lenbits) - 1, O = (1 << u.distbits) - 1;
        e: do {
          _ < 15 && (x += T[c++] << _, _ += 8, x += T[c++] << _, _ += 8), F = C[x & M];
          t: for (; ; ) {
            if (x >>>= $ = F >>> 24, _ -= $, ($ = F >>> 16 & 255) === 0) H[f++] = 65535 & F;
            else {
              if (!(16 & $)) {
                if (!(64 & $)) {
                  F = C[(65535 & F) + (x & (1 << $) - 1)];
                  continue t;
                }
                if (32 & $) {
                  u.mode = 12;
                  break e;
                }
                a.msg = "invalid literal/length code", u.mode = 30;
                break e;
              }
              ne = 65535 & F, ($ &= 15) && (_ < $ && (x += T[c++] << _, _ += 8), ne += x & (1 << $) - 1, x >>>= $, _ -= $), _ < 15 && (x += T[c++] << _, _ += 8, x += T[c++] << _, _ += 8), F = k[x & O];
              n: for (; ; ) {
                if (x >>>= $ = F >>> 24, _ -= $, !(16 & ($ = F >>> 16 & 255))) {
                  if (!(64 & $)) {
                    F = k[(65535 & F) + (x & (1 << $) - 1)];
                    continue n;
                  }
                  a.msg = "invalid distance code", u.mode = 30;
                  break e;
                }
                if (oe = 65535 & F, _ < ($ &= 15) && (x += T[c++] << _, (_ += 8) < $ && (x += T[c++] << _, _ += 8)), y < (oe += x & (1 << $) - 1)) {
                  a.msg = "invalid distance too far back", u.mode = 30;
                  break e;
                }
                if (x >>>= $, _ -= $, ($ = f - g) < oe) {
                  if (m < ($ = oe - $) && u.sane) {
                    a.msg = "invalid distance too far back", u.mode = 30;
                    break e;
                  }
                  if (X = S, (z = 0) === b) {
                    if (z += v - $, $ < ne) {
                      for (ne -= $; H[f++] = S[z++], --$; ) ;
                      z = f - oe, X = H;
                    }
                  } else if (b < $) {
                    if (z += v + b - $, ($ -= b) < ne) {
                      for (ne -= $; H[f++] = S[z++], --$; ) ;
                      if (z = 0, b < ne) {
                        for (ne -= $ = b; H[f++] = S[z++], --$; ) ;
                        z = f - oe, X = H;
                      }
                    }
                  } else if (z += b - $, $ < ne) {
                    for (ne -= $; H[f++] = S[z++], --$; ) ;
                    z = f - oe, X = H;
                  }
                  for (; 2 < ne; ) H[f++] = X[z++], H[f++] = X[z++], H[f++] = X[z++], ne -= 3;
                  ne && (H[f++] = X[z++], 1 < ne && (H[f++] = X[z++]));
                } else {
                  for (z = f - oe; H[f++] = H[z++], H[f++] = H[z++], H[f++] = H[z++], 2 < (ne -= 3); ) ;
                  ne && (H[f++] = H[z++], 1 < ne && (H[f++] = H[z++]));
                }
                break;
              }
            }
            break;
          }
        } while (c < d && f < p);
        c -= ne = _ >> 3, x &= (1 << (_ -= ne << 3)) - 1, a.next_in = c, a.next_out = f, a.avail_in = c < d ? d - c + 5 : 5 - (c - d), a.avail_out = f < p ? p - f + 257 : 257 - (f - p), u.hold = x, u.bits = _;
      };
    }, {}], 49: [function(s, r, o) {
      var a = s("../utils/common"), l = s("./adler32"), u = s("./crc32"), c = s("./inffast"), d = s("./inftrees"), f = 1, g = 2, p = 0, y = -2, v = 1, m = 852, b = 592;
      function S(z) {
        return (z >>> 24 & 255) + (z >>> 8 & 65280) + ((65280 & z) << 8) + ((255 & z) << 24);
      }
      function x() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function _(z) {
        var X;
        return z && z.state ? (X = z.state, z.total_in = z.total_out = X.total = 0, z.msg = "", X.wrap && (z.adler = 1 & X.wrap), X.mode = v, X.last = 0, X.havedict = 0, X.dmax = 32768, X.head = null, X.hold = 0, X.bits = 0, X.lencode = X.lendyn = new a.Buf32(m), X.distcode = X.distdyn = new a.Buf32(b), X.sane = 1, X.back = -1, p) : y;
      }
      function C(z) {
        var X;
        return z && z.state ? ((X = z.state).wsize = 0, X.whave = 0, X.wnext = 0, _(z)) : y;
      }
      function k(z, X) {
        var T, H;
        return z && z.state ? (H = z.state, X < 0 ? (T = 0, X = -X) : (T = 1 + (X >> 4), X < 48 && (X &= 15)), X && (X < 8 || 15 < X) ? y : (H.window !== null && H.wbits !== X && (H.window = null), H.wrap = T, H.wbits = X, C(z))) : y;
      }
      function M(z, X) {
        var T, H;
        return z ? (H = new x(), (z.state = H).window = null, (T = k(z, X)) !== p && (z.state = null), T) : y;
      }
      var O, F, $ = !0;
      function ne(z) {
        if ($) {
          var X;
          for (O = new a.Buf32(512), F = new a.Buf32(32), X = 0; X < 144; ) z.lens[X++] = 8;
          for (; X < 256; ) z.lens[X++] = 9;
          for (; X < 280; ) z.lens[X++] = 7;
          for (; X < 288; ) z.lens[X++] = 8;
          for (d(f, z.lens, 0, 288, O, 0, z.work, { bits: 9 }), X = 0; X < 32; ) z.lens[X++] = 5;
          d(g, z.lens, 0, 32, F, 0, z.work, { bits: 5 }), $ = !1;
        }
        z.lencode = O, z.lenbits = 9, z.distcode = F, z.distbits = 5;
      }
      function oe(z, X, T, H) {
        var ge, K = z.state;
        return K.window === null && (K.wsize = 1 << K.wbits, K.wnext = 0, K.whave = 0, K.window = new a.Buf8(K.wsize)), H >= K.wsize ? (a.arraySet(K.window, X, T - K.wsize, K.wsize, 0), K.wnext = 0, K.whave = K.wsize) : (H < (ge = K.wsize - K.wnext) && (ge = H), a.arraySet(K.window, X, T - H, ge, K.wnext), (H -= ge) ? (a.arraySet(K.window, X, T - H, H, 0), K.wnext = H, K.whave = K.wsize) : (K.wnext += ge, K.wnext === K.wsize && (K.wnext = 0), K.whave < K.wsize && (K.whave += ge))), 0;
      }
      o.inflateReset = C, o.inflateReset2 = k, o.inflateResetKeep = _, o.inflateInit = function(z) {
        return M(z, 15);
      }, o.inflateInit2 = M, o.inflate = function(z, X) {
        var T, H, ge, K, re, ie, be, J, ee, ve, G, N, te, fe, ae, D, R, P, Y, U, w, L, A, E, I = 0, j = new a.Buf8(4), Q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!z || !z.state || !z.output || !z.input && z.avail_in !== 0) return y;
        (T = z.state).mode === 12 && (T.mode = 13), re = z.next_out, ge = z.output, be = z.avail_out, K = z.next_in, H = z.input, ie = z.avail_in, J = T.hold, ee = T.bits, ve = ie, G = be, L = p;
        e: for (; ; ) switch (T.mode) {
          case v:
            if (T.wrap === 0) {
              T.mode = 13;
              break;
            }
            for (; ee < 16; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if (2 & T.wrap && J === 35615) {
              j[T.check = 0] = 255 & J, j[1] = J >>> 8 & 255, T.check = u(T.check, j, 2, 0), ee = J = 0, T.mode = 2;
              break;
            }
            if (T.flags = 0, T.head && (T.head.done = !1), !(1 & T.wrap) || (((255 & J) << 8) + (J >> 8)) % 31) {
              z.msg = "incorrect header check", T.mode = 30;
              break;
            }
            if ((15 & J) != 8) {
              z.msg = "unknown compression method", T.mode = 30;
              break;
            }
            if (ee -= 4, w = 8 + (15 & (J >>>= 4)), T.wbits === 0) T.wbits = w;
            else if (w > T.wbits) {
              z.msg = "invalid window size", T.mode = 30;
              break;
            }
            T.dmax = 1 << w, z.adler = T.check = 1, T.mode = 512 & J ? 10 : 12, ee = J = 0;
            break;
          case 2:
            for (; ee < 16; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if (T.flags = J, (255 & T.flags) != 8) {
              z.msg = "unknown compression method", T.mode = 30;
              break;
            }
            if (57344 & T.flags) {
              z.msg = "unknown header flags set", T.mode = 30;
              break;
            }
            T.head && (T.head.text = J >> 8 & 1), 512 & T.flags && (j[0] = 255 & J, j[1] = J >>> 8 & 255, T.check = u(T.check, j, 2, 0)), ee = J = 0, T.mode = 3;
          case 3:
            for (; ee < 32; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            T.head && (T.head.time = J), 512 & T.flags && (j[0] = 255 & J, j[1] = J >>> 8 & 255, j[2] = J >>> 16 & 255, j[3] = J >>> 24 & 255, T.check = u(T.check, j, 4, 0)), ee = J = 0, T.mode = 4;
          case 4:
            for (; ee < 16; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            T.head && (T.head.xflags = 255 & J, T.head.os = J >> 8), 512 & T.flags && (j[0] = 255 & J, j[1] = J >>> 8 & 255, T.check = u(T.check, j, 2, 0)), ee = J = 0, T.mode = 5;
          case 5:
            if (1024 & T.flags) {
              for (; ee < 16; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              T.length = J, T.head && (T.head.extra_len = J), 512 & T.flags && (j[0] = 255 & J, j[1] = J >>> 8 & 255, T.check = u(T.check, j, 2, 0)), ee = J = 0;
            } else T.head && (T.head.extra = null);
            T.mode = 6;
          case 6:
            if (1024 & T.flags && (ie < (N = T.length) && (N = ie), N && (T.head && (w = T.head.extra_len - T.length, T.head.extra || (T.head.extra = new Array(T.head.extra_len)), a.arraySet(T.head.extra, H, K, N, w)), 512 & T.flags && (T.check = u(T.check, H, N, K)), ie -= N, K += N, T.length -= N), T.length)) break e;
            T.length = 0, T.mode = 7;
          case 7:
            if (2048 & T.flags) {
              if (ie === 0) break e;
              for (N = 0; w = H[K + N++], T.head && w && T.length < 65536 && (T.head.name += String.fromCharCode(w)), w && N < ie; ) ;
              if (512 & T.flags && (T.check = u(T.check, H, N, K)), ie -= N, K += N, w) break e;
            } else T.head && (T.head.name = null);
            T.length = 0, T.mode = 8;
          case 8:
            if (4096 & T.flags) {
              if (ie === 0) break e;
              for (N = 0; w = H[K + N++], T.head && w && T.length < 65536 && (T.head.comment += String.fromCharCode(w)), w && N < ie; ) ;
              if (512 & T.flags && (T.check = u(T.check, H, N, K)), ie -= N, K += N, w) break e;
            } else T.head && (T.head.comment = null);
            T.mode = 9;
          case 9:
            if (512 & T.flags) {
              for (; ee < 16; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              if (J !== (65535 & T.check)) {
                z.msg = "header crc mismatch", T.mode = 30;
                break;
              }
              ee = J = 0;
            }
            T.head && (T.head.hcrc = T.flags >> 9 & 1, T.head.done = !0), z.adler = T.check = 0, T.mode = 12;
            break;
          case 10:
            for (; ee < 32; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            z.adler = T.check = S(J), ee = J = 0, T.mode = 11;
          case 11:
            if (T.havedict === 0) return z.next_out = re, z.avail_out = be, z.next_in = K, z.avail_in = ie, T.hold = J, T.bits = ee, 2;
            z.adler = T.check = 1, T.mode = 12;
          case 12:
            if (X === 5 || X === 6) break e;
          case 13:
            if (T.last) {
              J >>>= 7 & ee, ee -= 7 & ee, T.mode = 27;
              break;
            }
            for (; ee < 3; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            switch (T.last = 1 & J, ee -= 1, 3 & (J >>>= 1)) {
              case 0:
                T.mode = 14;
                break;
              case 1:
                if (ne(T), T.mode = 20, X !== 6) break;
                J >>>= 2, ee -= 2;
                break e;
              case 2:
                T.mode = 17;
                break;
              case 3:
                z.msg = "invalid block type", T.mode = 30;
            }
            J >>>= 2, ee -= 2;
            break;
          case 14:
            for (J >>>= 7 & ee, ee -= 7 & ee; ee < 32; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if ((65535 & J) != (J >>> 16 ^ 65535)) {
              z.msg = "invalid stored block lengths", T.mode = 30;
              break;
            }
            if (T.length = 65535 & J, ee = J = 0, T.mode = 15, X === 6) break e;
          case 15:
            T.mode = 16;
          case 16:
            if (N = T.length) {
              if (ie < N && (N = ie), be < N && (N = be), N === 0) break e;
              a.arraySet(ge, H, K, N, re), ie -= N, K += N, be -= N, re += N, T.length -= N;
              break;
            }
            T.mode = 12;
            break;
          case 17:
            for (; ee < 14; ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if (T.nlen = 257 + (31 & J), J >>>= 5, ee -= 5, T.ndist = 1 + (31 & J), J >>>= 5, ee -= 5, T.ncode = 4 + (15 & J), J >>>= 4, ee -= 4, 286 < T.nlen || 30 < T.ndist) {
              z.msg = "too many length or distance symbols", T.mode = 30;
              break;
            }
            T.have = 0, T.mode = 18;
          case 18:
            for (; T.have < T.ncode; ) {
              for (; ee < 3; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              T.lens[Q[T.have++]] = 7 & J, J >>>= 3, ee -= 3;
            }
            for (; T.have < 19; ) T.lens[Q[T.have++]] = 0;
            if (T.lencode = T.lendyn, T.lenbits = 7, A = { bits: T.lenbits }, L = d(0, T.lens, 0, 19, T.lencode, 0, T.work, A), T.lenbits = A.bits, L) {
              z.msg = "invalid code lengths set", T.mode = 30;
              break;
            }
            T.have = 0, T.mode = 19;
          case 19:
            for (; T.have < T.nlen + T.ndist; ) {
              for (; D = (I = T.lencode[J & (1 << T.lenbits) - 1]) >>> 16 & 255, R = 65535 & I, !((ae = I >>> 24) <= ee); ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              if (R < 16) J >>>= ae, ee -= ae, T.lens[T.have++] = R;
              else {
                if (R === 16) {
                  for (E = ae + 2; ee < E; ) {
                    if (ie === 0) break e;
                    ie--, J += H[K++] << ee, ee += 8;
                  }
                  if (J >>>= ae, ee -= ae, T.have === 0) {
                    z.msg = "invalid bit length repeat", T.mode = 30;
                    break;
                  }
                  w = T.lens[T.have - 1], N = 3 + (3 & J), J >>>= 2, ee -= 2;
                } else if (R === 17) {
                  for (E = ae + 3; ee < E; ) {
                    if (ie === 0) break e;
                    ie--, J += H[K++] << ee, ee += 8;
                  }
                  ee -= ae, w = 0, N = 3 + (7 & (J >>>= ae)), J >>>= 3, ee -= 3;
                } else {
                  for (E = ae + 7; ee < E; ) {
                    if (ie === 0) break e;
                    ie--, J += H[K++] << ee, ee += 8;
                  }
                  ee -= ae, w = 0, N = 11 + (127 & (J >>>= ae)), J >>>= 7, ee -= 7;
                }
                if (T.have + N > T.nlen + T.ndist) {
                  z.msg = "invalid bit length repeat", T.mode = 30;
                  break;
                }
                for (; N--; ) T.lens[T.have++] = w;
              }
            }
            if (T.mode === 30) break;
            if (T.lens[256] === 0) {
              z.msg = "invalid code -- missing end-of-block", T.mode = 30;
              break;
            }
            if (T.lenbits = 9, A = { bits: T.lenbits }, L = d(f, T.lens, 0, T.nlen, T.lencode, 0, T.work, A), T.lenbits = A.bits, L) {
              z.msg = "invalid literal/lengths set", T.mode = 30;
              break;
            }
            if (T.distbits = 6, T.distcode = T.distdyn, A = { bits: T.distbits }, L = d(g, T.lens, T.nlen, T.ndist, T.distcode, 0, T.work, A), T.distbits = A.bits, L) {
              z.msg = "invalid distances set", T.mode = 30;
              break;
            }
            if (T.mode = 20, X === 6) break e;
          case 20:
            T.mode = 21;
          case 21:
            if (6 <= ie && 258 <= be) {
              z.next_out = re, z.avail_out = be, z.next_in = K, z.avail_in = ie, T.hold = J, T.bits = ee, c(z, G), re = z.next_out, ge = z.output, be = z.avail_out, K = z.next_in, H = z.input, ie = z.avail_in, J = T.hold, ee = T.bits, T.mode === 12 && (T.back = -1);
              break;
            }
            for (T.back = 0; D = (I = T.lencode[J & (1 << T.lenbits) - 1]) >>> 16 & 255, R = 65535 & I, !((ae = I >>> 24) <= ee); ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if (D && !(240 & D)) {
              for (P = ae, Y = D, U = R; D = (I = T.lencode[U + ((J & (1 << P + Y) - 1) >> P)]) >>> 16 & 255, R = 65535 & I, !(P + (ae = I >>> 24) <= ee); ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              J >>>= P, ee -= P, T.back += P;
            }
            if (J >>>= ae, ee -= ae, T.back += ae, T.length = R, D === 0) {
              T.mode = 26;
              break;
            }
            if (32 & D) {
              T.back = -1, T.mode = 12;
              break;
            }
            if (64 & D) {
              z.msg = "invalid literal/length code", T.mode = 30;
              break;
            }
            T.extra = 15 & D, T.mode = 22;
          case 22:
            if (T.extra) {
              for (E = T.extra; ee < E; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              T.length += J & (1 << T.extra) - 1, J >>>= T.extra, ee -= T.extra, T.back += T.extra;
            }
            T.was = T.length, T.mode = 23;
          case 23:
            for (; D = (I = T.distcode[J & (1 << T.distbits) - 1]) >>> 16 & 255, R = 65535 & I, !((ae = I >>> 24) <= ee); ) {
              if (ie === 0) break e;
              ie--, J += H[K++] << ee, ee += 8;
            }
            if (!(240 & D)) {
              for (P = ae, Y = D, U = R; D = (I = T.distcode[U + ((J & (1 << P + Y) - 1) >> P)]) >>> 16 & 255, R = 65535 & I, !(P + (ae = I >>> 24) <= ee); ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              J >>>= P, ee -= P, T.back += P;
            }
            if (J >>>= ae, ee -= ae, T.back += ae, 64 & D) {
              z.msg = "invalid distance code", T.mode = 30;
              break;
            }
            T.offset = R, T.extra = 15 & D, T.mode = 24;
          case 24:
            if (T.extra) {
              for (E = T.extra; ee < E; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              T.offset += J & (1 << T.extra) - 1, J >>>= T.extra, ee -= T.extra, T.back += T.extra;
            }
            if (T.offset > T.dmax) {
              z.msg = "invalid distance too far back", T.mode = 30;
              break;
            }
            T.mode = 25;
          case 25:
            if (be === 0) break e;
            if (N = G - be, T.offset > N) {
              if ((N = T.offset - N) > T.whave && T.sane) {
                z.msg = "invalid distance too far back", T.mode = 30;
                break;
              }
              te = N > T.wnext ? (N -= T.wnext, T.wsize - N) : T.wnext - N, N > T.length && (N = T.length), fe = T.window;
            } else fe = ge, te = re - T.offset, N = T.length;
            for (be < N && (N = be), be -= N, T.length -= N; ge[re++] = fe[te++], --N; ) ;
            T.length === 0 && (T.mode = 21);
            break;
          case 26:
            if (be === 0) break e;
            ge[re++] = T.length, be--, T.mode = 21;
            break;
          case 27:
            if (T.wrap) {
              for (; ee < 32; ) {
                if (ie === 0) break e;
                ie--, J |= H[K++] << ee, ee += 8;
              }
              if (G -= be, z.total_out += G, T.total += G, G && (z.adler = T.check = T.flags ? u(T.check, ge, G, re - G) : l(T.check, ge, G, re - G)), G = be, (T.flags ? J : S(J)) !== T.check) {
                z.msg = "incorrect data check", T.mode = 30;
                break;
              }
              ee = J = 0;
            }
            T.mode = 28;
          case 28:
            if (T.wrap && T.flags) {
              for (; ee < 32; ) {
                if (ie === 0) break e;
                ie--, J += H[K++] << ee, ee += 8;
              }
              if (J !== (4294967295 & T.total)) {
                z.msg = "incorrect length check", T.mode = 30;
                break;
              }
              ee = J = 0;
            }
            T.mode = 29;
          case 29:
            L = 1;
            break e;
          case 30:
            L = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return y;
        }
        return z.next_out = re, z.avail_out = be, z.next_in = K, z.avail_in = ie, T.hold = J, T.bits = ee, (T.wsize || G !== z.avail_out && T.mode < 30 && (T.mode < 27 || X !== 4)) && oe(z, z.output, z.next_out, G - z.avail_out) ? (T.mode = 31, -4) : (ve -= z.avail_in, G -= z.avail_out, z.total_in += ve, z.total_out += G, T.total += G, T.wrap && G && (z.adler = T.check = T.flags ? u(T.check, ge, G, z.next_out - G) : l(T.check, ge, G, z.next_out - G)), z.data_type = T.bits + (T.last ? 64 : 0) + (T.mode === 12 ? 128 : 0) + (T.mode === 20 || T.mode === 15 ? 256 : 0), (ve == 0 && G === 0 || X === 4) && L === p && (L = -5), L);
      }, o.inflateEnd = function(z) {
        if (!z || !z.state) return y;
        var X = z.state;
        return X.window && (X.window = null), z.state = null, p;
      }, o.inflateGetHeader = function(z, X) {
        var T;
        return z && z.state && 2 & (T = z.state).wrap ? ((T.head = X).done = !1, p) : y;
      }, o.inflateSetDictionary = function(z, X) {
        var T, H = X.length;
        return z && z.state ? (T = z.state).wrap !== 0 && T.mode !== 11 ? y : T.mode === 11 && l(1, X, H, 0) !== T.check ? -3 : oe(z, X, H, H) ? (T.mode = 31, -4) : (T.havedict = 1, p) : y;
      }, o.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(s, r, o) {
      var a = s("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], u = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], c = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(f, g, p, y, v, m, b, S) {
        var x, _, C, k, M, O, F, $, ne, oe = S.bits, z = 0, X = 0, T = 0, H = 0, ge = 0, K = 0, re = 0, ie = 0, be = 0, J = 0, ee = null, ve = 0, G = new a.Buf16(16), N = new a.Buf16(16), te = null, fe = 0;
        for (z = 0; z <= 15; z++) G[z] = 0;
        for (X = 0; X < y; X++) G[g[p + X]]++;
        for (ge = oe, H = 15; 1 <= H && G[H] === 0; H--) ;
        if (H < ge && (ge = H), H === 0) return v[m++] = 20971520, v[m++] = 20971520, S.bits = 1, 0;
        for (T = 1; T < H && G[T] === 0; T++) ;
        for (ge < T && (ge = T), z = ie = 1; z <= 15; z++) if (ie <<= 1, (ie -= G[z]) < 0) return -1;
        if (0 < ie && (f === 0 || H !== 1)) return -1;
        for (N[1] = 0, z = 1; z < 15; z++) N[z + 1] = N[z] + G[z];
        for (X = 0; X < y; X++) g[p + X] !== 0 && (b[N[g[p + X]]++] = X);
        if (O = f === 0 ? (ee = te = b, 19) : f === 1 ? (ee = l, ve -= 257, te = u, fe -= 257, 256) : (ee = c, te = d, -1), z = T, M = m, re = X = J = 0, C = -1, k = (be = 1 << (K = ge)) - 1, f === 1 && 852 < be || f === 2 && 592 < be) return 1;
        for (; ; ) {
          for (F = z - re, ne = b[X] < O ? ($ = 0, b[X]) : b[X] > O ? ($ = te[fe + b[X]], ee[ve + b[X]]) : ($ = 96, 0), x = 1 << z - re, T = _ = 1 << K; v[M + (J >> re) + (_ -= x)] = F << 24 | $ << 16 | ne | 0, _ !== 0; ) ;
          for (x = 1 << z - 1; J & x; ) x >>= 1;
          if (x !== 0 ? (J &= x - 1, J += x) : J = 0, X++, --G[z] == 0) {
            if (z === H) break;
            z = g[p + b[X]];
          }
          if (ge < z && (J & k) !== C) {
            for (re === 0 && (re = ge), M += T, ie = 1 << (K = z - re); K + re < H && !((ie -= G[K + re]) <= 0); ) K++, ie <<= 1;
            if (be += 1 << K, f === 1 && 852 < be || f === 2 && 592 < be) return 1;
            v[C = J & k] = ge << 24 | K << 16 | M - m | 0;
          }
        }
        return J !== 0 && (v[M + J] = z - re << 24 | 64 << 16 | 0), S.bits = ge, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(s, r, o) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(s, r, o) {
      var a = s("../utils/common"), l = 0, u = 1;
      function c(I) {
        for (var j = I.length; 0 <= --j; ) I[j] = 0;
      }
      var d = 0, f = 29, g = 256, p = g + 1 + f, y = 30, v = 19, m = 2 * p + 1, b = 15, S = 16, x = 7, _ = 256, C = 16, k = 17, M = 18, O = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], F = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], $ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ne = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], oe = new Array(2 * (p + 2));
      c(oe);
      var z = new Array(2 * y);
      c(z);
      var X = new Array(512);
      c(X);
      var T = new Array(256);
      c(T);
      var H = new Array(f);
      c(H);
      var ge, K, re, ie = new Array(y);
      function be(I, j, Q, ce, Z) {
        this.static_tree = I, this.extra_bits = j, this.extra_base = Q, this.elems = ce, this.max_length = Z, this.has_stree = I && I.length;
      }
      function J(I, j) {
        this.dyn_tree = I, this.max_code = 0, this.stat_desc = j;
      }
      function ee(I) {
        return I < 256 ? X[I] : X[256 + (I >>> 7)];
      }
      function ve(I, j) {
        I.pending_buf[I.pending++] = 255 & j, I.pending_buf[I.pending++] = j >>> 8 & 255;
      }
      function G(I, j, Q) {
        I.bi_valid > S - Q ? (I.bi_buf |= j << I.bi_valid & 65535, ve(I, I.bi_buf), I.bi_buf = j >> S - I.bi_valid, I.bi_valid += Q - S) : (I.bi_buf |= j << I.bi_valid & 65535, I.bi_valid += Q);
      }
      function N(I, j, Q) {
        G(I, Q[2 * j], Q[2 * j + 1]);
      }
      function te(I, j) {
        for (var Q = 0; Q |= 1 & I, I >>>= 1, Q <<= 1, 0 < --j; ) ;
        return Q >>> 1;
      }
      function fe(I, j, Q) {
        var ce, Z, xe = new Array(b + 1), Me = 0;
        for (ce = 1; ce <= b; ce++) xe[ce] = Me = Me + Q[ce - 1] << 1;
        for (Z = 0; Z <= j; Z++) {
          var Se = I[2 * Z + 1];
          Se !== 0 && (I[2 * Z] = te(xe[Se]++, Se));
        }
      }
      function ae(I) {
        var j;
        for (j = 0; j < p; j++) I.dyn_ltree[2 * j] = 0;
        for (j = 0; j < y; j++) I.dyn_dtree[2 * j] = 0;
        for (j = 0; j < v; j++) I.bl_tree[2 * j] = 0;
        I.dyn_ltree[2 * _] = 1, I.opt_len = I.static_len = 0, I.last_lit = I.matches = 0;
      }
      function D(I) {
        8 < I.bi_valid ? ve(I, I.bi_buf) : 0 < I.bi_valid && (I.pending_buf[I.pending++] = I.bi_buf), I.bi_buf = 0, I.bi_valid = 0;
      }
      function R(I, j, Q, ce) {
        var Z = 2 * j, xe = 2 * Q;
        return I[Z] < I[xe] || I[Z] === I[xe] && ce[j] <= ce[Q];
      }
      function P(I, j, Q) {
        for (var ce = I.heap[Q], Z = Q << 1; Z <= I.heap_len && (Z < I.heap_len && R(j, I.heap[Z + 1], I.heap[Z], I.depth) && Z++, !R(j, ce, I.heap[Z], I.depth)); ) I.heap[Q] = I.heap[Z], Q = Z, Z <<= 1;
        I.heap[Q] = ce;
      }
      function Y(I, j, Q) {
        var ce, Z, xe, Me, Se = 0;
        if (I.last_lit !== 0) for (; ce = I.pending_buf[I.d_buf + 2 * Se] << 8 | I.pending_buf[I.d_buf + 2 * Se + 1], Z = I.pending_buf[I.l_buf + Se], Se++, ce === 0 ? N(I, Z, j) : (N(I, (xe = T[Z]) + g + 1, j), (Me = O[xe]) !== 0 && G(I, Z -= H[xe], Me), N(I, xe = ee(--ce), Q), (Me = F[xe]) !== 0 && G(I, ce -= ie[xe], Me)), Se < I.last_lit; ) ;
        N(I, _, j);
      }
      function U(I, j) {
        var Q, ce, Z, xe = j.dyn_tree, Me = j.stat_desc.static_tree, Se = j.stat_desc.has_stree, q = j.stat_desc.elems, de = -1;
        for (I.heap_len = 0, I.heap_max = m, Q = 0; Q < q; Q++) xe[2 * Q] !== 0 ? (I.heap[++I.heap_len] = de = Q, I.depth[Q] = 0) : xe[2 * Q + 1] = 0;
        for (; I.heap_len < 2; ) xe[2 * (Z = I.heap[++I.heap_len] = de < 2 ? ++de : 0)] = 1, I.depth[Z] = 0, I.opt_len--, Se && (I.static_len -= Me[2 * Z + 1]);
        for (j.max_code = de, Q = I.heap_len >> 1; 1 <= Q; Q--) P(I, xe, Q);
        for (Z = q; Q = I.heap[1], I.heap[1] = I.heap[I.heap_len--], P(I, xe, 1), ce = I.heap[1], I.heap[--I.heap_max] = Q, I.heap[--I.heap_max] = ce, xe[2 * Z] = xe[2 * Q] + xe[2 * ce], I.depth[Z] = (I.depth[Q] >= I.depth[ce] ? I.depth[Q] : I.depth[ce]) + 1, xe[2 * Q + 1] = xe[2 * ce + 1] = Z, I.heap[1] = Z++, P(I, xe, 1), 2 <= I.heap_len; ) ;
        I.heap[--I.heap_max] = I.heap[1], function(ye, Ee) {
          var Le, ze, ke, Ce, Pe, je, Ge = Ee.dyn_tree, ct = Ee.max_code, St = Ee.stat_desc.static_tree, Ut = Ee.stat_desc.has_stree, Vt = Ee.stat_desc.extra_bits, jt = Ee.stat_desc.extra_base, Dt = Ee.stat_desc.max_length, _n = 0;
          for (Ce = 0; Ce <= b; Ce++) ye.bl_count[Ce] = 0;
          for (Ge[2 * ye.heap[ye.heap_max] + 1] = 0, Le = ye.heap_max + 1; Le < m; Le++) Dt < (Ce = Ge[2 * Ge[2 * (ze = ye.heap[Le]) + 1] + 1] + 1) && (Ce = Dt, _n++), Ge[2 * ze + 1] = Ce, ct < ze || (ye.bl_count[Ce]++, Pe = 0, jt <= ze && (Pe = Vt[ze - jt]), je = Ge[2 * ze], ye.opt_len += je * (Ce + Pe), Ut && (ye.static_len += je * (St[2 * ze + 1] + Pe)));
          if (_n !== 0) {
            do {
              for (Ce = Dt - 1; ye.bl_count[Ce] === 0; ) Ce--;
              ye.bl_count[Ce]--, ye.bl_count[Ce + 1] += 2, ye.bl_count[Dt]--, _n -= 2;
            } while (0 < _n);
            for (Ce = Dt; Ce !== 0; Ce--) for (ze = ye.bl_count[Ce]; ze !== 0; ) ct < (ke = ye.heap[--Le]) || (Ge[2 * ke + 1] !== Ce && (ye.opt_len += (Ce - Ge[2 * ke + 1]) * Ge[2 * ke], Ge[2 * ke + 1] = Ce), ze--);
          }
        }(I, j), fe(xe, de, I.bl_count);
      }
      function w(I, j, Q) {
        var ce, Z, xe = -1, Me = j[1], Se = 0, q = 7, de = 4;
        for (Me === 0 && (q = 138, de = 3), j[2 * (Q + 1) + 1] = 65535, ce = 0; ce <= Q; ce++) Z = Me, Me = j[2 * (ce + 1) + 1], ++Se < q && Z === Me || (Se < de ? I.bl_tree[2 * Z] += Se : Z !== 0 ? (Z !== xe && I.bl_tree[2 * Z]++, I.bl_tree[2 * C]++) : Se <= 10 ? I.bl_tree[2 * k]++ : I.bl_tree[2 * M]++, xe = Z, de = (Se = 0) === Me ? (q = 138, 3) : Z === Me ? (q = 6, 3) : (q = 7, 4));
      }
      function L(I, j, Q) {
        var ce, Z, xe = -1, Me = j[1], Se = 0, q = 7, de = 4;
        for (Me === 0 && (q = 138, de = 3), ce = 0; ce <= Q; ce++) if (Z = Me, Me = j[2 * (ce + 1) + 1], !(++Se < q && Z === Me)) {
          if (Se < de) for (; N(I, Z, I.bl_tree), --Se != 0; ) ;
          else Z !== 0 ? (Z !== xe && (N(I, Z, I.bl_tree), Se--), N(I, C, I.bl_tree), G(I, Se - 3, 2)) : Se <= 10 ? (N(I, k, I.bl_tree), G(I, Se - 3, 3)) : (N(I, M, I.bl_tree), G(I, Se - 11, 7));
          xe = Z, de = (Se = 0) === Me ? (q = 138, 3) : Z === Me ? (q = 6, 3) : (q = 7, 4);
        }
      }
      c(ie);
      var A = !1;
      function E(I, j, Q, ce) {
        G(I, (d << 1) + (ce ? 1 : 0), 3), function(Z, xe, Me, Se) {
          D(Z), ve(Z, Me), ve(Z, ~Me), a.arraySet(Z.pending_buf, Z.window, xe, Me, Z.pending), Z.pending += Me;
        }(I, j, Q);
      }
      o._tr_init = function(I) {
        A || (function() {
          var j, Q, ce, Z, xe, Me = new Array(b + 1);
          for (Z = ce = 0; Z < f - 1; Z++) for (H[Z] = ce, j = 0; j < 1 << O[Z]; j++) T[ce++] = Z;
          for (T[ce - 1] = Z, Z = xe = 0; Z < 16; Z++) for (ie[Z] = xe, j = 0; j < 1 << F[Z]; j++) X[xe++] = Z;
          for (xe >>= 7; Z < y; Z++) for (ie[Z] = xe << 7, j = 0; j < 1 << F[Z] - 7; j++) X[256 + xe++] = Z;
          for (Q = 0; Q <= b; Q++) Me[Q] = 0;
          for (j = 0; j <= 143; ) oe[2 * j + 1] = 8, j++, Me[8]++;
          for (; j <= 255; ) oe[2 * j + 1] = 9, j++, Me[9]++;
          for (; j <= 279; ) oe[2 * j + 1] = 7, j++, Me[7]++;
          for (; j <= 287; ) oe[2 * j + 1] = 8, j++, Me[8]++;
          for (fe(oe, p + 1, Me), j = 0; j < y; j++) z[2 * j + 1] = 5, z[2 * j] = te(j, 5);
          ge = new be(oe, O, g + 1, p, b), K = new be(z, F, 0, y, b), re = new be(new Array(0), $, 0, v, x);
        }(), A = !0), I.l_desc = new J(I.dyn_ltree, ge), I.d_desc = new J(I.dyn_dtree, K), I.bl_desc = new J(I.bl_tree, re), I.bi_buf = 0, I.bi_valid = 0, ae(I);
      }, o._tr_stored_block = E, o._tr_flush_block = function(I, j, Q, ce) {
        var Z, xe, Me = 0;
        0 < I.level ? (I.strm.data_type === 2 && (I.strm.data_type = function(Se) {
          var q, de = 4093624447;
          for (q = 0; q <= 31; q++, de >>>= 1) if (1 & de && Se.dyn_ltree[2 * q] !== 0) return l;
          if (Se.dyn_ltree[18] !== 0 || Se.dyn_ltree[20] !== 0 || Se.dyn_ltree[26] !== 0) return u;
          for (q = 32; q < g; q++) if (Se.dyn_ltree[2 * q] !== 0) return u;
          return l;
        }(I)), U(I, I.l_desc), U(I, I.d_desc), Me = function(Se) {
          var q;
          for (w(Se, Se.dyn_ltree, Se.l_desc.max_code), w(Se, Se.dyn_dtree, Se.d_desc.max_code), U(Se, Se.bl_desc), q = v - 1; 3 <= q && Se.bl_tree[2 * ne[q] + 1] === 0; q--) ;
          return Se.opt_len += 3 * (q + 1) + 5 + 5 + 4, q;
        }(I), Z = I.opt_len + 3 + 7 >>> 3, (xe = I.static_len + 3 + 7 >>> 3) <= Z && (Z = xe)) : Z = xe = Q + 5, Q + 4 <= Z && j !== -1 ? E(I, j, Q, ce) : I.strategy === 4 || xe === Z ? (G(I, 2 + (ce ? 1 : 0), 3), Y(I, oe, z)) : (G(I, 4 + (ce ? 1 : 0), 3), function(Se, q, de, ye) {
          var Ee;
          for (G(Se, q - 257, 5), G(Se, de - 1, 5), G(Se, ye - 4, 4), Ee = 0; Ee < ye; Ee++) G(Se, Se.bl_tree[2 * ne[Ee] + 1], 3);
          L(Se, Se.dyn_ltree, q - 1), L(Se, Se.dyn_dtree, de - 1);
        }(I, I.l_desc.max_code + 1, I.d_desc.max_code + 1, Me + 1), Y(I, I.dyn_ltree, I.dyn_dtree)), ae(I), ce && D(I);
      }, o._tr_tally = function(I, j, Q) {
        return I.pending_buf[I.d_buf + 2 * I.last_lit] = j >>> 8 & 255, I.pending_buf[I.d_buf + 2 * I.last_lit + 1] = 255 & j, I.pending_buf[I.l_buf + I.last_lit] = 255 & Q, I.last_lit++, j === 0 ? I.dyn_ltree[2 * Q]++ : (I.matches++, j--, I.dyn_ltree[2 * (T[Q] + g + 1)]++, I.dyn_dtree[2 * ee(j)]++), I.last_lit === I.lit_bufsize - 1;
      }, o._tr_align = function(I) {
        G(I, 2, 3), N(I, _, oe), function(j) {
          j.bi_valid === 16 ? (ve(j, j.bi_buf), j.bi_buf = 0, j.bi_valid = 0) : 8 <= j.bi_valid && (j.pending_buf[j.pending++] = 255 & j.bi_buf, j.bi_buf >>= 8, j.bi_valid -= 8);
        }(I);
      };
    }, { "../utils/common": 41 }], 53: [function(s, r, o) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(s, r, o) {
      (function(a) {
        (function(l, u) {
          if (!l.setImmediate) {
            var c, d, f, g, p = 1, y = {}, v = !1, m = l.document, b = Object.getPrototypeOf && Object.getPrototypeOf(l);
            b = b && b.setTimeout ? b : l, c = {}.toString.call(l.process) === "[object process]" ? function(C) {
              n.nextTick(function() {
                x(C);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var C = !0, k = l.onmessage;
                return l.onmessage = function() {
                  C = !1;
                }, l.postMessage("", "*"), l.onmessage = k, C;
              }
            }() ? (g = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", _, !1) : l.attachEvent("onmessage", _), function(C) {
              l.postMessage(g + C, "*");
            }) : l.MessageChannel ? ((f = new MessageChannel()).port1.onmessage = function(C) {
              x(C.data);
            }, function(C) {
              f.port2.postMessage(C);
            }) : m && "onreadystatechange" in m.createElement("script") ? (d = m.documentElement, function(C) {
              var k = m.createElement("script");
              k.onreadystatechange = function() {
                x(C), k.onreadystatechange = null, d.removeChild(k), k = null;
              }, d.appendChild(k);
            }) : function(C) {
              setTimeout(x, 0, C);
            }, b.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var k = new Array(arguments.length - 1), M = 0; M < k.length; M++) k[M] = arguments[M + 1];
              var O = { callback: C, args: k };
              return y[p] = O, c(p), p++;
            }, b.clearImmediate = S;
          }
          function S(C) {
            delete y[C];
          }
          function x(C) {
            if (v) setTimeout(x, 0, C);
            else {
              var k = y[C];
              if (k) {
                v = !0;
                try {
                  (function(M) {
                    var O = M.callback, F = M.args;
                    switch (F.length) {
                      case 0:
                        O();
                        break;
                      case 1:
                        O(F[0]);
                        break;
                      case 2:
                        O(F[0], F[1]);
                        break;
                      case 3:
                        O(F[0], F[1], F[2]);
                        break;
                      default:
                        O.apply(u, F);
                    }
                  })(k);
                } finally {
                  S(C), v = !1;
                }
              }
            }
          }
          function _(C) {
            C.source === l && typeof C.data == "string" && C.data.indexOf(g) === 0 && x(+C.data.slice(g.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof So < "u" ? So : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Qf);
var pD = Qf.exports;
const mD = /* @__PURE__ */ fD(pD), gD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: mD
}, Symbol.toStringTag, { value: "Module" }));
export {
  wd as mountApp,
  yD as sendToComfyUI
};
