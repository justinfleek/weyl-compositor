import { H as defineStore, I as toRaw, c as computed, r as ref, J as reactive, K as defineComponent, w as watch, o as onMounted, a as createElementBlock, d as openBlock, L as withModifiers, t as createBaseVNode, C as createCommentVNode, D as normalizeClass, x as toDisplayString, A as withDirectives, F as Fragment, M as renderList, v as createTextVNode, N as vModelSelect, O as vModelText, P as vModelCheckbox, g as createBlock, u as unref, B as withCtx, n as normalizeStyle, Q as vModelRadio, E as createVNode, R as onUnmounted, S as withKeys, T as Teleport, U as createStaticVNode, V as shallowRef, W as vShow, i as inject, X as markRaw, h as resolveDynamicComponent, Y as storeToRefs, k as nextTick, p as provide, Z as createApp, _ as createPinia } from './weyl-vue-vendor.js';
import { s as script, g as ge, P as Pe } from './weyl-ui-vendor.js';
import { G as Group, M as MathUtils, V as Vector3, a as Matrix4, Q as Quaternion, b as Mesh, N as NormalBlending, A as AddEquation, S as SrcAlphaFactor, O as OneMinusSrcAlphaFactor, c as OneFactor, C as CustomBlending, d as MaxEquation, e as MinEquation, f as OneMinusDstColorFactor, g as OneMinusSrcColorFactor, h as SubtractEquation, i as SubtractiveBlending, j as AdditiveBlending, k as MultiplyBlending, l as CatmullRomCurve3, B as BufferGeometry, L as LineBasicMaterial, m as Line, n as OctahedronGeometry, o as MeshBasicMaterial, p as SphereGeometry, q as Box3, P as PlaneGeometry, D as DoubleSide, r as VideoTexture, s as LinearFilter, R as RGBAFormat, t as SRGBColorSpace, u as SVGLoader, v as Color, E as ExtrudeGeometry, w as ShapeGeometry, x as BufferAttribute, y as MeshStandardMaterial, z as MeshPhysicalMaterial, F as BackSide, H as FrontSide, I as Float32BufferAttribute, T as TubeGeometry, J as Vector2, K as TextureLoader, U as BoxGeometry, W as IcosahedronGeometry, X as TetrahedronGeometry, Y as TorusGeometry, Z as CylinderGeometry, _ as ConeGeometry, $ as InstancedMesh, a0 as DynamicDrawUsage, a1 as Euler, a2 as Scene, a3 as PerspectiveCamera, a4 as AmbientLight, a5 as DirectionalLight, a6 as WebGLRenderer, a7 as NearestFilter, a8 as SpriteMaterial, a9 as RGBELoader, aa as EXRLoader, ab as PMREMGenerator, ac as RepeatWrapping, ad as LinearMipmapLinearFilter, ae as LinearSRGBColorSpace, af as AxesHelper, ag as GridHelper, ah as EquirectangularReflectionMapping, ai as LineLoop, aj as Shape, ak as Path$1, al as ACESFilmicToneMapping, am as PCFSoftShadowMap, an as EffectComposer, ao as MeshNormalMaterial, ap as WebGLRenderTarget, aq as HalfFloatType, ar as DepthTexture, as as DepthFormat, at as UnsignedIntType, au as FloatType, av as ShaderMaterial, aw as RenderPass, ax as OutputPass, ay as BokehPass, az as SSAOPass, aA as UnrealBloomPass, aB as ShaderPass, aC as UnsignedByteType, aD as CircleGeometry, aE as CurvePath, aF as CubicBezierCurve3, aG as Text, aH as LineGeometry, aI as LineMaterial, aJ as Line2, aK as DataTexture, aL as RedFormat, aM as InstancedBufferGeometry, aN as InstancedBufferAttribute, aO as LineSegments, aP as LinearMipMapLinearFilter, aQ as ClampToEdgeWrapping, aR as RingGeometry, aS as PointLight, aT as RectAreaLight, aU as SpotLight, aV as RectAreaLightHelper, aW as DirectionalLightHelper, aX as SpotLightHelper, aY as PointLightHelper, aZ as RectAreaLightUniformsLib, a_ as CanvasTexture, a$ as GLTFLoader, b0 as DRACOLoader, b1 as MeshoptDecoder, b2 as OBJLoader, b3 as FBXLoader, b4 as ColladaLoader, b5 as AnimationMixer, b6 as LoopRepeat, b7 as LoopOnce, b8 as MeshDepthMaterial, b9 as RGBADepthPacking, ba as BoxHelper, bb as SkeletonHelper, bc as SkinnedMesh, bd as PLYLoader, be as PCDLoader, bf as Points, bg as EllipseCurve, bh as Material, bi as LineDashedMaterial, bj as Raycaster, bk as Clock, bl as OrthographicCamera, bm as THREE$1, bn as Texture, bo as TransformControls } from './weyl-three-vendor.js';
import { M as Muxer, A as ArrayBufferTarget, a as Muxer$1, b as ArrayBufferTarget$1 } from './weyl-export-vendor.js';

const PI = Math.PI;
const c1$1 = 1.70158;
const c2$1 = c1$1 * 1.525;
const c3$1 = c1$1 + 1;
const c4$1 = 2 * PI / 3;
const c5$1 = 2 * PI / 4.5;
const easings = {
  // Linear - no easing
  linear: (t) => t,
  // Sine easing
  easeInSine: (t) => 1 - Math.cos(t * PI / 2),
  easeOutSine: (t) => Math.sin(t * PI / 2),
  easeInOutSine: (t) => -(Math.cos(PI * t) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
    return (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // Circ (circular)
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (t) => c3$1 * t * t * t - c1$1 * t * t,
  easeOutBack: (t) => 1 + c3$1 * Math.pow(t - 1, 3) + c1$1 * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2$1 + 1) * 2 * t - c2$1) / 2 : (Math.pow(2 * t - 2, 2) * ((c2$1 + 1) * (t * 2 - 2) + c2$1) + 2) / 2,
  // Elastic
  easeInElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4$1);
  },
  easeOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4$1) + 1;
  },
  easeInOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) {
      return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5$1)) / 2;
    }
    return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5$1) / 2 + 1;
  },
  // Bounce
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInBounce: (t) => 1 - easings.easeOutBounce(1 - t),
  easeInOutBounce: (t) => t < 0.5 ? (1 - easings.easeOutBounce(1 - 2 * t)) / 2 : (1 + easings.easeOutBounce(2 * t - 1)) / 2
};
function getEasing(name) {
  if (name in easings) {
    return easings[name];
  }
  return easings.linear;
}

const LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
const config = {
  level: "warn",
  prefix: "[Weyl]"};
function shouldLog(level) {
  return LOG_LEVELS[level] >= LOG_LEVELS[config.level];
}
function formatMessage(level, context, message) {
  const parts = [];
  {
    parts.push(config.prefix);
  }
  if (context) {
    parts.push(`[${context}]`);
  }
  parts.push(message);
  return parts.join(" ");
}
function createLogger(context) {
  return {
    debug(message, ...args) {
      if (shouldLog("debug")) {
        console.log(formatMessage("DEBUG", context, message), ...args);
      }
    },
    info(message, ...args) {
      if (shouldLog("info")) {
        console.info(formatMessage("INFO", context, message), ...args);
      }
    },
    warn(message, ...args) {
      if (shouldLog("warn")) {
        console.warn(formatMessage("WARN", context, message), ...args);
      }
    },
    error(message, ...args) {
      if (shouldLog("error")) {
        console.error(formatMessage("ERROR", context, message), ...args);
      }
    },
    /**
     * Log with a specific level
     */
    log(level, message, ...args) {
      switch (level) {
        case "debug":
          this.debug(message, ...args);
          break;
        case "info":
          this.info(message, ...args);
          break;
        case "warn":
          this.warn(message, ...args);
          break;
        case "error":
          this.error(message, ...args);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(label) {
      if (shouldLog("debug")) {
        console.group(formatMessage("", context, label));
      }
    },
    groupEnd() {
      if (shouldLog("debug")) {
        console.groupEnd();
      }
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(data) {
      if (shouldLog("debug")) {
        console.log(formatMessage("", context, "Table:"));
        console.table(data);
      }
    },
    /**
     * Measure time for an operation
     */
    time(label) {
      if (shouldLog("debug")) {
        console.time(`${config.prefix} [${context}] ${label}`);
      }
    },
    timeEnd(label) {
      if (shouldLog("debug")) {
        console.timeEnd(`${config.prefix} [${context}] ${label}`);
      }
    }
  };
}
const storeLogger = createLogger("Store");
const engineLogger = createLogger("Engine");
const layerLogger = createLogger("Layer");
const renderLogger = createLogger("Render");
const exportLogger = createLogger("Export");

const easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
const easeOutSine = (t) => Math.sin(t * Math.PI / 2);
const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
const easeInQuad = (t) => t * t;
const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
const easeInCubic = (t) => t * t * t;
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
const easeInQuart = (t) => t * t * t * t;
const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
const easeInQuint = (t) => t * t * t * t * t;
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
const easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
const easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
const easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
const easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
const easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
const c1 = 1.70158;
const c2 = c1 * 1.525;
const c3 = c1 + 1;
const easeInBack = (t) => c3 * t * t * t - c1 * t * t;
const easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
const easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
const c4 = 2 * Math.PI / 3;
const c5 = 2 * Math.PI / 4.5;
const easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
const easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
const easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
const easeOutBounce = (t) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
const easeInBounce = (t) => 1 - easeOutBounce(1 - t);
const easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
const linear = (t) => t;
const stepStart = (t) => t === 0 ? 0 : 1;
const stepEnd = (t) => t === 1 ? 1 : 0;
const EASING_FUNCTIONS = {
  // Linear
  linear,
  // Sine
  easeInSine,
  easeOutSine,
  easeInOutSine,
  // Quad
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  // Cubic
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  // Quart
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  // Quint
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  // Expo
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  // Circ
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  // Back
  easeInBack,
  easeOutBack,
  easeInOutBack,
  // Elastic
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  // Bounce
  easeInBounce,
  easeOutBounce,
  easeInOutBounce,
  // Step
  stepStart,
  stepEnd
};
function inertia(ctx, amplitude = 0.1, frequency = 2, decay = 2) {
  const { time: time2, keyframes, value, velocity } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let nearestKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      nearestKey = keyframes[i];
      break;
    }
  }
  if (!nearestKey) return value;
  const keyTime = nearestKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const vel = typeof velocity === "number" ? velocity : velocity[0];
  const val = typeof value === "number" ? value : value[0];
  const oscillation = vel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  if (typeof value === "number") {
    return val + oscillation;
  }
  return value.map((v, i) => {
    const componentVel = velocity[i] || 0;
    return v + componentVel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  });
}
function bounce(ctx, elasticity = 0.7, gravity = 4e3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  let bounceTime = t;
  let bounceHeight = 1;
  let totalBounces = 0;
  const maxBounces = 10;
  while (bounceTime > 0 && totalBounces < maxBounces) {
    const bounceDuration2 = Math.sqrt(2 * bounceHeight / gravity);
    if (bounceTime < bounceDuration2 * 2) {
      break;
    }
    bounceTime -= bounceDuration2 * 2;
    bounceHeight *= elasticity * elasticity;
    totalBounces++;
  }
  const bounceDuration = Math.sqrt(2 * bounceHeight / gravity);
  const bounceT = bounceTime / (bounceDuration * 2);
  const bounceOffset = bounceHeight * 4 * bounceT * (1 - bounceT);
  if (typeof value === "number") {
    return value - bounceOffset * (1 - elasticity);
  }
  return value.map((v) => v - bounceOffset * (1 - elasticity));
}
function elastic(ctx, amplitude = 1, period = 0.3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const s = period / 4;
  const decay = Math.pow(2, -10 * t);
  const oscillation = decay * Math.sin((t - s) * (2 * Math.PI) / period);
  if (typeof value === "number") {
    return value + amplitude * oscillation;
  }
  return value.map((v) => v + amplitude * oscillation);
}
function repeatAfter(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const startIdx = numKeyframes > 0 ? Math.max(0, keyframes.length - numKeyframes) : 0;
  const startKey = keyframes[startIdx];
  const endKey = keyframes[keyframes.length - 1];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 <= endTime) return ctx.value;
  const elapsed = time2 - endTime;
  switch (type) {
    case "cycle": {
      const cycleTime = startTime + elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? 1 - cycleProgress : cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = startTime + elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(endKey.value, startKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value + velocity * elapsed;
      }
      return ctx.value.map((v, i) => v + velocity[i] * elapsed);
    }
  }
}
function repeatBefore(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const endIdx = numKeyframes > 0 ? Math.min(keyframes.length - 1, numKeyframes - 1) : keyframes.length - 1;
  const startKey = keyframes[0];
  const endKey = keyframes[endIdx];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 >= startTime) return ctx.value;
  const elapsed = startTime - time2;
  switch (type) {
    case "cycle": {
      const cycleTime = endTime - elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? cycleProgress : 1 - cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = endTime - elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(startKey.value, endKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value - velocity * elapsed;
      }
      return ctx.value.map((v, i) => v - velocity[i] * elapsed);
    }
  }
}
function jitter(ctx, frequency = 5, amplitude = 50, octaves = 1, amplitudeMultiplier = 0.5, time2) {
  const t = time2 ?? ctx.time;
  const { value } = ctx;
  const noise = (seed, t2) => {
    let result = 0;
    let amp = 1;
    let freq = 1;
    for (let i = 0; i < octaves; i++) {
      result += amp * Math.sin(t2 * frequency * freq * Math.PI * 2 + seed * 1e3);
      result += amp * 0.5 * Math.sin(t2 * frequency * freq * Math.PI * 2 * 1.5 + seed * 500);
      amp *= amplitudeMultiplier;
      freq *= 2;
    }
    return result / (1 + (octaves - 1) * amplitudeMultiplier);
  };
  if (typeof value === "number") {
    return value + noise(0, t) * amplitude;
  }
  return value.map((v, i) => v + noise(i, t) * amplitude);
}
const timeExpressions = {
  /**
   * Linear time ramp
   */
  timeRamp(startTime, endTime, startValue, endValue, time2) {
    if (time2 <= startTime) return startValue;
    if (time2 >= endTime) return endValue;
    const t = (time2 - startTime) / (endTime - startTime);
    return startValue + (endValue - startValue) * t;
  },
  /**
   * Periodic function (loops every period seconds)
   */
  periodic(time2, period) {
    return time2 % period / period;
  },
  /**
   * Sawtooth wave
   */
  sawtooth(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * 2 * (t - Math.floor(t + 0.5));
  },
  /**
   * Triangle wave
   */
  triangle(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1);
  },
  /**
   * Square wave
   */
  square(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (t - Math.floor(t) < 0.5 ? 1 : -1);
  },
  /**
   * Sine wave
   */
  sine(time2, frequency, amplitude = 1, phase = 0) {
    return amplitude * Math.sin(2 * Math.PI * frequency * time2 + phase);
  },
  /**
   * Pulse (duty cycle controlled square)
   */
  pulse(time2, frequency, dutyCycle = 0.5, amplitude = 1) {
    const t = time2 * frequency % 1;
    return amplitude * (t < dutyCycle ? 1 : 0);
  }
};
const mathExpressions = {
  /**
   * Linear interpolation
   */
  lerp(a, b, t) {
    return a + (b - a) * t;
  },
  /**
   * Clamp value between min and max
   */
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  },
  /**
   * Map value from one range to another
   */
  map(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  },
  /**
   * Normalized value (0-1) based on range
   */
  normalize(value, min, max) {
    return (value - min) / (max - min);
  },
  /**
   * Smooth step (Hermite interpolation)
   */
  smoothstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  },
  /**
   * Smoother step (Ken Perlin's improved version)
   */
  smootherstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * t * (t * (t * 6 - 15) + 10);
  },
  /**
   * Modulo with support for negative numbers
   */
  mod(a, b) {
    return (a % b + b) % b;
  },
  /**
   * Distance between two 2D points
   */
  distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  },
  /**
   * Angle between two 2D points (in radians)
   */
  angleBetween(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  },
  /**
   * Convert degrees to radians
   */
  degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  },
  /**
   * Convert radians to degrees
   */
  radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  },
  /**
   * Random number with seed (deterministic)
   */
  seedRandom(seed, min = 0, max = 1) {
    const x = Math.sin(seed * 12.9898) * 43758.5453;
    const rand = x - Math.floor(x);
    return min + rand * (max - min);
  },
  /**
   * Gaussian random (normal distribution)
   */
  gaussRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }
};
function interpolateAtTime(keyframes, time2, fps) {
  const frame = time2 * fps;
  let before = null;
  let after = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      before = kf;
    } else if (!after) {
      after = kf;
      break;
    }
  }
  if (!before) return keyframes[0].value;
  if (!after) return before.value;
  const t = (frame - before.frame) / (after.frame - before.frame);
  const easedT = applyEasing$2(t, before.interpolation);
  return lerpValues(before.value, after.value, easedT);
}
function applyEasing$2(t, interpolation) {
  const fn = EASING_FUNCTIONS[interpolation];
  return fn ? fn(t) : t;
}
function lerpValues(a, b, t) {
  if (typeof a === "number" && typeof b === "number") {
    return a + (b - a) * t;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + (b[i] - v) * t);
  }
  return a;
}
function subtractValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v - b[i]);
  }
  return 0;
}
function addValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + b[i]);
  }
  return a;
}
function scaleValue(v, s) {
  if (typeof v === "number") {
    return v * s;
  }
  if (Array.isArray(v)) {
    return v.map((x) => x * s);
  }
  return 0;
}
function evaluateExpression(expression, ctx) {
  if (!expression.enabled) return ctx.value;
  switch (expression.type) {
    case "preset":
      return evaluatePreset(expression.name, ctx, expression.params);
    case "function":
      return evaluateFunction(expression.name, ctx, expression.params);
    default:
      return ctx.value;
  }
}
function evaluatePreset(name, ctx, params) {
  switch (name) {
    case "inertia":
      return inertia(ctx, params.amplitude, params.frequency, params.decay);
    case "bounce":
      return bounce(ctx, params.elasticity, params.gravity);
    case "elastic":
      return elastic(ctx, params.amplitude, params.period);
    case "jitter":
      return jitter(ctx, params.frequency, params.amplitude, params.octaves);
    case "repeatAfter":
      return repeatAfter(ctx, params.type, params.numKeyframes);
    case "repeatBefore":
      return repeatBefore(ctx, params.type, params.numKeyframes);
    default:
      return ctx.value;
  }
}
function evaluateFunction(name, ctx, params) {
  if (name in timeExpressions) {
    const fn = timeExpressions[name];
    return fn(ctx.time, ...Object.values(params));
  }
  if (name in mathExpressions) {
    const fn = mathExpressions[name];
    const val = typeof ctx.value === "number" ? ctx.value : ctx.value[0];
    return fn(val, ...Object.values(params));
  }
  return ctx.value;
}
const EXPRESSION_PRESETS = {
  // Motion presets
  inertiaLight: {
    type: "preset",
    name: "inertia",
    params: { amplitude: 0.05, frequency: 3, decay: 3 },
    enabled: true
  },
  inertiaHeavy: {
    type: "preset",
    name: "inertia",
    params: { amplitude: 0.15, frequency: 1.5, decay: 1.5 },
    enabled: true
  },
  bounceGentle: {
    type: "preset",
    name: "bounce",
    params: { elasticity: 0.6, gravity: 3e3 },
    enabled: true
  },
  bounceFirm: {
    type: "preset",
    name: "bounce",
    params: { elasticity: 0.8, gravity: 5e3 },
    enabled: true
  },
  elasticSnappy: {
    type: "preset",
    name: "elastic",
    params: { amplitude: 1, period: 0.2 },
    enabled: true
  },
  elasticLoose: {
    type: "preset",
    name: "elastic",
    params: { amplitude: 1.5, period: 0.5 },
    enabled: true
  },
  // Jitter presets
  jitterSubtle: {
    type: "preset",
    name: "jitter",
    params: { frequency: 2, amplitude: 10, octaves: 1 },
    enabled: true
  },
  jitterModerate: {
    type: "preset",
    name: "jitter",
    params: { frequency: 4, amplitude: 30, octaves: 2 },
    enabled: true
  },
  jitterIntense: {
    type: "preset",
    name: "jitter",
    params: { frequency: 8, amplitude: 50, octaves: 3 },
    enabled: true
  },
  // Repeat presets
  repeatCycle: {
    type: "preset",
    name: "repeatAfter",
    params: { type: "cycle", numKeyframes: 0 },
    enabled: true
  },
  repeatPingpong: {
    type: "preset",
    name: "repeatAfter",
    params: { type: "pingpong", numKeyframes: 0 },
    enabled: true
  },
  repeatOffset: {
    type: "preset",
    name: "repeatAfter",
    params: { type: "offset", numKeyframes: 0 },
    enabled: true
  }
};

const logger$9 = createLogger("PathMorphing");
const DEFAULT_MORPH_CONFIG = {
  pointMatchingStrategy: "subdivide-shorter",
  correspondenceMethod: "nearest-rotation"
};
function clonePoint$1(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex$1(v) {
  return {
    point: clonePoint$1(v.point),
    inHandle: clonePoint$1(v.inHandle),
    outHandle: clonePoint$1(v.outHandle)
  };
}
function clonePath$1(path) {
  return {
    vertices: path.vertices.map(cloneVertex$1),
    closed: path.closed
  };
}
function distance$2(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerp$1(a, b, t) {
  return a + (b - a) * t;
}
function lerpPoint$1(a, b, t) {
  return {
    x: lerp$1(a.x, b.x, t),
    y: lerp$1(a.y, b.y, t)
  };
}
function addPoints$1(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints$1(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint$2(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function cubicBezierPoint$1(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function splitCubicBezier$1(p0, p1, p2, p3, t) {
  const q0 = lerpPoint$1(p0, p1, t);
  const q1 = lerpPoint$1(p1, p2, t);
  const q2 = lerpPoint$1(p2, p3, t);
  const r0 = lerpPoint$1(q0, q1, t);
  const r1 = lerpPoint$1(q1, q2, t);
  const s = lerpPoint$1(r0, r1, t);
  return [
    [p0, q0, r0, s],
    // Left segment
    [s, r1, q2, p3]
    // Right segment
  ];
}
function estimateSegmentLength(p0, p1, p2, p3, samples = 10) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= samples; i++) {
    const t = i / samples;
    const curr = cubicBezierPoint$1(p0, p1, p2, p3, t);
    length += distance$2(prev, curr);
    prev = curr;
  }
  return length;
}
function getSegmentControlPoints(path, segmentIndex) {
  const v0 = path.vertices[segmentIndex];
  const v1 = path.vertices[(segmentIndex + 1) % path.vertices.length];
  return {
    p0: v0.point,
    p1: addPoints$1(v0.point, v0.outHandle),
    p2: addPoints$1(v1.point, v1.inHandle),
    p3: v1.point
  };
}
function getSegmentLengths(path, samplesPerSegment = 10) {
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  const lengths = [];
  for (let i = 0; i < numSegments; i++) {
    const { p0, p1, p2, p3 } = getSegmentControlPoints(path, i);
    lengths.push(estimateSegmentLength(p0, p1, p2, p3, samplesPerSegment));
  }
  return lengths;
}
function getPointAtArcLength(path, targetLength, segmentLengths) {
  let accumulated = 0;
  for (let i = 0; i < segmentLengths.length; i++) {
    const segmentLength = segmentLengths[i];
    if (accumulated + segmentLength >= targetLength || i === segmentLengths.length - 1) {
      const localT = segmentLength > 0 ? (targetLength - accumulated) / segmentLength : 0;
      const { p0, p1, p2, p3 } = getSegmentControlPoints(path, i);
      const point = cubicBezierPoint$1(p0, p1, p2, p3, Math.max(0, Math.min(1, localT)));
      return { point, segmentIndex: i, t: localT };
    }
    accumulated += segmentLength;
  }
  const lastVertex = path.vertices[path.vertices.length - 1];
  return {
    point: clonePoint$1(lastVertex.point),
    segmentIndex: segmentLengths.length - 1,
    t: 1
  };
}
function subdivideSegmentAt(path, segmentIndex, t) {
  const result = clonePath$1(path);
  const v0 = result.vertices[segmentIndex];
  const nextIdx = (segmentIndex + 1) % result.vertices.length;
  const v1 = result.vertices[nextIdx];
  const p0 = v0.point;
  const p1 = addPoints$1(v0.point, v0.outHandle);
  const p2 = addPoints$1(v1.point, v1.inHandle);
  const p3 = v1.point;
  const [left, right] = splitCubicBezier$1(p0, p1, p2, p3, t);
  v0.outHandle = subtractPoints$1(left[1], left[0]);
  const newVertex = {
    point: clonePoint$1(left[3]),
    inHandle: subtractPoints$1(left[2], left[3]),
    outHandle: subtractPoints$1(right[1], right[0])
  };
  v1.inHandle = subtractPoints$1(right[2], right[3]);
  result.vertices.splice(segmentIndex + 1, 0, newVertex);
  return result;
}
function subdivideToVertexCount(path, targetCount) {
  if (path.vertices.length >= targetCount) {
    return clonePath$1(path);
  }
  let current = clonePath$1(path);
  const segmentLengths = getSegmentLengths(current);
  segmentLengths.reduce((sum, l) => sum + l, 0);
  while (current.vertices.length < targetCount) {
    const currentLengths = getSegmentLengths(current);
    let maxLength = 0;
    let maxIndex = 0;
    for (let i = 0; i < currentLengths.length; i++) {
      if (currentLengths[i] > maxLength) {
        maxLength = currentLengths[i];
        maxIndex = i;
      }
    }
    current = subdivideSegmentAt(current, maxIndex, 0.5);
  }
  return current;
}
function resamplePath(path, vertexCount) {
  if (vertexCount < 2) {
    return clonePath$1(path);
  }
  const segmentLengths = getSegmentLengths(path);
  const totalLength = segmentLengths.reduce((sum, l) => sum + l, 0);
  if (totalLength === 0) {
    const vertices2 = [];
    for (let i = 0; i < vertexCount; i++) {
      const srcIdx = Math.floor(i * path.vertices.length / vertexCount);
      vertices2.push(cloneVertex$1(path.vertices[srcIdx]));
    }
    return { vertices: vertices2, closed: path.closed };
  }
  const spacing = totalLength / (path.closed ? vertexCount : vertexCount - 1);
  const vertices = [];
  for (let i = 0; i < vertexCount; i++) {
    const targetLength = i * spacing;
    const { point } = getPointAtArcLength(path, targetLength, segmentLengths);
    const prevLength = Math.max(0, targetLength - spacing * 0.33);
    const nextLength = Math.min(totalLength, targetLength + spacing * 0.33);
    const prevPoint = getPointAtArcLength(path, prevLength, segmentLengths).point;
    const nextPoint = getPointAtArcLength(path, nextLength, segmentLengths).point;
    const tangent = {
      x: (nextPoint.x - prevPoint.x) * 0.5,
      y: (nextPoint.y - prevPoint.y) * 0.5
    };
    const handleScale = 0.33;
    vertices.push({
      point: clonePoint$1(point),
      inHandle: scalePoint$2(tangent, -handleScale),
      outHandle: scalePoint$2(tangent, handleScale)
    });
  }
  return { vertices, closed: path.closed };
}
function calculateTravelDistance(source, target, rotationOffset = 0, reversed = false) {
  const n = source.vertices.length;
  let total = 0;
  for (let i = 0; i < n; i++) {
    const srcIdx = i;
    let tgtIdx = (i + rotationOffset + n) % n;
    if (reversed) {
      tgtIdx = (n - 1 - i + rotationOffset + n) % n;
    }
    total += distance$2(source.vertices[srcIdx].point, target.vertices[tgtIdx].point);
  }
  return total;
}
function findOptimalRotation(source, target) {
  const n = source.vertices.length;
  let bestOffset = 0;
  let bestReversed = false;
  let bestDistance = Infinity;
  for (let offset = 0; offset < n; offset++) {
    const dist = calculateTravelDistance(source, target, offset, false);
    if (dist < bestDistance) {
      bestDistance = dist;
      bestOffset = offset;
      bestReversed = false;
    }
    if (source.closed && target.closed) {
      const distRev = calculateTravelDistance(source, target, offset, true);
      if (distRev < bestDistance) {
        bestDistance = distRev;
        bestOffset = offset;
        bestReversed = true;
      }
    }
  }
  return { offset: bestOffset, reversed: bestReversed };
}
function rotateVertices(path, offset, reverse = false) {
  const n = path.vertices.length;
  const vertices = [];
  for (let i = 0; i < n; i++) {
    let srcIdx = (i + offset + n) % n;
    if (reverse) {
      srcIdx = (n - 1 - i + offset + n) % n;
    }
    const srcVertex = path.vertices[srcIdx];
    if (reverse) {
      vertices.push({
        point: clonePoint$1(srcVertex.point),
        inHandle: clonePoint$1(srcVertex.outHandle),
        outHandle: clonePoint$1(srcVertex.inHandle)
      });
    } else {
      vertices.push(cloneVertex$1(srcVertex));
    }
  }
  return { vertices, closed: path.closed };
}
function prepareMorphPaths(source, target, config = {}) {
  const cfg = { ...DEFAULT_MORPH_CONFIG, ...config };
  if (source.vertices.length === 0 || target.vertices.length === 0) {
    logger$9.warn("Cannot morph empty paths");
    return {
      source: clonePath$1(source),
      target: clonePath$1(target),
      rotationOffset: 0,
      reversed: false
    };
  }
  let preparedSource = clonePath$1(source);
  let preparedTarget = clonePath$1(target);
  const sourceCount = preparedSource.vertices.length;
  const targetCount = preparedTarget.vertices.length;
  if (sourceCount !== targetCount) {
    switch (cfg.pointMatchingStrategy) {
      case "subdivide-shorter":
        if (sourceCount < targetCount) {
          preparedSource = subdivideToVertexCount(preparedSource, targetCount);
        } else {
          preparedTarget = subdivideToVertexCount(preparedTarget, sourceCount);
        }
        break;
      case "subdivide-both": {
        const maxCount = Math.max(sourceCount, targetCount);
        preparedSource = subdivideToVertexCount(preparedSource, maxCount);
        preparedTarget = subdivideToVertexCount(preparedTarget, maxCount);
        break;
      }
      case "resample": {
        const count = cfg.resampleCount ?? Math.max(sourceCount, targetCount);
        preparedSource = resamplePath(preparedSource, count);
        preparedTarget = resamplePath(preparedTarget, count);
        break;
      }
    }
  }
  let rotationOffset = 0;
  let reversed = false;
  if (preparedSource.closed && preparedTarget.closed) {
    switch (cfg.correspondenceMethod) {
      case "nearest-rotation":
      case "nearest-distance": {
        const result = findOptimalRotation(preparedSource, preparedTarget);
        rotationOffset = result.offset;
        reversed = result.reversed;
        break;
      }
    }
  }
  if (rotationOffset !== 0 || reversed) {
    preparedTarget = rotateVertices(preparedTarget, rotationOffset, reversed);
  }
  return {
    source: preparedSource,
    target: preparedTarget,
    rotationOffset,
    reversed
  };
}
function morphPaths(source, target, t) {
  t = Math.max(0, Math.min(1, t));
  if (t === 0) return clonePath$1(source);
  if (t === 1) return clonePath$1(target);
  if (source.vertices.length !== target.vertices.length) {
    logger$9.warn("Paths have different vertex counts - use prepareMorphPaths() first");
    const count = Math.min(source.vertices.length, target.vertices.length);
    source = { vertices: source.vertices.slice(0, count), closed: source.closed };
    target = { vertices: target.vertices.slice(0, count), closed: target.closed };
  }
  const vertices = [];
  for (let i = 0; i < source.vertices.length; i++) {
    const srcV = source.vertices[i];
    const tgtV = target.vertices[i];
    vertices.push({
      point: lerpPoint$1(srcV.point, tgtV.point, t),
      inHandle: lerpPoint$1(srcV.inHandle, tgtV.inHandle, t),
      outHandle: lerpPoint$1(srcV.outHandle, tgtV.outHandle, t)
    });
  }
  return { vertices, closed: source.closed };
}
function isBezierPath(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const obj = value;
  if (!Array.isArray(obj.vertices) || typeof obj.closed !== "boolean") {
    return false;
  }
  if (obj.vertices.length > 0) {
    const v = obj.vertices[0];
    if (typeof v !== "object" || v === null) return false;
    if (typeof v.point?.x !== "number") return false;
    if (typeof v.point?.y !== "number") return false;
  }
  return true;
}

class BezierCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 500;
  /**
   * Generate cache key from bezier parameters
   * Uses fixed precision to avoid floating point key variations
   */
  makeKey(outHandle, inHandle, frameDuration, valueDelta) {
    const round = (n) => Math.round(n * 1e4);
    return `${round(outHandle.frame)},${round(outHandle.value)},${round(inHandle.frame)},${round(inHandle.value)},${round(frameDuration)},${round(valueDelta)}`;
  }
  /**
   * Get cached normalized bezier or compute and cache it
   */
  get(outHandle, inHandle, frameDuration, valueDelta) {
    const key = this.makeKey(outHandle, inHandle, frameDuration, valueDelta);
    const cached = this.cache.get(key);
    if (cached) {
      this.cache.delete(key);
      this.cache.set(key, cached);
      return cached;
    }
    const x1 = frameDuration > 0 ? Math.abs(outHandle.frame) / frameDuration : 0.33;
    const y1 = valueDelta !== 0 ? outHandle.value / valueDelta : 0.33;
    const x2 = frameDuration > 0 ? 1 - Math.abs(inHandle.frame) / frameDuration : 0.67;
    const y2 = valueDelta !== 0 ? 1 - inHandle.value / valueDelta : 0.67;
    const normalized = { x1, y1, x2, y2 };
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, normalized);
    return normalized;
  }
  /**
   * Clear the cache (call on project load)
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const bezierCache = new BezierCache();
function findKeyframeIndex(keyframes, frame) {
  let low = 0;
  let high = keyframes.length - 2;
  while (low <= high) {
    const mid = low + high >>> 1;
    const midFrame = keyframes[mid].frame;
    const nextFrame = keyframes[mid + 1].frame;
    if (frame >= midFrame && frame <= nextFrame) {
      return mid;
    } else if (frame < midFrame) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return Math.max(0, Math.min(low, keyframes.length - 2));
}
function getValueDelta(v1, v2) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v2 - v1;
  }
  if (typeof v1 === "object" && v1 !== null && "x" in v1 && "y" in v1 && typeof v2 === "object" && v2 !== null && "x" in v2 && "y" in v2) {
    const dx = v2.x - v1.x;
    const dy = v2.y - v1.y;
    return Math.sqrt(dx * dx + dy * dy) || 1;
  }
  return 1;
}
function interpolateProperty(property, frame, fps = 30, layerId = "") {
  let value;
  if (!property.animated || property.keyframes.length === 0) {
    value = property.value;
  } else {
    const keyframes = property.keyframes;
    if (frame <= keyframes[0].frame) {
      value = keyframes[0].value;
    } else if (frame >= keyframes[keyframes.length - 1].frame) {
      value = keyframes[keyframes.length - 1].value;
    } else {
      const idx = findKeyframeIndex(keyframes, frame);
      const k1 = keyframes[idx];
      const k2 = keyframes[idx + 1];
      const duration = k2.frame - k1.frame;
      const elapsed = frame - k1.frame;
      let t = duration > 0 ? elapsed / duration : 0;
      const interpolation = k1.interpolation || "linear";
      if (interpolation === "hold") {
        value = k1.value;
      } else {
        if (interpolation === "bezier") {
          const valueDelta = getValueDelta(k1.value, k2.value);
          t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
        } else if (interpolation !== "linear" && interpolation in easings) {
          const easingFn = getEasing(interpolation);
          t = easingFn(t);
        } else if (interpolation !== "linear") {
          renderLogger.warn(`Unknown interpolation type: ${interpolation}, using linear`);
        }
        value = interpolateValue$1(k1.value, k2.value, t);
      }
    }
  }
  if (property.expression?.enabled) {
    value = applyPropertyExpression(property, value, frame, fps);
  }
  return value;
}
function applyPropertyExpression(property, value, frame, fps, layerId) {
  const expr = property.expression;
  if (!expr || !expr.enabled) return value;
  const time = frame / fps;
  const velocity = calculateVelocity(property, frame, fps);
  const ctx = {
    time,
    fps,
    value,
    velocity,
    keyframes: property.keyframes
  };
  const expression = {
    type: expr.type,
    name: expr.name,
    params: expr.params,
    enabled: expr.enabled
  };
  const result = evaluateExpression(expression, ctx);
  return result;
}
function calculateVelocity(property, frame, fps) {
  const delta = 0.5;
  const valueBefore = interpolatePropertyBase(property, frame - delta);
  const valueAfter = interpolatePropertyBase(property, frame + delta);
  if (typeof valueBefore === "number" && typeof valueAfter === "number") {
    return (valueAfter - valueBefore) * fps;
  }
  if (typeof valueBefore === "object" && typeof valueAfter === "object") {
    const vb = valueBefore;
    const va = valueAfter;
    if ("x" in vb && "y" in vb) {
      const result = [(va.x - vb.x) * fps, (va.y - vb.y) * fps];
      if ("z" in vb && "z" in va) {
        result.push((va.z - vb.z) * fps);
      }
      return result;
    }
  }
  return 0;
}
function interpolatePropertyBase(property, frame) {
  if (!property.animated || property.keyframes.length === 0) {
    return property.value;
  }
  const keyframes = property.keyframes;
  if (frame <= keyframes[0].frame) {
    return keyframes[0].value;
  }
  if (frame >= keyframes[keyframes.length - 1].frame) {
    return keyframes[keyframes.length - 1].value;
  }
  const idx = findKeyframeIndex(keyframes, frame);
  const k1 = keyframes[idx];
  const k2 = keyframes[idx + 1];
  const duration = k2.frame - k1.frame;
  const elapsed = frame - k1.frame;
  let t = duration > 0 ? elapsed / duration : 0;
  const interpolation = k1.interpolation || "linear";
  if (interpolation === "hold") {
    return k1.value;
  } else if (interpolation === "bezier") {
    const valueDelta = getValueDelta(k1.value, k2.value);
    t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
  } else if (interpolation !== "linear" && interpolation in easings) {
    const easingFn = getEasing(interpolation);
    t = easingFn(t);
  }
  return interpolateValue$1(k1.value, k2.value, t);
}
function cubicBezierEasing(t, outHandle, inHandle, frameDuration = 1, valueDelta = 1) {
  if (!outHandle.enabled && !inHandle.enabled) {
    return t;
  }
  const { x1, y1, x2, y2 } = bezierCache.get(outHandle, inHandle, frameDuration, valueDelta);
  let guessT = t;
  const EPSILON = 1e-6;
  const MAX_ITERATIONS = 8;
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const currentX = bezierPoint(guessT, 0, x1, x2, 1);
    const error = currentX - t;
    if (Math.abs(error) < EPSILON) break;
    const currentSlope = bezierDerivative(guessT, 0, x1, x2, 1);
    if (Math.abs(currentSlope) < EPSILON) break;
    guessT -= error / currentSlope;
    guessT = Math.max(0, Math.min(1, guessT));
  }
  return bezierPoint(guessT, 0, y1, y2, 1);
}
function bezierPoint(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
}
function bezierDerivative(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
}
function interpolateValue$1(v1, v2, t) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v1 + (v2 - v1) * t;
  }
  if (typeof v1 === "object" && v1 !== null && typeof v2 === "object" && v2 !== null && "x" in v1 && "y" in v1 && "x" in v2 && "y" in v2) {
    const val1 = v1;
    const val2 = v2;
    const result = {
      x: val1.x + (val2.x - val1.x) * t,
      y: val1.y + (val2.y - val1.y) * t
    };
    if ("z" in val1 && "z" in val2) {
      result.z = val1.z + (val2.z - val1.z) * t;
    } else if ("z" in val1) {
      result.z = val1.z * (1 - t);
    } else if ("z" in val2) {
      result.z = val2.z * t;
    }
    return result;
  }
  if (typeof v1 === "string" && typeof v2 === "string" && v1.startsWith("#") && v2.startsWith("#")) {
    return interpolateColor(v1, v2, t);
  }
  if (isBezierPath(v1) && isBezierPath(v2)) {
    return interpolatePath(v1, v2, t);
  }
  return t < 0.5 ? v1 : v2;
}
function interpolateColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);
  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
const pathMorphCache = /* @__PURE__ */ new Map();
const PATH_MORPH_CACHE_MAX = 100;
function hashBezierPath(path) {
  const v = path.vertices;
  if (v.length === 0) return "empty";
  const first = v[0];
  const last = v[v.length - 1];
  return `${v.length}_${first.point.x.toFixed(1)}_${first.point.y.toFixed(1)}_${last.point.x.toFixed(1)}_${last.point.y.toFixed(1)}_${path.closed ? "c" : "o"}`;
}
function interpolatePath(p1, p2, t) {
  if (t <= 0) return p1;
  if (t >= 1) return p2;
  const key = `${hashBezierPath(p1)}|${hashBezierPath(p2)}`;
  let prepared = pathMorphCache.get(key);
  if (!prepared) {
    prepared = prepareMorphPaths(p1, p2);
    if (pathMorphCache.size >= PATH_MORPH_CACHE_MAX) {
      const firstKey = pathMorphCache.keys().next().value;
      if (firstKey) pathMorphCache.delete(firstKey);
    }
    pathMorphCache.set(key, prepared);
  }
  return morphPaths(prepared.source, prepared.target, t);
}
const EASING_PRESETS_NORMALIZED = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
const EASING_PRESETS = EASING_PRESETS_NORMALIZED;
function getBezierCurvePointNormalized(t, outHandle, inHandle) {
  const x1 = outHandle.x;
  const y1 = outHandle.y;
  const x2 = 1 - inHandle.x;
  const y2 = 1 - inHandle.y;
  return {
    x: bezierPoint(t, 0, x1, x2, 1),
    y: bezierPoint(t, 0, y1, y2, 1)
  };
}
function applyEasing$1(ratio, preset) {
  const t = Math.max(0, Math.min(1, ratio));
  const point = getBezierCurvePointNormalized(t, preset.outHandle, preset.inHandle);
  return point.y;
}

function getFeatureAtFrame(analysis, feature, frame) {
  const clampedFrame = Math.max(0, Math.min(frame, analysis.frameCount - 1));
  switch (feature) {
    case "amplitude":
      return analysis.amplitudeEnvelope[clampedFrame] ?? 0;
    case "rms":
      return analysis.rmsEnergy[clampedFrame] ?? 0;
    case "spectralCentroid":
      return analysis.spectralCentroid[clampedFrame] ?? 0;
    case "sub":
      return analysis.frequencyBands.sub[clampedFrame] ?? 0;
    case "bass":
      return analysis.frequencyBands.bass[clampedFrame] ?? 0;
    case "lowMid":
      return analysis.frequencyBands.lowMid[clampedFrame] ?? 0;
    case "mid":
      return analysis.frequencyBands.mid[clampedFrame] ?? 0;
    case "highMid":
      return analysis.frequencyBands.highMid[clampedFrame] ?? 0;
    case "high":
      return analysis.frequencyBands.high[clampedFrame] ?? 0;
    case "onsets":
      return analysis.onsets.includes(clampedFrame) ? 1 : 0;
    case "spectralFlux":
      return analysis.spectralFlux?.[clampedFrame] ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return analysis.zeroCrossingRate?.[clampedFrame] ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return analysis.spectralRolloff?.[clampedFrame] ?? 0;
    case "spectralFlatness":
    case "flatness":
      return analysis.spectralFlatness?.[clampedFrame] ?? 0;
    case "chromaEnergy":
      return analysis.chromaFeatures?.chromaEnergy[clampedFrame] ?? 0;
    case "chromaC":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[0] ?? 0;
    case "chromaCs":
    case "chromaDb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[1] ?? 0;
    case "chromaD":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[2] ?? 0;
    case "chromaDs":
    case "chromaEb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[3] ?? 0;
    case "chromaE":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[4] ?? 0;
    case "chromaF":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[5] ?? 0;
    case "chromaFs":
    case "chromaGb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[6] ?? 0;
    case "chromaG":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[7] ?? 0;
    case "chromaGs":
    case "chromaAb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[8] ?? 0;
    case "chromaA":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[9] ?? 0;
    case "chromaAs":
    case "chromaBb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[10] ?? 0;
    case "chromaB":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[11] ?? 0;
    default:
      return 0;
  }
}
function detectPeaks(weights, config) {
  const { threshold, minPeaksDistance, multiply } = config;
  const amplified = weights.map((w) => Math.min(1, w * multiply));
  const rawPeaks = [];
  for (let i = 1; i < amplified.length - 1; i++) {
    const prev = amplified[i - 1];
    const curr = amplified[i];
    const next = amplified[i + 1];
    if (curr > prev && curr > next && curr >= threshold) {
      rawPeaks.push({ index: i, value: curr });
    }
  }
  const filteredPeaks = [];
  for (const peak of rawPeaks) {
    const recentPeakIndex = filteredPeaks.findIndex(
      (p) => Math.abs(p.index - peak.index) < minPeaksDistance
    );
    if (recentPeakIndex === -1) {
      filteredPeaks.push(peak);
    } else {
      if (peak.value > filteredPeaks[recentPeakIndex].value) {
        filteredPeaks[recentPeakIndex] = peak;
      }
    }
  }
  filteredPeaks.sort((a, b) => a.index - b.index);
  const alternating = new Array(weights.length).fill(0);
  let currentState = 0;
  for (let i = 0; i < weights.length; i++) {
    const isPeak = filteredPeaks.some((p) => p.index === i);
    if (isPeak) {
      currentState = 1 - currentState;
    }
    alternating[i] = currentState;
  }
  return {
    indices: filteredPeaks.map((p) => p.index),
    values: filteredPeaks.map((p) => p.value),
    count: filteredPeaks.length,
    alternating
  };
}
function isBeatAtFrame(analysis, frame) {
  return analysis.onsets.includes(frame);
}
function isPeakAtFrame(peaks, frame) {
  return peaks.indices.includes(frame);
}

/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2024 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
// these __PURE__ comments help uglifyjs with dead code removal
//
const SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);
const F2 = 0.5 * (SQRT3 - 1.0);
const G2 = (3.0 - SQRT3) / 6.0;
const F3 = 1.0 / 3.0;
const G3 = 1.0 / 6.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x) => Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
    -1, 1,
    1, -1,
    -1, -1,
    1, 0,
    -1, 0,
    1, 0,
    -1, 0,
    0, 1,
    0, -1,
    0, 1,
    0, -1]);
// double seems to be faster than single or int's
// probably because most operations are in double precision
const grad3 = /*#__PURE__*/ new Float64Array([1, 1, 0,
    -1, 1, 0,
    1, -1, 0,
    -1, -1, 0,
    1, 0, 1,
    -1, 0, 1,
    1, 0, -1,
    -1, 0, -1,
    0, 1, 1,
    0, -1, 1,
    0, 1, -1,
    0, -1, -1]);
/**
 * Creates a 2D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction2D}
 */
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
/**
 * Creates a 3D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction3D}
 */
function createNoise3D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these seems to yield a speedup of over 15%
    const permGrad3x = new Float64Array(perm).map(v => grad3[(v % 12) * 3]);
    const permGrad3y = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 1]);
    const permGrad3z = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 2]);
    return function noise3D(x, y, z) {
        let n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const t = (i + j + k) * G3;
        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        const Y0 = j - t;
        const Z0 = k - t;
        const x0 = x - X0; // The x,y,z distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
        // Determine which simplex we are in.
        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        }
        else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
        // c = 1/6.
        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;
        // Work out the hashed gradient indices of the four simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        // Calculate the contribution from the four corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0)
            n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0)
            n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0)
            n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0)
            n3 = 0.0;
        else {
            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 32.0 * (n0 + n1 + n2 + n3);
    };
}
/**
 * Builds a random permutation table.
 * This is exported only for (internal) testing purposes.
 * Do not rely on this export.
 * @private
 */
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for (let i = 0; i < tableSize / 2; i++) {
        p[i] = i;
    }
    for (let i = 0; i < tableSize / 2 - 1; i++) {
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for (let i = 256; i < tableSize; i++) {
        p[i] = p[i - 256];
    }
    return p;
}

class SeededRandom {
  state;
  initialSeed;
  constructor(seed = 12345) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Reset to initial seed */
  reset() {
    this.state = this.initialSeed;
  }
  /** Reset to a new seed */
  setSeed(seed) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
  /** Get initial seed */
  getSeed() {
    return this.initialSeed;
  }
  /**
   * Get next random number in [0, 1)
   * Uses mulberry32 algorithm
   */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get random integer in range [min, max] inclusive */
  int(min, max) {
    return Math.floor(this.range(min, max + 1));
  }
  /** Get random value with variance: base + random(-variance, +variance) */
  variance(base, variance) {
    return base + (this.next() - 0.5) * 2 * variance;
  }
  /** Get random boolean with given probability of true */
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  /** Get random angle in radians [0, 2) */
  angle() {
    return this.next() * Math.PI * 2;
  }
  /** Get random point in unit circle */
  inCircle() {
    const angle = this.angle();
    const r = Math.sqrt(this.next());
    return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
  }
  /** Get random point on unit sphere */
  onSphere() {
    const theta = this.angle();
    const phi = Math.acos(2 * this.next() - 1);
    return {
      x: Math.sin(phi) * Math.cos(theta),
      y: Math.sin(phi) * Math.sin(theta),
      z: Math.cos(phi)
    };
  }
}
function createDefaultCollisionConfig() {
  return {
    enabled: false,
    particleCollision: false,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: false,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: false,
    floorY: 1,
    ceilingEnabled: false,
    ceilingY: 0,
    wallsEnabled: false,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function createDefaultConnectionConfig() {
  return {
    enabled: false,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: true
  };
}
function createDefaultSystemConfig() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: false,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: createDefaultCollisionConfig()
  };
}
function createDefaultRenderOptions() {
  return {
    blendMode: "additive",
    renderTrails: false,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: false,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: false,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: createDefaultConnectionConfig(),
    spriteSmoothing: true,
    spriteOpacityByAge: true,
    emissiveEnabled: false,
    emissiveIntensity: 2,
    emissiveColor: null
  };
}
class ParticleSystem {
  particles = [];
  emitters = /* @__PURE__ */ new Map();
  gravityWells = /* @__PURE__ */ new Map();
  vortices = /* @__PURE__ */ new Map();
  modulations = [];
  config;
  boundaryMask = null;
  frameCount = 0;
  emissionAccumulators = /* @__PURE__ */ new Map();
  nextParticleId = 0;
  trailHistory = /* @__PURE__ */ new Map();
  // ============================================================================
  // PARTICLE POOL - Recycles dead particles to reduce GC pressure
  // Memory management: Pool limited to maxParticles to prevent unbounded growth
  // ============================================================================
  particlePool = [];
  poolMaxSize = 1e4;
  // Cap pool size
  // Audio reactivity state
  featureOverrides = /* @__PURE__ */ new Map();
  // Turbulence noise generator (seeded for determinism)
  noise2D;
  noiseTime = 0;
  // Render options cache for spatial grid
  renderOptions = createDefaultRenderOptions();
  // Sprite image cache - maps emitter ID to loaded image
  spriteCache = /* @__PURE__ */ new Map();
  // Collision spatial hash grid
  collisionGrid = /* @__PURE__ */ new Map();
  collisionGridCellSize = 50;
  // SEEDED RNG - For deterministic simulation
  // Same seed + same config + same frame = identical particle state
  rng;
  // Spline path provider for emitters with shape='spline'
  // Set by the engine integration (e.g., WeylEngine) to resolve spline paths
  splineProvider = null;
  // Current frame for spline queries
  currentFrame = 0;
  // Sequential emit state per emitter (for 'sequential' emit mode)
  sequentialEmitT = /* @__PURE__ */ new Map();
  constructor(config = {}, seed = 12345) {
    this.config = { ...createDefaultSystemConfig(), ...config };
    this.rng = new SeededRandom(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
    if (this.config.collision) {
      this.collisionGridCellSize = this.config.collision.spatialHashCellSize;
    }
  }
  /**
   * Get the RNG instance (for external access/checkpointing)
   */
  getRng() {
    return this.rng;
  }
  /**
   * Set new seed and reset RNG
   */
  setSeed(seed) {
    this.rng.setSeed(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
  }
  /**
   * Set the spline path provider callback
   * This allows emitters with shape='spline' to query spline positions
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get the current spline provider
   */
  getSplineProvider() {
    return this.splineProvider;
  }
  /**
   * Set the current frame for spline queries
   * Called by the engine before stepping the simulation
   */
  setCurrentFrame(frame) {
    this.currentFrame = frame;
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(emitterId, imageUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.spriteCache.set(emitterId, img);
        const emitter = this.emitters.get(emitterId);
        if (emitter && emitter.sprite) {
          emitter.sprite.imageData = img;
        }
        resolve();
      };
      img.onerror = reject;
      img.src = imageUrl;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(emitterId, image) {
    this.spriteCache.set(emitterId, image);
    const emitter = this.emitters.get(emitterId);
    if (emitter && emitter.sprite) {
      emitter.sprite.imageData = image;
    }
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(emitterId) {
    return this.spriteCache.get(emitterId) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, { ...config });
    this.emissionAccumulators.set(config.id, 0);
    if (config.initialBurst > 0 && config.enabled) {
      const burstCount = Math.floor(config.emissionRate * config.initialBurst * 10);
      for (let i = 0; i < burstCount; i++) {
        this.spawnParticle(config);
      }
    }
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.emissionAccumulators.delete(id);
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(config) {
    this.gravityWells.set(config.id, { ...config });
  }
  updateGravityWell(id, updates) {
    const well = this.gravityWells.get(id);
    if (well) {
      Object.assign(well, updates);
    }
  }
  removeGravityWell(id) {
    this.gravityWells.delete(id);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(config) {
    this.vortices.set(config.id, { ...config });
  }
  updateVortex(id, updates) {
    const vortex = this.vortices.get(id);
    if (vortex) {
      Object.assign(vortex, updates);
    }
  }
  removeVortex(id) {
    this.vortices.delete(id);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(mod) {
    this.modulations.push({ ...mod });
  }
  removeModulation(id) {
    const index = this.modulations.findIndex((m) => m.id === id);
    if (index >= 0) {
      this.modulations.splice(index, 1);
    }
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(mask) {
    this.boundaryMask = mask;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(param, value, emitterId) {
    const key = emitterId ? `${emitterId}:${param}` : `*:${param}`;
    this.featureOverrides.set(key, value);
  }
  getFeatureValue(param, emitterId) {
    return this.featureOverrides.get(`${emitterId}:${param}`) ?? this.featureOverrides.get(`*:${param}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(deltaTime = 1) {
    this.emitters.forEach((emitter, id) => {
      if (!emitter.enabled) return;
      const baseRate = this.getFeatureValue("emissionRate", id) ?? emitter.emissionRate;
      const particlesToEmit = baseRate * deltaTime;
      let accumulated = (this.emissionAccumulators.get(id) || 0) + particlesToEmit;
      while (accumulated >= 1 && this.particles.length < this.config.maxParticles) {
        this.spawnParticle(emitter);
        accumulated -= 1;
      }
      this.emissionAccumulators.set(id, accumulated);
    });
    const windRadians = this.config.windDirection * Math.PI / 180;
    const windX = Math.cos(windRadians) * this.config.windStrength * 1e-3;
    const windY = Math.sin(windRadians) * this.config.windStrength * 1e-3;
    const gravity = this.getFeatureValue("gravity", "*") ?? this.config.gravity;
    const windStrength = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength;
    const actualWindX = windX * (windStrength / Math.max(1, this.config.windStrength));
    const actualWindY = windY * (windStrength / Math.max(1, this.config.windStrength));
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.prevX = p.x;
      p.prevY = p.y;
      if (this.trailHistory.has(p.id)) {
        const trail = this.trailHistory.get(p.id);
        trail.unshift({ x: p.x, y: p.y });
        if (trail.length > 20) trail.pop();
      }
      p.vy += gravity * 1e-3 * deltaTime;
      p.vx += actualWindX * deltaTime;
      p.vy += actualWindY * deltaTime;
      this.gravityWells.forEach((well) => {
        if (!well.enabled) return;
        const dx = well.x - p.x;
        const dy = well.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < well.radius && dist > 1e-3) {
          let force = well.strength * 1e-4;
          switch (well.falloff) {
            case "linear":
              force *= 1 - dist / well.radius;
              break;
            case "quadratic":
              force *= Math.pow(1 - dist / well.radius, 2);
              break;
          }
          const nx = dx / dist;
          const ny = dy / dist;
          p.vx += nx * force * deltaTime;
          p.vy += ny * force * deltaTime;
        }
      });
      this.vortices.forEach((vortex) => {
        if (!vortex.enabled) return;
        const dx = vortex.x - p.x;
        const dy = vortex.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < vortex.radius && dist > 1e-3) {
          const influence = 1 - dist / vortex.radius;
          const strength = vortex.strength * 1e-4 * influence;
          const nx = dx / dist;
          const ny = dy / dist;
          const perpX = -ny;
          const perpY = nx;
          p.vx += perpX * strength * deltaTime;
          p.vy += perpY * strength * deltaTime;
          const inward = vortex.inwardPull * 1e-4 * influence;
          p.vx += nx * inward * deltaTime;
          p.vy += ny * inward * deltaTime;
        }
      });
      this.applyTurbulence(p, deltaTime);
      const frictionFactor = 1 - this.config.friction;
      p.vx *= frictionFactor;
      p.vy *= frictionFactor;
      if (p.angularVelocity !== 0) {
        p.rotation += p.angularVelocity * deltaTime;
      }
      const emitter = this.emitters.get(p.emitterId);
      if (emitter?.sprite?.alignToVelocity && (p.vx !== 0 || p.vy !== 0)) {
        p.rotation = Math.atan2(p.vy, p.vx);
      }
      if (emitter?.sprite?.isSheet && emitter.sprite.totalFrames > 1) {
        this.updateSpriteFrame(p, emitter.sprite, deltaTime);
      }
      p.x += p.vx * deltaTime;
      p.y += p.vy * deltaTime;
      if (this.boundaryMask && this.config.respectMaskBoundary) {
        this.handleBoundaryCollision(p);
      }
      this.handleCanvasBoundary(p);
      this.applyModulations(p);
      p.age += deltaTime;
      if (p.age > p.lifetime) {
        if (!p.isSubParticle) {
          this.triggerSubEmitters(p);
        }
        if (this.particlePool.length < this.poolMaxSize) {
          this.particlePool.push(p);
        }
        this.particles.splice(i, 1);
        this.trailHistory.delete(p.id);
      }
    }
    if (this.config.collision?.enabled && this.config.collision.particleCollision) {
      this.handleParticleCollisions();
    }
    if (this.config.collision?.enabled) {
      this.handleEnvironmentCollisions();
    }
    this.noiseTime += deltaTime;
    this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(p, sprite, _deltaTime) {
    const totalFrames = sprite.totalFrames;
    switch (sprite.playMode) {
      case "loop": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = framesElapsed % totalFrames;
        break;
      }
      case "once": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = Math.min(framesElapsed, totalFrames - 1);
        break;
      }
      case "pingpong": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        const cycle = Math.floor(framesElapsed / (totalFrames - 1));
        const frameInCycle = framesElapsed % (totalFrames - 1);
        p.spriteIndex = cycle % 2 === 0 ? frameInCycle : totalFrames - 1 - frameInCycle;
        break;
      }
      case "random": {
        if (this.rng.bool(0.1)) {
          p.spriteIndex = this.rng.int(0, totalFrames - 1);
        }
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const collision = this.config.collision;
    if (!collision || !collision.particleCollision) return;
    this.collisionGrid.clear();
    const cellSize = this.collisionGridCellSize / 1e3;
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      const key = `${cellX},${cellY}`;
      if (!this.collisionGrid.has(key)) {
        this.collisionGrid.set(key, []);
      }
      this.collisionGrid.get(key).push(p);
    }
    const checked = /* @__PURE__ */ new Set();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          const cell = this.collisionGrid.get(key);
          if (!cell) continue;
          for (const other of cell) {
            if (other.id <= p.id) continue;
            const pairKey = `${Math.min(p.id, other.id)}-${Math.max(p.id, other.id)}`;
            if (checked.has(pairKey)) continue;
            checked.add(pairKey);
            const radiusP = p.size / 1e3 * collision.particleCollisionRadius;
            const radiusO = other.size / 1e3 * collision.particleCollisionRadius;
            const minDist = radiusP + radiusO;
            const dx2 = other.x - p.x;
            const dy2 = other.y - p.y;
            const distSq = dx2 * dx2 + dy2 * dy2;
            if (distSq < minDist * minDist && distSq > 1e-6) {
              const dist = Math.sqrt(distSq);
              const nx = dx2 / dist;
              const ny = dy2 / dist;
              switch (collision.particleCollisionResponse) {
                case "bounce": {
                  const dvx = p.vx - other.vx;
                  const dvy = p.vy - other.vy;
                  const dvDotN = dvx * nx + dvy * ny;
                  if (dvDotN > 0) {
                    const damping = collision.particleCollisionDamping;
                    p.vx -= dvDotN * nx * damping;
                    p.vy -= dvDotN * ny * damping;
                    other.vx += dvDotN * nx * damping;
                    other.vy += dvDotN * ny * damping;
                    const overlap = minDist - dist;
                    p.x -= nx * overlap * 0.5;
                    p.y -= ny * overlap * 0.5;
                    other.x += nx * overlap * 0.5;
                    other.y += ny * overlap * 0.5;
                  }
                  break;
                }
                case "absorb": {
                  if (p.size > other.size) {
                    p.size += other.size * 0.1;
                    other.age = other.lifetime + 1;
                  } else {
                    other.size += p.size * 0.1;
                    p.age = p.lifetime + 1;
                  }
                  break;
                }
                case "explode": {
                  p.age = p.lifetime + 1;
                  other.age = other.lifetime + 1;
                  break;
                }
              }
              p.collisionCount++;
              other.collisionCount++;
            }
          }
        }
      }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const collision = this.config.collision;
    if (!collision?.enabled) return;
    const bounciness = collision.bounciness;
    const friction = collision.friction;
    for (const p of this.particles) {
      if (collision.floorEnabled && p.y > collision.floorY) {
        p.y = collision.floorY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.ceilingEnabled && p.y < collision.ceilingY) {
        p.y = collision.ceilingY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.wallsEnabled) {
        if (p.x < 0) {
          p.x = 0;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
      }
    }
  }
  spawnParticle(emitter) {
    if (this.particles.length >= this.config.maxParticles) return;
    const spawnPos = this.getEmitterSpawnPosition(emitter);
    const baseDirection = spawnPos.direction !== void 0 ? spawnPos.direction : emitter.direction;
    const spreadRad = emitter.spread * Math.PI / 180;
    const baseRad = baseDirection * Math.PI / 180;
    const angle = baseRad + (this.rng.next() - 0.5) * spreadRad;
    const speed = this.rng.variance(emitter.speed, emitter.speedVariance);
    const speedNormalized = speed * 1e-3;
    const size = Math.max(1, this.rng.variance(emitter.size, emitter.sizeVariance));
    const lifetime = Math.max(1, this.rng.variance(emitter.particleLifetime, emitter.lifetimeVariance));
    let rotation = 0;
    let angularVelocity = 0;
    const sprite = emitter.sprite;
    if (sprite && sprite.rotationEnabled) {
      rotation = this.rng.angle();
      const rotSpeed = sprite.rotationSpeed * (Math.PI / 180);
      const rotVariance = sprite.rotationSpeedVariance * (Math.PI / 180);
      angularVelocity = this.rng.variance(rotSpeed, rotVariance);
    }
    if (sprite && sprite.alignToVelocity) {
      rotation = angle;
    }
    let spriteIndex = 0;
    if (sprite && sprite.isSheet && sprite.playMode === "random") {
      spriteIndex = this.rng.int(0, sprite.totalFrames - 1);
    }
    let particle;
    if (this.particlePool.length > 0) {
      particle = this.particlePool.pop();
      particle.id = this.nextParticleId++;
      particle.x = spawnPos.x;
      particle.y = spawnPos.y;
      particle.prevX = spawnPos.x;
      particle.prevY = spawnPos.y;
      particle.vx = Math.cos(angle) * speedNormalized;
      particle.vy = Math.sin(angle) * speedNormalized;
      particle.age = 0;
      particle.lifetime = lifetime;
      particle.size = size;
      particle.baseSize = size;
      particle.color[0] = emitter.color[0];
      particle.color[1] = emitter.color[1];
      particle.color[2] = emitter.color[2];
      particle.color[3] = 255;
      particle.baseColor[0] = emitter.color[0];
      particle.baseColor[1] = emitter.color[1];
      particle.baseColor[2] = emitter.color[2];
      particle.baseColor[3] = 255;
      particle.emitterId = emitter.id;
      particle.isSubParticle = false;
      particle.rotation = rotation;
      particle.angularVelocity = angularVelocity;
      particle.spriteIndex = spriteIndex;
      particle.collisionCount = 0;
    } else {
      particle = {
        id: this.nextParticleId++,
        x: spawnPos.x,
        y: spawnPos.y,
        prevX: spawnPos.x,
        prevY: spawnPos.y,
        vx: Math.cos(angle) * speedNormalized,
        vy: Math.sin(angle) * speedNormalized,
        age: 0,
        lifetime,
        size,
        baseSize: size,
        color: [...emitter.color, 255],
        baseColor: [...emitter.color, 255],
        emitterId: emitter.id,
        isSubParticle: false,
        rotation,
        angularVelocity,
        spriteIndex,
        collisionCount: 0
      };
    }
    this.particles.push(particle);
    this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   * Returns position and optionally a direction override for spline emission
   */
  getEmitterSpawnPosition(emitter) {
    const shape = emitter.shape || "point";
    switch (shape) {
      case "point":
        return { x: emitter.x, y: emitter.y };
      case "line": {
        const t = this.rng.next();
        const halfWidth = emitter.shapeWidth / 2;
        const dirRad = emitter.direction * Math.PI / 180;
        const perpX = -Math.sin(dirRad);
        const perpY = Math.cos(dirRad);
        return {
          x: emitter.x + perpX * (t - 0.5) * halfWidth * 2,
          y: emitter.y + perpY * (t - 0.5) * halfWidth * 2
        };
      }
      case "circle": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const angle = this.rng.angle();
          return {
            x: emitter.x + Math.cos(angle) * radius,
            y: emitter.y + Math.sin(angle) * radius
          };
        } else {
          const angle = this.rng.angle();
          const r = radius * Math.sqrt(this.rng.next());
          return {
            x: emitter.x + Math.cos(angle) * r,
            y: emitter.y + Math.sin(angle) * r
          };
        }
      }
      case "ring": {
        const innerR = emitter.shapeInnerRadius;
        const outerR = emitter.shapeRadius;
        const angle = this.rng.angle();
        const r = Math.sqrt(this.rng.next() * (outerR * outerR - innerR * innerR) + innerR * innerR);
        return {
          x: emitter.x + Math.cos(angle) * r,
          y: emitter.y + Math.sin(angle) * r
        };
      }
      case "box": {
        const halfW = emitter.shapeWidth / 2;
        const halfH = emitter.shapeHeight / 2;
        if (emitter.emitFromEdge) {
          const perimeter = 2 * (emitter.shapeWidth + emitter.shapeHeight);
          const t = this.rng.next() * perimeter;
          if (t < emitter.shapeWidth) {
            return { x: emitter.x - halfW + t, y: emitter.y - halfH };
          } else if (t < emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW, y: emitter.y - halfH + (t - emitter.shapeWidth) };
          } else if (t < 2 * emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW - (t - emitter.shapeWidth - emitter.shapeHeight), y: emitter.y + halfH };
          } else {
            return { x: emitter.x - halfW, y: emitter.y + halfH - (t - 2 * emitter.shapeWidth - emitter.shapeHeight) };
          }
        } else {
          return {
            x: emitter.x + (this.rng.next() - 0.5) * emitter.shapeWidth,
            y: emitter.y + (this.rng.next() - 0.5) * emitter.shapeHeight
          };
        }
      }
      case "sphere": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const theta = this.rng.angle();
          const phi = Math.acos(2 * this.rng.next() - 1);
          return {
            x: emitter.x + Math.sin(phi) * Math.cos(theta) * radius,
            y: emitter.y + Math.sin(phi) * Math.sin(theta) * radius
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let x, y, z;
          do {
            x = (this.rng.next() - 0.5) * 2;
            y = (this.rng.next() - 0.5) * 2;
            z = (this.rng.next() - 0.5) * 2;
          } while (x * x + y * y + z * z > 1);
          return {
            x: emitter.x + x * radius,
            y: emitter.y + y * radius
          };
        }
      }
      case "spline": {
        return this.getSplineEmitPosition(emitter);
      }
      case "depth-map": {
        return this.getDepthMapEmitPosition(emitter);
      }
      case "mask": {
        return this.getMaskEmitPosition(emitter);
      }
      default:
        return { x: emitter.x, y: emitter.y };
    }
  }
  /**
   * Get emission position along a spline path
   * Returns position and optionally modifies emission direction
   * DETERMINISM: Uses seeded RNG (this.rng) for random positions
   */
  getSplineEmitPosition(emitter) {
    const splinePath = emitter.splinePath;
    if (!splinePath || !this.splineProvider) {
      return { x: emitter.x, y: emitter.y };
    }
    let t;
    switch (splinePath.emitMode) {
      case "start":
        t = splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "end":
        t = 1 - splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "random":
        t = this.rng.next();
        break;
      case "uniform":
        const interval = Math.max(0.01, splinePath.parameter);
        const numSlots = Math.ceil(1 / interval);
        const slot = this.rng.int(0, numSlots - 1);
        t = slot * interval;
        break;
      case "sequential":
        const currentT = this.sequentialEmitT.get(emitter.id) ?? 0;
        t = currentT;
        const speed = Math.max(1e-3, splinePath.parameter);
        let nextT = currentT + speed;
        if (nextT > 1) nextT = nextT - 1;
        this.sequentialEmitT.set(emitter.id, nextT);
        break;
      default:
        t = this.rng.next();
    }
    t = Math.max(0, Math.min(1, t));
    const result = this.splineProvider(splinePath.layerId, t, this.currentFrame);
    if (!result) {
      return { x: emitter.x, y: emitter.y };
    }
    let x = result.point.x;
    let y = result.point.y;
    if (splinePath.offset !== 0) {
      const tangentLength = Math.sqrt(result.tangent.x ** 2 + result.tangent.y ** 2);
      if (tangentLength > 1e-4) {
        const perpX = -result.tangent.y / tangentLength;
        const perpY = result.tangent.x / tangentLength;
        x += perpX * splinePath.offset;
        y += perpY * splinePath.offset;
      }
    }
    let direction;
    if (splinePath.alignToPath) {
      const tangentAngle = Math.atan2(result.tangent.y, result.tangent.x) * (180 / Math.PI);
      if (splinePath.bidirectional && this.rng.bool(0.5)) {
        direction = tangentAngle + 180;
      } else {
        direction = tangentAngle;
      }
      direction += 90;
    }
    return { x, y, direction };
  }
  /**
   * Get emission position from depth map
   * Emits particles from positions where depth values fall within the configured range
   * Uses cached emission points for performance
   */
  getDepthMapEmitPosition(emitter) {
    const config = emitter.depthMapEmission;
    if (!config) {
      return { x: emitter.x, y: emitter.y };
    }
    const cacheKey = `depth_${config.sourceLayerId}`;
    let emissionPoints = this.imageEmissionCache.get(cacheKey);
    if (!emissionPoints) {
      emissionPoints = this.sampleDepthMapEmissionPoints(config);
      this.imageEmissionCache.set(cacheKey, emissionPoints);
    }
    if (emissionPoints.length === 0) {
      return { x: emitter.x, y: emitter.y };
    }
    const idx = this.rng.int(0, emissionPoints.length - 1);
    const point = emissionPoints[idx];
    return { x: point.x + emitter.x, y: point.y + emitter.y };
  }
  /**
   * Sample valid emission points from a depth map
   */
  sampleDepthMapEmissionPoints(config) {
    const points = [];
    if (!this.depthMapProvider) {
      const gridSize = 20;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const depth = (x + y) / (gridSize * 2);
          if (depth >= config.depthMin && depth <= config.depthMax) {
            points.push({
              x: (x / gridSize - 0.5) * 500,
              y: (y / gridSize - 0.5) * 500,
              depth
            });
          }
        }
      }
      return points;
    }
    const depthData = this.depthMapProvider(config.sourceLayerId, this.currentFrame);
    if (!depthData) {
      return points;
    }
    const sampleRate = Math.max(1, Math.floor(1 / config.density));
    for (let y = 0; y < depthData.height; y += sampleRate) {
      for (let x = 0; x < depthData.width; x += sampleRate) {
        const idx = (y * depthData.width + x) * 4;
        let depthValue = depthData.data[idx] / 255;
        if (config.depthMode === "near-black") {
          depthValue = 1 - depthValue;
        }
        if (depthValue >= config.depthMin && depthValue <= config.depthMax) {
          points.push({
            x: x - depthData.width / 2,
            y: y - depthData.height / 2,
            depth: depthValue
          });
        }
      }
    }
    return points;
  }
  /**
   * Get emission position from mask/matte
   * Emits particles from bright areas of the mask
   */
  getMaskEmitPosition(emitter) {
    const config = emitter.maskEmission;
    if (!config) {
      return { x: emitter.x, y: emitter.y };
    }
    const cacheKey = `mask_${config.sourceLayerId}_${config.channel}_${config.threshold}`;
    let emissionPoints = this.imageEmissionCache.get(cacheKey);
    if (!emissionPoints) {
      emissionPoints = this.sampleMaskEmissionPoints(config);
      this.imageEmissionCache.set(cacheKey, emissionPoints);
    }
    if (emissionPoints.length === 0) {
      return { x: emitter.x, y: emitter.y };
    }
    const idx = this.rng.int(0, emissionPoints.length - 1);
    const point = emissionPoints[idx];
    return { x: point.x + emitter.x, y: point.y + emitter.y };
  }
  /**
   * Sample valid emission points from a mask
   */
  sampleMaskEmissionPoints(config) {
    const points = [];
    if (!this.maskProvider) {
      return points;
    }
    const maskData = this.maskProvider(config.sourceLayerId, this.currentFrame);
    if (!maskData) {
      return points;
    }
    const channelIdx = config.channel === "alpha" ? 3 : config.channel === "red" ? 0 : config.channel === "green" ? 1 : config.channel === "blue" ? 2 : -1;
    const sampleRate = Math.max(1, config.sampleRate || 1);
    for (let y = 0; y < maskData.height; y += sampleRate) {
      for (let x = 0; x < maskData.width; x += sampleRate) {
        const idx = (y * maskData.width + x) * 4;
        let value;
        if (channelIdx === -1) {
          value = (maskData.data[idx] * 0.299 + maskData.data[idx + 1] * 0.587 + maskData.data[idx + 2] * 0.114) / 255;
        } else {
          value = maskData.data[idx + channelIdx] / 255;
        }
        if (config.invert) {
          value = 1 - value;
        }
        if (value >= config.threshold) {
          if (this.rng.next() < config.density) {
            points.push({
              x: x - maskData.width / 2,
              y: y - maskData.height / 2
            });
          }
        }
      }
    }
    return points;
  }
  // Cache for image-based emission points
  imageEmissionCache = /* @__PURE__ */ new Map();
  // Provider functions for image data (set by the engine)
  depthMapProvider;
  maskProvider;
  /**
   * Set the depth map provider function
   */
  setDepthMapProvider(provider) {
    this.depthMapProvider = provider;
  }
  /**
   * Set the mask provider function
   */
  setMaskProvider(provider) {
    this.maskProvider = provider;
  }
  /**
   * Clear the image emission cache (call when source layers change)
   */
  clearEmissionCache() {
    this.imageEmissionCache.clear();
  }
  handleBoundaryCollision(p) {
    if (!this.boundaryMask) return;
    const px = Math.floor(p.x * this.boundaryMask.width);
    const py = Math.floor(p.y * this.boundaryMask.height);
    if (px < 0 || px >= this.boundaryMask.width || py < 0 || py >= this.boundaryMask.height) {
      return;
    }
    const idx = (py * this.boundaryMask.width + px) * 4;
    const maskValue = this.boundaryMask.data[idx];
    if (maskValue < 128) {
      switch (this.config.boundaryBehavior) {
        case "bounce":
          p.vx *= -0.8;
          p.vy *= -0.8;
          p.x = p.prevX;
          p.y = p.prevY;
          break;
        case "kill":
          p.age = p.lifetime + 1;
          break;
        case "wrap":
          p.x = this.rng.next();
          p.y = this.rng.next();
          break;
      }
    }
  }
  handleCanvasBoundary(p) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        if (p.x < 0) {
          p.x = 0;
          p.vx *= -0.8;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx *= -0.8;
        }
        if (p.y < 0) {
          p.y = 0;
          p.vy *= -0.8;
        }
        if (p.y > 1) {
          p.y = 1;
          p.vy *= -0.8;
        }
        break;
      case "kill":
        if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1) {
          p.age = p.lifetime + 1;
        }
        break;
      case "wrap":
        if (p.x < 0) p.x += 1;
        if (p.x > 1) p.x -= 1;
        if (p.y < 0) p.y += 1;
        if (p.y > 1) p.y -= 1;
        break;
    }
  }
  applyModulations(p) {
    const lifeRatio = p.age / p.lifetime;
    for (const mod of this.modulations) {
      if (mod.emitterId !== "*" && mod.emitterId !== p.emitterId) continue;
      const easingKey = mod.easing;
      const easing = EASING_PRESETS[easingKey] || EASING_PRESETS.linear;
      const easedRatio = applyEasing$1(lifeRatio, easing);
      const value = mod.startValue + (mod.endValue - mod.startValue) * easedRatio;
      switch (mod.property) {
        case "size":
          p.size = p.baseSize * value;
          break;
        case "speed":
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (currentSpeed > 1e-4) {
            const scale = value / Math.max(1e-4, currentSpeed * 1e3);
            p.vx *= scale;
            p.vy *= scale;
          }
          break;
        case "opacity":
          p.color[3] = Math.max(0, Math.min(255, p.baseColor[3] * value));
          break;
        case "colorR":
          p.color[0] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorG":
          p.color[1] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorB":
          p.color[2] = Math.max(0, Math.min(255, value * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(p, deltaTime) {
    const turbFields = this.config.turbulenceFields || [];
    for (const turb of turbFields) {
      if (!turb.enabled) continue;
      const nx = p.x * turb.scale * 1e3;
      const ny = p.y * turb.scale * 1e3;
      const nt = this.noiseTime * turb.evolutionSpeed;
      const angle = this.noise2D(nx + nt, ny + nt) * Math.PI * 2;
      const force = turb.strength * 1e-5;
      p.vx += Math.cos(angle) * force * deltaTime;
      p.vy += Math.sin(angle) * force * deltaTime;
    }
  }
  addTurbulence(config) {
    if (!this.config.turbulenceFields) this.config.turbulenceFields = [];
    this.config.turbulenceFields.push(config);
  }
  updateTurbulence(id, updates) {
    const turb = this.config.turbulenceFields?.find((t) => t.id === id);
    if (turb) Object.assign(turb, updates);
  }
  removeTurbulence(id) {
    if (this.config.turbulenceFields) {
      this.config.turbulenceFields = this.config.turbulenceFields.filter((t) => t.id !== id);
    }
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  /**
   * Trigger sub-emitters when a particle dies
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   */
  triggerSubEmitters(deadParticle) {
    const subEmitters = this.config.subEmitters || [];
    for (const sub of subEmitters) {
      if (!sub.enabled) continue;
      if (sub.parentEmitterId !== "*" && sub.parentEmitterId !== deadParticle.emitterId) continue;
      for (let i = 0; i < sub.spawnCount; i++) {
        const angle = (this.rng.next() - 0.5) * sub.spread * Math.PI / 180;
        const baseAngle = Math.atan2(deadParticle.vy, deadParticle.vx);
        const emitAngle = baseAngle + angle;
        const inheritedSpeed = Math.sqrt(deadParticle.vx ** 2 + deadParticle.vy ** 2) * sub.inheritVelocity;
        const totalSpeed = sub.speed * 1e-3 + inheritedSpeed;
        const particle = {
          id: this.nextParticleId++,
          x: deadParticle.x,
          y: deadParticle.y,
          prevX: deadParticle.x,
          prevY: deadParticle.y,
          vx: Math.cos(emitAngle) * totalSpeed + deadParticle.vx * sub.inheritVelocity,
          vy: Math.sin(emitAngle) * totalSpeed + deadParticle.vy * sub.inheritVelocity,
          age: 0,
          lifetime: sub.lifetime * (1 + (this.rng.next() - 0.5) * 0.2),
          size: sub.size * (1 + (this.rng.next() - 0.5) * sub.sizeVariance / sub.size),
          baseSize: sub.size,
          color: [...sub.color, 255],
          baseColor: [...sub.color, 255],
          emitterId: sub.id,
          isSubParticle: true,
          rotation: deadParticle.rotation,
          // Inherit parent rotation
          angularVelocity: 0,
          spriteIndex: 0,
          collisionCount: 0
        };
        this.particles.push(particle);
        this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
      }
    }
  }
  addSubEmitter(config) {
    if (!this.config.subEmitters) this.config.subEmitters = [];
    this.config.subEmitters.push(config);
  }
  updateSubEmitter(id, updates) {
    const sub = this.config.subEmitters?.find((s) => s.id === id);
    if (sub) Object.assign(sub, updates);
  }
  removeSubEmitter(id) {
    if (this.config.subEmitters) {
      this.config.subEmitters = this.config.subEmitters.filter((s) => s.id !== id);
    }
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(emitterId, count) {
    const emitter = this.emitters.get(emitterId);
    if (!emitter || !emitter.enabled) return;
    const burstCount = count ?? emitter.burstCount ?? 20;
    for (let i = 0; i < burstCount; i++) {
      this.spawnParticle(emitter);
    }
  }
  triggerAllBursts() {
    for (const emitter of this.emitters.values()) {
      if (emitter.burstOnBeat && emitter.enabled) {
        this.triggerBurst(emitter.id);
      }
    }
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    const cellSize = this.renderOptions.connections?.maxDistance || 100;
    const cells = /* @__PURE__ */ new Map();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x * 1e3 / cellSize);
      const cellY = Math.floor(p.y * 1e3 / cellSize);
      const key = `${cellX},${cellY}`;
      if (!cells.has(key)) cells.set(key, []);
      cells.get(key).push(p);
    }
    return { cellSize, cells };
  }
  getNeighborParticles(p, grid) {
    const cellX = Math.floor(p.x * 1e3 / grid.cellSize);
    const cellY = Math.floor(p.y * 1e3 / grid.cellSize);
    const neighbors = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cellX + dx},${cellY + dy}`;
        const cell = grid.cells.get(key);
        if (cell) neighbors.push(...cell);
      }
    }
    return neighbors;
  }
  renderConnections(ctx, width, height) {
    const config = this.renderOptions.connections;
    if (!config?.enabled || this.particles.length < 2) return;
    const grid = this.buildSpatialGrid();
    const maxDist = config.maxDistance / 1e3;
    const maxDistSq = maxDist * maxDist;
    ctx.lineWidth = config.lineWidth;
    for (const p of this.particles) {
      const neighbors = this.getNeighborParticles(p, grid);
      let connectionCount = 0;
      for (const other of neighbors) {
        if (other.id <= p.id) continue;
        if (connectionCount >= config.maxConnections) break;
        const dx = other.x - p.x;
        const dy = other.y - p.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < maxDistSq) {
          const dist = Math.sqrt(distSq);
          let opacity = config.lineOpacity;
          if (config.fadeByDistance) {
            opacity *= 1 - dist / maxDist;
          }
          const r = Math.round((p.color[0] + other.color[0]) / 2);
          const g = Math.round((p.color[1] + other.color[1]) / 2);
          const b = Math.round((p.color[2] + other.color[2]) / 2);
          ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
          ctx.beginPath();
          ctx.moveTo(p.x * width, p.y * height);
          ctx.lineTo(other.x * width, other.y * height);
          ctx.stroke();
          connectionCount++;
        }
      }
    }
  }
  reset() {
    this.particles = [];
    this.particlePool = [];
    this.frameCount = 0;
    this.trailHistory.clear();
    this.emissionAccumulators.forEach((_, key) => {
      this.emissionAccumulators.set(key, 0);
    });
    this.nextParticleId = 0;
    this.sequentialEmitT.clear();
    this.currentFrame = 0;
  }
  /**
   * Get particle pool statistics for debugging
   */
  getPoolStats() {
    return {
      poolSize: this.particlePool.length,
      maxPoolSize: this.poolMaxSize,
      activeParticles: this.particles.length
    };
  }
  /**
   * Clear the particle pool to free memory
   * Call this when memory pressure is high
   */
  clearPool() {
    this.particlePool = [];
  }
  /**
   * Restore particles from serialized state (for checkpoint restoration)
   * DETERMINISM: Restores exact particle positions for scrub-safe simulation
   *
   * @param particleStates - Array of serialized particle states from a checkpoint
   * @param frameCount - The frame number being restored to
   */
  restoreParticles(particleStates, frameCount) {
    this.particles = [];
    this.trailHistory.clear();
    let maxId = 0;
    for (const state of particleStates) {
      const particle = {
        id: state.id,
        x: state.x,
        y: state.y,
        prevX: state.x,
        // Previous position set to current (no trail initially)
        prevY: state.y,
        vx: state.vx,
        vy: state.vy,
        age: state.age,
        lifetime: state.lifetime,
        size: state.size,
        baseSize: state.size,
        // Base size set to current
        color: [...state.color],
        baseColor: [...state.color],
        emitterId: state.emitterId,
        isSubParticle: false,
        rotation: state.rotation,
        angularVelocity: 0,
        // Default angular velocity
        spriteIndex: 0,
        collisionCount: 0
        // Reset collision count on restore
      };
      this.particles.push(particle);
      maxId = Math.max(maxId, state.id);
    }
    this.nextParticleId = maxId + 1;
    this.frameCount = frameCount;
  }
  warmup() {
    for (let i = 0; i < this.config.warmupPeriod; i++) {
      this.step(1);
    }
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(ctx, width, height, options = createDefaultRenderOptions()) {
    this.renderOptions = options;
    ctx.save();
    switch (options.blendMode) {
      case "additive":
        ctx.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        ctx.globalCompositeOperation = "multiply";
        break;
      case "screen":
        ctx.globalCompositeOperation = "screen";
        break;
      default:
        ctx.globalCompositeOperation = "source-over";
    }
    this.renderConnections(ctx, width, height);
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size;
      if (options.renderTrails) {
        const trail = this.trailHistory.get(p.id);
        if (trail && trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          const trailLen = Math.min(trail.length, options.trailLength);
          for (let i = 0; i < trailLen; i++) {
            const tp = trail[i];
            const opacity = p.color[3] * Math.pow(options.trailOpacityFalloff, i + 1);
            ctx.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${opacity / 255})`;
            ctx.lineWidth = size * Math.pow(options.trailOpacityFalloff, i);
            ctx.lineTo(tp.x * width, tp.y * height);
          }
          ctx.stroke();
        }
      }
      if (options.glowEnabled) {
        ctx.shadowBlur = options.glowRadius;
        ctx.shadowColor = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${options.glowIntensity})`;
      } else {
        ctx.shadowBlur = 0;
      }
      if (options.motionBlur && (p.vx !== 0 || p.vy !== 0)) {
        this.renderParticleWithMotionBlur(ctx, p, x, y, size, width, height, options);
      } else {
        this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
      }
    }
    ctx.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(ctx, p, x, y, size, _width, _height, options) {
    const velocityMag = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
    if (velocityMag < 1e-4) {
      this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape);
      return;
    }
    const stretchFactor = options.motionBlurStrength * velocityMag * 500;
    const samples = Math.min(options.motionBlurSamples, 16);
    const dirX = p.vx / velocityMag;
    const dirY = p.vy / velocityMag;
    const stretchDistance = Math.min(stretchFactor * size, size * 10);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      const sampleOpacity = (1 - t * 0.8) / samples;
      const sampleX = x - dirX * stretchDistance * t;
      const sampleY = y - dirY * stretchDistance * t;
      const sampleSize = size * (1 - t * 0.3);
      const alpha = p.color[3] / 255 * sampleOpacity * samples;
      ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${Math.min(1, alpha)})`;
      this.renderParticleShape(ctx, sampleX, sampleY, sampleSize, null, options.particleShape, p, options);
    }
    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.color[3] / 255})`;
    this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(ctx, x, y, size, color, shape, particle, options) {
    if (color) {
      ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
    }
    if (shape === "sprite" && particle) {
      this.renderSprite(ctx, x, y, size, particle, options);
      return;
    }
    const hasRotation = particle && particle.rotation !== 0;
    if (hasRotation && particle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(particle.rotation);
      this.drawShapeAtOrigin(ctx, size, shape);
      ctx.restore();
    } else {
      switch (shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          break;
        case "star":
          this.drawStar(ctx, x, y, 5, size / 2, size / 4);
          ctx.fill();
          break;
      }
    }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(ctx, size, shape) {
    switch (shape) {
      case "circle":
        ctx.beginPath();
        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case "square":
        ctx.fillRect(-size / 2, -size / 2, size, size);
        break;
      case "triangle":
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(-size / 2, size / 2);
        ctx.lineTo(size / 2, size / 2);
        ctx.closePath();
        ctx.fill();
        break;
      case "star":
        this.drawStar(ctx, 0, 0, 5, size / 2, size / 4);
        ctx.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(ctx, x, y, size, particle, options) {
    const emitter = this.emitters.get(particle.emitterId);
    if (!emitter?.sprite?.enabled) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    const sprite = emitter.sprite;
    const image = sprite.imageData || this.spriteCache.get(particle.emitterId);
    if (!image) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    ctx.save();
    ctx.imageSmoothingEnabled = options?.spriteSmoothing ?? true;
    let alpha = particle.color[3] / 255;
    if (options?.spriteOpacityByAge) {
      const lifeRatio = particle.age / particle.lifetime;
      if (lifeRatio > 0.8) {
        alpha *= 1 - (lifeRatio - 0.8) / 0.2;
      }
    }
    ctx.globalAlpha = alpha;
    let sx = 0;
    let sy = 0;
    let sw = image.width;
    let sh = image.height;
    if (sprite.isSheet && sprite.columns > 1 || sprite.rows > 1) {
      const frameWidth = image.width / sprite.columns;
      const frameHeight = image.height / sprite.rows;
      const col = particle.spriteIndex % sprite.columns;
      const row = Math.floor(particle.spriteIndex / sprite.columns) % sprite.rows;
      sx = col * frameWidth;
      sy = row * frameHeight;
      sw = frameWidth;
      sh = frameHeight;
    }
    ctx.translate(x, y);
    if (particle.rotation !== 0) {
      ctx.rotate(particle.rotation);
    }
    const halfSize = size / 2;
    ctx.drawImage(
      image,
      sx,
      sy,
      sw,
      sh,
      // Source rectangle
      -halfSize,
      -halfSize,
      size,
      size
      // Destination rectangle
    );
    ctx.restore();
  }
  drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    ctx.beginPath();
    let rotation = -Math.PI / 2;
    for (let i = 0; i < spikes; i++) {
      const outerX = cx + Math.cos(rotation) * outerRadius;
      const outerY = cy + Math.sin(rotation) * outerRadius;
      if (i === 0) {
        ctx.moveTo(outerX, outerY);
      } else {
        ctx.lineTo(outerX, outerY);
      }
      rotation += Math.PI / spikes;
      const innerX = cx + Math.cos(rotation) * innerRadius;
      const innerY = cy + Math.sin(rotation) * innerRadius;
      ctx.lineTo(innerX, innerY);
      rotation += Math.PI / spikes;
    }
    ctx.closePath();
  }
  renderToMask(width, height) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    const connConfig = this.renderOptions.connections;
    if (connConfig?.enabled && this.particles.length >= 2) {
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = connConfig.lineWidth * 2;
      this.renderConnections(ctx, width, height);
    }
    ctx.fillStyle = "#000000";
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
    return ctx.getImageData(0, 0, width, height);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(data) {
    const system = new ParticleSystem(data.config);
    if (data.emitters) {
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
    }
    if (data.modulations) {
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
    }
    return system;
  }
}

class SeededRNG {
  state;
  constructor(seed) {
    this.state = seed;
  }
  /** Reset to initial seed */
  reset(seed) {
    this.state = seed;
  }
  /** Get next random number in [0, 1) */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
}
class ParticleSimulationController {
  /** The underlying particle system (used for simulation) */
  system;
  /** Configuration (immutable after construction) */
  config;
  /** Master seed for deterministic simulation */
  seed;
  /** Seeded RNG instance */
  rng;
  /** Checkpoint interval (frames between cached states) */
  checkpointInterval;
  /** Cached checkpoints: frame  checkpoint */
  checkpoints;
  /** Last evaluated frame (for optimization) */
  lastEvaluatedFrame = -1;
  /** Last snapshot (cached for repeated access) */
  lastSnapshot = null;
  constructor(config, seed = 12345, checkpointInterval = 30) {
    this.config = { ...config };
    this.seed = seed;
    this.rng = new SeededRNG(seed);
    this.checkpointInterval = checkpointInterval;
    this.checkpoints = /* @__PURE__ */ new Map();
    this.system = new ParticleSystem(config, seed);
    this.createCheckpoint(0);
  }
  /**
   * Evaluate particle state at a specific frame
   *
   * PURE (relative to frame number): Same frame always produces same result.
   *
   * @param frame - Target frame number
   * @returns Immutable ParticleSnapshot
   */
  evaluateAtFrame(frame) {
    if (frame === this.lastEvaluatedFrame && this.lastSnapshot) {
      return this.lastSnapshot;
    }
    const checkpointFrame = this.findNearestCheckpoint(frame);
    this.restoreCheckpoint(checkpointFrame);
    const framesToSimulate = frame - checkpointFrame;
    for (let i = 0; i < framesToSimulate; i++) {
      this.deterministicStep();
      const currentFrame = checkpointFrame + i + 1;
      if (currentFrame % this.checkpointInterval === 0 && !this.checkpoints.has(currentFrame)) {
        this.createCheckpoint(currentFrame);
      }
    }
    const snapshot = this.createSnapshot(frame);
    this.lastEvaluatedFrame = frame;
    this.lastSnapshot = snapshot;
    return snapshot;
  }
  /**
   * Get the underlying particles for rendering
   * NOTE: This is a convenience method; prefer evaluateAtFrame() for determinism
   */
  getParticles() {
    return this.system.getParticles();
  }
  /**
   * Reset controller and clear all checkpoints
   */
  reset() {
    this.system.reset();
    this.rng.reset(this.seed);
    this.checkpoints.clear();
    this.lastEvaluatedFrame = -1;
    this.lastSnapshot = null;
    this.createCheckpoint(0);
  }
  /**
   * Update configuration (clears all checkpoints)
   */
  updateConfig(updates) {
    Object.assign(this.config, updates);
    this.system.setConfig(updates);
    this.reset();
  }
  /**
   * Get current seed
   */
  getSeed() {
    return this.seed;
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  /**
   * Find the frame number of the nearest checkpoint at or before target
   */
  findNearestCheckpoint(targetFrame) {
    let nearest = 0;
    for (const frame of this.checkpoints.keys()) {
      if (frame <= targetFrame && frame > nearest) {
        nearest = frame;
      }
    }
    return nearest;
  }
  /**
   * Create a checkpoint at the current state
   * DETERMINISM: Captures RNG state for exact restoration
   */
  createCheckpoint(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    const checkpoint = {
      frame,
      particles,
      emissionAccumulators: /* @__PURE__ */ new Map(),
      // Would need access to system internals
      nextParticleId: particles.length > 0 ? Math.max(...particles.map((p) => p.id)) + 1 : 0,
      noiseTime: 0,
      // Would need access to system internals
      frameCount: frame,
      // Capture RNG state from the particle system for deterministic restoration
      rngState: this.system.getRng().getState()
    };
    this.checkpoints.set(frame, checkpoint);
  }
  /**
   * Restore state from a checkpoint
   * DETERMINISM: Restores exact RNG state for reproducible continuation
   */
  restoreCheckpoint(frame) {
    const checkpoint = this.checkpoints.get(frame);
    if (!checkpoint) {
      throw new Error(`No checkpoint at frame ${frame}`);
    }
    this.system.getRng().setState(checkpoint.rngState);
    this.rng.setState(checkpoint.rngState);
    this.system.restoreParticles(checkpoint.particles, checkpoint.frame);
  }
  /**
   * Perform one deterministic simulation step
   * DETERMINISM: ParticleSystem now uses seeded RNG (mulberry32) for all randomness
   */
  deterministicStep() {
    this.system.step(1);
  }
  /**
   * Serialize a particle to immutable state
   */
  serializeParticle(p) {
    return Object.freeze({
      id: p.id,
      x: p.x,
      y: p.y,
      vx: p.vx,
      vy: p.vy,
      age: p.age,
      lifetime: p.lifetime,
      size: p.size,
      color: Object.freeze([...p.color]),
      rotation: p.rotation,
      emitterId: p.emitterId
    });
  }
  /**
   * Create an immutable snapshot of current state
   * DETERMINISM: No timestamps - only deterministic values
   */
  createSnapshot(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    return Object.freeze({
      frame,
      particles: Object.freeze(particles),
      count: particles.length,
      seed: this.seed,
      rngState: this.system.getRng().getState()
    });
  }
}
class ParticleSimulationRegistry {
  controllers = /* @__PURE__ */ new Map();
  /**
   * Get or create a controller for a layer
   */
  getController(layerId, config, seed) {
    let controller = this.controllers.get(layerId);
    if (!controller) {
      controller = new ParticleSimulationController(config, seed ?? this.generateSeed(layerId));
      this.controllers.set(layerId, controller);
    }
    return controller;
  }
  /**
   * Evaluate particles for a layer at a frame
   */
  evaluateLayer(layerId, frame, config, seed) {
    const controller = this.getController(layerId, config, seed);
    return controller.evaluateAtFrame(frame);
  }
  /**
   * Reset a specific layer's controller
   */
  resetLayer(layerId) {
    const controller = this.controllers.get(layerId);
    if (controller) {
      controller.reset();
    }
  }
  /**
   * Clear all controllers
   */
  clear() {
    this.controllers.clear();
  }
  /**
   * Generate deterministic seed from layer ID
   */
  generateSeed(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
const particleSimulationRegistry = new ParticleSimulationRegistry();

const SHAKE_PRESETS = {
  handheld: {
    intensity: 0.3,
    frequency: 1,
    rotationEnabled: true,
    rotationScale: 0.5,
    decay: 0
  },
  impact: {
    intensity: 0.8,
    frequency: 3,
    rotationEnabled: true,
    rotationScale: 1,
    decay: 0.9
  },
  earthquake: {
    intensity: 0.6,
    frequency: 2,
    rotationEnabled: true,
    rotationScale: 0.3,
    decay: 0.5
  },
  subtle: {
    intensity: 0.1,
    frequency: 0.5,
    rotationEnabled: false,
    rotationScale: 0,
    decay: 0
  },
  custom: {}
};
const DEFAULT_SHAKE_CONFIG = {
  intensity: 0.3,
  frequency: 1,
  rotationEnabled: true,
  rotationScale: 0.5,
  seed: 12345,
  decay: 0,
  type: "handheld"
};
const DEFAULT_RACK_FOCUS = {
  startDistance: 1e3,
  endDistance: 2e3,
  duration: 30,
  startFrame: 0,
  easing: "ease-in-out",
  holdStart: 0,
  holdEnd: 0
};
class CameraShake {
  noise2D;
  noise3D;
  config;
  startFrame;
  duration;
  constructor(config = {}, startFrame = 0, duration = Infinity) {
    this.config = { ...DEFAULT_SHAKE_CONFIG, ...SHAKE_PRESETS[config.type || "handheld"], ...config };
    this.startFrame = startFrame;
    this.duration = duration;
    const seedFn = () => this.config.seed / 1e5;
    this.noise2D = createNoise2D(seedFn);
    this.noise3D = createNoise3D(seedFn);
  }
  /**
   * Get shake offset for a specific frame
   */
  getOffset(frame) {
    const relativeFrame = frame - this.startFrame;
    if (relativeFrame < 0 || relativeFrame > this.duration) {
      return {
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      };
    }
    const { intensity, frequency, rotationEnabled, rotationScale, decay } = this.config;
    const decayFactor = decay > 0 ? 1 - relativeFrame / this.duration * decay : 1;
    const time = relativeFrame * frequency * 0.1;
    const scale = intensity * decayFactor * 10;
    const posX = (this.noise2D(time, 0) * 0.5 + this.noise2D(time * 2.3, 100) * 0.3 + this.noise2D(time * 5.7, 200) * 0.2) * scale;
    const posY = (this.noise2D(time, 1e3) * 0.5 + this.noise2D(time * 2.1, 1100) * 0.3 + this.noise2D(time * 4.9, 1200) * 0.2) * scale;
    const posZ = (this.noise2D(time, 2e3) * 0.3 + this.noise2D(time * 1.7, 2100) * 0.2) * scale * 0.5;
    let rotation = { x: 0, y: 0, z: 0 };
    if (rotationEnabled) {
      const rotScale = rotationScale * decayFactor * 2;
      rotation = {
        x: this.noise2D(time, 3e3) * rotScale,
        y: this.noise2D(time, 4e3) * rotScale,
        z: this.noise2D(time, 5e3) * rotScale * 0.5
        // Less roll
      };
    }
    return {
      position: { x: posX, y: posY, z: posZ },
      rotation
    };
  }
  /**
   * Apply shake to camera
   */
  applyToCamera(camera, frame) {
    const offset = this.getOffset(frame);
    return {
      ...camera,
      position: {
        x: camera.position.x + offset.position.x,
        y: camera.position.y + offset.position.y,
        z: camera.position.z + offset.position.z
      },
      xRotation: camera.xRotation + offset.rotation.x,
      yRotation: camera.yRotation + offset.rotation.y,
      zRotation: camera.zRotation + offset.rotation.z
    };
  }
  /**
   * Generate keyframes with shake applied
   */
  generateKeyframes(baseKeyframes, interval = 1) {
    const result = [];
    const frames = /* @__PURE__ */ new Set();
    for (const kf of baseKeyframes) {
      frames.add(kf.frame);
    }
    const minFrame = Math.min(...frames);
    const maxFrame = Math.max(...frames);
    for (let f = minFrame; f <= maxFrame; f += interval) {
      frames.add(f);
    }
    const sortedFrames = Array.from(frames).sort((a, b) => a - b);
    for (const frame of sortedFrames) {
      const base = this.interpolateBaseKeyframe(baseKeyframes, frame);
      const offset = this.getOffset(frame);
      const keyframe = {
        frame,
        temporalInterpolation: "linear"
      };
      if (base.position) {
        keyframe.position = {
          x: base.position.x + offset.position.x,
          y: base.position.y + offset.position.y,
          z: base.position.z + offset.position.z
        };
      }
      if (base.xRotation !== void 0) {
        keyframe.xRotation = base.xRotation + offset.rotation.x;
      }
      if (base.yRotation !== void 0) {
        keyframe.yRotation = base.yRotation + offset.rotation.y;
      }
      if (base.zRotation !== void 0) {
        keyframe.zRotation = base.zRotation + offset.rotation.z;
      }
      result.push(keyframe);
    }
    return result;
  }
  interpolateBaseKeyframe(keyframes, frame) {
    if (keyframes.length === 0) return {};
    if (keyframes.length === 1) return keyframes[0];
    let before = null;
    let after = null;
    for (const kf of keyframes) {
      if (kf.frame <= frame) {
        if (!before || kf.frame > before.frame) before = kf;
      }
      if (kf.frame >= frame) {
        if (!after || kf.frame < after.frame) after = kf;
      }
    }
    if (!before) return after || {};
    if (!after) return before;
    if (before.frame === after.frame) return before;
    const t = (frame - before.frame) / (after.frame - before.frame);
    return {
      frame,
      position: before.position && after.position ? {
        x: before.position.x + (after.position.x - before.position.x) * t,
        y: before.position.y + (after.position.y - before.position.y) * t,
        z: before.position.z + (after.position.z - before.position.z) * t
      } : before.position || after.position,
      xRotation: before.xRotation !== void 0 && after.xRotation !== void 0 ? before.xRotation + (after.xRotation - before.xRotation) * t : before.xRotation ?? after.xRotation,
      yRotation: before.yRotation !== void 0 && after.yRotation !== void 0 ? before.yRotation + (after.yRotation - before.yRotation) * t : before.yRotation ?? after.yRotation,
      zRotation: before.zRotation !== void 0 && after.zRotation !== void 0 ? before.zRotation + (after.zRotation - before.zRotation) * t : before.zRotation ?? after.zRotation
    };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
function getRackFocusDistance(config, frame) {
  const { startDistance, endDistance, duration, startFrame, easing, holdStart, holdEnd } = config;
  const endFrame = startFrame + holdStart + duration + holdEnd;
  if (frame < startFrame) {
    return startDistance;
  }
  if (frame < startFrame + holdStart) {
    return startDistance;
  }
  if (frame >= endFrame) {
    return endDistance;
  }
  if (frame >= startFrame + holdStart + duration) {
    return endDistance;
  }
  const transitionFrame = frame - startFrame - holdStart;
  const t = transitionFrame / duration;
  const easedT = applyRackEasing(t, easing);
  return startDistance + (endDistance - startDistance) * easedT;
}
function applyRackEasing(t, easing) {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t * t;
    case "ease-out":
      return 1 - Math.pow(1 - t, 3);
    case "ease-in-out":
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    case "snap":
      return t < 0.8 ? t * 0.1 : 0.1 + (t - 0.8) * 4.5;
    default:
      return t;
  }
}
function generateRackFocusKeyframes(config, interval = 2) {
  const keyframes = [];
  const { startFrame, duration, holdStart, holdEnd } = config;
  const totalDuration = holdStart + duration + holdEnd;
  const endFrame = startFrame + totalDuration;
  for (let frame = startFrame; frame <= endFrame; frame += interval) {
    keyframes.push({
      frame,
      focusDistance: getRackFocusDistance(config, frame),
      temporalInterpolation: "linear"
    });
  }
  if (keyframes[keyframes.length - 1].frame !== endFrame) {
    keyframes.push({
      frame: endFrame,
      focusDistance: getRackFocusDistance(config, endFrame),
      temporalInterpolation: "linear"
    });
  }
  return keyframes;
}
function createCameraShake(type, overrides, startFrame, duration) {
  return new CameraShake(
    { type, ...overrides },
    startFrame,
    duration
  );
}
function createRackFocus(startDistance, endDistance, duration, options) {
  return {
    ...DEFAULT_RACK_FOCUS,
    startDistance,
    endDistance,
    duration,
    ...options
  };
}

class FrameStateCache {
  cache = /* @__PURE__ */ new Map();
  maxSize;
  maxAgeMs;
  constructor(maxSize = 120, maxAgeMs = 3e4) {
    this.maxSize = maxSize;
    this.maxAgeMs = maxAgeMs;
  }
  /**
   * Generate cache key from frame + composition ID
   */
  makeKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Compute a lightweight hash of project state that affects rendering
   * Changes to layers, keyframes, or effects invalidate the cache
   */
  computeProjectHash(project) {
    const comp = project.compositions[project.mainCompositionId];
    if (!comp) return "";
    let hash = 0;
    const str = JSON.stringify({
      layerCount: comp.layers.length,
      layerIds: comp.layers.map((l) => l.id),
      modified: project.meta?.modified || "",
      // Include layer visibility and animation state in hash
      layerStates: comp.layers.map((l) => ({
        id: l.id,
        visible: l.visible,
        startFrame: l.startFrame ?? l.inPoint ?? 0,
        endFrame: l.endFrame ?? l.outPoint ?? 80,
        kfCount: l.properties.reduce((sum, p) => sum + (p.keyframes?.length || 0), 0)
      }))
    });
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  /**
   * Get cached frame state if valid
   */
  get(frame, compositionId, projectHash) {
    const key = this.makeKey(frame, compositionId);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (entry.projectHash !== projectHash || now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.frameState;
  }
  /**
   * Store frame state in cache
   */
  set(frame, compositionId, projectHash, frameState) {
    const key = this.makeKey(frame, compositionId);
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, {
      frameState,
      projectHash,
      timestamp: Date.now()
    });
  }
  /**
   * Invalidate all cached entries
   * Call when project structure changes (layer add/remove, etc.)
   */
  invalidate() {
    this.cache.clear();
  }
  /**
   * Invalidate entries for a specific composition
   */
  invalidateComposition(compositionId) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${compositionId}:`)) {
        this.cache.delete(key);
      }
    }
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: 0
      // Would need hit/miss tracking
    };
  }
}
class MotionEngine {
  /**
   * Frame state cache for memoization
   * Dramatically improves scrubbing performance (90%+ for repeated frames)
   */
  frameCache = new FrameStateCache();
  lastProjectHash = "";
  /**
   * Invalidate the frame cache
   * Call this when project structure changes
   */
  invalidateCache() {
    this.frameCache.invalidate();
    this.lastProjectHash = "";
  }
  /**
   * Get cache statistics for debugging
   */
  getCacheStats() {
    return this.frameCache.getStats();
  }
  /**
   * Evaluate complete frame state
   *
   * PURE FUNCTION: Same inputs always produce same outputs
   * NO SIDE EFFECTS: Does not mutate project, layers, or any external state
   *
   * @param frame - Absolute frame number (0-indexed)
   * @param project - The project data (read-only)
   * @param audioAnalysis - Pre-computed audio analysis (optional)
   * @param activeCameraId - ID of active camera layer (optional)
   * @param useCache - Whether to use memoization cache (default: true)
   * @returns Immutable FrameState snapshot
   */
  evaluate(frame, project, audioAnalysis, activeCameraId, useCache = true) {
    const composition = project.compositions[project.mainCompositionId];
    if (!composition) {
      return this.createEmptyFrameState(frame, project.composition);
    }
    const projectHash = useCache ? this.frameCache.computeProjectHash(project) : "";
    if (useCache) {
      const cached = this.frameCache.get(frame, project.mainCompositionId, projectHash);
      if (cached) {
        return cached;
      }
    }
    const evaluatedLayers = this.evaluateLayers(frame, composition.layers);
    const evaluatedCamera = this.evaluateCamera(
      frame,
      composition.layers,
      activeCameraId ?? null,
      composition.settings
    );
    const evaluatedAudio = this.evaluateAudio(frame, audioAnalysis ?? null);
    const particleSnapshots = this.evaluateParticleLayers(frame, composition.layers);
    const frameState = Object.freeze({
      frame,
      composition: composition.settings,
      layers: Object.freeze(evaluatedLayers),
      camera: evaluatedCamera,
      audio: evaluatedAudio,
      particleSnapshots: Object.freeze(particleSnapshots)
    });
    if (useCache) {
      this.frameCache.set(frame, project.mainCompositionId, projectHash, frameState);
    }
    return frameState;
  }
  /**
   * Evaluate a single property at a given frame
   * Utility method for UI components that need individual values
   */
  evaluateProperty(property, frame) {
    return interpolateProperty(property, frame);
  }
  /**
   * Check if a layer is visible at a given frame
   */
  isLayerVisibleAtFrame(layer, frame) {
    const start = layer.startFrame ?? layer.inPoint ?? 0;
    const end = layer.endFrame ?? layer.outPoint ?? 80;
    return layer.visible && frame >= start && frame <= end;
  }
  // ============================================================================
  // PRIVATE EVALUATION METHODS
  // ============================================================================
  evaluateLayers(frame, layers) {
    const evaluated = [];
    for (const layer of layers) {
      const start = layer.startFrame ?? layer.inPoint ?? 0;
      const end = layer.endFrame ?? layer.outPoint ?? 80;
      const inRange = frame >= start && frame <= end;
      const visible = layer.visible && inRange;
      const transform = this.evaluateTransform(frame, layer.transform, layer.threeD);
      const opacity = interpolateProperty(layer.opacity, frame);
      const effects = this.evaluateEffects(frame, layer.effects);
      const properties = this.evaluateLayerProperties(frame, layer);
      evaluated.push(Object.freeze({
        id: layer.id,
        type: layer.type,
        name: layer.name,
        frame,
        // Include frame number for layers that need simulation (particles)
        visible,
        inRange,
        opacity,
        transform: Object.freeze(transform),
        effects: Object.freeze(effects),
        properties: Object.freeze(properties),
        parentId: layer.parentId,
        blendMode: layer.blendMode,
        threeD: layer.threeD,
        layerRef: layer
        // Reference for static data only - NOT for evaluation
      }));
    }
    return evaluated;
  }
  evaluateTransform(frame, transform, is3D) {
    const position = interpolateProperty(transform.position, frame);
    const originProp = transform.origin || transform.anchorPoint;
    const origin = originProp ? interpolateProperty(originProp, frame) : { x: 0, y: 0, z: 0 };
    const scale = interpolateProperty(transform.scale, frame);
    const rotation = interpolateProperty(transform.rotation, frame);
    const result = {
      position: { ...position },
      origin: { ...origin },
      // Keep anchorPoint alias for backwards compatibility
      anchorPoint: { ...origin },
      scale: { ...scale },
      rotation
    };
    if (is3D) {
      return {
        ...result,
        rotationX: transform.rotationX ? interpolateProperty(transform.rotationX, frame) : 0,
        rotationY: transform.rotationY ? interpolateProperty(transform.rotationY, frame) : 0,
        rotationZ: transform.rotationZ ? interpolateProperty(transform.rotationZ, frame) : rotation
      };
    }
    return result;
  }
  evaluateEffects(frame, effects) {
    return effects.map((effect) => {
      const evaluatedParams = {};
      for (const [key, param] of Object.entries(effect.parameters)) {
        if (this.isAnimatableProperty(param)) {
          evaluatedParams[key] = interpolateProperty(param, frame);
        } else {
          evaluatedParams[key] = param;
        }
      }
      return Object.freeze({
        id: effect.id,
        type: effect.effectKey,
        // Use effectKey as the effect type identifier
        enabled: effect.enabled,
        parameters: Object.freeze(evaluatedParams)
      });
    });
  }
  evaluateLayerProperties(frame, layer) {
    const evaluated = {};
    for (const prop of layer.properties) {
      evaluated[prop.name] = interpolateProperty(prop, frame);
    }
    switch (layer.type) {
      case "text":
        break;
      case "solid":
        break;
      case "depthflow":
        if (layer.data && "animatedZoom" in layer.data) {
          const data = layer.data;
          if (data.animatedZoom) {
            evaluated["zoom"] = interpolateProperty(data.animatedZoom, frame);
          }
          if (data.animatedOffsetX) {
            evaluated["offsetX"] = interpolateProperty(data.animatedOffsetX, frame);
          }
          if (data.animatedOffsetY) {
            evaluated["offsetY"] = interpolateProperty(data.animatedOffsetY, frame);
          }
          if (data.animatedRotation) {
            evaluated["rotation"] = interpolateProperty(data.animatedRotation, frame);
          }
        }
        break;
      case "particles":
        evaluated["_requiresSimulation"] = true;
        break;
    }
    return evaluated;
  }
  evaluateCamera(frame, layers, activeCameraId, compositionSettings) {
    let cameraLayer;
    if (activeCameraId) {
      cameraLayer = layers.find(
        (l) => l.id === activeCameraId && l.type === "camera"
      );
    }
    if (!cameraLayer) {
      cameraLayer = layers.find(
        (l) => l.type === "camera" && l.visible && frame >= (l.startFrame ?? l.inPoint ?? 0) && frame <= (l.endFrame ?? l.outPoint ?? 80)
      );
    }
    if (!cameraLayer || !cameraLayer.data) {
      return null;
    }
    const cameraData = cameraLayer.data;
    const transform = this.evaluateTransform(frame, cameraLayer.transform, true);
    const compWidth = compositionSettings?.width ?? 1024;
    const compHeight = compositionSettings?.height ?? 1024;
    const centerX = compWidth / 2;
    const centerY = compHeight / 2;
    let position = { x: transform.position.x, y: transform.position.y, z: 0 };
    let target = { x: centerX, y: centerY, z: 0 };
    let fov = 50;
    let focalLength = 50;
    if (cameraData.animatedPosition) {
      const pos = interpolateProperty(cameraData.animatedPosition, frame);
      position = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    }
    if (cameraData.animatedTarget) {
      const tgt = interpolateProperty(cameraData.animatedTarget, frame);
      target = { x: tgt.x, y: tgt.y, z: tgt.z ?? 0 };
    }
    if (cameraData.animatedFov) {
      fov = interpolateProperty(cameraData.animatedFov, frame);
    }
    if (cameraData.animatedFocalLength) {
      focalLength = interpolateProperty(cameraData.animatedFocalLength, frame);
    }
    let focusDistance = cameraData.depthOfField?.focusDistance ?? 1e3;
    let aperture = cameraData.depthOfField?.aperture ?? 2.8;
    let blurLevel = cameraData.depthOfField?.blurLevel ?? 50;
    if (cameraData.animatedFocusDistance) {
      focusDistance = interpolateProperty(cameraData.animatedFocusDistance, frame);
    }
    if (cameraData.animatedAperture) {
      aperture = interpolateProperty(cameraData.animatedAperture, frame);
    }
    if (cameraData.animatedBlurLevel) {
      blurLevel = interpolateProperty(cameraData.animatedBlurLevel, frame);
    }
    if (cameraData.trajectoryKeyframes) {
      const trajKfs = cameraData.trajectoryKeyframes;
      if (trajKfs.position && trajKfs.position.length > 0) {
        const posKfs = trajKfs.position;
        let before = posKfs[0];
        let after = posKfs[posKfs.length - 1];
        for (const kf of posKfs) {
          if (kf.frame <= frame && kf.frame >= before.frame) before = kf;
          if (kf.frame >= frame && kf.frame <= after.frame) after = kf;
        }
        if (before.frame === after.frame || frame <= before.frame) {
          position = { ...before.position };
        } else if (frame >= after.frame) {
          position = { ...after.position };
        } else {
          const t = (frame - before.frame) / (after.frame - before.frame);
          position = {
            x: before.position.x + (after.position.x - before.position.x) * t,
            y: before.position.y + (after.position.y - before.position.y) * t,
            z: before.position.z + (after.position.z - before.position.z) * t
          };
        }
      }
      if (trajKfs.pointOfInterest && trajKfs.pointOfInterest.length > 0) {
        const poiKfs = trajKfs.pointOfInterest;
        let before = poiKfs[0];
        let after = poiKfs[poiKfs.length - 1];
        for (const kf of poiKfs) {
          if (kf.frame <= frame && kf.frame >= before.frame) before = kf;
          if (kf.frame >= frame && kf.frame <= after.frame) after = kf;
        }
        if (before.frame === after.frame || frame <= before.frame) {
          target = { ...before.pointOfInterest };
        } else if (frame >= after.frame) {
          target = { ...after.pointOfInterest };
        } else {
          const t = (frame - before.frame) / (after.frame - before.frame);
          target = {
            x: before.pointOfInterest.x + (after.pointOfInterest.x - before.pointOfInterest.x) * t,
            y: before.pointOfInterest.y + (after.pointOfInterest.y - before.pointOfInterest.y) * t,
            z: before.pointOfInterest.z + (after.pointOfInterest.z - before.pointOfInterest.z) * t
          };
        }
      }
    }
    if (cameraData.shake?.enabled) {
      const shakeData = cameraData.shake;
      const shake = new CameraShake(
        {
          type: shakeData.type,
          intensity: shakeData.intensity,
          frequency: shakeData.frequency,
          rotationEnabled: shakeData.rotationEnabled,
          rotationScale: shakeData.rotationScale,
          seed: shakeData.seed,
          decay: shakeData.decay
        },
        shakeData.startFrame,
        shakeData.duration
      );
      const offset = shake.getOffset(frame);
      position = {
        x: position.x + offset.position.x,
        y: position.y + offset.position.y,
        z: position.z + offset.position.z
      };
    }
    if (cameraData.rackFocus?.enabled) {
      const rf = cameraData.rackFocus;
      focusDistance = getRackFocusDistance(
        {
          startDistance: rf.startDistance,
          endDistance: rf.endDistance,
          duration: rf.duration,
          startFrame: rf.startFrame,
          easing: rf.easing,
          holdStart: rf.holdStart,
          holdEnd: rf.holdEnd
        },
        frame
      );
    }
    return Object.freeze({
      id: cameraLayer.id,
      name: cameraLayer.name,
      position: Object.freeze(position),
      target: Object.freeze(target),
      fov,
      focalLength,
      depthOfField: Object.freeze({
        enabled: cameraData.depthOfField?.enabled ?? false,
        focusDistance,
        aperture,
        blurLevel
      })
    });
  }
  evaluateAudio(frame, analysis) {
    if (!analysis) {
      return Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      });
    }
    return Object.freeze({
      hasAudio: true,
      amplitude: getFeatureAtFrame(analysis, "amplitude", frame),
      rms: getFeatureAtFrame(analysis, "rms", frame),
      bass: getFeatureAtFrame(analysis, "bass", frame),
      mid: getFeatureAtFrame(analysis, "mid", frame),
      high: getFeatureAtFrame(analysis, "high", frame),
      spectralCentroid: getFeatureAtFrame(analysis, "spectralCentroid", frame),
      isBeat: getFeatureAtFrame(analysis, "onsets", frame) > 0.5,
      isOnset: getFeatureAtFrame(analysis, "onsets", frame) > 0,
      bpm: analysis.bpm
    });
  }
  /**
   * Evaluate particle layers through deterministic simulation
   * DETERMINISM: Uses ParticleSimulationRegistry which guarantees same frame = same result
   */
  evaluateParticleLayers(frame, layers) {
    const snapshots = {};
    for (const layer of layers) {
      if (layer.type !== "particles" || !layer.visible) continue;
      const start = layer.startFrame ?? layer.inPoint ?? 0;
      const end = layer.endFrame ?? layer.outPoint ?? 80;
      if (frame < start || frame > end) continue;
      const data = layer.data;
      if (!data?.systemConfig) continue;
      const config = this.convertToParticleSystemConfig(data);
      const relativeFrame = frame - start;
      const snapshot = particleSimulationRegistry.evaluateLayer(
        layer.id,
        relativeFrame,
        config
      );
      snapshots[layer.id] = snapshot;
    }
    return snapshots;
  }
  /**
   * Convert ParticleLayerData to ParticleSystemConfig
   * Maps the project-level configuration to the simulation config
   */
  convertToParticleSystemConfig(data) {
    const sys = data.systemConfig;
    return {
      maxParticles: sys.maxParticles,
      gravity: sys.gravity,
      windStrength: sys.windStrength,
      windDirection: sys.windDirection,
      warmupPeriod: sys.warmupPeriod,
      respectMaskBoundary: sys.respectMaskBoundary,
      boundaryBehavior: sys.boundaryBehavior,
      friction: sys.friction,
      turbulenceFields: sys.turbulenceFields ?? [],
      subEmitters: sys.subEmitters ?? [],
      collision: {
        enabled: false,
        particleCollision: false,
        particleCollisionRadius: 1,
        particleCollisionResponse: "bounce",
        particleCollisionDamping: 0.5,
        layerCollision: false,
        layerCollisionLayerId: null,
        layerCollisionThreshold: 0.5,
        floorEnabled: false,
        floorY: 1,
        ceilingEnabled: false,
        ceilingY: 0,
        wallsEnabled: false,
        bounciness: 0.8,
        friction: 0.1,
        spatialHashCellSize: 32
      }
    };
  }
  /**
   * Create empty frame state for missing compositions
   * DETERMINISM: No timestamps or non-deterministic values
   */
  createEmptyFrameState(frame, settings) {
    return Object.freeze({
      frame,
      composition: settings,
      layers: Object.freeze([]),
      camera: null,
      audio: Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      }),
      particleSnapshots: Object.freeze({})
    });
  }
  /**
   * Type guard to check if a value is an AnimatableProperty
   */
  isAnimatableProperty(value) {
    return typeof value === "object" && value !== null && "value" in value && "keyframes" in value && Array.isArray(value.keyframes);
  }
}
const motionEngine = new MotionEngine();

const easingFunctions = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (t) => t,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return c3 * t * t * t - c1 * t * t;
  },
  easeOutBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  },
  easeInOutBack: (t) => {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;
    return t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
  },
  easeOutElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  },
  easeInOutElastic: (t) => {
    const c5 = 2 * Math.PI / 4.5;
    return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (t) => 1 - easingFunctions.easeOutBounce(1 - t),
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInOutBounce: (t) => t < 0.5 ? (1 - easingFunctions.easeOutBounce(1 - 2 * t)) / 2 : (1 + easingFunctions.easeOutBounce(2 * t - 1)) / 2
};

class KeyframeEvaluator {
  // Cache for recent evaluations (cleared per frame batch)
  cache = /* @__PURE__ */ new Map();
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(property, frame) {
    const cacheKey = property.id;
    const cached = this.cache.get(cacheKey);
    if (cached && cached.frame === frame) {
      return cached.value;
    }
    let value;
    if (!property.animated || !property.keyframes || property.keyframes.length === 0) {
      value = property.value;
    } else {
      value = this.evaluateKeyframes(property.keyframes, frame, property.value);
    }
    this.cache.set(cacheKey, { frame, value });
    return value;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(keyframes, frame, defaultValue) {
    const sorted = [...keyframes].sort((a, b) => a.frame - b.frame);
    if (frame <= sorted[0].frame) {
      return sorted[0].value;
    }
    if (frame >= sorted[sorted.length - 1].frame) {
      return sorted[sorted.length - 1].value;
    }
    let prevKeyframe = sorted[0];
    let nextKeyframe = sorted[sorted.length - 1];
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i].frame <= frame && sorted[i + 1].frame > frame) {
        prevKeyframe = sorted[i];
        nextKeyframe = sorted[i + 1];
        break;
      }
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const rawT = frameDiff > 0 ? (frame - prevKeyframe.frame) / frameDiff : 0;
    const easedT = this.applyEasing(rawT, prevKeyframe.interpolation, prevKeyframe, nextKeyframe);
    return this.interpolateValue(prevKeyframe.value, nextKeyframe.value, easedT, defaultValue);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(t, interpolation, prevKeyframe, nextKeyframe) {
    switch (interpolation) {
      case "hold":
        return 0;
      case "linear":
        return t;
      case "bezier":
        return this.evaluateBezier(t, prevKeyframe, nextKeyframe);
      default:
        const easingFn = easingFunctions[interpolation];
        if (easingFn) {
          return easingFn(t);
        }
        return t;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(t, prevKeyframe, nextKeyframe) {
    const outHandle = prevKeyframe.outHandle;
    const inHandle = nextKeyframe.inHandle;
    if (!outHandle?.enabled && !inHandle?.enabled) {
      return t;
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const p0 = { x: 0, y: 0 };
    const p1 = {
      x: outHandle?.enabled ? Math.min(1, Math.max(0, outHandle.frame / frameDiff)) : 0.33,
      y: outHandle?.enabled ? outHandle.value : 0
    };
    const p2 = {
      x: inHandle?.enabled ? Math.min(1, Math.max(0, 1 + inHandle.frame / frameDiff)) : 0.67,
      y: inHandle?.enabled ? 1 + inHandle.value : 1
    };
    const p3 = { x: 1, y: 1 };
    return this.solveCubicBezier(t, p0.x, p1.x, p2.x, p3.x, p0.y, p1.y, p2.y, p3.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(x, x0, x1, x2, x3, y0, y1, y2, y3) {
    let t = x;
    const epsilon = 1e-4;
    for (let i = 0; i < 10; i++) {
      const currentX = this.cubicBezier(t, x0, x1, x2, x3);
      const diff = currentX - x;
      if (Math.abs(diff) < epsilon) {
        break;
      }
      const derivative = this.cubicBezierDerivative(t, x0, x1, x2, x3);
      if (Math.abs(derivative) < epsilon) {
        break;
      }
      t -= diff / derivative;
      t = Math.max(0, Math.min(1, t));
    }
    return this.cubicBezier(t, y0, y1, y2, y3);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(from, to, t, defaultValue) {
    if (typeof from === "number" && typeof to === "number") {
      return from + (to - from) * t;
    }
    if (this.isPositionLike(from) && this.isPositionLike(to)) {
      return this.interpolatePosition(from, to, t);
    }
    if (typeof from === "string" && typeof to === "string") {
      if (from.startsWith("#") && to.startsWith("#")) {
        return this.interpolateColor(from, to, t);
      }
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return this.interpolateArray(from, to, t);
    }
    return t < 0.5 ? from : to;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(value) {
    return value !== null && typeof value === "object" && "x" in value && "y" in value;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(from, to, t) {
    const result = {
      x: from.x + (to.x - from.x) * t,
      y: from.y + (to.y - from.y) * t
    };
    if ("z" in from || "z" in to) {
      result.z = (from.z ?? 0) + ((to.z ?? 0) - (from.z ?? 0)) * t;
    }
    return result;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(from, to, t) {
    const fromRGB = this.hexToRGB(from);
    const toRGB = this.hexToRGB(to);
    const r = Math.round(fromRGB.r + (toRGB.r - fromRGB.r) * t);
    const g = Math.round(fromRGB.g + (toRGB.g - fromRGB.g) * t);
    const b = Math.round(fromRGB.b + (toRGB.b - fromRGB.b) * t);
    return this.rgbToHex(r, g, b);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(from, to, t) {
    const length = Math.max(from.length, to.length);
    const result = [];
    for (let i = 0; i < length; i++) {
      const fromVal = from[i] ?? 0;
      const toVal = to[i] ?? 0;
      result.push(fromVal + (toVal - fromVal) * t);
    }
    return result;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(r, g, b) {
    return "#" + [r, g, b].map((x) => Math.max(0, Math.min(255, x)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}

class CanvasPool {
  pool = [];
  maxSize = 20;
  // Max pooled canvases
  maxAge = 6e4;
  // 60 second TTL for unused canvases
  /**
   * Acquire a canvas of the specified dimensions
   */
  acquire(width, height) {
    const now = Date.now();
    for (const item of this.pool) {
      if (!item.inUse && item.width === width && item.height === height) {
        item.inUse = true;
        item.lastUsed = now;
        item.ctx.clearRect(0, 0, width, height);
        return { canvas: item.canvas, ctx: item.ctx };
      }
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (this.pool.length < this.maxSize) {
      this.pool.push({
        canvas,
        ctx,
        width,
        height,
        inUse: true,
        lastUsed: now
      });
    }
    return { canvas, ctx };
  }
  /**
   * Release a canvas back to the pool
   * Call this when done with an effect result
   */
  release(canvas) {
    const item = this.pool.find((p) => p.canvas === canvas);
    if (item) {
      item.inUse = false;
      item.lastUsed = Date.now();
    }
  }
  /**
   * Clean up old unused canvases to free memory
   */
  cleanup() {
    const now = Date.now();
    this.pool = this.pool.filter((item) => {
      if (!item.inUse && now - item.lastUsed > this.maxAge) {
        return false;
      }
      return true;
    });
  }
  /**
   * Clear all pooled canvases
   */
  clear() {
    this.pool = [];
  }
  /**
   * Get pool statistics
   */
  getStats() {
    const inUse = this.pool.filter((p) => p.inUse).length;
    return {
      total: this.pool.length,
      inUse,
      available: this.pool.length - inUse
    };
  }
}
const canvasPool = new CanvasPool();
const effectRenderers = /* @__PURE__ */ new Map();
function registerEffectRenderer(effectKey, renderer) {
  effectRenderers.set(effectKey, renderer);
}
function evaluateEffectParameters(effect, frame) {
  const evaluated = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    const animatableProp = param;
    evaluated[key] = interpolateProperty(animatableProp, frame);
  }
  return evaluated;
}
function processEffectStack(effects, inputCanvas, frame, quality = "high", context) {
  const workCanvas = document.createElement("canvas");
  workCanvas.width = inputCanvas.width;
  workCanvas.height = inputCanvas.height;
  const workCtx = workCanvas.getContext("2d");
  workCtx.drawImage(inputCanvas, 0, 0);
  let current = {
    canvas: workCanvas,
    ctx: workCtx
  };
  for (const effect of effects) {
    if (!effect.enabled) {
      continue;
    }
    const renderer = effectRenderers.get(effect.effectKey);
    if (!renderer) {
      renderLogger.warn(`No renderer registered for effect: ${effect.effectKey}`);
      continue;
    }
    const params = evaluateEffectParameters(effect, frame);
    if (context) {
      params._frame = context.frame;
      params._fps = context.fps;
      params._layerId = context.layerId;
      if (context.compositionId) {
        params._compositionId = context.compositionId;
      }
    } else {
      params._frame = frame;
      params._fps = 30;
      params._layerId = "default";
    }
    try {
      current = renderer(current, params);
    } catch (error) {
      renderLogger.error(`Error applying effect ${effect.name}:`, error);
    }
  }
  return current;
}
function createMatchingCanvas(source) {
  return canvasPool.acquire(source.width, source.height);
}
function hasEnabledEffects(effects) {
  return effects.some((e) => e.enabled);
}

function renderMaskPath(ctx, path) {
  if (path.vertices.length < 2) return;
  ctx.beginPath();
  const vertices = path.vertices;
  const n = vertices.length;
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 0; i < n; i++) {
    const current = vertices[i];
    const next = vertices[(i + 1) % n];
    if (!path.closed && i === n - 1) break;
    const cp1x = current.x + current.outTangentX;
    const cp1y = current.y + current.outTangentY;
    const cp2x = next.x + next.inTangentX;
    const cp2y = next.y + next.inTangentY;
    if (cp1x === current.x && cp1y === current.y && cp2x === next.x && cp2y === next.y) {
      ctx.lineTo(next.x, next.y);
    } else {
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
    }
  }
  if (path.closed) {
    ctx.closePath();
  }
}
function calculateVertexNormal(prev, curr, next) {
  let inDx, inDy;
  if (curr.inTangentX || curr.inTangentY) {
    inDx = -curr.inTangentX;
    inDy = -curr.inTangentY;
  } else {
    inDx = curr.x - prev.x;
    inDy = curr.y - prev.y;
  }
  let outDx, outDy;
  if (curr.outTangentX || curr.outTangentY) {
    outDx = curr.outTangentX;
    outDy = curr.outTangentY;
  } else {
    outDx = next.x - curr.x;
    outDy = next.y - curr.y;
  }
  const inLen = Math.sqrt(inDx * inDx + inDy * inDy);
  if (inLen > 0) {
    inDx /= inLen;
    inDy /= inLen;
  }
  const outLen = Math.sqrt(outDx * outDx + outDy * outDy);
  if (outLen > 0) {
    outDx /= outLen;
    outDy /= outLen;
  }
  const inNx = -inDy;
  const inNy = inDx;
  const outNx = -outDy;
  const outNy = outDx;
  let nx = (inNx + outNx) / 2;
  let ny = (inNy + outNy) / 2;
  const nLen = Math.sqrt(nx * nx + ny * ny);
  if (nLen > 0) {
    nx /= nLen;
    ny /= nLen;
  } else {
    nx = inNx;
    ny = inNy;
  }
  const dot = inNx * outNx + inNy * outNy;
  const miterFactor = 1 / Math.max(0.5, (1 + dot) / 2);
  return {
    nx: nx * Math.min(miterFactor, 2),
    ny: ny * Math.min(miterFactor, 2)
  };
}
function expandMaskPath(path, expansion) {
  if (expansion === 0) return path;
  const vertices = path.vertices;
  if (vertices.length < 2) return path;
  const expandedVertices = [];
  for (let i = 0; i < vertices.length; i++) {
    const prev = vertices[(i - 1 + vertices.length) % vertices.length];
    const curr = vertices[i];
    const next = vertices[(i + 1) % vertices.length];
    const effectivePrev = !path.closed && i === 0 ? curr : prev;
    const effectiveNext = !path.closed && i === vertices.length - 1 ? curr : next;
    const { nx, ny } = calculateVertexNormal(effectivePrev, curr, effectiveNext);
    const offsetX = nx * expansion;
    const offsetY = ny * expansion;
    const handleScale = 1 + expansion / 100;
    expandedVertices.push({
      x: curr.x + offsetX,
      y: curr.y + offsetY,
      // Scale handles to maintain curve shape
      inTangentX: curr.inTangentX * handleScale,
      inTangentY: curr.inTangentY * handleScale,
      outTangentX: curr.outTangentX * handleScale,
      outTangentY: curr.outTangentY * handleScale
    });
  }
  return { ...path, vertices: expandedVertices };
}
function calculateMaskMotion(currentPath, previousPath) {
  if (!previousPath || currentPath.vertices.length !== previousPath.vertices.length) {
    return currentPath.vertices.map(() => ({
      dx: 0,
      dy: 0,
      magnitude: 0,
      angle: 0
    }));
  }
  return currentPath.vertices.map((curr, i) => {
    const prev = previousPath.vertices[i];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    return { dx, dy, magnitude, angle };
  });
}
function applyMotionAwareFeather(canvas, baseFeather, motionVectors, motionScale = 1) {
  const width = canvas.width;
  const height = canvas.height;
  let avgDx = 0;
  let avgDy = 0;
  let avgMagnitude = 0;
  for (const motion of motionVectors) {
    avgDx += motion.dx;
    avgDy += motion.dy;
    avgMagnitude += motion.magnitude;
  }
  const count = motionVectors.length || 1;
  avgDx /= count;
  avgDy /= count;
  avgMagnitude /= count;
  if (avgMagnitude < 0.5) {
    if (baseFeather > 0) {
      const ctx2 = canvas.getContext("2d");
      const blurCanvas = document.createElement("canvas");
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext("2d");
      blurCtx.filter = `blur(${baseFeather}px)`;
      blurCtx.drawImage(canvas, 0, 0);
      ctx2.clearRect(0, 0, width, height);
      ctx2.drawImage(blurCanvas, 0, 0);
    }
    return canvas;
  }
  const motionFeather = avgMagnitude * motionScale;
  const len = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
  const normDx = len > 0 ? avgDx / len : 0;
  const normDy = len > 0 ? avgDy / len : 0;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = width;
  baseCanvas.height = height;
  const baseCtx = baseCanvas.getContext("2d");
  if (baseFeather > 0) {
    baseCtx.filter = `blur(${baseFeather}px)`;
  }
  baseCtx.drawImage(canvas, 0, 0);
  const steps = Math.max(3, Math.min(15, Math.ceil(motionFeather / 2)));
  resultCtx.globalAlpha = 1 / steps;
  for (let i = 0; i < steps; i++) {
    const t = i / (steps - 1) - 0.5;
    const offsetX = normDx * motionFeather * t;
    const offsetY = normDy * motionFeather * t;
    resultCtx.drawImage(baseCanvas, offsetX, offsetY);
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, width, height);
  ctx.globalAlpha = 1;
  ctx.drawImage(resultCanvas, 0, 0);
  return canvas;
}
const previousPathCache = /* @__PURE__ */ new Map();
function getPreviousPath(maskId, currentFrame) {
  const cached = previousPathCache.get(maskId);
  if (cached && cached.frame === currentFrame - 1) {
    return cached.path;
  }
  return null;
}
function cachePath(maskId, frame, path) {
  previousPathCache.set(maskId, { frame, path });
}
function renderMask(mask, width, height, frame) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);
  if (!mask.enabled) return canvas;
  const path = interpolateProperty(mask.path, frame);
  const expansion = interpolateProperty(mask.expansion, frame);
  const opacity = interpolateProperty(mask.opacity, frame);
  const feather = interpolateProperty(mask.feather, frame);
  const expandedPath = expandMaskPath(path, expansion);
  ctx.fillStyle = "white";
  renderMaskPath(ctx, expandedPath);
  ctx.fill();
  if (opacity < 100) {
    const opacityFactor = opacity / 100;
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = Math.round(imageData.data[i] * opacityFactor);
    }
    ctx.putImageData(imageData, 0, 0);
  }
  const previousPath = getPreviousPath(mask.id, frame);
  const motionVectors = calculateMaskMotion(path, previousPath);
  cachePath(mask.id, frame, path);
  const avgMotion = motionVectors.reduce((sum, v) => sum + v.magnitude, 0) / motionVectors.length;
  if (feather > 0 || avgMotion > 1) {
    applyMotionAwareFeather(canvas, feather, motionVectors, 0.5);
  }
  if (mask.inverted) {
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = 255 - imageData.data[i];
      imageData.data[i + 1] = 255 - imageData.data[i + 1];
      imageData.data[i + 2] = 255 - imageData.data[i + 2];
    }
    ctx.putImageData(imageData, 0, 0);
  }
  return canvas;
}
function combineMasks(masks, width, height, frame) {
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const enabledMasks = masks.filter((m) => m.enabled && m.mode !== "none");
  if (enabledMasks.length === 0) {
    resultCtx.fillStyle = "white";
    resultCtx.fillRect(0, 0, width, height);
    return resultCanvas;
  }
  resultCtx.fillStyle = "black";
  resultCtx.fillRect(0, 0, width, height);
  const resultData = resultCtx.getImageData(0, 0, width, height);
  const result = resultData.data;
  for (const mask of enabledMasks) {
    const maskCanvas = renderMask(mask, width, height, frame);
    const maskCtx = maskCanvas.getContext("2d");
    const maskData = maskCtx.getImageData(0, 0, width, height);
    const maskPixels = maskData.data;
    for (let i = 0; i < result.length; i += 4) {
      const maskValue = maskPixels[i];
      switch (mask.mode) {
        case "add":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "subtract":
          result[i] = Math.max(0, result[i] - maskValue);
          result[i + 1] = Math.max(0, result[i + 1] - maskValue);
          result[i + 2] = Math.max(0, result[i + 2] - maskValue);
          break;
        case "intersect":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "lighten":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "darken":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "difference":
          result[i] = Math.abs(result[i] - maskValue);
          result[i + 1] = Math.abs(result[i + 1] - maskValue);
          result[i + 2] = Math.abs(result[i + 2] - maskValue);
          break;
      }
    }
  }
  resultCtx.putImageData(resultData, 0, 0);
  return resultCanvas;
}
function applyTrackMatte(layerCanvas, matteCanvas, matteType) {
  if (matteType === "none") return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const matteScaled = document.createElement("canvas");
  matteScaled.width = width;
  matteScaled.height = height;
  const matteScaledCtx = matteScaled.getContext("2d");
  matteScaledCtx.drawImage(matteCanvas, 0, 0, width, height);
  const matteData = matteScaledCtx.getImageData(0, 0, width, height);
  const matte = matteData.data;
  for (let i = 0; i < layer.length; i += 4) {
    let matteValue;
    switch (matteType) {
      case "alpha":
        matteValue = matte[i + 3] / 255;
        break;
      case "alpha_inverted":
        matteValue = 1 - matte[i + 3] / 255;
        break;
      case "luma":
        matteValue = (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      case "luma_inverted":
        matteValue = 1 - (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      default:
        matteValue = 1;
    }
    layer[i + 3] = Math.round(layer[i + 3] * matteValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}
function applyMasksToLayer(layerCanvas, masks, frame) {
  if (!masks || masks.length === 0) return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const combinedMask = combineMasks(masks, width, height, frame);
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const maskCtx = combinedMask.getContext("2d");
  const maskData = maskCtx.getImageData(0, 0, width, height);
  const mask = maskData.data;
  for (let i = 0; i < layer.length; i += 4) {
    const maskValue = mask[i] / 255;
    layer[i + 3] = Math.round(layer[i + 3] * maskValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}

function createDefaultMotionBlurSettings() {
  return {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16,
    pixelBlurLength: 50,
    vectorDetail: 50,
    direction: 0,
    blurLength: 10,
    radialMode: "zoom",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    adaptiveThreshold: 2,
    motionBlurQuality: "normal",
    useGPU: true
  };
}
class MotionBlurProcessor {
  settings;
  frameBuffer = [];
  maxBufferSize = 5;
  // Cached canvases for compositing
  workCanvas;
  workCtx;
  outputCanvas;
  outputCtx;
  constructor(width, height, settings) {
    this.settings = { ...createDefaultMotionBlurSettings(), ...settings };
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
  }
  // ============================================================================
  // SETTINGS
  // ============================================================================
  setSettings(settings) {
    this.settings = { ...this.settings, ...settings };
  }
  getSettings() {
    return { ...this.settings };
  }
  resize(width, height) {
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
    this.frameBuffer = [];
  }
  // ============================================================================
  // VELOCITY CALCULATION
  // ============================================================================
  /**
   * Calculate velocity from transform changes between frames
   */
  calculateVelocity(prevTransform, currTransform, deltaTime = 1) {
    return {
      x: (currTransform.x - prevTransform.x) / deltaTime,
      y: (currTransform.y - prevTransform.y) / deltaTime,
      rotation: (currTransform.rotation - prevTransform.rotation) / deltaTime,
      scale: (currTransform.scaleX - prevTransform.scaleX + (currTransform.scaleY - prevTransform.scaleY)) / 2 / deltaTime
    };
  }
  /**
   * Get velocity magnitude
   */
  getVelocityMagnitude(velocity) {
    return Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
  }
  // ============================================================================
  // BLUR APPLICATION
  // ============================================================================
  /**
   * Apply motion blur to a canvas based on current settings
   */
  applyMotionBlur(sourceCanvas, velocity, frame) {
    if (!this.settings.enabled || this.settings.type === "none") {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    this.addFrameToBuffer(sourceCanvas, velocity, frame);
    switch (this.settings.type) {
      case "standard":
        return this.applyStandardBlur(sourceCanvas, velocity);
      case "pixel":
        return this.applyPixelMotionBlur(sourceCanvas);
      case "directional":
        return this.applyDirectionalBlur(sourceCanvas);
      case "radial":
        return this.applyRadialBlur(sourceCanvas);
      case "vector":
        return this.applyVectorBlur(sourceCanvas, velocity);
      case "adaptive":
        return this.applyAdaptiveBlur(sourceCanvas, velocity);
      default:
        this.outputCtx.drawImage(sourceCanvas, 0, 0);
        return this.outputCanvas;
    }
  }
  /**
   * Add frame to circular buffer
   */
  addFrameToBuffer(canvas, velocity, frame) {
    const cloned = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = cloned.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    this.frameBuffer.push({
      canvas: cloned,
      velocity,
      timestamp: frame
    });
    while (this.frameBuffer.length > this.maxBufferSize) {
      this.frameBuffer.shift();
    }
  }
  // ============================================================================
  // STANDARD MOTION BLUR (Shutter-based)
  // ============================================================================
  /**
   * Standard shutter-angle motion blur
   * Simulates camera shutter open during frame exposure
   */
  applyStandardBlur(sourceCanvas, velocity) {
    const { shutterAngle, shutterPhase} = this.settings;
    const exposureRatio = shutterAngle / 360;
    const phaseOffset = shutterPhase / 360;
    const blurDistX = velocity.x * exposureRatio;
    const blurDistY = velocity.y * exposureRatio;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5 + phaseOffset;
      const offsetX = blurDistX * t;
      const offsetY = blurDistY * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // PIXEL MOTION BLUR
  // ============================================================================
  /**
   * Pixel Motion Blur - analyzes motion between frames
   * Creates blur based on pixel movement vectors
   */
  applyPixelMotionBlur(sourceCanvas) {
    if (this.frameBuffer.length < 2) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    const { pixelBlurLength, vectorDetail } = this.settings;
    const blurStrength = pixelBlurLength / 100;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const frameCount = Math.min(this.frameBuffer.length, Math.ceil(vectorDetail / 20) + 2);
    const alpha = 1 / frameCount;
    this.outputCtx.globalAlpha = alpha;
    for (let i = this.frameBuffer.length - frameCount; i < this.frameBuffer.length; i++) {
      if (i >= 0) {
        const frame = this.frameBuffer[i];
        const timeOffset = (this.frameBuffer.length - 1 - i) * blurStrength;
        this.outputCtx.save();
        this.outputCtx.translate(
          -frame.velocity.x * timeOffset * 0.5,
          -frame.velocity.y * timeOffset * 0.5
        );
        this.outputCtx.drawImage(frame.canvas, 0, 0);
        this.outputCtx.restore();
      }
    }
    this.outputCtx.globalAlpha = 0.5;
    this.outputCtx.drawImage(sourceCanvas, 0, 0);
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // DIRECTIONAL BLUR
  // ============================================================================
  /**
   * Directional blur - blur in a specific direction
   * Independent of actual motion
   */
  applyDirectionalBlur(sourceCanvas) {
    const { direction, blurLength } = this.settings;
    const angleRad = direction * Math.PI / 180;
    const dx = Math.cos(angleRad) * blurLength;
    const dy = Math.sin(angleRad) * blurLength;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      const offsetX = dx * t;
      const offsetY = dy * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // RADIAL BLUR
  // ============================================================================
  /**
   * Radial blur - zoom or spin blur from center point
   */
  applyRadialBlur(sourceCanvas) {
    const { radialMode, radialAmount, radialCenterX, radialCenterY } = this.settings;
    const centerX = this.outputCanvas.width * radialCenterX;
    const centerY = this.outputCanvas.height * radialCenterY;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    const amount = radialAmount / 100;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      if (radialMode === "spin") {
        const angle = t * amount * 0.2;
        this.outputCtx.rotate(angle);
      } else {
        const scale = 1 + t * amount * 0.1;
        this.outputCtx.scale(scale, scale);
      }
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // VECTOR MOTION BLUR
  // ============================================================================
  /**
   * Vector-based motion blur using velocity data
   * More accurate than pixel-based for known motion
   */
  applyVectorBlur(sourceCanvas, velocity) {
    const { shutterAngle, vectorDetail } = this.settings;
    const exposureRatio = shutterAngle / 360;
    const blurX = velocity.x * exposureRatio;
    const blurY = velocity.y * exposureRatio;
    const blurRotation = velocity.rotation * exposureRatio * 0.01;
    const blurScale = velocity.scale * exposureRatio * 1e-3;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = Math.ceil(vectorDetail / 100 * this.getSampleCount());
    const alpha = 1 / samples;
    const centerX = this.outputCanvas.width / 2;
    const centerY = this.outputCanvas.height / 2;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      this.outputCtx.translate(blurX * t, blurY * t);
      this.outputCtx.rotate(blurRotation * t);
      this.outputCtx.scale(1 + blurScale * t, 1 + blurScale * t);
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // ADAPTIVE BLUR
  // ============================================================================
  /**
   * Adaptive blur - automatically selects blur type based on motion
   */
  applyAdaptiveBlur(sourceCanvas, velocity) {
    const magnitude = this.getVelocityMagnitude(velocity);
    if (magnitude < this.settings.adaptiveThreshold) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    if (Math.abs(velocity.rotation) > magnitude * 0.5) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "spin";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.rotation) * 2);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    if (Math.abs(velocity.scale) > 0.1) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "zoom";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.scale) * 500);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    return this.applyVectorBlur(sourceCanvas, velocity);
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  /**
   * Get sample count based on quality setting
   */
  getSampleCount() {
    const base = this.settings.samplesPerFrame;
    switch (this.settings.motionBlurQuality) {
      case "draft":
        return Math.max(4, Math.floor(base / 2));
      case "high":
        return Math.min(64, base * 2);
      default:
        return base;
    }
  }
  /**
   * Clear frame buffer (call when seeking or starting new playback)
   */
  clearBuffer() {
    this.frameBuffer = [];
  }
  /**
   * Get motion blur intensity suggestion based on frame rate
   */
  static suggestSettings(fps) {
    const baseAngle = 180;
    const fpsRatio = 24 / fps;
    return {
      shutterAngle: Math.min(360, baseAngle * fpsRatio),
      samplesPerFrame: fps >= 60 ? 8 : fps >= 30 ? 12 : 16
    };
  }
}
const MOTION_BLUR_PRESETS = {
  // Film Standards
  "film_24fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_cinematic": {
    type: "standard",
    shutterAngle: 172.8,
    // 1/48s at 24fps
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_smooth": {
    type: "standard",
    shutterAngle: 270,
    shutterPhase: -90,
    samplesPerFrame: 24
  },
  // Video Standards
  "video_30fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 12
  },
  "video_60fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 8
  },
  // Stylized
  "action_crisp": {
    type: "standard",
    shutterAngle: 90,
    shutterPhase: -45,
    samplesPerFrame: 8
  },
  "dreamy": {
    type: "standard",
    shutterAngle: 360,
    shutterPhase: -180,
    samplesPerFrame: 32
  },
  "staccato": {
    type: "standard",
    shutterAngle: 45,
    shutterPhase: -22.5,
    samplesPerFrame: 4
  },
  // Directional Effects
  "speed_horizontal": {
    type: "directional",
    direction: 0,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "speed_vertical": {
    type: "directional",
    direction: 90,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "diagonal_streak": {
    type: "directional",
    direction: 45,
    blurLength: 30,
    samplesPerFrame: 24
  },
  // Radial Effects
  "zoom_impact": {
    type: "radial",
    radialMode: "zoom",
    radialAmount: 75,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  "spin_vortex": {
    type: "radial",
    radialMode: "spin",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  // Advanced
  "pixel_smooth": {
    type: "pixel",
    pixelBlurLength: 60,
    vectorDetail: 70,
    samplesPerFrame: 16
  },
  "vector_accurate": {
    type: "vector",
    shutterAngle: 180,
    vectorDetail: 90,
    samplesPerFrame: 24
  },
  "adaptive_auto": {
    type: "adaptive",
    shutterAngle: 180,
    adaptiveThreshold: 3,
    samplesPerFrame: 16
  }
};

class BaseLayer {
  /** Unique layer identifier */
  id;
  /** Layer type */
  type;
  /** The Three.js group containing this layer's content */
  group;
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /** Keyframe evaluator for animated properties */
  evaluator;
  /** Layer visibility */
  visible;
  /** Layer locked state */
  locked;
  /** In point (start frame) */
  inPoint;
  /** Out point (end frame) */
  outPoint;
  /** Layer opacity (0-100) */
  opacity;
  /** Layer transform */
  transform;
  /** 3D layer flag */
  threeD;
  /** Auto-orient mode (billboard to camera, along path, etc.) */
  autoOrient = "off";
  /** Blend mode */
  blendMode;
  /** Parent layer ID (for parenting hierarchy) */
  parentId;
  /** Reference to parent layer (set by LayerManager) */
  parentLayer = null;
  /** Driven values override (from property drivers/expressions) */
  drivenValues = /* @__PURE__ */ new Map();
  /** Audio reactive values (from audio analysis mapping) */
  audioReactiveValues = /* @__PURE__ */ new Map();
  /** Effects stack for this layer */
  effects = [];
  /** Layer-level effects enable/disable (fx switch in AE) */
  effectsEnabled = true;
  /** Layer quality mode (draft = faster, best = full quality) */
  quality = "best";
  /** Source canvas for effect processing (lazy initialized) */
  effectSourceCanvas = null;
  /** Flag to track if effects need processing */
  effectsDirty = false;
  // ============================================================================
  // MASK & MATTE SYSTEM
  // ============================================================================
  /** Masks applied to this layer (vector cutouts) */
  masks = [];
  /** Matte source type (uses another layer as alpha/luma source) */
  matteType = "none";
  /** ID of the layer used as matte source */
  matteLayerId = null;
  /** ID of composition containing matte layer (for cross-comp mattes) */
  matteCompositionId = null;
  /** Canvas of matte source layer (set externally by LayerManager) */
  matteCanvas = null;
  /** Preserve transparency - only paint on existing pixels */
  preserveTransparency = false;
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /** Motion path line visualization */
  motionPath = null;
  /** Motion path points (frame positions) */
  motionPathPoints = [];
  /** Whether motion path is visible */
  showMotionPath = false;
  /** Motion path keyframe markers */
  motionPathMarkers = null;
  /** 3D axis gizmo at anchor point */
  axisGizmo = null;
  /** Whether 3D axis gizmo is visible */
  showAxisGizmo = false;
  // ============================================================================
  // MOTION BLUR
  // ============================================================================
  /** Motion blur enabled (layer switch) */
  motionBlur = false;
  /** Motion blur settings */
  motionBlurSettings = null;
  /** Motion blur processor instance */
  motionBlurProcessor = null;
  /** Previous frame transform values for velocity calculation */
  prevTransform = null;
  /** Last frame that motion blur was evaluated */
  motionBlurLastFrame = -1;
  /** Reference to layer data for property access */
  layerData;
  constructor(layerData) {
    this.id = layerData.id;
    this.type = layerData.type;
    this.group = new Group();
    this.group.name = `layer_${this.id}`;
    this.group.userData.layerId = this.id;
    this.group.userData.layerType = this.type;
    this.evaluator = new KeyframeEvaluator();
    this.visible = layerData.visible;
    this.locked = layerData.locked;
    this.inPoint = layerData.startFrame ?? layerData.inPoint ?? 0;
    this.outPoint = layerData.endFrame ?? layerData.outPoint ?? 80;
    this.opacity = layerData.opacity;
    this.transform = layerData.transform;
    this.threeD = layerData.threeD ?? false;
    this.autoOrient = layerData.autoOrient ?? "off";
    this.blendMode = layerData.blendMode ?? "normal";
    this.parentId = layerData.parentId ?? null;
    this.effects = layerData.effects ?? [];
    this.effectsEnabled = layerData.effectsEnabled !== false;
    this.quality = layerData.quality ?? "best";
    this.motionBlur = layerData.motionBlur ?? false;
    this.motionBlurSettings = layerData.motionBlurSettings ?? null;
    this.layerData = layerData;
    this.masks = layerData.masks ?? [];
    this.matteType = layerData.matteType ?? layerData.trackMatteType ?? "none";
    this.matteLayerId = layerData.matteLayerId ?? layerData.trackMatteLayerId ?? null;
    this.matteCompositionId = layerData.matteCompositionId ?? layerData.trackMatteCompositionId ?? null;
    this.preserveTransparency = layerData.preserveTransparency ?? false;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    if (this.blendMode !== "normal") {
      this.applyBlendMode(this.blendMode);
    }
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(frame) {
    const inRange = frame >= this.inPoint && frame <= this.outPoint;
    this.group.visible = this.visible && inRange;
    if (!this.group.visible) {
      return;
    }
    let baseOpacity = this.evaluator.evaluate(this.opacity, frame);
    baseOpacity = this.getDrivenOrBase("opacity", baseOpacity);
    const opacityValue = this.applyAudioModulation(baseOpacity, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(opacityValue);
    this.evaluateTransform(frame);
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(frame) {
    const basePosition = this.evaluator.evaluate(this.transform.position, frame);
    let posX = this.getDrivenOrBase("transform.position.x", basePosition.x);
    let posY = this.getDrivenOrBase("transform.position.y", basePosition.y);
    const posZ = this.getDrivenOrBase("transform.position.z", basePosition.z ?? 0);
    posX = this.applyAudioModulation(posX, "layer.x", "add");
    posY = this.applyAudioModulation(posY, "layer.y", "add");
    const position = { x: posX, y: posY, z: posZ };
    const baseScale = this.evaluator.evaluate(this.transform.scale, frame);
    let scaleX = this.getDrivenOrBase("transform.scale.x", baseScale.x ?? 100);
    let scaleY = this.getDrivenOrBase("transform.scale.y", baseScale.y ?? 100);
    const scaleZ = this.getDrivenOrBase("transform.scale.z", baseScale.z ?? 100);
    const audioScaleMod = this.getAudioReactiveValue("layer.scale");
    if (audioScaleMod !== 0) {
      const scaleFactor = 0.5 + audioScaleMod;
      scaleX *= scaleFactor;
      scaleY *= scaleFactor;
    }
    const scale = { x: scaleX, y: scaleY, z: scaleZ };
    const originProp = this.transform.origin || this.transform.anchorPoint;
    const baseOrigin = originProp ? this.evaluator.evaluate(originProp, frame) : { x: 0, y: 0, z: 0 };
    const origin = {
      x: this.getDrivenOrBase("transform.origin.x", baseOrigin.x ?? 0),
      y: this.getDrivenOrBase("transform.origin.y", baseOrigin.y ?? 0),
      z: this.getDrivenOrBase("transform.origin.z", baseOrigin.z ?? 0)
    };
    let rotation = 0;
    let rotationX = 0;
    let rotationY = 0;
    if (this.threeD) {
      const baseRotX = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, frame) : 0;
      rotationX = this.getDrivenOrBase("transform.rotationX", baseRotX);
      const baseRotY = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, frame) : 0;
      rotationY = this.getDrivenOrBase("transform.rotationY", baseRotY);
      const baseRotZ = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, frame) : 0;
      rotation = this.getDrivenOrBase("transform.rotationZ", baseRotZ);
    } else {
      const baseRotation = this.evaluator.evaluate(this.transform.rotation, frame);
      rotation = this.getDrivenOrBase("transform.rotation", baseRotation);
    }
    const audioRotMod = this.getAudioReactiveValue("layer.rotation");
    if (audioRotMod !== 0) {
      rotation += audioRotMod * 360;
    }
    this.applyTransform({
      position: {
        x: position.x,
        y: position.y,
        z: position.z
      },
      rotation: {
        x: rotationX,
        y: rotationY,
        z: rotation
      },
      scale: {
        x: scale.x / 100,
        y: scale.y / 100,
        z: scale.z / 100
      },
      origin: {
        x: origin.x,
        y: origin.y,
        z: origin.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(transform) {
    const { position, rotation, scale, origin } = transform;
    this.group.position.set(
      position.x - origin.x,
      -(position.y - origin.y),
      // Negate for screen coords
      position.z - origin.z
    );
    this.group.rotation.set(
      MathUtils.degToRad(rotation.x),
      MathUtils.degToRad(rotation.y),
      MathUtils.degToRad(-rotation.z)
    );
    this.group.scale.set(scale.x, scale.y, scale.z);
    this.group.updateMatrix();
  }
  /**
   * Apply auto-orient behavior (billboarding, path orientation, etc.)
   *
   * Call this after applyTransform when the layer should face the camera.
   * For 'toCamera' mode, the layer always faces the camera but only X/Y position moves.
   *
   * @param camera - The camera to orient toward (for 'toCamera' mode)
   * @param pathTangent - Optional path tangent vector (for 'alongPath' mode)
   */
  applyAutoOrient(camera, pathTangent) {
    if (this.autoOrient === "off") {
      return;
    }
    if (this.autoOrient === "toCamera" && camera) {
      const cameraPosition = new Vector3();
      camera.getWorldPosition(cameraPosition);
      const layerPosition = new Vector3();
      this.group.getWorldPosition(layerPosition);
      new Vector3().subVectors(cameraPosition, layerPosition).normalize();
      const targetQuaternion = new Quaternion();
      const up = new Vector3(0, 1, 0);
      const matrix = new Matrix4();
      matrix.lookAt(layerPosition, cameraPosition, up);
      targetQuaternion.setFromRotationMatrix(matrix);
      this.group.quaternion.copy(targetQuaternion);
      this.group.updateMatrix();
    }
    if (this.autoOrient === "alongPath" && pathTangent) {
      const angle = Math.atan2(pathTangent.y, pathTangent.x);
      if (this.threeD) {
        this.group.rotation.z = -angle;
      } else {
        this.group.rotation.set(0, 0, -angle);
      }
      this.group.updateMatrix();
    }
  }
  /**
   * Get the current auto-orient mode
   */
  getAutoOrient() {
    return this.autoOrient;
  }
  /**
   * Set the auto-orient mode
   */
  setAutoOrient(mode) {
    this.autoOrient = mode;
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        if ("opacity" in material) {
          material.opacity = normalizedOpacity;
          material.transparent = normalizedOpacity < 1;
          material.needsUpdate = true;
        }
      }
    });
  }
  // ============================================================================
  // EVALUATED STATE APPLICATION (NEW - SINGLE SOURCE OF TRUTH)
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer visual state.
   * All values are already computed - layers only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * @param state - Pre-evaluated layer state from MotionEngine
   */
  applyEvaluatedState(state) {
    this.group.visible = state.visible;
    if (!state.visible) {
      return;
    }
    const opacity = this.getDrivenOrBase("opacity", state.opacity);
    this.applyOpacity(opacity);
    const transform = state.transform;
    const originVal = transform.origin || transform.anchorPoint || { x: 0, y: 0, z: 0 };
    this.applyTransform({
      position: {
        x: this.getDrivenOrBase("transform.position.x", transform.position.x),
        y: this.getDrivenOrBase("transform.position.y", transform.position.y),
        z: this.getDrivenOrBase("transform.position.z", transform.position.z ?? 0)
      },
      rotation: {
        x: this.getDrivenOrBase("transform.rotationX", transform.rotationX ?? 0),
        y: this.getDrivenOrBase("transform.rotationY", transform.rotationY ?? 0),
        z: this.getDrivenOrBase("transform.rotation", transform.rotation)
      },
      scale: {
        x: this.getDrivenOrBase("transform.scale.x", transform.scale.x ?? 100) / 100,
        y: this.getDrivenOrBase("transform.scale.y", transform.scale.y ?? 100) / 100,
        z: this.getDrivenOrBase("transform.scale.z", transform.scale.z ?? 100) / 100
      },
      origin: {
        x: this.getDrivenOrBase("transform.origin.x", originVal.x),
        y: this.getDrivenOrBase("transform.origin.y", originVal.y),
        z: this.getDrivenOrBase("transform.origin.z", originVal.z ?? 0)
      }
    });
    this.onApplyEvaluatedState(state);
  }
  /**
   * Override in subclasses for type-specific state application
   * Default implementation calls legacy onEvaluateFrame for compatibility
   */
  onApplyEvaluatedState(state) {
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(properties) {
    if (properties.visible !== void 0) {
      this.visible = properties.visible;
      this.group.visible = this.visible;
    }
    if (properties.locked !== void 0) {
      this.locked = properties.locked;
    }
    if (properties.inPoint !== void 0) {
      this.inPoint = properties.inPoint;
    }
    if (properties.outPoint !== void 0) {
      this.outPoint = properties.outPoint;
    }
    if (properties.opacity !== void 0) {
      this.opacity = properties.opacity;
    }
    if (properties.transform !== void 0) {
      this.transform = properties.transform;
    }
    if (properties.threeD !== void 0) {
      this.threeD = properties.threeD;
    }
    if (properties.autoOrient !== void 0) {
      this.autoOrient = properties.autoOrient;
    }
    if (properties.blendMode !== void 0) {
      this.blendMode = properties.blendMode;
      this.applyBlendMode(this.blendMode);
    }
    if (properties.effects !== void 0) {
      this.setEffects(properties.effects);
    }
    if (properties.masks !== void 0) {
      this.masks = properties.masks;
    }
    const newMatteType = properties.matteType ?? properties.trackMatteType;
    if (newMatteType !== void 0) {
      this.matteType = newMatteType;
    }
    const newMatteLayerId = properties.matteLayerId ?? properties.trackMatteLayerId;
    if (newMatteLayerId !== void 0) {
      this.matteLayerId = newMatteLayerId;
      this.matteCanvas = null;
    }
    const newMatteCompId = properties.matteCompositionId ?? properties.trackMatteCompositionId;
    if (newMatteCompId !== void 0) {
      this.matteCompositionId = newMatteCompId;
      this.matteCanvas = null;
    }
    if (properties.preserveTransparency !== void 0) {
      this.preserveTransparency = properties.preserveTransparency;
    }
    this.onUpdate(properties);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(visible) {
    this.visible = visible;
    this.group.visible = visible;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  /**
   * Get the underlying layer data
   * Used for accessing transform, anchor point, and other layer properties
   */
  getLayerData() {
    return this.layerData;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(values) {
    this.drivenValues = values;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(propertyPath, baseValue) {
    return this.drivenValues.get(propertyPath) ?? baseValue;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(values) {
    this.audioReactiveValues = values;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(target) {
    return this.audioReactiveValues.get(target) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(baseValue, target, mode = "add", range = {}) {
    const audioValue = this.getAudioReactiveValue(target);
    if (audioValue === 0) return baseValue;
    let result;
    switch (mode) {
      case "multiply":
        result = baseValue * (0.5 + audioValue);
        break;
      case "replace":
        result = audioValue;
        break;
      case "add":
      default:
        result = baseValue + audioValue * 100;
        break;
    }
    if (range.min !== void 0) result = Math.max(range.min, result);
    if (range.max !== void 0) result = Math.min(range.max, result);
    return result;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(effects) {
    this.effects = effects;
    this.effectsDirty = true;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   * Also respects the layer-level effectsEnabled flag (fx switch)
   */
  hasEnabledEffects() {
    if (!this.effectsEnabled) {
      return false;
    }
    return hasEnabledEffects(this.effects);
  }
  /**
   * Set layer-level effects enabled state (fx switch)
   */
  setEffectsEnabled(enabled) {
    this.effectsEnabled = enabled;
  }
  /**
   * Get layer-level effects enabled state
   */
  getEffectsEnabled() {
    return this.effectsEnabled;
  }
  /**
   * Set layer quality mode (draft = faster preview, best = full quality)
   */
  setQuality(quality) {
    this.quality = quality;
  }
  /**
   * Get layer quality mode
   */
  getQuality() {
    return this.quality;
  }
  /**
   * Check if layer is in draft quality mode
   */
  isDraftQuality() {
    return this.quality === "draft";
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(frame) {
    if (!this.hasEnabledEffects()) {
      return null;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    try {
      const qualityHint = this.isDraftQuality() ? "draft" : "high";
      const effectContext = {
        frame,
        fps: 16,
        // Default project fps (Wan 2.1 standard)
        layerId: this.id
      };
      const result = processEffectStack(this.effects, sourceCanvas, frame, qualityHint, effectContext);
      let processedCanvas = result.canvas;
      if (this.motionBlur) {
        const currentTransform = this.getCurrentTransformValues();
        processedCanvas = this.applyMotionBlur(processedCanvas, frame, currentTransform);
      }
      return processedCanvas;
    } catch (error) {
      layerLogger.error(`Error processing effects for layer ${this.id}:`, error);
      return null;
    }
  }
  /**
   * Get current transform values for motion blur calculation
   * Uses evaluated values from the current frame
   */
  getCurrentTransformValues() {
    return {
      position: {
        x: this.group.position.x,
        y: -this.group.position.y,
        // Negate to convert back to screen coords
        z: this.group.position.z
      },
      rotation: MathUtils.radToDeg(-this.group.rotation.z),
      // Convert back
      scale: {
        x: this.group.scale.x * 100,
        y: this.group.scale.y * 100
      }
    };
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(_processedCanvas) {
  }
  // ============================================================================
  // MOTION BLUR PROCESSING
  // ============================================================================
  /**
   * Check if motion blur should be applied
   */
  shouldApplyMotionBlur() {
    return this.motionBlur && this.getSourceCanvas() !== null;
  }
  /**
   * Initialize motion blur processor with layer dimensions
   */
  initializeMotionBlurProcessor(width, height) {
    if (!this.motionBlurProcessor) {
      const settings = this.motionBlurSettings ? {
        enabled: true,
        type: this.motionBlurSettings.type,
        shutterAngle: this.motionBlurSettings.shutterAngle,
        shutterPhase: this.motionBlurSettings.shutterPhase,
        samplesPerFrame: this.motionBlurSettings.samplesPerFrame,
        direction: this.motionBlurSettings.direction,
        blurLength: this.motionBlurSettings.blurLength
      } : { ...createDefaultMotionBlurSettings(), enabled: true };
      this.motionBlurProcessor = new MotionBlurProcessor(width, height, settings);
    } else if (this.motionBlurProcessor.getSettings().shutterAngle !== (this.motionBlurSettings?.shutterAngle ?? 180)) {
      this.motionBlurProcessor.setSettings({
        shutterAngle: this.motionBlurSettings?.shutterAngle ?? 180,
        shutterPhase: this.motionBlurSettings?.shutterPhase ?? -90,
        samplesPerFrame: this.motionBlurSettings?.samplesPerFrame ?? 16
      });
    }
  }
  /**
   * Calculate velocity from current and previous transforms
   */
  calculateTransformVelocity(currentTransform) {
    if (!this.prevTransform) {
      return { x: 0, y: 0, rotation: 0, scale: 0 };
    }
    return {
      x: currentTransform.position.x - this.prevTransform.position.x,
      y: currentTransform.position.y - this.prevTransform.position.y,
      rotation: currentTransform.rotation - this.prevTransform.rotation,
      scale: (currentTransform.scale.x - this.prevTransform.scale.x + (currentTransform.scale.y - this.prevTransform.scale.y)) / 2
    };
  }
  /**
   * Apply motion blur to a canvas based on transform velocity
   * @param sourceCanvas - Canvas to apply motion blur to
   * @param frame - Current frame number
   * @param currentTransform - Current transform values
   * @returns Canvas with motion blur applied, or source if no blur needed
   */
  applyMotionBlur(sourceCanvas, frame, currentTransform) {
    if (!this.motionBlur) {
      return sourceCanvas;
    }
    this.initializeMotionBlurProcessor(sourceCanvas.width, sourceCanvas.height);
    if (!this.motionBlurProcessor) {
      return sourceCanvas;
    }
    const velocity = this.calculateTransformVelocity(currentTransform);
    this.prevTransform = {
      position: { ...currentTransform.position },
      rotation: currentTransform.rotation,
      scale: { ...currentTransform.scale }
    };
    const velocityMagnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
    if (velocityMagnitude < 0.5 && Math.abs(velocity.rotation) < 0.5 && Math.abs(velocity.scale) < 0.01) {
      return sourceCanvas;
    }
    try {
      const offscreen = new OffscreenCanvas(sourceCanvas.width, sourceCanvas.height);
      const ctx = offscreen.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        const blurredOffscreen = this.motionBlurProcessor.applyMotionBlur(offscreen, velocity, frame);
        const resultCanvas = document.createElement("canvas");
        resultCanvas.width = sourceCanvas.width;
        resultCanvas.height = sourceCanvas.height;
        const resultCtx = resultCanvas.getContext("2d");
        if (resultCtx) {
          resultCtx.drawImage(blurredOffscreen, 0, 0);
          return resultCanvas;
        }
      }
    } catch (error) {
      layerLogger.error(`Error applying motion blur to layer ${this.id}:`, error);
    }
    return sourceCanvas;
  }
  /**
   * Set motion blur enabled state
   */
  setMotionBlur(enabled) {
    this.motionBlur = enabled;
    this.layerData.motionBlur = enabled;
    if (!enabled) {
      this.motionBlurProcessor?.clearBuffer();
      this.prevTransform = null;
    }
  }
  /**
   * Update motion blur settings
   */
  setMotionBlurSettings(settings) {
    if (!this.motionBlurSettings) {
      this.motionBlurSettings = {
        type: "standard",
        shutterAngle: 180,
        shutterPhase: -90,
        samplesPerFrame: 16,
        ...settings
      };
    } else {
      Object.assign(this.motionBlurSettings, settings);
    }
    if (this.motionBlurProcessor) {
      this.motionBlurProcessor.setSettings({
        type: this.motionBlurSettings.type,
        shutterAngle: this.motionBlurSettings.shutterAngle,
        shutterPhase: this.motionBlurSettings.shutterPhase,
        samplesPerFrame: this.motionBlurSettings.samplesPerFrame
      });
    }
  }
  // ============================================================================
  // MASK PROCESSING
  // ============================================================================
  /**
   * Check if this layer has any enabled masks
   */
  hasMasks() {
    return this.masks.length > 0 && this.masks.some((m) => m.enabled);
  }
  /**
   * Check if this layer has a matte source assigned
   */
  hasMatte() {
    return this.matteType !== "none" && this.matteCanvas !== null;
  }
  /** @deprecated Use hasMatte() instead */
  hasTrackMatte() {
    return this.hasMatte();
  }
  /**
   * Set the matte canvas (called by LayerManager when compositing)
   * @param canvas - The rendered canvas of the matte layer
   */
  setMatteCanvas(canvas) {
    this.matteCanvas = canvas;
  }
  /** @deprecated Use setMatteCanvas() instead */
  setTrackMatteCanvas(canvas) {
    this.setMatteCanvas(canvas);
  }
  /**
   * Get the matte layer ID
   */
  getMatteLayerId() {
    return this.matteLayerId;
  }
  /** @deprecated Use getMatteLayerId() instead */
  getTrackMatteLayerId() {
    return this.getMatteLayerId();
  }
  /**
   * Get the matte composition ID (for cross-comp mattes)
   * Returns null if matte is in the same composition
   */
  getMatteCompositionId() {
    return this.matteCompositionId;
  }
  /** @deprecated Use getMatteCompositionId() instead */
  getTrackMatteCompositionId() {
    return this.getMatteCompositionId();
  }
  /**
   * Check if this layer uses a cross-composition matte
   */
  hasCrossCompMatte() {
    return this.matteCompositionId !== null && this.matteLayerId !== null;
  }
  /**
   * Get the matte type
   */
  getMatteType() {
    return this.matteType;
  }
  /** @deprecated Use getMatteType() instead */
  getTrackMatteType() {
    return this.getMatteType();
  }
  /**
   * Update masks
   */
  setMasks(masks) {
    this.masks = masks;
  }
  /**
   * Process masks and matte source on a canvas
   * @param canvas - Source canvas to apply masks to
   * @param frame - Current frame for animated masks
   * @returns Processed canvas with masks applied
   */
  processMasksAndMattes(canvas, frame) {
    let result = canvas;
    if (this.hasMasks()) {
      result = applyMasksToLayer(result, this.masks, frame);
    }
    if (this.hasMatte() && this.matteCanvas) {
      result = applyTrackMatte(result, this.matteCanvas, this.matteType);
    }
    return result;
  }
  /**
   * Called after frame evaluation to apply effects AND masks
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(frame) {
    const hasEffects = this.hasEnabledEffects();
    const hasMasks = this.hasMasks();
    const hasTrackMatte = this.hasTrackMatte();
    if (!hasEffects && !hasMasks && !hasTrackMatte) {
      return;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return;
    }
    let processedCanvas = sourceCanvas;
    if (hasEffects) {
      const effectResult = this.processEffects(frame);
      if (effectResult) {
        processedCanvas = effectResult;
      }
    }
    if (hasMasks || hasTrackMatte) {
      processedCanvas = this.processMasksAndMattes(processedCanvas, frame);
    }
    if (processedCanvas !== sourceCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Apply pre-evaluated effects from MotionEngine
   * Uses the evaluated effect parameters rather than re-evaluating
   */
  applyEvaluatedEffects(evaluatedEffects) {
    if (evaluatedEffects.length === 0 || !this.hasEnabledEffects()) {
      return;
    }
    const processedCanvas = this.processEffectsWithEvaluated(evaluatedEffects);
    if (processedCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Process effects using pre-evaluated parameters
   */
  processEffectsWithEvaluated(evaluatedEffects) {
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    let currentCanvas = sourceCanvas;
    for (const evalEffect of evaluatedEffects) {
      if (!evalEffect.enabled) continue;
      const effect = this.effects.find((e) => e.id === evalEffect.id);
      if (!effect) continue;
      const result = this.processEffectWithParams(effect, currentCanvas, evalEffect.parameters);
      if (result) {
        currentCanvas = result;
      }
    }
    return currentCanvas !== sourceCanvas ? currentCanvas : null;
  }
  /**
   * Process a single effect with pre-evaluated parameters
   */
  processEffectWithParams(effect, sourceCanvas, params) {
    return null;
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(parent) {
    if (this.parentLayer) {
      this.parentLayer.getObject().remove(this.group);
    }
    this.parentLayer = parent;
    if (parent) {
      parent.getObject().add(this.group);
    }
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(mode) {
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        this.setMaterialBlendMode(material, mode);
        material.needsUpdate = true;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(material, mode) {
    material.blending = NormalBlending;
    material.blendEquation = AddEquation;
    material.blendSrc = SrcAlphaFactor;
    material.blendDst = OneMinusSrcAlphaFactor;
    material.blendEquationAlpha = AddEquation;
    material.blendSrcAlpha = OneFactor;
    material.blendDstAlpha = OneMinusSrcAlphaFactor;
    switch (mode) {
      case "normal":
        material.blending = NormalBlending;
        break;
      case "add":
        material.blending = AdditiveBlending;
        break;
      case "multiply":
        material.blending = MultiplyBlending;
        break;
      case "screen":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "overlay":
        material.blending = MultiplyBlending;
        break;
      case "soft-light":
        material.blending = NormalBlending;
        break;
      case "hard-light":
        material.blending = MultiplyBlending;
        break;
      case "color-dodge":
        material.blending = AdditiveBlending;
        break;
      case "color-burn":
        material.blending = SubtractiveBlending;
        break;
      case "difference":
        material.blending = CustomBlending;
        material.blendEquation = SubtractEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "exclusion":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneMinusDstColorFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "darken":
        material.blending = CustomBlending;
        material.blendEquation = MinEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "lighten":
        material.blending = CustomBlending;
        material.blendEquation = MaxEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      default:
        material.blending = NormalBlending;
        break;
    }
  }
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /**
   * Compute motion path from position keyframes
   * Samples position at each frame from inPoint to outPoint
   */
  computeMotionPath(startFrame, endFrame) {
    const start = startFrame ?? this.inPoint;
    const end = endFrame ?? this.outPoint;
    this.motionPathPoints = [];
    for (let frame = start; frame <= end; frame++) {
      const pos = this.evaluator.evaluate(this.transform.position, frame);
      this.motionPathPoints.push(new Vector3(pos.x, -pos.y, pos.z ?? 0));
    }
    this.rebuildMotionPath();
  }
  /**
   * Rebuild the motion path line from computed points
   */
  rebuildMotionPath() {
    if (this.motionPath) {
      this.group.remove(this.motionPath);
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.group.remove(this.motionPathMarkers);
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.motionPathPoints.length < 2) return;
    const curve = new CatmullRomCurve3(this.motionPathPoints);
    const curvePoints = curve.getPoints(this.motionPathPoints.length * 10);
    const geometry = new BufferGeometry().setFromPoints(curvePoints);
    const material = new LineBasicMaterial({
      color: 4886745,
      // Blue motion path
      linewidth: 2,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    this.motionPath = new Line(geometry, material);
    this.motionPath.name = `motion_path_${this.id}`;
    this.motionPath.renderOrder = 998;
    this.motionPath.visible = this.showMotionPath;
    this.motionPath.matrixAutoUpdate = false;
    this.motionPath.matrix.identity();
    this.group.add(this.motionPath);
    this.createMotionPathMarkers();
  }
  /**
   * Create markers at keyframe positions on the motion path
   */
  createMotionPathMarkers() {
    this.motionPathMarkers = new Group();
    this.motionPathMarkers.name = `motion_path_markers_${this.id}`;
    this.motionPathMarkers.renderOrder = 999;
    const positionKeyframes = this.transform.position.keyframes;
    if (!positionKeyframes || positionKeyframes.length === 0) return;
    const markerGeometry = new OctahedronGeometry(5, 0);
    const markerMaterial = new MeshBasicMaterial({
      color: 16763904,
      // Yellow keyframe markers
      transparent: true,
      opacity: 0.9,
      depthTest: false
    });
    for (const kf of positionKeyframes) {
      const pos = kf.value;
      const marker = new Mesh(markerGeometry.clone(), markerMaterial.clone());
      marker.position.set(pos.x, -pos.y, pos.z ?? 0);
      marker.userData.frame = kf.frame;
      this.motionPathMarkers.add(marker);
    }
    this.motionPathMarkers.visible = this.showMotionPath;
    this.group.add(this.motionPathMarkers);
  }
  /**
   * Set motion path visibility
   */
  setMotionPathVisible(visible) {
    this.showMotionPath = visible;
    if (visible && this.motionPathPoints.length === 0) {
      this.computeMotionPath();
    }
    if (this.motionPath) {
      this.motionPath.visible = visible;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.visible = visible;
    }
  }
  /**
   * Check if motion path is visible
   */
  isMotionPathVisible() {
    return this.showMotionPath;
  }
  /**
   * Check if layer has position animation
   */
  hasPositionAnimation() {
    return (this.transform.position.keyframes?.length ?? 0) > 0;
  }
  // ============================================================================
  // 3D AXIS GIZMO
  // ============================================================================
  /**
   * Create 3D axis gizmo at anchor point
   */
  createAxisGizmo(size = 50) {
    if (this.axisGizmo) {
      this.group.remove(this.axisGizmo);
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.axisGizmo = new Group();
    this.axisGizmo.name = `axis_gizmo_${this.id}`;
    this.axisGizmo.renderOrder = 1e3;
    const xGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(size, 0, 0)
    ]);
    const xMat = new LineBasicMaterial({
      color: 16711680,
      linewidth: 2,
      depthTest: false
    });
    const xLine = new Line(xGeom, xMat);
    this.axisGizmo.add(xLine);
    const yGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(0, size, 0)
    ]);
    const yMat = new LineBasicMaterial({
      color: 65280,
      linewidth: 2,
      depthTest: false
    });
    const yLine = new Line(yGeom, yMat);
    this.axisGizmo.add(yLine);
    if (this.threeD) {
      const zGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, size)
      ]);
      const zMat = new LineBasicMaterial({
        color: 35071,
        linewidth: 2,
        depthTest: false
      });
      const zLine = new Line(zGeom, zMat);
      this.axisGizmo.add(zLine);
    }
    this.addAxisLabels(size);
    const originProp = this.transform.origin || this.transform.anchorPoint;
    const originVal = originProp?.value || { x: 0, y: 0, z: 0 };
    this.axisGizmo.position.set(-originVal.x, originVal.y, -(originVal.z ?? 0));
    this.axisGizmo.visible = this.showAxisGizmo;
    this.group.add(this.axisGizmo);
  }
  /**
   * Add axis labels (X, Y, Z)
   */
  addAxisLabels(size) {
    if (!this.axisGizmo) return;
    const sphereGeom = new SphereGeometry(3, 8, 8);
    const xSphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 16711680, depthTest: false })
    );
    xSphere.position.set(size + 5, 0, 0);
    this.axisGizmo.add(xSphere);
    const ySphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 65280, depthTest: false })
    );
    ySphere.position.set(0, size + 5, 0);
    this.axisGizmo.add(ySphere);
    if (this.threeD) {
      const zSphere = new Mesh(
        sphereGeom.clone(),
        new MeshBasicMaterial({ color: 35071, depthTest: false })
      );
      zSphere.position.set(0, 0, size + 5);
      this.axisGizmo.add(zSphere);
    }
  }
  /**
   * Set axis gizmo visibility
   */
  setAxisGizmoVisible(visible) {
    this.showAxisGizmo = visible;
    if (visible && !this.axisGizmo) {
      this.createAxisGizmo();
    }
    if (this.axisGizmo) {
      this.axisGizmo.visible = visible;
    }
  }
  /**
   * Check if axis gizmo is visible
   */
  isAxisGizmoVisible() {
    return this.showAxisGizmo;
  }
  /**
   * Update axis gizmo position to match origin
   */
  updateAxisGizmoPosition() {
    if (!this.axisGizmo) return;
    const originProp = this.transform.origin || this.transform.anchorPoint;
    const originVal = originProp?.value || { x: 0, y: 0, z: 0 };
    this.axisGizmo.position.set(-originVal.x, originVal.y, -(originVal.z ?? 0));
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const box = new Box3();
    box.setFromObject(this.group);
    return box;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const box = this.getBoundingBox();
    const center = new Vector3();
    box.getCenter(center);
    return center;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    if (this.motionPath) {
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.axisGizmo) {
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.group.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry?.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else if (child.material) {
          child.material.dispose();
        }
      }
    });
    this.group.clear();
    this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}

class VideoLayer extends BaseLayer {
  resources;
  // Video elements
  videoElement = null;
  videoTexture = null;
  mesh = null;
  material = null;
  // Video data
  videoData;
  assetRef = null;
  // Metadata (populated after video loads)
  metadata = null;
  // Animation evaluator
  videoEvaluator;
  // Playback state
  lastEvaluatedFrame = -1;
  isPlaying = false;
  // Callbacks for composition auto-resize
  onMetadataLoaded;
  // Composition FPS for time calculation
  compositionFPS = 30;
  // Canvas for effect processing
  effectCanvas = null;
  effectCanvasCtx = null;
  // Frame blending support
  prevFrameCanvas = null;
  prevFrameCtx = null;
  blendCanvas = null;
  blendCtx = null;
  lastVideoTime = -1;
  prevFrameTime = -1;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.videoEvaluator = new KeyframeEvaluator();
    this.videoData = this.extractVideoData(layerData);
    this.createPlaceholderMesh();
    if (this.videoData.assetId) {
      this.loadVideo(this.videoData.assetId);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      loop: data?.loop ?? false,
      pingPong: data?.pingPong ?? false,
      startTime: data?.startTime ?? 0,
      endTime: data?.endTime,
      speed: data?.speed ?? 1,
      // Speed map (new naming)
      speedMapEnabled: data?.speedMapEnabled ?? data?.timeRemapEnabled ?? false,
      speedMap: data?.speedMap ?? data?.timeRemap,
      // Backwards compatibility aliases
      timeRemapEnabled: data?.timeRemapEnabled ?? data?.speedMapEnabled ?? false,
      timeRemap: data?.timeRemap ?? data?.speedMap,
      frameBlending: data?.frameBlending ?? "none",
      audioEnabled: data?.audioEnabled ?? true,
      audioLevel: data?.audioLevel ?? 100,
      posterFrame: data?.posterFrame ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 3355443,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `video_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(assetId) {
    const asset = this.resources.getAsset(assetId);
    if (!asset || asset.type !== "video") {
      layerLogger.warn(`VideoLayer: Asset ${assetId} not found or not a video`);
      return;
    }
    this.assetRef = asset;
    this.videoData.assetId = assetId;
    this.videoElement = document.createElement("video");
    this.videoElement.crossOrigin = "anonymous";
    this.videoElement.playsInline = true;
    this.videoElement.muted = !this.videoData.audioEnabled;
    this.videoElement.loop = false;
    this.videoElement.preload = "auto";
    if (asset.data) {
      this.videoElement.src = asset.data;
    }
    await this.waitForMetadata();
    this.createVideoTexture();
    this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((resolve, reject) => {
      if (!this.videoElement) {
        reject(new Error("No video element"));
        return;
      }
      const onLoadedMetadata = () => {
        this.extractMetadata();
        cleanup();
        resolve();
      };
      const onError = (e) => {
        cleanup();
        reject(new Error(`Video load error: ${e}`));
      };
      const cleanup = () => {
        this.videoElement?.removeEventListener("loadedmetadata", onLoadedMetadata);
        this.videoElement?.removeEventListener("error", onError);
      };
      this.videoElement.addEventListener("loadedmetadata", onLoadedMetadata);
      this.videoElement.addEventListener("error", onError);
      this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    if (!this.videoElement) return;
    const duration = this.videoElement.duration;
    const width = this.videoElement.videoWidth;
    const height = this.videoElement.videoHeight;
    const fps = this.assetRef?.fps ?? 30;
    const frameCount = Math.ceil(duration * fps);
    this.metadata = {
      duration,
      frameCount,
      fps,
      width,
      height,
      hasAudio: this.hasAudioTrack()
    };
    if (this.assetRef) {
      this.assetRef.duration = duration;
      this.assetRef.frameCount = frameCount;
      this.assetRef.fps = fps;
      this.assetRef.hasAudio = this.metadata.hasAudio;
    }
    this.onMetadataLoaded?.(this.metadata);
    layerLogger.debug(`VideoLayer: Loaded: ${width}x${height}, ${frameCount} frames @ ${fps}fps, ${duration.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return false;
    const audioTracks = this.videoElement.audioTracks;
    if (audioTracks) {
      return audioTracks.length > 0;
    }
    return true;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    if (!this.videoElement || !this.metadata) return;
    this.videoTexture = new VideoTexture(this.videoElement);
    this.videoTexture.minFilter = LinearFilter;
    this.videoTexture.magFilter = LinearFilter;
    this.videoTexture.format = RGBAFormat;
    this.videoTexture.colorSpace = SRGBColorSpace;
    if (this.material) {
      this.material.map = this.videoTexture;
      this.material.color.setHex(16777215);
      this.material.needsUpdate = true;
    }
    this.resizeMesh(this.metadata.width, this.metadata.height);
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(compositionFrame) {
    if (!this.videoElement || !this.metadata) return;
    const videoTime = this.calculateVideoTime(compositionFrame);
    const clampedTime = Math.max(0, Math.min(videoTime, this.videoElement.duration));
    this.videoElement.currentTime = clampedTime;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, speed map (time remapping), loop, and ping-pong
   */
  calculateVideoTime(compositionFrame) {
    if (!this.metadata) return 0;
    const speedMapEnabled = this.videoData.speedMapEnabled ?? this.videoData.timeRemapEnabled;
    const speedMapProp = this.videoData.speedMap ?? this.videoData.timeRemap;
    if (speedMapEnabled && speedMapProp?.animated) {
      return this.videoEvaluator.evaluate(speedMapProp, compositionFrame);
    }
    const compFps = this.compositionFPS;
    const compTime = compositionFrame / compFps;
    let videoTime = compTime * this.videoData.speed;
    videoTime += this.videoData.startTime;
    const effectiveDuration = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && effectiveDuration > 0) {
      if (this.videoData.pingPong) {
        const cycles = Math.floor(videoTime / effectiveDuration);
        const phase = videoTime % effectiveDuration;
        videoTime = cycles % 2 === 0 ? phase : effectiveDuration - phase;
      } else {
        videoTime = videoTime % effectiveDuration;
      }
      videoTime += this.videoData.startTime;
    }
    return videoTime;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(level) {
    this.videoData.audioLevel = level;
    if (this.videoElement) {
      this.videoElement.volume = Math.max(0, Math.min(1, level / 100));
    }
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(enabled) {
    this.videoData.audioEnabled = enabled;
    if (this.videoElement) {
      this.videoElement.muted = !enabled;
    }
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.compositionFPS = fps;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(callback) {
    this.onMetadataLoaded = callback;
    if (this.metadata) {
      callback(this.metadata);
    }
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(loop) {
    this.videoData.loop = loop;
  }
  setPingPong(pingPong) {
    this.videoData.pingPong = pingPong;
  }
  setSpeed(speed) {
    this.videoData.speed = speed;
    if (this.videoElement) {
      this.videoElement.playbackRate = speed;
    }
  }
  setStartTime(time) {
    this.videoData.startTime = time;
  }
  setEndTime(time) {
    this.videoData.endTime = time;
  }
  setFrameBlending(mode) {
    this.videoData.frameBlending = mode;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   * Supports frame blending for smooth slow-motion
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata) {
      return null;
    }
    const width = this.metadata.width;
    const height = this.metadata.height;
    this.ensureCanvases(width, height);
    if (!this.effectCanvasCtx) {
      return null;
    }
    const shouldBlend = this.layerData.frameBlending === true && this.videoData.frameBlending !== "none";
    if (shouldBlend && this.prevFrameCtx && this.blendCtx && this.blendCanvas) {
      return this.getBlendedFrame(width, height);
    }
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    return this.effectCanvas;
  }
  /**
   * Ensure all canvases are created and sized correctly
   */
  ensureCanvases(width, height) {
    if (!this.effectCanvas || this.effectCanvas.width !== width || this.effectCanvas.height !== height) {
      this.effectCanvas = document.createElement("canvas");
      this.effectCanvas.width = width;
      this.effectCanvas.height = height;
      this.effectCanvasCtx = this.effectCanvas.getContext("2d");
    }
    if (!this.prevFrameCanvas || this.prevFrameCanvas.width !== width || this.prevFrameCanvas.height !== height) {
      this.prevFrameCanvas = document.createElement("canvas");
      this.prevFrameCanvas.width = width;
      this.prevFrameCanvas.height = height;
      this.prevFrameCtx = this.prevFrameCanvas.getContext("2d");
    }
    if (!this.blendCanvas || this.blendCanvas.width !== width || this.blendCanvas.height !== height) {
      this.blendCanvas = document.createElement("canvas");
      this.blendCanvas.width = width;
      this.blendCanvas.height = height;
      this.blendCtx = this.blendCanvas.getContext("2d");
    }
  }
  /**
   * Get blended frame between previous and current video frame
   * Used for smooth slow-motion playback
   */
  getBlendedFrame(width, height) {
    if (!this.videoElement || !this.metadata || !this.blendCtx || !this.blendCanvas || !this.prevFrameCtx || !this.prevFrameCanvas) {
      return null;
    }
    const currentVideoTime = this.videoElement.currentTime;
    const videoFps = this.metadata.fps || 30;
    const currentVideoFrame = currentVideoTime * videoFps;
    const blendFactor = currentVideoFrame - Math.floor(currentVideoFrame);
    const currentIntFrame = Math.floor(currentVideoFrame);
    const prevIntFrame = Math.floor(this.lastVideoTime * videoFps);
    if (this.lastVideoTime < 0 || currentIntFrame !== prevIntFrame) {
      if (this.effectCanvasCtx && this.effectCanvas) {
        this.effectCanvasCtx.clearRect(0, 0, width, height);
        this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
        this.prevFrameCtx.clearRect(0, 0, width, height);
        this.prevFrameCtx.drawImage(this.effectCanvas, 0, 0);
        this.prevFrameTime = this.lastVideoTime;
      }
    }
    this.lastVideoTime = currentVideoTime;
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    if (blendFactor < 0.01 || blendFactor > 0.99) {
      return this.effectCanvas;
    }
    this.blendCtx.clearRect(0, 0, width, height);
    this.blendCtx.globalAlpha = 1;
    this.blendCtx.drawImage(this.prevFrameCanvas, 0, 0);
    this.blendCtx.globalAlpha = blendFactor;
    this.blendCtx.drawImage(this.effectCanvas, 0, 0);
    this.blendCtx.globalAlpha = 1;
    return this.blendCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    if (!this.material || !this.metadata) return;
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (frame === this.lastEvaluatedFrame) return;
    this.lastEvaluatedFrame = frame;
    this.seekToFrame(frame);
    if (this.videoTexture) {
      this.videoTexture.needsUpdate = true;
    }
    if (this.hasEnabledEffects()) {
      this.evaluateEffects(frame);
    } else if (this.material && this.videoTexture) {
      this.material.map = this.videoTexture;
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    const speedMapValue = props["speedMap"] ?? props["timeRemap"];
    if (speedMapValue !== void 0 && this.videoElement) {
      const targetTime = speedMapValue;
      const clampedTime = Math.max(0, Math.min(targetTime, this.videoElement.duration || targetTime));
      this.videoElement.currentTime = clampedTime;
    }
    if (props["speed"] !== void 0) {
      this.videoData.speed = props["speed"];
    }
    if (props["audioLevel"] !== void 0) {
      this.setAudioLevel(props["audioLevel"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.videoData.assetId) {
        if (data.assetId) {
          this.loadVideo(data.assetId);
        } else {
          this.clearVideo();
        }
      }
      if (data.loop !== void 0) this.setLoop(data.loop);
      if (data.pingPong !== void 0) this.setPingPong(data.pingPong);
      if (data.speed !== void 0) this.setSpeed(data.speed);
      if (data.startTime !== void 0) this.setStartTime(data.startTime);
      if (data.endTime !== void 0) this.setEndTime(data.endTime);
      if (data.frameBlending !== void 0) this.setFrameBlending(data.frameBlending);
      if (data.audioEnabled !== void 0) this.setAudioEnabled(data.audioEnabled);
      if (data.audioLevel !== void 0) this.setAudioLevel(data.audioLevel);
    }
  }
  /**
   * Clear current video
   */
  clearVideo() {
    if (this.videoElement) {
      this.videoElement.pause();
      this.videoElement.src = "";
      this.videoElement = null;
    }
    if (this.videoTexture) {
      this.videoTexture.dispose();
      this.videoTexture = null;
    }
    if (this.material) {
      this.material.map = null;
      this.material.color.setHex(3355443);
    }
    this.metadata = null;
    this.videoData.assetId = null;
    this.lastVideoTime = -1;
    this.prevFrameTime = -1;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo();
    this.prevFrameCanvas = null;
    this.prevFrameCtx = null;
    this.blendCanvas = null;
    this.blendCtx = null;
    this.effectCanvas = null;
    this.effectCanvasCtx = null;
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
  }
}
async function extractVideoMetadata(source) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.preload = "metadata";
    const cleanup = () => {
      video.removeEventListener("loadedmetadata", onLoad);
      video.removeEventListener("error", onError);
      URL.revokeObjectURL(video.src);
    };
    const onLoad = () => {
      const metadata = {
        duration: video.duration,
        frameCount: Math.ceil(video.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: video.videoWidth,
        height: video.videoHeight,
        hasAudio: true
        // Assume true
      };
      cleanup();
      resolve(metadata);
    };
    const onError = () => {
      cleanup();
      reject(new Error("Failed to load video metadata"));
    };
    video.addEventListener("loadedmetadata", onLoad);
    video.addEventListener("error", onError);
    if (typeof source === "string") {
      video.src = source;
    } else {
      video.src = URL.createObjectURL(source);
    }
  });
}
function calculateCompositionFromVideo(metadata, targetFps = 16) {
  const width = Math.round(metadata.width / 8) * 8;
  const height = Math.round(metadata.height / 8) * 8;
  const frameCount = Math.ceil(metadata.duration * targetFps);
  return { width, height, frameCount };
}

const CAMERA_PRESETS = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function createDefaultCamera(id, compWidth, compHeight) {
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  return {
    id,
    name: "Camera 1",
    type: "two-node",
    position: { x: centerX, y: centerY, z: -1500 },
    pointOfInterest: { x: centerX, y: centerY, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: false,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: false
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function createDefaultViewportState() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function createDefaultViewOptions() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: true,
    showLayerHandles: true,
    showSafeZones: false,
    showGrid: false,
    showRulers: true,
    show3DReferenceAxes: true,
    showCompositionBounds: true,
    showFocalPlane: false
  };
}

function controlPointToAnimatable(cp) {
  return {
    id: cp.id,
    x: createAnimatableProperty("x", cp.x, "number"),
    y: createAnimatableProperty("y", cp.y, "number"),
    depth: cp.depth !== void 0 ? createAnimatableProperty("depth", cp.depth, "number") : void 0,
    handleIn: cp.handleIn ? {
      x: createAnimatableProperty("handleIn.x", cp.handleIn.x, "number"),
      y: createAnimatableProperty("handleIn.y", cp.handleIn.y, "number")
    } : null,
    handleOut: cp.handleOut ? {
      x: createAnimatableProperty("handleOut.x", cp.handleOut.x, "number"),
      y: createAnimatableProperty("handleOut.y", cp.handleOut.y, "number")
    } : null,
    type: cp.type,
    group: cp.group
  };
}
function animatableToControlPoint(acp) {
  return {
    id: acp.id,
    x: acp.x.value,
    y: acp.y.value,
    depth: acp.depth?.value,
    handleIn: acp.handleIn ? {
      x: acp.handleIn.x.value,
      y: acp.handleIn.y.value
    } : null,
    handleOut: acp.handleOut ? {
      x: acp.handleOut.x.value,
      y: acp.handleOut.y.value
    } : null,
    type: acp.type,
    group: acp.group
  };
}
function createAnimatableProperty(name, value, type = "number", group) {
  return {
    id: `prop_${name}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name,
    type,
    value,
    animated: false,
    keyframes: [],
    group
  };
}
function createDefaultTransform() {
  const originProp = createAnimatableProperty("origin", { x: 0, y: 0, z: 0 }, "vector3");
  return {
    position: createAnimatableProperty("position", { x: 0, y: 0, z: 0 }, "vector3"),
    origin: originProp,
    // @deprecated alias for backwards compatibility
    anchorPoint: originProp,
    scale: createAnimatableProperty("scale", { x: 100, y: 100, z: 100 }, "vector3"),
    rotation: createAnimatableProperty("rotation", 0, "number"),
    // 3D rotation properties (always present for consistent structure)
    orientation: createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3"),
    rotationX: createAnimatableProperty("rotationX", 0, "number"),
    rotationY: createAnimatableProperty("rotationY", 0, "number"),
    rotationZ: createAnimatableProperty("rotationZ", 0, "number")
  };
}
function createEmptyProject(width, height) {
  const mainCompId = "main";
  const compositionSettings = {
    width,
    height,
    frameCount: 81,
    fps: 16,
    duration: 81 / 16,
    backgroundColor: "#050505",
    autoResizeToContent: true
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [mainCompId]: {
        id: mainCompId,
        name: "Main Comp",
        settings: compositionSettings,
        layers: [],
        currentFrame: 0,
        isNestedComp: false
      }
    },
    mainCompositionId: mainCompId,
    // Legacy alias
    composition: compositionSettings,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}

function isSplineControlPointPath(path) {
  return path.startsWith("spline.controlPoint.");
}
function createSplineControlPointPath(index, property) {
  return `spline.controlPoint.${index}.${property}`;
}
class PropertyDriverSystem {
  drivers = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  audioAnalysis = null;
  propertyGetter = null;
  constructor() {
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(analysis) {
    this.audioAnalysis = analysis;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(getter) {
    this.propertyGetter = getter;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(driver) {
    if (driver.sourceType === "property" && driver.sourceLayerId && driver.sourceProperty) {
      if (this.wouldCreateCycle(driver)) {
        storeLogger.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency");
        return false;
      }
    }
    this.drivers.set(driver.id, driver);
    this.smoothedValues.set(driver.id, 0);
    return true;
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(newDriver) {
    if (newDriver.sourceType !== "property") return false;
    if (!newDriver.sourceLayerId || !newDriver.sourceProperty) return false;
    const visited = /* @__PURE__ */ new Set();
    const targetKey = `${newDriver.targetLayerId}:${newDriver.targetProperty}`;
    const hasCycle = (layerId, property) => {
      const key = `${layerId}:${property}`;
      if (key === targetKey) return true;
      if (visited.has(key)) return false;
      visited.add(key);
      for (const driver of this.drivers.values()) {
        if (driver.sourceType !== "property") continue;
        if (driver.targetLayerId !== layerId || driver.targetProperty !== property) continue;
        if (!driver.sourceLayerId || !driver.sourceProperty) continue;
        if (hasCycle(driver.sourceLayerId, driver.sourceProperty)) {
          return true;
        }
      }
      return false;
    };
    return hasCycle(newDriver.sourceLayerId, newDriver.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(id) {
    this.drivers.delete(id);
    this.smoothedValues.delete(id);
  }
  /**
   * Update a driver
   */
  updateDriver(id, updates) {
    const driver = this.drivers.get(id);
    if (driver) {
      Object.assign(driver, updates);
    }
  }
  /**
   * Get a driver by ID
   */
  getDriver(id) {
    return this.drivers.get(id);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(layerId) {
    return Array.from(this.drivers.values()).filter((d) => d.targetLayerId === layerId);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(layerId, property) {
    return Array.from(this.drivers.values()).filter(
      (d) => d.targetLayerId === layerId && d.targetProperty === property && d.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(driver, frame, baseValue) {
    if (!driver.enabled) return baseValue;
    let value = this.getSourceValue(driver, frame);
    if (value === null) return baseValue;
    value = this.applyTransforms(driver, value);
    return this.blendValue(baseValue, value, driver.blendMode, driver.blendAmount);
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(driver, frame) {
    switch (driver.sourceType) {
      case "property":
        return this.getPropertySourceValue(driver, frame);
      case "audio":
        return this.getAudioSourceValue(driver, frame);
      case "time":
        return frame;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(driver, frame) {
    if (!this.propertyGetter || !driver.sourceLayerId || !driver.sourceProperty) {
      return null;
    }
    return this.propertyGetter(driver.sourceLayerId, driver.sourceProperty, frame);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(driver, frame) {
    if (!this.audioAnalysis || !driver.audioFeature) {
      return null;
    }
    let value = getFeatureAtFrame(this.audioAnalysis, driver.audioFeature, frame);
    if (driver.audioThreshold !== void 0) {
      if (driver.audioAboveThreshold) {
        value = value > driver.audioThreshold ? value : 0;
      } else {
        value = value >= driver.audioThreshold ? value : 0;
      }
    }
    return value;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(driver, value) {
    for (const transform of driver.transforms) {
      value = this.applyTransform(driver.id, transform, value);
    }
    return value;
  }
  /**
   * Apply a single transform
   */
  applyTransform(driverId, transform, value) {
    switch (transform.type) {
      case "scale":
        return value * (transform.factor ?? 1);
      case "offset":
        return value + (transform.amount ?? 0);
      case "clamp":
        return Math.max(transform.min ?? -Infinity, Math.min(transform.max ?? Infinity, value));
      case "smooth": {
        const prevValue = this.smoothedValues.get(driverId) ?? value;
        const smoothing = transform.smoothing ?? 0.5;
        const smoothed = prevValue * smoothing + value * (1 - smoothing);
        this.smoothedValues.set(driverId, smoothed);
        return smoothed;
      }
      case "invert":
        return 1 - value;
      case "remap": {
        const inMin = transform.inMin ?? 0;
        const inMax = transform.inMax ?? 1;
        const outMin = transform.outMin ?? 0;
        const outMax = transform.outMax ?? 1;
        const normalized = (value - inMin) / (inMax - inMin);
        return outMin + normalized * (outMax - outMin);
      }
      case "threshold":
        return value > (transform.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const freq = transform.frequency ?? 1;
        const amp = transform.amplitude ?? 1;
        const phase = transform.phase ?? 0;
        return Math.sin((value * freq + phase) * Math.PI * 2) * amp;
      }
      default:
        return value;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(base, driven, mode, amount) {
    let result;
    switch (mode) {
      case "replace":
        result = driven;
        break;
      case "add":
        result = base + driven;
        break;
      case "multiply":
        result = base * driven;
        break;
      default:
        result = driven;
    }
    return base * (1 - amount) + result * amount;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(layerId, frame, baseValues) {
    const result = /* @__PURE__ */ new Map();
    const drivers = this.getDriversForLayer(layerId);
    for (const driver of drivers) {
      if (!driver.enabled) continue;
      const baseValue = baseValues.get(driver.targetProperty) ?? 0;
      const drivenValue = this.evaluateDriver(driver, frame, baseValue);
      const existing = result.get(driver.targetProperty);
      if (existing !== void 0) {
        result.set(driver.targetProperty, existing + drivenValue - baseValue);
      } else {
        result.set(driver.targetProperty, drivenValue);
      }
    }
    return result;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear();
    this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(drivers) {
    this.clear();
    for (const driver of drivers) {
      this.addDriver(driver);
    }
  }
}
function createPropertyDriver(targetLayerId, targetProperty, sourceType = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: true,
    targetLayerId,
    targetProperty,
    sourceType,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function createAudioDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "audio");
  driver.audioFeature = audioFeature;
  driver.audioThreshold = options.threshold ?? 0;
  driver.audioAboveThreshold = options.threshold !== void 0;
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  if (options.smoothing !== void 0 && options.smoothing > 0) {
    driver.transforms.push({ type: "smooth", smoothing: options.smoothing });
  }
  return driver;
}
function createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "property");
  driver.sourceLayerId = sourceLayerId;
  driver.sourceProperty = sourceProperty;
  driver.blendMode = options.blendMode ?? "add";
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  return driver;
}

const DEFAULT_SNAP_CONFIG = {
  enabled: true,
  snapToGrid: true,
  snapToKeyframes: true,
  snapToBeats: true,
  snapToPeaks: true,
  snapToLayerBounds: true,
  snapToPlayhead: true,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function findNearestSnap(frame, config, pixelsPerFrame, context) {
  if (!config.enabled) {
    return null;
  }
  const snapTargets = [];
  const thresholdFrames = config.threshold / pixelsPerFrame;
  if (config.snapToGrid) {
    const nearestGridFrame = Math.round(frame / config.gridInterval) * config.gridInterval;
    const gridDistance = Math.abs(frame - nearestGridFrame);
    if (gridDistance <= thresholdFrames) {
      snapTargets.push({
        frame: nearestGridFrame,
        type: "frame",
        distance: gridDistance * pixelsPerFrame
      });
    }
  }
  if (config.snapToKeyframes && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, snapTargets);
    }
  }
  if (config.snapToBeats && context.audioAnalysis?.onsets) {
    for (const onset of context.audioAnalysis.onsets) {
      const distance = Math.abs(frame - onset);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: onset,
          type: "beat",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPeaks && context.peakData?.indices) {
    for (const peakFrame of context.peakData.indices) {
      const distance = Math.abs(frame - peakFrame);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: peakFrame,
          type: "peak",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToLayerBounds && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      const layerStart = layer.startFrame ?? layer.inPoint ?? 0;
      const layerEnd = layer.endFrame ?? layer.outPoint ?? 80;
      const inDistance = Math.abs(frame - layerStart);
      const outDistance = Math.abs(frame - layerEnd);
      if (inDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layerStart,
          type: "layer-in",
          distance: inDistance * pixelsPerFrame
        });
      }
      if (outDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layerEnd,
          type: "layer-out",
          distance: outDistance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPlayhead && context.currentFrame !== void 0) {
    const distance = Math.abs(frame - context.currentFrame);
    if (distance <= thresholdFrames && distance > 0) {
      snapTargets.push({
        frame: context.currentFrame,
        type: "playhead",
        distance: distance * pixelsPerFrame
      });
    }
  }
  if (snapTargets.length === 0) {
    return null;
  }
  const priority = {
    "playhead": 5,
    "beat": 4,
    "peak": 4,
    "keyframe": 3,
    "layer-in": 2,
    "layer-out": 2,
    "frame": 1
  };
  snapTargets.sort((a, b) => {
    const distDiff = a.distance - b.distance;
    if (Math.abs(distDiff) < 0.5) {
      return priority[b.type] - priority[a.type];
    }
    return distDiff;
  });
  return snapTargets[0];
}
function collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, targets) {
  const properties = [
    layer.transform.position,
    layer.transform.scale,
    layer.transform.rotation,
    layer.opacity,
    ...layer.properties
  ];
  for (const prop of properties) {
    if (!prop.animated || !prop.keyframes) continue;
    for (const kf of prop.keyframes) {
      const distance = Math.abs(frame - kf.frame);
      if (distance <= thresholdFrames) {
        if (!targets.some((t) => t.frame === kf.frame && t.type === "keyframe")) {
          targets.push({
            frame: kf.frame,
            type: "keyframe",
            distance: distance * pixelsPerFrame
          });
        }
      }
    }
  }
}
function getBeatFrames(audioAnalysis) {
  return audioAnalysis?.onsets ?? [];
}
function getPeakFrames(peakData) {
  return peakData?.indices ?? [];
}

const useSelectionStore$1 = defineStore("selection", {
  state: () => ({
    selectedLayerIds: [],
    lastSelectedLayerId: null,
    selectedKeyframeIds: [],
    selectedControlPoints: [],
    selectedPropertyPath: null,
    currentTool: "select"
  }),
  getters: {
    hasSelection: (state) => state.selectedLayerIds.length > 0,
    hasMultipleSelected: (state) => state.selectedLayerIds.length > 1,
    hasKeyframeSelection: (state) => state.selectedKeyframeIds.length > 0,
    hasControlPointSelection: (state) => state.selectedControlPoints.length > 0,
    singleSelectedLayerId: (state) => state.selectedLayerIds.length === 1 ? state.selectedLayerIds[0] : null,
    selectedControlPointCount: (state) => state.selectedControlPoints.length
  },
  actions: {
    // ============================================================
    // LAYER SELECTION
    // ============================================================
    /**
     * Select a single layer (replaces current selection)
     */
    selectLayer(layerId) {
      this.selectedLayerIds = [layerId];
      this.lastSelectedLayerId = layerId;
      storeLogger.debug("Selected layer:", layerId);
    },
    /**
     * Select multiple layers (replaces current selection)
     */
    selectLayers(layerIds) {
      this.selectedLayerIds = [...layerIds];
      if (layerIds.length > 0) {
        this.lastSelectedLayerId = layerIds[layerIds.length - 1];
      }
      storeLogger.debug("Selected layers:", layerIds.length);
    },
    /**
     * Add layer to selection (multi-select)
     */
    addToSelection(layerId) {
      if (!this.selectedLayerIds.includes(layerId)) {
        this.selectedLayerIds.push(layerId);
        this.lastSelectedLayerId = layerId;
      }
    },
    /**
     * Remove layer from selection
     */
    removeFromSelection(layerId) {
      const index = this.selectedLayerIds.indexOf(layerId);
      if (index >= 0) {
        this.selectedLayerIds.splice(index, 1);
      }
    },
    /**
     * Toggle layer selection
     */
    toggleLayerSelection(layerId) {
      if (this.selectedLayerIds.includes(layerId)) {
        this.removeFromSelection(layerId);
      } else {
        this.addToSelection(layerId);
      }
    },
    /**
     * Select layer with keyboard modifiers (Ctrl/Shift+Click behavior)
     *
     * @param layerId The layer to select
     * @param modifiers Modifier keys state
     * @param orderedLayerIds All layer IDs in order (for shift+click range selection)
     */
    selectLayerWithModifiers(layerId, modifiers, orderedLayerIds) {
      if (modifiers.shift && this.lastSelectedLayerId && orderedLayerIds) {
        this.selectRange(this.lastSelectedLayerId, layerId, orderedLayerIds);
      } else if (modifiers.ctrl) {
        this.toggleLayerSelection(layerId);
        this.lastSelectedLayerId = layerId;
      } else {
        this.selectLayer(layerId);
      }
    },
    /**
     * Select a range of layers between two layer IDs
     *
     * @param startLayerId First layer in range
     * @param endLayerId Last layer in range
     * @param orderedLayerIds All layer IDs in display order
     */
    selectRange(startLayerId, endLayerId, orderedLayerIds) {
      const startIndex = orderedLayerIds.indexOf(startLayerId);
      const endIndex = orderedLayerIds.indexOf(endLayerId);
      if (startIndex === -1 || endIndex === -1) {
        this.selectLayer(endLayerId);
        return;
      }
      const minIndex = Math.min(startIndex, endIndex);
      const maxIndex = Math.max(startIndex, endIndex);
      this.selectedLayerIds = orderedLayerIds.slice(minIndex, maxIndex + 1);
      this.lastSelectedLayerId = endLayerId;
      storeLogger.debug("Range selected layers:", this.selectedLayerIds.length);
    },
    /**
     * Clear layer selection
     */
    clearLayerSelection() {
      this.selectedLayerIds = [];
      this.lastSelectedLayerId = null;
    },
    /**
     * Check if layer is selected
     */
    isLayerSelected(layerId) {
      return this.selectedLayerIds.includes(layerId);
    },
    // ============================================================
    // KEYFRAME SELECTION
    // ============================================================
    /**
     * Select a single keyframe
     */
    selectKeyframe(keyframeId) {
      this.selectedKeyframeIds = [keyframeId];
    },
    /**
     * Select multiple keyframes
     */
    selectKeyframes(keyframeIds) {
      this.selectedKeyframeIds = [...keyframeIds];
    },
    /**
     * Add keyframe to selection
     */
    addKeyframeToSelection(keyframeId) {
      if (!this.selectedKeyframeIds.includes(keyframeId)) {
        this.selectedKeyframeIds.push(keyframeId);
      }
    },
    /**
     * Remove keyframe from selection
     */
    removeKeyframeFromSelection(keyframeId) {
      const index = this.selectedKeyframeIds.indexOf(keyframeId);
      if (index >= 0) {
        this.selectedKeyframeIds.splice(index, 1);
      }
    },
    /**
     * Toggle keyframe selection
     */
    toggleKeyframeSelection(keyframeId) {
      if (this.selectedKeyframeIds.includes(keyframeId)) {
        this.removeKeyframeFromSelection(keyframeId);
      } else {
        this.addKeyframeToSelection(keyframeId);
      }
    },
    /**
     * Clear keyframe selection
     */
    clearKeyframeSelection() {
      this.selectedKeyframeIds = [];
    },
    /**
     * Check if keyframe is selected
     */
    isKeyframeSelected(keyframeId) {
      return this.selectedKeyframeIds.includes(keyframeId);
    },
    // ============================================================
    // CONTROL POINT SELECTION
    // ============================================================
    /**
     * Select a single control point
     */
    selectControlPoint(layerId, pointIndex, groupId) {
      this.selectedControlPoints = [{ layerId, pointIndex, groupId }];
    },
    /**
     * Select multiple control points
     */
    selectControlPoints(points) {
      this.selectedControlPoints = [...points];
    },
    /**
     * Add control point to selection
     */
    addControlPointToSelection(layerId, pointIndex, groupId) {
      const exists = this.selectedControlPoints.some(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
      if (!exists) {
        this.selectedControlPoints.push({ layerId, pointIndex, groupId });
      }
    },
    /**
     * Remove control point from selection
     */
    removeControlPointFromSelection(layerId, pointIndex) {
      this.selectedControlPoints = this.selectedControlPoints.filter(
        (p) => !(p.layerId === layerId && p.pointIndex === pointIndex)
      );
    },
    /**
     * Toggle control point selection
     */
    toggleControlPointSelection(layerId, pointIndex, groupId) {
      const index = this.selectedControlPoints.findIndex(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
      if (index >= 0) {
        this.selectedControlPoints.splice(index, 1);
      } else {
        this.selectedControlPoints.push({ layerId, pointIndex, groupId });
      }
    },
    /**
     * Select control point with keyboard modifiers
     */
    selectControlPointWithModifiers(layerId, pointIndex, modifiers, groupId) {
      if (modifiers.ctrl) {
        this.toggleControlPointSelection(layerId, pointIndex, groupId);
      } else {
        this.selectControlPoint(layerId, pointIndex, groupId);
      }
    },
    /**
     * Select all control points in a group
     * @param groupId The group ID to select
     * @param layerId The layer containing the group
     * @param pointIndicesInGroup All point indices that belong to this group
     */
    selectControlPointGroup(groupId, layerId, pointIndicesInGroup) {
      this.selectedControlPoints = pointIndicesInGroup.map((pointIndex) => ({
        layerId,
        pointIndex,
        groupId
      }));
      storeLogger.debug("Selected control point group:", groupId, "points:", pointIndicesInGroup.length);
    },
    /**
     * Add all control points in a group to selection
     */
    addControlPointGroupToSelection(groupId, layerId, pointIndicesInGroup) {
      for (const pointIndex of pointIndicesInGroup) {
        const exists = this.selectedControlPoints.some(
          (p) => p.layerId === layerId && p.pointIndex === pointIndex
        );
        if (!exists) {
          this.selectedControlPoints.push({ layerId, pointIndex, groupId });
        }
      }
    },
    /**
     * Clear control point selection
     */
    clearControlPointSelection() {
      this.selectedControlPoints = [];
    },
    /**
     * Check if control point is selected
     */
    isControlPointSelected(layerId, pointIndex) {
      return this.selectedControlPoints.some(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
    },
    /**
     * Get selected control points for a specific layer
     */
    getSelectedControlPointsForLayer(layerId) {
      return this.selectedControlPoints.filter((p) => p.layerId === layerId);
    },
    // ============================================================
    // PROPERTY SELECTION
    // ============================================================
    /**
     * Set selected property path (for graph editor focus)
     */
    setSelectedPropertyPath(path) {
      this.selectedPropertyPath = path;
    },
    // ============================================================
    // TOOL STATE
    // ============================================================
    /**
     * Set current tool
     */
    setTool(tool) {
      this.currentTool = tool;
    },
    // ============================================================
    // CLEAR ALL
    // ============================================================
    /**
     * Clear all selections
     */
    clearAll() {
      this.selectedLayerIds = [];
      this.lastSelectedLayerId = null;
      this.selectedKeyframeIds = [];
      this.selectedControlPoints = [];
      this.selectedPropertyPath = null;
    }
  }
});

const layerVersions = /* @__PURE__ */ new Map();
function markLayerDirty(layerId) {
  const current = layerVersions.get(layerId) ?? 0;
  layerVersions.set(layerId, current + 1);
}
const evaluationCache = /* @__PURE__ */ new Map();
function clearLayerCache(layerId) {
  const keysToDelete = [];
  for (const key of evaluationCache.keys()) {
    if (key.startsWith(`${layerId}:`)) {
      keysToDelete.push(key);
    }
  }
  keysToDelete.forEach((key) => evaluationCache.delete(key));
}

/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
  (function() {
    var defineProperty = function() {
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    var codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      var string = String(this);
      var size = string.length;
      var index = position ? Number(position) : 0;
      if (index != index) {
        index = 0;
      }
      if (index < 0 || index >= size) {
        return void 0;
      }
      var first = string.charCodeAt(index);
      var second;
      if (
        // check if its the start of a surrogate pair
        first >= 55296 && first <= 56319 && // high surrogate
        size > index + 1
      ) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree$1() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree$1();
  this.dtree = new Tree$1();
}
var sltree = new Tree$1();
var sdtree = new Tree$1();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var code_tree = new Tree$1();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;
  for (i = 0; i < delta; ++i) {
    bits[i] = 0;
  }
  for (i = 0; i < 30 - delta; ++i) {
    bits[i + delta] = i / delta | 0;
  }
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  var i;
  for (i = 0; i < 7; ++i) {
    lt.table[i] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) {
    lt.trans[i] = 256 + i;
  }
  for (i = 0; i < 144; ++i) {
    lt.trans[24 + i] = i;
  }
  for (i = 0; i < 8; ++i) {
    lt.trans[24 + 144 + i] = 280 + i;
  }
  for (i = 0; i < 112; ++i) {
    lt.trans[24 + 144 + 8 + i] = 144 + i;
  }
  for (i = 0; i < 5; ++i) {
    dt.table[i] = 0;
  }
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) {
    dt.trans[i] = i;
  }
}
var offs = new Uint16Array(16);
function tinf_build_tree(t, lengths2, off, num) {
  var i, sum;
  for (i = 0; i < 16; ++i) {
    t.table[i] = 0;
  }
  for (i = 0; i < num; ++i) {
    t.table[lengths2[off + i]]++;
  }
  t.table[0] = 0;
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths2[off + i]) {
      t.trans[offs[lengths2[off + i]]++] = i;
    }
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num) {
    return base;
  }
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t.trans[sum + cur];
}
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;
  hlit = tinf_read_bits(d, 5, 257);
  hdist = tinf_read_bits(d, 5, 1);
  hclen = tinf_read_bits(d, 4, 4);
  for (i = 0; i < 19; ++i) {
    lengths[i] = 0;
  }
  for (i = 0; i < hclen; ++i) {
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs2;
      var i;
      sym -= 257;
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);
      offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i = offs2; i < offs2 + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) {
    return TINF_DATA_ERROR;
  }
  d.sourceIndex += 4;
  for (i = length; i; --i) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) {
      throw new Error("Data error");
    }
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") {
      return d.dest.slice(0, d.destLen);
    } else {
      return d.dest.subarray(0, d.destLen);
    }
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
var tinyInflate = tinf_uncompress;
function derive(v0, v1, v2, v3, t) {
  return Math.pow(1 - t, 3) * v0 + 3 * Math.pow(1 - t, 2) * t * v1 + 3 * (1 - t) * Math.pow(t, 2) * v2 + Math.pow(t, 3) * v3;
}
function BoundingBox() {
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;
}
BoundingBox.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
BoundingBox.prototype.addPoint = function(x, y) {
  if (typeof x === "number") {
    if (isNaN(this.x1) || isNaN(this.x2)) {
      this.x1 = x;
      this.x2 = x;
    }
    if (x < this.x1) {
      this.x1 = x;
    }
    if (x > this.x2) {
      this.x2 = x;
    }
  }
  if (typeof y === "number") {
    if (isNaN(this.y1) || isNaN(this.y2)) {
      this.y1 = y;
      this.y2 = y;
    }
    if (y < this.y1) {
      this.y1 = y;
    }
    if (y > this.y2) {
      this.y2 = y;
    }
  }
};
BoundingBox.prototype.addX = function(x) {
  this.addPoint(x, null);
};
BoundingBox.prototype.addY = function(y) {
  this.addPoint(null, y);
};
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
  var p0 = [x0, y0];
  var p1 = [x1, y1];
  var p2 = [x2, y2];
  var p3 = [x, y];
  this.addPoint(x0, y0);
  this.addPoint(x, y);
  for (var i = 0; i <= 1; i++) {
    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
    var c = 3 * p1[i] - 3 * p0[i];
    if (a === 0) {
      if (b === 0) {
        continue;
      }
      var t = -c / b;
      if (0 < t && t < 1) {
        if (i === 0) {
          this.addX(derive(p0[i], p1[i], p2[i], p3[i], t));
        }
        if (i === 1) {
          this.addY(derive(p0[i], p1[i], p2[i], p3[i], t));
        }
      }
      continue;
    }
    var b2ac = Math.pow(b, 2) - 4 * c * a;
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
    if (0 < t1 && t1 < 1) {
      if (i === 0) {
        this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
      }
      if (i === 1) {
        this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
      }
    }
    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
    if (0 < t2 && t2 < 1) {
      if (i === 0) {
        this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
      }
      if (i === 1) {
        this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
      }
    }
  }
};
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
  var cp1x = x0 + 2 / 3 * (x1 - x0);
  var cp1y = y0 + 2 / 3 * (y1 - y0);
  var cp2x = cp1x + 1 / 3 * (x - x0);
  var cp2y = cp1y + 1 / 3 * (y - y0);
  this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
function Path() {
  this.commands = [];
  this.fill = "black";
  this.stroke = null;
  this.strokeWidth = 1;
}
Path.prototype.moveTo = function(x, y) {
  this.commands.push({
    type: "M",
    x,
    y
  });
};
Path.prototype.lineTo = function(x, y) {
  this.commands.push({
    type: "L",
    x,
    y
  });
};
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
  this.commands.push({
    type: "C",
    x1,
    y1,
    x2,
    y2,
    x,
    y
  });
};
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
  this.commands.push({
    type: "Q",
    x1,
    y1,
    x,
    y
  });
};
Path.prototype.close = Path.prototype.closePath = function() {
  this.commands.push({
    type: "Z"
  });
};
Path.prototype.extend = function(pathOrCommands) {
  if (pathOrCommands.commands) {
    pathOrCommands = pathOrCommands.commands;
  } else if (pathOrCommands instanceof BoundingBox) {
    var box = pathOrCommands;
    this.moveTo(box.x1, box.y1);
    this.lineTo(box.x2, box.y1);
    this.lineTo(box.x2, box.y2);
    this.lineTo(box.x1, box.y2);
    this.close();
    return;
  }
  Array.prototype.push.apply(this.commands, pathOrCommands);
};
Path.prototype.getBoundingBox = function() {
  var box = new BoundingBox();
  var startX = 0;
  var startY = 0;
  var prevX = 0;
  var prevY = 0;
  for (var i = 0; i < this.commands.length; i++) {
    var cmd = this.commands[i];
    switch (cmd.type) {
      case "M":
        box.addPoint(cmd.x, cmd.y);
        startX = prevX = cmd.x;
        startY = prevY = cmd.y;
        break;
      case "L":
        box.addPoint(cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Q":
        box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "C":
        box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Z":
        prevX = startX;
        prevY = startY;
        break;
      default:
        throw new Error("Unexpected path command " + cmd.type);
    }
  }
  if (box.isEmpty()) {
    box.addPoint(0, 0);
  }
  return box;
};
Path.prototype.draw = function(ctx) {
  ctx.beginPath();
  for (var i = 0; i < this.commands.length; i += 1) {
    var cmd = this.commands[i];
    if (cmd.type === "M") {
      ctx.moveTo(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      ctx.lineTo(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      ctx.closePath();
    }
  }
  if (this.fill) {
    ctx.fillStyle = this.fill;
    ctx.fill();
  }
  if (this.stroke) {
    ctx.strokeStyle = this.stroke;
    ctx.lineWidth = this.strokeWidth;
    ctx.stroke();
  }
};
Path.prototype.toPathData = function(decimalPlaces) {
  decimalPlaces = decimalPlaces !== void 0 ? decimalPlaces : 2;
  function floatToString(v) {
    if (Math.round(v) === v) {
      return "" + Math.round(v);
    } else {
      return v.toFixed(decimalPlaces);
    }
  }
  function packValues() {
    var arguments$1 = arguments;
    var s = "";
    for (var i2 = 0; i2 < arguments.length; i2 += 1) {
      var v = arguments$1[i2];
      if (v >= 0 && i2 > 0) {
        s += " ";
      }
      s += floatToString(v);
    }
    return s;
  }
  var d = "";
  for (var i = 0; i < this.commands.length; i += 1) {
    var cmd = this.commands[i];
    if (cmd.type === "M") {
      d += "M" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      d += "L" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      d += "Z";
    }
  }
  return d;
};
Path.prototype.toSVG = function(decimalPlaces) {
  var svg = '<path d="';
  svg += this.toPathData(decimalPlaces);
  svg += '"';
  if (this.fill && this.fill !== "black") {
    if (this.fill === null) {
      svg += ' fill="none"';
    } else {
      svg += ' fill="' + this.fill + '"';
    }
  }
  if (this.stroke) {
    svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
  }
  svg += "/>";
  return svg;
};
Path.prototype.toDOMElement = function(decimalPlaces) {
  var temporaryPath = this.toPathData(decimalPlaces);
  var newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  newPath.setAttribute("d", temporaryPath);
  return newPath;
};
function fail(message) {
  throw new Error(message);
}
function argument(predicate, message) {
  if (!predicate) {
    fail(message);
  }
}
var check = { fail, argument, assert: argument };
var LIMIT16 = 32768;
var LIMIT32 = 2147483648;
var decode = {};
var encode = {};
var sizeOf = {};
function constant(v) {
  return function() {
    return v;
  };
}
encode.BYTE = function(v) {
  check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
  return [v];
};
sizeOf.BYTE = constant(1);
encode.CHAR = function(v) {
  return [v.charCodeAt(0)];
};
sizeOf.CHAR = constant(1);
encode.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    v = "";
    console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.");
  }
  var b = [];
  for (var i = 0; i < v.length; i += 1) {
    b[i] = v.charCodeAt(i);
  }
  return b;
};
sizeOf.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    return 0;
  }
  return v.length;
};
encode.USHORT = function(v) {
  return [v >> 8 & 255, v & 255];
};
sizeOf.USHORT = constant(2);
encode.SHORT = function(v) {
  if (v >= LIMIT16) {
    v = -(2 * LIMIT16 - v);
  }
  return [v >> 8 & 255, v & 255];
};
sizeOf.SHORT = constant(2);
encode.UINT24 = function(v) {
  return [v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.UINT24 = constant(3);
encode.ULONG = function(v) {
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.ULONG = constant(4);
encode.LONG = function(v) {
  if (v >= LIMIT32) {
    v = -(2 * LIMIT32 - v);
  }
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONG = constant(4);
encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
encode.LONGDATETIME = function(v) {
  return [0, 0, 0, 0, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONGDATETIME = constant(8);
encode.TAG = function(v) {
  check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
  return [
    v.charCodeAt(0),
    v.charCodeAt(1),
    v.charCodeAt(2),
    v.charCodeAt(3)
  ];
};
sizeOf.TAG = constant(4);
encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;
encode.NUMBER = function(v) {
  if (v >= -107 && v <= 107) {
    return [v + 139];
  } else if (v >= 108 && v <= 1131) {
    v = v - 108;
    return [(v >> 8) + 247, v & 255];
  } else if (v >= -1131 && v <= -108) {
    v = -v - 108;
    return [(v >> 8) + 251, v & 255];
  } else if (v >= -32768 && v <= 32767) {
    return encode.NUMBER16(v);
  } else {
    return encode.NUMBER32(v);
  }
};
sizeOf.NUMBER = function(v) {
  return encode.NUMBER(v).length;
};
encode.NUMBER16 = function(v) {
  return [28, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER16 = constant(3);
encode.NUMBER32 = function(v) {
  return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER32 = constant(5);
encode.REAL = function(v) {
  var value = v.toString();
  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
  if (m) {
    var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
    value = (Math.round(v * epsilon) / epsilon).toString();
  }
  var nibbles = "";
  for (var i = 0, ii = value.length; i < ii; i += 1) {
    var c = value[i];
    if (c === "e") {
      nibbles += value[++i] === "-" ? "c" : "b";
    } else if (c === ".") {
      nibbles += "a";
    } else if (c === "-") {
      nibbles += "e";
    } else {
      nibbles += c;
    }
  }
  nibbles += nibbles.length & 1 ? "f" : "ff";
  var out = [30];
  for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
    out.push(parseInt(nibbles.substr(i$1, 2), 16));
  }
  return out;
};
sizeOf.REAL = function(v) {
  return encode.REAL(v).length;
};
encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
decode.UTF8 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes;
  for (var j = 0; j < numChars; j++, offset += 1) {
    codePoints[j] = data.getUint8(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
decode.UTF16 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes / 2;
  for (var j = 0; j < numChars; j++, offset += 2) {
    codePoints[j] = data.getUint16(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
encode.UTF16 = function(v) {
  var b = [];
  for (var i = 0; i < v.length; i += 1) {
    var codepoint = v.charCodeAt(i);
    b[b.length] = codepoint >> 8 & 255;
    b[b.length] = codepoint & 255;
  }
  return b;
};
sizeOf.UTF16 = function(v) {
  return v.length * 2;
};
var eightBitMacEncodings = {
  "x-mac-croatian": (
    // Python: 'mac_croatian'
    ""
  ),
  "x-mac-cyrillic": (
    // Python: 'mac_cyrillic'
    ""
  ),
  "x-mac-gaelic": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    ""
  ),
  "x-mac-greek": (
    // Python: 'mac_greek'
    ""
  ),
  "x-mac-icelandic": (
    // Python: 'mac_iceland'
    ""
  ),
  "x-mac-inuit": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    ""
  ),
  "x-mac-ce": (
    // Python: 'mac_latin2'
    ""
  ),
  macintosh: (
    // Python: 'mac_roman'
    ""
  ),
  "x-mac-romanian": (
    // Python: 'mac_romanian'
    ""
  ),
  "x-mac-turkish": (
    // Python: 'mac_turkish'
    ""
  )
};
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
  var table2 = eightBitMacEncodings[encoding];
  if (table2 === void 0) {
    return void 0;
  }
  var result = "";
  for (var i = 0; i < dataLength; i++) {
    var c = dataView.getUint8(offset + i);
    if (c <= 127) {
      result += String.fromCharCode(c);
    } else {
      result += table2[c & 127];
    }
  }
  return result;
};
var macEncodingTableCache = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function(encoding) {
  if (!macEncodingCacheKeys) {
    macEncodingCacheKeys = {};
    for (var e in eightBitMacEncodings) {
      macEncodingCacheKeys[e] = new String(e);
    }
  }
  var cacheKey = macEncodingCacheKeys[encoding];
  if (cacheKey === void 0) {
    return void 0;
  }
  if (macEncodingTableCache) {
    var cachedTable = macEncodingTableCache.get(cacheKey);
    if (cachedTable !== void 0) {
      return cachedTable;
    }
  }
  var decodingTable = eightBitMacEncodings[encoding];
  if (decodingTable === void 0) {
    return void 0;
  }
  var encodingTable = {};
  for (var i = 0; i < decodingTable.length; i++) {
    encodingTable[decodingTable.charCodeAt(i)] = i + 128;
  }
  if (macEncodingTableCache) {
    macEncodingTableCache.set(cacheKey, encodingTable);
  }
  return encodingTable;
};
encode.MACSTRING = function(str, encoding) {
  var table2 = getMacEncodingTable(encoding);
  if (table2 === void 0) {
    return void 0;
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c >= 128) {
      c = table2[c];
      if (c === void 0) {
        return void 0;
      }
    }
    result[i] = c;
  }
  return result;
};
sizeOf.MACSTRING = function(str, encoding) {
  var b = encode.MACSTRING(str, encoding);
  if (b !== void 0) {
    return b.length;
  } else {
    return 0;
  }
};
function isByteEncodable(value) {
  return value >= -128 && value <= 127;
}
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
    ++pos;
    ++runLength;
  }
  result.push(128 | runLength - 1);
  return pos;
}
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (!isByteEncodable(value)) {
      break;
    }
    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(runLength - 1);
  for (var i = offset; i < pos; ++i) {
    result.push(deltas[i] + 256 & 255);
  }
  return pos;
}
function encodeVarDeltaRunAsWords(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (value === 0) {
      break;
    }
    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(64 | runLength - 1);
  for (var i = offset; i < pos; ++i) {
    var val = deltas[i];
    result.push(val + 65536 >> 8 & 255, val + 256 & 255);
  }
  return pos;
}
encode.VARDELTAS = function(deltas) {
  var pos = 0;
  var result = [];
  while (pos < deltas.length) {
    var value = deltas[pos];
    if (value === 0) {
      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
    } else if (value >= -128 && value <= 127) {
      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
    } else {
      pos = encodeVarDeltaRunAsWords(deltas, pos, result);
    }
  }
  return result;
};
encode.INDEX = function(l) {
  var offset = 1;
  var offsets = [offset];
  var data = [];
  for (var i = 0; i < l.length; i += 1) {
    var v = encode.OBJECT(l[i]);
    Array.prototype.push.apply(data, v);
    offset += v.length;
    offsets.push(offset);
  }
  if (data.length === 0) {
    return [0, 0];
  }
  var encodedOffsets = [];
  var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
  var offsetEncoder = [void 0, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
  for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
    var encodedOffset = offsetEncoder(offsets[i$1]);
    Array.prototype.push.apply(encodedOffsets, encodedOffset);
  }
  return Array.prototype.concat(
    encode.Card16(l.length),
    encode.OffSize(offSize),
    encodedOffsets,
    data
  );
};
sizeOf.INDEX = function(v) {
  return encode.INDEX(v).length;
};
encode.DICT = function(m) {
  var d = [];
  var keys = Object.keys(m);
  var length = keys.length;
  for (var i = 0; i < length; i += 1) {
    var k = parseInt(keys[i], 0);
    var v = m[k];
    d = d.concat(encode.OPERAND(v.value, v.type));
    d = d.concat(encode.OPERATOR(k));
  }
  return d;
};
sizeOf.DICT = function(m) {
  return encode.DICT(m).length;
};
encode.OPERATOR = function(v) {
  if (v < 1200) {
    return [v];
  } else {
    return [12, v - 1200];
  }
};
encode.OPERAND = function(v, type) {
  var d = [];
  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i += 1) {
      check.argument(v.length === type.length, "Not enough arguments given for type" + type);
      d = d.concat(encode.OPERAND(v[i], type[i]));
    }
  } else {
    if (type === "SID") {
      d = d.concat(encode.NUMBER(v));
    } else if (type === "offset") {
      d = d.concat(encode.NUMBER32(v));
    } else if (type === "number") {
      d = d.concat(encode.NUMBER(v));
    } else if (type === "real") {
      d = d.concat(encode.REAL(v));
    } else {
      throw new Error("Unknown operand type " + type);
    }
  }
  return d;
};
encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;
var wmm = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
encode.CHARSTRING = function(ops) {
  if (wmm) {
    var cachedValue = wmm.get(ops);
    if (cachedValue !== void 0) {
      return cachedValue;
    }
  }
  var d = [];
  var length = ops.length;
  for (var i = 0; i < length; i += 1) {
    var op = ops[i];
    d = d.concat(encode[op.type](op.value));
  }
  if (wmm) {
    wmm.set(ops, d);
  }
  return d;
};
sizeOf.CHARSTRING = function(ops) {
  return encode.CHARSTRING(ops).length;
};
encode.OBJECT = function(v) {
  var encodingFunction = encode[v.type];
  check.argument(encodingFunction !== void 0, "No encoding function for type " + v.type);
  return encodingFunction(v.value);
};
sizeOf.OBJECT = function(v) {
  var sizeOfFunction = sizeOf[v.type];
  check.argument(sizeOfFunction !== void 0, "No sizeOf function for type " + v.type);
  return sizeOfFunction(v.value);
};
encode.TABLE = function(table2) {
  var d = [];
  var length = table2.fields.length;
  var subtables = [];
  var subtableOffsets = [];
  for (var i = 0; i < length; i += 1) {
    var field = table2.fields[i];
    var encodingFunction = encode[field.type];
    check.argument(encodingFunction !== void 0, "No encoding function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    var bytes = encodingFunction(value);
    if (field.type === "TABLE") {
      subtableOffsets.push(d.length);
      d = d.concat([0, 0]);
      subtables.push(bytes);
    } else {
      d = d.concat(bytes);
    }
  }
  for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
    var o = subtableOffsets[i$1];
    var offset = d.length;
    check.argument(offset < 65536, "Table " + table2.tableName + " too big.");
    d[o] = offset >> 8;
    d[o + 1] = offset & 255;
    d = d.concat(subtables[i$1]);
  }
  return d;
};
sizeOf.TABLE = function(table2) {
  var numBytes = 0;
  var length = table2.fields.length;
  for (var i = 0; i < length; i += 1) {
    var field = table2.fields[i];
    var sizeOfFunction = sizeOf[field.type];
    check.argument(sizeOfFunction !== void 0, "No sizeOf function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    numBytes += sizeOfFunction(value);
    if (field.type === "TABLE") {
      numBytes += 2;
    }
  }
  return numBytes;
};
encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
encode.LITERAL = function(v) {
  return v;
};
sizeOf.LITERAL = function(v) {
  return v.length;
};
function Table(tableName, fields, options) {
  if (fields.length && (fields[0].name !== "coverageFormat" || fields[0].value === 1)) {
    for (var i = 0; i < fields.length; i += 1) {
      var field = fields[i];
      this[field.name] = field.value;
    }
  }
  this.tableName = tableName;
  this.fields = fields;
  if (options) {
    var optionKeys = Object.keys(options);
    for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
      var k = optionKeys[i$1];
      var v = options[k];
      if (this[k] !== void 0) {
        this[k] = v;
      }
    }
  }
}
Table.prototype.encode = function() {
  return encode.TABLE(this);
};
Table.prototype.sizeOf = function() {
  return sizeOf.TABLE(this);
};
function ushortList(itemName, list, count) {
  if (count === void 0) {
    count = list.length;
  }
  var fields = new Array(list.length + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < list.length; i++) {
    fields[i + 1] = { name: itemName + i, type: "USHORT", value: list[i] };
  }
  return fields;
}
function tableList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = new Array(count + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < count; i++) {
    fields[i + 1] = { name: itemName + i, type: "TABLE", value: itemCallback(records[i], i) };
  }
  return fields;
}
function recordList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = [];
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < count; i++) {
    fields = fields.concat(itemCallback(records[i], i));
  }
  return fields;
}
function Coverage(coverageTable) {
  if (coverageTable.format === 1) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ushortList("glyph", coverageTable.glyphs))
    );
  } else if (coverageTable.format === 2) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(recordList("rangeRecord", coverageTable.ranges, function(RangeRecord) {
        return [
          { name: "startGlyphID", type: "USHORT", value: RangeRecord.start },
          { name: "endGlyphID", type: "USHORT", value: RangeRecord.end },
          { name: "startCoverageIndex", type: "USHORT", value: RangeRecord.index }
        ];
      }))
    );
  } else {
    check.assert(false, "Coverage format must be 1 or 2.");
  }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
  Table.call(
    this,
    "scriptListTable",
    recordList("scriptRecord", scriptListTable, function(scriptRecord, i) {
      var script = scriptRecord.script;
      var defaultLangSys = script.defaultLangSys;
      check.assert(!!defaultLangSys, "Unable to write GSUB: script " + scriptRecord.tag + " has no default language system.");
      return [
        { name: "scriptTag" + i, type: "TAG", value: scriptRecord.tag },
        { name: "script" + i, type: "TABLE", value: new Table("scriptTable", [
          { name: "defaultLangSys", type: "TABLE", value: new Table("defaultLangSys", [
            { name: "lookupOrder", type: "USHORT", value: 0 },
            { name: "reqFeatureIndex", type: "USHORT", value: defaultLangSys.reqFeatureIndex }
          ].concat(ushortList("featureIndex", defaultLangSys.featureIndexes))) }
        ].concat(recordList("langSys", script.langSysRecords, function(langSysRecord, i2) {
          var langSys = langSysRecord.langSys;
          return [
            { name: "langSysTag" + i2, type: "TAG", value: langSysRecord.tag },
            { name: "langSys" + i2, type: "TABLE", value: new Table("langSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: langSys.reqFeatureIndex }
            ].concat(ushortList("featureIndex", langSys.featureIndexes))) }
          ];
        }))) }
      ];
    })
  );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
function FeatureList(featureListTable) {
  Table.call(
    this,
    "featureListTable",
    recordList("featureRecord", featureListTable, function(featureRecord, i) {
      var feature = featureRecord.feature;
      return [
        { name: "featureTag" + i, type: "TAG", value: featureRecord.tag },
        { name: "feature" + i, type: "TABLE", value: new Table("featureTable", [
          { name: "featureParams", type: "USHORT", value: feature.featureParams }
        ].concat(ushortList("lookupListIndex", feature.lookupListIndexes))) }
      ];
    })
  );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
function LookupList(lookupListTable, subtableMakers2) {
  Table.call(this, "lookupListTable", tableList("lookup", lookupListTable, function(lookupTable) {
    var subtableCallback = subtableMakers2[lookupTable.lookupType];
    check.assert(!!subtableCallback, "Unable to write GSUB lookup type " + lookupTable.lookupType + " tables.");
    return new Table("lookupTable", [
      { name: "lookupType", type: "USHORT", value: lookupTable.lookupType },
      { name: "lookupFlag", type: "USHORT", value: lookupTable.lookupFlag }
    ].concat(tableList("subtable", lookupTable.subtables, subtableCallback)));
  }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
var table = {
  Table,
  Record: Table,
  Coverage,
  ScriptList,
  FeatureList,
  LookupList,
  ushortList,
  tableList,
  recordList
};
function getByte(dataView, offset) {
  return dataView.getUint8(offset);
}
function getUShort(dataView, offset) {
  return dataView.getUint16(offset, false);
}
function getShort(dataView, offset) {
  return dataView.getInt16(offset, false);
}
function getULong(dataView, offset) {
  return dataView.getUint32(offset, false);
}
function getFixed(dataView, offset) {
  var decimal = dataView.getInt16(offset, false);
  var fraction = dataView.getUint16(offset + 2, false);
  return decimal + fraction / 65535;
}
function getTag(dataView, offset) {
  var tag = "";
  for (var i = offset; i < offset + 4; i += 1) {
    tag += String.fromCharCode(dataView.getInt8(i));
  }
  return tag;
}
function getOffset(dataView, offset, offSize) {
  var v = 0;
  for (var i = 0; i < offSize; i += 1) {
    v <<= 8;
    v += dataView.getUint8(offset + i);
  }
  return v;
}
function getBytes(dataView, startOffset, endOffset) {
  var bytes = [];
  for (var i = startOffset; i < endOffset; i += 1) {
    bytes.push(dataView.getUint8(i));
  }
  return bytes;
}
function bytesToString(bytes) {
  var s = "";
  for (var i = 0; i < bytes.length; i += 1) {
    s += String.fromCharCode(bytes[i]);
  }
  return s;
}
var typeOffsets = {
  byte: 1,
  uShort: 2,
  short: 2,
  uLong: 4,
  fixed: 4,
  longDateTime: 8,
  tag: 4
};
function Parser(data, offset) {
  this.data = data;
  this.offset = offset;
  this.relativeOffset = 0;
}
Parser.prototype.parseByte = function() {
  var v = this.data.getUint8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser.prototype.parseChar = function() {
  var v = this.data.getInt8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser.prototype.parseCard8 = Parser.prototype.parseByte;
Parser.prototype.parseUShort = function() {
  var v = this.data.getUint16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
Parser.prototype.parseShort = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseF2Dot14 = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseULong = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
Parser.prototype.parseFixed = function() {
  var v = getFixed(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser.prototype.parseString = function(length) {
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  var string = "";
  this.relativeOffset += length;
  for (var i = 0; i < length; i++) {
    string += String.fromCharCode(dataView.getUint8(offset + i));
  }
  return string;
};
Parser.prototype.parseTag = function() {
  return this.parseString(4);
};
Parser.prototype.parseLongDateTime = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset + 4);
  v -= 2082844800;
  this.relativeOffset += 8;
  return v;
};
Parser.prototype.parseVersion = function(minorBase) {
  var major = getUShort(this.data, this.offset + this.relativeOffset);
  var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
  this.relativeOffset += 4;
  if (minorBase === void 0) {
    minorBase = 4096;
  }
  return major + minor / minorBase / 10;
};
Parser.prototype.skip = function(type, amount) {
  if (amount === void 0) {
    amount = 1;
  }
  this.relativeOffset += typeOffsets[type] * amount;
};
Parser.prototype.parseULongList = function(count) {
  if (count === void 0) {
    count = this.parseULong();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    offsets[i] = dataView.getUint32(offset);
    offset += 4;
  }
  this.relativeOffset += count * 4;
  return offsets;
};
Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {
  if (count === void 0) {
    count = this.parseUShort();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    offsets[i] = dataView.getUint16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return offsets;
};
Parser.prototype.parseShortList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    list[i] = dataView.getInt16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return list;
};
Parser.prototype.parseByteList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    list[i] = dataView.getUint8(offset++);
  }
  this.relativeOffset += count;
  return list;
};
Parser.prototype.parseList = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseUShort();
  }
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    list[i] = itemCallback.call(this);
  }
  return list;
};
Parser.prototype.parseList32 = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseULong();
  }
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    list[i] = itemCallback.call(this);
  }
  return list;
};
Parser.prototype.parseRecordList = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseUShort();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i = 0; i < count; i++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i] = rec;
  }
  return records;
};
Parser.prototype.parseRecordList32 = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseULong();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i = 0; i < count; i++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i] = rec;
  }
  return records;
};
Parser.prototype.parseStruct = function(description) {
  if (typeof description === "function") {
    return description.call(this);
  } else {
    var fields = Object.keys(description);
    var struct = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = description[fieldName];
      struct[fieldName] = fieldType.call(this);
    }
    return struct;
  }
};
Parser.prototype.parseValueRecord = function(valueFormat) {
  if (valueFormat === void 0) {
    valueFormat = this.parseUShort();
  }
  if (valueFormat === 0) {
    return;
  }
  var valueRecord = {};
  if (valueFormat & 1) {
    valueRecord.xPlacement = this.parseShort();
  }
  if (valueFormat & 2) {
    valueRecord.yPlacement = this.parseShort();
  }
  if (valueFormat & 4) {
    valueRecord.xAdvance = this.parseShort();
  }
  if (valueFormat & 8) {
    valueRecord.yAdvance = this.parseShort();
  }
  if (valueFormat & 16) {
    valueRecord.xPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 32) {
    valueRecord.yPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 64) {
    valueRecord.xAdvDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 128) {
    valueRecord.yAdvDevice = void 0;
    this.parseShort();
  }
  return valueRecord;
};
Parser.prototype.parseValueRecordList = function() {
  var valueFormat = this.parseUShort();
  var valueCount = this.parseUShort();
  var values = new Array(valueCount);
  for (var i = 0; i < valueCount; i++) {
    values[i] = this.parseValueRecord(valueFormat);
  }
  return values;
};
Parser.prototype.parsePointer = function(description) {
  var structOffset = this.parseOffset16();
  if (structOffset > 0) {
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser.prototype.parsePointer32 = function(description) {
  var structOffset = this.parseOffset32();
  if (structOffset > 0) {
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser.prototype.parseListOfLists = function(itemCallback) {
  var offsets = this.parseOffset16List();
  var count = offsets.length;
  var relativeOffset = this.relativeOffset;
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    var start = offsets[i];
    if (start === 0) {
      list[i] = void 0;
      continue;
    }
    this.relativeOffset = start;
    if (itemCallback) {
      var subOffsets = this.parseOffset16List();
      var subList = new Array(subOffsets.length);
      for (var j = 0; j < subOffsets.length; j++) {
        this.relativeOffset = start + subOffsets[j];
        subList[j] = itemCallback.call(this);
      }
      list[i] = subList;
    } else {
      list[i] = this.parseUShortList();
    }
  }
  this.relativeOffset = relativeOffset;
  return list;
};
Parser.prototype.parseCoverage = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  var count = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      glyphs: this.parseUShortList(count)
    };
  } else if (format === 2) {
    var ranges = new Array(count);
    for (var i = 0; i < count; i++) {
      ranges[i] = {
        start: this.parseUShort(),
        end: this.parseUShort(),
        index: this.parseUShort()
      };
    }
    return {
      format: 2,
      ranges
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": Coverage format must be 1 or 2.");
};
Parser.prototype.parseClassDef = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      startGlyph: this.parseUShort(),
      classes: this.parseUShortList()
    };
  } else if (format === 2) {
    return {
      format: 2,
      ranges: this.parseRecordList({
        start: Parser.uShort,
        end: Parser.uShort,
        classId: Parser.uShort
      })
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": ClassDef format must be 1 or 2.");
};
Parser.list = function(count, itemCallback) {
  return function() {
    return this.parseList(count, itemCallback);
  };
};
Parser.list32 = function(count, itemCallback) {
  return function() {
    return this.parseList32(count, itemCallback);
  };
};
Parser.recordList = function(count, recordDescription) {
  return function() {
    return this.parseRecordList(count, recordDescription);
  };
};
Parser.recordList32 = function(count, recordDescription) {
  return function() {
    return this.parseRecordList32(count, recordDescription);
  };
};
Parser.pointer = function(description) {
  return function() {
    return this.parsePointer(description);
  };
};
Parser.pointer32 = function(description) {
  return function() {
    return this.parsePointer32(description);
  };
};
Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;
var langSysTable = {
  reserved: Parser.uShort,
  reqFeatureIndex: Parser.uShort,
  featureIndexes: Parser.uShortList
};
Parser.prototype.parseScriptList = function() {
  return this.parsePointer(Parser.recordList({
    tag: Parser.tag,
    script: Parser.pointer({
      defaultLangSys: Parser.pointer(langSysTable),
      langSysRecords: Parser.recordList({
        tag: Parser.tag,
        langSys: Parser.pointer(langSysTable)
      })
    })
  })) || [];
};
Parser.prototype.parseFeatureList = function() {
  return this.parsePointer(Parser.recordList({
    tag: Parser.tag,
    feature: Parser.pointer({
      featureParams: Parser.offset16,
      lookupListIndexes: Parser.uShortList
    })
  })) || [];
};
Parser.prototype.parseLookupList = function(lookupTableParsers) {
  return this.parsePointer(Parser.list(Parser.pointer(function() {
    var lookupType = this.parseUShort();
    check.argument(1 <= lookupType && lookupType <= 9, "GPOS/GSUB lookup type " + lookupType + " unknown.");
    var lookupFlag = this.parseUShort();
    var useMarkFilteringSet = lookupFlag & 16;
    return {
      lookupType,
      lookupFlag,
      subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : void 0
    };
  }))) || [];
};
Parser.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var majorVersion = this.parseUShort();
    var minorVersion = this.parseUShort();
    check.argument(majorVersion === 1 && minorVersion < 1, "GPOS/GSUB feature variations table unknown.");
    var featureVariations = this.parseRecordList32({
      conditionSetOffset: Parser.offset32,
      featureTableSubstitutionOffset: Parser.offset32
    });
    return featureVariations;
  }) || [];
};
var parse = {
  getByte,
  getCard8: getByte,
  getUShort,
  getCard16: getUShort,
  getShort,
  getULong,
  getFixed,
  getTag,
  getOffset,
  getBytes,
  bytesToString,
  Parser
};
function parseCmapTableFormat12(cmap2, p) {
  p.parseUShort();
  cmap2.length = p.parseULong();
  cmap2.language = p.parseULong();
  var groupCount;
  cmap2.groupCount = groupCount = p.parseULong();
  cmap2.glyphIndexMap = {};
  for (var i = 0; i < groupCount; i += 1) {
    var startCharCode = p.parseULong();
    var endCharCode = p.parseULong();
    var startGlyphId = p.parseULong();
    for (var c = startCharCode; c <= endCharCode; c += 1) {
      cmap2.glyphIndexMap[c] = startGlyphId;
      startGlyphId++;
    }
  }
}
function parseCmapTableFormat4(cmap2, p, data, start, offset) {
  cmap2.length = p.parseUShort();
  cmap2.language = p.parseUShort();
  var segCount;
  cmap2.segCount = segCount = p.parseUShort() >> 1;
  p.skip("uShort", 3);
  cmap2.glyphIndexMap = {};
  var endCountParser = new parse.Parser(data, start + offset + 14);
  var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
  var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
  var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
  var glyphIndexOffset = start + offset + 16 + segCount * 8;
  for (var i = 0; i < segCount - 1; i += 1) {
    var glyphIndex = void 0;
    var endCount = endCountParser.parseUShort();
    var startCount = startCountParser.parseUShort();
    var idDelta = idDeltaParser.parseShort();
    var idRangeOffset = idRangeOffsetParser.parseUShort();
    for (var c = startCount; c <= endCount; c += 1) {
      if (idRangeOffset !== 0) {
        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
        glyphIndexOffset += idRangeOffset;
        glyphIndexOffset += (c - startCount) * 2;
        glyphIndex = parse.getUShort(data, glyphIndexOffset);
        if (glyphIndex !== 0) {
          glyphIndex = glyphIndex + idDelta & 65535;
        }
      } else {
        glyphIndex = c + idDelta & 65535;
      }
      cmap2.glyphIndexMap[c] = glyphIndex;
    }
  }
}
function parseCmapTable(data, start) {
  var cmap2 = {};
  cmap2.version = parse.getUShort(data, start);
  check.argument(cmap2.version === 0, "cmap table version should be 0.");
  cmap2.numTables = parse.getUShort(data, start + 2);
  var offset = -1;
  for (var i = cmap2.numTables - 1; i >= 0; i -= 1) {
    var platformId = parse.getUShort(data, start + 4 + i * 8);
    var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);
    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
      offset = parse.getULong(data, start + 4 + i * 8 + 4);
      break;
    }
  }
  if (offset === -1) {
    throw new Error("No valid cmap sub-tables found.");
  }
  var p = new parse.Parser(data, start + offset);
  cmap2.format = p.parseUShort();
  if (cmap2.format === 12) {
    parseCmapTableFormat12(cmap2, p);
  } else if (cmap2.format === 4) {
    parseCmapTableFormat4(cmap2, p, data, start, offset);
  } else {
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + cmap2.format + ").");
  }
  return cmap2;
}
function addSegment(t, code, glyphIndex) {
  t.segments.push({
    end: code,
    start: code,
    delta: -(code - glyphIndex),
    offset: 0,
    glyphIndex
  });
}
function addTerminatorSegment(t) {
  t.segments.push({
    end: 65535,
    start: 65535,
    delta: 1,
    offset: 0
  });
}
function makeCmapTable(glyphs) {
  var isPlan0Only = true;
  var i;
  for (i = glyphs.length - 1; i > 0; i -= 1) {
    var g = glyphs.get(i);
    if (g.unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)");
      isPlan0Only = false;
      break;
    }
  }
  var cmapTable = [
    { name: "version", type: "USHORT", value: 0 },
    { name: "numTables", type: "USHORT", value: isPlan0Only ? 1 : 2 },
    // CMAP 4 header
    { name: "platformID", type: "USHORT", value: 3 },
    { name: "encodingID", type: "USHORT", value: 1 },
    { name: "offset", type: "ULONG", value: isPlan0Only ? 12 : 12 + 8 }
  ];
  if (!isPlan0Only) {
    cmapTable = cmapTable.concat([
      // CMAP 12 header
      { name: "cmap12PlatformID", type: "USHORT", value: 3 },
      // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
      { name: "cmap12EncodingID", type: "USHORT", value: 10 },
      { name: "cmap12Offset", type: "ULONG", value: 0 }
    ]);
  }
  cmapTable = cmapTable.concat([
    // CMAP 4 Subtable
    { name: "format", type: "USHORT", value: 4 },
    { name: "cmap4Length", type: "USHORT", value: 0 },
    { name: "language", type: "USHORT", value: 0 },
    { name: "segCountX2", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  var t = new table.Table("cmap", cmapTable);
  t.segments = [];
  for (i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    for (var j = 0; j < glyph.unicodes.length; j += 1) {
      addSegment(t, glyph.unicodes[j], i);
    }
    t.segments = t.segments.sort(function(a, b) {
      return a.start - b.start;
    });
  }
  addTerminatorSegment(t);
  var segCount = t.segments.length;
  var segCountToRemove = 0;
  var endCounts = [];
  var startCounts = [];
  var idDeltas = [];
  var idRangeOffsets = [];
  var glyphIds = [];
  var cmap12Groups = [];
  for (i = 0; i < segCount; i += 1) {
    var segment = t.segments[i];
    if (segment.end <= 65535 && segment.start <= 65535) {
      endCounts = endCounts.concat({ name: "end_" + i, type: "USHORT", value: segment.end });
      startCounts = startCounts.concat({ name: "start_" + i, type: "USHORT", value: segment.start });
      idDeltas = idDeltas.concat({ name: "idDelta_" + i, type: "SHORT", value: segment.delta });
      idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i, type: "USHORT", value: segment.offset });
      if (segment.glyphId !== void 0) {
        glyphIds = glyphIds.concat({ name: "glyph_" + i, type: "USHORT", value: segment.glyphId });
      }
    } else {
      segCountToRemove += 1;
    }
    if (!isPlan0Only && segment.glyphIndex !== void 0) {
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Start_" + i, type: "ULONG", value: segment.start });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12End_" + i, type: "ULONG", value: segment.end });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Glyph_" + i, type: "ULONG", value: segment.glyphIndex });
    }
  }
  t.segCountX2 = (segCount - segCountToRemove) * 2;
  t.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
  t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
  t.rangeShift = t.segCountX2 - t.searchRange;
  t.fields = t.fields.concat(endCounts);
  t.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  t.fields = t.fields.concat(startCounts);
  t.fields = t.fields.concat(idDeltas);
  t.fields = t.fields.concat(idRangeOffsets);
  t.fields = t.fields.concat(glyphIds);
  t.cmap4Length = 14 + // Subtable header
  endCounts.length * 2 + 2 + // reservedPad
  startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
  if (!isPlan0Only) {
    var cmap12Length = 16 + // Subtable header
    cmap12Groups.length * 4;
    t.cmap12Offset = 12 + 2 * 2 + 4 + t.cmap4Length;
    t.fields = t.fields.concat([
      { name: "cmap12Format", type: "USHORT", value: 12 },
      { name: "cmap12Reserved", type: "USHORT", value: 0 },
      { name: "cmap12Length", type: "ULONG", value: cmap12Length },
      { name: "cmap12Language", type: "ULONG", value: 0 },
      { name: "cmap12nGroups", type: "ULONG", value: cmap12Groups.length / 3 }
    ]);
    t.fields = t.fields.concat(cmap12Groups);
  }
  return t;
}
var cmap = { parse: parseCmapTable, make: makeCmapTable };
var cffStandardStrings = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "266 ff",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var cffStandardEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var cffExpertEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var standardNames = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function DefaultEncoding(font) {
  this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c) {
  var code = c.codePointAt(0);
  var glyphs = this.font.glyphs;
  if (glyphs) {
    for (var i = 0; i < glyphs.length; i += 1) {
      var glyph = glyphs.get(i);
      for (var j = 0; j < glyph.unicodes.length; j += 1) {
        if (glyph.unicodes[j] === code) {
          return i;
        }
      }
    }
  }
  return null;
};
function CmapEncoding(cmap2) {
  this.cmap = cmap2;
}
CmapEncoding.prototype.charToGlyphIndex = function(c) {
  return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
};
function CffEncoding(encoding, charset) {
  this.encoding = encoding;
  this.charset = charset;
}
CffEncoding.prototype.charToGlyphIndex = function(s) {
  var code = s.codePointAt(0);
  var charName = this.encoding[code];
  return this.charset.indexOf(charName);
};
function GlyphNames(post2) {
  switch (post2.version) {
    case 1:
      this.names = standardNames.slice();
      break;
    case 2:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i = 0; i < post2.numberOfGlyphs; i++) {
        if (post2.glyphNameIndex[i] < standardNames.length) {
          this.names[i] = standardNames[post2.glyphNameIndex[i]];
        } else {
          this.names[i] = post2.names[post2.glyphNameIndex[i] - standardNames.length];
        }
      }
      break;
    case 2.5:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        this.names[i$1] = standardNames[i$1 + post2.glyphNameIndex[i$1]];
      }
      break;
    case 3:
      this.names = [];
      break;
    default:
      this.names = [];
      break;
  }
}
GlyphNames.prototype.nameToGlyphIndex = function(name) {
  return this.names.indexOf(name);
};
GlyphNames.prototype.glyphIndexToName = function(gid) {
  return this.names[gid];
};
function addGlyphNamesAll(font) {
  var glyph;
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i = 0; i < charCodes.length; i += 1) {
    var c = charCodes[i];
    var glyphIndex = glyphIndexMap[c];
    glyph = font.glyphs.get(glyphIndex);
    glyph.addUnicode(parseInt(c));
  }
  for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
    glyph = font.glyphs.get(i$1);
    if (font.cffEncoding) {
      if (font.isCIDFont) {
        glyph.name = "gid" + i$1;
      } else {
        glyph.name = font.cffEncoding.charset[i$1];
      }
    } else if (font.glyphNames.names) {
      glyph.name = font.glyphNames.glyphIndexToName(i$1);
    }
  }
}
function addGlyphNamesToUnicodeMap(font) {
  font._IndexToUnicodeMap = {};
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i = 0; i < charCodes.length; i += 1) {
    var c = charCodes[i];
    var glyphIndex = glyphIndexMap[c];
    if (font._IndexToUnicodeMap[glyphIndex] === void 0) {
      font._IndexToUnicodeMap[glyphIndex] = {
        unicodes: [parseInt(c)]
      };
    } else {
      font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
    }
  }
}
function addGlyphNames(font, opt) {
  if (opt.lowMemory) {
    addGlyphNamesToUnicodeMap(font);
  } else {
    addGlyphNamesAll(font);
  }
}
function line(ctx, x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}
var draw = { line };
function getPathDefinition(glyph, path) {
  var _path = path || new Path();
  return {
    configurable: true,
    get: function() {
      if (typeof _path === "function") {
        _path = _path();
      }
      return _path;
    },
    set: function(p) {
      _path = p;
    }
  };
}
function Glyph(options) {
  this.bindConstructorValues(options);
}
Glyph.prototype.bindConstructorValues = function(options) {
  this.index = options.index || 0;
  this.name = options.name || null;
  this.unicode = options.unicode || void 0;
  this.unicodes = options.unicodes || options.unicode !== void 0 ? [options.unicode] : [];
  if ("xMin" in options) {
    this.xMin = options.xMin;
  }
  if ("yMin" in options) {
    this.yMin = options.yMin;
  }
  if ("xMax" in options) {
    this.xMax = options.xMax;
  }
  if ("yMax" in options) {
    this.yMax = options.yMax;
  }
  if ("advanceWidth" in options) {
    this.advanceWidth = options.advanceWidth;
  }
  Object.defineProperty(this, "path", getPathDefinition(this, options.path));
};
Glyph.prototype.addUnicode = function(unicode) {
  if (this.unicodes.length === 0) {
    this.unicode = unicode;
  }
  this.unicodes.push(unicode);
};
Glyph.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
};
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  var commands;
  var hPoints;
  if (!options) {
    options = {};
  }
  var xScale = options.xScale;
  var yScale = options.yScale;
  if (options.hinting && font && font.hinting) {
    hPoints = this.path && font.hinting.exec(this, fontSize);
  }
  if (hPoints) {
    commands = font.hinting.getCommands(hPoints);
    x = Math.round(x);
    y = Math.round(y);
    xScale = yScale = 1;
  } else {
    commands = this.path.commands;
    var scale = 1 / (this.path.unitsPerEm || 1e3) * fontSize;
    if (xScale === void 0) {
      xScale = scale;
    }
    if (yScale === void 0) {
      yScale = scale;
    }
  }
  var p = new Path();
  for (var i = 0; i < commands.length; i += 1) {
    var cmd = commands[i];
    if (cmd.type === "M") {
      p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "L") {
      p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "Q") {
      p.quadraticCurveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "C") {
      p.curveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x2 * xScale,
        y + -cmd.y2 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "Z") {
      p.closePath();
    }
  }
  return p;
};
Glyph.prototype.getContours = function() {
  if (this.points === void 0) {
    return [];
  }
  var contours = [];
  var currentContour = [];
  for (var i = 0; i < this.points.length; i += 1) {
    var pt = this.points[i];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
};
Glyph.prototype.getMetrics = function() {
  var commands = this.path.commands;
  var xCoords = [];
  var yCoords = [];
  for (var i = 0; i < commands.length; i += 1) {
    var cmd = commands[i];
    if (cmd.type !== "Z") {
      xCoords.push(cmd.x);
      yCoords.push(cmd.y);
    }
    if (cmd.type === "Q" || cmd.type === "C") {
      xCoords.push(cmd.x1);
      yCoords.push(cmd.y1);
    }
    if (cmd.type === "C") {
      xCoords.push(cmd.x2);
      yCoords.push(cmd.y2);
    }
  }
  var metrics = {
    xMin: Math.min.apply(null, xCoords),
    yMin: Math.min.apply(null, yCoords),
    xMax: Math.max.apply(null, xCoords),
    yMax: Math.max.apply(null, yCoords),
    leftSideBearing: this.leftSideBearing
  };
  if (!isFinite(metrics.xMin)) {
    metrics.xMin = 0;
  }
  if (!isFinite(metrics.xMax)) {
    metrics.xMax = this.advanceWidth;
  }
  if (!isFinite(metrics.yMin)) {
    metrics.yMin = 0;
  }
  if (!isFinite(metrics.yMax)) {
    metrics.yMax = 0;
  }
  metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
  return metrics;
};
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
  this.getPath(x, y, fontSize, options).draw(ctx);
};
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
  function drawCircles(l, x2, y2, scale2) {
    ctx.beginPath();
    for (var j = 0; j < l.length; j += 1) {
      ctx.moveTo(x2 + l[j].x * scale2, y2 + l[j].y * scale2);
      ctx.arc(x2 + l[j].x * scale2, y2 + l[j].y * scale2, 2, 0, Math.PI * 2, false);
    }
    ctx.closePath();
    ctx.fill();
  }
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  var scale = 1 / this.path.unitsPerEm * fontSize;
  var blueCircles = [];
  var redCircles = [];
  var path = this.path;
  for (var i = 0; i < path.commands.length; i += 1) {
    var cmd = path.commands[i];
    if (cmd.x !== void 0) {
      blueCircles.push({ x: cmd.x, y: -cmd.y });
    }
    if (cmd.x1 !== void 0) {
      redCircles.push({ x: cmd.x1, y: -cmd.y1 });
    }
    if (cmd.x2 !== void 0) {
      redCircles.push({ x: cmd.x2, y: -cmd.y2 });
    }
  }
  ctx.fillStyle = "blue";
  drawCircles(blueCircles, x, y, scale);
  ctx.fillStyle = "red";
  drawCircles(redCircles, x, y, scale);
};
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
  var scale;
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  scale = 1 / this.path.unitsPerEm * fontSize;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  draw.line(ctx, x, -1e4, x, 1e4);
  draw.line(ctx, -1e4, y, 1e4, y);
  var xMin = this.xMin || 0;
  var yMin = this.yMin || 0;
  var xMax = this.xMax || 0;
  var yMax = this.yMax || 0;
  var advanceWidth = this.advanceWidth || 0;
  ctx.strokeStyle = "blue";
  draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
  draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
  draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
  draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
  ctx.strokeStyle = "green";
  draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
};
function defineDependentProperty(glyph, externalName, internalName) {
  Object.defineProperty(glyph, externalName, {
    get: function() {
      return glyph[internalName];
    },
    set: function(newValue) {
      glyph[internalName] = newValue;
    },
    enumerable: true,
    configurable: true
  });
}
function GlyphSet(font, glyphs) {
  this.font = font;
  this.glyphs = {};
  if (Array.isArray(glyphs)) {
    for (var i = 0; i < glyphs.length; i++) {
      var glyph = glyphs[i];
      glyph.path.unitsPerEm = font.unitsPerEm;
      this.glyphs[i] = glyph;
    }
  }
  this.length = glyphs && glyphs.length || 0;
}
GlyphSet.prototype.get = function(index) {
  if (this.glyphs[index] === void 0) {
    this.font._push(index);
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
    var glyph = this.glyphs[index];
    var unicodeObj = this.font._IndexToUnicodeMap[index];
    if (unicodeObj) {
      for (var j = 0; j < unicodeObj.unicodes.length; j++) {
        glyph.addUnicode(unicodeObj.unicodes[j]);
      }
    }
    if (this.font.cffEncoding) {
      if (this.font.isCIDFont) {
        glyph.name = "gid" + index;
      } else {
        glyph.name = this.font.cffEncoding.charset[index];
      }
    } else if (this.font.glyphNames.names) {
      glyph.name = this.font.glyphNames.glyphIndexToName(index);
    }
    this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
    this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
  } else {
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
  }
  return this.glyphs[index];
};
GlyphSet.prototype.push = function(index, loader) {
  this.glyphs[index] = loader;
  this.length++;
};
function glyphLoader(font, index) {
  return new Glyph({ index, font });
}
function ttfGlyphLoader(font, index, parseGlyph2, data, position, buildPath2) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      parseGlyph2(glyph, data, position);
      var path = buildPath2(font.glyphs, glyph);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    defineDependentProperty(glyph, "xMin", "_xMin");
    defineDependentProperty(glyph, "xMax", "_xMax");
    defineDependentProperty(glyph, "yMin", "_yMin");
    defineDependentProperty(glyph, "yMax", "_yMax");
    return glyph;
  };
}
function cffGlyphLoader(font, index, parseCFFCharstring2, charstring) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      var path = parseCFFCharstring2(font, glyph, charstring);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    return glyph;
  };
}
var glyphset = { GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader };
function equals(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i += 1) {
      if (!equals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function calcCFFSubroutineBias(subrs) {
  var bias;
  if (subrs.length < 1240) {
    bias = 107;
  } else if (subrs.length < 33900) {
    bias = 1131;
  } else {
    bias = 32768;
  }
  return bias;
}
function parseCFFIndex(data, start, conversionFn) {
  var offsets = [];
  var objects = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i = 0; i < count + 1; i += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
    var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
    if (conversionFn) {
      value = conversionFn(value);
    }
    objects.push(value);
  }
  return { objects, startOffset: start, endOffset };
}
function parseCFFIndexLowMemory(data, start) {
  var offsets = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i = 0; i < count + 1; i += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  return { offsets, startOffset: start, endOffset };
}
function getCffIndexObject(i, offsets, data, start, conversionFn) {
  var count = parse.getCard16(data, start);
  var objectOffset = 0;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
  }
  var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
  return value;
}
function parseFloatOperand(parser) {
  var s = "";
  var eof = 15;
  var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
  while (true) {
    var b = parser.parseByte();
    var n1 = b >> 4;
    var n2 = b & 15;
    if (n1 === eof) {
      break;
    }
    s += lookup[n1];
    if (n2 === eof) {
      break;
    }
    s += lookup[n2];
  }
  return parseFloat(s);
}
function parseOperand(parser, b0) {
  var b1;
  var b2;
  var b3;
  var b4;
  if (b0 === 28) {
    b1 = parser.parseByte();
    b2 = parser.parseByte();
    return b1 << 8 | b2;
  }
  if (b0 === 29) {
    b1 = parser.parseByte();
    b2 = parser.parseByte();
    b3 = parser.parseByte();
    b4 = parser.parseByte();
    return b1 << 24 | b2 << 16 | b3 << 8 | b4;
  }
  if (b0 === 30) {
    return parseFloatOperand(parser);
  }
  if (b0 >= 32 && b0 <= 246) {
    return b0 - 139;
  }
  if (b0 >= 247 && b0 <= 250) {
    b1 = parser.parseByte();
    return (b0 - 247) * 256 + b1 + 108;
  }
  if (b0 >= 251 && b0 <= 254) {
    b1 = parser.parseByte();
    return -(b0 - 251) * 256 - b1 - 108;
  }
  throw new Error("Invalid b0 " + b0);
}
function entriesToObject(entries) {
  var o = {};
  for (var i = 0; i < entries.length; i += 1) {
    var key = entries[i][0];
    var values = entries[i][1];
    var value = void 0;
    if (values.length === 1) {
      value = values[0];
    } else {
      value = values;
    }
    if (o.hasOwnProperty(key) && !isNaN(o[key])) {
      throw new Error("Object " + o + " already has key " + key);
    }
    o[key] = value;
  }
  return o;
}
function parseCFFDict(data, start, size) {
  start = start !== void 0 ? start : 0;
  var parser = new parse.Parser(data, start);
  var entries = [];
  var operands = [];
  size = size !== void 0 ? size : data.length;
  while (parser.relativeOffset < size) {
    var op = parser.parseByte();
    if (op <= 21) {
      if (op === 12) {
        op = 1200 + parser.parseByte();
      }
      entries.push([op, operands]);
      operands = [];
    } else {
      operands.push(parseOperand(parser, op));
    }
  }
  return entriesToObject(entries);
}
function getCFFString(strings, index) {
  if (index <= 390) {
    index = cffStandardStrings[index];
  } else {
    index = strings[index - 391];
  }
  return index;
}
function interpretDict(dict, meta2, strings) {
  var newDict = {};
  var value;
  for (var i = 0; i < meta2.length; i += 1) {
    var m = meta2[i];
    if (Array.isArray(m.type)) {
      var values = [];
      values.length = m.type.length;
      for (var j = 0; j < m.type.length; j++) {
        value = dict[m.op] !== void 0 ? dict[m.op][j] : void 0;
        if (value === void 0) {
          value = m.value !== void 0 && m.value[j] !== void 0 ? m.value[j] : null;
        }
        if (m.type[j] === "SID") {
          value = getCFFString(strings, value);
        }
        values[j] = value;
      }
      newDict[m.name] = values;
    } else {
      value = dict[m.op];
      if (value === void 0) {
        value = m.value !== void 0 ? m.value : null;
      }
      if (m.type === "SID") {
        value = getCFFString(strings, value);
      }
      newDict[m.name] = value;
    }
  }
  return newDict;
}
function parseCFFHeader(data, start) {
  var header = {};
  header.formatMajor = parse.getCard8(data, start);
  header.formatMinor = parse.getCard8(data, start + 1);
  header.size = parse.getCard8(data, start + 2);
  header.offsetSize = parse.getCard8(data, start + 3);
  header.startOffset = start;
  header.endOffset = start + 4;
  return header;
}
var TOP_DICT_META = [
  { name: "version", op: 0, type: "SID" },
  { name: "notice", op: 1, type: "SID" },
  { name: "copyright", op: 1200, type: "SID" },
  { name: "fullName", op: 2, type: "SID" },
  { name: "familyName", op: 3, type: "SID" },
  { name: "weight", op: 4, type: "SID" },
  { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
  { name: "italicAngle", op: 1202, type: "number", value: 0 },
  { name: "underlinePosition", op: 1203, type: "number", value: -100 },
  { name: "underlineThickness", op: 1204, type: "number", value: 50 },
  { name: "paintType", op: 1205, type: "number", value: 0 },
  { name: "charstringType", op: 1206, type: "number", value: 2 },
  {
    name: "fontMatrix",
    op: 1207,
    type: ["real", "real", "real", "real", "real", "real"],
    value: [1e-3, 0, 0, 1e-3, 0, 0]
  },
  { name: "uniqueId", op: 13, type: "number" },
  { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
  { name: "strokeWidth", op: 1208, type: "number", value: 0 },
  { name: "xuid", op: 14, type: [], value: null },
  { name: "charset", op: 15, type: "offset", value: 0 },
  { name: "encoding", op: 16, type: "offset", value: 0 },
  { name: "charStrings", op: 17, type: "offset", value: 0 },
  { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
  { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
  { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
  { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
  { name: "cidFontType", op: 1233, type: "number", value: 0 },
  { name: "cidCount", op: 1234, type: "number", value: 8720 },
  { name: "uidBase", op: 1235, type: "number" },
  { name: "fdArray", op: 1236, type: "offset" },
  { name: "fdSelect", op: 1237, type: "offset" },
  { name: "fontName", op: 1238, type: "SID" }
];
var PRIVATE_DICT_META = [
  { name: "subrs", op: 19, type: "offset", value: 0 },
  { name: "defaultWidthX", op: 20, type: "number", value: 0 },
  { name: "nominalWidthX", op: 21, type: "number", value: 0 }
];
function parseCFFTopDict(data, strings) {
  var dict = parseCFFDict(data, 0, data.byteLength);
  return interpretDict(dict, TOP_DICT_META, strings);
}
function parseCFFPrivateDict(data, start, size, strings) {
  var dict = parseCFFDict(data, start, size);
  return interpretDict(dict, PRIVATE_DICT_META, strings);
}
function gatherCFFTopDicts(data, start, cffIndex, strings) {
  var topDictArray = [];
  for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
    var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
    var topDict = parseCFFTopDict(topDictData, strings);
    topDict._subrs = [];
    topDict._subrsBias = 0;
    topDict._defaultWidthX = 0;
    topDict._nominalWidthX = 0;
    var privateSize = topDict.private[0];
    var privateOffset = topDict.private[1];
    if (privateSize !== 0 && privateOffset !== 0) {
      var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
      topDict._defaultWidthX = privateDict.defaultWidthX;
      topDict._nominalWidthX = privateDict.nominalWidthX;
      if (privateDict.subrs !== 0) {
        var subrOffset = privateOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset + start);
        topDict._subrs = subrIndex.objects;
        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
      }
      topDict._privateDict = privateDict;
    }
    topDictArray.push(topDict);
  }
  return topDictArray;
}
function parseCFFCharset(data, start, nGlyphs, strings) {
  var sid;
  var count;
  var parser = new parse.Parser(data, start);
  nGlyphs -= 1;
  var charset = [".notdef"];
  var format = parser.parseCard8();
  if (format === 0) {
    for (var i = 0; i < nGlyphs; i += 1) {
      sid = parser.parseSID();
      charset.push(getCFFString(strings, sid));
    }
  } else if (format === 1) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard8();
      for (var i$1 = 0; i$1 <= count; i$1 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else if (format === 2) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard16();
      for (var i$2 = 0; i$2 <= count; i$2 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else {
    throw new Error("Unknown charset format " + format);
  }
  return charset;
}
function parseCFFEncoding(data, start, charset) {
  var code;
  var enc = {};
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    var nCodes = parser.parseCard8();
    for (var i = 0; i < nCodes; i += 1) {
      code = parser.parseCard8();
      enc[code] = i;
    }
  } else if (format === 1) {
    var nRanges = parser.parseCard8();
    code = 1;
    for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
      var first = parser.parseCard8();
      var nLeft = parser.parseCard8();
      for (var j = first; j <= first + nLeft; j += 1) {
        enc[j] = code;
        code += 1;
      }
    }
  } else {
    throw new Error("Unknown encoding format " + format);
  }
  return new CffEncoding(enc, charset);
}
function parseCFFCharstring(font, glyph, code) {
  var c1x;
  var c1y;
  var c2x;
  var c2y;
  var p = new Path();
  var stack = [];
  var nStems = 0;
  var haveWidth = false;
  var open = false;
  var x = 0;
  var y = 0;
  var subrs;
  var subrsBias;
  var defaultWidthX;
  var nominalWidthX;
  if (font.isCIDFont) {
    var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
    var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
    subrs = fdDict._subrs;
    subrsBias = fdDict._subrsBias;
    defaultWidthX = fdDict._defaultWidthX;
    nominalWidthX = fdDict._nominalWidthX;
  } else {
    subrs = font.tables.cff.topDict._subrs;
    subrsBias = font.tables.cff.topDict._subrsBias;
    defaultWidthX = font.tables.cff.topDict._defaultWidthX;
    nominalWidthX = font.tables.cff.topDict._nominalWidthX;
  }
  var width = defaultWidthX;
  function newContour(x2, y2) {
    if (open) {
      p.closePath();
    }
    p.moveTo(x2, y2);
    open = true;
  }
  function parseStems() {
    var hasWidthArg;
    hasWidthArg = stack.length % 2 !== 0;
    if (hasWidthArg && !haveWidth) {
      width = stack.shift() + nominalWidthX;
    }
    nStems += stack.length >> 1;
    stack.length = 0;
    haveWidth = true;
  }
  function parse2(code2) {
    var b1;
    var b2;
    var b3;
    var b4;
    var codeIndex;
    var subrCode;
    var jpx;
    var jpy;
    var c3x;
    var c3y;
    var c4x;
    var c4y;
    var i = 0;
    while (i < code2.length) {
      var v = code2[i];
      i += 1;
      switch (v) {
        case 1:
          parseStems();
          break;
        case 3:
          parseStems();
          break;
        case 4:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          newContour(x, y);
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 10:
          codeIndex = stack.pop() + subrsBias;
          subrCode = subrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code2[i];
          i += 1;
          switch (v) {
            case 35:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              y = c4y + stack.shift();
              stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 34:
              c1x = x + stack.shift();
              c1y = y;
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = y;
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 36:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 37:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                x = c4x + stack.shift();
              } else {
                y = c4y + stack.shift();
              }
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            default:
              console.log("Glyph " + glyph.index + ": unknown operator 1200" + v);
              stack.length = 0;
          }
          break;
        case 14:
          if (stack.length > 0 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          if (open) {
            p.closePath();
            open = false;
          }
          break;
        case 18:
          parseStems();
          break;
        case 19:
        case 20:
          parseStems();
          i += nStems + 7 >> 3;
          break;
        case 21:
          if (stack.length > 2 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          x += stack.pop();
          newContour(x, y);
          break;
        case 22:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          x += stack.pop();
          newContour(x, y);
          break;
        case 23:
          parseStems();
          break;
        case 24:
          while (stack.length > 2) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          p.lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          p.curveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x;
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y;
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 28:
          b1 = code2[i];
          b2 = code2[i + 1];
          stack.push((b1 << 24 | b2 << 16) >> 16);
          i += 2;
          break;
        case 29:
          codeIndex = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        default:
          if (v < 32) {
            console.log("Glyph " + glyph.index + ": unknown operator " + v);
          } else if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            b1 = code2[i];
            i += 1;
            stack.push((v - 247) * 256 + b1 + 108);
          } else if (v < 255) {
            b1 = code2[i];
            i += 1;
            stack.push(-(v - 251) * 256 - b1 - 108);
          } else {
            b1 = code2[i];
            b2 = code2[i + 1];
            b3 = code2[i + 2];
            b4 = code2[i + 3];
            i += 4;
            stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
          }
      }
    }
  }
  parse2(code);
  glyph.advanceWidth = width;
  return p;
}
function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
  var fdSelect = [];
  var fdIndex;
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    for (var iGid = 0; iGid < nGlyphs; iGid++) {
      fdIndex = parser.parseCard8();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      fdSelect.push(fdIndex);
    }
  } else if (format === 3) {
    var nRanges = parser.parseCard16();
    var first = parser.parseCard16();
    if (first !== 0) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + first);
    }
    var next;
    for (var iRange = 0; iRange < nRanges; iRange++) {
      fdIndex = parser.parseCard8();
      next = parser.parseCard16();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      if (next > nGlyphs) {
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + next);
      }
      for (; first < next; first++) {
        fdSelect.push(fdIndex);
      }
      first = next;
    }
    if (next !== nGlyphs) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + next);
    }
  } else {
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + format);
  }
  return fdSelect;
}
function parseCFFTable(data, start, font, opt) {
  font.tables.cff = {};
  var header = parseCFFHeader(data, start);
  var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
  var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
  var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
  var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
  font.gsubrs = globalSubrIndex.objects;
  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
  var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
  if (topDictArray.length !== 1) {
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + topDictArray.length);
  }
  var topDict = topDictArray[0];
  font.tables.cff.topDict = topDict;
  if (topDict._privateDict) {
    font.defaultWidthX = topDict._privateDict.defaultWidthX;
    font.nominalWidthX = topDict._privateDict.nominalWidthX;
  }
  if (topDict.ros[0] !== void 0 && topDict.ros[1] !== void 0) {
    font.isCIDFont = true;
  }
  if (font.isCIDFont) {
    var fdArrayOffset = topDict.fdArray;
    var fdSelectOffset = topDict.fdSelect;
    if (fdArrayOffset === 0 || fdSelectOffset === 0) {
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    }
    fdArrayOffset += start;
    var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
    var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
    topDict._fdArray = fdArray;
    fdSelectOffset += start;
    topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
  }
  var privateDictOffset = start + topDict.private[1];
  var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
  font.defaultWidthX = privateDict.defaultWidthX;
  font.nominalWidthX = privateDict.nominalWidthX;
  if (privateDict.subrs !== 0) {
    var subrOffset = privateDictOffset + privateDict.subrs;
    var subrIndex = parseCFFIndex(data, subrOffset);
    font.subrs = subrIndex.objects;
    font.subrsBias = calcCFFSubroutineBias(font.subrs);
  } else {
    font.subrs = [];
    font.subrsBias = 0;
  }
  var charStringsIndex;
  if (opt.lowMemory) {
    charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.offsets.length;
  } else {
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;
  }
  var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
  if (topDict.encoding === 0) {
    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
  } else if (topDict.encoding === 1) {
    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
  } else {
    font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
  }
  font.encoding = font.encoding || font.cffEncoding;
  font.glyphs = new glyphset.GlyphSet(font);
  if (opt.lowMemory) {
    font._push = function(i2) {
      var charString2 = getCffIndexObject(i2, charStringsIndex.offsets, data, start + topDict.charStrings);
      font.glyphs.push(i2, glyphset.cffGlyphLoader(font, i2, parseCFFCharstring, charString2));
    };
  } else {
    for (var i = 0; i < font.nGlyphs; i += 1) {
      var charString = charStringsIndex.objects[i];
      font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
  }
}
function encodeString(s, strings) {
  var sid;
  var i = cffStandardStrings.indexOf(s);
  if (i >= 0) {
    sid = i;
  }
  i = strings.indexOf(s);
  if (i >= 0) {
    sid = i + cffStandardStrings.length;
  } else {
    sid = cffStandardStrings.length + strings.length;
    strings.push(s);
  }
  return sid;
}
function makeHeader() {
  return new table.Record("Header", [
    { name: "major", type: "Card8", value: 1 },
    { name: "minor", type: "Card8", value: 0 },
    { name: "hdrSize", type: "Card8", value: 4 },
    { name: "major", type: "Card8", value: 1 }
  ]);
}
function makeNameIndex(fontNames) {
  var t = new table.Record("Name INDEX", [
    { name: "names", type: "INDEX", value: [] }
  ]);
  t.names = [];
  for (var i = 0; i < fontNames.length; i += 1) {
    t.names.push({ name: "name_" + i, type: "NAME", value: fontNames[i] });
  }
  return t;
}
function makeDict(meta2, attrs, strings) {
  var m = {};
  for (var i = 0; i < meta2.length; i += 1) {
    var entry = meta2[i];
    var value = attrs[entry.name];
    if (value !== void 0 && !equals(value, entry.value)) {
      if (entry.type === "SID") {
        value = encodeString(value, strings);
      }
      m[entry.op] = { name: entry.name, type: entry.type, value };
    }
  }
  return m;
}
function makeTopDict(attrs, strings) {
  var t = new table.Record("Top DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t.dict = makeDict(TOP_DICT_META, attrs, strings);
  return t;
}
function makeTopDictIndex(topDict) {
  var t = new table.Record("Top DICT INDEX", [
    { name: "topDicts", type: "INDEX", value: [] }
  ]);
  t.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
  return t;
}
function makeStringIndex(strings) {
  var t = new table.Record("String INDEX", [
    { name: "strings", type: "INDEX", value: [] }
  ]);
  t.strings = [];
  for (var i = 0; i < strings.length; i += 1) {
    t.strings.push({ name: "string_" + i, type: "STRING", value: strings[i] });
  }
  return t;
}
function makeGlobalSubrIndex() {
  return new table.Record("Global Subr INDEX", [
    { name: "subrs", type: "INDEX", value: [] }
  ]);
}
function makeCharsets(glyphNames, strings) {
  var t = new table.Record("Charsets", [
    { name: "format", type: "Card8", value: 0 }
  ]);
  for (var i = 0; i < glyphNames.length; i += 1) {
    var glyphName = glyphNames[i];
    var glyphSID = encodeString(glyphName, strings);
    t.fields.push({ name: "glyph_" + i, type: "SID", value: glyphSID });
  }
  return t;
}
function glyphToOps(glyph) {
  var ops = [];
  var path = glyph.path;
  ops.push({ name: "width", type: "NUMBER", value: glyph.advanceWidth });
  var x = 0;
  var y = 0;
  for (var i = 0; i < path.commands.length; i += 1) {
    var dx = void 0;
    var dy = void 0;
    var cmd = path.commands[i];
    if (cmd.type === "Q") {
      var _13 = 1 / 3;
      var _23 = 2 / 3;
      cmd = {
        type: "C",
        x: cmd.x,
        y: cmd.y,
        x1: Math.round(_13 * x + _23 * cmd.x1),
        y1: Math.round(_13 * y + _23 * cmd.y1),
        x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
        y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
      };
    }
    if (cmd.type === "M") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rmoveto", type: "OP", value: 21 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "L") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rlineto", type: "OP", value: 5 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "C") {
      var dx1 = Math.round(cmd.x1 - x);
      var dy1 = Math.round(cmd.y1 - y);
      var dx2 = Math.round(cmd.x2 - cmd.x1);
      var dy2 = Math.round(cmd.y2 - cmd.y1);
      dx = Math.round(cmd.x - cmd.x2);
      dy = Math.round(cmd.y - cmd.y2);
      ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
      ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
      ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
      ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rrcurveto", type: "OP", value: 8 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    }
  }
  ops.push({ name: "endchar", type: "OP", value: 14 });
  return ops;
}
function makeCharStringsIndex(glyphs) {
  var t = new table.Record("CharStrings INDEX", [
    { name: "charStrings", type: "INDEX", value: [] }
  ]);
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    var ops = glyphToOps(glyph);
    t.charStrings.push({ name: glyph.name, type: "CHARSTRING", value: ops });
  }
  return t;
}
function makePrivateDict(attrs, strings) {
  var t = new table.Record("Private DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
  return t;
}
function makeCFFTable(glyphs, options) {
  var t = new table.Table("CFF ", [
    { name: "header", type: "RECORD" },
    { name: "nameIndex", type: "RECORD" },
    { name: "topDictIndex", type: "RECORD" },
    { name: "stringIndex", type: "RECORD" },
    { name: "globalSubrIndex", type: "RECORD" },
    { name: "charsets", type: "RECORD" },
    { name: "charStringsIndex", type: "RECORD" },
    { name: "privateDict", type: "RECORD" }
  ]);
  var fontScale = 1 / options.unitsPerEm;
  var attrs = {
    version: options.version,
    fullName: options.fullName,
    familyName: options.familyName,
    weight: options.weightName,
    fontBBox: options.fontBBox || [0, 0, 0, 0],
    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
    charset: 999,
    encoding: 0,
    charStrings: 999,
    private: [0, 999]
  };
  var privateAttrs = {};
  var glyphNames = [];
  var glyph;
  for (var i = 1; i < glyphs.length; i += 1) {
    glyph = glyphs.get(i);
    glyphNames.push(glyph.name);
  }
  var strings = [];
  t.header = makeHeader();
  t.nameIndex = makeNameIndex([options.postScriptName]);
  var topDict = makeTopDict(attrs, strings);
  t.topDictIndex = makeTopDictIndex(topDict);
  t.globalSubrIndex = makeGlobalSubrIndex();
  t.charsets = makeCharsets(glyphNames, strings);
  t.charStringsIndex = makeCharStringsIndex(glyphs);
  t.privateDict = makePrivateDict(privateAttrs, strings);
  t.stringIndex = makeStringIndex(strings);
  var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
  attrs.charset = startOffset;
  attrs.encoding = 0;
  attrs.charStrings = attrs.charset + t.charsets.sizeOf();
  attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
  topDict = makeTopDict(attrs, strings);
  t.topDictIndex = makeTopDictIndex(topDict);
  return t;
}
var cff = { parse: parseCFFTable, make: makeCFFTable };
function parseHeadTable(data, start) {
  var head2 = {};
  var p = new parse.Parser(data, start);
  head2.version = p.parseVersion();
  head2.fontRevision = Math.round(p.parseFixed() * 1e3) / 1e3;
  head2.checkSumAdjustment = p.parseULong();
  head2.magicNumber = p.parseULong();
  check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
  head2.flags = p.parseUShort();
  head2.unitsPerEm = p.parseUShort();
  head2.created = p.parseLongDateTime();
  head2.modified = p.parseLongDateTime();
  head2.xMin = p.parseShort();
  head2.yMin = p.parseShort();
  head2.xMax = p.parseShort();
  head2.yMax = p.parseShort();
  head2.macStyle = p.parseUShort();
  head2.lowestRecPPEM = p.parseUShort();
  head2.fontDirectionHint = p.parseShort();
  head2.indexToLocFormat = p.parseShort();
  head2.glyphDataFormat = p.parseShort();
  return head2;
}
function makeHeadTable(options) {
  var timestamp = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800;
  var createdTimestamp = timestamp;
  if (options.createdTimestamp) {
    createdTimestamp = options.createdTimestamp + 2082844800;
  }
  return new table.Table("head", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "fontRevision", type: "FIXED", value: 65536 },
    { name: "checkSumAdjustment", type: "ULONG", value: 0 },
    { name: "magicNumber", type: "ULONG", value: 1594834165 },
    { name: "flags", type: "USHORT", value: 0 },
    { name: "unitsPerEm", type: "USHORT", value: 1e3 },
    { name: "created", type: "LONGDATETIME", value: createdTimestamp },
    { name: "modified", type: "LONGDATETIME", value: timestamp },
    { name: "xMin", type: "SHORT", value: 0 },
    { name: "yMin", type: "SHORT", value: 0 },
    { name: "xMax", type: "SHORT", value: 0 },
    { name: "yMax", type: "SHORT", value: 0 },
    { name: "macStyle", type: "USHORT", value: 0 },
    { name: "lowestRecPPEM", type: "USHORT", value: 0 },
    { name: "fontDirectionHint", type: "SHORT", value: 2 },
    { name: "indexToLocFormat", type: "SHORT", value: 0 },
    { name: "glyphDataFormat", type: "SHORT", value: 0 }
  ], options);
}
var head = { parse: parseHeadTable, make: makeHeadTable };
function parseHheaTable(data, start) {
  var hhea2 = {};
  var p = new parse.Parser(data, start);
  hhea2.version = p.parseVersion();
  hhea2.ascender = p.parseShort();
  hhea2.descender = p.parseShort();
  hhea2.lineGap = p.parseShort();
  hhea2.advanceWidthMax = p.parseUShort();
  hhea2.minLeftSideBearing = p.parseShort();
  hhea2.minRightSideBearing = p.parseShort();
  hhea2.xMaxExtent = p.parseShort();
  hhea2.caretSlopeRise = p.parseShort();
  hhea2.caretSlopeRun = p.parseShort();
  hhea2.caretOffset = p.parseShort();
  p.relativeOffset += 8;
  hhea2.metricDataFormat = p.parseShort();
  hhea2.numberOfHMetrics = p.parseUShort();
  return hhea2;
}
function makeHheaTable(options) {
  return new table.Table("hhea", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "ascender", type: "FWORD", value: 0 },
    { name: "descender", type: "FWORD", value: 0 },
    { name: "lineGap", type: "FWORD", value: 0 },
    { name: "advanceWidthMax", type: "UFWORD", value: 0 },
    { name: "minLeftSideBearing", type: "FWORD", value: 0 },
    { name: "minRightSideBearing", type: "FWORD", value: 0 },
    { name: "xMaxExtent", type: "FWORD", value: 0 },
    { name: "caretSlopeRise", type: "SHORT", value: 1 },
    { name: "caretSlopeRun", type: "SHORT", value: 0 },
    { name: "caretOffset", type: "SHORT", value: 0 },
    { name: "reserved1", type: "SHORT", value: 0 },
    { name: "reserved2", type: "SHORT", value: 0 },
    { name: "reserved3", type: "SHORT", value: 0 },
    { name: "reserved4", type: "SHORT", value: 0 },
    { name: "metricDataFormat", type: "SHORT", value: 0 },
    { name: "numberOfHMetrics", type: "USHORT", value: 0 }
  ], options);
}
var hhea = { parse: parseHheaTable, make: makeHheaTable };
function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i = 0; i < numGlyphs; i += 1) {
    if (i < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    var glyph = glyphs.get(i);
    glyph.advanceWidth = advanceWidth;
    glyph.leftSideBearing = leftSideBearing;
  }
}
function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
  font._hmtxTableData = {};
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i = 0; i < numGlyphs; i += 1) {
    if (i < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    font._hmtxTableData[i] = {
      advanceWidth,
      leftSideBearing
    };
  }
}
function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
  if (opt.lowMemory) {
    parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs);
  } else {
    parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs);
  }
}
function makeHmtxTable(glyphs) {
  var t = new table.Table("hmtx", []);
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    var advanceWidth = glyph.advanceWidth || 0;
    var leftSideBearing = glyph.leftSideBearing || 0;
    t.fields.push({ name: "advanceWidth_" + i, type: "USHORT", value: advanceWidth });
    t.fields.push({ name: "leftSideBearing_" + i, type: "SHORT", value: leftSideBearing });
  }
  return t;
}
var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
function makeLtagTable(tags) {
  var result = new table.Table("ltag", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "numTags", type: "ULONG", value: tags.length }
  ]);
  var stringPool = "";
  var stringPoolOffset = 12 + tags.length * 4;
  for (var i = 0; i < tags.length; ++i) {
    var pos = stringPool.indexOf(tags[i]);
    if (pos < 0) {
      pos = stringPool.length;
      stringPool += tags[i];
    }
    result.fields.push({ name: "offset " + i, type: "USHORT", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + i, type: "USHORT", value: tags[i].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
function parseLtagTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported ltag table version.");
  p.skip("uLong", 1);
  var numTags = p.parseULong();
  var tags = [];
  for (var i = 0; i < numTags; i++) {
    var tag = "";
    var offset = start + p.parseUShort();
    var length = p.parseUShort();
    for (var j = offset; j < offset + length; ++j) {
      tag += String.fromCharCode(data.getInt8(j));
    }
    tags.push(tag);
  }
  return tags;
}
var ltag = { make: makeLtagTable, parse: parseLtagTable };
function parseMaxpTable(data, start) {
  var maxp2 = {};
  var p = new parse.Parser(data, start);
  maxp2.version = p.parseVersion();
  maxp2.numGlyphs = p.parseUShort();
  if (maxp2.version === 1) {
    maxp2.maxPoints = p.parseUShort();
    maxp2.maxContours = p.parseUShort();
    maxp2.maxCompositePoints = p.parseUShort();
    maxp2.maxCompositeContours = p.parseUShort();
    maxp2.maxZones = p.parseUShort();
    maxp2.maxTwilightPoints = p.parseUShort();
    maxp2.maxStorage = p.parseUShort();
    maxp2.maxFunctionDefs = p.parseUShort();
    maxp2.maxInstructionDefs = p.parseUShort();
    maxp2.maxStackElements = p.parseUShort();
    maxp2.maxSizeOfInstructions = p.parseUShort();
    maxp2.maxComponentElements = p.parseUShort();
    maxp2.maxComponentDepth = p.parseUShort();
  }
  return maxp2;
}
function makeMaxpTable(numGlyphs) {
  return new table.Table("maxp", [
    { name: "version", type: "FIXED", value: 20480 },
    { name: "numGlyphs", type: "USHORT", value: numGlyphs }
  ]);
}
var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
var nameTableNames = [
  "copyright",
  // 0
  "fontFamily",
  // 1
  "fontSubfamily",
  // 2
  "uniqueID",
  // 3
  "fullName",
  // 4
  "version",
  // 5
  "postScriptName",
  // 6
  "trademark",
  // 7
  "manufacturer",
  // 8
  "designer",
  // 9
  "description",
  // 10
  "manufacturerURL",
  // 11
  "designerURL",
  // 12
  "license",
  // 13
  "licenseURL",
  // 14
  "reserved",
  // 15
  "preferredFamily",
  // 16
  "preferredSubfamily",
  // 17
  "compatibleFullName",
  // 18
  "sampleText",
  // 19
  "postScriptFindFontName",
  // 20
  "wwsFamily",
  // 21
  "wwsSubfamily"
  // 22
];
var macLanguages = {
  0: "en",
  1: "fr",
  2: "de",
  3: "it",
  4: "nl",
  5: "sv",
  6: "es",
  7: "da",
  8: "pt",
  9: "no",
  10: "he",
  11: "ja",
  12: "ar",
  13: "fi",
  14: "el",
  15: "is",
  16: "mt",
  17: "tr",
  18: "hr",
  19: "zh-Hant",
  20: "ur",
  21: "hi",
  22: "th",
  23: "ko",
  24: "lt",
  25: "pl",
  26: "hu",
  27: "es",
  28: "lv",
  29: "se",
  30: "fo",
  31: "fa",
  32: "ru",
  33: "zh",
  34: "nl-BE",
  35: "ga",
  36: "sq",
  37: "ro",
  38: "cz",
  39: "sk",
  40: "si",
  41: "yi",
  42: "sr",
  43: "mk",
  44: "bg",
  45: "uk",
  46: "be",
  47: "uz",
  48: "kk",
  49: "az-Cyrl",
  50: "az-Arab",
  51: "hy",
  52: "ka",
  53: "mo",
  54: "ky",
  55: "tg",
  56: "tk",
  57: "mn-CN",
  58: "mn",
  59: "ps",
  60: "ks",
  61: "ku",
  62: "sd",
  63: "bo",
  64: "ne",
  65: "sa",
  66: "mr",
  67: "bn",
  68: "as",
  69: "gu",
  70: "pa",
  71: "or",
  72: "ml",
  73: "kn",
  74: "ta",
  75: "te",
  76: "si",
  77: "my",
  78: "km",
  79: "lo",
  80: "vi",
  81: "id",
  82: "tl",
  83: "ms",
  84: "ms-Arab",
  85: "am",
  86: "ti",
  87: "om",
  88: "so",
  89: "sw",
  90: "rw",
  91: "rn",
  92: "ny",
  93: "mg",
  94: "eo",
  128: "cy",
  129: "eu",
  130: "ca",
  131: "la",
  132: "qu",
  133: "gn",
  134: "ay",
  135: "tt",
  136: "ug",
  137: "dz",
  138: "jv",
  139: "su",
  140: "gl",
  141: "af",
  142: "br",
  143: "iu",
  144: "gd",
  145: "gv",
  146: "ga",
  147: "to",
  148: "el-polyton",
  149: "kl",
  150: "az",
  151: "nn"
};
var macLanguageToScript = {
  0: 0,
  // langEnglish  smRoman
  1: 0,
  // langFrench  smRoman
  2: 0,
  // langGerman  smRoman
  3: 0,
  // langItalian  smRoman
  4: 0,
  // langDutch  smRoman
  5: 0,
  // langSwedish  smRoman
  6: 0,
  // langSpanish  smRoman
  7: 0,
  // langDanish  smRoman
  8: 0,
  // langPortuguese  smRoman
  9: 0,
  // langNorwegian  smRoman
  10: 5,
  // langHebrew  smHebrew
  11: 1,
  // langJapanese  smJapanese
  12: 4,
  // langArabic  smArabic
  13: 0,
  // langFinnish  smRoman
  14: 6,
  // langGreek  smGreek
  15: 0,
  // langIcelandic  smRoman (modified)
  16: 0,
  // langMaltese  smRoman
  17: 0,
  // langTurkish  smRoman (modified)
  18: 0,
  // langCroatian  smRoman (modified)
  19: 2,
  // langTradChinese  smTradChinese
  20: 4,
  // langUrdu  smArabic
  21: 9,
  // langHindi  smDevanagari
  22: 21,
  // langThai  smThai
  23: 3,
  // langKorean  smKorean
  24: 29,
  // langLithuanian  smCentralEuroRoman
  25: 29,
  // langPolish  smCentralEuroRoman
  26: 29,
  // langHungarian  smCentralEuroRoman
  27: 29,
  // langEstonian  smCentralEuroRoman
  28: 29,
  // langLatvian  smCentralEuroRoman
  29: 0,
  // langSami  smRoman
  30: 0,
  // langFaroese  smRoman (modified)
  31: 4,
  // langFarsi  smArabic (modified)
  32: 7,
  // langRussian  smCyrillic
  33: 25,
  // langSimpChinese  smSimpChinese
  34: 0,
  // langFlemish  smRoman
  35: 0,
  // langIrishGaelic  smRoman (modified)
  36: 0,
  // langAlbanian  smRoman
  37: 0,
  // langRomanian  smRoman (modified)
  38: 29,
  // langCzech  smCentralEuroRoman
  39: 29,
  // langSlovak  smCentralEuroRoman
  40: 0,
  // langSlovenian  smRoman (modified)
  41: 5,
  // langYiddish  smHebrew
  42: 7,
  // langSerbian  smCyrillic
  43: 7,
  // langMacedonian  smCyrillic
  44: 7,
  // langBulgarian  smCyrillic
  45: 7,
  // langUkrainian  smCyrillic (modified)
  46: 7,
  // langByelorussian  smCyrillic
  47: 7,
  // langUzbek  smCyrillic
  48: 7,
  // langKazakh  smCyrillic
  49: 7,
  // langAzerbaijani  smCyrillic
  50: 4,
  // langAzerbaijanAr  smArabic
  51: 24,
  // langArmenian  smArmenian
  52: 23,
  // langGeorgian  smGeorgian
  53: 7,
  // langMoldavian  smCyrillic
  54: 7,
  // langKirghiz  smCyrillic
  55: 7,
  // langTajiki  smCyrillic
  56: 7,
  // langTurkmen  smCyrillic
  57: 27,
  // langMongolian  smMongolian
  58: 7,
  // langMongolianCyr  smCyrillic
  59: 4,
  // langPashto  smArabic
  60: 4,
  // langKurdish  smArabic
  61: 4,
  // langKashmiri  smArabic
  62: 4,
  // langSindhi  smArabic
  63: 26,
  // langTibetan  smTibetan
  64: 9,
  // langNepali  smDevanagari
  65: 9,
  // langSanskrit  smDevanagari
  66: 9,
  // langMarathi  smDevanagari
  67: 13,
  // langBengali  smBengali
  68: 13,
  // langAssamese  smBengali
  69: 11,
  // langGujarati  smGujarati
  70: 10,
  // langPunjabi  smGurmukhi
  71: 12,
  // langOriya  smOriya
  72: 17,
  // langMalayalam  smMalayalam
  73: 16,
  // langKannada  smKannada
  74: 14,
  // langTamil  smTamil
  75: 15,
  // langTelugu  smTelugu
  76: 18,
  // langSinhalese  smSinhalese
  77: 19,
  // langBurmese  smBurmese
  78: 20,
  // langKhmer  smKhmer
  79: 22,
  // langLao  smLao
  80: 30,
  // langVietnamese  smVietnamese
  81: 0,
  // langIndonesian  smRoman
  82: 0,
  // langTagalog  smRoman
  83: 0,
  // langMalayRoman  smRoman
  84: 4,
  // langMalayArabic  smArabic
  85: 28,
  // langAmharic  smEthiopic
  86: 28,
  // langTigrinya  smEthiopic
  87: 28,
  // langOromo  smEthiopic
  88: 0,
  // langSomali  smRoman
  89: 0,
  // langSwahili  smRoman
  90: 0,
  // langKinyarwanda  smRoman
  91: 0,
  // langRundi  smRoman
  92: 0,
  // langNyanja  smRoman
  93: 0,
  // langMalagasy  smRoman
  94: 0,
  // langEsperanto  smRoman
  128: 0,
  // langWelsh  smRoman (modified)
  129: 0,
  // langBasque  smRoman
  130: 0,
  // langCatalan  smRoman
  131: 0,
  // langLatin  smRoman
  132: 0,
  // langQuechua  smRoman
  133: 0,
  // langGuarani  smRoman
  134: 0,
  // langAymara  smRoman
  135: 7,
  // langTatar  smCyrillic
  136: 4,
  // langUighur  smArabic
  137: 26,
  // langDzongkha  smTibetan
  138: 0,
  // langJavaneseRom  smRoman
  139: 0,
  // langSundaneseRom  smRoman
  140: 0,
  // langGalician  smRoman
  141: 0,
  // langAfrikaans  smRoman
  142: 0,
  // langBreton  smRoman (modified)
  143: 28,
  // langInuktitut  smEthiopic (modified)
  144: 0,
  // langScottishGaelic  smRoman (modified)
  145: 0,
  // langManxGaelic  smRoman (modified)
  146: 0,
  // langIrishGaelicScript  smRoman (modified)
  147: 0,
  // langTongan  smRoman
  148: 6,
  // langGreekAncient  smRoman
  149: 0,
  // langGreenlandic  smRoman
  150: 0,
  // langAzerbaijanRoman  smRoman
  151: 0
  // langNynorsk  smRoman
};
var windowsLanguages = {
  1078: "af",
  1052: "sq",
  1156: "gsw",
  1118: "am",
  5121: "ar-DZ",
  15361: "ar-BH",
  3073: "ar",
  2049: "ar-IQ",
  11265: "ar-JO",
  13313: "ar-KW",
  12289: "ar-LB",
  4097: "ar-LY",
  6145: "ary",
  8193: "ar-OM",
  16385: "ar-QA",
  1025: "ar-SA",
  10241: "ar-SY",
  7169: "aeb",
  14337: "ar-AE",
  9217: "ar-YE",
  1067: "hy",
  1101: "as",
  2092: "az-Cyrl",
  1068: "az",
  1133: "ba",
  1069: "eu",
  1059: "be",
  2117: "bn",
  1093: "bn-IN",
  8218: "bs-Cyrl",
  5146: "bs",
  1150: "br",
  1026: "bg",
  1027: "ca",
  3076: "zh-HK",
  5124: "zh-MO",
  2052: "zh",
  4100: "zh-SG",
  1028: "zh-TW",
  1155: "co",
  1050: "hr",
  4122: "hr-BA",
  1029: "cs",
  1030: "da",
  1164: "prs",
  1125: "dv",
  2067: "nl-BE",
  1043: "nl",
  3081: "en-AU",
  10249: "en-BZ",
  4105: "en-CA",
  9225: "en-029",
  16393: "en-IN",
  6153: "en-IE",
  8201: "en-JM",
  17417: "en-MY",
  5129: "en-NZ",
  13321: "en-PH",
  18441: "en-SG",
  7177: "en-ZA",
  11273: "en-TT",
  2057: "en-GB",
  1033: "en",
  12297: "en-ZW",
  1061: "et",
  1080: "fo",
  1124: "fil",
  1035: "fi",
  2060: "fr-BE",
  3084: "fr-CA",
  1036: "fr",
  5132: "fr-LU",
  6156: "fr-MC",
  4108: "fr-CH",
  1122: "fy",
  1110: "gl",
  1079: "ka",
  3079: "de-AT",
  1031: "de",
  5127: "de-LI",
  4103: "de-LU",
  2055: "de-CH",
  1032: "el",
  1135: "kl",
  1095: "gu",
  1128: "ha",
  1037: "he",
  1081: "hi",
  1038: "hu",
  1039: "is",
  1136: "ig",
  1057: "id",
  1117: "iu",
  2141: "iu-Latn",
  2108: "ga",
  1076: "xh",
  1077: "zu",
  1040: "it",
  2064: "it-CH",
  1041: "ja",
  1099: "kn",
  1087: "kk",
  1107: "km",
  1158: "quc",
  1159: "rw",
  1089: "sw",
  1111: "kok",
  1042: "ko",
  1088: "ky",
  1108: "lo",
  1062: "lv",
  1063: "lt",
  2094: "dsb",
  1134: "lb",
  1071: "mk",
  2110: "ms-BN",
  1086: "ms",
  1100: "ml",
  1082: "mt",
  1153: "mi",
  1146: "arn",
  1102: "mr",
  1148: "moh",
  1104: "mn",
  2128: "mn-CN",
  1121: "ne",
  1044: "nb",
  2068: "nn",
  1154: "oc",
  1096: "or",
  1123: "ps",
  1045: "pl",
  1046: "pt",
  2070: "pt-PT",
  1094: "pa",
  1131: "qu-BO",
  2155: "qu-EC",
  3179: "qu",
  1048: "ro",
  1047: "rm",
  1049: "ru",
  9275: "smn",
  4155: "smj-NO",
  5179: "smj",
  3131: "se-FI",
  1083: "se",
  2107: "se-SE",
  8251: "sms",
  6203: "sma-NO",
  7227: "sms",
  1103: "sa",
  7194: "sr-Cyrl-BA",
  3098: "sr",
  6170: "sr-Latn-BA",
  2074: "sr-Latn",
  1132: "nso",
  1074: "tn",
  1115: "si",
  1051: "sk",
  1060: "sl",
  11274: "es-AR",
  16394: "es-BO",
  13322: "es-CL",
  9226: "es-CO",
  5130: "es-CR",
  7178: "es-DO",
  12298: "es-EC",
  17418: "es-SV",
  4106: "es-GT",
  18442: "es-HN",
  2058: "es-MX",
  19466: "es-NI",
  6154: "es-PA",
  15370: "es-PY",
  10250: "es-PE",
  20490: "es-PR",
  // Microsoft has defined two different language codes for
  // Spanish with modern sorting and Spanish with traditional
  // sorting. This makes sense for collation APIs, and it would be
  // possible to express this in BCP 47 language tags via Unicode
  // extensions (eg., es-u-co-trad is Spanish with traditional
  // sorting). However, for storing names in fonts, the distinction
  // does not make sense, so we give es in both cases.
  3082: "es",
  1034: "es",
  21514: "es-US",
  14346: "es-UY",
  8202: "es-VE",
  2077: "sv-FI",
  1053: "sv",
  1114: "syr",
  1064: "tg",
  2143: "tzm",
  1097: "ta",
  1092: "tt",
  1098: "te",
  1054: "th",
  1105: "bo",
  1055: "tr",
  1090: "tk",
  1152: "ug",
  1058: "uk",
  1070: "hsb",
  1056: "ur",
  2115: "uz-Cyrl",
  1091: "uz",
  1066: "vi",
  1106: "cy",
  1160: "wo",
  1157: "sah",
  1144: "ii",
  1130: "yo"
};
function getLanguageCode(platformID, languageID, ltag2) {
  switch (platformID) {
    case 0:
      if (languageID === 65535) {
        return "und";
      } else if (ltag2) {
        return ltag2[languageID];
      }
      break;
    case 1:
      return macLanguages[languageID];
    case 3:
      return windowsLanguages[languageID];
  }
  return void 0;
}
var utf16 = "utf-16";
var macScriptEncodings = {
  0: "macintosh",
  // smRoman
  1: "x-mac-japanese",
  // smJapanese
  2: "x-mac-chinesetrad",
  // smTradChinese
  3: "x-mac-korean",
  // smKorean
  6: "x-mac-greek",
  // smGreek
  7: "x-mac-cyrillic",
  // smCyrillic
  9: "x-mac-devanagai",
  // smDevanagari
  10: "x-mac-gurmukhi",
  // smGurmukhi
  11: "x-mac-gujarati",
  // smGujarati
  12: "x-mac-oriya",
  // smOriya
  13: "x-mac-bengali",
  // smBengali
  14: "x-mac-tamil",
  // smTamil
  15: "x-mac-telugu",
  // smTelugu
  16: "x-mac-kannada",
  // smKannada
  17: "x-mac-malayalam",
  // smMalayalam
  18: "x-mac-sinhalese",
  // smSinhalese
  19: "x-mac-burmese",
  // smBurmese
  20: "x-mac-khmer",
  // smKhmer
  21: "x-mac-thai",
  // smThai
  22: "x-mac-lao",
  // smLao
  23: "x-mac-georgian",
  // smGeorgian
  24: "x-mac-armenian",
  // smArmenian
  25: "x-mac-chinesesimp",
  // smSimpChinese
  26: "x-mac-tibetan",
  // smTibetan
  27: "x-mac-mongolian",
  // smMongolian
  28: "x-mac-ethiopic",
  // smEthiopic
  29: "x-mac-ce",
  // smCentralEuroRoman
  30: "x-mac-vietnamese",
  // smVietnamese
  31: "x-mac-extarabic"
  // smExtArabic
};
var macLanguageEncodings = {
  15: "x-mac-icelandic",
  // langIcelandic
  17: "x-mac-turkish",
  // langTurkish
  18: "x-mac-croatian",
  // langCroatian
  24: "x-mac-ce",
  // langLithuanian
  25: "x-mac-ce",
  // langPolish
  26: "x-mac-ce",
  // langHungarian
  27: "x-mac-ce",
  // langEstonian
  28: "x-mac-ce",
  // langLatvian
  30: "x-mac-icelandic",
  // langFaroese
  37: "x-mac-romanian",
  // langRomanian
  38: "x-mac-ce",
  // langCzech
  39: "x-mac-ce",
  // langSlovak
  40: "x-mac-ce",
  // langSlovenian
  143: "x-mac-inuit",
  // langInuktitut
  146: "x-mac-gaelic"
  // langIrishGaelicScript
};
function getEncoding(platformID, encodingID, languageID) {
  switch (platformID) {
    case 0:
      return utf16;
    case 1:
      return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
    case 3:
      if (encodingID === 1 || encodingID === 10) {
        return utf16;
      }
      break;
  }
  return void 0;
}
function parseNameTable(data, start, ltag2) {
  var name = {};
  var p = new parse.Parser(data, start);
  var format = p.parseUShort();
  var count = p.parseUShort();
  var stringOffset = p.offset + p.parseUShort();
  for (var i = 0; i < count; i++) {
    var platformID = p.parseUShort();
    var encodingID = p.parseUShort();
    var languageID = p.parseUShort();
    var nameID = p.parseUShort();
    var property = nameTableNames[nameID] || nameID;
    var byteLength = p.parseUShort();
    var offset = p.parseUShort();
    var language = getLanguageCode(platformID, languageID, ltag2);
    var encoding = getEncoding(platformID, encodingID, languageID);
    if (encoding !== void 0 && language !== void 0) {
      var text = void 0;
      if (encoding === utf16) {
        text = decode.UTF16(data, stringOffset + offset, byteLength);
      } else {
        text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
      }
      if (text) {
        var translations = name[property];
        if (translations === void 0) {
          translations = name[property] = {};
        }
        translations[language] = text;
      }
    }
  }
  if (format === 1) {
    p.parseUShort();
  }
  return name;
}
function reverseDict(dict) {
  var result = {};
  for (var key in dict) {
    result[dict[key]] = parseInt(key);
  }
  return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
  return new table.Record("NameRecord", [
    { name: "platformID", type: "USHORT", value: platformID },
    { name: "encodingID", type: "USHORT", value: encodingID },
    { name: "languageID", type: "USHORT", value: languageID },
    { name: "nameID", type: "USHORT", value: nameID },
    { name: "length", type: "USHORT", value: length },
    { name: "offset", type: "USHORT", value: offset }
  ]);
}
function findSubArray(needle, haystack) {
  var needleLength = needle.length;
  var limit = haystack.length - needleLength + 1;
  loop:
    for (var pos = 0; pos < limit; pos++) {
      for (; pos < limit; pos++) {
        for (var k = 0; k < needleLength; k++) {
          if (haystack[pos + k] !== needle[k]) {
            continue loop;
          }
        }
        return pos;
      }
    }
  return -1;
}
function addStringToPool(s, pool) {
  var offset = findSubArray(s, pool);
  if (offset < 0) {
    offset = pool.length;
    var i = 0;
    var len = s.length;
    for (; i < len; ++i) {
      pool.push(s[i]);
    }
  }
  return offset;
}
function makeNameTable(names, ltag2) {
  var nameID;
  var nameIDs = [];
  var namesWithNumericKeys = {};
  var nameTableIds = reverseDict(nameTableNames);
  for (var key in names) {
    var id = nameTableIds[key];
    if (id === void 0) {
      id = key;
    }
    nameID = parseInt(id);
    if (isNaN(nameID)) {
      throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
    }
    namesWithNumericKeys[nameID] = names[key];
    nameIDs.push(nameID);
  }
  var macLanguageIds = reverseDict(macLanguages);
  var windowsLanguageIds = reverseDict(windowsLanguages);
  var nameRecords = [];
  var stringPool = [];
  for (var i = 0; i < nameIDs.length; i++) {
    nameID = nameIDs[i];
    var translations = namesWithNumericKeys[nameID];
    for (var lang in translations) {
      var text = translations[lang];
      var macPlatform = 1;
      var macLanguage = macLanguageIds[lang];
      var macScript = macLanguageToScript[macLanguage];
      var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
      var macName = encode.MACSTRING(text, macEncoding);
      if (macName === void 0) {
        macPlatform = 0;
        macLanguage = ltag2.indexOf(lang);
        if (macLanguage < 0) {
          macLanguage = ltag2.length;
          ltag2.push(lang);
        }
        macScript = 4;
        macName = encode.UTF16(text);
      }
      var macNameOffset = addStringToPool(macName, stringPool);
      nameRecords.push(makeNameRecord(
        macPlatform,
        macScript,
        macLanguage,
        nameID,
        macName.length,
        macNameOffset
      ));
      var winLanguage = windowsLanguageIds[lang];
      if (winLanguage !== void 0) {
        var winName = encode.UTF16(text);
        var winNameOffset = addStringToPool(winName, stringPool);
        nameRecords.push(makeNameRecord(
          3,
          1,
          winLanguage,
          nameID,
          winName.length,
          winNameOffset
        ));
      }
    }
  }
  nameRecords.sort(function(a, b) {
    return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
  });
  var t = new table.Table("name", [
    { name: "format", type: "USHORT", value: 0 },
    { name: "count", type: "USHORT", value: nameRecords.length },
    { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
  ]);
  for (var r = 0; r < nameRecords.length; r++) {
    t.fields.push({ name: "record_" + r, type: "RECORD", value: nameRecords[r] });
  }
  t.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
  return t;
}
var _name = { parse: parseNameTable, make: makeNameTable };
var unicodeRanges = [
  { begin: 0, end: 127 },
  // Basic Latin
  { begin: 128, end: 255 },
  // Latin-1 Supplement
  { begin: 256, end: 383 },
  // Latin Extended-A
  { begin: 384, end: 591 },
  // Latin Extended-B
  { begin: 592, end: 687 },
  // IPA Extensions
  { begin: 688, end: 767 },
  // Spacing Modifier Letters
  { begin: 768, end: 879 },
  // Combining Diacritical Marks
  { begin: 880, end: 1023 },
  // Greek and Coptic
  { begin: 11392, end: 11519 },
  // Coptic
  { begin: 1024, end: 1279 },
  // Cyrillic
  { begin: 1328, end: 1423 },
  // Armenian
  { begin: 1424, end: 1535 },
  // Hebrew
  { begin: 42240, end: 42559 },
  // Vai
  { begin: 1536, end: 1791 },
  // Arabic
  { begin: 1984, end: 2047 },
  // NKo
  { begin: 2304, end: 2431 },
  // Devanagari
  { begin: 2432, end: 2559 },
  // Bengali
  { begin: 2560, end: 2687 },
  // Gurmukhi
  { begin: 2688, end: 2815 },
  // Gujarati
  { begin: 2816, end: 2943 },
  // Oriya
  { begin: 2944, end: 3071 },
  // Tamil
  { begin: 3072, end: 3199 },
  // Telugu
  { begin: 3200, end: 3327 },
  // Kannada
  { begin: 3328, end: 3455 },
  // Malayalam
  { begin: 3584, end: 3711 },
  // Thai
  { begin: 3712, end: 3839 },
  // Lao
  { begin: 4256, end: 4351 },
  // Georgian
  { begin: 6912, end: 7039 },
  // Balinese
  { begin: 4352, end: 4607 },
  // Hangul Jamo
  { begin: 7680, end: 7935 },
  // Latin Extended Additional
  { begin: 7936, end: 8191 },
  // Greek Extended
  { begin: 8192, end: 8303 },
  // General Punctuation
  { begin: 8304, end: 8351 },
  // Superscripts And Subscripts
  { begin: 8352, end: 8399 },
  // Currency Symbol
  { begin: 8400, end: 8447 },
  // Combining Diacritical Marks For Symbols
  { begin: 8448, end: 8527 },
  // Letterlike Symbols
  { begin: 8528, end: 8591 },
  // Number Forms
  { begin: 8592, end: 8703 },
  // Arrows
  { begin: 8704, end: 8959 },
  // Mathematical Operators
  { begin: 8960, end: 9215 },
  // Miscellaneous Technical
  { begin: 9216, end: 9279 },
  // Control Pictures
  { begin: 9280, end: 9311 },
  // Optical Character Recognition
  { begin: 9312, end: 9471 },
  // Enclosed Alphanumerics
  { begin: 9472, end: 9599 },
  // Box Drawing
  { begin: 9600, end: 9631 },
  // Block Elements
  { begin: 9632, end: 9727 },
  // Geometric Shapes
  { begin: 9728, end: 9983 },
  // Miscellaneous Symbols
  { begin: 9984, end: 10175 },
  // Dingbats
  { begin: 12288, end: 12351 },
  // CJK Symbols And Punctuation
  { begin: 12352, end: 12447 },
  // Hiragana
  { begin: 12448, end: 12543 },
  // Katakana
  { begin: 12544, end: 12591 },
  // Bopomofo
  { begin: 12592, end: 12687 },
  // Hangul Compatibility Jamo
  { begin: 43072, end: 43135 },
  // Phags-pa
  { begin: 12800, end: 13055 },
  // Enclosed CJK Letters And Months
  { begin: 13056, end: 13311 },
  // CJK Compatibility
  { begin: 44032, end: 55215 },
  // Hangul Syllables
  { begin: 55296, end: 57343 },
  // Non-Plane 0 *
  { begin: 67840, end: 67871 },
  // Phoenicia
  { begin: 19968, end: 40959 },
  // CJK Unified Ideographs
  { begin: 57344, end: 63743 },
  // Private Use Area (plane 0)
  { begin: 12736, end: 12783 },
  // CJK Strokes
  { begin: 64256, end: 64335 },
  // Alphabetic Presentation Forms
  { begin: 64336, end: 65023 },
  // Arabic Presentation Forms-A
  { begin: 65056, end: 65071 },
  // Combining Half Marks
  { begin: 65040, end: 65055 },
  // Vertical Forms
  { begin: 65104, end: 65135 },
  // Small Form Variants
  { begin: 65136, end: 65279 },
  // Arabic Presentation Forms-B
  { begin: 65280, end: 65519 },
  // Halfwidth And Fullwidth Forms
  { begin: 65520, end: 65535 },
  // Specials
  { begin: 3840, end: 4095 },
  // Tibetan
  { begin: 1792, end: 1871 },
  // Syriac
  { begin: 1920, end: 1983 },
  // Thaana
  { begin: 3456, end: 3583 },
  // Sinhala
  { begin: 4096, end: 4255 },
  // Myanmar
  { begin: 4608, end: 4991 },
  // Ethiopic
  { begin: 5024, end: 5119 },
  // Cherokee
  { begin: 5120, end: 5759 },
  // Unified Canadian Aboriginal Syllabics
  { begin: 5760, end: 5791 },
  // Ogham
  { begin: 5792, end: 5887 },
  // Runic
  { begin: 6016, end: 6143 },
  // Khmer
  { begin: 6144, end: 6319 },
  // Mongolian
  { begin: 10240, end: 10495 },
  // Braille Patterns
  { begin: 40960, end: 42127 },
  // Yi Syllables
  { begin: 5888, end: 5919 },
  // Tagalog
  { begin: 66304, end: 66351 },
  // Old Italic
  { begin: 66352, end: 66383 },
  // Gothic
  { begin: 66560, end: 66639 },
  // Deseret
  { begin: 118784, end: 119039 },
  // Byzantine Musical Symbols
  { begin: 119808, end: 120831 },
  // Mathematical Alphanumeric Symbols
  { begin: 1044480, end: 1048573 },
  // Private Use (plane 15)
  { begin: 65024, end: 65039 },
  // Variation Selectors
  { begin: 917504, end: 917631 },
  // Tags
  { begin: 6400, end: 6479 },
  // Limbu
  { begin: 6480, end: 6527 },
  // Tai Le
  { begin: 6528, end: 6623 },
  // New Tai Lue
  { begin: 6656, end: 6687 },
  // Buginese
  { begin: 11264, end: 11359 },
  // Glagolitic
  { begin: 11568, end: 11647 },
  // Tifinagh
  { begin: 19904, end: 19967 },
  // Yijing Hexagram Symbols
  { begin: 43008, end: 43055 },
  // Syloti Nagri
  { begin: 65536, end: 65663 },
  // Linear B Syllabary
  { begin: 65856, end: 65935 },
  // Ancient Greek Numbers
  { begin: 66432, end: 66463 },
  // Ugaritic
  { begin: 66464, end: 66527 },
  // Old Persian
  { begin: 66640, end: 66687 },
  // Shavian
  { begin: 66688, end: 66735 },
  // Osmanya
  { begin: 67584, end: 67647 },
  // Cypriot Syllabary
  { begin: 68096, end: 68191 },
  // Kharoshthi
  { begin: 119552, end: 119647 },
  // Tai Xuan Jing Symbols
  { begin: 73728, end: 74751 },
  // Cuneiform
  { begin: 119648, end: 119679 },
  // Counting Rod Numerals
  { begin: 7040, end: 7103 },
  // Sundanese
  { begin: 7168, end: 7247 },
  // Lepcha
  { begin: 7248, end: 7295 },
  // Ol Chiki
  { begin: 43136, end: 43231 },
  // Saurashtra
  { begin: 43264, end: 43311 },
  // Kayah Li
  { begin: 43312, end: 43359 },
  // Rejang
  { begin: 43520, end: 43615 },
  // Cham
  { begin: 65936, end: 65999 },
  // Ancient Symbols
  { begin: 66e3, end: 66047 },
  // Phaistos Disc
  { begin: 66208, end: 66271 },
  // Carian
  { begin: 127024, end: 127135 }
  // Domino Tiles
];
function getUnicodeRange(unicode) {
  for (var i = 0; i < unicodeRanges.length; i += 1) {
    var range = unicodeRanges[i];
    if (unicode >= range.begin && unicode < range.end) {
      return i;
    }
  }
  return -1;
}
function parseOS2Table(data, start) {
  var os22 = {};
  var p = new parse.Parser(data, start);
  os22.version = p.parseUShort();
  os22.xAvgCharWidth = p.parseShort();
  os22.usWeightClass = p.parseUShort();
  os22.usWidthClass = p.parseUShort();
  os22.fsType = p.parseUShort();
  os22.ySubscriptXSize = p.parseShort();
  os22.ySubscriptYSize = p.parseShort();
  os22.ySubscriptXOffset = p.parseShort();
  os22.ySubscriptYOffset = p.parseShort();
  os22.ySuperscriptXSize = p.parseShort();
  os22.ySuperscriptYSize = p.parseShort();
  os22.ySuperscriptXOffset = p.parseShort();
  os22.ySuperscriptYOffset = p.parseShort();
  os22.yStrikeoutSize = p.parseShort();
  os22.yStrikeoutPosition = p.parseShort();
  os22.sFamilyClass = p.parseShort();
  os22.panose = [];
  for (var i = 0; i < 10; i++) {
    os22.panose[i] = p.parseByte();
  }
  os22.ulUnicodeRange1 = p.parseULong();
  os22.ulUnicodeRange2 = p.parseULong();
  os22.ulUnicodeRange3 = p.parseULong();
  os22.ulUnicodeRange4 = p.parseULong();
  os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
  os22.fsSelection = p.parseUShort();
  os22.usFirstCharIndex = p.parseUShort();
  os22.usLastCharIndex = p.parseUShort();
  os22.sTypoAscender = p.parseShort();
  os22.sTypoDescender = p.parseShort();
  os22.sTypoLineGap = p.parseShort();
  os22.usWinAscent = p.parseUShort();
  os22.usWinDescent = p.parseUShort();
  if (os22.version >= 1) {
    os22.ulCodePageRange1 = p.parseULong();
    os22.ulCodePageRange2 = p.parseULong();
  }
  if (os22.version >= 2) {
    os22.sxHeight = p.parseShort();
    os22.sCapHeight = p.parseShort();
    os22.usDefaultChar = p.parseUShort();
    os22.usBreakChar = p.parseUShort();
    os22.usMaxContent = p.parseUShort();
  }
  return os22;
}
function makeOS2Table(options) {
  return new table.Table("OS/2", [
    { name: "version", type: "USHORT", value: 3 },
    { name: "xAvgCharWidth", type: "SHORT", value: 0 },
    { name: "usWeightClass", type: "USHORT", value: 0 },
    { name: "usWidthClass", type: "USHORT", value: 0 },
    { name: "fsType", type: "USHORT", value: 0 },
    { name: "ySubscriptXSize", type: "SHORT", value: 650 },
    { name: "ySubscriptYSize", type: "SHORT", value: 699 },
    { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
    { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
    { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
    { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
    { name: "yStrikeoutSize", type: "SHORT", value: 49 },
    { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
    { name: "sFamilyClass", type: "SHORT", value: 0 },
    { name: "bFamilyType", type: "BYTE", value: 0 },
    { name: "bSerifStyle", type: "BYTE", value: 0 },
    { name: "bWeight", type: "BYTE", value: 0 },
    { name: "bProportion", type: "BYTE", value: 0 },
    { name: "bContrast", type: "BYTE", value: 0 },
    { name: "bStrokeVariation", type: "BYTE", value: 0 },
    { name: "bArmStyle", type: "BYTE", value: 0 },
    { name: "bLetterform", type: "BYTE", value: 0 },
    { name: "bMidline", type: "BYTE", value: 0 },
    { name: "bXHeight", type: "BYTE", value: 0 },
    { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
    { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
    { name: "fsSelection", type: "USHORT", value: 0 },
    { name: "usFirstCharIndex", type: "USHORT", value: 0 },
    { name: "usLastCharIndex", type: "USHORT", value: 0 },
    { name: "sTypoAscender", type: "SHORT", value: 0 },
    { name: "sTypoDescender", type: "SHORT", value: 0 },
    { name: "sTypoLineGap", type: "SHORT", value: 0 },
    { name: "usWinAscent", type: "USHORT", value: 0 },
    { name: "usWinDescent", type: "USHORT", value: 0 },
    { name: "ulCodePageRange1", type: "ULONG", value: 0 },
    { name: "ulCodePageRange2", type: "ULONG", value: 0 },
    { name: "sxHeight", type: "SHORT", value: 0 },
    { name: "sCapHeight", type: "SHORT", value: 0 },
    { name: "usDefaultChar", type: "USHORT", value: 0 },
    { name: "usBreakChar", type: "USHORT", value: 0 },
    { name: "usMaxContext", type: "USHORT", value: 0 }
  ], options);
}
var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange };
function parsePostTable(data, start) {
  var post2 = {};
  var p = new parse.Parser(data, start);
  post2.version = p.parseVersion();
  post2.italicAngle = p.parseFixed();
  post2.underlinePosition = p.parseShort();
  post2.underlineThickness = p.parseShort();
  post2.isFixedPitch = p.parseULong();
  post2.minMemType42 = p.parseULong();
  post2.maxMemType42 = p.parseULong();
  post2.minMemType1 = p.parseULong();
  post2.maxMemType1 = p.parseULong();
  switch (post2.version) {
    case 1:
      post2.names = standardNames.slice();
      break;
    case 2:
      post2.numberOfGlyphs = p.parseUShort();
      post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
      for (var i = 0; i < post2.numberOfGlyphs; i++) {
        post2.glyphNameIndex[i] = p.parseUShort();
      }
      post2.names = [];
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        if (post2.glyphNameIndex[i$1] >= standardNames.length) {
          var nameLength = p.parseChar();
          post2.names.push(p.parseString(nameLength));
        }
      }
      break;
    case 2.5:
      post2.numberOfGlyphs = p.parseUShort();
      post2.offset = new Array(post2.numberOfGlyphs);
      for (var i$2 = 0; i$2 < post2.numberOfGlyphs; i$2++) {
        post2.offset[i$2] = p.parseChar();
      }
      break;
  }
  return post2;
}
function makePostTable() {
  return new table.Table("post", [
    { name: "version", type: "FIXED", value: 196608 },
    { name: "italicAngle", type: "FIXED", value: 0 },
    { name: "underlinePosition", type: "FWORD", value: 0 },
    { name: "underlineThickness", type: "FWORD", value: 0 },
    { name: "isFixedPitch", type: "ULONG", value: 0 },
    { name: "minMemType42", type: "ULONG", value: 0 },
    { name: "maxMemType42", type: "ULONG", value: 0 },
    { name: "minMemType1", type: "ULONG", value: 0 },
    { name: "maxMemType1", type: "ULONG", value: 0 }
  ]);
}
var post = { parse: parsePostTable, make: makePostTable };
var subtableParsers = new Array(9);
subtableParsers[1] = function parseLookup1() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      deltaGlyphId: this.parseUShort()
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      substitute: this.parseOffset16List()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
subtableParsers[2] = function parseLookup2() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    sequences: this.parseListOfLists()
  };
};
subtableParsers[3] = function parseLookup3() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    alternateSets: this.parseListOfLists()
  };
};
subtableParsers[4] = function parseLookup4() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB ligature table identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    ligatureSets: this.parseListOfLists(function() {
      return {
        ligGlyph: this.parseUShort(),
        components: this.parseUShortList(this.parseUShort() - 1)
      };
    })
  };
};
var lookupRecordDesc = {
  sequenceIndex: Parser.uShort,
  lookupListIndex: Parser.uShort
};
subtableParsers[5] = function parseLookup5() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser.coverage),
      ruleSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          input: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser.coverage),
      classDef: this.parsePointer(Parser.classDef),
      classSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          classes: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    var glyphCount = this.parseUShort();
    var substCount = this.parseUShort();
    return {
      substFormat,
      coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
subtableParsers[6] = function parseLookup6() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      chainRuleSets: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      backtrackClassDef: this.parsePointer(Parser.classDef),
      inputClassDef: this.parsePointer(Parser.classDef),
      lookaheadClassDef: this.parsePointer(Parser.classDef),
      chainClassSet: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    return {
      substFormat: 3,
      backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      lookupRecords: this.parseRecordList(lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
subtableParsers[7] = function parseLookup7() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var extensionLookupType = this.parseUShort();
  var extensionParser = new Parser(this.data, this.offset + this.parseULong());
  return {
    substFormat: 1,
    lookupType: extensionLookupType,
    extension: subtableParsers[extensionLookupType].call(extensionParser)
  };
};
subtableParsers[8] = function parseLookup8() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
    lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
    substitutes: this.parseUShortList()
  };
};
function parseGsubTable(data, start) {
  start = start || 0;
  var p = new Parser(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GSUB table version.");
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
  if (subtable.substFormat === 1) {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 1 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) },
      { name: "deltaGlyphID", type: "USHORT", value: subtable.deltaGlyphId }
    ]);
  } else {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 2 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.ushortList("substitute", subtable.substitute)));
  }
};
subtableMakers[2] = function makeLookup2(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 2 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("seqSet", subtable.sequences, function(sequenceSet) {
    return new table.Table("sequenceSetTable", table.ushortList("sequence", sequenceSet));
  })));
};
subtableMakers[3] = function makeLookup3(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 3 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("altSet", subtable.alternateSets, function(alternateSet) {
    return new table.Table("alternateSetTable", table.ushortList("alternate", alternateSet));
  })));
};
subtableMakers[4] = function makeLookup4(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 4 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("ligSet", subtable.ligatureSets, function(ligatureSet) {
    return new table.Table("ligatureSetTable", table.tableList("ligature", ligatureSet, function(ligature) {
      return new table.Table(
        "ligatureTable",
        [{ name: "ligGlyph", type: "USHORT", value: ligature.ligGlyph }].concat(table.ushortList("component", ligature.components, ligature.components.length + 1))
      );
    }));
  })));
};
subtableMakers[6] = function makeLookup6(subtable) {
  if (subtable.substFormat === 1) {
    var returnTable = new table.Table("chainContextTable", [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.tableList("chainRuleSet", subtable.chainRuleSets, function(chainRuleSet) {
      return new table.Table("chainRuleSetTable", table.tableList("chainRule", chainRuleSet, function(chainRule) {
        var tableData2 = table.ushortList("backtrackGlyph", chainRule.backtrack, chainRule.backtrack.length).concat(table.ushortList("inputGlyph", chainRule.input, chainRule.input.length + 1)).concat(table.ushortList("lookaheadGlyph", chainRule.lookahead, chainRule.lookahead.length)).concat(table.ushortList("substitution", [], chainRule.lookupRecords.length));
        chainRule.lookupRecords.forEach(function(record, i) {
          tableData2 = tableData2.concat({ name: "sequenceIndex" + i, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i, type: "USHORT", value: record.lookupListIndex });
        });
        return new table.Table("chainRuleTable", tableData2);
      }));
    })));
    return returnTable;
  } else if (subtable.substFormat === 2) {
    check.assert(false, "lookup type 6 format 2 is not yet supported.");
  } else if (subtable.substFormat === 3) {
    var tableData = [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat }
    ];
    tableData.push({ name: "backtrackGlyphCount", type: "USHORT", value: subtable.backtrackCoverage.length });
    subtable.backtrackCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "backtrackCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "inputGlyphCount", type: "USHORT", value: subtable.inputCoverage.length });
    subtable.inputCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "inputCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "lookaheadGlyphCount", type: "USHORT", value: subtable.lookaheadCoverage.length });
    subtable.lookaheadCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "lookaheadCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "substitutionCount", type: "USHORT", value: subtable.lookupRecords.length });
    subtable.lookupRecords.forEach(function(record, i) {
      tableData = tableData.concat({ name: "sequenceIndex" + i, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i, type: "USHORT", value: record.lookupListIndex });
    });
    var returnTable$1 = new table.Table("chainContextTable", tableData);
    return returnTable$1;
  }
  check.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
function makeGsubTable(gsub2) {
  return new table.Table("GSUB", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gsub2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gsub2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gsub2.lookups, subtableMakers) }
  ]);
}
var gsub = { parse: parseGsubTable, make: makeGsubTable };
function parseMetaTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported META table version.");
  p.parseULong();
  p.parseULong();
  var numDataMaps = p.parseULong();
  var tags = {};
  for (var i = 0; i < numDataMaps; i++) {
    var tag = p.parseTag();
    var dataOffset = p.parseULong();
    var dataLength = p.parseULong();
    var text = decode.UTF8(data, start + dataOffset, dataLength);
    tags[tag] = text;
  }
  return tags;
}
function makeMetaTable(tags) {
  var numTags = Object.keys(tags).length;
  var stringPool = "";
  var stringPoolOffset = 16 + numTags * 12;
  var result = new table.Table("meta", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "offset", type: "ULONG", value: stringPoolOffset },
    { name: "numTags", type: "ULONG", value: numTags }
  ]);
  for (var tag in tags) {
    var pos = stringPool.length;
    stringPool += tags[tag];
    result.fields.push({ name: "tag " + tag, type: "TAG", value: tag });
    result.fields.push({ name: "offset " + tag, type: "ULONG", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + tag, type: "ULONG", value: tags[tag].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
var meta = { parse: parseMetaTable, make: makeMetaTable };
function log2(v) {
  return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
  while (bytes.length % 4 !== 0) {
    bytes.push(0);
  }
  var sum = 0;
  for (var i = 0; i < bytes.length; i += 4) {
    sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
  }
  sum %= Math.pow(2, 32);
  return sum;
}
function makeTableRecord(tag, checkSum, offset, length) {
  return new table.Record("Table Record", [
    { name: "tag", type: "TAG", value: tag !== void 0 ? tag : "" },
    { name: "checkSum", type: "ULONG", value: checkSum !== void 0 ? checkSum : 0 },
    { name: "offset", type: "ULONG", value: offset !== void 0 ? offset : 0 },
    { name: "length", type: "ULONG", value: length !== void 0 ? length : 0 }
  ]);
}
function makeSfntTable(tables) {
  var sfnt2 = new table.Table("sfnt", [
    { name: "version", type: "TAG", value: "OTTO" },
    { name: "numTables", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  sfnt2.tables = tables;
  sfnt2.numTables = tables.length;
  var highestPowerOf2 = Math.pow(2, log2(sfnt2.numTables));
  sfnt2.searchRange = 16 * highestPowerOf2;
  sfnt2.entrySelector = log2(highestPowerOf2);
  sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
  var recordFields = [];
  var tableFields = [];
  var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
  while (offset % 4 !== 0) {
    offset += 1;
    tableFields.push({ name: "padding", type: "BYTE", value: 0 });
  }
  for (var i = 0; i < tables.length; i += 1) {
    var t = tables[i];
    check.argument(t.tableName.length === 4, "Table name" + t.tableName + " is invalid.");
    var tableLength = t.sizeOf();
    var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
    recordFields.push({ name: tableRecord.tag + " Table Record", type: "RECORD", value: tableRecord });
    tableFields.push({ name: t.tableName + " table", type: "RECORD", value: t });
    offset += tableLength;
    check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
    while (offset % 4 !== 0) {
      offset += 1;
      tableFields.push({ name: "padding", type: "BYTE", value: 0 });
    }
  }
  recordFields.sort(function(r1, r2) {
    if (r1.value.tag > r2.value.tag) {
      return 1;
    } else {
      return -1;
    }
  });
  sfnt2.fields = sfnt2.fields.concat(recordFields);
  sfnt2.fields = sfnt2.fields.concat(tableFields);
  return sfnt2;
}
function metricsForChar(font, chars, notFoundMetrics) {
  for (var i = 0; i < chars.length; i += 1) {
    var glyphIndex = font.charToGlyphIndex(chars[i]);
    if (glyphIndex > 0) {
      var glyph = font.glyphs.get(glyphIndex);
      return glyph.getMetrics();
    }
  }
  return notFoundMetrics;
}
function average(vs) {
  var sum = 0;
  for (var i = 0; i < vs.length; i += 1) {
    sum += vs[i];
  }
  return sum / vs.length;
}
function fontToSfntTable(font) {
  var xMins = [];
  var yMins = [];
  var xMaxs = [];
  var yMaxs = [];
  var advanceWidths = [];
  var leftSideBearings = [];
  var rightSideBearings = [];
  var firstCharIndex;
  var lastCharIndex = 0;
  var ulUnicodeRange1 = 0;
  var ulUnicodeRange2 = 0;
  var ulUnicodeRange3 = 0;
  var ulUnicodeRange4 = 0;
  for (var i = 0; i < font.glyphs.length; i += 1) {
    var glyph = font.glyphs.get(i);
    var unicode = glyph.unicode | 0;
    if (isNaN(glyph.advanceWidth)) {
      throw new Error("Glyph " + glyph.name + " (" + i + "): advanceWidth is not a number.");
    }
    if (firstCharIndex > unicode || firstCharIndex === void 0) {
      if (unicode > 0) {
        firstCharIndex = unicode;
      }
    }
    if (lastCharIndex < unicode) {
      lastCharIndex = unicode;
    }
    var position = os2.getUnicodeRange(unicode);
    if (position < 32) {
      ulUnicodeRange1 |= 1 << position;
    } else if (position < 64) {
      ulUnicodeRange2 |= 1 << position - 32;
    } else if (position < 96) {
      ulUnicodeRange3 |= 1 << position - 64;
    } else if (position < 123) {
      ulUnicodeRange4 |= 1 << position - 96;
    } else {
      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
    }
    if (glyph.name === ".notdef") {
      continue;
    }
    var metrics = glyph.getMetrics();
    xMins.push(metrics.xMin);
    yMins.push(metrics.yMin);
    xMaxs.push(metrics.xMax);
    yMaxs.push(metrics.yMax);
    leftSideBearings.push(metrics.leftSideBearing);
    rightSideBearings.push(metrics.rightSideBearing);
    advanceWidths.push(glyph.advanceWidth);
  }
  var globals = {
    xMin: Math.min.apply(null, xMins),
    yMin: Math.min.apply(null, yMins),
    xMax: Math.max.apply(null, xMaxs),
    yMax: Math.max.apply(null, yMaxs),
    advanceWidthMax: Math.max.apply(null, advanceWidths),
    advanceWidthAvg: average(advanceWidths),
    minLeftSideBearing: Math.min.apply(null, leftSideBearings),
    maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
    minRightSideBearing: Math.min.apply(null, rightSideBearings)
  };
  globals.ascender = font.ascender;
  globals.descender = font.descender;
  var headTable = head.make({
    flags: 3,
    // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
    unitsPerEm: font.unitsPerEm,
    xMin: globals.xMin,
    yMin: globals.yMin,
    xMax: globals.xMax,
    yMax: globals.yMax,
    lowestRecPPEM: 3,
    createdTimestamp: font.createdTimestamp
  });
  var hheaTable = hhea.make({
    ascender: globals.ascender,
    descender: globals.descender,
    advanceWidthMax: globals.advanceWidthMax,
    minLeftSideBearing: globals.minLeftSideBearing,
    minRightSideBearing: globals.minRightSideBearing,
    xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
    numberOfHMetrics: font.glyphs.length
  });
  var maxpTable = maxp.make(font.glyphs.length);
  var os2Table = os2.make(Object.assign({
    xAvgCharWidth: Math.round(globals.advanceWidthAvg),
    usFirstCharIndex: firstCharIndex,
    usLastCharIndex: lastCharIndex,
    ulUnicodeRange1,
    ulUnicodeRange2,
    ulUnicodeRange3,
    ulUnicodeRange4,
    // See http://typophile.com/node/13081 for more info on vertical metrics.
    // We get metrics for typical characters (such as "x" for xHeight).
    // We provide some fallback characters if characters are unavailable: their
    // ordering was chosen experimentally.
    sTypoAscender: globals.ascender,
    sTypoDescender: globals.descender,
    sTypoLineGap: 0,
    usWinAscent: globals.yMax,
    usWinDescent: Math.abs(globals.yMin),
    ulCodePageRange1: 1,
    // FIXME: hard-code Latin 1 support for now
    sxHeight: metricsForChar(font, "xyvw", { yMax: Math.round(globals.ascender / 2) }).yMax,
    sCapHeight: metricsForChar(font, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
    usDefaultChar: font.hasChar(" ") ? 32 : 0,
    // Use space as the default character, if available.
    usBreakChar: font.hasChar(" ") ? 32 : 0
    // Use space as the break character, if available.
  }, font.tables.os2));
  var hmtxTable = hmtx.make(font.glyphs);
  var cmapTable = cmap.make(font.glyphs);
  var englishFamilyName = font.getEnglishName("fontFamily");
  var englishStyleName = font.getEnglishName("fontSubfamily");
  var englishFullName = englishFamilyName + " " + englishStyleName;
  var postScriptName = font.getEnglishName("postScriptName");
  if (!postScriptName) {
    postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
  }
  var names = {};
  for (var n in font.names) {
    names[n] = font.names[n];
  }
  if (!names.uniqueID) {
    names.uniqueID = { en: font.getEnglishName("manufacturer") + ":" + englishFullName };
  }
  if (!names.postScriptName) {
    names.postScriptName = { en: postScriptName };
  }
  if (!names.preferredFamily) {
    names.preferredFamily = font.names.fontFamily;
  }
  if (!names.preferredSubfamily) {
    names.preferredSubfamily = font.names.fontSubfamily;
  }
  var languageTags = [];
  var nameTable = _name.make(names, languageTags);
  var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : void 0;
  var postTable = post.make();
  var cffTable = cff.make(font.glyphs, {
    version: font.getEnglishName("version"),
    fullName: englishFullName,
    familyName: englishFamilyName,
    weightName: englishStyleName,
    postScriptName,
    unitsPerEm: font.unitsPerEm,
    fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
  });
  var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : void 0;
  var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
  if (ltagTable) {
    tables.push(ltagTable);
  }
  if (font.tables.gsub) {
    tables.push(gsub.make(font.tables.gsub));
  }
  if (metaTable) {
    tables.push(metaTable);
  }
  var sfntTable = makeSfntTable(tables);
  var bytes = sfntTable.encode();
  var checkSum = computeCheckSum(bytes);
  var tableFields = sfntTable.fields;
  var checkSumAdjusted = false;
  for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
    if (tableFields[i$1].name === "head table") {
      tableFields[i$1].value.checkSumAdjustment = 2981146554 - checkSum;
      checkSumAdjusted = true;
      break;
    }
  }
  if (!checkSumAdjusted) {
    throw new Error("Could not find head table with checkSum to adjust.");
  }
  return sfntTable;
}
var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };
function searchTag(arr, tag) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid].tag;
    if (val === tag) {
      return imid;
    } else if (val < tag) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function binSearch(arr, value) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid];
    if (val === value) {
      return imid;
    } else if (val < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function searchRange(ranges, value) {
  var range;
  var imin = 0;
  var imax = ranges.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    range = ranges[imid];
    var start = range.start;
    if (start === value) {
      return range;
    } else if (start < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  if (imin > 0) {
    range = ranges[imin - 1];
    if (value > range.end) {
      return 0;
    }
    return range;
  }
}
function Layout(font, tableName) {
  this.font = font;
  this.tableName = tableName;
}
Layout.prototype = {
  /**
   * Binary search an object by "tag" property
   * @instance
   * @function searchTag
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {string} tag
   * @return {number}
   */
  searchTag,
  /**
   * Binary search in a list of numbers
   * @instance
   * @function binSearch
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {number} value
   * @return {number}
   */
  binSearch,
  /**
   * Get or create the Layout table (GSUB, GPOS etc).
   * @param  {boolean} create - Whether to create a new one.
   * @return {Object} The GSUB or GPOS table.
   */
  getTable: function(create) {
    var layout = this.font.tables[this.tableName];
    if (!layout && create) {
      layout = this.font.tables[this.tableName] = this.createDefaultTable();
    }
    return layout;
  },
  /**
   * Returns all scripts in the substitution table.
   * @instance
   * @return {Array}
   */
  getScriptNames: function() {
    var layout = this.getTable();
    if (!layout) {
      return [];
    }
    return layout.scripts.map(function(script) {
      return script.tag;
    });
  },
  /**
   * Returns the best bet for a script name.
   * Returns 'DFLT' if it exists.
   * If not, returns 'latn' if it exists.
   * If neither exist, returns undefined.
   */
  getDefaultScriptName: function() {
    var layout = this.getTable();
    if (!layout) {
      return;
    }
    var hasLatn = false;
    for (var i = 0; i < layout.scripts.length; i++) {
      var name = layout.scripts[i].tag;
      if (name === "DFLT") {
        return name;
      }
      if (name === "latn") {
        hasLatn = true;
      }
    }
    if (hasLatn) {
      return "latn";
    }
  },
  /**
   * Returns all LangSysRecords in the given script.
   * @instance
   * @param {string} [script='DFLT']
   * @param {boolean} create - forces the creation of this script table if it doesn't exist.
   * @return {Object} An object with tag and script properties.
   */
  getScriptTable: function(script, create) {
    var layout = this.getTable(create);
    if (layout) {
      script = script || "DFLT";
      var scripts = layout.scripts;
      var pos = searchTag(layout.scripts, script);
      if (pos >= 0) {
        return scripts[pos].script;
      } else if (create) {
        var scr = {
          tag: script,
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        };
        scripts.splice(-1 - pos, 0, scr);
        return scr.script;
      }
    }
  },
  /**
   * Returns a language system table
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
   * @return {Object}
   */
  getLangSysTable: function(script, language, create) {
    var scriptTable = this.getScriptTable(script, create);
    if (scriptTable) {
      if (!language || language === "dflt" || language === "DFLT") {
        return scriptTable.defaultLangSys;
      }
      var pos = searchTag(scriptTable.langSysRecords, language);
      if (pos >= 0) {
        return scriptTable.langSysRecords[pos].langSys;
      } else if (create) {
        var langSysRecord = {
          tag: language,
          langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
        };
        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
        return langSysRecord.langSys;
      }
    }
  },
  /**
   * Get a specific feature table.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
   * @return {Object}
   */
  getFeatureTable: function(script, language, feature, create) {
    var langSysTable2 = this.getLangSysTable(script, language, create);
    if (langSysTable2) {
      var featureRecord;
      var featIndexes = langSysTable2.featureIndexes;
      var allFeatures = this.font.tables[this.tableName].features;
      for (var i = 0; i < featIndexes.length; i++) {
        featureRecord = allFeatures[featIndexes[i]];
        if (featureRecord.tag === feature) {
          return featureRecord.feature;
        }
      }
      if (create) {
        var index = allFeatures.length;
        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, "Features must be added in alphabetical order.");
        featureRecord = {
          tag: feature,
          feature: { params: 0, lookupListIndexes: [] }
        };
        allFeatures.push(featureRecord);
        featIndexes.push(index);
        return featureRecord.feature;
      }
    }
  },
  /**
   * Get the lookup tables of a given type for a script/language/feature.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - 4-letter feature code
   * @param {number} lookupType - 1 to 9
   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
   * @return {Object[]}
   */
  getLookupTables: function(script, language, feature, lookupType, create) {
    var featureTable = this.getFeatureTable(script, language, feature, create);
    var tables = [];
    if (featureTable) {
      var lookupTable;
      var lookupListIndexes = featureTable.lookupListIndexes;
      var allLookups = this.font.tables[this.tableName].lookups;
      for (var i = 0; i < lookupListIndexes.length; i++) {
        lookupTable = allLookups[lookupListIndexes[i]];
        if (lookupTable.lookupType === lookupType) {
          tables.push(lookupTable);
        }
      }
      if (tables.length === 0 && create) {
        lookupTable = {
          lookupType,
          lookupFlag: 0,
          subtables: [],
          markFilteringSet: void 0
        };
        var index = allLookups.length;
        allLookups.push(lookupTable);
        lookupListIndexes.push(index);
        return [lookupTable];
      }
    }
    return tables;
  },
  /**
   * Find a glyph in a class definition table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
   * @param {object} classDefTable - an OpenType Layout class definition table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getGlyphClass: function(classDefTable, glyphIndex) {
    switch (classDefTable.format) {
      case 1:
        if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
          return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
        }
        return 0;
      case 2:
        var range = searchRange(classDefTable.ranges, glyphIndex);
        return range ? range.classId : 0;
    }
  },
  /**
   * Find a glyph in a coverage table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
   * @param {object} coverageTable - an OpenType Layout coverage table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getCoverageIndex: function(coverageTable, glyphIndex) {
    switch (coverageTable.format) {
      case 1:
        var index = binSearch(coverageTable.glyphs, glyphIndex);
        return index >= 0 ? index : -1;
      case 2:
        var range = searchRange(coverageTable.ranges, glyphIndex);
        return range ? range.index + glyphIndex - range.start : -1;
    }
  },
  /**
   * Returns the list of glyph indexes of a coverage table.
   * Format 1: the list is stored raw
   * Format 2: compact list as range records.
   * @instance
   * @param  {Object} coverageTable
   * @return {Array}
   */
  expandCoverage: function(coverageTable) {
    if (coverageTable.format === 1) {
      return coverageTable.glyphs;
    } else {
      var glyphs = [];
      var ranges = coverageTable.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        var start = range.start;
        var end = range.end;
        for (var j = start; j <= end; j++) {
          glyphs.push(j);
        }
      }
      return glyphs;
    }
  }
};
function Position(font) {
  Layout.call(this, font, "gpos");
}
Position.prototype = Layout.prototype;
Position.prototype.init = function() {
  var script = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(script);
};
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
  for (var i = 0; i < kerningLookups.length; i++) {
    var subtables = kerningLookups[i].subtables;
    for (var j = 0; j < subtables.length; j++) {
      var subtable = subtables[j];
      var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
      if (covIndex < 0) {
        continue;
      }
      switch (subtable.posFormat) {
        case 1:
          var pairSet = subtable.pairSets[covIndex];
          for (var k = 0; k < pairSet.length; k++) {
            var pair = pairSet[k];
            if (pair.secondGlyph === rightIndex) {
              return pair.value1 && pair.value1.xAdvance || 0;
            }
          }
          break;
        case 2:
          var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
          var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
          var pair$1 = subtable.classRecords[class1][class2];
          return pair$1.value1 && pair$1.value1.xAdvance || 0;
      }
    }
  }
  return 0;
};
Position.prototype.getKerningTables = function(script, language) {
  if (this.font.tables.gpos) {
    return this.getLookupTables(script, language, "kern", 2);
  }
};
function Substitution(font) {
  Layout.call(this, font, "gsub");
}
function arraysEqual(ar1, ar2) {
  var n = ar1.length;
  if (n !== ar2.length) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    if (ar1[i] !== ar2[i]) {
      return false;
    }
  }
  return true;
}
function getSubstFormat(lookupTable, format, defaultSubtable) {
  var subtables = lookupTable.subtables;
  for (var i = 0; i < subtables.length; i++) {
    var subtable = subtables[i];
    if (subtable.substFormat === format) {
      return subtable;
    }
  }
  if (defaultSubtable) {
    subtables.push(defaultSubtable);
    return defaultSubtable;
  }
  return void 0;
}
Substitution.prototype = Layout.prototype;
Substitution.prototype.createDefaultTable = function() {
  return {
    version: 1,
    scripts: [{
      tag: "DFLT",
      script: {
        defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
        langSysRecords: []
      }
    }],
    features: [],
    lookups: []
  };
};
Substitution.prototype.getSingle = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 1);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      if (subtable.substFormat === 1) {
        var delta = subtable.deltaGlyphId;
        for (j = 0; j < glyphs.length; j++) {
          var glyph = glyphs[j];
          substitutions.push({ sub: glyph, by: glyph + delta });
        }
      } else {
        var substitute = subtable.substitute;
        for (j = 0; j < glyphs.length; j++) {
          substitutions.push({ sub: glyphs[j], by: substitute[j] });
        }
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getMultiple = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 2);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      for (j = 0; j < glyphs.length; j++) {
        var glyph = glyphs[j];
        var replacements = subtable.sequences[j];
        substitutions.push({ sub: glyph, by: replacements });
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getAlternates = function(feature, script, language) {
  var alternates = [];
  var lookupTables = this.getLookupTables(script, language, feature, 3);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var alternateSets = subtable.alternateSets;
      for (var j = 0; j < glyphs.length; j++) {
        alternates.push({ sub: glyphs[j], by: alternateSets[j] });
      }
    }
  }
  return alternates;
};
Substitution.prototype.getLigatures = function(feature, script, language) {
  var ligatures = [];
  var lookupTables = this.getLookupTables(script, language, feature, 4);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var ligatureSets = subtable.ligatureSets;
      for (var j = 0; j < glyphs.length; j++) {
        var startGlyph = glyphs[j];
        var ligSet = ligatureSets[j];
        for (var k = 0; k < ligSet.length; k++) {
          var lig = ligSet[k];
          ligatures.push({
            sub: [startGlyph].concat(lig.components),
            by: lig.ligGlyph
          });
        }
      }
    }
  }
  return ligatures;
};
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
  var subtable = getSubstFormat(lookupTable, 2, {
    // lookup type 1 subtable, format 2, coverage format 1
    substFormat: 2,
    coverage: { format: 1, glyphs: [] },
    substitute: []
  });
  check.assert(subtable.coverage.format === 1, "Single: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.substitute.splice(pos, 0, 0);
  }
  subtable.substitute[pos] = substitution.by;
};
Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
  check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 2 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    sequences: []
  });
  check.assert(subtable.coverage.format === 1, "Multiple: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.sequences.splice(pos, 0, 0);
  }
  subtable.sequences[pos] = substitution.by;
};
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 3 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    alternateSets: []
  });
  check.assert(subtable.coverage.format === 1, "Alternate: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.alternateSets.splice(pos, 0, 0);
  }
  subtable.alternateSets[pos] = substitution.by;
};
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
  var subtable = lookupTable.subtables[0];
  if (!subtable) {
    subtable = {
      // lookup type 4 subtable, format 1, coverage format 1
      substFormat: 1,
      coverage: { format: 1, glyphs: [] },
      ligatureSets: []
    };
    lookupTable.subtables[0] = subtable;
  }
  check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = ligature.sub[0];
  var ligComponents = ligature.sub.slice(1);
  var ligatureTable = {
    ligGlyph: ligature.by,
    components: ligComponents
  };
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos >= 0) {
    var ligatureSet = subtable.ligatureSets[pos];
    for (var i = 0; i < ligatureSet.length; i++) {
      if (arraysEqual(ligatureSet[i].components, ligComponents)) {
        return;
      }
    }
    ligatureSet.push(ligatureTable);
  } else {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
  }
};
Substitution.prototype.getFeature = function(feature, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.getSingle(feature, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(feature, script, language);
    case "ccmp":
      return this.getMultiple(feature, script, language).concat(this.getLigatures(feature, script, language));
    case "stch":
      return this.getMultiple(feature, script, language);
  }
  return void 0;
};
Substitution.prototype.add = function(feature, sub, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.addSingle(feature, sub, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      if (typeof sub.by === "number") {
        return this.addSingle(feature, sub, script, language);
      }
      return this.addAlternate(feature, sub, script, language);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(feature, sub, script, language);
    case "ccmp":
      if (sub.by instanceof Array) {
        return this.addMultiple(feature, sub, script, language);
      }
      return this.addLigature(feature, sub, script, language);
  }
  return void 0;
};
function isBrowser() {
  return typeof window !== "undefined";
}
function nodeBufferToArrayBuffer(buffer) {
  var ab = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return ab;
}
function arrayBufferToNodeBuffer(ab) {
  var buffer = new Buffer(ab.byteLength);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
    buffer[i] = view[i];
  }
  return buffer;
}
function checkArgument(expression, message) {
  if (!expression) {
    throw message;
  }
}
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
  var v;
  if ((flag & shortVectorBitMask) > 0) {
    v = p.parseByte();
    if ((flag & sameBitMask) === 0) {
      v = -v;
    }
    v = previousValue + v;
  } else {
    if ((flag & sameBitMask) > 0) {
      v = previousValue;
    } else {
      v = previousValue + p.parseShort();
    }
  }
  return v;
}
function parseGlyph(glyph, data, start) {
  var p = new parse.Parser(data, start);
  glyph.numberOfContours = p.parseShort();
  glyph._xMin = p.parseShort();
  glyph._yMin = p.parseShort();
  glyph._xMax = p.parseShort();
  glyph._yMax = p.parseShort();
  var flags;
  var flag;
  if (glyph.numberOfContours > 0) {
    var endPointIndices = glyph.endPointIndices = [];
    for (var i = 0; i < glyph.numberOfContours; i += 1) {
      endPointIndices.push(p.parseUShort());
    }
    glyph.instructionLength = p.parseUShort();
    glyph.instructions = [];
    for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
      glyph.instructions.push(p.parseByte());
    }
    var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
    flags = [];
    for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
      flag = p.parseByte();
      flags.push(flag);
      if ((flag & 8) > 0) {
        var repeatCount = p.parseByte();
        for (var j = 0; j < repeatCount; j += 1) {
          flags.push(flag);
          i$2 += 1;
        }
      }
    }
    check.argument(flags.length === numberOfCoordinates, "Bad flags.");
    if (endPointIndices.length > 0) {
      var points = [];
      var point;
      if (numberOfCoordinates > 0) {
        for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
          flag = flags[i$3];
          point = {};
          point.onCurve = !!(flag & 1);
          point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
          points.push(point);
        }
        var px = 0;
        for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
          flag = flags[i$4];
          point = points[i$4];
          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
          px = point.x;
        }
        var py = 0;
        for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
          flag = flags[i$5];
          point = points[i$5];
          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
          py = point.y;
        }
      }
      glyph.points = points;
    } else {
      glyph.points = [];
    }
  } else if (glyph.numberOfContours === 0) {
    glyph.points = [];
  } else {
    glyph.isComposite = true;
    glyph.points = [];
    glyph.components = [];
    var moreComponents = true;
    while (moreComponents) {
      flags = p.parseUShort();
      var component = {
        glyphIndex: p.parseUShort(),
        xScale: 1,
        scale01: 0,
        scale10: 0,
        yScale: 1,
        dx: 0,
        dy: 0
      };
      if ((flags & 1) > 0) {
        if ((flags & 2) > 0) {
          component.dx = p.parseShort();
          component.dy = p.parseShort();
        } else {
          component.matchedPoints = [p.parseUShort(), p.parseUShort()];
        }
      } else {
        if ((flags & 2) > 0) {
          component.dx = p.parseChar();
          component.dy = p.parseChar();
        } else {
          component.matchedPoints = [p.parseByte(), p.parseByte()];
        }
      }
      if ((flags & 8) > 0) {
        component.xScale = component.yScale = p.parseF2Dot14();
      } else if ((flags & 64) > 0) {
        component.xScale = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      } else if ((flags & 128) > 0) {
        component.xScale = p.parseF2Dot14();
        component.scale01 = p.parseF2Dot14();
        component.scale10 = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      }
      glyph.components.push(component);
      moreComponents = !!(flags & 32);
    }
    if (flags & 256) {
      glyph.instructionLength = p.parseUShort();
      glyph.instructions = [];
      for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
        glyph.instructions.push(p.parseByte());
      }
    }
  }
}
function transformPoints(points, transform) {
  var newPoints = [];
  for (var i = 0; i < points.length; i += 1) {
    var pt = points[i];
    var newPt = {
      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
      onCurve: pt.onCurve,
      lastPointOfContour: pt.lastPointOfContour
    };
    newPoints.push(newPt);
  }
  return newPoints;
}
function getContours(points) {
  var contours = [];
  var currentContour = [];
  for (var i = 0; i < points.length; i += 1) {
    var pt = points[i];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
}
function getPath(points) {
  var p = new Path();
  if (!points) {
    return p;
  }
  var contours = getContours(points);
  for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
    var contour = contours[contourIndex];
    var curr = contour[contour.length - 1];
    var next = contour[0];
    if (curr.onCurve) {
      p.moveTo(curr.x, curr.y);
    } else {
      if (next.onCurve) {
        p.moveTo(next.x, next.y);
      } else {
        var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        p.moveTo(start.x, start.y);
      }
    }
    for (var i = 0; i < contour.length; ++i) {
      curr = next;
      next = contour[(i + 1) % contour.length];
      if (curr.onCurve) {
        p.lineTo(curr.x, curr.y);
      } else {
        var next2 = next;
        if (!next.onCurve) {
          next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        }
        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
      }
    }
    p.closePath();
  }
  return p;
}
function buildPath(glyphs, glyph) {
  if (glyph.isComposite) {
    for (var j = 0; j < glyph.components.length; j += 1) {
      var component = glyph.components[j];
      var componentGlyph = glyphs.get(component.glyphIndex);
      componentGlyph.getPath();
      if (componentGlyph.points) {
        var transformedPoints = void 0;
        if (component.matchedPoints === void 0) {
          transformedPoints = transformPoints(componentGlyph.points, component);
        } else {
          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
            throw Error("Matched points out of range in " + glyph.name);
          }
          var firstPt = glyph.points[component.matchedPoints[0]];
          var secondPt = componentGlyph.points[component.matchedPoints[1]];
          var transform = {
            xScale: component.xScale,
            scale01: component.scale01,
            scale10: component.scale10,
            yScale: component.yScale,
            dx: 0,
            dy: 0
          };
          secondPt = transformPoints([secondPt], transform)[0];
          transform.dx = firstPt.x - secondPt.x;
          transform.dy = firstPt.y - secondPt.y;
          transformedPoints = transformPoints(componentGlyph.points, transform);
        }
        glyph.points = glyph.points.concat(transformedPoints);
      }
    }
  }
  return getPath(glyph.points);
}
function parseGlyfTableAll(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  for (var i = 0; i < loca2.length - 1; i += 1) {
    var offset = loca2[i];
    var nextOffset = loca2[i + 1];
    if (offset !== nextOffset) {
      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i, glyphset.glyphLoader(font, i));
    }
  }
  return glyphs;
}
function parseGlyfTableOnLowMemory(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  font._push = function(i) {
    var offset = loca2[i];
    var nextOffset = loca2[i + 1];
    if (offset !== nextOffset) {
      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i, glyphset.glyphLoader(font, i));
    }
  };
  return glyphs;
}
function parseGlyfTable(data, start, loca2, font, opt) {
  if (opt.lowMemory) {
    return parseGlyfTableOnLowMemory(data, start, loca2, font);
  } else {
    return parseGlyfTableAll(data, start, loca2, font);
  }
}
var glyf = { getPath, parse: parseGlyfTable };
var instructionTable;
var exec;
var execGlyph;
var execComponent;
function Hinting(font) {
  this.font = font;
  this.getCommands = function(hPoints) {
    return glyf.getPath(hPoints).commands;
  };
  this._fpgmState = this._prepState = void 0;
  this._errorState = 0;
}
function roundOff(v) {
  return v;
}
function roundToGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v));
}
function roundToDoubleGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
function roundToHalfGrid(v) {
  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
function roundUpToGrid(v) {
  return Math.sign(v) * Math.ceil(Math.abs(v));
}
function roundDownToGrid(v) {
  return Math.sign(v) * Math.floor(Math.abs(v));
}
var roundSuper = function(v) {
  var period = this.srPeriod;
  var phase = this.srPhase;
  var threshold = this.srThreshold;
  var sign = 1;
  if (v < 0) {
    v = -v;
    sign = -1;
  }
  v += threshold - phase;
  v = Math.trunc(v / period) * period;
  v += phase;
  if (v < 0) {
    return phase * sign;
  }
  return v * sign;
};
var xUnitVector = {
  x: 1,
  y: 0,
  axis: "x",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.xo - rp1.xo;
      do2 = p.xo - rp2.xo;
      dm1 = rp1.x - rp1.xo;
      dm2 = rp2.x - rp2.xo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.x = p.xo + (dm1 + dm2) / 2;
        return;
      }
      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this
  normalSlope: Number.NEGATIVE_INFINITY,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'.
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.x = (org ? rp.xo : rp.x) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
  },
  // Slope of vector line.
  slope: 0,
  // Touches the point p.
  touch: function(p) {
    p.xTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.xTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.xTouched = false;
  }
};
var yUnitVector = {
  x: 0,
  y: 1,
  axis: "y",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.yo - rp1.yo;
      do2 = p.yo - rp2.yo;
      dm1 = rp1.y - rp1.yo;
      dm2 = rp2.y - rp2.yo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.y = p.yo + (dm1 + dm2) / 2;
        return;
      }
      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this.
  normalSlope: 0,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.y = (org ? rp.yo : rp.y) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.y = rpdy + pv.normalSlope * (p.x - rpdx);
  },
  // Slope of vector line.
  slope: Number.POSITIVE_INFINITY,
  // Touches the point p.
  touch: function(p) {
    p.yTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.yTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.yTouched = false;
  }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
function UnitVector(x, y) {
  this.x = x;
  this.y = y;
  this.axis = void 0;
  this.slope = y / x;
  this.normalSlope = -x / y;
  Object.freeze(this);
}
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
  var dm1;
  var dm2;
  var do1;
  var do2;
  var doa1;
  var doa2;
  var dt;
  do1 = pv.distance(p, rp1, true, true);
  do2 = pv.distance(p, rp2, true, true);
  dm1 = pv.distance(rp1, rp1, false, true);
  dm2 = pv.distance(rp2, rp2, false, true);
  doa1 = Math.abs(do1);
  doa2 = Math.abs(do2);
  dt = doa1 + doa2;
  if (dt === 0) {
    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
    return;
  }
  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
  pv = pv || this;
  var rpx = org ? rp.xo : rp.x;
  var rpy = org ? rp.yo : rp.y;
  var rpdx = rpx + d * pv.x;
  var rpdy = rpy + d * pv.y;
  var pvns = pv.normalSlope;
  var fvs = this.slope;
  var px = p.x;
  var py = p.y;
  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
  p.y = fvs * (p.x - px) + py;
};
UnitVector.prototype.touch = function(p) {
  p.xTouched = true;
  p.yTouched = true;
};
function getUnitVector(x, y) {
  var d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  if (x === 1 && y === 0) {
    return xUnitVector;
  } else if (x === 0 && y === 1) {
    return yUnitVector;
  } else {
    return new UnitVector(x, y);
  }
}
function HPoint(x, y, lastPointOfContour, onCurve) {
  this.x = this.xo = Math.round(x * 64) / 64;
  this.y = this.yo = Math.round(y * 64) / 64;
  this.lastPointOfContour = lastPointOfContour;
  this.onCurve = onCurve;
  this.prevPointOnContour = void 0;
  this.nextPointOnContour = void 0;
  this.xTouched = false;
  this.yTouched = false;
  Object.preventExtensions(this);
}
HPoint.prototype.nextTouched = function(v) {
  var p = this.nextPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.nextPointOnContour;
  }
  return p;
};
HPoint.prototype.prevTouched = function(v) {
  var p = this.prevPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.prevPointOnContour;
  }
  return p;
};
var HPZero = Object.freeze(new HPoint(0, 0));
var defaultState = {
  cvCutIn: 17 / 16,
  // control value cut in
  deltaBase: 9,
  deltaShift: 0.125,
  loop: 1,
  // loops some instructions
  minDis: 1,
  // minimum distance
  autoFlip: true
};
function State(env, prog) {
  this.env = env;
  this.stack = [];
  this.prog = prog;
  switch (env) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1;
      this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = xUnitVector;
      this.round = roundToGrid;
  }
}
Hinting.prototype.exec = function(glyph, ppem) {
  if (typeof ppem !== "number") {
    throw new Error("Point size is not a number!");
  }
  if (this._errorState > 2) {
    return;
  }
  var font = this.font;
  var prepState = this._prepState;
  if (!prepState || prepState.ppem !== ppem) {
    var fpgmState = this._fpgmState;
    if (!fpgmState) {
      State.prototype = defaultState;
      fpgmState = this._fpgmState = new State("fpgm", font.tables.fpgm);
      fpgmState.funcs = [];
      fpgmState.font = font;
      if (exports.DEBUG) {
        console.log("---EXEC FPGM---");
        fpgmState.step = -1;
      }
      try {
        exec(fpgmState);
      } catch (e) {
        console.log("Hinting error in FPGM:" + e);
        this._errorState = 3;
        return;
      }
    }
    State.prototype = fpgmState;
    prepState = this._prepState = new State("prep", font.tables.prep);
    prepState.ppem = ppem;
    var oCvt = font.tables.cvt;
    if (oCvt) {
      var cvt = prepState.cvt = new Array(oCvt.length);
      var scale = ppem / font.unitsPerEm;
      for (var c = 0; c < oCvt.length; c++) {
        cvt[c] = oCvt[c] * scale;
      }
    } else {
      prepState.cvt = [];
    }
    if (exports.DEBUG) {
      console.log("---EXEC PREP---");
      prepState.step = -1;
    }
    try {
      exec(prepState);
    } catch (e) {
      if (this._errorState < 2) {
        console.log("Hinting error in PREP:" + e);
      }
      this._errorState = 2;
    }
  }
  if (this._errorState > 1) {
    return;
  }
  try {
    return execGlyph(glyph, prepState);
  } catch (e) {
    if (this._errorState < 1) {
      console.log("Hinting error:" + e);
      console.log("Note: further hinting errors are silenced");
    }
    this._errorState = 1;
    return void 0;
  }
};
execGlyph = function(glyph, prepState) {
  var xScale = prepState.ppem / prepState.font.unitsPerEm;
  var yScale = xScale;
  var components = glyph.components;
  var contours;
  var gZone;
  var state;
  State.prototype = prepState;
  if (!components) {
    state = new State("glyf", glyph.instructions);
    if (exports.DEBUG) {
      console.log("---EXEC GLYPH---");
      state.step = -1;
    }
    execComponent(glyph, state, xScale, yScale);
    gZone = state.gZone;
  } else {
    var font = prepState.font;
    gZone = [];
    contours = [];
    for (var i = 0; i < components.length; i++) {
      var c = components[i];
      var cg = font.glyphs.get(c.glyphIndex);
      state = new State("glyf", cg.instructions);
      if (exports.DEBUG) {
        console.log("---EXEC COMP " + i + "---");
        state.step = -1;
      }
      execComponent(cg, state, xScale, yScale);
      var dx = Math.round(c.dx * xScale);
      var dy = Math.round(c.dy * yScale);
      var gz = state.gZone;
      var cc = state.contours;
      for (var pi = 0; pi < gz.length; pi++) {
        var p = gz[pi];
        p.xTouched = p.yTouched = false;
        p.xo = p.x = p.x + dx;
        p.yo = p.y = p.y + dy;
      }
      var gLen = gZone.length;
      gZone.push.apply(gZone, gz);
      for (var j = 0; j < cc.length; j++) {
        contours.push(cc[j] + gLen);
      }
    }
    if (glyph.instructions && !state.inhibitGridFit) {
      state = new State("glyf", glyph.instructions);
      state.gZone = state.z0 = state.z1 = state.z2 = gZone;
      state.contours = contours;
      gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
      );
      if (exports.DEBUG) {
        console.log("---EXEC COMPOSITE---");
        state.step = -1;
      }
      exec(state);
      gZone.length -= 2;
    }
  }
  return gZone;
};
execComponent = function(glyph, state, xScale, yScale) {
  var points = glyph.points || [];
  var pLen = points.length;
  var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
  var contours = state.contours = [];
  var cp;
  for (var i = 0; i < pLen; i++) {
    cp = points[i];
    gZone[i] = new HPoint(
      cp.x * xScale,
      cp.y * yScale,
      cp.lastPointOfContour,
      cp.onCurve
    );
  }
  var sp;
  var np;
  for (var i$1 = 0; i$1 < pLen; i$1++) {
    cp = gZone[i$1];
    if (!sp) {
      sp = cp;
      contours.push(i$1);
    }
    if (cp.lastPointOfContour) {
      cp.nextPointOnContour = sp;
      sp.prevPointOnContour = cp;
      sp = void 0;
    } else {
      np = gZone[i$1 + 1];
      cp.nextPointOnContour = np;
      np.prevPointOnContour = cp;
    }
  }
  if (state.inhibitGridFit) {
    return;
  }
  if (exports.DEBUG) {
    console.log("PROCESSING GLYPH", state.stack);
    for (var i$2 = 0; i$2 < pLen; i$2++) {
      console.log(i$2, gZone[i$2].x, gZone[i$2].y);
    }
  }
  gZone.push(
    new HPoint(0, 0),
    new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  );
  exec(state);
  gZone.length -= 2;
  if (exports.DEBUG) {
    console.log("FINISHED GLYPH", state.stack);
    for (var i$3 = 0; i$3 < pLen; i$3++) {
      console.log(i$3, gZone[i$3].x, gZone[i$3].y);
    }
  }
};
exec = function(state) {
  var prog = state.prog;
  if (!prog) {
    return;
  }
  var pLen = prog.length;
  var ins;
  for (state.ip = 0; state.ip < pLen; state.ip++) {
    if (exports.DEBUG) {
      state.step++;
    }
    ins = instructionTable[prog[state.ip]];
    if (!ins) {
      throw new Error(
        "unknown instruction: 0x" + Number(prog[state.ip]).toString(16)
      );
    }
    ins(state);
  }
};
function initTZone(state) {
  var tZone = state.tZone = new Array(state.gZone.length);
  for (var i = 0; i < tZone.length; i++) {
    tZone[i] = new HPoint(0, 0);
  }
}
function skip(state, handleElse) {
  var prog = state.prog;
  var ip = state.ip;
  var nesting = 1;
  var ins;
  do {
    ins = prog[++ip];
    if (ins === 88) {
      nesting++;
    } else if (ins === 89) {
      nesting--;
    } else if (ins === 64) {
      ip += prog[ip + 1] + 1;
    } else if (ins === 65) {
      ip += 2 * prog[ip + 1] + 1;
    } else if (ins >= 176 && ins <= 183) {
      ip += ins - 176 + 1;
    } else if (ins >= 184 && ins <= 191) {
      ip += (ins - 184 + 1) * 2;
    } else if (handleElse && nesting === 1 && ins === 27) {
      break;
    }
  } while (nesting > 0);
  state.ip = ip;
}
function SVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SVTCA[" + v.axis + "]");
  }
  state.fv = state.pv = state.dpv = v;
}
function SPVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SPVTCA[" + v.axis + "]");
  }
  state.pv = state.dpv = v;
}
function SFVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SFVTCA[" + v.axis + "]");
  }
  state.fv = v;
}
function SPVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SPVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.pv = state.dpv = getUnitVector(dx, dy);
}
function SFVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SFVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.fv = getUnitVector(dx, dy);
}
function SPVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.pv = state.dpv = getUnitVector(x, y);
}
function SFVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.fv = getUnitVector(x, y);
}
function GPV(state) {
  var stack = state.stack;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "GPV[]");
  }
  stack.push(pv.x * 16384);
  stack.push(pv.y * 16384);
}
function GFV(state) {
  var stack = state.stack;
  var fv = state.fv;
  if (exports.DEBUG) {
    console.log(state.step, "GFV[]");
  }
  stack.push(fv.x * 16384);
  stack.push(fv.y * 16384);
}
function SFVTPV(state) {
  state.fv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "SFVTPV[]");
  }
}
function ISECT(state) {
  var stack = state.stack;
  var pa0i = stack.pop();
  var pa1i = stack.pop();
  var pb0i = stack.pop();
  var pb1i = stack.pop();
  var pi = stack.pop();
  var z0 = state.z0;
  var z1 = state.z1;
  var pa0 = z0[pa0i];
  var pa1 = z0[pa1i];
  var pb0 = z1[pb0i];
  var pb1 = z1[pb1i];
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log("ISECT[], ", pa0i, pa1i, pb0i, pb1i, pi);
  }
  var x1 = pa0.x;
  var y1 = pa0.y;
  var x2 = pa1.x;
  var y2 = pa1.y;
  var x3 = pb0.x;
  var y3 = pb0.y;
  var x4 = pb1.x;
  var y4 = pb1.y;
  var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  var f1 = x1 * y2 - y1 * x2;
  var f2 = x3 * y4 - y3 * x4;
  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}
function SRP0(state) {
  state.rp0 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP0[]", state.rp0);
  }
}
function SRP1(state) {
  state.rp1 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP1[]", state.rp1);
  }
}
function SRP2(state) {
  state.rp2 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP2[]", state.rp2);
  }
}
function SZP0(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP0[]", n);
  }
  state.zp0 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.tZone;
      break;
    case 1:
      state.z0 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP1(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP1[]", n);
  }
  state.zp1 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z1 = state.tZone;
      break;
    case 1:
      state.z1 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP2(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP2[]", n);
  }
  state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z2 = state.tZone;
      break;
    case 1:
      state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZPS(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZPS[]", n);
  }
  state.zp0 = state.zp1 = state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.z1 = state.z2 = state.tZone;
      break;
    case 1:
      state.z0 = state.z1 = state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SLOOP(state) {
  state.loop = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SLOOP[]", state.loop);
  }
}
function RTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTG[]");
  }
  state.round = roundToGrid;
}
function RTHG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTHG[]");
  }
  state.round = roundToHalfGrid;
}
function SMD(state) {
  var d = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SMD[]", d);
  }
  state.minDis = d / 64;
}
function ELSE(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ELSE[]");
  }
  skip(state, false);
}
function JMPR(state) {
  var o = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "JMPR[]", o);
  }
  state.ip += o - 1;
}
function SCVTCI(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCVTCI[]", n);
  }
  state.cvCutIn = n / 64;
}
function DUP(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DUP[]");
  }
  stack.push(stack[stack.length - 1]);
}
function POP(state) {
  if (exports.DEBUG) {
    console.log(state.step, "POP[]");
  }
  state.stack.pop();
}
function CLEAR(state) {
  if (exports.DEBUG) {
    console.log(state.step, "CLEAR[]");
  }
  state.stack.length = 0;
}
function SWAP(state) {
  var stack = state.stack;
  var a = stack.pop();
  var b = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SWAP[]");
  }
  stack.push(a);
  stack.push(b);
}
function DEPTH(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DEPTH[]");
  }
  stack.push(stack.length);
}
function LOOPCALL(state) {
  var stack = state.stack;
  var fn = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LOOPCALL[]", fn, c);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  for (var i = 0; i < c; i++) {
    exec(state);
    if (exports.DEBUG) {
      console.log(
        ++state.step,
        i + 1 < c ? "next loopcall" : "done loopcall",
        i
      );
    }
  }
  state.ip = cip;
  state.prog = cprog;
}
function CALL(state) {
  var fn = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CALL[]", fn);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  exec(state);
  state.ip = cip;
  state.prog = cprog;
  if (exports.DEBUG) {
    console.log(++state.step, "returning from", fn);
  }
}
function CINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CINDEX[]", k);
  }
  stack.push(stack[stack.length - k]);
}
function MINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MINDEX[]", k);
  }
  stack.push(stack.splice(stack.length - k, 1)[0]);
}
function FDEF(state) {
  if (state.env !== "fpgm") {
    throw new Error("FDEF not allowed here");
  }
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  var fn = stack.pop();
  var ipBegin = ip;
  if (exports.DEBUG) {
    console.log(state.step, "FDEF[]", fn);
  }
  while (prog[++ip] !== 45) {
  }
  state.ip = ip;
  state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
function MDAP(round, state) {
  var pi = state.stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "MDAP[" + round + "]", pi);
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function IUP(v, state) {
  var z2 = state.z2;
  var pLen = z2.length - 2;
  var cp;
  var pp;
  var np;
  if (exports.DEBUG) {
    console.log(state.step, "IUP[" + v.axis + "]");
  }
  for (var i = 0; i < pLen; i++) {
    cp = z2[i];
    if (v.touched(cp)) {
      continue;
    }
    pp = cp.prevTouched(v);
    if (pp === cp) {
      continue;
    }
    np = cp.nextTouched(v);
    if (pp === np) {
      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
    }
    v.interpolate(cp, pp, np, v);
  }
}
function SHP(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var loop = state.loop;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    var d = pv.distance(rp, rp, false, true);
    fv.setRelative(p, p, d, pv);
    fv.touch(p);
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHP[" + (a ? "rp1" : "rp2") + "]",
        pi
      );
    }
  }
  state.loop = 1;
}
function SHC(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var ci = stack.pop();
  var sp = state.z2[state.contours[ci]];
  var p = sp;
  if (exports.DEBUG) {
    console.log(state.step, "SHC[" + a + "]", ci);
  }
  var d = pv.distance(rp, rp, false, true);
  do {
    if (p !== rp) {
      fv.setRelative(p, p, d, pv);
    }
    p = p.nextPointOnContour;
  } while (p !== sp);
}
function SHZ(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SHZ[" + a + "]", e);
  }
  var z;
  switch (e) {
    case 0:
      z = state.tZone;
      break;
    case 1:
      z = state.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  var p;
  var d = pv.distance(rp, rp, false, true);
  var pLen = z.length - 2;
  for (var i = 0; i < pLen; i++) {
    p = z[i];
    fv.setRelative(p, p, d, pv);
  }
}
function SHPIX(state) {
  var stack = state.stack;
  var loop = state.loop;
  var fv = state.fv;
  var d = stack.pop() / 64;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHPIX[]",
        pi,
        d
      );
    }
    fv.setRelative(p, p, d);
    fv.touch(p);
  }
  state.loop = 1;
}
function IP(state) {
  var stack = state.stack;
  var rp1i = state.rp1;
  var rp2i = state.rp2;
  var loop = state.loop;
  var rp1 = state.z0[rp1i];
  var rp2 = state.z1[rp2i];
  var fv = state.fv;
  var pv = state.dpv;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "IP[]",
        pi,
        rp1i,
        "<->",
        rp2i
      );
    }
    fv.interpolate(p, rp1, rp2, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function MSIRP(a, state) {
  var stack = state.stack;
  var d = stack.pop() / 64;
  var pi = stack.pop();
  var p = state.z1[pi];
  var rp0 = state.z0[state.rp0];
  var fv = state.fv;
  var pv = state.pv;
  fv.setRelative(p, rp0, d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(state.step, "MSIRP[" + a + "]", d, pi);
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (a) {
    state.rp0 = pi;
  }
}
function ALIGNRP(state) {
  var stack = state.stack;
  var rp0i = state.rp0;
  var rp0 = state.z0[rp0i];
  var loop = state.loop;
  var fv = state.fv;
  var pv = state.pv;
  var z1 = state.z1;
  while (loop--) {
    var pi = stack.pop();
    var p = z1[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "ALIGNRP[]",
        pi
      );
    }
    fv.setRelative(p, rp0, 0, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function RTDG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTDG[]");
  }
  state.round = roundToDoubleGrid;
}
function MIAP(round, state) {
  var stack = state.stack;
  var n = stack.pop();
  var pi = stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  var cv = state.cvt[n];
  if (exports.DEBUG) {
    console.log(
      state.step,
      "MIAP[" + round + "]",
      n,
      "(",
      cv,
      ")",
      pi
    );
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    if (Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  if (state.zp0 === 0) {
    p.xo = p.x;
    p.yo = p.y;
  }
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function NPUSHB(state) {
  var prog = state.prog;
  var ip = state.ip;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHB[]", n);
  }
  for (var i = 0; i < n; i++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function NPUSHW(state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHW[]", n);
  }
  for (var i = 0; i < n; i++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function WS(state) {
  var stack = state.stack;
  var store = state.store;
  if (!store) {
    store = state.store = [];
  }
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WS", v, l);
  }
  store[l] = v;
}
function RS(state) {
  var stack = state.stack;
  var store = state.store;
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RS", l);
  }
  var v = store && store[l] || 0;
  stack.push(v);
}
function WCVTP(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTP", v, l);
  }
  state.cvt[l] = v / 64;
}
function RCVT(state) {
  var stack = state.stack;
  var cvte = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RCVT", cvte);
  }
  stack.push(state.cvt[cvte] * 64);
}
function GC(a, state) {
  var stack = state.stack;
  var pi = stack.pop();
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log(state.step, "GC[" + a + "]", pi);
  }
  stack.push(state.dpv.distance(p, HPZero, a, false) * 64);
}
function MD(a, state) {
  var stack = state.stack;
  var pi2 = stack.pop();
  var pi1 = stack.pop();
  var p2 = state.z1[pi2];
  var p1 = state.z0[pi1];
  var d = state.dpv.distance(p1, p2, a, a);
  if (exports.DEBUG) {
    console.log(state.step, "MD[" + a + "]", pi2, pi1, "->", d);
  }
  state.stack.push(Math.round(d * 64));
}
function MPPEM(state) {
  if (exports.DEBUG) {
    console.log(state.step, "MPPEM[]");
  }
  state.stack.push(state.ppem);
}
function FLIPON(state) {
  if (exports.DEBUG) {
    console.log(state.step, "FLIPON[]");
  }
  state.autoFlip = true;
}
function LT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LT[]", e2, e1);
  }
  stack.push(e1 < e2 ? 1 : 0);
}
function LTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LTEQ[]", e2, e1);
  }
  stack.push(e1 <= e2 ? 1 : 0);
}
function GT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GT[]", e2, e1);
  }
  stack.push(e1 > e2 ? 1 : 0);
}
function GTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GTEQ[]", e2, e1);
  }
  stack.push(e1 >= e2 ? 1 : 0);
}
function EQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EQ[]", e2, e1);
  }
  stack.push(e2 === e1 ? 1 : 0);
}
function NEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEQ[]", e2, e1);
  }
  stack.push(e2 !== e1 ? 1 : 0);
}
function ODD(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ODD[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
function EVEN(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EVEN[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
function IF(state) {
  var test = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "IF[]", test);
  }
  if (!test) {
    skip(state, true);
    if (exports.DEBUG) {
      console.log(state.step, "EIF[]");
    }
  }
}
function EIF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "EIF[]");
  }
}
function AND(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "AND[]", e2, e1);
  }
  stack.push(e2 && e1 ? 1 : 0);
}
function OR(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "OR[]", e2, e1);
  }
  stack.push(e2 || e1 ? 1 : 0);
}
function NOT(state) {
  var stack = state.stack;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NOT[]", e);
  }
  stack.push(e ? 0 : 1);
}
function DELTAP123(b, state) {
  var stack = state.stack;
  var n = stack.pop();
  var fv = state.fv;
  var pv = state.pv;
  var ppem = state.ppem;
  var base = state.deltaBase + (b - 1) * 16;
  var ds = state.deltaShift;
  var z0 = state.z0;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAP[" + b + "]", n, stack);
  }
  for (var i = 0; i < n; i++) {
    var pi = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    if (exports.DEBUG) {
      console.log(state.step, "DELTAPFIX", pi, "by", mag * ds);
    }
    var p = z0[pi];
    fv.setRelative(p, p, mag * ds, pv);
  }
}
function SDB(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDB[]", n);
  }
  state.deltaBase = n;
}
function SDS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDS[]", n);
  }
  state.deltaShift = Math.pow(0.5, n);
}
function ADD(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ADD[]", n2, n1);
  }
  stack.push(n1 + n2);
}
function SUB(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SUB[]", n2, n1);
  }
  stack.push(n1 - n2);
}
function DIV(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "DIV[]", n2, n1);
  }
  stack.push(n1 * 64 / n2);
}
function MUL(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MUL[]", n2, n1);
  }
  stack.push(n1 * n2 / 64);
}
function ABS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ABS[]", n);
  }
  stack.push(Math.abs(n));
}
function NEG(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEG[]", n);
  }
  stack.push(-n);
}
function FLOOR(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "FLOOR[]", n);
  }
  stack.push(Math.floor(n / 64) * 64);
}
function CEILING(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CEILING[]", n);
  }
  stack.push(Math.ceil(n / 64) * 64);
}
function ROUND(dt, state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROUND[]");
  }
  stack.push(state.round(n / 64) * 64);
}
function WCVTF(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTF[]", v, l);
  }
  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
function DELTAC123(b, state) {
  var stack = state.stack;
  var n = stack.pop();
  var ppem = state.ppem;
  var base = state.deltaBase + (b - 1) * 16;
  var ds = state.deltaShift;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAC[" + b + "]", n, stack);
  }
  for (var i = 0; i < n; i++) {
    var c = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    var delta = mag * ds;
    if (exports.DEBUG) {
      console.log(state.step, "DELTACFIX", c, "by", delta);
    }
    state.cvt[c] += delta;
  }
}
function SROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = 0.5;
      break;
    case 64:
      period = 1;
      break;
    case 128:
      period = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function S45ROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "S45ROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = Math.sqrt(2) / 2;
      break;
    case 64:
      period = Math.sqrt(2);
      break;
    case 128:
      period = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function ROFF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ROFF[]");
  }
  state.round = roundOff;
}
function RUTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RUTG[]");
  }
  state.round = roundUpToGrid;
}
function RDTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RDTG[]");
  }
  state.round = roundDownToGrid;
}
function SCANCTRL(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANCTRL[]", n);
  }
}
function SDPVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log(state.step, "SDPVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.dpv = getUnitVector(dx, dy);
}
function GETINFO(state) {
  var stack = state.stack;
  var sel = stack.pop();
  var r = 0;
  if (exports.DEBUG) {
    console.log(state.step, "GETINFO[]", sel);
  }
  if (sel & 1) {
    r = 35;
  }
  if (sel & 32) {
    r |= 4096;
  }
  stack.push(r);
}
function ROLL(state) {
  var stack = state.stack;
  var a = stack.pop();
  var b = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROLL[]");
  }
  stack.push(b);
  stack.push(a);
  stack.push(c);
}
function MAX(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MAX[]", e2, e1);
  }
  stack.push(Math.max(e1, e2));
}
function MIN(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MIN[]", e2, e1);
  }
  stack.push(Math.min(e1, e2));
}
function SCANTYPE(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANTYPE[]", n);
  }
}
function INSTCTRL(state) {
  var s = state.stack.pop();
  var v = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "INSTCTRL[]", s, v);
  }
  switch (s) {
    case 1:
      state.inhibitGridFit = !!v;
      return;
    case 2:
      state.ignoreCvt = !!v;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function PUSHB(n, state) {
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  if (exports.DEBUG) {
    console.log(state.step, "PUSHB[" + n + "]");
  }
  for (var i = 0; i < n; i++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function PUSHW(n, state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.ip, "PUSHW[" + n + "]");
  }
  for (var i = 0; i < n; i++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
  var stack = state.stack;
  var cvte = indirect && stack.pop();
  var pi = stack.pop();
  var rp0i = state.rp0;
  var rp = state.z0[rp0i];
  var p = state.z1[pi];
  var md = state.minDis;
  var fv = state.fv;
  var pv = state.dpv;
  var od;
  var d;
  var sign;
  var cv;
  d = od = pv.distance(p, rp, true, true);
  sign = d >= 0 ? 1 : -1;
  d = Math.abs(d);
  if (indirect) {
    cv = state.cvt[cvte];
    if (ro && Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
  }
  if (keepD && d < md) {
    d = md;
  }
  if (ro) {
    d = state.round(d);
  }
  fv.setRelative(p, rp, sign * d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(
      state.step,
      (indirect ? "MIRP[" : "MDRP[") + (setRp0 ? "M" : "m") + (keepD ? ">" : "_") + (ro ? "R" : "_") + (dt === 0 ? "Gr" : dt === 1 ? "Bl" : dt === 2 ? "Wh" : "") + "]",
      indirect ? cvte + "(" + state.cvt[cvte] + "," + cv + ")" : "",
      pi,
      "(d =",
      od,
      "->",
      sign * d,
      ")"
    );
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (setRp0) {
    state.rp0 = pi;
  }
}
instructionTable = [
  /* 0x00 */
  SVTCA.bind(void 0, yUnitVector),
  /* 0x01 */
  SVTCA.bind(void 0, xUnitVector),
  /* 0x02 */
  SPVTCA.bind(void 0, yUnitVector),
  /* 0x03 */
  SPVTCA.bind(void 0, xUnitVector),
  /* 0x04 */
  SFVTCA.bind(void 0, yUnitVector),
  /* 0x05 */
  SFVTCA.bind(void 0, xUnitVector),
  /* 0x06 */
  SPVTL.bind(void 0, 0),
  /* 0x07 */
  SPVTL.bind(void 0, 1),
  /* 0x08 */
  SFVTL.bind(void 0, 0),
  /* 0x09 */
  SFVTL.bind(void 0, 1),
  /* 0x0A */
  SPVFS,
  /* 0x0B */
  SFVFS,
  /* 0x0C */
  GPV,
  /* 0x0D */
  GFV,
  /* 0x0E */
  SFVTPV,
  /* 0x0F */
  ISECT,
  /* 0x10 */
  SRP0,
  /* 0x11 */
  SRP1,
  /* 0x12 */
  SRP2,
  /* 0x13 */
  SZP0,
  /* 0x14 */
  SZP1,
  /* 0x15 */
  SZP2,
  /* 0x16 */
  SZPS,
  /* 0x17 */
  SLOOP,
  /* 0x18 */
  RTG,
  /* 0x19 */
  RTHG,
  /* 0x1A */
  SMD,
  /* 0x1B */
  ELSE,
  /* 0x1C */
  JMPR,
  /* 0x1D */
  SCVTCI,
  /* 0x1E */
  void 0,
  // TODO SSWCI
  /* 0x1F */
  void 0,
  // TODO SSW
  /* 0x20 */
  DUP,
  /* 0x21 */
  POP,
  /* 0x22 */
  CLEAR,
  /* 0x23 */
  SWAP,
  /* 0x24 */
  DEPTH,
  /* 0x25 */
  CINDEX,
  /* 0x26 */
  MINDEX,
  /* 0x27 */
  void 0,
  // TODO ALIGNPTS
  /* 0x28 */
  void 0,
  /* 0x29 */
  void 0,
  // TODO UTP
  /* 0x2A */
  LOOPCALL,
  /* 0x2B */
  CALL,
  /* 0x2C */
  FDEF,
  /* 0x2D */
  void 0,
  // ENDF (eaten by FDEF)
  /* 0x2E */
  MDAP.bind(void 0, 0),
  /* 0x2F */
  MDAP.bind(void 0, 1),
  /* 0x30 */
  IUP.bind(void 0, yUnitVector),
  /* 0x31 */
  IUP.bind(void 0, xUnitVector),
  /* 0x32 */
  SHP.bind(void 0, 0),
  /* 0x33 */
  SHP.bind(void 0, 1),
  /* 0x34 */
  SHC.bind(void 0, 0),
  /* 0x35 */
  SHC.bind(void 0, 1),
  /* 0x36 */
  SHZ.bind(void 0, 0),
  /* 0x37 */
  SHZ.bind(void 0, 1),
  /* 0x38 */
  SHPIX,
  /* 0x39 */
  IP,
  /* 0x3A */
  MSIRP.bind(void 0, 0),
  /* 0x3B */
  MSIRP.bind(void 0, 1),
  /* 0x3C */
  ALIGNRP,
  /* 0x3D */
  RTDG,
  /* 0x3E */
  MIAP.bind(void 0, 0),
  /* 0x3F */
  MIAP.bind(void 0, 1),
  /* 0x40 */
  NPUSHB,
  /* 0x41 */
  NPUSHW,
  /* 0x42 */
  WS,
  /* 0x43 */
  RS,
  /* 0x44 */
  WCVTP,
  /* 0x45 */
  RCVT,
  /* 0x46 */
  GC.bind(void 0, 0),
  /* 0x47 */
  GC.bind(void 0, 1),
  /* 0x48 */
  void 0,
  // TODO SCFS
  /* 0x49 */
  MD.bind(void 0, 0),
  /* 0x4A */
  MD.bind(void 0, 1),
  /* 0x4B */
  MPPEM,
  /* 0x4C */
  void 0,
  // TODO MPS
  /* 0x4D */
  FLIPON,
  /* 0x4E */
  void 0,
  // TODO FLIPOFF
  /* 0x4F */
  void 0,
  // TODO DEBUG
  /* 0x50 */
  LT,
  /* 0x51 */
  LTEQ,
  /* 0x52 */
  GT,
  /* 0x53 */
  GTEQ,
  /* 0x54 */
  EQ,
  /* 0x55 */
  NEQ,
  /* 0x56 */
  ODD,
  /* 0x57 */
  EVEN,
  /* 0x58 */
  IF,
  /* 0x59 */
  EIF,
  /* 0x5A */
  AND,
  /* 0x5B */
  OR,
  /* 0x5C */
  NOT,
  /* 0x5D */
  DELTAP123.bind(void 0, 1),
  /* 0x5E */
  SDB,
  /* 0x5F */
  SDS,
  /* 0x60 */
  ADD,
  /* 0x61 */
  SUB,
  /* 0x62 */
  DIV,
  /* 0x63 */
  MUL,
  /* 0x64 */
  ABS,
  /* 0x65 */
  NEG,
  /* 0x66 */
  FLOOR,
  /* 0x67 */
  CEILING,
  /* 0x68 */
  ROUND.bind(void 0, 0),
  /* 0x69 */
  ROUND.bind(void 0, 1),
  /* 0x6A */
  ROUND.bind(void 0, 2),
  /* 0x6B */
  ROUND.bind(void 0, 3),
  /* 0x6C */
  void 0,
  // TODO NROUND[ab]
  /* 0x6D */
  void 0,
  // TODO NROUND[ab]
  /* 0x6E */
  void 0,
  // TODO NROUND[ab]
  /* 0x6F */
  void 0,
  // TODO NROUND[ab]
  /* 0x70 */
  WCVTF,
  /* 0x71 */
  DELTAP123.bind(void 0, 2),
  /* 0x72 */
  DELTAP123.bind(void 0, 3),
  /* 0x73 */
  DELTAC123.bind(void 0, 1),
  /* 0x74 */
  DELTAC123.bind(void 0, 2),
  /* 0x75 */
  DELTAC123.bind(void 0, 3),
  /* 0x76 */
  SROUND,
  /* 0x77 */
  S45ROUND,
  /* 0x78 */
  void 0,
  // TODO JROT[]
  /* 0x79 */
  void 0,
  // TODO JROF[]
  /* 0x7A */
  ROFF,
  /* 0x7B */
  void 0,
  /* 0x7C */
  RUTG,
  /* 0x7D */
  RDTG,
  /* 0x7E */
  POP,
  // actually SANGW, supposed to do only a pop though
  /* 0x7F */
  POP,
  // actually AA, supposed to do only a pop though
  /* 0x80 */
  void 0,
  // TODO FLIPPT
  /* 0x81 */
  void 0,
  // TODO FLIPRGON
  /* 0x82 */
  void 0,
  // TODO FLIPRGOFF
  /* 0x83 */
  void 0,
  /* 0x84 */
  void 0,
  /* 0x85 */
  SCANCTRL,
  /* 0x86 */
  SDPVTL.bind(void 0, 0),
  /* 0x87 */
  SDPVTL.bind(void 0, 1),
  /* 0x88 */
  GETINFO,
  /* 0x89 */
  void 0,
  // TODO IDEF
  /* 0x8A */
  ROLL,
  /* 0x8B */
  MAX,
  /* 0x8C */
  MIN,
  /* 0x8D */
  SCANTYPE,
  /* 0x8E */
  INSTCTRL,
  /* 0x8F */
  void 0,
  /* 0x90 */
  void 0,
  /* 0x91 */
  void 0,
  /* 0x92 */
  void 0,
  /* 0x93 */
  void 0,
  /* 0x94 */
  void 0,
  /* 0x95 */
  void 0,
  /* 0x96 */
  void 0,
  /* 0x97 */
  void 0,
  /* 0x98 */
  void 0,
  /* 0x99 */
  void 0,
  /* 0x9A */
  void 0,
  /* 0x9B */
  void 0,
  /* 0x9C */
  void 0,
  /* 0x9D */
  void 0,
  /* 0x9E */
  void 0,
  /* 0x9F */
  void 0,
  /* 0xA0 */
  void 0,
  /* 0xA1 */
  void 0,
  /* 0xA2 */
  void 0,
  /* 0xA3 */
  void 0,
  /* 0xA4 */
  void 0,
  /* 0xA5 */
  void 0,
  /* 0xA6 */
  void 0,
  /* 0xA7 */
  void 0,
  /* 0xA8 */
  void 0,
  /* 0xA9 */
  void 0,
  /* 0xAA */
  void 0,
  /* 0xAB */
  void 0,
  /* 0xAC */
  void 0,
  /* 0xAD */
  void 0,
  /* 0xAE */
  void 0,
  /* 0xAF */
  void 0,
  /* 0xB0 */
  PUSHB.bind(void 0, 1),
  /* 0xB1 */
  PUSHB.bind(void 0, 2),
  /* 0xB2 */
  PUSHB.bind(void 0, 3),
  /* 0xB3 */
  PUSHB.bind(void 0, 4),
  /* 0xB4 */
  PUSHB.bind(void 0, 5),
  /* 0xB5 */
  PUSHB.bind(void 0, 6),
  /* 0xB6 */
  PUSHB.bind(void 0, 7),
  /* 0xB7 */
  PUSHB.bind(void 0, 8),
  /* 0xB8 */
  PUSHW.bind(void 0, 1),
  /* 0xB9 */
  PUSHW.bind(void 0, 2),
  /* 0xBA */
  PUSHW.bind(void 0, 3),
  /* 0xBB */
  PUSHW.bind(void 0, 4),
  /* 0xBC */
  PUSHW.bind(void 0, 5),
  /* 0xBD */
  PUSHW.bind(void 0, 6),
  /* 0xBE */
  PUSHW.bind(void 0, 7),
  /* 0xBF */
  PUSHW.bind(void 0, 8),
  /* 0xC0 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 0),
  /* 0xC1 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 1),
  /* 0xC2 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 2),
  /* 0xC3 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 3),
  /* 0xC4 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 0),
  /* 0xC5 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 1),
  /* 0xC6 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 2),
  /* 0xC7 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 3),
  /* 0xC8 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 0),
  /* 0xC9 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 1),
  /* 0xCA */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 2),
  /* 0xCB */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 3),
  /* 0xCC */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 0),
  /* 0xCD */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 1),
  /* 0xCE */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 2),
  /* 0xCF */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 3),
  /* 0xD0 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 0),
  /* 0xD1 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 1),
  /* 0xD2 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 2),
  /* 0xD3 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 3),
  /* 0xD4 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 0),
  /* 0xD5 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 1),
  /* 0xD6 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 2),
  /* 0xD7 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 3),
  /* 0xD8 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 0),
  /* 0xD9 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 1),
  /* 0xDA */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 2),
  /* 0xDB */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 3),
  /* 0xDC */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 0),
  /* 0xDD */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 1),
  /* 0xDE */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 2),
  /* 0xDF */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 3),
  /* 0xE0 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 0),
  /* 0xE1 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 1),
  /* 0xE2 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 2),
  /* 0xE3 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 3),
  /* 0xE4 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 0),
  /* 0xE5 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 1),
  /* 0xE6 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 2),
  /* 0xE7 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 3),
  /* 0xE8 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 0),
  /* 0xE9 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 1),
  /* 0xEA */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 2),
  /* 0xEB */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 3),
  /* 0xEC */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 0),
  /* 0xED */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 1),
  /* 0xEE */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 2),
  /* 0xEF */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 3),
  /* 0xF0 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 0),
  /* 0xF1 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 1),
  /* 0xF2 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 2),
  /* 0xF3 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 3),
  /* 0xF4 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 0),
  /* 0xF5 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 1),
  /* 0xF6 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 2),
  /* 0xF7 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 3),
  /* 0xF8 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 0),
  /* 0xF9 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 1),
  /* 0xFA */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 2),
  /* 0xFB */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 3),
  /* 0xFC */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 0),
  /* 0xFD */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 1),
  /* 0xFE */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 2),
  /* 0xFF */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 3)
];
function Token(char) {
  this.char = char;
  this.state = {};
  this.activeState = null;
}
function ContextRange(startIndex, endOffset, contextName) {
  this.contextName = contextName;
  this.startIndex = startIndex;
  this.endOffset = endOffset;
}
function ContextChecker(contextName, checkStart, checkEnd) {
  this.contextName = contextName;
  this.openRange = null;
  this.ranges = [];
  this.checkStart = checkStart;
  this.checkEnd = checkEnd;
}
function ContextParams(context, currentIndex) {
  this.context = context;
  this.index = currentIndex;
  this.length = context.length;
  this.current = context[currentIndex];
  this.backtrack = context.slice(0, currentIndex);
  this.lookahead = context.slice(currentIndex + 1);
}
function Event(eventId) {
  this.eventId = eventId;
  this.subscribers = [];
}
function initializeCoreEvents(events) {
  var this$1$1 = this;
  var coreEvents = [
    "start",
    "end",
    "next",
    "newToken",
    "contextStart",
    "contextEnd",
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD",
    "updateContextsRanges"
  ];
  coreEvents.forEach(function(eventId) {
    Object.defineProperty(this$1$1.events, eventId, {
      value: new Event(eventId)
    });
  });
  if (!!events) {
    coreEvents.forEach(function(eventId) {
      var event = events[eventId];
      if (typeof event === "function") {
        this$1$1.events[eventId].subscribe(event);
      }
    });
  }
  var requiresContextUpdate = [
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD"
  ];
  requiresContextUpdate.forEach(function(eventId) {
    this$1$1.events[eventId].subscribe(
      this$1$1.updateContextsRanges
    );
  });
}
function Tokenizer(events) {
  this.tokens = [];
  this.registeredContexts = {};
  this.contextCheckers = [];
  this.events = {};
  this.registeredModifiers = [];
  initializeCoreEvents.call(this, events);
}
Token.prototype.setState = function(key, value) {
  this.state[key] = value;
  this.activeState = { key, value: this.state[key] };
  return this.activeState;
};
Token.prototype.getState = function(stateId) {
  return this.state[stateId] || null;
};
Tokenizer.prototype.inboundIndex = function(index) {
  return index >= 0 && index < this.tokens.length;
};
Tokenizer.prototype.composeRUD = function(RUDs) {
  var this$1$1 = this;
  var silent = true;
  var state = RUDs.map(function(RUD) {
    return this$1$1[RUD[0]].apply(this$1$1, RUD.slice(1).concat(silent));
  });
  var hasFAILObject = function(obj) {
    return typeof obj === "object" && obj.hasOwnProperty("FAIL");
  };
  if (state.every(hasFAILObject)) {
    return {
      FAIL: "composeRUD: one or more operations hasn't completed successfully",
      report: state.filter(hasFAILObject)
    };
  }
  this.dispatch("composeRUD", [state.filter(function(op) {
    return !hasFAILObject(op);
  })]);
};
Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {
  offset = offset !== null ? offset : this.tokens.length;
  var isTokenType = tokens.every(function(token) {
    return token instanceof Token;
  });
  if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
    var replaced = this.tokens.splice.apply(
      this.tokens,
      [startIndex, offset].concat(tokens)
    );
    if (!silent) {
      this.dispatch("replaceToken", [startIndex, offset, tokens]);
    }
    return [replaced, tokens];
  } else {
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
  }
};
Tokenizer.prototype.replaceToken = function(index, token, silent) {
  if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
    var replaced = this.tokens.splice(index, 1, token);
    if (!silent) {
      this.dispatch("replaceToken", [index, token]);
    }
    return [replaced[0], token];
  } else {
    return { FAIL: "replaceToken: invalid token or index." };
  }
};
Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
  offset = !isNaN(offset) ? offset : this.tokens.length;
  var tokens = this.tokens.splice(startIndex, offset);
  if (!silent) {
    this.dispatch("removeRange", [tokens, startIndex, offset]);
  }
  return tokens;
};
Tokenizer.prototype.removeToken = function(index, silent) {
  if (!isNaN(index) && this.inboundIndex(index)) {
    var token = this.tokens.splice(index, 1);
    if (!silent) {
      this.dispatch("removeToken", [token, index]);
    }
    return token;
  } else {
    return { FAIL: "removeToken: invalid token index." };
  }
};
Tokenizer.prototype.insertToken = function(tokens, index, silent) {
  var tokenType = tokens.every(
    function(token) {
      return token instanceof Token;
    }
  );
  if (tokenType) {
    this.tokens.splice.apply(
      this.tokens,
      [index, 0].concat(tokens)
    );
    if (!silent) {
      this.dispatch("insertToken", [tokens, index]);
    }
    return tokens;
  } else {
    return { FAIL: "insertToken: invalid token(s)." };
  }
};
Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.events.newToken.subscribe(function(token, contextParams) {
    var conditionParams = [token, contextParams];
    var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;
    var modifierParams = [token, contextParams];
    if (canApplyModifier) {
      var newStateValue = modifier.apply(this, modifierParams);
      token.setState(modifierId, newStateValue);
    }
  });
  this.registeredModifiers.push(modifierId);
};
Event.prototype.subscribe = function(eventHandler) {
  if (typeof eventHandler === "function") {
    return this.subscribers.push(eventHandler) - 1;
  } else {
    return { FAIL: "invalid '" + this.eventId + "' event handler" };
  }
};
Event.prototype.unsubscribe = function(subsId) {
  this.subscribers.splice(subsId, 1);
};
ContextParams.prototype.setCurrentIndex = function(index) {
  this.index = index;
  this.current = this.context[index];
  this.backtrack = this.context.slice(0, index);
  this.lookahead = this.context.slice(index + 1);
};
ContextParams.prototype.get = function(offset) {
  switch (true) {
    case offset === 0:
      return this.current;
    case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
      return this.backtrack.slice(offset)[0];
    case (offset > 0 && offset <= this.lookahead.length):
      return this.lookahead[offset - 1];
    default:
      return null;
  }
};
Tokenizer.prototype.rangeToText = function(range) {
  if (range instanceof ContextRange) {
    return this.getRangeTokens(range).map(function(token) {
      return token.char;
    }).join("");
  }
};
Tokenizer.prototype.getText = function() {
  return this.tokens.map(function(token) {
    return token.char;
  }).join("");
};
Tokenizer.prototype.getContext = function(contextName) {
  var context = this.registeredContexts[contextName];
  return !!context ? context : null;
};
Tokenizer.prototype.on = function(eventName, eventHandler) {
  var event = this.events[eventName];
  if (!!event) {
    return event.subscribe(eventHandler);
  } else {
    return null;
  }
};
Tokenizer.prototype.dispatch = function(eventName, args) {
  var this$1$1 = this;
  var event = this.events[eventName];
  if (event instanceof Event) {
    event.subscribers.forEach(function(subscriber) {
      subscriber.apply(this$1$1, args || []);
    });
  }
};
Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
  if (!!this.getContext(contextName)) {
    return {
      FAIL: "context name '" + contextName + "' is already registered."
    };
  }
  if (typeof contextStartCheck !== "function") {
    return {
      FAIL: "missing context start check."
    };
  }
  if (typeof contextEndCheck !== "function") {
    return {
      FAIL: "missing context end check."
    };
  }
  var contextCheckers = new ContextChecker(
    contextName,
    contextStartCheck,
    contextEndCheck
  );
  this.registeredContexts[contextName] = contextCheckers;
  this.contextCheckers.push(contextCheckers);
  return contextCheckers;
};
Tokenizer.prototype.getRangeTokens = function(range) {
  var endIndex = range.startIndex + range.endOffset;
  return [].concat(
    this.tokens.slice(range.startIndex, endIndex)
  );
};
Tokenizer.prototype.getContextRanges = function(contextName) {
  var context = this.getContext(contextName);
  if (!!context) {
    return context.ranges;
  } else {
    return { FAIL: "context checker '" + contextName + "' is not registered." };
  }
};
Tokenizer.prototype.resetContextsRanges = function() {
  var registeredContexts = this.registeredContexts;
  for (var contextName in registeredContexts) {
    if (registeredContexts.hasOwnProperty(contextName)) {
      var context = registeredContexts[contextName];
      context.ranges = [];
    }
  }
};
Tokenizer.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  var chars = this.tokens.map(function(token) {
    return token.char;
  });
  for (var i = 0; i < chars.length; i++) {
    var contextParams = new ContextParams(chars, i);
    this.runContextCheck(contextParams);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Tokenizer.prototype.setEndOffset = function(offset, contextName) {
  var startIndex = this.getContext(contextName).openRange.startIndex;
  var range = new ContextRange(startIndex, offset, contextName);
  var ranges = this.getContext(contextName).ranges;
  range.rangeId = contextName + "." + ranges.length;
  ranges.push(range);
  this.getContext(contextName).openRange = null;
  return range;
};
Tokenizer.prototype.runContextCheck = function(contextParams) {
  var this$1$1 = this;
  var index = contextParams.index;
  this.contextCheckers.forEach(function(contextChecker) {
    var contextName = contextChecker.contextName;
    var openRange = this$1$1.getContext(contextName).openRange;
    if (!openRange && contextChecker.checkStart(contextParams)) {
      openRange = new ContextRange(index, null, contextName);
      this$1$1.getContext(contextName).openRange = openRange;
      this$1$1.dispatch("contextStart", [contextName, index]);
    }
    if (!!openRange && contextChecker.checkEnd(contextParams)) {
      var offset = index - openRange.startIndex + 1;
      var range = this$1$1.setEndOffset(offset, contextName);
      this$1$1.dispatch("contextEnd", [contextName, range]);
    }
  });
};
Tokenizer.prototype.tokenize = function(text) {
  this.tokens = [];
  this.resetContextsRanges();
  var chars = Array.from(text);
  this.dispatch("start");
  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];
    var contextParams = new ContextParams(chars, i);
    this.dispatch("next", [contextParams]);
    this.runContextCheck(contextParams);
    var token = new Token(char);
    this.tokens.push(token);
    this.dispatch("newToken", [token, contextParams]);
  }
  this.dispatch("end", [this.tokens]);
  return this.tokens;
};
function isArabicChar(c) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
}
function isIsolatedArabicChar(char) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isLatinChar(c) {
  return /[A-z]/.test(c);
}
function isWhiteSpace(c) {
  return /\s/.test(c);
}
function FeatureQuery(font) {
  this.font = font;
  this.features = {};
}
function SubstitutionAction(action) {
  this.id = action.id;
  this.tag = action.tag;
  this.substitution = action.substitution;
}
function lookupCoverage(glyphIndex, coverage) {
  if (!glyphIndex) {
    return -1;
  }
  switch (coverage.format) {
    case 1:
      return coverage.glyphs.indexOf(glyphIndex);
    case 2:
      var ranges = coverage.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (glyphIndex >= range.start && glyphIndex <= range.end) {
          var offset = glyphIndex - range.start;
          return range.index + offset;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function singleSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return glyphIndex + subtable.deltaGlyphId;
}
function singleSubstitutionFormat2(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.substitute[substituteIndex];
}
function lookupCoverageList(coverageList, contextParams) {
  var lookupList = [];
  for (var i = 0; i < coverageList.length; i++) {
    var coverage = coverageList[i];
    var glyphIndex = contextParams.current;
    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
    var lookupIndex = lookupCoverage(glyphIndex, coverage);
    if (lookupIndex !== -1) {
      lookupList.push(lookupIndex);
    }
  }
  if (lookupList.length !== coverageList.length) {
    return -1;
  }
  return lookupList;
}
function chainingSubstitutionFormat3(contextParams, subtable) {
  var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;
  if (contextParams.context.length < lookupsCount) {
    return [];
  }
  var inputLookups = lookupCoverageList(
    subtable.inputCoverage,
    contextParams
  );
  if (inputLookups === -1) {
    return [];
  }
  var lookaheadOffset = subtable.inputCoverage.length - 1;
  if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {
    return [];
  }
  var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
  while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
    lookaheadContext.shift();
  }
  var lookaheadParams = new ContextParams(lookaheadContext, 0);
  var lookaheadLookups = lookupCoverageList(
    subtable.lookaheadCoverage,
    lookaheadParams
  );
  var backtrackContext = [].concat(contextParams.backtrack);
  backtrackContext.reverse();
  while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
    backtrackContext.shift();
  }
  if (backtrackContext.length < subtable.backtrackCoverage.length) {
    return [];
  }
  var backtrackParams = new ContextParams(backtrackContext, 0);
  var backtrackLookups = lookupCoverageList(
    subtable.backtrackCoverage,
    backtrackParams
  );
  var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;
  var substitutions = [];
  if (contextRulesMatch) {
    for (var i = 0; i < subtable.lookupRecords.length; i++) {
      var lookupRecord = subtable.lookupRecords[i];
      var lookupListIndex = lookupRecord.lookupListIndex;
      var lookupTable = this.getLookupByIndex(lookupListIndex);
      for (var s = 0; s < lookupTable.subtables.length; s++) {
        var subtable$1 = lookupTable.subtables[s];
        var lookup = this.getLookupMethod(lookupTable, subtable$1);
        var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
        if (substitutionType === "12") {
          for (var n = 0; n < inputLookups.length; n++) {
            var glyphIndex = contextParams.get(n);
            var substitution = lookup(glyphIndex);
            if (substitution) {
              substitutions.push(substitution);
            }
          }
        }
      }
    }
  }
  return substitutions;
}
function ligatureSubstitutionFormat1(contextParams, subtable) {
  var glyphIndex = contextParams.current;
  var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (ligSetIndex === -1) {
    return null;
  }
  var ligature;
  var ligatureSet = subtable.ligatureSets[ligSetIndex];
  for (var s = 0; s < ligatureSet.length; s++) {
    ligature = ligatureSet[s];
    for (var l = 0; l < ligature.components.length; l++) {
      var lookaheadItem = contextParams.lookahead[l];
      var component = ligature.components[l];
      if (lookaheadItem !== component) {
        break;
      }
      if (l === ligature.components.length - 1) {
        return ligature;
      }
    }
  }
  return null;
}
function decompositionSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.sequences[substituteIndex];
}
FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function() {
  var scripts = this.font.tables.gsub.scripts;
  for (var s = 0; s < scripts.length; s++) {
    var script = scripts[s];
    if (script.tag === "DFLT") {
      return script.script.defaultLangSys.featureIndexes;
    }
  }
  return [];
};
FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
  var tables = this.font.tables;
  if (!tables.gsub) {
    return [];
  }
  if (!scriptTag) {
    return this.getDefaultScriptFeaturesIndexes();
  }
  var scripts = this.font.tables.gsub.scripts;
  for (var i = 0; i < scripts.length; i++) {
    var script = scripts[i];
    if (script.tag === scriptTag && script.script.defaultLangSys) {
      return script.script.defaultLangSys.featureIndexes;
    } else {
      var langSysRecords = script.langSysRecords;
      if (!!langSysRecords) {
        for (var j = 0; j < langSysRecords.length; j++) {
          var langSysRecord = langSysRecords[j];
          if (langSysRecord.tag === scriptTag) {
            var langSys = langSysRecord.langSys;
            return langSys.featureIndexes;
          }
        }
      }
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {
  var tags = {};
  for (var i = 0; i < features.length; i++) {
    var tag = features[i].tag;
    var feature = features[i].feature;
    tags[tag] = feature;
  }
  this.features[scriptTag].tags = tags;
};
FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {
  var features = this.features[scriptTag];
  if (this.features.hasOwnProperty(scriptTag)) {
    return features;
  }
  var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
  if (!featuresIndexes) {
    return null;
  }
  var gsub2 = this.font.tables.gsub;
  features = featuresIndexes.map(function(index) {
    return gsub2.features[index];
  });
  this.features[scriptTag] = features;
  this.mapTagsToFeatures(features, scriptTag);
  return features;
};
FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
  var lookupType = lookupTable.lookupType.toString();
  var substFormat = subtable.substFormat.toString();
  return lookupType + substFormat;
};
FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
  var this$1$1 = this;
  var substitutionType = this.getSubstitutionType(lookupTable, subtable);
  switch (substitutionType) {
    case "11":
      return function(glyphIndex) {
        return singleSubstitutionFormat1.apply(
          this$1$1,
          [glyphIndex, subtable]
        );
      };
    case "12":
      return function(glyphIndex) {
        return singleSubstitutionFormat2.apply(
          this$1$1,
          [glyphIndex, subtable]
        );
      };
    case "63":
      return function(contextParams) {
        return chainingSubstitutionFormat3.apply(
          this$1$1,
          [contextParams, subtable]
        );
      };
    case "41":
      return function(contextParams) {
        return ligatureSubstitutionFormat1.apply(
          this$1$1,
          [contextParams, subtable]
        );
      };
    case "21":
      return function(glyphIndex) {
        return decompositionSubstitutionFormat1.apply(
          this$1$1,
          [glyphIndex, subtable]
        );
      };
    default:
      throw new Error(
        "lookupType: " + lookupTable.lookupType + " - substFormat: " + subtable.substFormat + " is not yet supported"
      );
  }
};
FeatureQuery.prototype.lookupFeature = function(query) {
  var contextParams = query.contextParams;
  var currentIndex = contextParams.index;
  var feature = this.getFeature({
    tag: query.tag,
    script: query.script
  });
  if (!feature) {
    return new Error(
      "font '" + this.font.names.fullName.en + "' doesn't support feature '" + query.tag + "' for script '" + query.script + "'."
    );
  }
  var lookups = this.getFeatureLookups(feature);
  var substitutions = [].concat(contextParams.context);
  for (var l = 0; l < lookups.length; l++) {
    var lookupTable = lookups[l];
    var subtables = this.getLookupSubtables(lookupTable);
    for (var s = 0; s < subtables.length; s++) {
      var subtable = subtables[s];
      var substType = this.getSubstitutionType(lookupTable, subtable);
      var lookup = this.getLookupMethod(lookupTable, subtable);
      var substitution = void 0;
      switch (substType) {
        case "11":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 11,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "12":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 12,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "63":
          substitution = lookup(contextParams);
          if (Array.isArray(substitution) && substitution.length) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 63,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "41":
          substitution = lookup(contextParams);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 41,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "21":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 21,
              tag: query.tag,
              substitution
            }));
          }
          break;
      }
      contextParams = new ContextParams(substitutions, currentIndex);
      if (Array.isArray(substitution) && !substitution.length) {
        continue;
      }
      substitution = null;
    }
  }
  return substitutions.length ? substitutions : null;
};
FeatureQuery.prototype.supports = function(query) {
  if (!query.script) {
    return false;
  }
  this.getScriptFeatures(query.script);
  var supportedScript = this.features.hasOwnProperty(query.script);
  if (!query.tag) {
    return supportedScript;
  }
  var supportedFeature = this.features[query.script].some(function(feature) {
    return feature.tag === query.tag;
  });
  return supportedScript && supportedFeature;
};
FeatureQuery.prototype.getLookupSubtables = function(lookupTable) {
  return lookupTable.subtables || null;
};
FeatureQuery.prototype.getLookupByIndex = function(index) {
  var lookups = this.font.tables.gsub.lookups;
  return lookups[index] || null;
};
FeatureQuery.prototype.getFeatureLookups = function(feature) {
  return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
FeatureQuery.prototype.getFeature = function getFeature(query) {
  if (!this.font) {
    return { FAIL: "No font was found" };
  }
  if (!this.features.hasOwnProperty(query.script)) {
    this.getScriptFeatures(query.script);
  }
  var scriptFeatures = this.features[query.script];
  if (!scriptFeatures) {
    return { FAIL: "No feature for script " + query.script };
  }
  if (!scriptFeatures.tags[query.tag]) {
    return null;
  }
  return this.features[query.script].tags[query.tag];
};
function arabicWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? arabic first char
    prevChar === null && isArabicChar(char) || // ? arabic char preceded with a non arabic char
    !isArabicChar(prevChar) && isArabicChar(char)
  );
}
function arabicWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last arabic char
    nextChar === null || // ? next char is not arabic
    !isArabicChar(nextChar)
  );
}
var arabicWordCheck = {
  startCheck: arabicWordStartCheck,
  endCheck: arabicWordEndCheck
};
function arabicSentenceStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? an arabic char preceded with a non arabic char
    (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar)
  );
}
function arabicSentenceEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  switch (true) {
    case nextChar === null:
      return true;
    case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
      var nextIsWhitespace = isWhiteSpace(nextChar);
      if (!nextIsWhitespace) {
        return true;
      }
      if (nextIsWhitespace) {
        var arabicCharAhead = false;
        arabicCharAhead = contextParams.lookahead.some(
          function(c) {
            return isArabicChar(c) || isTashkeelArabicChar(c);
          }
        );
        if (!arabicCharAhead) {
          return true;
        }
      }
      break;
    default:
      return false;
  }
}
var arabicSentenceCheck = {
  startCheck: arabicSentenceStartCheck,
  endCheck: arabicSentenceEndCheck
};
function singleSubstitutionFormat1$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function singleSubstitutionFormat2$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function chainingSubstitutionFormat3$1(action, tokens, index) {
  action.substitution.forEach(function(subst, offset) {
    var token = tokens[index + offset];
    token.setState(action.tag, subst);
  });
}
function ligatureSubstitutionFormat1$1(action, tokens, index) {
  var token = tokens[index];
  token.setState(action.tag, action.substitution.ligGlyph);
  var compsCount = action.substitution.components.length;
  for (var i = 0; i < compsCount; i++) {
    token = tokens[index + i + 1];
    token.setState("deleted", true);
  }
}
var SUBSTITUTIONS = {
  11: singleSubstitutionFormat1$1,
  12: singleSubstitutionFormat2$1,
  63: chainingSubstitutionFormat3$1,
  41: ligatureSubstitutionFormat1$1
};
function applySubstitution(action, tokens, index) {
  if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
    SUBSTITUTIONS[action.id](action, tokens, index);
  }
}
function willConnectPrev(charContextParams) {
  var backtrack = [].concat(charContextParams.backtrack);
  for (var i = backtrack.length - 1; i >= 0; i--) {
    var prevChar = backtrack[i];
    var isolated = isIsolatedArabicChar(prevChar);
    var tashkeel = isTashkeelArabicChar(prevChar);
    if (!isolated && !tashkeel) {
      return true;
    }
    if (isolated) {
      return false;
    }
  }
  return false;
}
function willConnectNext(charContextParams) {
  if (isIsolatedArabicChar(charContextParams.current)) {
    return false;
  }
  for (var i = 0; i < charContextParams.lookahead.length; i++) {
    var nextChar = charContextParams.lookahead[i];
    var tashkeel = isTashkeelArabicChar(nextChar);
    if (!tashkeel) {
      return true;
    }
  }
  return false;
}
function arabicPresentationForms(range) {
  var this$1$1 = this;
  var script = "arab";
  var tags = this.featuresTags[script];
  var tokens = this.tokenizer.getRangeTokens(range);
  if (tokens.length === 1) {
    return;
  }
  var contextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.getState("glyphIndex");
      }
    ),
    0
  );
  var charContextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.char;
      }
    ),
    0
  );
  tokens.forEach(function(token, index) {
    if (isTashkeelArabicChar(token.char)) {
      return;
    }
    contextParams.setCurrentIndex(index);
    charContextParams.setCurrentIndex(index);
    var CONNECT = 0;
    if (willConnectPrev(charContextParams)) {
      CONNECT |= 1;
    }
    if (willConnectNext(charContextParams)) {
      CONNECT |= 2;
    }
    var tag;
    switch (CONNECT) {
      case 1:
        tag = "fina";
        break;
      case 2:
        tag = "init";
        break;
      case 3:
        tag = "medi";
        break;
    }
    if (tags.indexOf(tag) === -1) {
      return;
    }
    var substitutions = this$1$1.query.lookupFeature({
      tag,
      script,
      contextParams
    });
    if (substitutions instanceof Error) {
      return console.info(substitutions.message);
    }
    substitutions.forEach(function(action, index2) {
      if (action instanceof SubstitutionAction) {
        applySubstitution(action, tokens, index2);
        contextParams.context[index2] = action.substitution;
      }
    });
  });
}
function getContextParams(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, 0);
}
function arabicRequiredLigatures(range) {
  var this$1$1 = this;
  var script = "arab";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1$1.query.lookupFeature({
      tag: "rlig",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams(tokens);
    }
  });
}
function latinWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? latin first char
    prevChar === null && isLatinChar(char) || // ? latin char preceded with a non latin char
    !isLatinChar(prevChar) && isLatinChar(char)
  );
}
function latinWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last latin char
    nextChar === null || // ? next char is not latin
    !isLatinChar(nextChar)
  );
}
var latinWordCheck = {
  startCheck: latinWordStartCheck,
  endCheck: latinWordEndCheck
};
function getContextParams$1(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, 0);
}
function latinLigature(range) {
  var this$1$1 = this;
  var script = "latn";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams$1(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1$1.query.lookupFeature({
      tag: "liga",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams$1(tokens);
    }
  });
}
function Bidi(baseDir) {
  this.baseDir = baseDir || "ltr";
  this.tokenizer = new Tokenizer();
  this.featuresTags = {};
}
Bidi.prototype.setText = function(text) {
  this.text = text;
};
Bidi.prototype.contextChecks = {
  latinWordCheck,
  arabicWordCheck,
  arabicSentenceCheck
};
function registerContextChecker(checkId) {
  var check2 = this.contextChecks[checkId + "Check"];
  return this.tokenizer.registerContextChecker(
    checkId,
    check2.startCheck,
    check2.endCheck
  );
}
function tokenizeText() {
  registerContextChecker.call(this, "latinWord");
  registerContextChecker.call(this, "arabicWord");
  registerContextChecker.call(this, "arabicSentence");
  return this.tokenizer.tokenize(this.text);
}
function reverseArabicSentences() {
  var this$1$1 = this;
  var ranges = this.tokenizer.getContextRanges("arabicSentence");
  ranges.forEach(function(range) {
    var rangeTokens = this$1$1.tokenizer.getRangeTokens(range);
    this$1$1.tokenizer.replaceRange(
      range.startIndex,
      range.endOffset,
      rangeTokens.reverse()
    );
  });
}
Bidi.prototype.registerFeatures = function(script, tags) {
  var this$1$1 = this;
  var supportedTags = tags.filter(
    function(tag) {
      return this$1$1.query.supports({ script, tag });
    }
  );
  if (!this.featuresTags.hasOwnProperty(script)) {
    this.featuresTags[script] = supportedTags;
  } else {
    this.featuresTags[script] = this.featuresTags[script].concat(supportedTags);
  }
};
Bidi.prototype.applyFeatures = function(font, features) {
  if (!font) {
    throw new Error(
      "No valid font was provided to apply features"
    );
  }
  if (!this.query) {
    this.query = new FeatureQuery(font);
  }
  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    if (!this.query.supports({ script: feature.script })) {
      continue;
    }
    this.registerFeatures(feature.script, feature.tags);
  }
};
Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.tokenizer.registerModifier(modifierId, condition, modifier);
};
function checkGlyphIndexStatus() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) {
    throw new Error(
      "glyphIndex modifier is required to apply arabic presentation features."
    );
  }
}
function applyArabicPresentationForms() {
  var this$1$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicPresentationForms.call(this$1$1, range);
  });
}
function applyArabicRequireLigatures() {
  var this$1$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("rlig") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicRequiredLigatures.call(this$1$1, range);
  });
}
function applyLatinLigatures() {
  var this$1$1 = this;
  var script = "latn";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("liga") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("latinWord");
  ranges.forEach(function(range) {
    latinLigature.call(this$1$1, range);
  });
}
Bidi.prototype.checkContextReady = function(contextId) {
  return !!this.tokenizer.getContext(contextId);
};
Bidi.prototype.applyFeaturesToContexts = function() {
  if (this.checkContextReady("arabicWord")) {
    applyArabicPresentationForms.call(this);
    applyArabicRequireLigatures.call(this);
  }
  if (this.checkContextReady("latinWord")) {
    applyLatinLigatures.call(this);
  }
  if (this.checkContextReady("arabicSentence")) {
    reverseArabicSentences.call(this);
  }
};
Bidi.prototype.processText = function(text) {
  if (!this.text || this.text !== text) {
    this.setText(text);
    tokenizeText.call(this);
    this.applyFeaturesToContexts();
  }
};
Bidi.prototype.getBidiText = function(text) {
  this.processText(text);
  return this.tokenizer.getText();
};
Bidi.prototype.getTextGlyphs = function(text) {
  this.processText(text);
  var indexes = [];
  for (var i = 0; i < this.tokenizer.tokens.length; i++) {
    var token = this.tokenizer.tokens[i];
    if (token.state.deleted) {
      continue;
    }
    var index = token.activeState.value;
    indexes.push(Array.isArray(index) ? index[0] : index);
  }
  return indexes;
};
function Font(options) {
  options = options || {};
  options.tables = options.tables || {};
  if (!options.empty) {
    checkArgument(options.familyName, "When creating a new Font object, familyName is required.");
    checkArgument(options.styleName, "When creating a new Font object, styleName is required.");
    checkArgument(options.unitsPerEm, "When creating a new Font object, unitsPerEm is required.");
    checkArgument(options.ascender, "When creating a new Font object, ascender is required.");
    checkArgument(options.descender <= 0, "When creating a new Font object, negative descender value is required.");
    this.names = {
      fontFamily: { en: options.familyName || " " },
      fontSubfamily: { en: options.styleName || " " },
      fullName: { en: options.fullName || options.familyName + " " + options.styleName },
      // postScriptName may not contain any whitespace
      postScriptName: { en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, "") },
      designer: { en: options.designer || " " },
      designerURL: { en: options.designerURL || " " },
      manufacturer: { en: options.manufacturer || " " },
      manufacturerURL: { en: options.manufacturerURL || " " },
      license: { en: options.license || " " },
      licenseURL: { en: options.licenseURL || " " },
      version: { en: options.version || "Version 0.1" },
      description: { en: options.description || " " },
      copyright: { en: options.copyright || " " },
      trademark: { en: options.trademark || " " }
    };
    this.unitsPerEm = options.unitsPerEm || 1e3;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.createdTimestamp = options.createdTimestamp;
    this.tables = Object.assign(options.tables, {
      os2: Object.assign({
        usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
        usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
        fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
      }, options.tables.os2)
    });
  }
  this.supported = true;
  this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
  this.encoding = new DefaultEncoding(this);
  this.position = new Position(this);
  this.substitution = new Substitution(this);
  this.tables = this.tables || {};
  this._push = null;
  this._hmtxTableData = {};
  Object.defineProperty(this, "hinting", {
    get: function() {
      if (this._hinting) {
        return this._hinting;
      }
      if (this.outlinesFormat === "truetype") {
        return this._hinting = new Hinting(this);
      }
    }
  });
}
Font.prototype.hasChar = function(c) {
  return this.encoding.charToGlyphIndex(c) !== null;
};
Font.prototype.charToGlyphIndex = function(s) {
  return this.encoding.charToGlyphIndex(s);
};
Font.prototype.charToGlyph = function(c) {
  var glyphIndex = this.charToGlyphIndex(c);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font.prototype.updateFeatures = function(options) {
  return this.defaultRenderOptions.features.map(function(feature) {
    if (feature.script === "latn") {
      return {
        script: "latn",
        tags: feature.tags.filter(function(tag) {
          return options[tag];
        })
      };
    } else {
      return feature;
    }
  });
};
Font.prototype.stringToGlyphs = function(s, options) {
  var this$1$1 = this;
  var bidi = new Bidi();
  var charToGlyphIndexMod = function(token) {
    return this$1$1.charToGlyphIndex(token.char);
  };
  bidi.registerModifier("glyphIndex", null, charToGlyphIndexMod);
  var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;
  bidi.applyFeatures(this, features);
  var indexes = bidi.getTextGlyphs(s);
  var length = indexes.length;
  var glyphs = new Array(length);
  var notdef = this.glyphs.get(0);
  for (var i = 0; i < length; i += 1) {
    glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
  }
  return glyphs;
};
Font.prototype.nameToGlyphIndex = function(name) {
  return this.glyphNames.nameToGlyphIndex(name);
};
Font.prototype.nameToGlyph = function(name) {
  var glyphIndex = this.nameToGlyphIndex(name);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font.prototype.glyphIndexToName = function(gid) {
  if (!this.glyphNames.glyphIndexToName) {
    return "";
  }
  return this.glyphNames.glyphIndexToName(gid);
};
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
  leftGlyph = leftGlyph.index || leftGlyph;
  rightGlyph = rightGlyph.index || rightGlyph;
  var gposKerning = this.position.defaultKerningTables;
  if (gposKerning) {
    return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
  }
  return this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
};
Font.prototype.defaultRenderOptions = {
  kerning: true,
  features: [
    /**
     * these 4 features are required to render Arabic text properly
     * and shouldn't be turned off when rendering arabic text.
     */
    { script: "arab", tags: ["init", "medi", "fina", "rlig"] },
    { script: "latn", tags: ["liga", "rlig"] }
  ]
};
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  options = Object.assign({}, this.defaultRenderOptions, options);
  var fontScale = 1 / this.unitsPerEm * fontSize;
  var glyphs = this.stringToGlyphs(text, options);
  var kerningLookups;
  if (options.kerning) {
    var script = options.script || this.position.getDefaultScriptName();
    kerningLookups = this.position.getKerningTables(script, options.language);
  }
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs[i];
    callback.call(this, glyph, x, y, fontSize, options);
    if (glyph.advanceWidth) {
      x += glyph.advanceWidth * fontScale;
    }
    if (options.kerning && i < glyphs.length - 1) {
      var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this.getKerningValue(glyph, glyphs[i + 1]);
      x += kerningValue * fontScale;
    }
    if (options.letterSpacing) {
      x += options.letterSpacing * fontSize;
    } else if (options.tracking) {
      x += options.tracking / 1e3 * fontSize;
    }
  }
  return x;
};
Font.prototype.getPath = function(text, x, y, fontSize, options) {
  var fullPath = new Path();
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    fullPath.extend(glyphPath);
  });
  return fullPath;
};
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
  var glyphPaths = [];
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    glyphPaths.push(glyphPath);
  });
  return glyphPaths;
};
Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
  return this.forEachGlyph(text, 0, 0, fontSize, options, function() {
  });
};
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
  this.getPath(text, x, y, fontSize, options).draw(ctx);
};
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawPoints(ctx, gX, gY, gFontSize);
  });
};
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawMetrics(ctx, gX, gY, gFontSize);
  });
};
Font.prototype.getEnglishName = function(name) {
  var translations = this.names[name];
  if (translations) {
    return translations.en;
  }
};
Font.prototype.validate = function() {
  var _this = this;
  function assert(predicate, message) {
  }
  function assertNamePresent(name) {
    var englishName = _this.getEnglishName(name);
    assert(englishName && englishName.trim().length > 0);
  }
  assertNamePresent("fontFamily");
  assertNamePresent("weightName");
  assertNamePresent("manufacturer");
  assertNamePresent("copyright");
  assertNamePresent("version");
};
Font.prototype.toTables = function() {
  return sfnt.fontToTable(this);
};
Font.prototype.toBuffer = function() {
  console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");
  return this.toArrayBuffer();
};
Font.prototype.toArrayBuffer = function() {
  var sfntTable = this.toTables();
  var bytes = sfntTable.encode();
  var buffer = new ArrayBuffer(bytes.length);
  var intArray = new Uint8Array(buffer);
  for (var i = 0; i < bytes.length; i++) {
    intArray[i] = bytes[i];
  }
  return buffer;
};
Font.prototype.download = function(fileName) {
  var familyName = this.getEnglishName("fontFamily");
  var styleName = this.getEnglishName("fontSubfamily");
  fileName = fileName || familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
  var arrayBuffer = this.toArrayBuffer();
  if (isBrowser()) {
    window.URL = window.URL || window.webkitURL;
    if (window.URL) {
      var dataView = new DataView(arrayBuffer);
      var blob = new Blob([dataView], { type: "font/opentype" });
      var link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = fileName;
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, false);
      link.dispatchEvent(event);
    } else {
      console.warn("Font file could not be downloaded. Try using a different browser.");
    }
  } else {
    var fs = require("fs");
    var buffer = arrayBufferToNodeBuffer(arrayBuffer);
    fs.writeFileSync(fileName, buffer);
  }
};
Font.prototype.fsSelectionValues = {
  ITALIC: 1,
  //1
  UNDERSCORE: 2,
  //2
  NEGATIVE: 4,
  //4
  OUTLINED: 8,
  //8
  STRIKEOUT: 16,
  //16
  BOLD: 32,
  //32
  REGULAR: 64,
  //64
  USER_TYPO_METRICS: 128,
  //128
  WWS: 256,
  //256
  OBLIQUE: 512
  //512
};
Font.prototype.usWidthClasses = {
  ULTRA_CONDENSED: 1,
  EXTRA_CONDENSED: 2,
  CONDENSED: 3,
  SEMI_CONDENSED: 4,
  MEDIUM: 5,
  SEMI_EXPANDED: 6,
  EXPANDED: 7,
  EXTRA_EXPANDED: 8,
  ULTRA_EXPANDED: 9
};
Font.prototype.usWeightClasses = {
  THIN: 100,
  EXTRA_LIGHT: 200,
  LIGHT: 300,
  NORMAL: 400,
  MEDIUM: 500,
  SEMI_BOLD: 600,
  BOLD: 700,
  EXTRA_BOLD: 800,
  BLACK: 900
};
function addName(name, names) {
  var nameString = JSON.stringify(name);
  var nameID = 256;
  for (var nameKey in names) {
    var n = parseInt(nameKey);
    if (!n || n < 256) {
      continue;
    }
    if (JSON.stringify(names[nameKey]) === nameString) {
      return n;
    }
    if (nameID <= n) {
      nameID = n + 1;
    }
  }
  names[nameID] = name;
  return nameID;
}
function makeFvarAxis(n, axis, names) {
  var nameID = addName(axis.name, names);
  return [
    { name: "tag_" + n, type: "TAG", value: axis.tag },
    { name: "minValue_" + n, type: "FIXED", value: axis.minValue << 16 },
    { name: "defaultValue_" + n, type: "FIXED", value: axis.defaultValue << 16 },
    { name: "maxValue_" + n, type: "FIXED", value: axis.maxValue << 16 },
    { name: "flags_" + n, type: "USHORT", value: 0 },
    { name: "nameID_" + n, type: "USHORT", value: nameID }
  ];
}
function parseFvarAxis(data, start, names) {
  var axis = {};
  var p = new parse.Parser(data, start);
  axis.tag = p.parseTag();
  axis.minValue = p.parseFixed();
  axis.defaultValue = p.parseFixed();
  axis.maxValue = p.parseFixed();
  p.skip("uShort", 1);
  axis.name = names[p.parseUShort()] || {};
  return axis;
}
function makeFvarInstance(n, inst, axes, names) {
  var nameID = addName(inst.name, names);
  var fields = [
    { name: "nameID_" + n, type: "USHORT", value: nameID },
    { name: "flags_" + n, type: "USHORT", value: 0 }
  ];
  for (var i = 0; i < axes.length; ++i) {
    var axisTag = axes[i].tag;
    fields.push({
      name: "axis_" + n + " " + axisTag,
      type: "FIXED",
      value: inst.coordinates[axisTag] << 16
    });
  }
  return fields;
}
function parseFvarInstance(data, start, axes, names) {
  var inst = {};
  var p = new parse.Parser(data, start);
  inst.name = names[p.parseUShort()] || {};
  p.skip("uShort", 1);
  inst.coordinates = {};
  for (var i = 0; i < axes.length; ++i) {
    inst.coordinates[axes[i].tag] = p.parseFixed();
  }
  return inst;
}
function makeFvarTable(fvar2, names) {
  var result = new table.Table("fvar", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "offsetToData", type: "USHORT", value: 0 },
    { name: "countSizePairs", type: "USHORT", value: 2 },
    { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
    { name: "axisSize", type: "USHORT", value: 20 },
    { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
    { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
  ]);
  result.offsetToData = result.sizeOf();
  for (var i = 0; i < fvar2.axes.length; i++) {
    result.fields = result.fields.concat(makeFvarAxis(i, fvar2.axes[i], names));
  }
  for (var j = 0; j < fvar2.instances.length; j++) {
    result.fields = result.fields.concat(makeFvarInstance(j, fvar2.instances[j], fvar2.axes, names));
  }
  return result;
}
function parseFvarTable(data, start, names) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 65536, "Unsupported fvar table version.");
  var offsetToData = p.parseOffset16();
  p.skip("uShort", 1);
  var axisCount = p.parseUShort();
  var axisSize = p.parseUShort();
  var instanceCount = p.parseUShort();
  var instanceSize = p.parseUShort();
  var axes = [];
  for (var i = 0; i < axisCount; i++) {
    axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
  }
  var instances = [];
  var instanceStart = start + offsetToData + axisCount * axisSize;
  for (var j = 0; j < instanceCount; j++) {
    instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
  }
  return { axes, instances };
}
var fvar = { make: makeFvarTable, parse: parseFvarTable };
var attachList = function() {
  return {
    coverage: this.parsePointer(Parser.coverage),
    attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
  };
};
var caretValue = function() {
  var format = this.parseUShort();
  check.argument(
    format === 1 || format === 2 || format === 3,
    "Unsupported CaretValue table version."
  );
  if (format === 1) {
    return { coordinate: this.parseShort() };
  } else if (format === 2) {
    return { pointindex: this.parseShort() };
  } else if (format === 3) {
    return { coordinate: this.parseShort() };
  }
};
var ligGlyph = function() {
  return this.parseList(Parser.pointer(caretValue));
};
var ligCaretList = function() {
  return {
    coverage: this.parsePointer(Parser.coverage),
    ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
  };
};
var markGlyphSets = function() {
  this.parseUShort();
  return this.parseList(Parser.pointer(Parser.coverage));
};
function parseGDEFTable(data, start) {
  start = start || 0;
  var p = new Parser(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(
    tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
    "Unsupported GDEF table version."
  );
  var gdef2 = {
    version: tableVersion,
    classDef: p.parsePointer(Parser.classDef),
    attachList: p.parsePointer(attachList),
    ligCaretList: p.parsePointer(ligCaretList),
    markAttachClassDef: p.parsePointer(Parser.classDef)
  };
  if (tableVersion >= 1.2) {
    gdef2.markGlyphSets = p.parsePointer(markGlyphSets);
  }
  return gdef2;
}
var gdef = { parse: parseGDEFTable };
var subtableParsers$1 = new Array(10);
subtableParsers$1[1] = function parseLookup12() {
  var start = this.offset + this.relativeOffset;
  var posformat = this.parseUShort();
  if (posformat === 1) {
    return {
      posFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      value: this.parseValueRecord()
    };
  } else if (posformat === 2) {
    return {
      posFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      values: this.parseValueRecordList()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
subtableParsers$1[2] = function parseLookup22() {
  var start = this.offset + this.relativeOffset;
  var posFormat = this.parseUShort();
  check.assert(posFormat === 1 || posFormat === 2, "0x" + start.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var coverage = this.parsePointer(Parser.coverage);
  var valueFormat1 = this.parseUShort();
  var valueFormat2 = this.parseUShort();
  if (posFormat === 1) {
    return {
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      pairSets: this.parseList(Parser.pointer(Parser.list(function() {
        return {
          // pairValueRecord
          secondGlyph: this.parseUShort(),
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      })))
    };
  } else if (posFormat === 2) {
    var classDef1 = this.parsePointer(Parser.classDef);
    var classDef2 = this.parsePointer(Parser.classDef);
    var class1Count = this.parseUShort();
    var class2Count = this.parseUShort();
    return {
      // Class Pair Adjustment
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      classDef1,
      classDef2,
      class1Count,
      class2Count,
      classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
        return {
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      }))
    };
  }
};
subtableParsers$1[3] = function parseLookup32() {
  return { error: "GPOS Lookup 3 not supported" };
};
subtableParsers$1[4] = function parseLookup42() {
  return { error: "GPOS Lookup 4 not supported" };
};
subtableParsers$1[5] = function parseLookup52() {
  return { error: "GPOS Lookup 5 not supported" };
};
subtableParsers$1[6] = function parseLookup62() {
  return { error: "GPOS Lookup 6 not supported" };
};
subtableParsers$1[7] = function parseLookup72() {
  return { error: "GPOS Lookup 7 not supported" };
};
subtableParsers$1[8] = function parseLookup82() {
  return { error: "GPOS Lookup 8 not supported" };
};
subtableParsers$1[9] = function parseLookup9() {
  return { error: "GPOS Lookup 9 not supported" };
};
function parseGposTable(data, start) {
  start = start || 0;
  var p = new Parser(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GPOS table version " + tableVersion);
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers$1 = new Array(10);
function makeGposTable(gpos2) {
  return new table.Table("GPOS", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gpos2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gpos2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gpos2.lookups, subtableMakers$1) }
  ]);
}
var gpos = { parse: parseGposTable, make: makeGposTable };
function parseWindowsKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var subtableVersion = p.parseUShort();
  check.argument(subtableVersion === 0, "Unsupported kern sub-table version.");
  p.skip("uShort", 2);
  var nPairs = p.parseUShort();
  p.skip("uShort", 3);
  for (var i = 0; i < nPairs; i += 1) {
    var leftIndex = p.parseUShort();
    var rightIndex = p.parseUShort();
    var value = p.parseShort();
    pairs[leftIndex + "," + rightIndex] = value;
  }
  return pairs;
}
function parseMacKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var nTables = p.parseULong();
  if (nTables > 1) {
    console.warn("Only the first kern subtable is supported.");
  }
  p.skip("uLong");
  var coverage = p.parseUShort();
  var subtableVersion = coverage & 255;
  p.skip("uShort");
  if (subtableVersion === 0) {
    var nPairs = p.parseUShort();
    p.skip("uShort", 3);
    for (var i = 0; i < nPairs; i += 1) {
      var leftIndex = p.parseUShort();
      var rightIndex = p.parseUShort();
      var value = p.parseShort();
      pairs[leftIndex + "," + rightIndex] = value;
    }
  }
  return pairs;
}
function parseKernTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseUShort();
  if (tableVersion === 0) {
    return parseWindowsKernTable(p);
  } else if (tableVersion === 1) {
    return parseMacKernTable(p);
  } else {
    throw new Error("Unsupported kern table version (" + tableVersion + ").");
  }
}
var kern = { parse: parseKernTable };
function parseLocaTable(data, start, numGlyphs, shortVersion) {
  var p = new parse.Parser(data, start);
  var parseFn = shortVersion ? p.parseUShort : p.parseULong;
  var glyphOffsets = [];
  for (var i = 0; i < numGlyphs + 1; i += 1) {
    var glyphOffset = parseFn.call(p);
    if (shortVersion) {
      glyphOffset *= 2;
    }
    glyphOffsets.push(glyphOffset);
  }
  return glyphOffsets;
}
var loca = { parse: parseLocaTable };
function loadFromFile(path, callback) {
  var fs = require("fs");
  fs.readFile(path, function(err, buffer) {
    if (err) {
      return callback(err.message);
    }
    callback(null, nodeBufferToArrayBuffer(buffer));
  });
}
function loadFromUrl(url, callback) {
  var request = new XMLHttpRequest();
  request.open("get", url, true);
  request.responseType = "arraybuffer";
  request.onload = function() {
    if (request.response) {
      return callback(null, request.response);
    } else {
      return callback("Font could not be loaded: " + request.statusText);
    }
  };
  request.onerror = function() {
    callback("Font could not be loaded");
  };
  request.send();
}
function parseOpenTypeTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 12;
  for (var i = 0; i < numTables; i += 1) {
    var tag = parse.getTag(data, p);
    var checksum = parse.getULong(data, p + 4);
    var offset = parse.getULong(data, p + 8);
    var length = parse.getULong(data, p + 12);
    tableEntries.push({ tag, checksum, offset, length, compression: false });
    p += 16;
  }
  return tableEntries;
}
function parseWOFFTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 44;
  for (var i = 0; i < numTables; i += 1) {
    var tag = parse.getTag(data, p);
    var offset = parse.getULong(data, p + 4);
    var compLength = parse.getULong(data, p + 8);
    var origLength = parse.getULong(data, p + 12);
    var compression = void 0;
    if (compLength < origLength) {
      compression = "WOFF";
    } else {
      compression = false;
    }
    tableEntries.push({
      tag,
      offset,
      compression,
      compressedLength: compLength,
      length: origLength
    });
    p += 20;
  }
  return tableEntries;
}
function uncompressTable(data, tableEntry) {
  if (tableEntry.compression === "WOFF") {
    var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
    var outBuffer = new Uint8Array(tableEntry.length);
    tinyInflate(inBuffer, outBuffer);
    if (outBuffer.byteLength !== tableEntry.length) {
      throw new Error("Decompression error: " + tableEntry.tag + " decompressed length doesn't match recorded length");
    }
    var view = new DataView(outBuffer.buffer, 0);
    return { data: view, offset: 0 };
  } else {
    return { data, offset: tableEntry.offset };
  }
}
function parseBuffer(buffer, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var indexToLocFormat;
  var ltagTable;
  var font = new Font({ empty: true });
  var data = new DataView(buffer, 0);
  var numTables;
  var tableEntries = [];
  var signature = parse.getTag(data, 0);
  if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
    font.outlinesFormat = "truetype";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "OTTO") {
    font.outlinesFormat = "cff";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "wOFF") {
    var flavor = parse.getTag(data, 4);
    if (flavor === String.fromCharCode(0, 1, 0, 0)) {
      font.outlinesFormat = "truetype";
    } else if (flavor === "OTTO") {
      font.outlinesFormat = "cff";
    } else {
      throw new Error("Unsupported OpenType flavor " + signature);
    }
    numTables = parse.getUShort(data, 12);
    tableEntries = parseWOFFTableEntries(data, numTables);
  } else {
    throw new Error("Unsupported OpenType signature " + signature);
  }
  var cffTableEntry;
  var fvarTableEntry;
  var glyfTableEntry;
  var gdefTableEntry;
  var gposTableEntry;
  var gsubTableEntry;
  var hmtxTableEntry;
  var kernTableEntry;
  var locaTableEntry;
  var nameTableEntry;
  var metaTableEntry;
  var p;
  for (var i = 0; i < numTables; i += 1) {
    var tableEntry = tableEntries[i];
    var table2 = void 0;
    switch (tableEntry.tag) {
      case "cmap":
        table2 = uncompressTable(data, tableEntry);
        font.tables.cmap = cmap.parse(table2.data, table2.offset);
        font.encoding = new CmapEncoding(font.tables.cmap);
        break;
      case "cvt ":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.cvt = p.parseShortList(tableEntry.length / 2);
        break;
      case "fvar":
        fvarTableEntry = tableEntry;
        break;
      case "fpgm":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.fpgm = p.parseByteList(tableEntry.length);
        break;
      case "head":
        table2 = uncompressTable(data, tableEntry);
        font.tables.head = head.parse(table2.data, table2.offset);
        font.unitsPerEm = font.tables.head.unitsPerEm;
        indexToLocFormat = font.tables.head.indexToLocFormat;
        break;
      case "hhea":
        table2 = uncompressTable(data, tableEntry);
        font.tables.hhea = hhea.parse(table2.data, table2.offset);
        font.ascender = font.tables.hhea.ascender;
        font.descender = font.tables.hhea.descender;
        font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        hmtxTableEntry = tableEntry;
        break;
      case "ltag":
        table2 = uncompressTable(data, tableEntry);
        ltagTable = ltag.parse(table2.data, table2.offset);
        break;
      case "maxp":
        table2 = uncompressTable(data, tableEntry);
        font.tables.maxp = maxp.parse(table2.data, table2.offset);
        font.numGlyphs = font.tables.maxp.numGlyphs;
        break;
      case "name":
        nameTableEntry = tableEntry;
        break;
      case "OS/2":
        table2 = uncompressTable(data, tableEntry);
        font.tables.os2 = os2.parse(table2.data, table2.offset);
        break;
      case "post":
        table2 = uncompressTable(data, tableEntry);
        font.tables.post = post.parse(table2.data, table2.offset);
        font.glyphNames = new GlyphNames(font.tables.post);
        break;
      case "prep":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.prep = p.parseByteList(tableEntry.length);
        break;
      case "glyf":
        glyfTableEntry = tableEntry;
        break;
      case "loca":
        locaTableEntry = tableEntry;
        break;
      case "CFF ":
        cffTableEntry = tableEntry;
        break;
      case "kern":
        kernTableEntry = tableEntry;
        break;
      case "GDEF":
        gdefTableEntry = tableEntry;
        break;
      case "GPOS":
        gposTableEntry = tableEntry;
        break;
      case "GSUB":
        gsubTableEntry = tableEntry;
        break;
      case "meta":
        metaTableEntry = tableEntry;
        break;
    }
  }
  var nameTable = uncompressTable(data, nameTableEntry);
  font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
  font.names = font.tables.name;
  if (glyfTableEntry && locaTableEntry) {
    var shortVersion = indexToLocFormat === 0;
    var locaTable = uncompressTable(data, locaTableEntry);
    var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
    var glyfTable = uncompressTable(data, glyfTableEntry);
    font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
  } else if (cffTableEntry) {
    var cffTable = uncompressTable(data, cffTableEntry);
    cff.parse(cffTable.data, cffTable.offset, font, opt);
  } else {
    throw new Error("Font doesn't contain TrueType or CFF outlines.");
  }
  var hmtxTable = uncompressTable(data, hmtxTableEntry);
  hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
  addGlyphNames(font, opt);
  if (kernTableEntry) {
    var kernTable = uncompressTable(data, kernTableEntry);
    font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
  } else {
    font.kerningPairs = {};
  }
  if (gdefTableEntry) {
    var gdefTable = uncompressTable(data, gdefTableEntry);
    font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
  }
  if (gposTableEntry) {
    var gposTable = uncompressTable(data, gposTableEntry);
    font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    font.position.init();
  }
  if (gsubTableEntry) {
    var gsubTable = uncompressTable(data, gsubTableEntry);
    font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
  }
  if (fvarTableEntry) {
    var fvarTable = uncompressTable(data, fvarTableEntry);
    font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
  }
  if (metaTableEntry) {
    var metaTable = uncompressTable(data, metaTableEntry);
    font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
    font.metas = font.tables.meta;
  }
  return font;
}
function load(url, callback, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var isNode = typeof window === "undefined";
  var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;
  return new Promise(function(resolve, reject) {
    loadFn(url, function(err, arrayBuffer) {
      if (err) {
        if (callback) {
          return callback(err);
        } else {
          reject(err);
        }
      }
      var font;
      try {
        font = parseBuffer(arrayBuffer, opt);
      } catch (e) {
        if (callback) {
          return callback(e, null);
        } else {
          reject(e);
        }
      }
      if (callback) {
        return callback(null, font);
      } else {
        resolve(font);
      }
    });
  });
}
function loadSync(url, opt) {
  var fs = require("fs");
  var buffer = fs.readFileSync(url);
  return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
}
var opentype = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Font,
  Glyph,
  Path,
  BoundingBox,
  _parse: parse,
  parse: parseBuffer,
  load,
  loadSync
});

const logger$8 = createLogger("TextToVector");
function commandsToBezierPaths(commands) {
  const paths = [];
  let currentPath = [];
  let currentPoint = { x: 0, y: 0 };
  let startPoint = { x: 0, y: 0 };
  for (const cmd of commands) {
    switch (cmd.type) {
      case "M":
        if (currentPath.length > 0) {
          paths.push({ vertices: currentPath, closed: false });
          currentPath = [];
        }
        currentPoint = { x: cmd.x, y: cmd.y };
        startPoint = { ...currentPoint };
        break;
      case "L":
        currentPath.push({
          point: { ...currentPoint },
          inHandle: { x: 0, y: 0 },
          outHandle: { x: 0, y: 0 }
        });
        currentPoint = { x: cmd.x, y: cmd.y };
        break;
      case "C":
        currentPath.push({
          point: { ...currentPoint },
          inHandle: { x: 0, y: 0 },
          outHandle: {
            x: cmd.x1 - currentPoint.x,
            y: cmd.y1 - currentPoint.y
          }
        });
        currentPoint = { x: cmd.x, y: cmd.y };
        break;
      case "Q":
        {
          const cp1x = currentPoint.x + 2 / 3 * (cmd.x1 - currentPoint.x);
          const cp1y = currentPoint.y + 2 / 3 * (cmd.y1 - currentPoint.y);
          currentPath.push({
            point: { ...currentPoint },
            inHandle: { x: 0, y: 0 },
            outHandle: {
              x: cp1x - currentPoint.x,
              y: cp1y - currentPoint.y
            }
          });
          currentPoint = { x: cmd.x, y: cmd.y };
        }
        break;
      case "Z":
        currentPath.push({
          point: { ...currentPoint },
          inHandle: { x: 0, y: 0 },
          outHandle: { x: 0, y: 0 }
        });
        if (currentPath.length > 0) {
          paths.push({ vertices: currentPath, closed: true });
          currentPath = [];
        }
        currentPoint = { ...startPoint };
        break;
    }
  }
  if (currentPath.length > 0) {
    currentPath.push({
      point: { ...currentPoint },
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
    paths.push({ vertices: currentPath, closed: false });
  }
  return paths;
}
async function textToVectorFromUrl(text, fontUrl, fontSize, options) {
  const opts = {
    x: options?.x ?? 0,
    y: options?.y ?? 0,
    kerning: options?.kerning ?? true,
    letterSpacing: options?.letterSpacing ?? 0
  };
  let font;
  try {
    font = await opentype.load(fontUrl);
  } catch (error) {
    logger$8.error(`Failed to load font from URL ${fontUrl}:`, error);
    throw new Error(`Failed to load font from URL: ${fontUrl}`);
  }
  const path = font.getPath(text, opts.x, opts.y, fontSize);
  const allPaths = commandsToBezierPaths(path.commands);
  const characters = [];
  let x = opts.x;
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const glyph = font.charToGlyph(char);
    if (!glyph) {
      continue;
    }
    const charPath = glyph.getPath(x, opts.y, fontSize);
    const paths = commandsToBezierPaths(charPath.commands);
    const bbox = charPath.getBoundingBox();
    const bounds2 = {
      x: bbox.x1,
      y: bbox.y1,
      width: bbox.x2 - bbox.x1,
      height: bbox.y2 - bbox.y1
    };
    const advanceWidth = (glyph.advanceWidth ?? 0) * (fontSize / font.unitsPerEm);
    characters.push({
      character: char,
      charIndex: i,
      paths,
      bounds: bounds2,
      advanceWidth
    });
    x += advanceWidth + opts.letterSpacing;
    if (opts.kerning && i < text.length - 1) {
      const nextGlyph = font.charToGlyph(text[i + 1]);
      if (nextGlyph) {
        const kerning = font.getKerningValue(glyph, nextGlyph);
        x += kerning * (fontSize / font.unitsPerEm);
      }
    }
  }
  const pathBbox = path.getBoundingBox();
  const bounds = {
    x: pathBbox.x1,
    y: pathBbox.y1,
    width: pathBbox.x2 - pathBbox.x1,
    height: pathBbox.y2 - pathBbox.y1
  };
  return {
    allPaths,
    characters,
    bounds,
    text,
    fontFamily: font.names.fontFamily?.en || "Unknown",
    fontSize
  };
}

function createLayer(store, type, name) {
  const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  let layerData = null;
  switch (type) {
    case "text":
      layerData = {
        text: "Text",
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        tracking: 0,
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left"
      };
      break;
    case "solid":
      layerData = {
        color: "#808080",
        width: store.project.composition.width,
        height: store.project.composition.height
      };
      break;
    case "null":
      layerData = {
        size: 40
      };
      break;
    case "spline":
      layerData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        // Stroke options (shown in More Options group)
        lineCap: "round",
        // butt, round, square
        lineJoin: "round",
        // miter, round, bevel
        dashArray: "",
        // e.g., "10, 5" for dashed lines
        dashOffset: 0
      };
      break;
    case "path":
      layerData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        showGuide: true,
        // Show dashed guide line in editor
        guideColor: "#00FFFF",
        // Cyan guide line
        guideDashPattern: [10, 5]
        // [dash, gap]
      };
      break;
    case "particles":
      layerData = {
        systemConfig: {
          maxParticles: 1e3,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: "emitter_1",
          name: "Emitter 1",
          x: store.project.composition.width / 2,
          y: store.project.composition.height / 2,
          direction: -90,
          spread: 30,
          speed: 5,
          speedVariance: 0.2,
          size: 10,
          sizeVariance: 0.3,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 0.2,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 10,
          trailOpacityFalloff: 0.9,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 5,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 4,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          },
          // Sprite sheet defaults
          spriteEnabled: false,
          spriteImageUrl: "",
          spriteColumns: 1,
          spriteRows: 1,
          spriteAnimate: false,
          spriteFrameRate: 10,
          spriteRandomStart: false
        }
      };
      break;
    case "depthflow":
      layerData = {
        sourceLayerId: null,
        depthLayerId: null,
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0,
          orbitSpeed: 1,
          swingAmplitude: 0,
          swingFrequency: 1,
          edgeDilation: 0,
          inpaintEdges: false
        }
      };
      break;
    case "light":
      layerData = {
        lightType: "point",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0
      };
      break;
    case "camera":
      layerData = {
        cameraId: null,
        isActiveCamera: false
      };
      break;
    case "image":
      layerData = {
        assetId: null,
        fit: "contain"
      };
      break;
    case "video":
      layerData = {
        assetId: null,
        loop: false,
        startTime: 0,
        speed: 1
      };
      break;
    case "shape":
      layerData = {
        shapes: [],
        fill: "#ffffff",
        stroke: "#000000",
        strokeWidth: 2
      };
      break;
    case "nestedComp":
      layerData = {
        compositionId: null,
        // Speed map (new naming)
        speedMap: null,
        speedMapEnabled: false,
        // Backwards compatibility
        timeRemap: null,
        timeRemapEnabled: false
      };
      break;
    case "matte":
      layerData = {
        matteType: "luminance",
        invert: false,
        threshold: 0.5,
        feather: 0,
        expansion: 0,
        sourceLayerId: null,
        previewMode: "matte"
      };
      break;
    case "model":
      layerData = {
        assetId: "",
        format: "gltf",
        scale: createAnimatableProperty("Scale", 1, "number"),
        uniformScale: true,
        castShadow: true,
        receiveShadow: true,
        frustumCulled: true,
        renderOrder: 0,
        showBoundingBox: false,
        showSkeleton: false,
        envMapIntensity: 1
      };
      break;
    case "pointcloud":
      layerData = {
        assetId: "",
        format: "ply",
        pointCount: 0,
        pointSize: createAnimatableProperty("Point Size", 2, "number"),
        sizeAttenuation: true,
        minPointSize: 1,
        maxPointSize: 64,
        colorMode: "rgb",
        uniformColor: "#ffffff",
        renderMode: "points",
        opacity: createAnimatableProperty("Opacity", 1, "number"),
        depthTest: true,
        depthWrite: true,
        showBoundingBox: false,
        pointBudget: 1e6
      };
      break;
    case "control":
      layerData = {
        size: 50,
        showAxes: true,
        showIcon: true,
        iconShape: "crosshair",
        iconColor: "#ffcc00"
      };
      break;
    case "depth":
      layerData = {
        assetId: null,
        visualizationMode: "colormap",
        colorMap: "turbo",
        invert: false,
        minDepth: 0,
        maxDepth: 1,
        autoNormalize: true,
        contourLevels: 10,
        contourColor: "#ffffff",
        contourWidth: 1,
        meshDisplacement: createAnimatableProperty("Displacement", 50, "number"),
        meshResolution: 128,
        wireframe: false
      };
      break;
    case "normal":
      layerData = {
        assetId: null,
        visualizationMode: "rgb",
        format: "opengl",
        flipX: false,
        flipY: false,
        flipZ: false,
        arrowDensity: 20,
        arrowScale: 10,
        arrowColor: "#00ff00",
        lightDirection: { x: 0.5, y: 0.5, z: 1 },
        lightIntensity: 1,
        ambientIntensity: 0.2
      };
      break;
    case "audio":
      layerData = {
        assetId: null,
        level: createAnimatableProperty("Level", 0, "number"),
        muted: false,
        solo: false,
        pan: createAnimatableProperty("Pan", 0, "number"),
        startTime: 0,
        loop: false,
        speed: 1,
        showWaveform: true,
        waveformColor: "#4a90d9",
        exposeFeatures: true
      };
      break;
    case "generated":
      layerData = {
        generationType: "depth",
        sourceLayerId: null,
        model: "depth-anything-v2",
        parameters: {},
        generatedAssetId: null,
        status: "pending",
        autoRegenerate: false
      };
      break;
    case "group":
      layerData = {
        collapsed: false,
        color: null,
        passThrough: true,
        isolate: false
      };
      break;
    case "particle":
      layerData = {
        emitterType: "point",
        particleCount: 100,
        lifetime: 2,
        speed: 50,
        spread: 45,
        gravity: -9.8,
        color: "#ffffff",
        size: 5
      };
      break;
    case "adjustment":
      layerData = {
        color: "#808080",
        effectLayer: true,
        adjustmentLayer: true
        // Backwards compatibility
      };
      break;
  }
  let audioProps = void 0;
  if (type === "video" || type === "audio") {
    audioProps = {
      level: createAnimatableProperty("Audio Levels", 0, "number")
      // 0dB default
    };
  }
  const comp = store.getActiveComp();
  const layers = store.getActiveCompLayers();
  const compWidth = comp?.settings.width || store.project.composition.width || 1920;
  const compHeight = comp?.settings.height || store.project.composition.height || 1080;
  const centeredTransform = createDefaultTransform();
  centeredTransform.position.value = { x: compWidth / 2, y: compHeight / 2 };
  const layer = {
    id,
    name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
    type,
    visible: true,
    locked: false,
    isolate: false,
    threeD: false,
    motionBlur: false,
    // Timing (primary properties)
    startFrame: 0,
    endFrame: (comp?.settings.frameCount || 81) - 1,
    // Backwards compatibility aliases
    inPoint: 0,
    outPoint: (comp?.settings.frameCount || 81) - 1,
    parentId: null,
    blendMode: "normal",
    opacity: createAnimatableProperty("opacity", 100, "number"),
    transform: centeredTransform,
    audio: audioProps,
    properties: [],
    effects: [],
    data: layerData
  };
  if (type === "camera") {
    storeLogger.warn("Use createCameraLayer() for camera layers");
  }
  layers.unshift(layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return layer;
}
function deleteLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const index = layers.findIndex((l) => l.id === layerId);
  if (index === -1) return;
  layers.splice(index, 1);
  useSelectionStore$1().removeFromSelection(layerId);
  clearLayerCache(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function duplicateLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const original = layers.find((l) => l.id === layerId);
  if (!original) return null;
  const duplicate = structuredClone(original);
  duplicate.id = crypto.randomUUID();
  duplicate.name = original.name + " Copy";
  regenerateKeyframeIds(duplicate);
  const index = layers.findIndex((l) => l.id === layerId);
  layers.splice(index, 0, duplicate);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return duplicate;
}
function copySelectedLayers(store) {
  const layers = store.getActiveCompLayers();
  const selection = useSelectionStore$1();
  const selectedLayers = layers.filter((l) => selection.selectedLayerIds.includes(l.id));
  if (selectedLayers.length === 0) return;
  store.clipboard.layers = selectedLayers.map((layer) => structuredClone(layer));
  storeLogger.debug(`Copied ${store.clipboard.layers.length} layer(s) to clipboard`);
}
function pasteLayers(store) {
  if (store.clipboard.layers.length === 0) return [];
  const layers = store.getActiveCompLayers();
  const pastedLayers = [];
  for (const clipboardLayer of store.clipboard.layers) {
    const newLayer = structuredClone(clipboardLayer);
    newLayer.id = crypto.randomUUID();
    newLayer.name = clipboardLayer.name + " Copy";
    regenerateKeyframeIds(newLayer);
    newLayer.parentId = null;
    layers.unshift(newLayer);
    pastedLayers.push(newLayer);
  }
  useSelectionStore$1().selectLayers(pastedLayers.map((l) => l.id));
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  storeLogger.debug(`Pasted ${pastedLayers.length} layer(s)`);
  return pastedLayers;
}
function cutSelectedLayers(store) {
  copySelectedLayers(store);
  const layerIds = [...useSelectionStore$1().selectedLayerIds];
  for (const id of layerIds) {
    deleteLayer(store, id);
  }
}
function updateLayer(store, layerId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  Object.assign(layer, updates);
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function updateLayerData(store, layerId, dataUpdates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.data) return;
  layer.data = { ...layer.data, ...dataUpdates };
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function replaceLayerSource(store, layerId, newSource) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const assetId = newSource.assetId || newSource.id || null;
  if (layer.type === "image" && newSource.type === "asset" && assetId) {
    layer.data.assetId = assetId;
    layer.name = newSource.name || layer.name;
  } else if (layer.type === "video" && newSource.type === "asset" && assetId) {
    layer.data.assetId = assetId;
    layer.name = newSource.name || layer.name;
  } else if (layer.type === "solid" && newSource.type === "asset" && assetId) {
    layer.type = "image";
    layer.data = { assetId, fit: "none" };
    layer.name = newSource.name || layer.name;
  } else if (layer.type === "nestedComp" && newSource.type === "composition" && newSource.id) {
    layer.data.compositionId = newSource.id;
    layer.name = newSource.name || layer.name;
  } else if (newSource.type === "composition" && newSource.id) {
    layer.type = "nestedComp";
    layer.data = { compositionId: newSource.id, speedMapEnabled: false, flattenTransform: false, overrideFrameRate: false };
    layer.name = newSource.name || layer.name;
  } else if (newSource.type === "asset" && assetId) {
    const path = newSource.path || "";
    const ext = path.split(".").pop()?.toLowerCase() || "";
    const imageExts = ["png", "jpg", "jpeg", "gif", "webp", "svg"];
    const videoExts = ["mp4", "webm", "mov", "avi"];
    if (imageExts.includes(ext)) {
      layer.type = "image";
      layer.data = { assetId, fit: "none" };
    } else if (videoExts.includes(ext)) {
      layer.type = "video";
      layer.data = {
        assetId,
        loop: true,
        pingPong: false,
        startTime: 0,
        speed: 1,
        speedMapEnabled: false,
        frameBlending: "none",
        audioEnabled: true,
        audioLevel: 100,
        posterFrame: 0
      };
    }
    layer.name = newSource.name || layer.name;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  console.log(`[Weyl] Replaced layer source: ${layer.name}`);
}
function moveLayer(store, layerId, newIndex) {
  const layers = store.getActiveCompLayers();
  const currentIndex = layers.findIndex((l) => l.id === layerId);
  if (currentIndex === -1) return;
  const [layer] = layers.splice(currentIndex, 1);
  layers.splice(newIndex, 0, layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleLayer3D(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  layer.threeD = !layer.threeD;
  if (layer.threeD) {
    const t = layer.transform;
    const pos = t.position.value;
    t.position.value = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    t.position.type = "vector3";
    const originProp = t.origin || t.anchorPoint;
    if (originProp) {
      const orig = originProp.value;
      originProp.value = { x: orig.x, y: orig.y, z: orig.z ?? 0 };
      originProp.type = "vector3";
    }
    const scl = t.scale.value;
    t.scale.value = { x: scl.x, y: scl.y, z: scl.z ?? 100 };
    t.scale.type = "vector3";
    if (!t.orientation) {
      t.orientation = createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3");
    }
    if (!t.rotationX) {
      t.rotationX = createAnimatableProperty("rotationX", 0, "number");
    }
    if (!t.rotationY) {
      t.rotationY = createAnimatableProperty("rotationY", 0, "number");
    }
    if (!t.rotationZ) {
      t.rotationZ = createAnimatableProperty("rotationZ", 0, "number");
      t.rotationZ.value = t.rotation.value;
    }
  } else {
    if (layer.transform.rotationZ) {
      layer.transform.rotation.value = layer.transform.rotationZ.value;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setLayerParent(store, layerId, parentId) {
  const layers = store.getActiveCompLayers();
  const layer = layers.find((l) => l.id === layerId);
  if (!layer) return;
  if (parentId === layerId) return;
  if (parentId) {
    const getDescendants = (id) => {
      const descendants2 = /* @__PURE__ */ new Set();
      const children = layers.filter((l) => l.parentId === id);
      for (const child of children) {
        descendants2.add(child.id);
        const childDescendants = getDescendants(child.id);
        childDescendants.forEach((d) => descendants2.add(d));
      }
      return descendants2;
    };
    const descendants = getDescendants(layerId);
    if (descendants.has(parentId)) {
      storeLogger.warn("Cannot set parent: would create circular reference");
      return;
    }
  }
  layer.parentId = parentId;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function addSplineControlPoint(store, layerId, point) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  splineData.controlPoints.push(point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function insertSplineControlPoint(store, layerId, point, index) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  const insertIndex = Math.max(0, Math.min(index, splineData.controlPoints.length));
  splineData.controlPoints.splice(insertIndex, 0, point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateSplineControlPoint(store, layerId, pointId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const point = splineData.controlPoints?.find((p) => p.id === pointId);
  if (!point) return;
  Object.assign(point, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteSplineControlPoint(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) return;
  const index = splineData.controlPoints.findIndex((p) => p.id === pointId);
  if (index >= 0) {
    splineData.controlPoints.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function enableSplineAnimation(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (splineData.animated && splineData.animatedControlPoints) {
    storeLogger.debug("Spline already in animated mode");
    return;
  }
  const staticPoints = splineData.controlPoints || [];
  const animatedPoints = staticPoints.map(
    (cp) => controlPointToAnimatable(cp)
  );
  splineData.animatedControlPoints = animatedPoints;
  splineData.animated = true;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug("Enabled spline animation with", animatedPoints.length, "control points");
}
function addSplinePointKeyframe(store, layerId, pointId, property, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) {
    enableSplineAnimation(store, layerId);
  }
  const point = splineData.animatedControlPoints?.find((p) => p.id === pointId);
  if (!point) {
    storeLogger.warn("Control point not found:", pointId);
    return;
  }
  let animatableProp;
  switch (property) {
    case "x":
      animatableProp = point.x;
      break;
    case "y":
      animatableProp = point.y;
      break;
    case "depth":
      animatableProp = point.depth;
      break;
    case "handleIn.x":
      animatableProp = point.handleIn?.x;
      break;
    case "handleIn.y":
      animatableProp = point.handleIn?.y;
      break;
    case "handleOut.x":
      animatableProp = point.handleOut?.x;
      break;
    case "handleOut.y":
      animatableProp = point.handleOut?.y;
      break;
  }
  if (!animatableProp) {
    storeLogger.warn("Property not found on control point:", property);
    return;
  }
  const existingIdx = animatableProp.keyframes.findIndex((k) => k.frame === frame);
  if (existingIdx >= 0) {
    animatableProp.keyframes[existingIdx].value = animatableProp.value;
  } else {
    animatableProp.keyframes.push({
      id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      frame,
      value: animatableProp.value,
      interpolation: "bezier",
      controlMode: "smooth",
      inHandle: { frame: -5, value: 0, enabled: true },
      outHandle: { frame: 5, value: 0, enabled: true }
    });
    animatableProp.keyframes.sort((a, b) => a.frame - b.frame);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug("Added keyframe to control point", pointId, "property", property, "at frame", frame);
}
function addSplinePointPositionKeyframe(store, layerId, pointId, frame) {
  addSplinePointKeyframe(store, layerId, pointId, "x", frame);
  addSplinePointKeyframe(store, layerId, pointId, "y", frame);
}
function updateSplinePointWithKeyframe(store, layerId, pointId, x, y, frame, addKeyframe = false) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (splineData.animated && splineData.animatedControlPoints) {
    const point = splineData.animatedControlPoints.find((p) => p.id === pointId);
    if (!point) return;
    point.x.value = x;
    point.y.value = y;
    if (addKeyframe) {
      addSplinePointPositionKeyframe(store, layerId, pointId, frame);
    }
    const staticPoint = splineData.controlPoints?.find((p) => p.id === pointId);
    if (staticPoint) {
      staticPoint.x = x;
      staticPoint.y = y;
    }
  } else {
    const point = splineData.controlPoints?.find((p) => p.id === pointId);
    if (!point) return;
    point.x = x;
    point.y = y;
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
}
function getEvaluatedSplinePoints(store, layerId, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return [];
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) {
    return (splineData.controlPoints || []).map((cp) => ({
      id: cp.id,
      x: cp.x,
      y: cp.y,
      depth: cp.depth ?? 0,
      handleIn: cp.handleIn ? { ...cp.handleIn } : null,
      handleOut: cp.handleOut ? { ...cp.handleOut } : null,
      type: cp.type
    }));
  }
  return splineData.animatedControlPoints.map((acp) => {
    const x = interpolateProperty(acp.x, frame);
    const y = interpolateProperty(acp.y, frame);
    const depth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    let handleIn = null;
    let handleOut = null;
    if (acp.handleIn) {
      handleIn = {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      };
    }
    if (acp.handleOut) {
      handleOut = {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      };
    }
    return {
      id: acp.id,
      x,
      y,
      depth,
      handleIn,
      handleOut,
      type: animatableToControlPoint(acp).type
    };
  });
}
function isSplineAnimated(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return false;
  const splineData = layer.data;
  return !!splineData.animated;
}
function hasSplinePointKeyframes(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return false;
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) return false;
  const point = splineData.animatedControlPoints.find((p) => p.id === pointId);
  if (!point) return false;
  if (point.x.keyframes.length > 0) return true;
  if (point.y.keyframes.length > 0) return true;
  if (point.depth?.keyframes.length) return true;
  if (point.handleIn?.x.keyframes.length) return true;
  if (point.handleIn?.y.keyframes.length) return true;
  if (point.handleOut?.x.keyframes.length) return true;
  if (point.handleOut?.y.keyframes.length) return true;
  return false;
}
function simplifySpline(store, layerId, tolerance) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const controlPoints = splineData.controlPoints;
  if (!controlPoints || controlPoints.length <= 2) return;
  const points = controlPoints.map((cp) => ({ x: cp.x, y: cp.y }));
  const simplified = douglasPeuckerSimplify(points, tolerance);
  const newControlPoints = [];
  let simplifiedIdx = 0;
  for (const cp of controlPoints) {
    if (simplifiedIdx < simplified.length) {
      const sp = simplified[simplifiedIdx];
      if (Math.abs(cp.x - sp.x) < 0.01 && Math.abs(cp.y - sp.y) < 0.01) {
        newControlPoints.push(cp);
        simplifiedIdx++;
      }
    }
  }
  splineData.controlPoints = newControlPoints;
  if (splineData.animated && splineData.animatedControlPoints) {
    const newAnimatedPoints = splineData.animatedControlPoints.filter(
      (acp) => newControlPoints.some((cp) => cp.id === acp.id)
    );
    splineData.animatedControlPoints = newAnimatedPoints;
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug(`Simplified spline from ${controlPoints.length} to ${newControlPoints.length} points`);
}
function douglasPeuckerSimplify(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDist(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeuckerSimplify(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeuckerSimplify(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function perpendicularDist(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (length < 1e-4) {
    return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);
  }
  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
  const closest = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return Math.sqrt((point.x - closest.x) ** 2 + (point.y - closest.y) ** 2);
}
function smoothSplineHandles(store, layerId, amount) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const controlPoints = splineData.controlPoints;
  if (!controlPoints || controlPoints.length < 2) return;
  const factor = Math.max(0, Math.min(100, amount)) / 100;
  for (let i = 0; i < controlPoints.length; i++) {
    const cp = controlPoints[i];
    const prev = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
    const next = controlPoints[(i + 1) % controlPoints.length];
    if (!splineData.closed && (i === 0 || i === controlPoints.length - 1)) {
      continue;
    }
    const toPrev = { x: prev.x - cp.x, y: prev.y - cp.y };
    const toNext = { x: next.x - cp.x, y: next.y - cp.y };
    const avgDir = { x: toNext.x - toPrev.x, y: toNext.y - toPrev.y };
    const avgLength = Math.sqrt(avgDir.x * avgDir.x + avgDir.y * avgDir.y);
    if (avgLength < 0.01) continue;
    const normalized = { x: avgDir.x / avgLength, y: avgDir.y / avgLength };
    const distPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
    const distNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);
    const handleLength = (distPrev + distNext) / 6;
    const idealIn = { x: cp.x - normalized.x * handleLength, y: cp.y - normalized.y * handleLength };
    const idealOut = { x: cp.x + normalized.x * handleLength, y: cp.y + normalized.y * handleLength };
    if (cp.handleIn) {
      cp.handleIn = {
        x: cp.handleIn.x + (idealIn.x - cp.handleIn.x) * factor,
        y: cp.handleIn.y + (idealIn.y - cp.handleIn.y) * factor
      };
    } else {
      cp.handleIn = { x: idealIn.x * factor + cp.x * (1 - factor), y: idealIn.y * factor + cp.y * (1 - factor) };
    }
    if (cp.handleOut) {
      cp.handleOut = {
        x: cp.handleOut.x + (idealOut.x - cp.handleOut.x) * factor,
        y: cp.handleOut.y + (idealOut.y - cp.handleOut.y) * factor
      };
    } else {
      cp.handleOut = { x: idealOut.x * factor + cp.x * (1 - factor), y: idealOut.y * factor + cp.y * (1 - factor) };
    }
    cp.type = "smooth";
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug(`Smoothed spline handles with amount ${amount}%`);
}
function selectLayer(_store, layerId, addToSelection = false) {
  const selection = useSelectionStore$1();
  if (addToSelection) {
    selection.addToSelection(layerId);
  } else {
    selection.selectLayer(layerId);
  }
}
function deselectLayer(_store, layerId) {
  useSelectionStore$1().removeFromSelection(layerId);
}
function regenerateKeyframeIds(layer) {
  if (layer.transform) {
    for (const key of Object.keys(layer.transform)) {
      const prop = layer.transform[key];
      if (prop?.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
  if (layer.properties) {
    for (const prop of layer.properties) {
      if (prop.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
}
function getLayerById(store, layerId) {
  return store.getActiveCompLayers().find((l) => l.id === layerId) || null;
}
function bezierPathToControlPoints(path) {
  return path.vertices.map((vertex, index) => {
    const handleIn = vertex.inHandle.x !== 0 || vertex.inHandle.y !== 0 ? {
      x: vertex.point.x + vertex.inHandle.x,
      y: vertex.point.y + vertex.inHandle.y
    } : null;
    const handleOut = vertex.outHandle.x !== 0 || vertex.outHandle.y !== 0 ? {
      x: vertex.point.x + vertex.outHandle.x,
      y: vertex.point.y + vertex.outHandle.y
    } : null;
    return {
      id: `cp_${Date.now()}_${index}_${Math.random().toString(36).slice(2, 6)}`,
      x: vertex.point.x,
      y: vertex.point.y,
      depth: 0,
      handleIn,
      handleOut,
      type: handleIn || handleOut ? "smooth" : "corner"
    };
  });
}
async function convertTextLayerToSplines(store, layerId, options = {}) {
  const layer = getLayerById(store, layerId);
  if (!layer || layer.type !== "text") {
    storeLogger.error("convertTextLayerToSplines: Layer not found or not a text layer");
    return null;
  }
  const textData = layer.data;
  if (!textData.text) {
    storeLogger.error("convertTextLayerToSplines: No text content");
    return null;
  }
  const fontUrl = options.fontUrl || `https://fonts.gstatic.com/s/${textData.fontFamily.toLowerCase().replace(/\s+/g, "")}/v1/regular.woff`;
  try {
    const result = await textToVectorFromUrl(
      textData.text,
      fontUrl,
      textData.fontSize,
      {
        x: layer.transform.position.value.x,
        y: layer.transform.position.value.y,
        kerning: true
      }
    );
    if (!result.allPaths.length && !result.characters.length) {
      storeLogger.error("convertTextLayerToSplines: No paths generated");
      return null;
    }
    store.pushHistory();
    const createdLayerIds = [];
    const layers = store.getActiveCompLayers();
    layers.findIndex((l) => l.id === layerId);
    if (options.perCharacter && result.characters.length > 0) {
      let parentId = layer.parentId ?? null;
      if (options.groupCharacters) {
        const groupLayer = createLayer(store, "null", `${layer.name} (Group)`);
        groupLayer.transform = { ...layer.transform };
        parentId = groupLayer.id;
        createdLayerIds.push(groupLayer.id);
      }
      for (let i = 0; i < result.characters.length; i++) {
        const charGroup = result.characters[i];
        if (charGroup.character.trim() === "" || charGroup.paths.length === 0) {
          continue;
        }
        const allControlPoints = [];
        for (const path of charGroup.paths) {
          const points = bezierPathToControlPoints(path);
          allControlPoints.push(...points);
        }
        if (allControlPoints.length === 0) continue;
        const charLayerName = `${layer.name} - "${charGroup.character}" [${i}]`;
        const charLayer = createLayer(store, "spline", charLayerName);
        const splineData = {
          pathData: "",
          controlPoints: allControlPoints,
          closed: charGroup.paths[0]?.closed ?? true,
          stroke: textData.stroke || "",
          strokeWidth: textData.strokeWidth || 0,
          fill: textData.fill || "#ffffff"
        };
        charLayer.data = splineData;
        charLayer.parentId = parentId;
        charLayer.inPoint = layer.inPoint;
        charLayer.outPoint = layer.outPoint;
        if (!options.groupCharacters) {
          charLayer.transform = {
            ...createDefaultTransform(),
            position: createAnimatableProperty("Position", {
              x: layer.transform.position.value.x + charGroup.bounds.x,
              y: layer.transform.position.value.y
            }, "position")
          };
        }
        createdLayerIds.push(charLayer.id);
      }
    } else {
      const allControlPoints = [];
      for (const path of result.allPaths) {
        const points = bezierPathToControlPoints(path);
        allControlPoints.push(...points);
      }
      if (allControlPoints.length === 0) {
        storeLogger.error("convertTextLayerToSplines: No control points generated");
        return null;
      }
      const splineLayer = createLayer(store, "spline", `${layer.name} (Spline)`);
      const splineData = {
        pathData: "",
        controlPoints: allControlPoints,
        closed: result.allPaths[0]?.closed ?? true,
        stroke: textData.stroke || "",
        strokeWidth: textData.strokeWidth || 0,
        fill: textData.fill || "#ffffff"
      };
      splineLayer.data = splineData;
      splineLayer.transform = { ...layer.transform };
      splineLayer.parentId = layer.parentId;
      splineLayer.inPoint = layer.inPoint;
      splineLayer.outPoint = layer.outPoint;
      createdLayerIds.push(splineLayer.id);
    }
    if (!options.keepOriginal) {
      deleteLayer(store, layerId);
    }
    if (createdLayerIds.length > 0) {
      const selectionStore = useSelectionStore$1();
      selectionStore.clearLayerSelection();
      selectionStore.selectLayer(createdLayerIds[0]);
    }
    storeLogger.info(`Converted text layer to ${createdLayerIds.length} spline layer(s)`);
    return createdLayerIds;
  } catch (error) {
    storeLogger.error("convertTextLayerToSplines: Failed to convert", error);
    return null;
  }
}
function copyPathToPosition(store, sourceSplineLayerId, targetLayerId, options = {}) {
  const comp = store.getActiveComp();
  if (!comp) {
    storeLogger.error("copyPathToPosition: No active composition");
    return null;
  }
  const sourceLayer = comp.layers.find((l) => l.id === sourceSplineLayerId);
  if (!sourceLayer || sourceLayer.type !== "spline" || !sourceLayer.data) {
    storeLogger.error("copyPathToPosition: Source layer not found or not a spline");
    return null;
  }
  const targetLayer = comp.layers.find((l) => l.id === targetLayerId);
  if (!targetLayer) {
    storeLogger.error("copyPathToPosition: Target layer not found");
    return null;
  }
  const splineData = sourceLayer.data;
  const controlPoints = splineData.controlPoints || [];
  if (controlPoints.length < 2) {
    storeLogger.error("copyPathToPosition: Path needs at least 2 control points");
    return null;
  }
  const useFullDuration = options.useFullDuration ?? true;
  const startFrame = options.startFrame ?? 0;
  const endFrame = options.endFrame ?? comp.settings.frameCount - 1;
  const interpolation = options.interpolation ?? "bezier";
  const useSpatialTangents = options.useSpatialTangents ?? true;
  const reversed = options.reversed ?? false;
  const frameStart = useFullDuration ? 0 : startFrame;
  const frameEnd = useFullDuration ? comp.settings.frameCount - 1 : endFrame;
  const frameDuration = frameEnd - frameStart;
  const defaultKeyframeCount = Math.max(
    controlPoints.length,
    Math.ceil(frameDuration / 5)
    // At least one keyframe every 5 frames
  );
  const keyframeCount = options.keyframeCount ?? defaultKeyframeCount;
  const sampledPoints = samplePathPoints(controlPoints, keyframeCount, splineData.closed ?? false);
  if (reversed) {
    sampledPoints.reverse();
  }
  const keyframes = [];
  for (let i = 0; i < sampledPoints.length; i++) {
    const t = sampledPoints.length > 1 ? i / (sampledPoints.length - 1) : 0;
    const frame = Math.round(frameStart + t * frameDuration);
    const point = sampledPoints[i];
    const prevFrame = i > 0 ? keyframes[i - 1]?.frame ?? 0 : 0;
    const nextFrame = i < sampledPoints.length - 1 ? Math.round(frameStart + (i + 1) / (sampledPoints.length - 1) * frameDuration) : frameDuration;
    const inInfluence = (frame - prevFrame) * 0.33;
    const outInfluence = (nextFrame - frame) * 0.33;
    const keyframe = {
      id: `kf_${Date.now()}_${i}`,
      frame,
      value: { x: point.x, y: point.y, z: point.depth ?? 0 },
      interpolation,
      inHandle: { frame: -inInfluence, value: 0, enabled: true },
      outHandle: { frame: outInfluence, value: 0, enabled: true },
      controlMode: "smooth"
    };
    if (useSpatialTangents && point.handleIn && point.handleOut) {
      keyframe.spatialInTangent = {
        x: point.handleIn.x - point.x,
        y: point.handleIn.y - point.y,
        z: 0
      };
      keyframe.spatialOutTangent = {
        x: point.handleOut.x - point.x,
        y: point.handleOut.y - point.y,
        z: 0
      };
    }
    keyframes.push(keyframe);
  }
  store.pushHistory();
  targetLayer.transform.position.animated = true;
  targetLayer.transform.position.keyframes = keyframes;
  markLayerDirty(targetLayerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  storeLogger.info(`copyPathToPosition: Created ${keyframes.length} position keyframes on layer "${targetLayer.name}"`);
  return keyframes.length;
}
function samplePathPoints(controlPoints, count, closed) {
  if (controlPoints.length === 0) return [];
  if (controlPoints.length === 1) {
    return [{ x: controlPoints[0].x, y: controlPoints[0].y, depth: controlPoints[0].depth }];
  }
  const segments = [];
  let totalLength = 0;
  for (let i = 0; i < controlPoints.length - 1; i++) {
    const curr = controlPoints[i];
    const next = controlPoints[i + 1];
    const p0 = { x: curr.x, y: curr.y, depth: curr.depth };
    const p3 = { x: next.x, y: next.y, depth: next.depth };
    const p1 = curr.handleOut ? { x: curr.handleOut.x, y: curr.handleOut.y } : { x: curr.x, y: curr.y };
    const p2 = next.handleIn ? { x: next.handleIn.x, y: next.handleIn.y } : { x: next.x, y: next.y };
    const length = approximateBezierLength(p0, p1, p2, p3);
    totalLength += length;
    segments.push({ p0, p1, p2, p3, length });
  }
  if (closed && controlPoints.length > 2) {
    const last = controlPoints[controlPoints.length - 1];
    const first = controlPoints[0];
    const p0 = { x: last.x, y: last.y, depth: last.depth };
    const p3 = { x: first.x, y: first.y, depth: first.depth };
    const p1 = last.handleOut ? { x: last.handleOut.x, y: last.handleOut.y } : { x: last.x, y: last.y };
    const p2 = first.handleIn ? { x: first.handleIn.x, y: first.handleIn.y } : { x: first.x, y: first.y };
    const length = approximateBezierLength(p0, p1, p2, p3);
    totalLength += length;
    segments.push({ p0, p1, p2, p3, length });
  }
  const result = [];
  const step = totalLength / (count - 1);
  let currentDist = 0;
  let segIndex = 0;
  let segDist = 0;
  for (let i = 0; i < count; i++) {
    const targetDist = i * step;
    while (segIndex < segments.length - 1 && currentDist + segments[segIndex].length < targetDist) {
      currentDist += segments[segIndex].length;
      segIndex++;
    }
    const seg = segments[segIndex];
    if (!seg) {
      const lastCp = controlPoints[controlPoints.length - 1];
      result.push({ x: lastCp.x, y: lastCp.y, depth: lastCp.depth });
      continue;
    }
    segDist = targetDist - currentDist;
    const t = seg.length > 0 ? Math.min(1, segDist / seg.length) : 0;
    const point = evaluateCubicBezier(seg.p0, seg.p1, seg.p2, seg.p3, t);
    const depth = seg.p0.depth !== void 0 && seg.p3.depth !== void 0 ? seg.p0.depth + (seg.p3.depth - seg.p0.depth) * t : void 0;
    const tangent = evaluateCubicBezierDerivative(seg.p0, seg.p1, seg.p2, seg.p3, t);
    const handleScale = 20;
    result.push({
      x: point.x,
      y: point.y,
      depth,
      handleIn: { x: point.x - tangent.x * handleScale, y: point.y - tangent.y * handleScale },
      handleOut: { x: point.x + tangent.x * handleScale, y: point.y + tangent.y * handleScale }
    });
  }
  return result;
}
function approximateBezierLength(p0, p1, p2, p3, samples = 10) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= samples; i++) {
    const t = i / samples;
    const curr = evaluateCubicBezier(p0, p1, p2, p3, t);
    length += Math.sqrt(
      (curr.x - prev.x) ** 2 + (curr.y - prev.y) ** 2
    );
    prev = curr;
  }
  return length;
}
function evaluateCubicBezier(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function evaluateCubicBezierDerivative(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const dx = 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x);
  const dy = 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y);
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len === 0) return { x: 0, y: 0 };
  return { x: dx / len, y: dy / len };
}
function timeStretchLayer(store, layerId, options) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.warn("Layer not found for time stretch:", layerId);
    return;
  }
  if (layer.type !== "video" && layer.type !== "nestedComp") {
    storeLogger.warn("Time stretch only works on video/nestedComp layers");
    return;
  }
  store.pushHistory();
  layer.startFrame = options.newStartFrame;
  layer.endFrame = options.newEndFrame;
  if (layer.data) {
    const data = layer.data;
    data.speed = options.speed;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  storeLogger.debug(
    `Time stretched layer ${layer.name}: ${options.stretchFactor}% (speed: ${options.speed.toFixed(2)}, hold: ${options.holdInPlace})`
  );
}
function reverseLayer(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.warn("Layer not found for reverse:", layerId);
    return;
  }
  if (layer.type !== "video" && layer.type !== "nestedComp") {
    storeLogger.warn("Reverse only works on video/nestedComp layers");
    return;
  }
  store.pushHistory();
  if (layer.data) {
    const data = layer.data;
    data.speed = -(data.speed ?? 1);
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  storeLogger.debug(`Reversed layer: ${layer.name}`);
}
function freezeFrameAtPlayhead(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.warn("Layer not found for freeze frame:", layerId);
    return;
  }
  if (layer.type !== "video" && layer.type !== "nestedComp") {
    storeLogger.warn("Freeze frame only works on video/nestedComp layers");
    return;
  }
  store.pushHistory();
  const currentFrame = store.currentFrame ?? 0;
  const fps = store.fps ?? 30;
  const sourceTime = currentFrame / fps;
  if (layer.data) {
    const data = layer.data;
    data.speedMapEnabled = true;
    if (!data.speedMap) {
      data.speedMap = createAnimatableProperty("Speed Map", sourceTime, "number");
    }
    data.speedMap.keyframes = [
      {
        id: `kf_freeze_start_${Date.now()}`,
        frame: currentFrame,
        value: sourceTime,
        interpolation: "hold",
        controlMode: "linked",
        inHandle: { frame: -5, value: 0, enabled: true },
        outHandle: { frame: 5, value: 0, enabled: true }
      },
      {
        id: `kf_freeze_end_${Date.now() + 1}`,
        frame: (layer.endFrame ?? store.getActiveComp()?.settings.frameCount ?? 81) - 1,
        value: sourceTime,
        interpolation: "hold",
        controlMode: "linked",
        inHandle: { frame: -5, value: 0, enabled: true },
        outHandle: { frame: 5, value: 0, enabled: true }
      }
    ];
    data.speedMap.value = sourceTime;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  storeLogger.debug(`Created freeze frame on ${layer.name} at frame ${currentFrame}`);
}
function splitLayerAtPlayhead(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.warn("Layer not found for split:", layerId);
    return null;
  }
  const currentFrame = store.currentFrame ?? 0;
  const startFrame = layer.startFrame ?? 0;
  const endFrame = layer.endFrame ?? store.getActiveComp()?.settings.frameCount ?? 81;
  if (currentFrame <= startFrame || currentFrame >= endFrame) {
    storeLogger.warn("Split point must be within layer bounds");
    return null;
  }
  store.pushHistory();
  const newLayerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const newLayer = {
    ...JSON.parse(JSON.stringify(layer)),
    id: newLayerId,
    name: `${layer.name} (split)`
  };
  layer.endFrame = currentFrame;
  newLayer.startFrame = currentFrame;
  newLayer.endFrame = endFrame;
  if ((layer.type === "video" || layer.type === "nestedComp") && newLayer.data) {
    const data = newLayer.data;
    const fps = 30;
    const originalStartTime = data.startTime ?? 0;
    const speed = data.speed ?? 1;
    const frameOffset = currentFrame - startFrame;
    const timeOffset = frameOffset / fps * speed;
    data.startTime = originalStartTime + timeOffset;
  }
  const layers = store.getActiveCompLayers();
  const originalIndex = layers.findIndex((l) => l.id === layerId);
  layers.splice(originalIndex + 1, 0, newLayer);
  markLayerDirty(layerId);
  markLayerDirty(newLayerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  storeLogger.debug(`Split layer ${layer.name} at frame ${currentFrame}`);
  return newLayer;
}

function findPropertyByPath(layer, propertyPath) {
  const normalizedPath = propertyPath.replace(/^transform\./, "");
  if (normalizedPath === "position") {
    return layer.transform.position;
  }
  if (normalizedPath === "scale") {
    return layer.transform.scale;
  }
  if (normalizedPath === "rotation") {
    return layer.transform.rotation;
  }
  if (normalizedPath === "anchorPoint") {
    return layer.transform.anchorPoint;
  }
  if (propertyPath === "opacity") {
    return layer.opacity;
  }
  if (normalizedPath === "rotationX" && layer.transform.rotationX) {
    return layer.transform.rotationX;
  }
  if (normalizedPath === "rotationY" && layer.transform.rotationY) {
    return layer.transform.rotationY;
  }
  if (normalizedPath === "rotationZ" && layer.transform.rotationZ) {
    return layer.transform.rotationZ;
  }
  if (normalizedPath === "orientation" && layer.transform.orientation) {
    return layer.transform.orientation;
  }
  return layer.properties.find((p) => p.name === propertyPath || p.id === propertyPath);
}
function addKeyframe(store, layerId, propertyPath, value, atFrame) {
  const comp = store.getActiveComp();
  const frame = atFrame ?? (comp?.currentFrame ?? 0);
  storeLogger.debug("addKeyframe called:", { layerId, propertyPath, value, frame });
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.debug("addKeyframe: layer not found");
    return null;
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    storeLogger.debug("addKeyframe: property not found:", propertyPath);
    return null;
  }
  property.animated = true;
  const keyframe = {
    id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    frame,
    value,
    interpolation: "linear",
    inHandle: { frame: 0, value: 0, enabled: false },
    outHandle: { frame: 0, value: 0, enabled: false },
    controlMode: "smooth"
  };
  const existingIndex = property.keyframes.findIndex((k) => k.frame === frame);
  if (existingIndex >= 0) {
    property.keyframes[existingIndex] = keyframe;
    storeLogger.debug("addKeyframe: replaced existing keyframe at frame", frame);
  } else {
    property.keyframes.push(keyframe);
    property.keyframes.sort((a, b) => a.frame - b.frame);
    storeLogger.debug("addKeyframe: added new keyframe at frame", frame, "total keyframes:", property.keyframes.length);
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  return keyframe;
}
function removeKeyframe(store, layerId, propertyPath, keyframeId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const index = property.keyframes.findIndex((k) => k.id === keyframeId);
  if (index >= 0) {
    property.keyframes.splice(index, 1);
    if (property.keyframes.length === 0) {
      property.animated = false;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveKeyframe(store, layerId, propertyPath, keyframeId, newFrame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  const existingAtTarget = property.keyframes.find(
    (kf) => kf.frame === newFrame && kf.id !== keyframeId
  );
  if (existingAtTarget) {
    property.keyframes = property.keyframes.filter((kf) => kf.id !== existingAtTarget.id);
  }
  keyframe.frame = newFrame;
  property.keyframes.sort((a, b) => a.frame - b.frame);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeValue(store, layerId, propertyPath, keyframeId, newValue) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (typeof keyframe.value === "object" && keyframe.value !== null && typeof newValue === "number") {
    storeLogger.warn("setKeyframeValue: Cannot directly update vector keyframes with scalar. Use separate dimension curves.");
    return;
  }
  keyframe.value = newValue;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateKeyframe(store, layerId, propertyPath, keyframeId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (updates.frame !== void 0) {
    keyframe.frame = updates.frame;
    property.keyframes.sort((a, b) => a.frame - b.frame);
  }
  if (updates.value !== void 0) {
    keyframe.value = updates.value;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeInterpolation(store, layerId, propertyPath, keyframeId, interpolation) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  keyframe.interpolation = interpolation;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeHandle(store, layerId, propertyPath, keyframeId, handleType, handle) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (handleType === "in") {
    keyframe.inHandle = { ...handle };
  } else {
    keyframe.outHandle = { ...handle };
  }
  if (handle.enabled && keyframe.interpolation === "linear") {
    keyframe.interpolation = "bezier";
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyValue(store, layerId, propertyPath, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.value = value;
  if (property.animated && property.keyframes.length > 0) {
    const currentFrame = store.getActiveComp()?.currentFrame ?? 0;
    const existingKf = property.keyframes.find((kf) => kf.frame === currentFrame);
    if (existingKf) {
      existingKf.value = value;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyAnimated(store, layerId, propertyPath, animated, addKeyframeCallback) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.animated = animated;
  if (animated && property.keyframes.length === 0) {
    if (addKeyframeCallback) {
      addKeyframeCallback();
    } else {
      const comp = store.getActiveComp();
      const frame = comp?.currentFrame ?? 0;
      const keyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame,
        value: property.value,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false },
        controlMode: "smooth"
      };
      property.keyframes.push(keyframe);
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}

const BLOCKED_HOSTNAMES = [
  "localhost",
  "127.0.0.1",
  "0.0.0.0",
  "::1"
  // Private IP ranges are checked separately
];
function isPrivateIP(hostname) {
  const privateRanges = [
    /^10\./,
    // 10.0.0.0/8
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
    // 172.16.0.0/12
    /^192\.168\./,
    // 192.168.0.0/16
    /^169\.254\./,
    // Link-local
    /^127\./
    // Loopback
  ];
  return privateRanges.some((range) => range.test(hostname));
}
function isValidExternalURL(url, options = {}) {
  const {
    allowData = true,
    allowBlob = true,
    allowHttp = false
    // Default to HTTPS only for external URLs
  } = options;
  try {
    const parsed = new URL(url);
    const allowedProtocols = ["https:"];
    if (allowHttp) allowedProtocols.push("http:");
    if (allowData) allowedProtocols.push("data:");
    if (allowBlob) allowedProtocols.push("blob:");
    if (!allowedProtocols.includes(parsed.protocol)) {
      console.warn(`[Security] Blocked URL with protocol: ${parsed.protocol}`);
      return false;
    }
    if (parsed.protocol === "data:" || parsed.protocol === "blob:") {
      return true;
    }
    if (BLOCKED_HOSTNAMES.includes(parsed.hostname.toLowerCase())) {
      console.warn(`[Security] Blocked URL with hostname: ${parsed.hostname}`);
      return false;
    }
    if (isPrivateIP(parsed.hostname)) {
      console.warn(`[Security] Blocked URL with private IP: ${parsed.hostname}`);
      return false;
    }
    return true;
  } catch {
    console.warn(`[Security] Invalid URL: ${url}`);
    return false;
  }
}
function validateURL(url, context = "resource loading", options = {}) {
  if (!isValidExternalURL(url, options)) {
    throw new Error(
      `[Security] Invalid or blocked URL for ${context}: ${url.substring(0, 100)}...`
    );
  }
  return url;
}
function secureUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);
  array[6] = array[6] & 15 | 64;
  array[8] = array[8] & 63 | 128;
  const hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join("");
  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
}

const logger$7 = createLogger("ProjectStorage");
const API_BASE = "/weyl/compositor";
function isValidProjectId(projectId) {
  const uuidPattern = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;
  const alphanumericPattern = /^[a-zA-Z0-9_-]{1,128}$/;
  return uuidPattern.test(projectId) || alphanumericPattern.test(projectId);
}
async function saveProject(project, projectId) {
  try {
    logger$7.info(`Saving project${projectId ? ` (${projectId})` : ""}...`);
    const response = await fetch(`${API_BASE}/save_project`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        project,
        project_id: projectId
      })
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project saved: ${result.project_id}`);
    } else {
      logger$7.error(`Failed to save project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error saving project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function loadProject(projectId) {
  if (!isValidProjectId(projectId)) {
    logger$7.error(`Invalid project ID format: ${projectId}`);
    return {
      status: "error",
      message: "Invalid project ID format"
    };
  }
  try {
    logger$7.info(`Loading project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/load_project/${encodeURIComponent(projectId)}`);
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project loaded: ${projectId}`);
    } else {
      logger$7.error(`Failed to load project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error loading project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function listProjects() {
  try {
    logger$7.info("Listing projects...");
    const response = await fetch(`${API_BASE}/list_projects`);
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Found ${result.projects?.length || 0} projects`);
    } else {
      logger$7.error(`Failed to list projects: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error listing projects:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function deleteProject(projectId) {
  try {
    logger$7.info(`Deleting project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/delete_project/${encodeURIComponent(projectId)}`, {
      method: "DELETE"
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project deleted: ${projectId}`);
    } else {
      logger$7.error(`Failed to delete project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error deleting project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}

const MAX_HISTORY_SIZE = 50;
function pushHistory(store) {
  if (store.historyIndex < store.historyStack.length - 1) {
    store.historyStack = store.historyStack.slice(0, store.historyIndex + 1);
  }
  const snapshot = structuredClone(toRaw(store.project));
  store.historyStack.push(snapshot);
  store.historyIndex = store.historyStack.length - 1;
  if (store.historyStack.length > MAX_HISTORY_SIZE) {
    store.historyStack = store.historyStack.slice(-MAX_HISTORY_SIZE);
    store.historyIndex = store.historyStack.length - 1;
  }
}
function undo(store) {
  if (store.historyIndex <= 0) return false;
  store.historyIndex--;
  const historyEntry = toRaw(store.historyStack[store.historyIndex]);
  store.project = structuredClone(historyEntry);
  return true;
}
function redo(store) {
  if (store.historyIndex >= store.historyStack.length - 1) return false;
  store.historyIndex++;
  const historyEntry = toRaw(store.historyStack[store.historyIndex]);
  store.project = structuredClone(historyEntry);
  return true;
}
function exportProject(store) {
  return JSON.stringify(store.project, null, 2);
}
function importProject(store, json, pushHistoryFn) {
  try {
    const project = JSON.parse(json);
    store.project = project;
    pushHistoryFn();
    return true;
  } catch (err) {
    storeLogger.error("Failed to import project:", err);
    return false;
  }
}
async function saveProjectToServer(store, projectId) {
  try {
    const result = await saveProject(store.project, projectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project saved to server:", result.project_id);
      return result.project_id;
    } else {
      storeLogger.error("Failed to save project:", result.message);
      return null;
    }
  } catch (err) {
    storeLogger.error("Error saving project to server:", err);
    return null;
  }
}
async function loadProjectFromServer(store, projectId, pushHistoryFn) {
  try {
    const result = await loadProject(projectId);
    if (result.status === "success" && result.project) {
      store.project = result.project;
      pushHistoryFn();
      store.lastSaveProjectId = projectId;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project loaded from server:", projectId);
      return true;
    } else {
      storeLogger.error("Failed to load project:", result.message);
      return false;
    }
  } catch (err) {
    storeLogger.error("Error loading project from server:", err);
    return false;
  }
}
async function listServerProjects() {
  try {
    const result = await listProjects();
    if (result.status === "success" && result.projects) {
      return result.projects;
    }
    return [];
  } catch (err) {
    storeLogger.error("Error listing projects:", err);
    return [];
  }
}
async function deleteServerProject(projectId) {
  try {
    const result = await deleteProject(projectId);
    return result.status === "success";
  } catch (err) {
    storeLogger.error("Error deleting project:", err);
    return false;
  }
}
function startAutosave(store, performAutosaveFn) {
  if (store.autosaveTimerId !== null || !store.autosaveEnabled) {
    return;
  }
  store.autosaveTimerId = window.setInterval(
    performAutosaveFn,
    store.autosaveIntervalMs
  );
  storeLogger.info("Autosave started with interval:", store.autosaveIntervalMs);
}
function stopAutosave(store) {
  if (store.autosaveTimerId !== null && store.autosaveTimerId !== void 0) {
    window.clearInterval(store.autosaveTimerId);
    store.autosaveTimerId = null;
    storeLogger.info("Autosave stopped");
  }
}
function configureAutosave(store, options, performAutosaveFn) {
  if (options.enabled !== void 0) {
    store.autosaveEnabled = options.enabled;
  }
  if (options.intervalMs !== void 0) {
    store.autosaveIntervalMs = options.intervalMs;
  }
  stopAutosave(store);
  if (store.autosaveEnabled) {
    startAutosave(store, performAutosaveFn);
  }
}
async function performAutosave(store) {
  if (!store.hasUnsavedChanges) return;
  try {
    const existingProjectId = store.lastSaveProjectId || void 0;
    const result = await saveProject(store.project, existingProjectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Autosaved project:", result.project_id);
    } else {
      storeLogger.error("Autosave failed:", result.message);
    }
  } catch (error) {
    storeLogger.error("Autosave failed:", error);
  }
}
function markUnsavedChanges(store) {
  store.hasUnsavedChanges = true;
}
function findUsedAssetIds(store) {
  const usedIds = /* @__PURE__ */ new Set();
  for (const comp of Object.values(store.project.compositions)) {
    for (const layer of comp.layers) {
      if (layer.data && typeof layer.data === "object") {
        const data = layer.data;
        if (data.assetId && typeof data.assetId === "string") {
          usedIds.add(data.assetId);
        }
        if (data.sourceAssetId && typeof data.sourceAssetId === "string") {
          usedIds.add(data.sourceAssetId);
        }
        if (data.materials && Array.isArray(data.materials)) {
          for (const mat of data.materials) {
            if (mat.textureId) usedIds.add(mat.textureId);
            if (mat.normalMapId) usedIds.add(mat.normalMapId);
            if (mat.roughnessMapId) usedIds.add(mat.roughnessMapId);
          }
        }
        if (data.spriteSheetAssetId) {
          usedIds.add(data.spriteSheetAssetId);
        }
        if (data.environmentMapId) {
          usedIds.add(data.environmentMapId);
        }
      }
    }
  }
  return usedIds;
}
function removeUnusedAssets(store) {
  const usedIds = findUsedAssetIds(store);
  const assets = store.project.assets;
  const removedNames = [];
  let removedCount = 0;
  for (const assetId of Object.keys(assets)) {
    if (!usedIds.has(assetId)) {
      const asset = assets[assetId];
      removedNames.push(asset.filename || assetId);
      delete assets[assetId];
      removedCount++;
    }
  }
  if (removedCount > 0) {
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    pushHistory(store);
    storeLogger.info(`Removed ${removedCount} unused assets:`, removedNames);
  }
  return { removed: removedCount, assetNames: removedNames };
}
function getAssetUsageStats(store) {
  const usedIds = findUsedAssetIds(store);
  const assets = store.project.assets;
  const unusedNames = [];
  for (const assetId of Object.keys(assets)) {
    if (!usedIds.has(assetId)) {
      unusedNames.push(assets[assetId].filename || assetId);
    }
  }
  return {
    total: Object.keys(assets).length,
    used: usedIds.size,
    unused: unusedNames.length,
    unusedNames
  };
}
async function collectFiles(store, options = {}) {
  const { includeUnused = false, projectName } = options;
  const JSZip = (await import('./weyl-export-vendor.js').then(n => n.j)).default;
  const zip = new JSZip();
  const folderName = projectName || store.project.meta.name || "weyl-project";
  const folder = zip.folder(folderName);
  if (!folder) throw new Error("Failed to create ZIP folder");
  const usedIds = includeUnused ? null : findUsedAssetIds(store);
  const assets = store.project.assets;
  const assetsFolder = folder.folder("assets");
  const assetManifest = {};
  for (const [assetId, asset] of Object.entries(assets)) {
    if (usedIds && !usedIds.has(assetId)) continue;
    const filename = asset.filename || `${assetId}.${getExtensionForAsset(asset)}`;
    assetManifest[assetId] = `assets/${filename}`;
    if (asset.data) {
      if (asset.data.startsWith("data:")) {
        const base64Data = asset.data.split(",")[1];
        if (base64Data) {
          assetsFolder?.file(filename, base64Data, { base64: true });
        }
      } else if (asset.data.startsWith("blob:") || asset.data.startsWith("http")) {
        try {
          const response = await fetch(asset.data);
          const blob = await response.blob();
          assetsFolder?.file(filename, blob);
        } catch (e) {
          storeLogger.warn(`Failed to fetch asset ${assetId}:`, e);
        }
      } else {
        assetsFolder?.file(filename, asset.data, { base64: true });
      }
    }
  }
  const exportProject2 = structuredClone(toRaw(store.project));
  exportProject2.meta.exportedAt = (/* @__PURE__ */ new Date()).toISOString();
  exportProject2._assetManifest = assetManifest;
  folder.file("project.weyl.json", JSON.stringify(exportProject2, null, 2));
  const zipBlob = await zip.generateAsync({
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: { level: 6 }
  });
  storeLogger.info(`Collected files: ${Object.keys(assetManifest).length} assets, project JSON`);
  return zipBlob;
}
function getExtensionForAsset(asset) {
  if (asset.filename) {
    const ext = asset.filename.split(".").pop();
    if (ext) return ext;
  }
  switch (asset.type) {
    case "image":
      return "png";
    case "video":
      return "mp4";
    case "audio":
      return "mp3";
    case "model":
      return "glb";
    case "pointcloud":
      return "ply";
    default:
      return "bin";
  }
}
async function downloadCollectedFiles(store, options = {}) {
  const projectName = store.project.meta.name || "weyl-project";
  const zipBlob = await collectFiles(store, { ...options, projectName });
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${projectName}.zip`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  storeLogger.info(`Downloaded collected files: ${projectName}.zip`);
}

let worker = null;
let currentResolve = null;
let currentReject = null;
let currentOnProgress = null;
function ensureWorker() {
  if (!worker) {
    worker = new Worker(
      new URL(/* @vite-ignore */ "/worker-audioWorker.js", import.meta.url),
      { type: "module" }
    );
    worker.onmessage = (event) => {
      const message = event.data;
      switch (message.type) {
        case "progress":
          if (currentOnProgress) {
            currentOnProgress({
              phase: message.payload.phase,
              progress: message.payload.progress,
              message: message.payload.message
            });
          }
          break;
        case "complete":
          if (currentResolve) {
            currentResolve(message.payload);
            cleanup();
          }
          break;
        case "error":
          if (currentReject) {
            currentReject(new Error(message.payload.message));
            cleanup();
          }
          break;
      }
    };
    worker.onerror = (error) => {
      console.error("[AudioWorker] Worker error:", error);
      if (currentReject) {
        currentReject(new Error(`Worker error: ${error.message}`));
        cleanup();
      }
    };
  }
  return worker;
}
function cleanup() {
  currentResolve = null;
  currentReject = null;
  currentOnProgress = null;
}
function cancelAnalysis() {
  if (worker) {
    worker.postMessage({ type: "cancel" });
  }
}
async function analyzeAudioInWorker(audioBuffer, fps, options = {}) {
  const w = ensureWorker();
  if (currentResolve) {
    throw new Error("Analysis already in progress. Cancel it first.");
  }
  const channelData = audioBuffer.getChannelData(0);
  const channelDataCopy = new Float32Array(channelData);
  return new Promise((resolve, reject) => {
    currentResolve = resolve;
    currentReject = reject;
    currentOnProgress = options.onProgress || null;
    w.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: channelDataCopy,
          sampleRate: audioBuffer.sampleRate,
          fps
        }
      },
      [channelDataCopy.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function loadAndAnalyzeAudio(file, fps, options = {}) {
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 0,
      message: "Decoding audio file..."
    });
  }
  const arrayBuffer = await file.arrayBuffer();
  const audioContext = new AudioContext();
  let buffer;
  try {
    buffer = await audioContext.decodeAudioData(arrayBuffer);
  } finally {
    await audioContext.close();
  }
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 1,
      message: "Audio decoded successfully"
    });
  }
  const analysis = await analyzeAudioInWorker(buffer, fps, options);
  return { buffer, analysis };
}

function createDefaultAudioMapping(id, feature = "amplitude", target = "particle.emissionRate") {
  return {
    id: id || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature,
    target,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: false,
    threshold: 0,
    enabled: true,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class AudioReactiveMapper {
  analysis;
  mappings = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  releaseEnvelopes = /* @__PURE__ */ new Map();
  // ATI-style release tracking
  beatToggleStates = /* @__PURE__ */ new Map();
  // For beat toggle/flip
  peakData = null;
  constructor(analysis) {
    this.analysis = analysis;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(peakData) {
    this.peakData = peakData;
  }
  /**
   * Add a new mapping
   */
  addMapping(mapping) {
    this.mappings.set(mapping.id, mapping);
    this.smoothedValues.set(mapping.id, 0);
    this.releaseEnvelopes.set(mapping.id, 0);
    this.beatToggleStates.set(mapping.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(id) {
    this.mappings.delete(id);
    this.smoothedValues.delete(id);
    this.releaseEnvelopes.delete(id);
    this.beatToggleStates.delete(id);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(id, updates) {
    const mapping = this.mappings.get(id);
    if (mapping) {
      Object.assign(mapping, updates);
    }
  }
  /**
   * Get a specific mapping
   */
  getMapping(id) {
    return this.mappings.get(id);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(layerId) {
    return Array.from(this.mappings.values()).filter(
      (m) => m.targetLayerId === layerId || m.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(target) {
    return Array.from(this.mappings.values()).filter((m) => m.target === target);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(feature, frame) {
    if (feature === "peaks") {
      if (this.peakData) {
        return isPeakAtFrame(this.peakData, frame) ? 1 : 0;
      }
      return 0;
    }
    return getFeatureAtFrame(this.analysis, feature, frame);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(mappingId, frame) {
    const mapping = this.mappings.get(mappingId);
    if (!mapping || !mapping.enabled) return 0;
    let value = this.getFeatureAtFrame(mapping.feature, frame);
    if (value < mapping.threshold) {
      value = 0;
    }
    if (mapping.amplitudeCurve !== 1) {
      value = Math.pow(value, mapping.amplitudeCurve);
    }
    const releaseEnvelope = this.releaseEnvelopes.get(mappingId) || 0;
    if (value > releaseEnvelope) {
      this.releaseEnvelopes.set(mappingId, value);
    } else {
      const decayRate = 1 - mapping.release * 0.98;
      const newEnvelope = releaseEnvelope * decayRate;
      this.releaseEnvelopes.set(mappingId, newEnvelope);
      value = Math.max(value, newEnvelope);
    }
    if (mapping.beatResponse !== "none") {
      const isBeat = this.analysis.onsets.includes(frame) && this.getFeatureAtFrame(mapping.feature, frame) > mapping.beatThreshold;
      if (isBeat) {
        const currentToggle = this.beatToggleStates.get(mappingId) || 0;
        switch (mapping.beatResponse) {
          case "flip":
            this.beatToggleStates.set(mappingId, currentToggle === 0 ? 1 : 0);
            break;
          case "pulse":
            value = 1;
            break;
          case "toggle":
            const newToggle = currentToggle === 0 ? 1 : 0;
            this.beatToggleStates.set(mappingId, newToggle);
            value = newToggle;
            break;
        }
      }
      if (mapping.beatResponse === "flip") {
        const toggle = this.beatToggleStates.get(mappingId) || 0;
        if (toggle === 1) {
          value = 1 - value;
        }
      }
    }
    value = this.applyCurve(value, mapping.curve);
    if (mapping.invert) {
      value = 1 - value;
    }
    value *= mapping.sensitivity;
    value += mapping.offset;
    value = Math.max(mapping.min, Math.min(mapping.max, value));
    const prevSmoothed = this.smoothedValues.get(mappingId) || 0;
    const smoothed = prevSmoothed * mapping.smoothing + value * (1 - mapping.smoothing);
    this.smoothedValues.set(mappingId, smoothed);
    return smoothed;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(layerId, frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      if (mapping.targetLayerId && mapping.targetLayerId !== layerId) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(value, curve) {
    const clamped = Math.max(0, Math.min(1, value));
    switch (curve) {
      case "exponential":
        return clamped * clamped;
      case "logarithmic":
        return Math.sqrt(clamped);
      case "smoothstep":
        return clamped * clamped * (3 - 2 * clamped);
      case "bounce":
        if (clamped < 0.5) {
          return 2 * clamped * clamped;
        } else {
          const t = clamped - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * t, 2));
        }
      case "linear":
      default:
        return clamped;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
    for (const mapping of this.mappings.values()) {
      this.smoothedValues.set(mapping.id, 0);
      this.releaseEnvelopes.set(mapping.id, 0);
      this.beatToggleStates.set(mapping.id, 0);
    }
  }
  /**
   * Update analysis data
   */
  setAnalysis(analysis) {
    this.analysis = analysis;
    this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear();
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(mappings) {
    this.clear();
    for (const mapping of mappings) {
      this.addMapping(mapping);
    }
  }
}
function getFeatureDisplayName(feature) {
  const names = {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  };
  return names[feature] || feature;
}
function getTargetDisplayName(target) {
  const splineMatch = target.match(/^spline\.controlPoint\.(\d+)\.(x|y|depth)$/);
  if (splineMatch) {
    const index = splineMatch[1];
    const prop = splineMatch[2] === "x" ? "X" : splineMatch[2] === "y" ? "Y" : "Depth";
    return `Spline: Control Point ${index} ${prop}`;
  }
  const names = {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  };
  return names[target] || target;
}
function getAllFeatures() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function getFeaturesByCategory() {
  return {
    "Energy": ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    "Spectral": ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    "Events": ["onsets", "peaks"],
    "Harmonic": ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function getTargetsByCategory() {
  return {
    "Particle": [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    "Depthflow": [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    "Path": ["path.position"],
    "Layer": [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
    // Note: 'Spline' targets are generated dynamically based on control point count
    // Use createSplineControlPointTargets() to get targets for a specific spline
  };
}

const DEFAULT_CONFIG$2 = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: true,
  beatThreshold: 0.05,
  motionBlur: false,
  motionBlurStrength: 0.5
};
class AudioPathAnimator {
  config;
  state;
  pathSegments = [];
  totalLength = 0;
  releaseState = 0;
  // For amplitude mode release tracking
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$2, ...config };
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(pathData) {
    this.pathSegments = this.parsePath(pathData);
    this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(pathData) {
    const segments = [];
    const commands = pathData.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let currentX = 0;
    let currentY = 0;
    for (const cmd of commands) {
      const type = cmd[0].toUpperCase();
      const nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter((n) => !isNaN(n));
      switch (type) {
        case "M":
          currentX = nums[0] || 0;
          currentY = nums[1] || 0;
          segments.push({
            type: "M",
            points: [currentX, currentY],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          segments.push({
            type: "L",
            points: [currentX, currentY, nums[0], nums[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[0];
          currentY = nums[1];
          break;
        case "C":
          segments.push({
            type: "C",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[4];
          currentY = nums[5];
          break;
        case "Q":
          segments.push({
            type: "Q",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[2];
          currentY = nums[3];
          break;
        case "Z":
          const firstMove = segments.find((s) => s.type === "M");
          if (firstMove) {
            segments.push({
              type: "L",
              points: [currentX, currentY, firstMove.points[0], firstMove.points[1]],
              length: 0,
              startT: 0,
              endT: 0
            });
          }
          break;
      }
    }
    return segments;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let totalLength = 0;
    for (const segment of this.pathSegments) {
      switch (segment.type) {
        case "M":
          segment.length = 0;
          break;
        case "L":
          segment.length = this.lineLength(segment.points);
          break;
        case "C":
          segment.length = this.bezierLength(segment.points, 3);
          break;
        case "Q":
          segment.length = this.bezierLength(segment.points, 2);
          break;
      }
      segment.startT = totalLength;
      totalLength += segment.length;
      segment.endT = totalLength;
    }
    this.totalLength = totalLength;
    if (this.totalLength > 0) {
      for (const segment of this.pathSegments) {
        segment.startT /= this.totalLength;
        segment.endT /= this.totalLength;
      }
    }
  }
  lineLength(points) {
    const dx = points[2] - points[0];
    const dy = points[3] - points[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  bezierLength(points, degree) {
    const steps = 20;
    let length = 0;
    let prevX = points[0];
    let prevY = points[1];
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const { x, y } = this.getBezierPoint(points, t, degree);
      const dx = x - prevX;
      const dy = y - prevY;
      length += Math.sqrt(dx * dx + dy * dy);
      prevX = x;
      prevY = y;
    }
    return length;
  }
  getBezierPoint(points, t, degree) {
    if (degree === 2) {
      const mt = 1 - t;
      return {
        x: mt * mt * points[0] + 2 * mt * t * points[2] + t * t * points[4],
        y: mt * mt * points[1] + 2 * mt * t * points[3] + t * t * points[5]
      };
    } else {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;
      return {
        x: mt2 * mt * points[0] + 3 * mt2 * t * points[2] + 3 * mt * t2 * points[4] + t2 * t * points[6],
        y: mt2 * mt * points[1] + 3 * mt2 * t * points[3] + 3 * mt * t2 * points[5] + t2 * t * points[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(audioValue, isBeat) {
    this.state.previousPosition = this.state.position;
    const smoothedInput = this.state.smoothedValue * this.config.smoothing + audioValue * (1 - this.config.smoothing);
    this.state.smoothedValue = smoothedInput;
    if (this.config.movementMode === "amplitude") {
      this.updateAmplitudeMode(smoothedInput);
    } else {
      this.updateAccumulateMode(smoothedInput, isBeat);
    }
    const pathPoint = this.getPositionOnPath(this.state.position);
    this.state.x = pathPoint.x;
    this.state.y = pathPoint.y;
    this.state.angle = pathPoint.angle;
    return { ...this.state };
  }
  updateAmplitudeMode(audioValue) {
    let processedValue = Math.pow(audioValue, this.config.amplitudeCurve);
    if (processedValue > this.releaseState) {
      this.releaseState = processedValue;
    } else {
      const decayRate = 1 - this.config.release * 0.95;
      this.releaseState *= decayRate;
    }
    const finalValue = Math.max(processedValue, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, finalValue * this.config.sensitivity));
  }
  updateAccumulateMode(audioValue, isBeat) {
    if (this.config.flipOnBeat && isBeat && audioValue > this.config.beatThreshold) {
      this.state.direction *= -1;
    }
    const delta = audioValue * this.config.sensitivity * 0.02 * this.state.direction;
    let newPosition = this.state.position + delta;
    if (newPosition > 1) {
      newPosition = 2 - newPosition;
      this.state.direction = -1;
    } else if (newPosition < 0) {
      newPosition = -newPosition;
      this.state.direction = 1;
    }
    this.state.position = Math.max(0, Math.min(1, newPosition));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(t) {
    t = Math.max(0, Math.min(1, t));
    if (this.pathSegments.length === 0) {
      return { x: 0, y: 0, angle: 0 };
    }
    let segment = this.pathSegments[0];
    for (const seg of this.pathSegments) {
      if (seg.type !== "M" && t >= seg.startT && t <= seg.endT) {
        segment = seg;
        break;
      }
    }
    if (segment.type === "M") {
      return { x: segment.points[0], y: segment.points[1], angle: 0 };
    }
    const segmentT = segment.endT > segment.startT ? (t - segment.startT) / (segment.endT - segment.startT) : 0;
    let x, y;
    let tangentX, tangentY;
    switch (segment.type) {
      case "L":
        x = segment.points[0] + (segment.points[2] - segment.points[0]) * segmentT;
        y = segment.points[1] + (segment.points[3] - segment.points[1]) * segmentT;
        tangentX = segment.points[2] - segment.points[0];
        tangentY = segment.points[3] - segment.points[1];
        break;
      case "Q": {
        const result = this.getBezierPoint(segment.points, segmentT, 2);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        tangentX = 2 * mt * (segment.points[2] - segment.points[0]) + 2 * segmentT * (segment.points[4] - segment.points[2]);
        tangentY = 2 * mt * (segment.points[3] - segment.points[1]) + 2 * segmentT * (segment.points[5] - segment.points[3]);
        break;
      }
      case "C": {
        const result = this.getBezierPoint(segment.points, segmentT, 3);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        const mt2 = mt * mt;
        const t2 = segmentT * segmentT;
        tangentX = 3 * mt2 * (segment.points[2] - segment.points[0]) + 6 * mt * segmentT * (segment.points[4] - segment.points[2]) + 3 * t2 * (segment.points[6] - segment.points[4]);
        tangentY = 3 * mt2 * (segment.points[3] - segment.points[1]) + 6 * mt * segmentT * (segment.points[5] - segment.points[3]) + 3 * t2 * (segment.points[7] - segment.points[5]);
        break;
      }
      default:
        x = 0;
        y = 0;
        tangentX = 1;
        tangentY = 0;
    }
    const angle = Math.atan2(tangentY, tangentX);
    return { x, y, angle };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(steps = 5) {
    if (!this.config.motionBlur) return [];
    const trail = [];
    const startT = this.state.previousPosition;
    const endT = this.state.position;
    for (let i = 0; i <= steps; i++) {
      const t = startT + (endT - startT) * (i / steps);
      const pos = this.getPositionOnPath(t);
      const opacity = i / steps * this.config.motionBlurStrength;
      trail.push({ x: pos.x, y: pos.y, opacity });
    }
    return trail;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
    this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}

async function loadAudio(store, file) {
  store.audioFile = file;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioLoadingState = "decoding";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "Preparing...";
  store.audioLoadingError = null;
  try {
    const result = await loadAndAnalyzeAudio(
      file,
      store.project.composition.fps,
      {
        onProgress: (progress) => {
          if (progress.phase === "decoding") {
            store.audioLoadingState = "decoding";
          } else {
            store.audioLoadingState = "analyzing";
          }
          store.audioLoadingProgress = progress.progress;
          store.audioLoadingPhase = progress.message;
        }
      }
    );
    store.audioBuffer = result.buffer;
    store.audioAnalysis = result.analysis;
    store.audioLoadingState = "complete";
    store.audioLoadingProgress = 1;
    store.audioLoadingPhase = "Complete";
    initializeAudioReactiveMapper(store);
    if (store.propertyDriverSystem && store.audioAnalysis) {
      store.propertyDriverSystem.setAudioAnalysis(store.audioAnalysis);
    }
    storeLogger.debug("Audio loaded:", {
      duration: store.audioBuffer.duration,
      bpm: store.audioAnalysis.bpm,
      frameCount: store.audioAnalysis.frameCount
    });
  } catch (error) {
    storeLogger.error("Failed to load audio:", error);
    store.audioFile = null;
    store.audioBuffer = null;
    store.audioAnalysis = null;
    store.audioReactiveMapper = null;
    store.audioLoadingState = "error";
    store.audioLoadingError = error.message;
  }
}
function cancelAudioLoad(store) {
  cancelAnalysis();
  store.audioLoadingState = "idle";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "";
  store.audioLoadingError = null;
}
function clearAudio(store) {
  cancelAudioLoad(store);
  store.audioFile = null;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioMappings.clear();
}
function getAudioFeatureAtFrame(store, feature, frame) {
  if (!store.audioAnalysis) return 0;
  return getFeatureAtFrame(store.audioAnalysis, feature, frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function setPeakData(store, peakData) {
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
}
function detectAudioPeaks(store, config) {
  if (!store.audioAnalysis) return null;
  const weights = store.audioAnalysis.amplitudeEnvelope;
  const peakData = detectPeaks(weights, config);
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
  return peakData;
}
function addAudioMapping(store, mapping) {
  store.audioReactiveMappings.push(mapping);
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.addMapping(mapping);
  }
}
function removeAudioMapping(store, mappingId) {
  const index = store.audioReactiveMappings.findIndex((m) => m.id === mappingId);
  if (index >= 0) {
    store.audioReactiveMappings.splice(index, 1);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.removeMapping(mappingId);
  }
}
function updateAudioMapping(store, mappingId, updates) {
  const mapping = store.audioReactiveMappings.find((m) => m.id === mappingId);
  if (mapping) {
    Object.assign(mapping, updates);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.updateMapping(mappingId, updates);
  }
}
function getMappedValueAtFrame(store, mappingId, frame) {
  if (!store.audioReactiveMapper) return 0;
  return store.audioReactiveMapper.getValueAtFrame(mappingId, frame);
}
function getAllMappedValuesAtFrame(store, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getAllValuesAtFrame(frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function getActiveMappingsForLayer(store, layerId) {
  return store.audioReactiveMappings.filter(
    (m) => m.enabled && (m.targetLayerId === layerId || m.targetLayerId === void 0)
  );
}
function getAudioReactiveValuesForLayer(store, layerId, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getValuesForLayerAtFrame(layerId, frame);
}
function isBeatAtCurrentFrame(store) {
  if (!store.audioAnalysis) return false;
  return isBeatAtFrame(store.audioAnalysis, store.getActiveComp()?.currentFrame ?? 0);
}
function initializeAudioReactiveMapper(store) {
  if (!store.audioAnalysis) return;
  store.audioReactiveMapper = new AudioReactiveMapper(store.audioAnalysis);
  for (const mapping of store.audioReactiveMappings) {
    store.audioReactiveMapper.addMapping(mapping);
  }
  if (store.peakData) {
    store.audioReactiveMapper.setPeakData(store.peakData);
  }
}
function createPathAnimator(store, layerId, config = {}) {
  const animator = new AudioPathAnimator(config);
  store.pathAnimators.set(layerId, animator);
}
function setPathAnimatorPath(store, layerId, pathData) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setPath(pathData);
  }
}
function updatePathAnimatorConfig(store, layerId, config) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setConfig(config);
  }
}
function removePathAnimator(store, layerId) {
  store.pathAnimators.delete(layerId);
}
function getPathAnimator(store, layerId) {
  return store.pathAnimators.get(layerId);
}
function updatePathAnimators(store) {
  if (!store.audioAnalysis) return;
  const frame = store.getActiveComp()?.currentFrame ?? 0;
  const amplitude = getFeatureAtFrame(store.audioAnalysis, "amplitude", frame);
  const isBeat = isBeatAtFrame(store.audioAnalysis, frame);
  for (const [_layerId, animator] of store.pathAnimators) {
    animator.update(amplitude, isBeat);
  }
}
function resetPathAnimators(store) {
  for (const animator of store.pathAnimators.values()) {
    animator.reset();
  }
}
function applyAudioToParticles(store, layerId, mapping) {
  const existing = store.audioMappings.get(layerId) || [];
  existing.push(mapping);
  store.audioMappings.set(layerId, existing);
}
function removeLegacyAudioMapping(store, layerId, index) {
  const mappings = store.audioMappings.get(layerId);
  if (mappings) {
    mappings.splice(index, 1);
    if (mappings.length === 0) {
      store.audioMappings.delete(layerId);
    }
  }
}
function getAudioMappingsForLayer(store, layerId) {
  return store.audioMappings.get(layerId) || [];
}

function getEvaluatedLayerProperties(store, layerId, frame) {
  if (!store.propertyDriverSystem) {
    return /* @__PURE__ */ new Map();
  }
  const layer = store.getLayer(layerId);
  if (!layer) return /* @__PURE__ */ new Map();
  const baseValues = /* @__PURE__ */ new Map();
  const pos = interpolateProperty(layer.transform.position, frame);
  baseValues.set("transform.position.x", pos.x);
  baseValues.set("transform.position.y", pos.y);
  const scale = interpolateProperty(layer.transform.scale, frame);
  baseValues.set("transform.scale.x", scale.x);
  baseValues.set("transform.scale.y", scale.y);
  baseValues.set("transform.rotation", interpolateProperty(layer.transform.rotation, frame));
  if (layer.transform.rotationX) {
    baseValues.set("transform.rotationX", interpolateProperty(layer.transform.rotationX, frame));
  }
  if (layer.transform.rotationY) {
    baseValues.set("transform.rotationY", interpolateProperty(layer.transform.rotationY, frame));
  }
  if (layer.transform.rotationZ) {
    baseValues.set("transform.rotationZ", interpolateProperty(layer.transform.rotationZ, frame));
  }
  baseValues.set("opacity", interpolateProperty(layer.opacity, frame));
  return store.propertyDriverSystem.evaluateLayerDrivers(layerId, frame, baseValues);
}
function addPropertyDriver(store, driver) {
  if (store.propertyDriverSystem) {
    const added = store.propertyDriverSystem.addDriver(driver);
    if (!added) {
      storeLogger.warn("Cannot add property driver: would create circular dependency");
      return false;
    }
  }
  store.propertyDrivers.push(driver);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return true;
}
function createAudioPropertyDriver(store, targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createAudioDriver(targetLayerId, targetProperty, audioFeature, options);
  addPropertyDriver(store, driver);
  return driver;
}
function createPropertyLinkDriver(store, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyLink(
    targetLayerId,
    targetProperty,
    sourceLayerId,
    sourceProperty,
    options
  );
  const success = addPropertyDriver(store, driver);
  if (!success) {
    return null;
  }
  return driver;
}
function removePropertyDriver(store, driverId) {
  const index = store.propertyDrivers.findIndex((d) => d.id === driverId);
  if (index >= 0) {
    store.propertyDrivers.splice(index, 1);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.removeDriver(driverId);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function updatePropertyDriver(store, driverId, updates) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    Object.assign(driver, updates);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.updateDriver(driverId, updates);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function getDriversForLayer(store, layerId) {
  return store.propertyDrivers.filter((d) => d.targetLayerId === layerId);
}
function togglePropertyDriver(store, driverId) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    driver.enabled = !driver.enabled;
    if (store.propertyDriverSystem) {
      store.propertyDriverSystem.updateDriver(driverId, { enabled: driver.enabled });
    }
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}

async function estimateVRAM(adapter) {
  try {
    const device = await adapter.requestDevice();
    const maxBufferSize = device.limits.maxBufferSize;
    device.destroy();
    return Math.round(maxBufferSize * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function detectGPUTier() {
  if ("gpu" in navigator) {
    try {
      const gpu = navigator.gpu;
      const adapter = await gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (adapter) {
        let deviceName = "";
        if ("info" in adapter) {
          const info = adapter.info;
          deviceName = info?.device || info?.description || "";
        }
        if (deviceName.includes("RTX 50") || deviceName.toLowerCase().includes("blackwell") || deviceName.includes("B100") || deviceName.includes("B200")) {
          return {
            tier: "blackwell",
            vram: await estimateVRAM(adapter),
            features: ["fp4_tensor", "webgpu", "cuda_12"]
          };
        }
        return {
          tier: "webgpu",
          vram: await estimateVRAM(adapter),
          features: ["webgpu"]
        };
      }
    } catch (error) {
      engineLogger.warn("WebGPU detection failed:", error);
    }
  }
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2");
  if (gl) {
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
    engineLogger.debug("WebGL renderer:", renderer);
    return {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}

const TIER_CONFIGS = {
  blackwell: {
    maxFrames: 500,
    maxMemoryBytes: 4 * 1024 * 1024 * 1024,
    // 4GB
    compression: false,
    // Fast GPU, no need for compression
    preCacheWindow: 30
  },
  webgpu: {
    maxFrames: 200,
    maxMemoryBytes: 1 * 1024 * 1024 * 1024,
    // 1GB
    compression: true,
    preCacheWindow: 15
  },
  webgl: {
    maxFrames: 100,
    maxMemoryBytes: 512 * 1024 * 1024,
    // 512MB
    compression: true,
    preCacheWindow: 10
  },
  cpu: {
    maxFrames: 50,
    maxMemoryBytes: 256 * 1024 * 1024,
    // 256MB
    compression: true,
    preCacheWindow: 5
  }
};
const DEFAULT_CONFIG$1 = {
  maxFrames: 100,
  maxMemoryBytes: 512 * 1024 * 1024,
  compression: true,
  compressionQuality: 0.92,
  preCacheWindow: 10,
  predictivePreCache: true
};
class LRUTracker {
  nodeMap = /* @__PURE__ */ new Map();
  head = null;
  // Oldest
  tail = null;
  // Most recent
  add(key) {
    if (this.nodeMap.has(key)) {
      this.moveToEnd(key);
      return;
    }
    const node = { key, prev: null, next: null };
    if (!this.tail) {
      this.head = this.tail = node;
    } else {
      node.prev = this.tail;
      this.tail.next = node;
      this.tail = node;
    }
    this.nodeMap.set(key, node);
  }
  moveToEnd(key) {
    const node = this.nodeMap.get(key);
    if (!node || node === this.tail) return;
    if (node.prev) node.prev.next = node.next;
    if (node.next) node.next.prev = node.prev;
    if (node === this.head) this.head = node.next;
    node.prev = this.tail;
    node.next = null;
    if (this.tail) this.tail.next = node;
    this.tail = node;
  }
  remove(key) {
    const node = this.nodeMap.get(key);
    if (!node) return;
    if (node.prev) node.prev.next = node.next;
    if (node.next) node.next.prev = node.prev;
    if (node === this.head) this.head = node.next;
    if (node === this.tail) this.tail = node.prev;
    this.nodeMap.delete(key);
  }
  getOldest() {
    return this.head?.key ?? null;
  }
  has(key) {
    return this.nodeMap.has(key);
  }
  clear() {
    this.nodeMap.clear();
    this.head = null;
    this.tail = null;
  }
  get size() {
    return this.nodeMap.size;
  }
}
class FrameCache {
  cache = /* @__PURE__ */ new Map();
  lru = new LRUTracker();
  // O(1) LRU tracking
  config;
  currentMemory = 0;
  stats = { hits: 0, misses: 0 };
  // Secondary index: compositionId -> Set of cache keys (for O(1) clearComposition)
  compositionKeyMap = /* @__PURE__ */ new Map();
  // Pre-caching state
  preCacheQueue = [];
  isPreCaching = false;
  preCacheAbort = null;
  // Composition state tracking
  stateHashCache = /* @__PURE__ */ new Map();
  // Frame render callback (set by engine)
  renderFrame = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$1, ...config };
  }
  /**
   * Initialize cache with GPU-tier-appropriate settings
   */
  async initializeForGPU() {
    const tier = await detectGPUTier();
    const tierConfig = TIER_CONFIGS[tier.tier];
    this.config = { ...this.config, ...tierConfig };
  }
  /**
   * Set the frame render callback
   * This is called to render frames for pre-caching
   */
  setRenderCallback(callback) {
    this.renderFrame = callback;
  }
  /**
   * Generate a cache key for a frame
   */
  getCacheKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Get a cached frame
   * @returns The cached frame or null if not found/invalid
   */
  get(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.lru.moveToEnd(key);
    this.stats.hits++;
    if (cached.compressed) {
      return null;
    }
    return cached.data;
  }
  /**
   * Get a cached frame (async, supports compression)
   */
  async getAsync(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.lru.moveToEnd(key);
    this.stats.hits++;
    if (cached.compressed) {
      return this.decompressFrame(cached);
    }
    return cached.data;
  }
  /**
   * Cache a frame
   */
  async set(frame, compositionId, imageData, stateHash) {
    const key = this.getCacheKey(frame, compositionId);
    if (this.cache.has(key)) {
      this.remove(frame, compositionId);
    }
    let data = imageData;
    let compressed = false;
    let size = imageData.width * imageData.height * 4;
    if (this.config.compression) {
      const compressedData = await this.compressFrame(imageData);
      if (compressedData.size < size * 0.7) {
        data = compressedData;
        compressed = true;
        size = compressedData.size;
      }
    }
    await this.ensureCapacity(size);
    const cachedFrame = {
      frame,
      compositionId,
      data,
      compressed,
      width: imageData.width,
      height: imageData.height,
      timestamp: Date.now(),
      size,
      stateHash
    };
    this.cache.set(key, cachedFrame);
    this.lru.add(key);
    this.currentMemory += size;
    let keySet = this.compositionKeyMap.get(compositionId);
    if (!keySet) {
      keySet = /* @__PURE__ */ new Set();
      this.compositionKeyMap.set(compositionId, keySet);
    }
    keySet.add(key);
  }
  /**
   * Remove a cached frame - O(1)
   */
  remove(frame, compositionId) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (cached) {
      this.currentMemory -= cached.size;
      this.cache.delete(key);
      this.lru.remove(key);
      const keySet = this.compositionKeyMap.get(compositionId);
      if (keySet) {
        keySet.delete(key);
        if (keySet.size === 0) {
          this.compositionKeyMap.delete(compositionId);
        }
      }
    }
  }
  /**
   * Check if a frame is cached
   */
  has(frame, compositionId) {
    return this.cache.has(this.getCacheKey(frame, compositionId));
  }
  /**
   * Clear all cached frames for a composition - O(k) where k = frames for this composition
   * Uses secondary index for direct lookup instead of O(n) iteration
   */
  clearComposition(compositionId) {
    const keySet = this.compositionKeyMap.get(compositionId);
    if (!keySet) return;
    for (const key of Array.from(keySet)) {
      const cached = this.cache.get(key);
      if (cached) {
        this.currentMemory -= cached.size;
      }
      this.cache.delete(key);
      this.lru.remove(key);
    }
    this.compositionKeyMap.delete(compositionId);
  }
  /**
   * Clear all cached frames
   */
  clear() {
    this.cache.clear();
    this.lru.clear();
    this.compositionKeyMap.clear();
    this.currentMemory = 0;
    this.stats = { hits: 0, misses: 0 };
    this.abortPreCache();
  }
  /**
   * Invalidate cache for a composition (when state changes)
   */
  invalidate(compositionId, newStateHash) {
    const oldHash = this.stateHashCache.get(compositionId);
    if (oldHash !== newStateHash) {
      this.clearComposition(compositionId);
      this.stateHashCache.set(compositionId, newStateHash);
    }
  }
  /**
   * Start predictive pre-caching around the current frame
   */
  async startPreCache(currentFrame, compositionId, stateHash, direction = "both") {
    if (!this.config.predictivePreCache || !this.renderFrame) {
      return;
    }
    this.abortPreCache();
    this.preCacheAbort = new AbortController();
    const signal = this.preCacheAbort.signal;
    this.preCacheQueue = [];
    const window = this.config.preCacheWindow;
    for (let i = 1; i <= window; i++) {
      if (direction !== "backward") {
        this.preCacheQueue.push({
          frame: currentFrame + i,
          compositionId,
          priority: window - i
          // Closer frames have higher priority
        });
      }
      if (direction !== "forward") {
        this.preCacheQueue.push({
          frame: currentFrame - i,
          compositionId,
          priority: window - i
        });
      }
    }
    this.preCacheQueue.sort((a, b) => b.priority - a.priority);
    this.isPreCaching = true;
    for (const item of this.preCacheQueue) {
      if (signal.aborted) {
        break;
      }
      if (!this.has(item.frame, item.compositionId)) {
        try {
          const imageData = await this.renderFrame(item.frame);
          if (!signal.aborted) {
            await this.set(item.frame, item.compositionId, imageData, stateHash);
          }
        } catch (error) {
          console.warn(`Pre-cache failed for frame ${item.frame}:`, error);
        }
      }
    }
    this.isPreCaching = false;
  }
  /**
   * Abort any ongoing pre-cache operation
   */
  abortPreCache() {
    if (this.preCacheAbort) {
      this.preCacheAbort.abort();
      this.preCacheAbort = null;
    }
    this.preCacheQueue = [];
    this.isPreCaching = false;
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    return {
      cachedFrames: this.cache.size,
      memoryUsed: this.currentMemory,
      hitRatio: total > 0 ? this.stats.hits / total : 0,
      hits: this.stats.hits,
      misses: this.stats.misses
    };
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  async ensureCapacity(requiredSize) {
    while ((this.cache.size >= this.config.maxFrames || this.currentMemory + requiredSize > this.config.maxMemoryBytes) && this.lru.size > 0) {
      const oldestKey = this.lru.getOldest();
      if (!oldestKey) break;
      const cached = this.cache.get(oldestKey);
      if (cached) {
        this.currentMemory -= cached.size;
        this.cache.delete(oldestKey);
        const compositionId = oldestKey.split(":")[0];
        const keySet = this.compositionKeyMap.get(compositionId);
        if (keySet) {
          keySet.delete(oldestKey);
          if (keySet.size === 0) {
            this.compositionKeyMap.delete(compositionId);
          }
        }
      }
      this.lru.remove(oldestKey);
    }
  }
  async compressFrame(imageData) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: "image/webp",
      quality: this.config.compressionQuality
    });
  }
  async decompressFrame(cached) {
    if (!(cached.data instanceof Blob)) {
      return cached.data;
    }
    const bitmap = await createImageBitmap(cached.data);
    const canvas = new OffscreenCanvas(cached.width, cached.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bitmap, 0, 0);
    bitmap.close();
    return ctx.getImageData(0, 0, cached.width, cached.height);
  }
}
let globalFrameCache = null;
function getFrameCache() {
  if (!globalFrameCache) {
    globalFrameCache = new FrameCache();
  }
  return globalFrameCache;
}
async function initializeFrameCache() {
  const cache = getFrameCache();
  await cache.initializeForGPU();
  return cache;
}

async function initializeCache(store) {
  if (store.frameCacheEnabled) {
    await initializeFrameCache();
    storeLogger.info("Frame cache initialized");
  }
}
function setFrameCacheEnabled(store, enabled) {
  store.frameCacheEnabled = enabled;
  if (!enabled) {
    clearFrameCache();
  }
  storeLogger.info("Frame cache", enabled ? "enabled" : "disabled");
}
function getCachedFrame(store, frame) {
  if (!store.frameCacheEnabled) return null;
  const cache = getFrameCache();
  return cache.get(frame, store.activeCompositionId, store.projectStateHash);
}
async function cacheFrame(store, frame, imageData) {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.set(frame, store.activeCompositionId, imageData, store.projectStateHash);
}
function isFrameCached(store, frame) {
  if (!store.frameCacheEnabled) return false;
  const cache = getFrameCache();
  return cache.has(frame, store.activeCompositionId);
}
async function startPreCache(store, currentFrame, direction = "both") {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.startPreCache(currentFrame, store.activeCompositionId, store.projectStateHash, direction);
}
function invalidateFrameCache(store) {
  store.projectStateHash = computeProjectHash(store);
  const cache = getFrameCache();
  cache.invalidate(store.activeCompositionId, store.projectStateHash);
}
function clearFrameCache() {
  const cache = getFrameCache();
  cache.clear();
  storeLogger.info("Frame cache cleared");
}
function getFrameCacheStats() {
  const cache = getFrameCache();
  return cache.getStats();
}
function computeProjectHash(store) {
  const comp = store.project.compositions[store.activeCompositionId];
  if (!comp) return "";
  const fingerprint = {
    layerCount: comp.layers.length,
    layerIds: comp.layers.map((l) => l.id).join(","),
    modified: store.project.meta.modified,
    settings: comp.settings
  };
  const str = JSON.stringify(fingerprint);
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return hash.toString(16);
}

function vec3(x, y, z) {
  return { x, y, z };
}
function addVec3(a, b) {
  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
function subVec3(a, b) {
  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
function scaleVec3(v, s) {
  return { x: v.x * s, y: v.y * s, z: v.z * s };
}
function lengthVec3(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
function normalizeVec3(v) {
  const len = lengthVec3(v);
  if (len === 0) return { x: 0, y: 0, z: 0 };
  return { x: v.x / len, y: v.y / len, z: v.z / len };
}
function crossVec3(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
  };
}
function dotVec3(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function perspectiveMat4(fovY, aspect, near, far) {
  const te = new Float32Array(16);
  const f = 1 / Math.tan(fovY / 2);
  const nf = 1 / (near - far);
  te[0] = f / aspect;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = f;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = (far + near) * nf;
  te[11] = -1;
  te[12] = 0;
  te[13] = 0;
  te[14] = 2 * far * near * nf;
  te[15] = 0;
  return { elements: te };
}
function orthographicMat4(left, right, bottom, top, near, far) {
  const te = new Float32Array(16);
  const w = 1 / (right - left);
  const h = 1 / (top - bottom);
  const p = 1 / (far - near);
  te[0] = 2 * w;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = 2 * h;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = -2 * p;
  te[11] = 0;
  te[12] = -(right + left) * w;
  te[13] = -(top + bottom) * h;
  te[14] = -10001 * p;
  te[15] = 1;
  return { elements: te };
}
function lookAtMat4(eye, target, up) {
  const te = new Float32Array(16);
  let zx = eye.x - target.x;
  let zy = eye.y - target.y;
  let zz = eye.z - target.z;
  let len = Math.sqrt(zx * zx + zy * zy + zz * zz);
  if (len === 0) {
    zz = 1;
  } else {
    len = 1 / len;
    zx *= len;
    zy *= len;
    zz *= len;
  }
  let xx = up.y * zz - up.z * zy;
  let xy = up.z * zx - up.x * zz;
  let xz = up.x * zy - up.y * zx;
  len = Math.sqrt(xx * xx + xy * xy + xz * xz);
  if (len === 0) {
    xx = 0;
    xy = 0;
    xz = 0;
  } else {
    len = 1 / len;
    xx *= len;
    xy *= len;
    xz *= len;
  }
  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;
  len = Math.sqrt(yx * yx + yy * yy + yz * yz);
  if (len === 0) {
    yx = 0;
    yy = 0;
    yz = 0;
  } else {
    len = 1 / len;
    yx *= len;
    yy *= len;
    yz *= len;
  }
  te[0] = xx;
  te[4] = xy;
  te[8] = xz;
  te[12] = -dotVec3({ x: xx, y: xy, z: xz }, eye);
  te[1] = yx;
  te[5] = yy;
  te[9] = yz;
  te[13] = -dotVec3({ x: yx, y: yy, z: yz }, eye);
  te[2] = zx;
  te[6] = zy;
  te[10] = zz;
  te[14] = -dotVec3({ x: zx, y: zy, z: zz }, eye);
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[15] = 1;
  return { elements: te };
}
function transformPoint(m, p) {
  const e = m.elements;
  const w = e[3] * p.x + e[7] * p.y + e[11] * p.z + e[15];
  return {
    x: (e[0] * p.x + e[4] * p.y + e[8] * p.z + e[12]) / w,
    y: (e[1] * p.x + e[5] * p.y + e[9] * p.z + e[13]) / w,
    z: (e[2] * p.x + e[6] * p.y + e[10] * p.z + e[14]) / w
  };
}
function focalLengthToFOV(focalLength, sensorSize) {
  return 2 * Math.atan(sensorSize / (2 * focalLength));
}
function fovToFocalLength(fov, sensorSize) {
  return sensorSize / (2 * Math.tan(fov / 2));
}

function interpolateCameraAtFrame(camera, keyframes, frame) {
  if (!keyframes || keyframes.length === 0) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  let prev = null;
  let next = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      prev = kf;
    }
    if (kf.frame >= frame && !next) {
      next = kf;
    }
  }
  if (!prev && !next) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  if (!prev) prev = next;
  if (!next) next = prev;
  const getPos = (kf) => kf?.position ?? camera.position;
  const getOri = (kf) => kf?.orientation ?? camera.orientation;
  const getFocal = (kf) => kf?.focalLength ?? camera.focalLength;
  const getZoom = (kf) => kf?.zoom ?? camera.zoom;
  const getFocusDist = (kf) => kf?.focusDistance ?? camera.depthOfField.focusDistance;
  if (prev.frame === next.frame) {
    return {
      position: getPos(prev),
      rotation: getOri(prev),
      focalLength: getFocal(prev),
      zoom: getZoom(prev),
      focusDistance: getFocusDist(prev)
    };
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevPos = getPos(prev);
  const nextPos = getPos(next);
  const prevOri = getOri(prev);
  const nextOri = getOri(next);
  return {
    position: {
      x: lerp(prevPos.x, nextPos.x, t),
      y: lerp(prevPos.y, nextPos.y, t),
      z: lerp(prevPos.z, nextPos.z, t)
    },
    rotation: {
      x: lerpAngle(prevOri.x, nextOri.x, t),
      y: lerpAngle(prevOri.y, nextOri.y, t),
      z: lerpAngle(prevOri.z, nextOri.z, t)
    },
    focalLength: lerp(getFocal(prev), getFocal(next), t),
    zoom: lerp(getZoom(prev), getZoom(next), t),
    focusDistance: lerp(getFocusDist(prev), getFocusDist(next), t)
  };
}
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return a + diff * t;
}
function computeViewMatrix(cam) {
  const { position, rotation } = cam;
  const rx = rotation.x * Math.PI / 180;
  const ry = rotation.y * Math.PI / 180;
  const rz = rotation.z * Math.PI / 180;
  const cosX = Math.cos(rx), sinX = Math.sin(rx);
  const cosY = Math.cos(ry), sinY = Math.sin(ry);
  const cosZ = Math.cos(rz), sinZ = Math.sin(rz);
  const r00 = cosY * cosZ + sinY * sinX * sinZ;
  const r01 = -cosY * sinZ + sinY * sinX * cosZ;
  const r02 = sinY * cosX;
  const r10 = cosX * sinZ;
  const r11 = cosX * cosZ;
  const r12 = -sinX;
  const r20 = -sinY * cosZ + cosY * sinX * sinZ;
  const r21 = sinY * sinZ + cosY * sinX * cosZ;
  const r22 = cosY * cosX;
  const tx = -(r00 * position.x + r10 * position.y + r20 * position.z);
  const ty = -(r01 * position.x + r11 * position.y + r21 * position.z);
  const tz = -(r02 * position.x + r12 * position.y + r22 * position.z);
  return [
    [r00, r01, r02, tx],
    [r10, r11, r12, ty],
    [r20, r21, r22, tz],
    [0, 0, 0, 1]
  ];
}
function computeProjectionMatrix(cam, aspectRatio, nearClip = 0.1, farClip = 1e3) {
  const fov = focalLengthToFOV(cam.focalLength, 36);
  const fovRad = fov * Math.PI / 180;
  const tanHalfFov = Math.tan(fovRad / 2);
  const f = 1 / tanHalfFov;
  const nf = 1 / (nearClip - farClip);
  return [
    [f / aspectRatio, 0, 0, 0],
    [0, f, 0, 0],
    [0, 0, (farClip + nearClip) * nf, 2 * farClip * nearClip * nf],
    [0, 0, -1, 0]
  ];
}
function exportToMotionCtrl(camera, keyframes, frameCount) {
  const poses = [];
  for (let frame = 0; frame < frameCount; frame++) {
    const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(interpolated);
    poses.push({
      RT: viewMatrix
    });
  }
  return { camera_poses: poses };
}
function detectMotionCtrlSVDPreset(keyframes) {
  if (!keyframes || keyframes.length < 2) return "static";
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const threshold = 50;
  if (Math.abs(deltaZ) > threshold) {
    return deltaZ < 0 ? "zoom_in" : "zoom_out";
  }
  if (Math.abs(deltaRy) > 15) {
    return deltaRy > 0 ? "rotate_cw" : "rotate_ccw";
  }
  if (Math.abs(deltaX) > threshold) {
    return deltaX > 0 ? "pan_right" : "pan_left";
  }
  if (Math.abs(deltaY) > threshold) {
    return deltaY > 0 ? "pan_down" : "pan_up";
  }
  return "static";
}
function exportToMotionCtrlSVD(camera, keyframes, frameCount) {
  const preset = detectMotionCtrlSVDPreset(keyframes);
  if (preset !== "static" && keyframes.length <= 2) {
    return { motion_camera: preset };
  }
  const motionctrlData = exportToMotionCtrl(camera, keyframes, frameCount);
  return {
    motion_camera: preset,
    camera_poses: JSON.stringify(motionctrlData.camera_poses)
  };
}
function analyzeCameraMotion(keyframes) {
  if (!keyframes || keyframes.length < 2) {
    return {
      hasPan: false,
      panMagnitude: 0,
      hasZoom: false,
      zoomMagnitude: 0,
      hasOrbit: false,
      orbitMagnitude: 0,
      hasRotation: false,
      rotationMagnitude: 0
    };
  }
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const panThreshold = 30;
  const zoomThreshold = 50;
  const orbitThreshold = 20;
  let panDirection;
  const panX = Math.abs(deltaX);
  const panY = Math.abs(deltaY);
  if (panX > panThreshold || panY > panThreshold) {
    if (panX > panY) {
      panDirection = deltaX > 0 ? "right" : "left";
    } else {
      panDirection = deltaY > 0 ? "down" : "up";
    }
  }
  let zoomDirection;
  if (Math.abs(deltaZ) > zoomThreshold) {
    zoomDirection = deltaZ < 0 ? "in" : "out";
  }
  let orbitDirection;
  if (Math.abs(deltaRy) > orbitThreshold && Math.abs(deltaX) > panThreshold) {
    orbitDirection = deltaRy > 0 ? "right" : "left";
  }
  return {
    hasPan: !!panDirection,
    panDirection,
    panMagnitude: Math.max(panX, panY),
    hasZoom: !!zoomDirection,
    zoomDirection,
    zoomMagnitude: Math.abs(deltaZ),
    hasOrbit: !!orbitDirection,
    orbitDirection,
    orbitMagnitude: Math.abs(deltaRy),
    hasRotation: Math.abs(deltaRy) > 5,
    rotationMagnitude: Math.abs(deltaRy)
  };
}
function mapToWan22FunCamera(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  let preset = "Static";
  if (motion.hasOrbit) {
    preset = motion.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  } else if (motion.hasZoom && motion.hasPan) {
    const panDir = capitalize(motion.panDirection || "up");
    const zoomDir = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    preset = `Pan ${panDir} + ${zoomDir}`;
  } else if (motion.hasZoom) {
    preset = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
  } else if (motion.hasPan) {
    preset = `Pan ${capitalize(motion.panDirection || "up")}`;
  }
  return { camera_motion: preset };
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function detectUni3CTrajectoryType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (motion.hasOrbit && motion.orbitMagnitude > 45) {
    return "orbit";
  }
  if (motion.hasPan && motion.hasZoom) {
    return "custom";
  }
  if (!motion.hasPan && !motion.hasZoom && !motion.hasOrbit) {
    return "free1";
  }
  return "custom";
}
function exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight) {
  const detectedType = detectUni3CTrajectoryType(keyframes);
  if (detectedType !== "custom") {
    return { traj_type: detectedType };
  }
  const trajectory = [];
  const baseCamera = interpolateCameraAtFrame(camera, keyframes, 0);
  for (let frame = 0; frame < frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    trajectory.push({
      zoom: cam.zoom / baseCamera.zoom,
      x_offset: (cam.position.x - baseCamera.position.x) / compWidth,
      y_offset: (cam.position.y - baseCamera.position.y) / compHeight,
      z_offset: (cam.position.z - baseCamera.position.z) / 1e3,
      pitch: cam.rotation.x,
      yaw: cam.rotation.y,
      roll: cam.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: trajectory
  };
}
function detectCameraCtrlMotionType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (!motion.hasPan && !motion.hasZoom && !motion.hasRotation) {
    return "Static";
  }
  if (motion.hasZoom) {
    return motion.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  }
  if (motion.hasPan) {
    switch (motion.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  }
  if (motion.hasRotation) {
    const first = keyframes[0];
    const last = keyframes[keyframes.length - 1];
    const firstOri = first.orientation ?? { x: 0, y: 0, z: 0 };
    const lastOri = last.orientation ?? { x: 0, y: 0, z: 0 };
    const deltaRx = lastOri.x - firstOri.x;
    const deltaRy = lastOri.y - firstOri.y;
    const deltaRz = lastOri.z - firstOri.z;
    if (Math.abs(deltaRy) > Math.abs(deltaRx) && Math.abs(deltaRy) > Math.abs(deltaRz)) {
      return deltaRy > 0 ? "Rotate Right" : "Rotate Left";
    }
    if (Math.abs(deltaRx) > Math.abs(deltaRz)) {
      return deltaRx > 0 ? "Rotate Down" : "Rotate Up";
    }
    return deltaRz > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function exportToCameraCtrl(keyframes, frameCount) {
  const motionType = detectCameraCtrlMotionType(keyframes);
  const motion = analyzeCameraMotion(keyframes);
  let speed = 0;
  if (motion.hasZoom) {
    speed = Math.min(100, motion.zoomMagnitude / 5);
  } else if (motion.hasPan) {
    speed = Math.min(100, motion.panMagnitude / 3);
  } else if (motion.hasRotation) {
    speed = Math.min(100, motion.rotationMagnitude * 2);
  }
  return {
    motion_type: motionType,
    speed: Math.round(speed),
    frame_length: frameCount
  };
}
function exportCameraMatrices(camera, keyframes, options) {
  const frames = [];
  const aspectRatio = options.width / options.height;
  for (let frame = 0; frame < options.frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(cam);
    const projMatrix = computeProjectionMatrix(cam, aspectRatio);
    frames.push({
      frame,
      timestamp: frame / options.fps,
      view_matrix: viewMatrix,
      projection_matrix: projMatrix,
      position: [cam.position.x, cam.position.y, cam.position.z],
      rotation: [cam.rotation.x, cam.rotation.y, cam.rotation.z],
      fov: focalLengthToFOV(cam.focalLength, camera.filmSize),
      focal_length: cam.focalLength,
      focus_distance: cam.focusDistance
    });
  }
  return {
    frames,
    metadata: {
      width: options.width,
      height: options.height,
      fps: options.fps,
      total_frames: options.frameCount,
      camera_type: camera.type,
      film_size: camera.filmSize
    }
  };
}
function exportCameraForTarget(target, camera, keyframes, frameCount, compWidth = 1920, compHeight = 1080, fps = 24) {
  switch (target) {
    case "motionctrl":
      return exportToMotionCtrl(camera, keyframes, frameCount);
    case "motionctrl-svd":
      return exportToMotionCtrlSVD(camera, keyframes, frameCount);
    case "wan22-fun-camera":
      return mapToWan22FunCamera(keyframes);
    case "uni3c-camera":
    case "uni3c-motion":
      return exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight);
    case "animatediff-cameractrl":
      return exportToCameraCtrl(keyframes, frameCount);
    default:
      return exportCameraMatrices(camera, keyframes, {
        frameCount,
        width: compWidth,
        height: compHeight,
        fps
      });
  }
}

function createCameraLayer(store, name) {
  const comp = store.getActiveComp();
  const layers = store.getActiveCompLayers();
  const cameraId = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const cameraName = name || `Camera ${store.cameras.size + 1}`;
  const camera = createDefaultCamera(
    cameraId,
    comp?.settings.width || 1024,
    comp?.settings.height || 1024
  );
  camera.name = cameraName;
  store.cameras.set(cameraId, camera);
  if (!store.activeCameraId) {
    store.activeCameraId = cameraId;
  }
  const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const frameCount = (comp?.settings.frameCount || 81) - 1;
  const layer = {
    id: layerId,
    name: cameraName,
    type: "camera",
    visible: true,
    locked: false,
    isolate: false,
    threeD: true,
    motionBlur: false,
    // Timing (primary properties)
    startFrame: 0,
    endFrame: frameCount,
    // Backwards compatibility aliases
    inPoint: 0,
    outPoint: frameCount,
    parentId: null,
    blendMode: "normal",
    opacity: createAnimatableProperty("opacity", 100, "number"),
    transform: createDefaultTransform(),
    properties: [],
    effects: [],
    data: {
      cameraId,
      isActiveCamera: !store.activeCameraId || store.activeCameraId === cameraId
    }
  };
  layers.unshift(layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  store.selectLayer(layerId);
  return { camera, layer };
}
function getCamera(store, cameraId) {
  return store.cameras.get(cameraId) || null;
}
function updateCamera(store, cameraId, updates) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return;
  Object.assign(camera, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setActiveCamera(store, cameraId) {
  if (!store.cameras.has(cameraId)) return;
  store.activeCameraId = cameraId;
  const layers = store.getActiveCompLayers();
  for (const layer of layers) {
    if (layer.type === "camera" && layer.data) {
      const cameraData = layer.data;
      cameraData.isActiveCamera = cameraData.cameraId === cameraId;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteCamera(store, cameraId) {
  const layers = store.getActiveCompLayers();
  const layerIndex = layers.findIndex(
    (l) => l.type === "camera" && l.data?.cameraId === cameraId
  );
  if (layerIndex !== -1) {
    const layerId = layers[layerIndex].id;
    layers.splice(layerIndex, 1);
    useSelectionStore$1().removeFromSelection(layerId);
  }
  store.cameraKeyframes.delete(cameraId);
  store.cameras.delete(cameraId);
  if (store.activeCameraId === cameraId) {
    const remaining = Array.from(store.cameras.keys());
    store.activeCameraId = remaining.length > 0 ? remaining[0] : null;
    if (store.activeCameraId) {
      setActiveCamera(store, store.activeCameraId);
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getCameraKeyframes(store, cameraId) {
  return store.cameraKeyframes.get(cameraId) || [];
}
function addCameraKeyframe(store, cameraId, keyframe) {
  let keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) {
    keyframes = [];
    store.cameraKeyframes.set(cameraId, keyframes);
  }
  const existingIndex = keyframes.findIndex((k) => k.frame === keyframe.frame);
  if (existingIndex >= 0) {
    keyframes[existingIndex] = keyframe;
  } else {
    keyframes.push(keyframe);
    keyframes.sort((a, b) => a.frame - b.frame);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function removeCameraKeyframe(store, cameraId, frame) {
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) return;
  const index = keyframes.findIndex((k) => k.frame === frame);
  if (index >= 0) {
    keyframes.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function getCameraAtFrame(store, cameraId, frame) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return null;
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes || keyframes.length === 0) {
    return camera;
  }
  const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
  return {
    ...camera,
    position: interpolated.position,
    orientation: interpolated.rotation,
    focalLength: interpolated.focalLength,
    zoom: interpolated.zoom,
    depthOfField: {
      ...camera.depthOfField,
      focusDistance: interpolated.focusDistance
    }
  };
}
function getActiveCameraAtFrame(store, frame) {
  if (!store.activeCameraId) return null;
  return getCameraAtFrame(store, store.activeCameraId, frame ?? store.currentFrame);
}
function updateViewportState(store, updates) {
  Object.assign(store.viewportState, updates);
}
function updateViewOptions(store, updates) {
  Object.assign(store.viewOptions, updates);
}

function getApiBase() {
  return "";
}
async function segmentImage(request) {
  const response = await fetch(`${getApiBase()}/weyl/segment`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `Segmentation failed: ${response.status}`);
  }
  return response.json();
}
async function segmentByPoint(imageBase64, point, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points: [point],
    labels: [1]
    // Foreground
  });
}
async function segmentByBox(imageBase64, box, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "box",
    model,
    box
  });
}
async function segmentByMultiplePoints(imageBase64, foregroundPoints, backgroundPoints = [], model = "sam2") {
  const points = [...foregroundPoints, ...backgroundPoints];
  const labels = [
    ...foregroundPoints.map(() => 1),
    // Foreground
    ...backgroundPoints.map(() => 0)
    // Background
  ];
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points,
    labels
  });
}
async function autoSegment(imageBase64, options = {}) {
  return segmentImage({
    image: imageBase64,
    mode: "auto",
    model: options.model || "sam2",
    minArea: options.minArea || 100,
    maxMasks: options.maxMasks || 20
  });
}
function applyMaskToImage(sourceImageBase64, maskBase64, bounds) {
  return new Promise((resolve, reject) => {
    const sourceImg = new Image();
    const maskImg = new Image();
    let sourceLoaded = false;
    let maskLoaded = false;
    const checkComplete = () => {
      if (!sourceLoaded || !maskLoaded) return;
      try {
        const canvas = document.createElement("canvas");
        canvas.width = bounds.width;
        canvas.height = bounds.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = maskImg.width;
        maskCanvas.height = maskImg.height;
        const maskCtx = maskCanvas.getContext("2d");
        if (!maskCtx) {
          reject(new Error("Failed to get mask canvas context"));
          return;
        }
        maskCtx.drawImage(maskImg, 0, 0);
        const maskData = maskCtx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
        ctx.drawImage(
          sourceImg,
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
          0,
          0,
          bounds.width,
          bounds.height
        );
        const imageData = ctx.getImageData(0, 0, bounds.width, bounds.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          imageData.data[i + 3] = maskData.data[i];
        }
        ctx.putImageData(imageData, 0, 0);
        const resultBase64 = canvas.toDataURL("image/png").split(",")[1];
        resolve(resultBase64);
      } catch (err) {
        reject(err);
      }
    };
    sourceImg.onload = () => {
      sourceLoaded = true;
      checkComplete();
    };
    sourceImg.onerror = () => reject(new Error("Failed to load source image"));
    maskImg.onload = () => {
      maskLoaded = true;
      checkComplete();
    };
    maskImg.onerror = () => reject(new Error("Failed to load mask image"));
    sourceImg.src = `data:image/png;base64,${sourceImageBase64}`;
    maskImg.src = `data:image/png;base64,${maskBase64}`;
  });
}

async function createLayerFromMask(store, sourceImageBase64, mask, name, positionAtCenter = false) {
  try {
    const maskedImageBase64 = await applyMaskToImage(
      sourceImageBase64,
      mask.mask,
      mask.bounds
    );
    const assetId = `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const asset = {
      id: assetId,
      type: "image",
      source: "generated",
      width: mask.bounds.width,
      height: mask.bounds.height,
      data: maskedImageBase64
    };
    store.project.assets[assetId] = asset;
    const layer = store.createLayer("image", name || "Segmented");
    const imageData = {
      assetId,
      fit: "none",
      // Don't scale - use original size
      sourceType: "segmented"
    };
    layer.data = imageData;
    if (positionAtCenter) {
      layer.transform.position.value = {
        x: store.project.composition.width / 2,
        y: store.project.composition.height / 2
      };
    } else {
      layer.transform.position.value = {
        x: mask.bounds.x + mask.bounds.width / 2,
        y: mask.bounds.y + mask.bounds.height / 2
      };
    }
    const originProp = layer.transform.origin || layer.transform.anchorPoint;
    if (originProp) {
      originProp.value = {
        x: mask.bounds.width / 2,
        y: mask.bounds.height / 2
      };
    }
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
    storeLogger.info(`Created segmented layer: ${layer.name} (${mask.bounds.width}x${mask.bounds.height})`);
    return layer;
  } catch (err) {
    storeLogger.error("Failed to create layer from mask:", err);
    return null;
  }
}
async function segmentToLayerByPoint(store, point, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByPoint(sourceImage, point, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByBox(store, box, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByBox(sourceImage, box, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByMultiplePoints(store, foregroundPoints, backgroundPoints = [], options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByMultiplePoints(
      sourceImage,
      foregroundPoints,
      backgroundPoints,
      options.model || "sam2"
    );
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function autoSegmentToLayers(store, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return [];
  }
  try {
    const result = await autoSegment(sourceImage, {
      model: options.model || "sam2",
      minArea: options.minArea || 1e3,
      maxMasks: options.maxMasks || 10
    });
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Auto-segmentation failed:", result.message);
      return [];
    }
    const layers = [];
    const prefix = options.namePrefix || "Segment";
    for (let i = 0; i < result.masks.length; i++) {
      const mask = result.masks[i];
      const layer = await createLayerFromMask(
        store,
        sourceImage,
        mask,
        `${prefix} ${i + 1}`,
        false
        // Don't center - preserve original position
      );
      if (layer) {
        layers.push(layer);
      }
    }
    return layers;
  } catch (err) {
    storeLogger.error("Auto-segmentation error:", err);
    return [];
  }
}

function getAnimatableType(paramType) {
  switch (paramType) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const EFFECT_DEFINITIONS = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: true },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: true },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: true }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: true },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: false },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: false }
    ]
  },
  "box-blur": {
    name: "Box Blur",
    category: "blur-sharpen",
    description: "Fast uniform blur using box averaging",
    parameters: [
      { name: "Blur Radius", type: "number", defaultValue: 5, min: 0, max: 100, animatable: true },
      { name: "Iterations", type: "number", defaultValue: 1, min: 1, max: 5, animatable: false }
    ]
  },
  "sharpen": {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: true }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: true },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: true },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Use Legacy", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: false },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: true, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "curves": {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false }
      // Note: Actual curve control would be a custom component
    ]
  },
  "levels": {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: false },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: true },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "tint": {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  // Distort
  "transform": {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: true },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: true },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "warp": {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: false },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: false },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true }
    ]
  },
  // Generate
  "fill": {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: true },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: true },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: false },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  // Stylize
  "glow": {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: true },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: true },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: true },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: false },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: true },
      { name: "Color Looping", type: "dropdown", defaultValue: "none", options: [
        { label: "None", value: "none" },
        { label: "Sawtooth A>B", value: "sawtooth_ab" },
        { label: "Sawtooth B>A", value: "sawtooth_ba" },
        { label: "Triangle A>B>A", value: "triangle" }
      ], animatable: false },
      { name: "Color Looping Speed", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.1, animatable: true },
      { name: "Glow Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: true },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: true },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: true },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: true },
      { name: "Shadow Only", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: false },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: false },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: true },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: true },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: true },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: true }
    ]
  },
  // Time Effects
  "echo": {
    name: "Echo",
    category: "time",
    description: "Create motion trails by compositing previous frames",
    parameters: [
      { name: "Echo Time", type: "number", defaultValue: -0.033, min: -2, max: 2, step: 1e-3, animatable: true },
      { name: "Number of Echoes", type: "number", defaultValue: 8, min: 1, max: 50, animatable: true },
      { name: "Starting Intensity", type: "number", defaultValue: 1, min: 0, max: 2, step: 0.01, animatable: true },
      { name: "Decay", type: "number", defaultValue: 0.5, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Echo Operator", type: "dropdown", defaultValue: "add", options: [
        { label: "Add", value: "add" },
        { label: "Screen", value: "screen" },
        { label: "Maximum", value: "maximum" },
        { label: "Minimum", value: "minimum" },
        { label: "Composite in Back", value: "composite_back" },
        { label: "Composite in Front", value: "composite_front" },
        { label: "Blend", value: "blend" }
      ], animatable: false }
    ]
  },
  "posterize-time": {
    name: "Posterize Time",
    category: "time",
    description: "Reduce temporal resolution for stylized frame rate",
    parameters: [
      { name: "Frame Rate", type: "number", defaultValue: 12, min: 1, max: 60, animatable: true }
    ]
  },
  "time-displacement": {
    name: "Time Displacement",
    category: "time",
    description: "Displace pixels in time based on luminance values",
    parameters: [
      { name: "Max Displacement", type: "number", defaultValue: 10, min: 0, max: 60, animatable: true },
      { name: "Time Resolution", type: "dropdown", defaultValue: "frame", options: [
        { label: "Frame", value: "frame" },
        { label: "Half Frame", value: "half" },
        { label: "Quarter Frame", value: "quarter" }
      ], animatable: false }
    ]
  },
  // Note: Timewarp is NOT an effect - it's a layer property on Video/NestedComp layers
  // that modifies timing with animatable speed curves. See VideoData.timewarpEnabled.
  // Stylize - Additional
  "add-grain": {
    name: "Add Grain",
    category: "noise-grain",
    description: "Add film grain texture",
    parameters: [
      { name: "Intensity", type: "number", defaultValue: 0.5, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Size", type: "number", defaultValue: 1, min: 0.5, max: 4, step: 0.1, animatable: true },
      { name: "Softness", type: "number", defaultValue: 0, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Animate", type: "checkbox", defaultValue: true, animatable: false },
      { name: "Color", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  // Stylize - Glitch Effects
  "rgb-split": {
    name: "RGB Split",
    category: "stylize",
    description: "Chromatic aberration / RGB channel separation",
    parameters: [
      { name: "Red Offset X", type: "number", defaultValue: 5, min: -100, max: 100, animatable: true },
      { name: "Red Offset Y", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Green Offset X", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Green Offset Y", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Blue Offset X", type: "number", defaultValue: -5, min: -100, max: 100, animatable: true },
      { name: "Blue Offset Y", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Blend Mode", type: "dropdown", defaultValue: "screen", options: [
        { label: "Screen", value: "screen" },
        { label: "Add", value: "add" },
        { label: "Normal", value: "normal" }
      ], animatable: false }
    ]
  },
  "scanlines": {
    name: "Scan Lines",
    category: "stylize",
    description: "CRT monitor scan line effect",
    parameters: [
      { name: "Line Width", type: "number", defaultValue: 2, min: 1, max: 20, animatable: true },
      { name: "Line Spacing", type: "number", defaultValue: 2, min: 1, max: 20, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 0.3, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Direction", type: "dropdown", defaultValue: "horizontal", options: [
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false },
      { name: "Animate", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "vhs": {
    name: "VHS",
    category: "stylize",
    description: "VHS tape distortion effect",
    parameters: [
      { name: "Tracking", type: "number", defaultValue: 0.5, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Noise", type: "number", defaultValue: 0.3, min: 0, max: 1, step: 0.01, animatable: true },
      { name: "Color Bleed", type: "number", defaultValue: 3, min: 0, max: 20, animatable: true },
      { name: "Jitter", type: "number", defaultValue: 0.5, min: 0, max: 5, animatable: true },
      { name: "Rolling Bands", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  // Color Correction - Additional
  "selective-color": {
    name: "Selective Color",
    category: "color-correction",
    description: "Adjust colors in specific color ranges",
    parameters: [
      { name: "Colors", type: "dropdown", defaultValue: "reds", options: [
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" },
        { label: "Whites", value: "whites" },
        { label: "Neutrals", value: "neutrals" },
        { label: "Blacks", value: "blacks" }
      ], animatable: false },
      { name: "Cyan", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Magenta", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Yellow", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Black", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true }
    ]
  },
  "photo-filter": {
    name: "Photo Filter",
    category: "color-correction",
    description: "Apply warming/cooling filter",
    parameters: [
      { name: "Filter", type: "dropdown", defaultValue: "warming_85", options: [
        { label: "Warming Filter (85)", value: "warming_85" },
        { label: "Warming Filter (81)", value: "warming_81" },
        { label: "Cooling Filter (80)", value: "cooling_80" },
        { label: "Cooling Filter (82)", value: "cooling_82" },
        { label: "Sepia", value: "sepia" },
        { label: "Deep Blue", value: "deep_blue" },
        { label: "Underwater", value: "underwater" }
      ], animatable: false },
      { name: "Color", type: "color", defaultValue: { r: 236, g: 138, b: 0, a: 1 }, animatable: true },
      { name: "Density", type: "number", defaultValue: 25, min: 0, max: 100, animatable: true },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "channel-mixer": {
    name: "Channel Mixer",
    category: "color-correction",
    description: "Mix RGB channels",
    parameters: [
      { name: "Output Channel", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false },
      { name: "Red", type: "number", defaultValue: 100, min: -200, max: 200, animatable: true },
      { name: "Green", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Blue", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Constant", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Monochrome", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "gradient-map": {
    name: "Gradient Map",
    category: "color-correction",
    description: "Map luminance to gradient colors",
    parameters: [
      { name: "Color 1", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Color 2", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Dither", type: "number", defaultValue: 0, min: 0, max: 100, animatable: false },
      { name: "Reverse", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "black-white": {
    name: "Black & White",
    category: "color-correction",
    description: "Convert to monochrome with color channel control",
    parameters: [
      { name: "Reds", type: "number", defaultValue: 40, min: -200, max: 300, animatable: true },
      { name: "Yellows", type: "number", defaultValue: 60, min: -200, max: 300, animatable: true },
      { name: "Greens", type: "number", defaultValue: 40, min: -200, max: 300, animatable: true },
      { name: "Cyans", type: "number", defaultValue: 60, min: -200, max: 300, animatable: true },
      { name: "Blues", type: "number", defaultValue: 20, min: -200, max: 300, animatable: true },
      { name: "Magentas", type: "number", defaultValue: 80, min: -200, max: 300, animatable: true },
      { name: "Tint", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Tint Color", type: "color", defaultValue: { r: 225, g: 210, b: 180, a: 1 }, animatable: true }
    ]
  },
  // Stylize - Additional
  "emboss": {
    name: "Emboss",
    category: "stylize",
    description: "Create embossed relief effect",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 135, animatable: true },
      { name: "Height", type: "number", defaultValue: 3, min: 1, max: 10, animatable: true },
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true }
    ]
  },
  "find-edges": {
    name: "Find Edges",
    category: "stylize",
    description: "Detect and highlight edges",
    parameters: [
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Blend with Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  "mosaic": {
    name: "Mosaic",
    category: "stylize",
    description: "Pixelate effect",
    parameters: [
      { name: "Horizontal Blocks", type: "number", defaultValue: 10, min: 2, max: 200, animatable: true },
      { name: "Vertical Blocks", type: "number", defaultValue: 10, min: 2, max: 200, animatable: true },
      { name: "Sharp Corners", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  // Blur - Additional
  "lens-blur": {
    name: "Lens Blur",
    category: "blur-sharpen",
    description: "Simulate camera lens blur with bokeh",
    parameters: [
      { name: "Radius", type: "number", defaultValue: 15, min: 0, max: 100, animatable: true },
      { name: "Blade Curvature", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: true },
      { name: "Brightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Threshold", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true }
    ]
  },
  // Distort - Additional
  "bulge": {
    name: "Bulge",
    category: "distort",
    description: "Spherical bulge distortion",
    parameters: [
      { name: "Horizontal Radius", type: "number", defaultValue: 100, min: 0, max: 1e3, animatable: true },
      { name: "Vertical Radius", type: "number", defaultValue: 100, min: 0, max: 1e3, animatable: true },
      { name: "Bulge Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Bulge Height", type: "number", defaultValue: 1, min: -4, max: 4, step: 0.1, animatable: true },
      { name: "Taper Radius", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  "twirl": {
    name: "Twirl",
    category: "distort",
    description: "Spiral twist distortion",
    parameters: [
      { name: "Angle", type: "angle", defaultValue: 50, animatable: true },
      { name: "Twirl Radius", type: "number", defaultValue: 200, min: 0, max: 2e3, animatable: true },
      { name: "Twirl Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true }
    ]
  },
  "ripple": {
    name: "Ripple",
    category: "distort",
    description: "Water ripple distortion",
    parameters: [
      { name: "Radius", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Wave Length", type: "number", defaultValue: 30, min: 1, max: 999, animatable: true },
      { name: "Amplitude", type: "number", defaultValue: 10, min: -100, max: 100, animatable: true },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Phase", type: "angle", defaultValue: 0, animatable: true }
    ]
  },
  "wave": {
    name: "Wave",
    category: "distort",
    description: "Wave distortion",
    parameters: [
      { name: "Wave Type", type: "dropdown", defaultValue: "sine", options: [
        { label: "Sine", value: "sine" },
        { label: "Triangle", value: "triangle" },
        { label: "Square", value: "square" }
      ], animatable: false },
      { name: "Wave Height", type: "number", defaultValue: 10, min: 0, max: 100, animatable: true },
      { name: "Wave Width", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Direction", type: "angle", defaultValue: 0, animatable: true },
      { name: "Phase", type: "angle", defaultValue: 0, animatable: true }
    ]
  },
  // ============================================================================
  // PERSPECTIVE / 3D EFFECTS
  // ============================================================================
  "fog-3d": {
    name: "Fog 3D",
    category: "perspective",
    description: "Depth-based atmospheric fog effect for 3D compositions",
    parameters: [
      { name: "Fog Start Depth", type: "number", defaultValue: 0, min: -1e4, max: 1e4, step: 10, animatable: true },
      { name: "Fog End Depth", type: "number", defaultValue: 2e3, min: -1e4, max: 1e4, step: 10, animatable: true },
      { name: "Fog Color", type: "color", defaultValue: { r: 200, g: 200, b: 220 }, animatable: true },
      { name: "Fog Opacity", type: "number", defaultValue: 100, min: 0, max: 100, step: 1, animatable: true },
      { name: "Scattering", type: "number", defaultValue: 0, min: 0, max: 100, step: 1, animatable: true },
      { name: "Gradient Mode", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear", value: "linear" },
        { label: "Exponential", value: "exponential" },
        { label: "Exponential Squared", value: "exponential2" }
      ], animatable: false },
      { name: "Use Comp Camera", type: "checkbox", defaultValue: true, animatable: false },
      { name: "Layer Depth", type: "number", defaultValue: 0, min: -1e4, max: 1e4, step: 10, animatable: true }
    ]
  },
  "depth-matte": {
    name: "Depth Matte",
    category: "perspective",
    description: "Create matte based on layer Z-depth",
    parameters: [
      { name: "Near Depth", type: "number", defaultValue: 0, min: -1e4, max: 1e4, step: 10, animatable: true },
      { name: "Far Depth", type: "number", defaultValue: 1e3, min: -1e4, max: 1e4, step: 10, animatable: true },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Softness", type: "number", defaultValue: 0, min: 0, max: 100, step: 1, animatable: true }
    ]
  },
  "3d-glasses": {
    name: "3D Glasses",
    category: "perspective",
    description: "Anaglyph 3D effect for stereoscopic viewing",
    parameters: [
      { name: "3D View", type: "dropdown", defaultValue: "red-cyan", options: [
        { label: "Red-Cyan", value: "red-cyan" },
        { label: "Green-Magenta", value: "green-magenta" },
        { label: "Amber-Blue", value: "amber-blue" }
      ], animatable: false },
      { name: "Left View", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false },
      { name: "Right View", type: "dropdown", defaultValue: "cyan", options: [
        { label: "Cyan", value: "cyan" },
        { label: "Magenta", value: "magenta" },
        { label: "Yellow", value: "yellow" }
      ], animatable: false },
      { name: "Convergence", type: "number", defaultValue: 0, min: -100, max: 100, step: 1, animatable: true },
      { name: "Balance", type: "number", defaultValue: 0, min: -100, max: 100, step: 1, animatable: true }
    ]
  }
};
const EFFECT_CATEGORIES = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  "distort": { label: "Distort", icon: "D", description: "Distortion effects" },
  "generate": { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  "keying": { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  "matte": { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  "perspective": { label: "Perspective", icon: "P", description: "3D perspective effects" },
  "stylize": { label: "Stylize", icon: "S", description: "Stylization effects" },
  "time": { label: "Time", icon: "T", description: "Time-based effects" },
  "transition": { label: "Transition", icon: "Tr", description: "Transition effects" },
  "utility": { label: "Utility", icon: "U", description: "Utility effects" }
};
function createEffectInstance(definitionKey) {
  const def = EFFECT_DEFINITIONS[definitionKey];
  if (!def) return null;
  const parameters = {};
  def.parameters.forEach((param, index) => {
    const paramKey = param.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    parameters[paramKey] = {
      id: `${definitionKey}-${paramKey}-${index}`,
      name: param.name,
      type: getAnimatableType(param.type),
      value: param.defaultValue,
      animated: false,
      keyframes: []
    };
  });
  return {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: definitionKey,
    name: def.name,
    category: def.category,
    enabled: true,
    expanded: true,
    parameters
  };
}
const ANIMATION_PRESETS = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];

function addEffectToLayer(store, layerId, effectKey) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const effect = createEffectInstance(effectKey);
  if (!effect) return;
  if (!layer.effects) {
    layer.effects = [];
  }
  layer.effects.push(effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function removeEffectFromLayer(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const index = layer.effects.findIndex((e) => e.id === effectId);
  if (index >= 0) {
    layer.effects.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
  }
}
function updateEffectParameter(store, layerId, effectId, paramKey, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  effect.parameters[paramKey].value = value;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function setEffectParamAnimated(store, layerId, effectId, paramKey, animated) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  const param = effect.parameters[paramKey];
  param.animated = animated;
  if (animated && (!param.keyframes || param.keyframes.length === 0)) {
    param.keyframes = [{
      id: `kf_${Date.now()}`,
      frame: store.currentFrame,
      value: param.value,
      interpolation: "linear",
      inHandle: { frame: -5, value: 0, enabled: false },
      outHandle: { frame: 5, value: 0, enabled: false },
      controlMode: "smooth"
    }];
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleEffect(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect) return;
  effect.enabled = !effect.enabled;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function reorderEffects(store, layerId, fromIndex, toIndex) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  if (fromIndex < 0 || fromIndex >= layer.effects.length) return;
  if (toIndex < 0 || toIndex >= layer.effects.length) return;
  const [effect] = layer.effects.splice(fromIndex, 1);
  layer.effects.splice(toIndex, 0, effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getEffectParameterValue(store, layerId, effectId, paramKey, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return null;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return null;
  const param = effect.parameters[paramKey];
  const targetFrame = frame ?? (store.getActiveComp()?.currentFrame ?? 0);
  if (param.animated && param.keyframes.length > 0) {
    return interpolateProperty(param, targetFrame);
  }
  return param.value;
}

const usePlaybackStore = defineStore("playback", {
  state: () => ({
    isPlaying: false,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    loopPlayback: true,
    workAreaStart: null,
    workAreaEnd: null
  }),
  getters: {
    playing: (state) => state.isPlaying,
    hasWorkArea: (state) => state.workAreaStart !== null && state.workAreaEnd !== null,
    effectiveStartFrame: (state) => state.workAreaStart ?? 0,
    effectiveEndFrame: (state) => (frameCount) => state.workAreaEnd ?? frameCount - 1
  },
  actions: {
    /**
     * Set work area bounds
     */
    setWorkArea(start, end) {
      this.workAreaStart = start;
      this.workAreaEnd = end;
      storeLogger.debug("Work area set:", { start, end });
    },
    /**
     * Clear work area
     */
    clearWorkArea() {
      this.workAreaStart = null;
      this.workAreaEnd = null;
      storeLogger.debug("Work area cleared");
    },
    /**
     * Start playback
     * @param fps - Frames per second
     * @param frameCount - Total frame count
     * @param currentFrame - Starting frame
     * @param onFrame - Callback for each frame
     */
    play(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) return;
      this.isPlaying = true;
      this.playbackStartTime = performance.now();
      this.playbackStartFrame = currentFrame;
      const rangeStart = this.workAreaStart ?? 0;
      const rangeEnd = this.workAreaEnd ?? frameCount - 1;
      const rangeLength = rangeEnd - rangeStart + 1;
      if (this.workAreaStart !== null && this.workAreaEnd !== null) {
        if (currentFrame < rangeStart || currentFrame > rangeEnd) {
          currentFrame = rangeStart;
          onFrame(currentFrame);
        }
      }
      const frameDuration = 1e3 / fps;
      let lastFrameTime = this.playbackStartTime;
      const tick = (now) => {
        if (!this.isPlaying) return;
        const elapsed = now - lastFrameTime;
        if (elapsed >= frameDuration) {
          const framesToAdvance = Math.floor(elapsed / frameDuration);
          let newFrame = currentFrame + framesToAdvance;
          if (newFrame > rangeEnd) {
            if (this.loopPlayback) {
              newFrame = rangeStart + (newFrame - rangeStart) % rangeLength;
            } else {
              newFrame = rangeEnd;
              this.stop();
              onFrame(newFrame);
              return;
            }
          }
          currentFrame = newFrame;
          lastFrameTime = now - elapsed % frameDuration;
          onFrame(currentFrame);
        }
        this.playbackRequestId = requestAnimationFrame(tick);
      };
      this.playbackRequestId = requestAnimationFrame(tick);
      storeLogger.debug("Playback started at frame", currentFrame, "range:", rangeStart, "-", rangeEnd);
    },
    /**
     * Stop playback
     */
    stop() {
      if (this.playbackRequestId !== null) {
        cancelAnimationFrame(this.playbackRequestId);
        this.playbackRequestId = null;
      }
      this.isPlaying = false;
      this.playbackStartTime = null;
      storeLogger.debug("Playback stopped");
    },
    /**
     * Toggle playback
     */
    toggle(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) {
        this.stop();
      } else {
        this.play(fps, frameCount, currentFrame, onFrame);
      }
    },
    /**
     * Set loop playback mode
     */
    setLoopPlayback(loop) {
      this.loopPlayback = loop;
    },
    /**
     * Go to first frame
     */
    goToStart(onFrame) {
      this.stop();
      onFrame(0);
    },
    /**
     * Go to last frame
     */
    goToEnd(frameCount, onFrame) {
      this.stop();
      onFrame(frameCount - 1);
    },
    /**
     * Step forward one frame
     */
    stepForward(currentFrame, frameCount, onFrame) {
      this.stop();
      const newFrame = Math.min(currentFrame + 1, frameCount - 1);
      onFrame(newFrame);
    },
    /**
     * Step backward one frame
     */
    stepBackward(currentFrame, onFrame) {
      this.stop();
      const newFrame = Math.max(currentFrame - 1, 0);
      onFrame(newFrame);
    },
    /**
     * Jump to specific frame
     */
    goToFrame(frame, frameCount, onFrame) {
      const clampedFrame = Math.max(0, Math.min(frame, frameCount - 1));
      onFrame(clampedFrame);
    }
  }
});

const useCompositorStore = defineStore("compositor", {
  state: () => {
    const initialProject = createEmptyProject(832, 480);
    return {
      project: initialProject,
      activeCompositionId: "main",
      openCompositionIds: ["main"],
      compositionBreadcrumbs: ["main"],
      // Start with main comp in breadcrumb path
      comfyuiNodeId: null,
      sourceImage: null,
      depthMap: null,
      isPlaying: false,
      segmentToolActive: false,
      segmentMode: "point",
      segmentPendingMask: null,
      segmentBoxStart: null,
      segmentIsLoading: false,
      curveEditorVisible: false,
      hideMinimizedLayers: false,
      // Initialize history with initial project state so first action can be undone
      historyStack: [structuredClone(initialProject)],
      historyIndex: 0,
      audioBuffer: null,
      audioAnalysis: null,
      audioFile: null,
      audioVolume: 100,
      audioMuted: false,
      audioLoadingState: "idle",
      audioLoadingProgress: 0,
      audioLoadingPhase: "",
      audioLoadingError: null,
      audioMappings: /* @__PURE__ */ new Map(),
      peakData: null,
      audioReactiveMappings: [],
      audioReactiveMapper: null,
      pathAnimators: /* @__PURE__ */ new Map(),
      // Camera system
      cameras: /* @__PURE__ */ new Map(),
      cameraKeyframes: /* @__PURE__ */ new Map(),
      activeCameraId: null,
      viewportState: createDefaultViewportState(),
      viewOptions: createDefaultViewOptions(),
      // Property driver system
      propertyDriverSystem: null,
      propertyDrivers: [],
      // Timeline snapping
      snapConfig: { ...DEFAULT_SNAP_CONFIG },
      // Clipboard
      clipboard: {
        layers: [],
        keyframes: []
      },
      // Autosave (enabled by default, every 60 seconds)
      autosaveEnabled: true,
      autosaveIntervalMs: 6e4,
      autosaveTimerId: null,
      lastSaveTime: null,
      lastSaveProjectId: null,
      hasUnsavedChanges: false,
      // Frame cache (enabled by default)
      frameCacheEnabled: true,
      projectStateHash: ""
    };
  },
  getters: {
    // Active composition helper
    activeComposition: (state) => {
      return state.project.compositions[state.activeCompositionId] || null;
    },
    // Project info - now uses active composition
    hasProject: (state) => state.sourceImage !== null,
    width(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.width || 1024;
    },
    height(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.height || 1024;
    },
    frameCount(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.frameCount || 81;
    },
    fps(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.fps || 16;
    },
    duration(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.duration || 5;
    },
    backgroundColor(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.backgroundColor || "#050505";
    },
    // Current frame - per composition
    currentFrame(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.currentFrame || 0;
    },
    currentTime(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      if (!comp) return 0;
      return comp.currentFrame / comp.settings.fps;
    },
    // Layers - from active composition
    layers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.layers || [];
    },
    visibleLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.visible);
    },
    // Layers displayed in timeline (respects minimized filter)
    displayedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      const allLayers = comp?.layers || [];
      if (state.hideMinimizedLayers) {
        return allLayers.filter((l) => !l.minimized);
      }
      return allLayers;
    },
    // Selection (delegated to selectionStore)
    selectedLayerIds() {
      return useSelectionStore$1().selectedLayerIds;
    },
    selectedKeyframeIds() {
      return useSelectionStore$1().selectedKeyframeIds;
    },
    selectedPropertyPath() {
      return useSelectionStore$1().selectedPropertyPath;
    },
    currentTool(state) {
      if (state.segmentToolActive) return "segment";
      return useSelectionStore$1().currentTool;
    },
    selectedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      const selectionStore = useSelectionStore$1();
      return (comp?.layers || []).filter((l) => selectionStore.selectedLayerIds.includes(l.id));
    },
    selectedLayer(state) {
      const selectionStore = useSelectionStore$1();
      if (selectionStore.selectedLayerIds.length !== 1) return null;
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).find((l) => l.id === selectionStore.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (state) => {
      return Object.values(state.project.compositions);
    },
    openCompositions(state) {
      return state.openCompositionIds.map((id) => state.project.compositions[id]).filter(Boolean);
    },
    // Breadcrumb navigation path for nested compositions
    breadcrumbPath(state) {
      return state.compositionBreadcrumbs.map((id) => {
        const comp = state.project.compositions[id];
        return comp ? { id, name: comp.name } : null;
      }).filter(Boolean);
    },
    // Assets
    assets: (state) => state.project.assets,
    // History
    canUndo: (state) => state.historyIndex > 0,
    canRedo: (state) => state.historyIndex < state.historyStack.length - 1,
    // Camera
    activeCamera: (state) => {
      if (!state.activeCameraId) return null;
      return state.cameras.get(state.activeCameraId) || null;
    },
    allCameras: (state) => Array.from(state.cameras.values()),
    cameraLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const comp = this.project.compositions[this.activeCompositionId];
      return comp?.layers || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(name, settings, isNestedComp = false) {
      const id = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const activeComp = this.project.compositions[this.activeCompositionId];
      const defaultSettings = {
        width: settings?.width ?? activeComp?.settings.width ?? 1024,
        height: settings?.height ?? activeComp?.settings.height ?? 1024,
        frameCount: settings?.frameCount ?? activeComp?.settings.frameCount ?? 81,
        fps: settings?.fps ?? activeComp?.settings.fps ?? 16,
        duration: 0,
        backgroundColor: settings?.backgroundColor ?? "#050505",
        autoResizeToContent: settings?.autoResizeToContent ?? true
      };
      defaultSettings.duration = defaultSettings.frameCount / defaultSettings.fps;
      const composition = {
        id,
        name,
        settings: defaultSettings,
        layers: [],
        currentFrame: 0,
        isNestedComp
      };
      this.project.compositions[id] = composition;
      if (!this.openCompositionIds.includes(id)) {
        this.openCompositionIds.push(id);
      }
      this.activeCompositionId = id;
      storeLogger.debug("Created composition:", name, id);
      return composition;
    },
    /**
     * Delete a composition
     */
    deleteComposition(compId) {
      if (compId === this.project.mainCompositionId) {
        storeLogger.warn("Cannot delete main composition");
        return false;
      }
      const comp = this.project.compositions[compId];
      if (!comp) return false;
      delete this.project.compositions[compId];
      const openIdx = this.openCompositionIds.indexOf(compId);
      if (openIdx >= 0) {
        this.openCompositionIds.splice(openIdx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId;
      }
      storeLogger.debug("Deleted composition:", compId);
      return true;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Composition not found:", compId);
        return;
      }
      if (!this.openCompositionIds.includes(compId)) {
        this.openCompositionIds.push(compId);
      }
      const selection = useSelectionStore$1();
      selection.clearLayerSelection();
      selection.clearKeyframeSelection();
      this.activeCompositionId = compId;
      storeLogger.debug("Switched to composition:", compId);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(compId) {
      if (this.openCompositionIds.length <= 1) {
        storeLogger.warn("Cannot close the last tab");
        return;
      }
      const idx = this.openCompositionIds.indexOf(compId);
      if (idx >= 0) {
        this.openCompositionIds.splice(idx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[Math.max(0, idx - 1)];
      }
    },
    /**
     * Enter a nested comp (e.g., double-click on nested comp layer)
     * Pushes the composition to the breadcrumb trail
     */
    enterNestedComp(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Nested comp not found:", compId);
        return;
      }
      this.compositionBreadcrumbs.push(compId);
      this.switchComposition(compId);
      storeLogger.debug("Entered nested comp:", compId, "breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Navigate back one level in the breadcrumb trail
     */
    navigateBack() {
      if (this.compositionBreadcrumbs.length <= 1) {
        storeLogger.warn("Already at root composition");
        return;
      }
      this.compositionBreadcrumbs.pop();
      const prevId = this.compositionBreadcrumbs[this.compositionBreadcrumbs.length - 1];
      if (prevId) {
        this.switchComposition(prevId);
      }
      storeLogger.debug("Navigated back, breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Navigate to a specific breadcrumb index
     * Truncates the breadcrumb trail to that point
     */
    navigateToBreadcrumb(index) {
      if (index < 0 || index >= this.compositionBreadcrumbs.length) {
        return;
      }
      if (index === this.compositionBreadcrumbs.length - 1) {
        return;
      }
      this.compositionBreadcrumbs = this.compositionBreadcrumbs.slice(0, index + 1);
      const targetId = this.compositionBreadcrumbs[index];
      if (targetId) {
        this.switchComposition(targetId);
      }
      storeLogger.debug("Navigated to breadcrumb", index, "breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Reset breadcrumbs to main composition (e.g., when loading a new project)
     */
    resetBreadcrumbs() {
      this.compositionBreadcrumbs = [this.project.mainCompositionId];
      this.switchComposition(this.project.mainCompositionId);
    },
    /**
     * Rename a composition
     */
    renameComposition(compId, newName) {
      const comp = this.project.compositions[compId];
      if (comp) {
        comp.name = newName;
      }
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(compId, settings) {
      const comp = this.project.compositions[compId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      Object.assign(comp.settings, settings);
      comp.settings.duration = comp.settings.frameCount / comp.settings.fps;
      if (settings.frameCount && settings.frameCount > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = settings.frameCount - 1;
          }
        }
      }
      if (compId === this.project.mainCompositionId) {
        Object.assign(this.project.composition, comp.settings);
      }
    },
    /**
     * Get a composition by ID
     */
    getComposition(compId) {
      return this.project.compositions[compId] || null;
    },
    /**
     * Nest selected layers into a new composition
     */
    nestSelectedLayers(name) {
      if (this.selectedLayerIds.length === 0) {
        storeLogger.warn("No layers selected for nesting");
        return null;
      }
      const activeComp = this.project.compositions[this.activeCompositionId];
      if (!activeComp) return null;
      const nestedComp = this.createComposition(
        name || "Nested Comp",
        activeComp.settings,
        true
      );
      const selectedLayers = activeComp.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      );
      const earliestIn = Math.min(...selectedLayers.map((l) => l.startFrame ?? l.inPoint ?? 0));
      for (const layer of selectedLayers) {
        const layerStart = layer.startFrame ?? layer.inPoint ?? 0;
        const layerEnd = layer.endFrame ?? layer.outPoint ?? 80;
        layer.startFrame = layerStart - earliestIn;
        layer.endFrame = layerEnd - earliestIn;
        layer.inPoint = layer.startFrame;
        layer.outPoint = layer.endFrame;
        const idx = activeComp.layers.indexOf(layer);
        if (idx >= 0) {
          activeComp.layers.splice(idx, 1);
        }
        nestedComp.layers.push(layer);
      }
      const maxOut = Math.max(...nestedComp.layers.map((l) => l.endFrame ?? l.outPoint ?? 80));
      nestedComp.settings.frameCount = maxOut + 1;
      nestedComp.settings.duration = nestedComp.settings.frameCount / nestedComp.settings.fps;
      const nestedEndFrame = earliestIn + nestedComp.settings.frameCount - 1;
      const nestedCompLayer = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: nestedComp.name,
        type: "nestedComp",
        visible: true,
        locked: false,
        isolate: false,
        threeD: false,
        // Timing (primary properties)
        startFrame: earliestIn,
        endFrame: nestedEndFrame,
        // Backwards compatibility aliases
        inPoint: earliestIn,
        outPoint: nestedEndFrame,
        parentId: null,
        transform: createDefaultTransform(),
        opacity: createAnimatableProperty("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: false,
        data: {
          compositionId: nestedComp.id,
          // Speed map (new naming)
          speedMapEnabled: false,
          // Backwards compatibility
          timeRemapEnabled: false,
          flattenTransform: false
        }
      };
      activeComp.layers.push(nestedCompLayer);
      useSelectionStore$1().clearLayerSelection();
      this.activeCompositionId = activeComp.id;
      storeLogger.debug("Nested layers into:", nestedComp.name);
      return nestedComp;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(inputs) {
      this.comfyuiNodeId = inputs.node_id;
      this.sourceImage = inputs.source_image;
      this.depthMap = inputs.depth_map;
      const comp = this.project.compositions[this.activeCompositionId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = inputs.width;
      comp.settings.height = inputs.height;
      comp.settings.frameCount = inputs.frame_count;
      comp.settings.duration = inputs.frame_count / comp.settings.fps;
      this.project.composition.width = inputs.width;
      this.project.composition.height = inputs.height;
      this.project.composition.frameCount = inputs.frame_count;
      this.project.composition.duration = inputs.frame_count / this.project.composition.fps;
      if (inputs.frame_count > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = inputs.frame_count - 1;
          }
        }
      }
      if (inputs.source_image) {
        this.project.assets["source_image"] = {
          id: "source_image",
          type: "image",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.source_image
        };
      }
      if (inputs.depth_map) {
        this.project.assets["depth_map"] = {
          id: "depth_map",
          type: "depth_map",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.depth_map
        };
      }
      if (comp) comp.currentFrame = 0;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      storeLogger.debug("Loaded inputs from ComfyUI:", {
        width: inputs.width,
        height: inputs.height,
        frameCount: inputs.frame_count
      });
      this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(type, name) {
      const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let layerData = null;
      switch (type) {
        case "text":
          layerData = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: false,
            pathPerpendicularToPath: true,
            pathForceAlignment: false,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid": {
          const activeComp = this.getActiveComp();
          layerData = {
            color: "#808080",
            width: activeComp?.settings.width || this.project.composition.width,
            height: activeComp?.settings.height || this.project.composition.height
          };
          break;
        }
        case "null":
          layerData = {
            size: 40
          };
          break;
        case "spline":
          layerData = {
            pathData: "",
            controlPoints: [],
            closed: false,
            stroke: "#00ff00",
            strokeWidth: 2,
            // Stroke options (shown in More Options group)
            lineCap: "round",
            // butt, round, square
            lineJoin: "round",
            // miter, round, bevel
            dashArray: "",
            // e.g., "10, 5" for dashed lines
            dashOffset: 0
          };
          break;
        case "particles": {
          const activeComp = this.getActiveComp();
          const compWidth2 = activeComp?.settings.width || this.project.composition.width;
          const compHeight2 = activeComp?.settings.height || this.project.composition.height;
          layerData = {
            systemConfig: {
              maxParticles: 1e4,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: false,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              // Use pixel coordinates - center of composition
              x: compWidth2 / 2,
              y: compHeight2 / 2,
              direction: 270,
              // Up direction (degrees, 270 = upward)
              spread: 30,
              speed: 150,
              // Pixels per second
              speedVariance: 30,
              size: 8,
              sizeVariance: 2,
              color: [255, 200, 100],
              // Orange-ish for visibility
              emissionRate: 30,
              // Particles per second
              initialBurst: 0,
              particleLifetime: 90,
              // Frames
              lifetimeVariance: 15,
              enabled: true,
              burstOnBeat: false,
              burstCount: 20,
              // Geometric emitter shape defaults
              shape: "point",
              shapeRadius: 50,
              shapeWidth: 100,
              shapeHeight: 100,
              shapeDepth: 100,
              shapeInnerRadius: 25,
              emitFromEdge: false,
              emitFromVolume: false,
              splinePath: null,
              sprite: {
                enabled: false,
                imageUrl: null,
                imageData: null,
                isSheet: false,
                columns: 1,
                rows: 1,
                totalFrames: 1,
                frameRate: 30,
                playMode: "loop",
                billboard: true,
                rotationEnabled: false,
                rotationSpeed: 0,
                rotationSpeedVariance: 0,
                alignToVelocity: false
              }
            }],
            gravityWells: [],
            vortices: [],
            modulations: [{
              id: "mod_opacity_1",
              emitterId: "*",
              property: "opacity",
              startValue: 1,
              endValue: 0,
              easing: "linear"
            }],
            renderOptions: {
              blendMode: "additive",
              renderTrails: false,
              trailLength: 5,
              trailOpacityFalloff: 0.7,
              particleShape: "circle",
              glowEnabled: true,
              glowRadius: 8,
              glowIntensity: 0.6,
              motionBlur: false,
              motionBlurStrength: 0.5,
              motionBlurSamples: 8,
              connections: {
                enabled: false,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: true
              }
            },
            turbulenceFields: [],
            subEmitters: []
          };
          break;
        }
        case "depthflow":
          layerData = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: false
            }
          };
          break;
        case "light":
          layerData = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: false,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          layerData = {
            cameraId: null,
            isActiveCamera: false
          };
          break;
        case "image":
          layerData = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          layerData = {
            assetId: null,
            loop: false,
            startTime: 0,
            speed: 1
          };
          break;
        case "shape":
          layerData = {
            contents: [],
            blendMode: "normal",
            quality: "normal",
            gpuAccelerated: false
          };
          break;
        case "adjustment":
          layerData = {
            color: "#808080",
            effectLayer: true,
            adjustmentLayer: true
            // Backwards compatibility
          };
          break;
        case "group":
          layerData = {
            collapsed: false,
            color: null,
            passThrough: true,
            isolate: false
          };
          break;
      }
      let audioProps = void 0;
      if (type === "video" || type === "audio") {
        audioProps = {
          level: createAnimatableProperty("Audio Levels", 0, "number")
          // 0dB default
        };
      }
      const comp = this.getActiveComp();
      const layers = this.getActiveCompLayers();
      const compWidth = comp?.settings.width || this.project.composition.width;
      const compHeight = comp?.settings.height || this.project.composition.height;
      const layerTransform = createDefaultTransform();
      layerTransform.position.value = { x: compWidth / 2, y: compHeight / 2, z: 0 };
      const originProp = layerTransform.origin || layerTransform.anchorPoint;
      if (type === "solid" && layerData) {
        const layerWidth = layerData.width || compWidth;
        const layerHeight = layerData.height || compHeight;
        if (originProp) originProp.value = { x: layerWidth / 2, y: layerHeight / 2, z: 0 };
      } else {
        if (originProp) originProp.value = { x: 0, y: 0, z: 0 };
      }
      let layerProperties = [];
      if (type === "spline") {
        layerProperties = [
          createAnimatableProperty("Stroke Width", layerData?.strokeWidth ?? 2, "number", "Stroke"),
          createAnimatableProperty("Stroke Opacity", layerData?.strokeOpacity ?? 100, "number", "Stroke"),
          // Line Cap, Line Join, Dashes are stored in layer.data and shown in More Options
          createAnimatableProperty("Trim Start", 0, "number", "Trim Paths"),
          createAnimatableProperty("Trim End", 100, "number", "Trim Paths"),
          createAnimatableProperty("Trim Offset", 0, "number", "Trim Paths")
          // Note: "Closed" is stored in layer.data.closed as a boolean, not animatable
          // It's displayed in the timeline via the Path Options group in EnhancedLayerTrack
        ];
      }
      const endFrameValue = (comp?.settings.frameCount || 81) - 1;
      const layer = {
        id,
        name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
        type,
        visible: true,
        locked: false,
        isolate: false,
        threeD: false,
        motionBlur: false,
        // Timing (primary properties)
        startFrame: 0,
        endFrame: endFrameValue,
        // Backwards compatibility aliases
        inPoint: 0,
        outPoint: endFrameValue,
        parentId: null,
        blendMode: "normal",
        opacity: createAnimatableProperty("opacity", 100, "number"),
        transform: layerTransform,
        audio: audioProps,
        properties: layerProperties,
        effects: [],
        data: layerData
      };
      if (type === "camera") {
        storeLogger.warn("Use createCameraLayer() for camera layers");
      }
      layers.unshift(layer);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Delete a layer
     */
    deleteLayer(layerId) {
      deleteLayer(this, layerId);
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(layerId) {
      return duplicateLayer(this, layerId);
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      copySelectedLayers(this);
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      return pasteLayers(this);
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      cutSelectedLayers(this);
    },
    /**
     * Select all layers in the active composition
     */
    selectAllLayers() {
      const layers = this.getActiveCompLayers();
      const selection = useSelectionStore$1();
      selection.selectLayers(layers.map((l) => l.id));
    },
    /**
     * Delete all selected layers
     */
    deleteSelectedLayers() {
      const selection = useSelectionStore$1();
      const layerIds = [...selection.selectedLayerIds];
      layerIds.forEach((id) => this.deleteLayer(id));
      selection.clearLayerSelection();
    },
    /**
     * Duplicate all selected layers
     */
    duplicateSelectedLayers() {
      const selection = useSelectionStore$1();
      const newLayerIds = [];
      selection.selectedLayerIds.forEach((id) => {
        const newLayer = duplicateLayer(this, id);
        if (newLayer) {
          newLayerIds.push(newLayer.id);
        }
      });
      if (newLayerIds.length > 0) {
        selection.selectLayers(newLayerIds);
      }
    },
    /**
     * Update layer properties
     */
    updateLayer(layerId, updates) {
      updateLayer(this, layerId, updates);
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(layerId, dataUpdates) {
      updateLayerData(this, layerId, dataUpdates);
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(layerId, point) {
      addSplineControlPoint(this, layerId, point);
    },
    /**
     * Insert a control point at a specific index in a spline layer
     */
    insertSplineControlPoint(layerId, point, index) {
      insertSplineControlPoint(this, layerId, point, index);
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(layerId, pointId, updates) {
      updateSplineControlPoint(this, layerId, pointId, updates);
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(layerId, pointId) {
      deleteSplineControlPoint(this, layerId, pointId);
    },
    /**
     * Enable animation mode on a spline layer (converts to keyframeable control points)
     */
    enableSplineAnimation(layerId) {
      enableSplineAnimation(this, layerId);
    },
    /**
     * Add keyframe to a spline control point property
     */
    addSplinePointKeyframe(layerId, pointId, property, frame) {
      addSplinePointKeyframe(this, layerId, pointId, property, frame);
    },
    /**
     * Add keyframes to all position properties of a control point
     */
    addSplinePointPositionKeyframe(layerId, pointId, frame) {
      addSplinePointPositionKeyframe(this, layerId, pointId, frame);
    },
    /**
     * Update spline control point with optional keyframe
     */
    updateSplinePointWithKeyframe(layerId, pointId, x, y, frame, addKeyframe = false) {
      updateSplinePointWithKeyframe(this, layerId, pointId, x, y, frame, addKeyframe);
    },
    /**
     * Get evaluated control points at a specific frame
     */
    getEvaluatedSplinePoints(layerId, frame) {
      return getEvaluatedSplinePoints(this, layerId, frame);
    },
    /**
     * Check if spline has animation enabled
     */
    isSplineAnimated(layerId) {
      return isSplineAnimated(this, layerId);
    },
    /**
     * Check if a control point has any keyframes
     */
    hasSplinePointKeyframes(layerId, pointId) {
      return hasSplinePointKeyframes(this, layerId, pointId);
    },
    /**
     * Simplify a spline by reducing control points (Douglas-Peucker)
     * @param tolerance - Distance threshold in pixels (higher = more simplification)
     */
    simplifySpline(layerId, tolerance) {
      simplifySpline(this, layerId, tolerance);
    },
    /**
     * Smooth spline handles to create smoother curves
     * @param amount - Smoothing amount 0-100 (100 = fully smooth)
     */
    smoothSplineHandles(layerId, amount) {
      smoothSplineHandles(this, layerId, amount);
    },
    /**
     * Copy a path from a spline layer and paste it as position keyframes on a target layer.
     * This creates a motion path where the layer follows the spline's shape over time.
     *
     * @param sourceSplineLayerId - The spline layer to copy the path from
     * @param targetLayerId - The layer to apply position keyframes to
     * @param options - Configuration options
     * @returns Number of keyframes created, or null if failed
     */
    copyPathToPosition(sourceSplineLayerId, targetLayerId, options) {
      return copyPathToPosition(this, sourceSplineLayerId, targetLayerId, options);
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(layerId) {
      toggleLayer3D(this, layerId);
    },
    /**
     * Reorder layers
     */
    moveLayer(layerId, newIndex) {
      moveLayer(this, layerId, newIndex);
    },
    /**
     * Replace layer source with a new asset (Alt+drag replacement)
     * Keeps all keyframes, effects, and transforms
     */
    replaceLayerSource(layerId, newSource) {
      replaceLayerSource(this, layerId, newSource);
    },
    /**
     * Selection
     */
    selectLayer(layerId, addToSelection = false) {
      selectLayer(this, layerId, addToSelection);
    },
    deselectLayer(layerId) {
      deselectLayer(this, layerId);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(layerId, parentId) {
      setLayerParent(this, layerId, parentId);
    },
    // ============================================================
    // TIME MANIPULATION
    // ============================================================
    /**
     * Apply time stretch to a video or nested comp layer
     * @param layerId - Target layer ID
     * @param options - Time stretch options including stretchFactor, holdInPlace, reverse
     */
    timeStretchLayer(layerId, options) {
      timeStretchLayer(this, layerId, options);
    },
    /**
     * Reverse layer playback by negating speed
     * @param layerId - Target layer ID
     */
    reverseLayer(layerId) {
      reverseLayer(this, layerId);
    },
    /**
     * Create freeze frame at current playhead
     * Uses speedMap with hold keyframes
     * @param layerId - Target layer ID
     */
    freezeFrameAtPlayhead(layerId) {
      const comp = this.getActiveComp();
      const storeWithFrame = {
        ...this,
        currentFrame: comp?.currentFrame ?? 0,
        fps: comp?.settings.fps ?? 30
      };
      freezeFrameAtPlayhead(storeWithFrame, layerId);
    },
    /**
     * Split layer at current playhead
     * Creates two layers: one ending at playhead, one starting at playhead
     * @param layerId - Target layer ID
     * @returns The new layer created after the split point
     */
    splitLayerAtPlayhead(layerId) {
      const comp = this.getActiveComp();
      const storeWithFrame = {
        ...this,
        currentFrame: comp?.currentFrame ?? 0
      };
      return splitLayerAtPlayhead(storeWithFrame, layerId);
    },
    clearSelection() {
      const selection = useSelectionStore$1();
      selection.clearAll();
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(propertyPath) {
      useSelectionStore$1().setSelectedPropertyPath(propertyPath);
    },
    // ============================================================
    // MOTION ENGINE INTEGRATION
    // ============================================================
    /**
     * Get evaluated FrameState for the current frame
     *
     * This is the CANONICAL way to get evaluated state for rendering.
     * Uses MotionEngine.evaluate() which is PURE and deterministic.
     *
     * @param frame - Optional frame override (defaults to currentFrame)
     * @returns Immutable FrameState snapshot
     */
    getFrameState(frame) {
      const comp = this.getActiveComp();
      const targetFrame = frame ?? (comp?.currentFrame ?? 0);
      return motionEngine.evaluate(
        targetFrame,
        this.project,
        this.audioAnalysis,
        this.activeCameraId
      );
    },
    // ============================================================
    // PLAYBACK CONTROLS
    // ============================================================
    /**
     * Start playback
     * NOTE: This only updates UI state (currentFrame).
     * Actual frame evaluation happens via getFrameState().
     */
    play() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) return;
      const comp = this.getActiveComp();
      if (!comp) return;
      playback.play(
        comp.settings.fps,
        comp.settings.frameCount,
        comp.currentFrame,
        (frame) => {
          comp.currentFrame = frame;
        }
      );
      this.isPlaying = true;
    },
    /**
     * Pause playback
     */
    pause() {
      const playback = usePlaybackStore();
      playback.stop();
      this.isPlaying = false;
    },
    /**
     * Toggle playback state
     */
    togglePlayback() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) {
        this.pause();
      } else {
        this.play();
      }
    },
    /**
     * Set current frame (UI state only)
     * Components watching currentFrame should call getFrameState() to evaluate.
     */
    setFrame(frame) {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
    },
    /**
     * Advance to next frame (UI state only)
     */
    nextFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame < comp.settings.frameCount - 1) {
        comp.currentFrame++;
      }
    },
    /**
     * Go to previous frame (UI state only)
     */
    prevFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame > 0) {
        comp.currentFrame--;
      }
    },
    /**
     * Jump to first frame (UI state only)
     */
    goToStart() {
      const comp = this.getActiveComp();
      if (comp) comp.currentFrame = 0;
    },
    /**
     * Jump to last frame (UI state only)
     */
    goToEnd() {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = comp.settings.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(tool) {
      if (tool === "segment") {
        this.segmentToolActive = true;
      } else {
        this.segmentToolActive = false;
        useSelectionStore$1().setTool(tool);
        this.clearSegmentPendingMask();
      }
    },
    /**
     * Set segmentation mode (point or box)
     */
    setSegmentMode(mode) {
      this.segmentMode = mode;
      this.clearSegmentPendingMask();
    },
    /**
     * Clear pending segmentation mask
     */
    clearSegmentPendingMask() {
      this.segmentPendingMask = null;
      this.segmentBoxStart = null;
    },
    /**
     * Set pending segmentation mask (preview before creating layer)
     */
    setSegmentPendingMask(mask) {
      this.segmentPendingMask = mask;
    },
    /**
     * Set box selection start point
     */
    setSegmentBoxStart(point) {
      this.segmentBoxStart = point;
    },
    /**
     * Set segmentation loading state
     */
    setSegmentLoading(loading) {
      this.segmentIsLoading = loading;
    },
    /**
     * Confirm pending mask and create layer from it
     */
    async confirmSegmentMask(layerName) {
      if (!this.segmentPendingMask || !this.sourceImage) {
        return null;
      }
      const layer = await createLayerFromMask(
        this,
        this.sourceImage,
        this.segmentPendingMask,
        layerName,
        false
      );
      this.clearSegmentPendingMask();
      return layer;
    },
    /**
     * History management
     */
    pushHistory() {
      pushHistory(this);
    },
    undo() {
      undo(this);
    },
    redo() {
      redo(this);
    },
    /**
     * Project serialization
     */
    exportProject() {
      return exportProject(this);
    },
    importProject(json) {
      importProject(this, json, () => this.pushHistory());
    },
    /**
     * Save project to server (ComfyUI backend)
     */
    async saveProjectToServer(projectId) {
      return saveProjectToServer(this, projectId);
    },
    /**
     * Load project from server (ComfyUI backend)
     */
    async loadProjectFromServer(projectId) {
      return loadProjectFromServer(this, projectId, () => this.pushHistory());
    },
    /**
     * List all projects saved on server
     */
    async listServerProjects() {
      return listServerProjects();
    },
    /**
     * Delete a project from server
     */
    async deleteServerProject(projectId) {
      return deleteServerProject(projectId);
    },
    /**
     * Remove unused assets from the project (Reduce Project)
     * Returns info about removed assets
     */
    removeUnusedAssets() {
      return removeUnusedAssets(this);
    },
    /**
     * Get statistics about asset usage
     */
    getAssetUsageStats() {
      return getAssetUsageStats(this);
    },
    /**
     * Collect Files - Package project and assets into a downloadable ZIP
     * @param includeUnused - Whether to include assets not used by any layer
     */
    async collectFiles(options = {}) {
      return downloadCollectedFiles(this, options);
    },
    /**
     * Toggle curve editor visibility
     */
    toggleCurveEditor() {
      this.curveEditorVisible = !this.curveEditorVisible;
    },
    /**
     * Toggle hide minimized layers in timeline
     */
    toggleHideMinimizedLayers() {
      this.hideMinimizedLayers = !this.hideMinimizedLayers;
    },
    /** @deprecated Use toggleHideMinimizedLayers instead */
    toggleHideShyLayers() {
      this.toggleHideMinimizedLayers();
    },
    /**
     * Set hide minimized layers state
     */
    setHideMinimizedLayers(hide) {
      this.hideMinimizedLayers = hide;
    },
    /** @deprecated Use setHideMinimizedLayers instead */
    setHideShyLayers(hide) {
      this.setHideMinimizedLayers(hide);
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(property) {
      return interpolateProperty(property, this.getActiveComp()?.currentFrame ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(layerId, propertyName, value, atFrame) {
      return addKeyframe(this, layerId, propertyName, value, atFrame);
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(layerId, propertyName, keyframeId) {
      removeKeyframe(this, layerId, propertyName, keyframeId);
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(layerId, propertyPath, value) {
      setPropertyValue(this, layerId, propertyPath, value);
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(layerId, propertyPath, animated) {
      setPropertyAnimated(this, layerId, propertyPath, animated, () => {
        this.addKeyframe(layerId, propertyPath, findPropertyByPath(
          this.getActiveCompLayers().find((l) => l.id === layerId),
          propertyPath
        )?.value);
      });
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(layerId, propertyPath, keyframeId, newFrame) {
      moveKeyframe(this, layerId, propertyPath, keyframeId, newFrame);
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(layerId, propertyPath, keyframeId, newValue) {
      setKeyframeValue(this, layerId, propertyPath, keyframeId, newValue);
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(layerId, propertyPath, keyframeId, interpolation) {
      setKeyframeInterpolation(this, layerId, propertyPath, keyframeId, interpolation);
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(layerId, propertyPath, keyframeId, updates) {
      updateKeyframe(this, layerId, propertyPath, keyframeId, updates);
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(layerId, propertyPath, keyframeId, handleType, handle) {
      setKeyframeHandle(this, layerId, propertyPath, keyframeId, handleType, handle);
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(text = "Text") {
      const layer = this.createLayer("text", text.substring(0, 20));
      const textData = {
        text,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: false
      };
      layer.data = textData;
      layer.properties.push(createAnimatableProperty("Font Size", 72, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Fill Color", "#ffffff", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Color", "#000000", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Width", 0, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Path Offset", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("First Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Last Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options"));
      layer.properties.push(createAnimatableProperty("Tracking", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Line Spacing", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Offset", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Value", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Blur", { x: 0, y: 0 }, "position", "Advanced"));
      return layer;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const layer = this.createLayer("spline");
      const splineData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      layer.data = splineData;
      return layer;
    },
    /**
     * Create a shape layer with proper data structure
     */
    createShapeLayer(name = "Shape Layer") {
      const layer = this.createLayer("shape", name);
      return layer;
    },
    /**
     * Rename a layer by ID
     */
    renameLayer(layerId, newName) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (layer) {
        layer.name = newName;
        this.pushHistory();
      }
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const layer = this.createLayer("particles", "Particle System");
      const activeComp = this.getActiveComp();
      const compWidth = activeComp?.settings.width || this.project.composition.width;
      const compHeight = activeComp?.settings.height || this.project.composition.height;
      const particleData = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          // Use pixel coordinates - center of composition
          x: compWidth / 2,
          y: compHeight / 2,
          direction: 270,
          // Up direction (270 degrees)
          spread: 30,
          speed: 150,
          // Pixels per second
          speedVariance: 30,
          size: 8,
          sizeVariance: 2,
          color: [255, 200, 100],
          emissionRate: 30,
          // Particles per second
          initialBurst: 0,
          particleLifetime: 90,
          lifetimeVariance: 15,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20,
          // Geometric emitter shape defaults (in pixels)
          shape: "point",
          shapeRadius: 50,
          shapeWidth: 100,
          shapeHeight: 100,
          shapeDepth: 100,
          shapeInnerRadius: 25,
          emitFromEdge: false,
          emitFromVolume: false,
          // Spline path emission (null = disabled)
          splinePath: null,
          // Sprite configuration
          sprite: {
            enabled: false,
            imageUrl: null,
            imageData: null,
            isSheet: false,
            columns: 1,
            rows: 1,
            totalFrames: 1,
            frameRate: 30,
            playMode: "loop",
            billboard: true,
            rotationEnabled: false,
            rotationSpeed: 0,
            rotationSpeedVariance: 0,
            alignToVelocity: false
          }
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      layer.data = particleData;
      return layer;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(layerId, config) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters.push(config);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(layerId, emitterId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      const emitter = data.emitters.find((e) => e.id === emitterId);
      if (emitter) {
        Object.assign(emitter, updates);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(layerId, emitterId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters = data.emitters.filter((e) => e.id !== emitterId);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(sourceLayerId = "", depthLayerId = "") {
      const layer = this.createLayer("depthflow", "Depthflow");
      const depthflowData = {
        sourceLayerId,
        depthLayerId,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        },
        animatedZoom: createAnimatableProperty("zoom", 1, "number"),
        animatedOffsetX: createAnimatableProperty("offsetX", 0, "number"),
        animatedOffsetY: createAnimatableProperty("offsetY", 0, "number"),
        animatedRotation: createAnimatableProperty("rotation", 0, "number"),
        animatedDepthScale: createAnimatableProperty("depthScale", 1, "number")
      };
      layer.data = depthflowData;
      return layer;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "depthflow") return;
      const data = layer.data;
      Object.assign(data.config, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(file, autoResizeComposition = true) {
      let videoUrl;
      try {
        videoUrl = URL.createObjectURL(file);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let metadata;
      try {
        metadata = await extractVideoMetadata(videoUrl);
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        throw new Error(`Failed to load video metadata: ${error.message}`);
      }
      const assetId = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const asset = {
        id: assetId,
        type: "video",
        source: "file",
        width: metadata.width,
        height: metadata.height,
        data: videoUrl,
        // Video-specific metadata
        duration: metadata.duration,
        frameCount: metadata.frameCount,
        fps: metadata.fps,
        hasAudio: metadata.hasAudio
      };
      this.project.assets[assetId] = asset;
      if (autoResizeComposition) {
        const compSettings = calculateCompositionFromVideo(metadata, this.project.composition.fps);
        storeLogger.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: compSettings.width,
          newHeight: compSettings.height,
          newFrameCount: compSettings.frameCount,
          videoDuration: metadata.duration
        });
        this.project.composition.width = compSettings.width;
        this.project.composition.height = compSettings.height;
        this.project.composition.frameCount = compSettings.frameCount;
        this.project.composition.duration = compSettings.frameCount / this.project.composition.fps;
      }
      const layer = this.createLayer("video", file.name.replace(/\.[^.]+$/, ""));
      const videoData = {
        assetId,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        // Speed map (new naming)
        speedMapEnabled: false,
        speedMap: void 0,
        // Backwards compatibility
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: metadata.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      layer.data = videoData;
      if (!autoResizeComposition) {
        const videoFrameCount = Math.ceil(metadata.duration * this.project.composition.fps);
        layer.outPoint = Math.min(videoFrameCount - 1, this.project.composition.frameCount - 1);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Created video layer:", {
        layerId: layer.id,
        assetId,
        dimensions: `${metadata.width}x${metadata.height}`,
        duration: `${metadata.duration.toFixed(2)}s`,
        frameCount: metadata.frameCount,
        hasAudio: metadata.hasAudio
      });
      return layer;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(layerId, metadata) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const videoData = layer.data;
      if (!videoData.assetId) return;
      const asset = this.project.assets[videoData.assetId];
      if (asset) {
        asset.width = metadata.width;
        asset.height = metadata.height;
        asset.duration = metadata.duration;
        asset.frameCount = metadata.frameCount;
        asset.fps = metadata.fps;
        asset.hasAudio = metadata.hasAudio;
      }
      storeLogger.debug("Video metadata loaded:", { layerId, metadata });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(width, height, frameCount) {
      const comp = this.getActiveComp();
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = width;
      comp.settings.height = height;
      this.project.composition.width = width;
      this.project.composition.height = height;
      if (frameCount !== void 0) {
        comp.settings.frameCount = frameCount;
        comp.settings.duration = frameCount / comp.settings.fps;
        this.project.composition.frameCount = frameCount;
        this.project.composition.duration = frameCount / this.project.composition.fps;
        if (frameCount > oldFrameCount) {
          for (const layer of comp.layers) {
            if (layer.outPoint === oldFrameCount - 1) {
              layer.outPoint = frameCount - 1;
            }
          }
        }
      }
      if (comp.currentFrame >= comp.settings.frameCount) {
        comp.currentFrame = comp.settings.frameCount - 1;
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Composition resized:", {
        width,
        height,
        frameCount: comp.settings.frameCount
      });
    },
    // ============================================================
    // NESTED COMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a nested comp layer referencing another composition
     */
    createNestedCompLayer(compositionId, name) {
      const layer = this.createLayer("nestedComp", name || "Nested Comp");
      const nestedCompData = {
        compositionId,
        // Speed map (new naming)
        speedMapEnabled: false,
        speedMap: void 0,
        // Backwards compatibility
        timeRemapEnabled: false,
        timeRemap: void 0,
        flattenTransform: false,
        overrideFrameRate: false,
        frameRate: void 0
      };
      layer.data = nestedCompData;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Update nested comp layer data
     */
    updateNestedCompLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "nestedComp") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // SEGMENTATION ACTIONS (delegated to segmentationActions)
    // ============================================================
    async segmentToLayerByPoint(point, options = {}) {
      return segmentToLayerByPoint(this, point, options);
    },
    async segmentToLayerByBox(box, options = {}) {
      return segmentToLayerByBox(this, box, options);
    },
    async segmentToLayerByMultiplePoints(foregroundPoints, backgroundPoints = [], options = {}) {
      return segmentToLayerByMultiplePoints(this, foregroundPoints, backgroundPoints, options);
    },
    async autoSegmentToLayers(options = {}) {
      return autoSegmentToLayers(this, options);
    },
    // ============================================================
    // EFFECT ACTIONS (delegated to effectActions)
    // ============================================================
    addEffectToLayer(layerId, effectKey) {
      addEffectToLayer(this, layerId, effectKey);
    },
    removeEffectFromLayer(layerId, effectId) {
      removeEffectFromLayer(this, layerId, effectId);
    },
    updateEffectParameter(layerId, effectId, paramKey, value) {
      updateEffectParameter(this, layerId, effectId, paramKey, value);
    },
    setEffectParamAnimated(layerId, effectId, paramKey, animated) {
      setEffectParamAnimated(this, layerId, effectId, paramKey, animated);
    },
    toggleEffect(layerId, effectId) {
      toggleEffect(this, layerId, effectId);
    },
    reorderEffects(layerId, fromIndex, toIndex) {
      reorderEffects(this, layerId, fromIndex, toIndex);
    },
    getEffectParameterValue(layerId, effectId, paramKey, frame) {
      return getEffectParameterValue(this, layerId, effectId, paramKey, frame);
    },
    // ============================================================
    // CAMERA ACTIONS (delegated to cameraActions module)
    // ============================================================
    createCameraLayer(name) {
      return createCameraLayer(this, name);
    },
    getCamera(cameraId) {
      return getCamera(this, cameraId);
    },
    updateCamera(cameraId, updates) {
      updateCamera(this, cameraId, updates);
    },
    setActiveCamera(cameraId) {
      setActiveCamera(this, cameraId);
    },
    deleteCamera(cameraId) {
      deleteCamera(this, cameraId);
    },
    getCameraKeyframes(cameraId) {
      return getCameraKeyframes(this, cameraId);
    },
    addCameraKeyframe(cameraId, keyframe) {
      addCameraKeyframe(this, cameraId, keyframe);
    },
    removeCameraKeyframe(cameraId, frame) {
      removeCameraKeyframe(this, cameraId, frame);
    },
    getCameraAtFrame(cameraId, frame) {
      return getCameraAtFrame(this, cameraId, frame);
    },
    getActiveCameraAtFrame(frame) {
      return getActiveCameraAtFrame(this, frame);
    },
    updateViewportState(updates) {
      updateViewportState(this, updates);
    },
    updateViewOptions(updates) {
      updateViewOptions(this, updates);
    },
    // ============================================================
    // AUDIO ACTIONS (delegated to audioActions module)
    // ============================================================
    async loadAudio(file) {
      return loadAudio(this, file);
    },
    cancelAudioLoad() {
      cancelAudioLoad(this);
    },
    clearAudio() {
      clearAudio(this);
    },
    setAudioVolume(volume) {
      this.audioVolume = Math.max(0, Math.min(100, volume));
    },
    setAudioMuted(muted) {
      this.audioMuted = muted;
    },
    toggleAudioMute() {
      this.audioMuted = !this.audioMuted;
    },
    getAudioFeatureAtFrame(feature, frame) {
      return getAudioFeatureAtFrame(this, feature, frame);
    },
    applyAudioToParticles(layerId, mapping) {
      applyAudioToParticles(this, layerId, mapping);
    },
    removeLegacyAudioMapping(layerId, index) {
      removeLegacyAudioMapping(this, layerId, index);
    },
    getAudioMappingsForLayer(layerId) {
      return getAudioMappingsForLayer(this, layerId);
    },
    setPeakData(peakData) {
      setPeakData(this, peakData);
    },
    detectAudioPeaks(config) {
      return detectAudioPeaks(this, config);
    },
    addAudioMapping(mapping) {
      addAudioMapping(this, mapping);
    },
    removeAudioMapping(mappingId) {
      removeAudioMapping(this, mappingId);
    },
    updateAudioMapping(mappingId, updates) {
      updateAudioMapping(this, mappingId, updates);
    },
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    getMappedValueAtFrame(mappingId, frame) {
      return getMappedValueAtFrame(this, mappingId, frame);
    },
    getAllMappedValuesAtFrame(frame) {
      return getAllMappedValuesAtFrame(this, frame);
    },
    getActiveMappingsForLayer(layerId) {
      return getActiveMappingsForLayer(this, layerId);
    },
    getAudioReactiveValuesForLayer(layerId, frame) {
      return getAudioReactiveValuesForLayer(this, layerId, frame);
    },
    isBeatAtCurrentFrame() {
      return isBeatAtCurrentFrame(this);
    },
    // Timeline snapping (simple inline - no need for delegation)
    findSnapPoint(frame, pixelsPerFrame, selectedLayerId) {
      return findNearestSnap(frame, this.snapConfig, pixelsPerFrame, {
        layers: this.layers,
        selectedLayerId,
        currentFrame: this.getActiveComp()?.currentFrame ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    getAudioBeatFrames() {
      return getBeatFrames(this.audioAnalysis);
    },
    getAudioPeakFrames() {
      return getPeakFrames(this.peakData);
    },
    setSnapConfig(config) {
      this.snapConfig = { ...this.snapConfig, ...config };
    },
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    toggleSnapType(type) {
      const typeMap = {
        "grid": "snapToGrid",
        "keyframes": "snapToKeyframes",
        "beats": "snapToBeats",
        "peaks": "snapToPeaks",
        "layerBounds": "snapToLayerBounds",
        "playhead": "snapToPlayhead"
      };
      const key = typeMap[type];
      if (key && typeof this.snapConfig[key] === "boolean") {
        this.snapConfig[key] = !this.snapConfig[key];
      }
    },
    // Path animator (delegated to audioActions module)
    createPathAnimator(layerId, config = {}) {
      createPathAnimator(this, layerId, config);
    },
    setPathAnimatorPath(layerId, pathData) {
      setPathAnimatorPath(this, layerId, pathData);
    },
    updatePathAnimatorConfig(layerId, config) {
      updatePathAnimatorConfig(this, layerId, config);
    },
    removePathAnimator(layerId) {
      removePathAnimator(this, layerId);
    },
    getPathAnimator(layerId) {
      return getPathAnimator(this, layerId);
    },
    updatePathAnimators() {
      updatePathAnimators(this);
    },
    resetPathAnimators() {
      resetPathAnimators(this);
    },
    initializeAudioReactiveMapper() {
      initializeAudioReactiveMapper(this);
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (delegated to propertyDriverActions)
    // ============================================================
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new PropertyDriverSystem();
      this.propertyDriverSystem.setPropertyGetter((layerId, propertyPath, frame) => {
        return this.getPropertyValueAtFrame(layerId, propertyPath, frame);
      });
      if (this.audioAnalysis) this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const driver of this.propertyDrivers) this.propertyDriverSystem.addDriver(driver);
    },
    getPropertyValueAtFrame(layerId, propertyPath, frame) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return null;
      const parts = propertyPath.split(".");
      if (parts[0] === "transform") {
        const t = layer.transform;
        if (parts[1] === "position") {
          const p = interpolateProperty(t.position, frame);
          return parts[2] === "x" ? p.x : parts[2] === "y" ? p.y : p.z ?? 0;
        }
        if (parts[1] === "anchorPoint" || parts[1] === "origin") {
          const originProp = t.origin || t.anchorPoint;
          if (!originProp) return 0;
          const a = interpolateProperty(originProp, frame);
          return parts[2] === "x" ? a.x : parts[2] === "y" ? a.y : a.z ?? 0;
        }
        if (parts[1] === "scale") {
          const s = interpolateProperty(t.scale, frame);
          return parts[2] === "x" ? s.x : parts[2] === "y" ? s.y : s.z ?? 100;
        }
        if (parts[1] === "rotation") return interpolateProperty(t.rotation, frame);
        if (parts[1] === "rotationX" && t.rotationX) return interpolateProperty(t.rotationX, frame);
        if (parts[1] === "rotationY" && t.rotationY) return interpolateProperty(t.rotationY, frame);
        if (parts[1] === "rotationZ" && t.rotationZ) return interpolateProperty(t.rotationZ, frame);
      }
      return parts[0] === "opacity" ? interpolateProperty(layer.opacity, frame) : null;
    },
    getDrivenValuesForLayer(layerId) {
      return getEvaluatedLayerProperties(this, layerId, this.getActiveComp()?.currentFrame ?? 0);
    },
    addPropertyDriver(driver) {
      return addPropertyDriver(this, driver);
    },
    createAudioPropertyDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
      return createAudioPropertyDriver(this, targetLayerId, targetProperty, audioFeature, options);
    },
    createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
      return createPropertyLinkDriver(this, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options);
    },
    removePropertyDriver(driverId) {
      removePropertyDriver(this, driverId);
    },
    updatePropertyDriver(driverId, updates) {
      updatePropertyDriver(this, driverId, updates);
    },
    getDriversForLayer(layerId) {
      return getDriversForLayer(this, layerId);
    },
    togglePropertyDriver(driverId) {
      togglePropertyDriver(this, driverId);
    },
    // ============================================================
    // PARTICLE SIMULATION ACTIONS
    // ============================================================
    /**
     * Reset a particle layer's simulation
     * Called when particle configuration changes
     */
    resetParticleSimulation(layerId) {
      particleSimulationRegistry.resetLayer(layerId);
      storeLogger.debug("Reset particle simulation for layer:", layerId);
    },
    /**
     * Clear all particle simulations
     * Called on project load/new
     */
    clearAllParticleSimulations() {
      particleSimulationRegistry.clear();
      storeLogger.debug("Cleared all particle simulations");
    },
    /**
     * Get particle snapshot for a layer at a specific frame
     * Evaluates the frame state to get the deterministic snapshot
     */
    getParticleSnapshot(layerId, frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots[layerId] ?? null;
    },
    /**
     * Get all particle snapshots from current frame
     */
    getAllParticleSnapshots(frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots;
    },
    // ============================================================
    // AUTOSAVE/PROJECT ACTIONS (delegated to projectActions)
    // ============================================================
    enableAutosave(intervalMs) {
      configureAutosave(this, { enabled: true, intervalMs }, () => this.performAutosave());
    },
    disableAutosave() {
      stopAutosave(this);
      this.autosaveEnabled = false;
    },
    startAutosaveTimer() {
      startAutosave(this, () => this.performAutosave());
    },
    stopAutosaveTimer() {
      stopAutosave(this);
    },
    async performAutosave() {
      return performAutosave(this);
    },
    markUnsavedChanges() {
      markUnsavedChanges(this);
      this.invalidateFrameCache();
    },
    async saveProjectToBackend() {
      const result = await saveProjectToServer(this);
      if (!result) throw new Error("Save failed");
      return result;
    },
    async loadProjectFromBackend(projectId) {
      const success = await loadProjectFromServer(this, projectId, () => this.pushHistory());
      if (!success) throw new Error("Load failed");
    },
    async listSavedProjects() {
      return listServerProjects();
    },
    // ============================================================
    // FRAME CACHE ACTIONS (delegated to cacheActions)
    // ============================================================
    async initializeFrameCache() {
      return initializeCache(this);
    },
    setFrameCacheEnabled(enabled) {
      setFrameCacheEnabled(this, enabled);
    },
    getCachedFrame(frame) {
      return getCachedFrame(this, frame);
    },
    async cacheFrame(frame, imageData) {
      return cacheFrame(this, frame, imageData);
    },
    isFrameCached(frame) {
      return isFrameCached(this, frame);
    },
    async startPreCache(currentFrame, direction = "both") {
      return startPreCache(this, currentFrame, direction);
    },
    invalidateFrameCache() {
      invalidateFrameCache(this);
    },
    clearFrameCache() {
      clearFrameCache();
    },
    getFrameCacheStats() {
      return getFrameCacheStats();
    },
    computeProjectHash() {
      return computeProjectHash(this);
    }
  }
});

const compositorStore = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  useCompositorStore
}, Symbol.toStringTag, { value: 'Module' }));

const comfyLogger = createLogger("ComfyUI");
class ComfyUIClient {
  serverAddress;
  clientId;
  ws = null;
  messageHandlers = /* @__PURE__ */ new Map();
  constructor(config) {
    this.serverAddress = config.serverAddress.replace(/\/$/, "");
    this.clientId = config.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + secureUUID();
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      });
      return response.ok;
    } catch {
      return false;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const response = await fetch(`http://${this.serverAddress}/prompt`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(imageData, filename, type = "input", subfolder, overwrite = true) {
    const formData = new FormData();
    formData.append("image", imageData, filename);
    formData.append("type", type);
    formData.append("overwrite", overwrite.toString());
    if (subfolder) {
      formData.append("subfolder", subfolder);
    }
    const response = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to upload image: ${error}`);
    }
    return response.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(maskData, filename, originalRef) {
    const formData = new FormData();
    formData.append("image", maskData, filename);
    formData.append("original_ref", JSON.stringify(originalRef));
    formData.append("type", "input");
    const response = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Failed to upload mask: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(workflow, extraData) {
    const payload = {
      prompt: workflow,
      client_id: this.clientId,
      extra_data: extraData
    };
    const response = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to queue prompt: ${error}`);
    }
    return response.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(promptId) {
    const url = promptId ? `http://${this.serverAddress}/history/${promptId}` : `http://${this.serverAddress}/history`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to get history: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(filename, subfolder = "", type = "output") {
    const params = new URLSearchParams({
      filename,
      subfolder,
      type
    });
    const response = await fetch(`http://${this.serverAddress}/view?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to get output: ${await response.text()}`);
    }
    return response.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(filename, subfolder = "", type = "output") {
    const blob = await this.getOutput(filename, subfolder, type);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const response = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`Failed to interrupt: ${await response.text()}`);
    }
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const response = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: true })
    });
    if (!response.ok) {
      throw new Error(`Failed to clear queue: ${await response.text()}`);
    }
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(deleteType, ids) {
    const response = await fetch(`http://${this.serverAddress}/${deleteType}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: ids })
    });
    if (!response.ok) {
      throw new Error(`Failed to delete from ${deleteType}: ${await response.text()}`);
    }
  }
  /**
   * Get available models
   */
  async getModels(type) {
    const folderMap = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    };
    const response = await fetch(
      `http://${this.serverAddress}/models/${folderMap[type]}`
    );
    if (!response.ok) {
      return [];
    }
    return response.json();
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const wsUrl = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(wsUrl);
      this.ws.onopen = () => {
        comfyLogger.debug("WebSocket connected");
        resolve();
      };
      this.ws.onerror = (event) => {
        comfyLogger.error("WebSocket error:", event);
        reject(new Error("WebSocket connection failed"));
      };
      this.ws.onclose = () => {
        comfyLogger.debug("WebSocket disconnected");
        this.ws = null;
      };
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (e) {
          comfyLogger.error("Failed to parse WebSocket message:", e);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.messageHandlers.clear();
  }
  /**
   * Clean up all resources (WebSocket, handlers)
   * Call this when the client is no longer needed
   */
  destroy() {
    this.disconnectWebSocket();
    comfyLogger.debug("ComfyUI client destroyed");
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  /**
   * Remove a message handler
   */
  offMessage(type) {
    this.messageHandlers.delete(type);
  }
  handleWebSocketMessage(data) {
    const { type } = data;
    const handler = this.messageHandlers.get(type);
    if (handler) {
      handler(data);
    }
    const allHandler = this.messageHandlers.get("all");
    if (allHandler) {
      allHandler(data);
    }
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(imageData, filename, subfolder) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(canvas, filename, subfolder) {
    let blob;
    if (canvas instanceof OffscreenCanvas) {
      blob = await canvas.convertToBlob({ type: "image/png" });
    } else {
      blob = await new Promise((resolve, reject) => {
        canvas.toBlob((b) => {
          if (b) resolve(b);
          else reject(new Error("Failed to convert canvas to blob"));
        }, "image/png");
      });
    }
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(promptId, onProgress, timeoutMs = 3e5) {
    const startTime = Date.now();
    if (!this.isWebSocketConnected()) {
      await this.connectWebSocket();
    }
    return new Promise((resolve, reject) => {
      let completed = false;
      const cleanup = () => {
        this.offMessage("progress");
        this.offMessage("executing");
        this.offMessage("executed");
        this.offMessage("execution_error");
      };
      const checkTimeout = () => {
        if (Date.now() - startTime > timeoutMs) {
          cleanup();
          reject(new Error("Prompt execution timed out"));
        }
      };
      this.onMessage("progress", (data) => {
        checkTimeout();
        onProgress?.({
          status: "executing",
          currentStep: data.data.value,
          totalSteps: data.data.max,
          percentage: data.data.value / data.data.max * 100
        });
      });
      this.onMessage("executing", (data) => {
        checkTimeout();
        if (data.data.prompt_id === promptId) {
          onProgress?.({
            status: "executing",
            currentNode: data.data.node,
            percentage: 10
            // Approximate
          });
        }
      });
      this.onMessage("executed", async (data) => {
        if (data.data.prompt_id === promptId && !completed) {
          completed = true;
          cleanup();
          onProgress?.({
            status: "completed",
            percentage: 100
          });
          const history = await this.getHistory(promptId);
          resolve(history[promptId]);
        }
      });
      this.onMessage("execution_error", (data) => {
        if (data.data.prompt_id === promptId) {
          cleanup();
          onProgress?.({
            status: "error",
            percentage: 0
          });
          reject(new Error(data.data.exception_message || "Execution failed"));
        }
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(workflow, onProgress) {
    const { prompt_id } = await this.queuePrompt(workflow);
    onProgress?.({
      status: "queued",
      percentage: 0
    });
    const history = await this.waitForPrompt(prompt_id, onProgress);
    const outputs = [];
    for (const nodeOutputs of Object.values(history.outputs)) {
      if (nodeOutputs.images) {
        outputs.push(...nodeOutputs.images);
      }
      if (nodeOutputs.gifs) {
        outputs.push(...nodeOutputs.gifs);
      }
    }
    return {
      promptId: prompt_id,
      history,
      outputs
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let defaultClient = null;
function getComfyUIClient(serverAddress) {
  if (!defaultClient || serverAddress && serverAddress !== defaultClient.server) {
    defaultClient = new ComfyUIClient({
      serverAddress: serverAddress || "127.0.0.1:8188"
    });
  }
  return defaultClient;
}

const logger$6 = createLogger("MemoryBudget");
const VRAM_ESTIMATES = {
  // AI Models
  "model:qwen-image-layered": 28800,
  "model:starvector": 4e3};
const THRESHOLDS = {
  info: 0.5,
  // 50% - getting busy
  warning: 0.75,
  // 75% - should consider cleanup
  critical: 0.9
  // 90% - likely to fail soon
};
const allocations = reactive(/* @__PURE__ */ new Map());
const gpuInfo = ref(null);
const isInitialized = ref(false);
const totalUsageMB = computed(() => {
  let total = 0;
  for (const alloc of allocations.values()) {
    total += alloc.estimatedMB;
  }
  return total;
});
const usageByCategory = computed(() => {
  const byCategory = {
    model: 0,
    texture: 0,
    framebuffer: 0,
    particles: 0,
    geometry: 0,
    audio: 0,
    other: 0
  };
  for (const alloc of allocations.values()) {
    byCategory[alloc.category] += alloc.estimatedMB;
  }
  return byCategory;
});
const availableVRAM = computed(() => {
  if (!gpuInfo.value) return 8e3;
  return gpuInfo.value.estimatedVRAM;
});
const usagePercent = computed(() => {
  return totalUsageMB.value / availableVRAM.value;
});
const warningLevel = computed(() => {
  const percent = usagePercent.value;
  if (percent >= THRESHOLDS.critical) return "critical";
  if (percent >= THRESHOLDS.warning) return "warning";
  if (percent >= THRESHOLDS.info) return "info";
  return "none";
});
const allocationList = computed(() => {
  return Array.from(allocations.values()).sort((a, b) => b.estimatedMB - a.estimatedMB);
});
const unloadableItems = computed(() => {
  return allocationList.value.filter((a) => a.canUnload);
});
async function initializeGPUDetection() {
  if (isInitialized.value) return;
  try {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
    if (gl) {
      const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Unknown";
      const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
      const estimatedVRAM = estimateVRAMFromRenderer(renderer);
      const tier = determineTier(estimatedVRAM);
      gpuInfo.value = {
        vendor,
        renderer,
        estimatedVRAM,
        tier
      };
      logger$6.info(`GPU detected: ${renderer} (~${estimatedVRAM}MB VRAM, tier: ${tier})`);
    } else {
      gpuInfo.value = {
        vendor: "Unknown",
        renderer: "Software",
        estimatedVRAM: 4e3,
        // Conservative 4GB
        tier: "low"
      };
      logger$6.warn("WebGL not available, using conservative estimates");
    }
    isInitialized.value = true;
  } catch (error) {
    logger$6.error("GPU detection failed:", error);
    gpuInfo.value = {
      vendor: "Unknown",
      renderer: "Unknown",
      estimatedVRAM: 8e3,
      tier: "medium"
    };
    isInitialized.value = true;
  }
}
function registerAllocation(id, name, category, estimatedMB, options) {
  const allocation = {
    id,
    name,
    category,
    estimatedMB,
    timestamp: Date.now(),
    canUnload: options?.canUnload ?? false,
    unloadFn: options?.unloadFn
  };
  allocations.set(id, allocation);
  logger$6.debug(`Registered: ${name} (${estimatedMB}MB) - Total: ${totalUsageMB.value}MB`);
  checkAndLogWarning();
}
function unregisterAllocation(id) {
  const alloc = allocations.get(id);
  if (alloc) {
    allocations.delete(id);
    logger$6.debug(`Unregistered: ${alloc.name} - Total: ${totalUsageMB.value}MB`);
  }
}
function getWarning() {
  const level = warningLevel.value;
  if (level === "none") return null;
  const percent = Math.round(usagePercent.value * 100);
  const suggestions = [];
  const categories = usageByCategory.value;
  if (categories.model > 1e3) {
    suggestions.push("Unload unused AI models to free GPU memory");
  }
  if (categories.texture > 500) {
    suggestions.push("Reduce image layer count or resolution");
  }
  if (categories.framebuffer > 200) {
    suggestions.push("Clear frame cache or reduce composition resolution");
  }
  if (categories.particles > 200) {
    suggestions.push("Reduce particle count or disable unused emitters");
  }
  if (categories.geometry > 500) {
    suggestions.push("Simplify point clouds or 3D models");
  }
  const unloadable = unloadableItems.value.slice(0, 3);
  for (const item of unloadable) {
    if (item.estimatedMB > 100) {
      suggestions.push(`Unload "${item.name}" to free ${formatMB(item.estimatedMB)}`);
    }
  }
  const messages = {
    info: `Memory usage at ${percent}% - consider cleanup for optimal performance`,
    warning: `Memory usage at ${percent}% - performance may degrade, cleanup recommended`,
    critical: `Memory usage at ${percent}% - high risk of crashes, immediate cleanup needed`
  };
  return {
    level,
    message: messages[level],
    suggestions
  };
}
function canAllocate(estimatedMB) {
  const afterUsage = (totalUsageMB.value + estimatedMB) / availableVRAM.value;
  if (afterUsage >= THRESHOLDS.critical) {
    return {
      canProceed: false,
      warning: {
        level: "critical",
        message: `This operation requires ~${formatMB(estimatedMB)} but would exceed safe memory limits`,
        suggestions: [
          "Unload AI models before proceeding",
          "Close other GPU-intensive applications",
          "Reduce project complexity"
        ]
      }
    };
  }
  if (afterUsage >= THRESHOLDS.warning) {
    return {
      canProceed: true,
      warning: {
        level: "warning",
        message: `This operation requires ~${formatMB(estimatedMB)} - consider cleanup first`,
        suggestions: ["Unload unused models", "Clear frame cache"]
      }
    };
  }
  return { canProceed: true, warning: null };
}
async function freeMemory(targetMB) {
  let freed = 0;
  const candidates = unloadableItems.value;
  for (const item of candidates) {
    if (freed >= targetMB) break;
    if (item.unloadFn) {
      try {
        await item.unloadFn();
        freed += item.estimatedMB;
        unregisterAllocation(item.id);
        logger$6.info(`Freed ${formatMB(item.estimatedMB)} by unloading "${item.name}"`);
      } catch (error) {
        logger$6.error(`Failed to unload "${item.name}":`, error);
      }
    }
  }
  return freed;
}
function estimateVRAMFromRenderer(renderer) {
  const r = renderer.toLowerCase();
  if (r.includes("rtx 4090")) return 24e3;
  if (r.includes("rtx 4080")) return 16e3;
  if (r.includes("rtx 4070")) return 12e3;
  if (r.includes("rtx 4060")) return 8e3;
  if (r.includes("rtx 3090")) return 24e3;
  if (r.includes("rtx 3080")) return 1e4;
  if (r.includes("rtx 3070")) return 8e3;
  if (r.includes("rtx 3060")) return 12e3;
  if (r.includes("rtx 2080")) return 8e3;
  if (r.includes("rtx 2070")) return 8e3;
  if (r.includes("rtx 2060")) return 6e3;
  if (r.includes("gtx 1080")) return 8e3;
  if (r.includes("gtx 1070")) return 8e3;
  if (r.includes("gtx 1060")) return 6e3;
  if (r.includes("rx 7900")) return 24e3;
  if (r.includes("rx 7800")) return 16e3;
  if (r.includes("rx 7700")) return 12e3;
  if (r.includes("rx 6900")) return 16e3;
  if (r.includes("rx 6800")) return 16e3;
  if (r.includes("rx 6700")) return 12e3;
  if (r.includes("rx 6600")) return 8e3;
  if (r.includes("apple m3 max")) return 48e3;
  if (r.includes("apple m3 pro")) return 18e3;
  if (r.includes("apple m3")) return 8e3;
  if (r.includes("apple m2 max")) return 32e3;
  if (r.includes("apple m2 pro")) return 16e3;
  if (r.includes("apple m2")) return 8e3;
  if (r.includes("apple m1")) return 8e3;
  if (r.includes("intel") && r.includes("iris")) return 4e3;
  if (r.includes("intel") && r.includes("uhd")) return 2e3;
  return 8e3;
}
function determineTier(vramMB) {
  if (vramMB >= 16e3) return "ultra";
  if (vramMB >= 8e3) return "high";
  if (vramMB >= 4e3) return "medium";
  return "low";
}
function formatMB(mb) {
  if (mb >= 1e3) {
    return `${(mb / 1e3).toFixed(1)}GB`;
  }
  return `${Math.round(mb)}MB`;
}
function checkAndLogWarning() {
  const warning = getWarning();
  if (warning) {
    if (warning.level === "critical") {
      logger$6.error(warning.message);
    } else if (warning.level === "warning") {
      logger$6.warn(warning.message);
    }
  }
}
const memoryState = {
  totalUsageMB,
  availableVRAM,
  usagePercent,
  warningLevel,
  usageByCategory,
  gpuInfo};

const logger$5 = createLogger("LayerDecomposition");
const MODEL_ALLOCATION_ID = "model:qwen-image-layered";
class LayerDecompositionService {
  baseUrl;
  constructor(serverAddress) {
    const client = getComfyUIClient(serverAddress);
    this.baseUrl = `http://${client.server}`;
  }
  /**
   * Get current model status (downloaded, loaded, errors)
   */
  async getStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/status`);
      const result = await response.json();
      if (result.status === "success") {
        return result.data;
      }
      throw new Error(result.message || "Failed to get model status");
    } catch (error) {
      logger$5.error("Failed to get model status:", error);
      throw error;
    }
  }
  /**
   * Download the model (28.8GB, may take a while)
   *
   * @param onProgress - Optional callback for download progress
   */
  async downloadModel(onProgress) {
    try {
      onProgress?.("starting", 0);
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/download`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      if (result.verification && !result.verification.verified && result.verification.files_invalid.length > 0) {
        throw new Error(`Model verification failed: ${result.verification.message}`);
      }
      onProgress?.("complete", 100);
      logger$5.info("Model download complete");
    } catch (error) {
      logger$5.error("Model download failed:", error);
      throw error;
    }
  }
  /**
   * Get current download progress
   */
  async getDownloadProgress() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/progress`);
      const result = await response.json();
      if (result.status === "success") {
        return result.data;
      }
      throw new Error(result.message || "Failed to get download progress");
    } catch (error) {
      logger$5.error("Failed to get download progress:", error);
      throw error;
    }
  }
  /**
   * Verify model integrity using SHA256 hashes
   */
  async verifyModel() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/verify`, {
        method: "POST"
      });
      const result = await response.json();
      return result.data;
    } catch (error) {
      logger$5.error("Failed to verify model:", error);
      throw error;
    }
  }
  /**
   * Poll download progress at intervals
   *
   * @param onProgress - Callback for progress updates
   * @param intervalMs - Polling interval (default 1000ms)
   * @returns Stop function to cancel polling
   */
  pollDownloadProgress(onProgress, intervalMs = 1e3) {
    let stopped = false;
    const poll = async () => {
      if (stopped) return;
      try {
        const progress = await this.getDownloadProgress();
        onProgress(progress);
        if (progress.stage === "complete" || progress.stage === "error" || progress.stage === "idle") {
          return;
        }
        setTimeout(poll, intervalMs);
      } catch (error) {
        logger$5.warn("Progress poll failed:", error);
        if (!stopped) {
          setTimeout(poll, intervalMs * 2);
        }
      }
    };
    poll();
    return () => {
      stopped = true;
    };
  }
  /**
   * Load the model into GPU memory
   */
  async loadModel() {
    const memCheck = canAllocate(VRAM_ESTIMATES["model:qwen-image-layered"]);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory");
    }
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/load`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      registerAllocation(
        MODEL_ALLOCATION_ID,
        "Qwen Image Layered Model",
        "model",
        VRAM_ESTIMATES["model:qwen-image-layered"],
        {
          canUnload: true,
          unloadFn: () => this.unloadModel()
        }
      );
      logger$5.info("Model loaded:", result.message);
    } catch (error) {
      logger$5.error("Model load failed:", error);
      throw error;
    }
  }
  /**
   * Unload the model from GPU memory
   */
  async unloadModel() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/unload`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      unregisterAllocation(MODEL_ALLOCATION_ID);
      logger$5.info("Model unloaded");
    } catch (error) {
      logger$5.error("Model unload failed:", error);
      throw error;
    }
  }
  /**
   * Decompose an image into RGBA layers
   *
   * @param imageDataUrl - Image as data URL (data:image/...;base64,...)
   * @param options - Decomposition options
   * @returns Array of decomposed layers
   */
  async decompose(imageDataUrl, options = {}) {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/decompose`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          num_layers: options.numLayers ?? 4,
          guidance_scale: options.guidanceScale ?? 3,
          num_inference_steps: options.numInferenceSteps ?? 50,
          seed: options.seed ?? null
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$5.info(`Decomposition complete: ${result.layers.length} layers`);
      return result.layers;
    } catch (error) {
      logger$5.error("Decomposition failed:", error);
      throw error;
    }
  }
  /**
   * One-click decomposition: handles download, load, decompose, and cleanup
   *
   * @param imageDataUrl - Image as data URL
   * @param options - Decomposition options
   * @param onProgress - Progress callback
   */
  async decomposeWithAutoSetup(imageDataUrl, options = {}, onProgress) {
    const autoUnload = options.autoUnload !== false;
    const generateLabels = options.generateSemanticLabels !== false;
    try {
      onProgress?.("checking", "Checking model status...");
      const status = await this.getStatus();
      if (!status.downloaded) {
        onProgress?.("downloading", "Downloading model (28.8GB)...");
        await this.downloadModel();
      }
      if (!status.loaded) {
        onProgress?.("loading", "Loading model into GPU memory...");
        await this.loadModel();
      }
      onProgress?.("decomposing", "Decomposing image into layers...");
      const layers = await this.decompose(imageDataUrl, options);
      if (generateLabels && layers.length > 0) {
        onProgress?.("labeling", "Generating semantic labels...");
        await this.generateSemanticLabels(layers);
      }
      onProgress?.("complete", `Generated ${layers.length} layers`);
      return layers;
    } finally {
      if (autoUnload) {
        onProgress?.("cleanup", "Freeing GPU memory...");
        try {
          await this.unloadModel();
          logger$5.info("Model auto-unloaded to free GPU memory");
        } catch (unloadError) {
          logger$5.warn("Failed to auto-unload model:", unloadError);
        }
      }
    }
  }
  /**
   * Generate semantic labels for decomposed layers using simple heuristics
   * Analyzes alpha channel coverage and position to assign meaningful names
   */
  async generateSemanticLabels(layers) {
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      try {
        const img = await dataUrlToImage(layer.image);
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const analysis = analyzeLayerContent(imageData);
        layer.label = generateLabelFromAnalysis(analysis, i, layers.length);
      } catch (error) {
        logger$5.warn(`Failed to analyze layer ${i}:`, error);
      }
    }
  }
}
let defaultService$1 = null;
function getLayerDecompositionService(serverAddress) {
  if (!defaultService$1) {
    defaultService$1 = new LayerDecompositionService(serverAddress);
  }
  return defaultService$1;
}
function dataUrlToImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}
function analyzeLayerContent(imageData) {
  const { data, width, height } = imageData;
  const totalPixels = width * height;
  let visiblePixels = 0;
  let solidPixels = 0;
  let weightedX = 0;
  let weightedY = 0;
  let totalR = 0, totalG = 0, totalB = 0;
  let colorSamples = 0;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const a = data[i + 3];
      if (a > 0) {
        visiblePixels++;
        const weight = a / 255;
        weightedX += x * weight;
        weightedY += y * weight;
        if (a > 200) {
          solidPixels++;
          totalR += r;
          totalG += g;
          totalB += b;
          colorSamples++;
        }
      }
    }
  }
  const coverage = visiblePixels / totalPixels;
  const solidCoverage = solidPixels / totalPixels;
  const centerX = visiblePixels > 0 ? weightedX / visiblePixels / width : 0.5;
  const centerY = visiblePixels > 0 ? weightedY / visiblePixels / height : 0.5;
  const avgColor = colorSamples > 0 ? { r: totalR / colorSamples, g: totalG / colorSamples, b: totalB / colorSamples } : { r: 128, g: 128, b: 128 };
  return {
    coverage,
    solidCoverage,
    verticalCenter: centerY,
    horizontalCenter: centerX,
    avgColor,
    isSparse: coverage < 0.1,
    isDense: solidCoverage > 0.8,
    isUpper: centerY < 0.4,
    isLower: centerY > 0.6,
    isEdge: coverage > 0.1 && coverage < 0.4 && solidCoverage < coverage * 0.5
  };
}
function generateLabelFromAnalysis(analysis, index, totalLayers) {
  const position = index / (totalLayers - 1);
  if (index === 0) {
    if (analysis.isDense) {
      return "Background (Solid)";
    }
    if (analysis.isUpper && analysis.coverage > 0.3) {
      return "Background (Sky)";
    }
    return "Background";
  }
  if (index === totalLayers - 1) {
    if (analysis.isSparse) {
      return "Foreground (Details)";
    }
    return "Foreground (Subject)";
  }
  if (analysis.isEdge) {
    return `Edges/Outlines (${index + 1})`;
  }
  if (analysis.isSparse) {
    if (analysis.isUpper) {
      return `Upper Details (${index + 1})`;
    }
    if (analysis.isLower) {
      return `Lower Details (${index + 1})`;
    }
    return `Sparse Elements (${index + 1})`;
  }
  if (analysis.isDense) {
    return `Solid Region (${index + 1})`;
  }
  if (position < 0.33) {
    return `Back Elements (${index + 1})`;
  }
  if (position > 0.66) {
    return `Front Elements (${index + 1})`;
  }
  return `Mid Elements (${index + 1})`;
}

const _hoisted_1$Z = { class: "decompose-dialog" };
const _hoisted_2$Y = { class: "dialog-header" };
const _hoisted_3$W = ["disabled"];
const _hoisted_4$V = { class: "dialog-content" };
const _hoisted_5$V = { class: "status-section" };
const _hoisted_6$V = {
  key: 0,
  class: "model-info"
};
const _hoisted_7$V = { class: "form-group" };
const _hoisted_8$T = { class: "source-options" };
const _hoisted_9$T = ["disabled"];
const _hoisted_10$S = {
  key: 0,
  class: "layer-select"
};
const _hoisted_11$R = ["disabled"];
const _hoisted_12$P = ["value"];
const _hoisted_13$P = {
  key: 0,
  class: "upload-placeholder"
};
const _hoisted_14$L = ["src"];
const _hoisted_15$K = { class: "form-group" };
const _hoisted_16$J = { class: "slider-row" };
const _hoisted_17$I = ["disabled"];
const _hoisted_18$G = { class: "slider-value" };
const _hoisted_19$F = { class: "form-group options-group" };
const _hoisted_20$F = { class: "checkbox-row" };
const _hoisted_21$D = { class: "checkbox-label" };
const _hoisted_22$B = ["disabled"];
const _hoisted_23$B = { class: "checkbox-row" };
const _hoisted_24$v = { class: "checkbox-label" };
const _hoisted_25$v = ["disabled"];
const _hoisted_26$t = { class: "checkbox-row" };
const _hoisted_27$s = { class: "checkbox-label" };
const _hoisted_28$r = ["disabled"];
const _hoisted_29$r = {
  key: 0,
  class: "form-group collapsed-params"
};
const _hoisted_30$q = { class: "param-row" };
const _hoisted_31$n = ["disabled"];
const _hoisted_32$n = { class: "param-row" };
const _hoisted_33$n = ["disabled"];
const _hoisted_34$l = { class: "param-row" };
const _hoisted_35$j = ["disabled"];
const _hoisted_36$h = {
  key: 1,
  class: "progress-section"
};
const _hoisted_37$h = { class: "progress-bar" };
const _hoisted_38$h = { class: "progress-text" };
const _hoisted_39$h = {
  key: 2,
  class: "error-section"
};
const _hoisted_40$g = { class: "dialog-footer" };
const _hoisted_41$e = ["disabled"];
const _hoisted_42$d = ["disabled"];
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "DecomposeDialog",
  emits: ["close", "decomposed"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const modelStatus = ref(null);
    const sourceType = ref("layer");
    const selectedLayerId = ref("");
    const uploadedImage = ref(null);
    const fileInput = ref(null);
    const numLayers = ref(4);
    const guidanceScale = ref(3);
    const numInferenceSteps = ref(50);
    const seed = ref(void 0);
    const showAdvanced = ref(false);
    const groupIntoComp = ref(true);
    const semanticLabels = ref(true);
    const autoUnload = ref(true);
    const isProcessing = ref(false);
    const progressMessage = ref("");
    const progressIndeterminate = ref(false);
    const errorMessage = ref("");
    const imageLayers = computed(() => {
      const layers = store.getActiveCompLayers();
      return layers.filter((l) => l.type === "image" || l.type === "solid");
    });
    const hasImageLayers = computed(() => imageLayers.value.length > 0);
    const statusClass = computed(() => {
      if (!modelStatus.value) return "checking";
      if (modelStatus.value.error) return "error";
      if (modelStatus.value.loading) return "loading";
      if (modelStatus.value.loaded) return "ready";
      if (modelStatus.value.downloaded) return "downloaded";
      return "not-downloaded";
    });
    const statusIcon = computed(() => {
      switch (statusClass.value) {
        case "ready":
          return "pi pi-check-circle";
        case "downloaded":
          return "pi pi-download";
        case "loading":
          return "pi pi-spin pi-spinner";
        case "checking":
          return "pi pi-spin pi-spinner";
        case "error":
          return "pi pi-exclamation-circle";
        default:
          return "pi pi-cloud-download";
      }
    });
    const statusText = computed(() => {
      if (!modelStatus.value) return "Checking model status...";
      if (modelStatus.value.error) return `Error: ${modelStatus.value.error}`;
      if (modelStatus.value.loading) return "Loading model...";
      if (modelStatus.value.loaded) return "Model ready";
      if (modelStatus.value.downloaded) return "Model downloaded (not loaded)";
      return "Model not downloaded";
    });
    const canDecompose = computed(() => {
      if (!modelStatus.value) return false;
      if (sourceType.value === "layer" && !selectedLayerId.value) return false;
      if (sourceType.value === "upload" && !uploadedImage.value) return false;
      return true;
    });
    const buttonText = computed(() => {
      if (!modelStatus.value) return "Checking...";
      if (isProcessing.value) {
        if (!modelStatus.value.downloaded) return "Downloading...";
        if (!modelStatus.value.loaded) return "Loading...";
        return "Decomposing...";
      }
      if (!modelStatus.value.downloaded) return "Download & Decompose";
      if (!modelStatus.value.loaded) return "Load & Decompose";
      return "Decompose Image";
    });
    function triggerUpload() {
      fileInput.value?.click();
    }
    function handleFileSelect(event) {
      const input = event.target;
      const file = input.files?.[0];
      if (file) {
        loadImageFile(file);
      }
    }
    function handleDrop(event) {
      const file = event.dataTransfer?.files[0];
      if (file && file.type.startsWith("image/")) {
        loadImageFile(file);
      }
    }
    function loadImageFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        uploadedImage.value = reader.result;
      };
      reader.readAsDataURL(file);
    }
    async function getSourceImage() {
      if (sourceType.value === "upload") {
        return uploadedImage.value;
      }
      const layer = imageLayers.value.find((l) => l.id === selectedLayerId.value);
      if (!layer) return null;
      if (layer.type === "image" && layer.data) {
        const source = layer.data.source || layer.data.url || layer.data.assetId;
        if (source) {
          if (source.startsWith("data:")) {
            return source;
          }
          return await loadImageAsDataUrl(source);
        }
      }
      if (layer.type === "solid" && layer.data) {
        const canvas = document.createElement("canvas");
        canvas.width = layer.data.width || store.width;
        canvas.height = layer.data.height || store.height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = layer.data.color || "#808080";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return canvas.toDataURL("image/png");
      }
      return null;
    }
    async function loadImageAsDataUrl(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          resolve(canvas.toDataURL("image/png"));
        };
        img.onerror = () => reject(new Error("Failed to load image"));
        img.src = url;
      });
    }
    async function createLayersFromDecomposition(decomposedLayers) {
      const comp = store.getActiveComp();
      if (!comp) return;
      if (groupIntoComp.value) {
        const nestedCompName = `Decomposed (${decomposedLayers.length} layers)`;
        const nestedComp = store.createComposition(nestedCompName, {
          width: comp.settings.width,
          height: comp.settings.height,
          frameCount: comp.settings.frameCount,
          fps: comp.settings.fps,
          backgroundColor: "#00000000"
          // Transparent
        });
        const originalCompId = comp.id;
        store.setActiveComposition(nestedComp.id);
        for (let i = decomposedLayers.length - 1; i >= 0; i--) {
          const decomposed = decomposedLayers[i];
          const layer = store.createLayer("image", decomposed.label);
          if (layer.data) {
            layer.data.source = decomposed.image;
          }
        }
        store.setActiveComposition(originalCompId);
        const nestedLayer = store.createLayer("nestedComp", nestedCompName);
        if (nestedLayer.data) {
          nestedLayer.data.compositionId = nestedComp.id;
        }
      } else {
        for (let i = decomposedLayers.length - 1; i >= 0; i--) {
          const decomposed = decomposedLayers[i];
          const layer = store.createLayer("image", decomposed.label);
          if (layer.data) {
            layer.data.source = decomposed.image;
          }
        }
      }
      store.pushHistory();
    }
    async function startDecomposition() {
      if (!canDecompose.value || isProcessing.value) return;
      isProcessing.value = true;
      errorMessage.value = "";
      progressIndeterminate.value = true;
      try {
        const service = getLayerDecompositionService();
        progressMessage.value = "Preparing source image...";
        const sourceImage = await getSourceImage();
        if (!sourceImage) {
          throw new Error("Failed to get source image");
        }
        const layers = await service.decomposeWithAutoSetup(
          sourceImage,
          {
            numLayers: numLayers.value,
            guidanceScale: guidanceScale.value,
            numInferenceSteps: numInferenceSteps.value,
            seed: seed.value,
            autoUnload: autoUnload.value,
            generateSemanticLabels: semanticLabels.value
          },
          (stage, message) => {
            progressMessage.value = message;
            progressIndeterminate.value = stage !== "decomposing";
            if (stage === "downloading" || stage === "loading" || stage === "cleanup") {
              checkModelStatus();
            }
          }
        );
        progressMessage.value = "Creating layers...";
        await createLayersFromDecomposition(layers);
        emit("decomposed", layers);
        emit("close");
      } catch (err) {
        errorMessage.value = err instanceof Error ? err.message : "Decomposition failed";
        console.error("[DecomposeDialog] Error:", err);
      } finally {
        isProcessing.value = false;
        progressIndeterminate.value = false;
      }
    }
    async function checkModelStatus() {
      try {
        const service = getLayerDecompositionService();
        modelStatus.value = await service.getStatus();
      } catch (err) {
        console.error("[DecomposeDialog] Failed to get model status:", err);
        modelStatus.value = {
          downloaded: false,
          loaded: false,
          loading: false,
          error: "Failed to connect to backend",
          model_path: "",
          model_size_gb: 28.8
        };
      }
    }
    watch(hasImageLayers, (has) => {
      if (has && !selectedLayerId.value) {
        selectedLayerId.value = imageLayers.value[0]?.id || "";
      }
    }, { immediate: true });
    onMounted(() => {
      checkModelStatus();
      if (!hasImageLayers.value) {
        sourceType.value = "upload";
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "decompose-dialog-overlay",
        onClick: _cache[14] || (_cache[14] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$Z, [
          createBaseVNode("div", _hoisted_2$Y, [
            _cache[16] || (_cache[16] = createBaseVNode("h3", null, "AI Layer Decomposition", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
              disabled: isProcessing.value
            }, [..._cache[15] || (_cache[15] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])], 8, _hoisted_3$W)
          ]),
          createBaseVNode("div", _hoisted_4$V, [
            createBaseVNode("div", _hoisted_5$V, [
              createBaseVNode("div", {
                class: normalizeClass(["status-indicator", statusClass.value])
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(statusIcon.value)
                }, null, 2),
                createBaseVNode("span", null, toDisplayString(statusText.value), 1)
              ], 2),
              modelStatus.value && !modelStatus.value.downloaded ? (openBlock(), createElementBlock("div", _hoisted_6$V, [
                createBaseVNode("small", null, "Model size: " + toDisplayString(modelStatus.value.model_size_gb) + "GB", 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_7$V, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Source Image", -1)),
              createBaseVNode("div", _hoisted_8$T, [
                createBaseVNode("button", {
                  class: normalizeClass(["source-btn", { active: sourceType.value === "layer" }]),
                  onClick: _cache[1] || (_cache[1] = ($event) => sourceType.value = "layer"),
                  disabled: !hasImageLayers.value
                }, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-images" }, null, -1),
                  createBaseVNode("span", null, "From Layer", -1)
                ])], 10, _hoisted_9$T),
                createBaseVNode("button", {
                  class: normalizeClass(["source-btn", { active: sourceType.value === "upload" }]),
                  onClick: _cache[2] || (_cache[2] = ($event) => sourceType.value = "upload")
                }, [..._cache[18] || (_cache[18] = [
                  createBaseVNode("i", { class: "pi pi-upload" }, null, -1),
                  createBaseVNode("span", null, "Upload", -1)
                ])], 2)
              ]),
              sourceType.value === "layer" ? (openBlock(), createElementBlock("div", _hoisted_10$S, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedLayerId.value = $event),
                  disabled: isProcessing.value
                }, [
                  _cache[19] || (_cache[19] = createBaseVNode("option", { value: "" }, "Select a layer...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_12$P);
                  }), 128))
                ], 8, _hoisted_11$R), [
                  [vModelSelect, selectedLayerId.value]
                ])
              ])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "upload-area",
                onClick: triggerUpload,
                onDrop: withModifiers(handleDrop, ["prevent"]),
                onDragover: _cache[4] || (_cache[4] = withModifiers(() => {
                }, ["prevent"]))
              }, [
                createBaseVNode("input", {
                  ref_key: "fileInput",
                  ref: fileInput,
                  type: "file",
                  accept: "image/*",
                  onChange: handleFileSelect,
                  style: { "display": "none" }
                }, null, 544),
                !uploadedImage.value ? (openBlock(), createElementBlock("div", _hoisted_13$P, [..._cache[20] || (_cache[20] = [
                  createBaseVNode("i", { class: "pi pi-cloud-upload" }, null, -1),
                  createBaseVNode("span", null, "Click or drop image here", -1)
                ])])) : (openBlock(), createElementBlock("img", {
                  key: 1,
                  src: uploadedImage.value,
                  class: "upload-preview",
                  alt: "Uploaded image"
                }, null, 8, _hoisted_14$L))
              ], 32))
            ]),
            createBaseVNode("div", _hoisted_15$K, [
              _cache[22] || (_cache[22] = createBaseVNode("label", null, "Number of Layers", -1)),
              createBaseVNode("div", _hoisted_16$J, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => numLayers.value = $event),
                  type: "range",
                  min: "3",
                  max: "16",
                  step: "1",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_17$I), [
                  [
                    vModelText,
                    numLayers.value,
                    void 0,
                    { number: true }
                  ]
                ]),
                createBaseVNode("span", _hoisted_18$G, toDisplayString(numLayers.value), 1)
              ]),
              _cache[23] || (_cache[23] = createBaseVNode("small", { class: "param-hint" }, "More layers = finer separation (3-16)", -1))
            ]),
            createBaseVNode("div", _hoisted_19$F, [
              _cache[30] || (_cache[30] = createBaseVNode("label", null, "Organization", -1)),
              createBaseVNode("div", _hoisted_20$F, [
                createBaseVNode("label", _hoisted_21$D, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => groupIntoComp.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_22$B), [
                    [vModelCheckbox, groupIntoComp.value]
                  ]),
                  _cache[24] || (_cache[24] = createBaseVNode("span", null, "Group into nested composition", -1))
                ]),
                _cache[25] || (_cache[25] = createBaseVNode("small", null, "Keeps layers organized, reduces clutter", -1))
              ]),
              createBaseVNode("div", _hoisted_23$B, [
                createBaseVNode("label", _hoisted_24$v, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => semanticLabels.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_25$v), [
                    [vModelCheckbox, semanticLabels.value]
                  ]),
                  _cache[26] || (_cache[26] = createBaseVNode("span", null, "Generate semantic labels", -1))
                ]),
                _cache[27] || (_cache[27] = createBaseVNode("small", null, "AI-friendly names based on content analysis", -1))
              ]),
              createBaseVNode("div", _hoisted_26$t, [
                createBaseVNode("label", _hoisted_27$s, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => autoUnload.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_28$r), [
                    [vModelCheckbox, autoUnload.value]
                  ]),
                  _cache[28] || (_cache[28] = createBaseVNode("span", null, "Free GPU memory after", -1))
                ]),
                _cache[29] || (_cache[29] = createBaseVNode("small", null, "Recommended for complex projects", -1))
              ])
            ]),
            showAdvanced.value ? (openBlock(), createElementBlock("div", _hoisted_29$r, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Advanced Settings", -1)),
              createBaseVNode("div", _hoisted_30$q, [
                _cache[31] || (_cache[31] = createBaseVNode("span", null, "Guidance Scale", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => guidanceScale.value = $event),
                  type: "number",
                  min: "1",
                  max: "10",
                  step: "0.5",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_31$n), [
                  [
                    vModelText,
                    guidanceScale.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_32$n, [
                _cache[32] || (_cache[32] = createBaseVNode("span", null, "Inference Steps", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => numInferenceSteps.value = $event),
                  type: "number",
                  min: "20",
                  max: "100",
                  step: "10",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_33$n), [
                  [
                    vModelText,
                    numInferenceSteps.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_34$l, [
                _cache[33] || (_cache[33] = createBaseVNode("span", null, "Seed (optional)", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => seed.value = $event),
                  type: "number",
                  min: "0",
                  placeholder: "Random",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_35$j), [
                  [
                    vModelText,
                    seed.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: "advanced-toggle",
              onClick: _cache[12] || (_cache[12] = ($event) => showAdvanced.value = !showAdvanced.value)
            }, [
              createBaseVNode("i", {
                class: normalizeClass(showAdvanced.value ? "pi pi-chevron-up" : "pi pi-chevron-down")
              }, null, 2),
              createTextVNode(" " + toDisplayString(showAdvanced.value ? "Hide" : "Show") + " Advanced Settings ", 1)
            ]),
            isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_36$h, [
              createBaseVNode("div", _hoisted_37$h, [
                createBaseVNode("div", {
                  class: normalizeClass(["progress-fill", { indeterminate: progressIndeterminate.value }])
                }, null, 2)
              ]),
              createBaseVNode("p", _hoisted_38$h, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true),
            errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_39$h, [
              _cache[35] || (_cache[35] = createBaseVNode("i", { class: "pi pi-exclamation-triangle" }, null, -1)),
              createBaseVNode("span", null, toDisplayString(errorMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_40$g, [
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[13] || (_cache[13] = ($event) => emit("close")),
              disabled: isProcessing.value
            }, " Cancel ", 8, _hoisted_41$e),
            createBaseVNode("button", {
              class: "decompose-btn",
              onClick: startDecomposition,
              disabled: !canDecompose.value || isProcessing.value
            }, [
              _cache[36] || (_cache[36] = createBaseVNode("i", { class: "pi pi-sparkles" }, null, -1)),
              createTextVNode(" " + toDisplayString(buttonText.value), 1)
            ], 8, _hoisted_42$d)
          ])
        ])
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const DecomposeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-7dd86d9c"]]);

/*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply2(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return func.apply(thisArg, args);
  };
}
if (!construct) {
  construct = function construct2(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(Func) {
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return construct(Func, args);
  };
}
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9};
const getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
const _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.3.1";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window2;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
    tagCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    }
  }));
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (typeof cfg.ADD_TAGS === "function") {
        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
      } else {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
    }
    if (cfg.ADD_ATTR) {
      if (typeof cfg.ADD_ATTR === "function") {
        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
      } else {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (cfg.ADD_FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    if (name === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {
        }
      } else {
        try {
          element.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node === "function" && value instanceof Node;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l = attributes.length;
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      const initValue = attrValue;
      let value = name === "value" ? initValue : stringTrim(initValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (lcName === "attributename" && stringMatch(value, "href")) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      if (!hookEvent.keepAttr) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_) {
          _removeAttribute(name, currentNode);
        }
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

const logger$4 = createLogger("Vectorize");
const STARVECTOR_ALLOCATION_ID = "model:starvector-1b";
const DEFAULT_VTRACE_OPTIONS = {
  mode: "spline",
  colorMode: "color",
  hierarchical: "stacked",
  filterSpeckle: 4,
  colorPrecision: 6,
  layerDifference: 16,
  cornerThreshold: 60,
  lengthThreshold: 4,
  maxIterations: 10,
  spliceThreshold: 45,
  pathPrecision: 3
};
const DEFAULT_STARVECTOR_OPTIONS = {
  maxLength: 4e3
};
class VectorizeService {
  baseUrl;
  constructor(serverAddress) {
    const client = getComfyUIClient(serverAddress);
    this.baseUrl = `http://${client.server}`;
  }
  /**
   * Get vectorization service status
   */
  async getStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/status`);
      const result = await response.json();
      if (result.status === "success") {
        return result.data;
      }
      throw new Error(result.message || "Failed to get status");
    } catch (error) {
      logger$4.error("Failed to get vectorize status:", error);
      throw error;
    }
  }
  /**
   * Trace an image to vector paths using VTracer (fast, any image type)
   *
   * @param imageDataUrl - Image as data URL (data:image/...;base64,...)
   * @param options - Tracing options
   * @returns Array of vector paths with control points
   */
  async trace(imageDataUrl, options = {}) {
    const opts = { ...DEFAULT_VTRACE_OPTIONS, ...options };
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/trace`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          mode: opts.mode,
          color_mode: opts.colorMode,
          hierarchical: opts.hierarchical,
          filter_speckle: opts.filterSpeckle,
          color_precision: opts.colorPrecision,
          layer_difference: opts.layerDifference,
          corner_threshold: opts.cornerThreshold,
          length_threshold: opts.lengthThreshold,
          max_iterations: opts.maxIterations,
          splice_threshold: opts.spliceThreshold,
          path_precision: opts.pathPrecision
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$4.info(`Traced image: ${result.pathCount} paths`);
      return result;
    } catch (error) {
      logger$4.error("Image tracing failed:", error);
      throw error;
    }
  }
  /**
   * Vectorize an icon/logo using StarVector AI
   * Note: Only works for simple graphics, not photos
   *
   * @param imageDataUrl - Image as data URL
   * @param options - StarVector options
   */
  async vectorizeWithAI(imageDataUrl, options = {}) {
    const opts = { ...DEFAULT_STARVECTOR_OPTIONS, ...options };
    const memCheck = canAllocate(VRAM_ESTIMATES["model:starvector"] || 2500);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory for StarVector");
    }
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/ai`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          max_length: opts.maxLength
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$4.info(`AI vectorized: ${result.pathCount} paths`);
      return result;
    } catch (error) {
      logger$4.error("AI vectorization failed:", error);
      throw error;
    }
  }
  /**
   * Download and load StarVector model
   */
  async loadStarVectorModel(onProgress) {
    const memCheck = canAllocate(VRAM_ESTIMATES["model:starvector"] || 2500);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory");
    }
    try {
      onProgress?.("downloading", "Downloading StarVector model (~2.5GB)...");
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/download-starvector`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      registerAllocation(
        STARVECTOR_ALLOCATION_ID,
        "StarVector 1B Model",
        "model",
        VRAM_ESTIMATES["model:starvector"] || 2500,
        {
          canUnload: true,
          unloadFn: () => this.unloadStarVectorModel()
        }
      );
      onProgress?.("complete", "StarVector model loaded");
      logger$4.info("StarVector model loaded");
    } catch (error) {
      logger$4.error("Failed to load StarVector:", error);
      throw error;
    }
  }
  /**
   * Unload StarVector model to free GPU memory
   */
  async unloadStarVectorModel() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/unload-starvector`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      unregisterAllocation(STARVECTOR_ALLOCATION_ID);
      logger$4.info("StarVector model unloaded");
    } catch (error) {
      logger$4.error("Failed to unload StarVector:", error);
      throw error;
    }
  }
  /**
   * One-click vectorization with automatic mode selection
   *
   * For icons/logos (simple graphics): Uses StarVector AI
   * For photos/complex images: Uses VTracer
   *
   * @param imageDataUrl - Image to vectorize
   * @param options - Options (mode can be 'auto', 'trace', or 'ai')
   * @param onProgress - Progress callback
   */
  async vectorize(imageDataUrl, options = {}, onProgress) {
    const mode = options.mode ?? "trace";
    if (mode === "ai") {
      onProgress?.("checking", "Checking StarVector model...");
      const status = await this.getStatus();
      if (!status.starvector.loaded) {
        if (!status.starvector.downloaded) {
          onProgress?.("downloading", "Downloading StarVector model...");
        }
        await this.loadStarVectorModel(onProgress);
      }
      onProgress?.("vectorizing", "Running AI vectorization...");
      return await this.vectorizeWithAI(imageDataUrl, options.aiOptions);
    }
    onProgress?.("tracing", "Tracing image to vectors...");
    return await this.trace(imageDataUrl, options.traceOptions);
  }
}
let defaultService = null;
function getVectorizeService(serverAddress) {
  if (!defaultService) {
    defaultService = new VectorizeService(serverAddress);
  }
  return defaultService;
}
function normalizeControlPoints(paths, options = {}) {
  const { groupByPath = false, prefix = "vec" } = options;
  return paths.map((path, pathIdx) => {
    const groupId = groupByPath ? `${prefix}_path_${pathIdx}` : void 0;
    return {
      ...path,
      controlPoints: path.controlPoints.map((cp, cpIdx) => ({
        ...cp,
        id: cp.id || `${prefix}_${pathIdx}_${cpIdx}`,
        group: groupId,
        // Ensure handles are in correct format (absolute positions)
        handleIn: cp.handleIn ? { x: cp.handleIn.x, y: cp.handleIn.y } : null,
        handleOut: cp.handleOut ? { x: cp.handleOut.x, y: cp.handleOut.y } : null
      }))
    };
  });
}
function filterSmallPaths(paths, minPoints = 3) {
  return paths.filter((path) => path.controlPoints.length >= minPoints);
}
function autoGroupPoints(controlPoints, options = {}) {
  const { method = "quadrant", gridSize = 100, numGroups = 4 } = options;
  if (controlPoints.length === 0) return [];
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const cp of controlPoints) {
    minX = Math.min(minX, cp.x);
    minY = Math.min(minY, cp.y);
    maxX = Math.max(maxX, cp.x);
    maxY = Math.max(maxY, cp.y);
  }
  const width = maxX - minX || 1;
  const height = maxY - minY || 1;
  return controlPoints.map((cp) => {
    let group;
    switch (method) {
      case "grid": {
        const gridX = Math.floor((cp.x - minX) / gridSize);
        const gridY = Math.floor((cp.y - minY) / gridSize);
        group = `grid_${gridX}_${gridY}`;
        break;
      }
      case "quadrant": {
        const normX = (cp.x - minX) / width;
        const normY = (cp.y - minY) / height;
        if (normX < 0.5 && normY < 0.5) group = "top_left";
        else if (normX >= 0.5 && normY < 0.5) group = "top_right";
        else if (normX < 0.5 && normY >= 0.5) group = "bottom_left";
        else group = "bottom_right";
        break;
      }
      case "proximity":
      default: {
        const normX = (cp.x - minX) / width;
        const groupIdx = Math.floor(normX * numGroups) % numGroups;
        group = `region_${groupIdx}`;
        break;
      }
    }
    return { ...cp, group };
  });
}
if (typeof VRAM_ESTIMATES === "object") {
  VRAM_ESTIMATES["model:starvector"] = 2500;
}

const _hoisted_1$Y = { class: "vectorize-dialog" };
const _hoisted_2$X = { class: "section" };
const _hoisted_3$V = { class: "source-options" };
const _hoisted_4$U = { class: "option-group" };
const _hoisted_5$U = ["disabled"];
const _hoisted_6$U = ["disabled"];
const _hoisted_7$U = ["value"];
const _hoisted_8$S = { class: "option-group" };
const _hoisted_9$S = ["disabled"];
const _hoisted_10$R = ["disabled"];
const _hoisted_11$Q = {
  key: 0,
  class: "preview-container"
};
const _hoisted_12$O = ["src"];
const _hoisted_13$O = { class: "preview-size" };
const _hoisted_14$K = { class: "section" };
const _hoisted_15$J = { class: "mode-options" };
const _hoisted_16$I = ["disabled"];
const _hoisted_17$H = ["disabled"];
const _hoisted_18$F = { class: "mode-info" };
const _hoisted_19$E = {
  key: 0,
  class: "mode-warning"
};
const _hoisted_20$E = {
  key: 0,
  class: "section options-section"
};
const _hoisted_21$C = { class: "options-grid" };
const _hoisted_22$A = { class: "option-row" };
const _hoisted_23$A = ["disabled"];
const _hoisted_24$u = { class: "option-row" };
const _hoisted_25$u = ["disabled"];
const _hoisted_26$s = { class: "value" };
const _hoisted_27$r = { class: "option-row" };
const _hoisted_28$q = ["disabled"];
const _hoisted_29$q = { class: "value" };
const _hoisted_30$p = { class: "option-row" };
const _hoisted_31$m = ["disabled"];
const _hoisted_32$m = { class: "value" };
const _hoisted_33$m = { class: "option-row" };
const _hoisted_34$k = ["disabled"];
const _hoisted_35$i = { class: "value" };
const _hoisted_36$g = { class: "section" };
const _hoisted_37$g = { class: "output-options" };
const _hoisted_38$g = ["disabled"];
const _hoisted_39$g = ["disabled"];
const _hoisted_40$f = ["disabled"];
const _hoisted_41$d = ["disabled"];
const _hoisted_42$c = {
  key: 1,
  class: "progress-section"
};
const _hoisted_43$c = { class: "progress-bar" };
const _hoisted_44$c = { class: "progress-text" };
const _hoisted_45$c = {
  key: 2,
  class: "result-section"
};
const _hoisted_46$c = { class: "result-header" };
const _hoisted_47$c = { class: "result-count" };
const _hoisted_48$c = ["innerHTML"];
const _hoisted_49$c = {
  key: 3,
  class: "error-message"
};
const _hoisted_50$b = { class: "dialog-footer" };
const _hoisted_51$b = ["disabled"];
const _hoisted_52$a = ["disabled"];
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "VectorizeDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "created"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const vectorizeService = getVectorizeService();
    const sourceType = ref("layer");
    const selectedLayerId = ref("");
    const uploadedImage = ref(null);
    const fileInput = ref(null);
    const previewUrl = ref(null);
    const previewWidth = ref(0);
    const previewHeight = ref(0);
    const mode = ref("trace");
    const starVectorAvailable = ref(false);
    const traceOptions = ref({ ...DEFAULT_VTRACE_OPTIONS });
    const createSeparateLayers = ref(true);
    const groupByPath = ref(true);
    const autoGroupByRegion = ref(false);
    const enableAnimation = ref(true);
    const isProcessing = ref(false);
    const progressPercent = ref(0);
    const progressMessage = ref("");
    const result = ref(null);
    const showSvgPreview = ref(false);
    const errorMessage = ref("");
    const availableLayers = computed(() => {
      return store.layers.filter(
        (l) => l.type === "image" || l.type === "video" || l.type === "solid"
      );
    });
    const canVectorize = computed(() => {
      if (sourceType.value === "layer") {
        return !!selectedLayerId.value;
      }
      return !!uploadedImage.value;
    });
    const sanitizedSvg = computed(() => {
      if (!result.value?.svg) return "";
      return purify.sanitize(result.value.svg, {
        USE_PROFILES: { svg: true, svgFilters: true },
        ADD_TAGS: ["use"]
      });
    });
    watch([sourceType, selectedLayerId], async () => {
      if (sourceType.value === "layer" && selectedLayerId.value) {
        await loadLayerPreview();
      }
    });
    onMounted(async () => {
      try {
        const status = await vectorizeService.getStatus();
        starVectorAvailable.value = status.starvector.available || status.starvector.downloaded;
      } catch {
        starVectorAvailable.value = false;
      }
    });
    async function loadLayerPreview() {
      const layer = store.layers.find((l) => l.id === selectedLayerId.value);
      if (!layer) return;
      try {
        const layerData = layer.data;
        if (layerData?.source) {
          previewUrl.value = layerData.source;
        } else if (layerData?.assetId) {
          const asset = store.project?.assets[layerData.assetId];
          if (asset?.data) {
            previewUrl.value = asset.data;
          }
        }
        if (previewUrl.value) {
          const img = new Image();
          img.onload = () => {
            previewWidth.value = img.naturalWidth;
            previewHeight.value = img.naturalHeight;
          };
          img.src = previewUrl.value;
        }
      } catch (error) {
        console.error("Failed to load layer preview:", error);
      }
    }
    function onFileSelect(event) {
      const input = event.target;
      const file = input.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedImage.value = e.target?.result;
        previewUrl.value = uploadedImage.value;
        const img = new Image();
        img.onload = () => {
          previewWidth.value = img.naturalWidth;
          previewHeight.value = img.naturalHeight;
        };
        img.src = uploadedImage.value;
      };
      reader.readAsDataURL(file);
    }
    async function startVectorize() {
      errorMessage.value = "";
      result.value = null;
      isProcessing.value = true;
      progressPercent.value = 0;
      try {
        let imageDataUrl;
        if (sourceType.value === "layer") {
          const layer = store.layers.find((l) => l.id === selectedLayerId.value);
          if (!layer) throw new Error("Layer not found");
          const layerData = layer.data;
          if (layerData?.source) {
            imageDataUrl = layerData.source;
          } else if (layerData?.assetId) {
            const asset = store.project?.assets[layerData.assetId];
            if (!asset?.data) throw new Error("Asset data not found");
            imageDataUrl = asset.data;
          } else {
            throw new Error("Could not get image data from layer");
          }
        } else {
          if (!uploadedImage.value) throw new Error("No image uploaded");
          imageDataUrl = uploadedImage.value;
        }
        progressMessage.value = "Vectorizing image...";
        progressPercent.value = 30;
        result.value = await vectorizeService.vectorize(
          imageDataUrl,
          {
            mode: mode.value,
            traceOptions: traceOptions.value
          },
          (stage, message) => {
            progressMessage.value = message;
            if (stage === "downloading") progressPercent.value = 20;
            else if (stage === "tracing" || stage === "vectorizing") progressPercent.value = 60;
            else if (stage === "complete") progressPercent.value = 100;
          }
        );
        progressPercent.value = 100;
        progressMessage.value = `Found ${result.value.pathCount} paths`;
      } catch (error) {
        errorMessage.value = error instanceof Error ? error.message : "Vectorization failed";
      } finally {
        isProcessing.value = false;
      }
    }
    function createLayers() {
      if (!result.value) return;
      const createdLayerIds = [];
      let paths = filterSmallPaths(result.value.paths, 2);
      paths = normalizeControlPoints(paths, {
        groupByPath: groupByPath.value,
        prefix: "vec"
      });
      if (createSeparateLayers.value) {
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          let controlPoints = path.controlPoints;
          if (autoGroupByRegion.value) {
            controlPoints = autoGroupPoints(controlPoints, { method: "quadrant" });
          }
          const layer = store.createSplineLayer();
          store.renameLayer(layer.id, `Vector Path ${i + 1}`);
          store.updateLayerData(layer.id, {
            controlPoints,
            closed: path.closed,
            stroke: path.stroke || "#00ff00",
            strokeWidth: 2,
            fill: path.fill || "",
            animated: enableAnimation.value
          });
          createdLayerIds.push(layer.id);
        }
      } else {
        const allPoints = [];
        let pointIdx = 0;
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
          const path = paths[pathIdx];
          for (const cp of path.controlPoints) {
            allPoints.push({
              ...cp,
              id: `vec_${pointIdx++}`,
              group: `path_${pathIdx}`
            });
          }
        }
        let controlPoints = allPoints;
        if (autoGroupByRegion.value) {
          controlPoints = autoGroupPoints(allPoints, { method: "quadrant" });
        }
        const layer = store.createSplineLayer();
        store.renameLayer(layer.id, "Vectorized Paths");
        store.updateLayerData(layer.id, {
          controlPoints,
          closed: false,
          stroke: "#00ff00",
          strokeWidth: 2,
          fill: "",
          animated: enableAnimation.value
        });
        createdLayerIds.push(layer.id);
      }
      emit("created", createdLayerIds);
      emit("close");
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script), {
        visible: __props.visible,
        modal: "",
        header: "Vectorize Image",
        style: { width: "700px" },
        closable: !isProcessing.value,
        "onUpdate:visible": _cache[16] || (_cache[16] = ($event) => _ctx.$emit("close"))
      }, {
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_50$b, [
            createBaseVNode("button", {
              class: "btn-secondary",
              onClick: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("close")),
              disabled: isProcessing.value
            }, " Cancel ", 8, _hoisted_51$b),
            createBaseVNode("button", {
              class: "btn-primary",
              onClick: startVectorize,
              disabled: !canVectorize.value || isProcessing.value
            }, toDisplayString(isProcessing.value ? "Processing..." : "Vectorize"), 9, _hoisted_52$a),
            result.value && !isProcessing.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "btn-success",
              onClick: createLayers
            }, " Create Layers (" + toDisplayString(result.value.pathCount) + ") ", 1)) : createCommentVNode("", true)
          ])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$Y, [
            createBaseVNode("div", _hoisted_2$X, [
              _cache[20] || (_cache[20] = createBaseVNode("h4", null, "Source", -1)),
              createBaseVNode("div", _hoisted_3$V, [
                createBaseVNode("div", _hoisted_4$U, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "radio",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => sourceType.value = $event),
                      value: "layer",
                      disabled: isProcessing.value || !availableLayers.value.length
                    }, null, 8, _hoisted_5$U), [
                      [vModelRadio, sourceType.value]
                    ]),
                    _cache[17] || (_cache[17] = createTextVNode(" From Layer ", -1))
                  ]),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedLayerId.value = $event),
                    disabled: sourceType.value !== "layer" || isProcessing.value,
                    class: "layer-select"
                  }, [
                    _cache[18] || (_cache[18] = createBaseVNode("option", { value: "" }, "Select a layer...", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(availableLayers.value, (layer) => {
                      return openBlock(), createElementBlock("option", {
                        key: layer.id,
                        value: layer.id
                      }, toDisplayString(layer.name), 9, _hoisted_7$U);
                    }), 128))
                  ], 8, _hoisted_6$U), [
                    [vModelSelect, selectedLayerId.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_8$S, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "radio",
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => sourceType.value = $event),
                      value: "upload",
                      disabled: isProcessing.value
                    }, null, 8, _hoisted_9$S), [
                      [vModelRadio, sourceType.value]
                    ]),
                    _cache[19] || (_cache[19] = createTextVNode(" Upload Image ", -1))
                  ]),
                  createBaseVNode("input", {
                    ref_key: "fileInput",
                    ref: fileInput,
                    type: "file",
                    accept: "image/*",
                    onChange: onFileSelect,
                    disabled: sourceType.value !== "upload" || isProcessing.value,
                    class: "file-input"
                  }, null, 40, _hoisted_10$R)
                ])
              ]),
              previewUrl.value ? (openBlock(), createElementBlock("div", _hoisted_11$Q, [
                createBaseVNode("img", {
                  src: previewUrl.value,
                  alt: "Source preview",
                  class: "preview-image"
                }, null, 8, _hoisted_12$O),
                createBaseVNode("span", _hoisted_13$O, toDisplayString(previewWidth.value) + " x " + toDisplayString(previewHeight.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_14$K, [
              _cache[24] || (_cache[24] = createBaseVNode("h4", null, "Vectorization Mode", -1)),
              createBaseVNode("div", _hoisted_15$J, [
                createBaseVNode("label", {
                  class: normalizeClass(["mode-option", { selected: mode.value === "trace" }])
                }, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => mode.value = $event),
                    value: "trace",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_16$I), [
                    [vModelRadio, mode.value]
                  ]),
                  _cache[21] || (_cache[21] = createBaseVNode("div", { class: "mode-info" }, [
                    createBaseVNode("span", { class: "mode-title" }, "VTracer (Fast)"),
                    createBaseVNode("span", { class: "mode-desc" }, "Works with any image. Fast tracing to bezier curves.")
                  ], -1))
                ], 2),
                createBaseVNode("label", {
                  class: normalizeClass(["mode-option", { selected: mode.value === "ai" }])
                }, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => mode.value = $event),
                    value: "ai",
                    disabled: isProcessing.value || !starVectorAvailable.value
                  }, null, 8, _hoisted_17$H), [
                    [vModelRadio, mode.value]
                  ]),
                  createBaseVNode("div", _hoisted_18$F, [
                    _cache[22] || (_cache[22] = createBaseVNode("span", { class: "mode-title" }, "StarVector AI", -1)),
                    _cache[23] || (_cache[23] = createBaseVNode("span", { class: "mode-desc" }, "Best for icons/logos. Requires ~2.5GB VRAM.", -1)),
                    !starVectorAvailable.value ? (openBlock(), createElementBlock("span", _hoisted_19$E, "Model not available")) : createCommentVNode("", true)
                  ])
                ], 2)
              ])
            ]),
            mode.value === "trace" ? (openBlock(), createElementBlock("div", _hoisted_20$E, [
              _cache[31] || (_cache[31] = createBaseVNode("h4", null, "Tracing Options", -1)),
              createBaseVNode("div", _hoisted_21$C, [
                createBaseVNode("div", _hoisted_22$A, [
                  _cache[26] || (_cache[26] = createBaseVNode("label", null, "Color Mode", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => traceOptions.value.colorMode = $event),
                    disabled: isProcessing.value
                  }, [..._cache[25] || (_cache[25] = [
                    createBaseVNode("option", { value: "color" }, "Color", -1),
                    createBaseVNode("option", { value: "binary" }, "Black & White", -1)
                  ])], 8, _hoisted_23$A), [
                    [vModelSelect, traceOptions.value.colorMode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$u, [
                  _cache[27] || (_cache[27] = createBaseVNode("label", null, "Filter Speckle", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => traceOptions.value.filterSpeckle = $event),
                    min: "0",
                    max: "100",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_25$u), [
                    [
                      vModelText,
                      traceOptions.value.filterSpeckle,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_26$s, toDisplayString(traceOptions.value.filterSpeckle), 1)
                ]),
                createBaseVNode("div", _hoisted_27$r, [
                  _cache[28] || (_cache[28] = createBaseVNode("label", null, "Corner Threshold", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => traceOptions.value.cornerThreshold = $event),
                    min: "0",
                    max: "180",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_28$q), [
                    [
                      vModelText,
                      traceOptions.value.cornerThreshold,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_29$q, toDisplayString(traceOptions.value.cornerThreshold) + "", 1)
                ]),
                createBaseVNode("div", _hoisted_30$p, [
                  _cache[29] || (_cache[29] = createBaseVNode("label", null, "Color Precision", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => traceOptions.value.colorPrecision = $event),
                    min: "1",
                    max: "10",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_31$m), [
                    [
                      vModelText,
                      traceOptions.value.colorPrecision,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_32$m, toDisplayString(traceOptions.value.colorPrecision), 1)
                ]),
                createBaseVNode("div", _hoisted_33$m, [
                  _cache[30] || (_cache[30] = createBaseVNode("label", null, "Layer Difference", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => traceOptions.value.layerDifference = $event),
                    min: "1",
                    max: "256",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_34$k), [
                    [
                      vModelText,
                      traceOptions.value.layerDifference,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_35$i, toDisplayString(traceOptions.value.layerDifference), 1)
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_36$g, [
              _cache[36] || (_cache[36] = createBaseVNode("h4", null, "Output Options", -1)),
              createBaseVNode("div", _hoisted_37$g, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => createSeparateLayers.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_38$g), [
                    [vModelCheckbox, createSeparateLayers.value]
                  ]),
                  _cache[32] || (_cache[32] = createTextVNode(" Create separate layer for each path ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => groupByPath.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_39$g), [
                    [vModelCheckbox, groupByPath.value]
                  ]),
                  _cache[33] || (_cache[33] = createTextVNode(" Assign group IDs to control points (for group animation) ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => autoGroupByRegion.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_40$f), [
                    [vModelCheckbox, autoGroupByRegion.value]
                  ]),
                  _cache[34] || (_cache[34] = createTextVNode(" Auto-group points by region (quadrants) ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => enableAnimation.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_41$d), [
                    [vModelCheckbox, enableAnimation.value]
                  ]),
                  _cache[35] || (_cache[35] = createTextVNode(" Enable keyframe animation on created layers ", -1))
                ])
              ])
            ]),
            isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_42$c, [
              createBaseVNode("div", _hoisted_43$c, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: progressPercent.value + "%" })
                }, null, 4)
              ]),
              createBaseVNode("span", _hoisted_44$c, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true),
            result.value && !isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_45$c, [
              createBaseVNode("div", _hoisted_46$c, [
                createBaseVNode("span", _hoisted_47$c, toDisplayString(result.value.pathCount) + " paths found", 1),
                createBaseVNode("button", {
                  class: "preview-svg-btn",
                  onClick: _cache[14] || (_cache[14] = ($event) => showSvgPreview.value = !showSvgPreview.value)
                }, toDisplayString(showSvgPreview.value ? "Hide" : "Show") + " SVG Preview ", 1)
              ]),
              showSvgPreview.value && result.value.svg ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "svg-preview",
                innerHTML: sanitizedSvg.value
              }, null, 8, _hoisted_48$c)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_49$c, toDisplayString(errorMessage.value), 1)) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["visible", "closable"]);
    };
  }
});

const VectorizeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-055779a9"]]);

const DEFAULT_OPTIONS = {
  includeStrokes: true,
  includeFills: true,
  precision: 3,
  viewBox: { x: 0, y: 0, width: 1920, height: 1080 },
  includeTransforms: true,
  includeMetadata: true,
  minify: false
};
class SVGExportService {
  options;
  constructor(options) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }
  exportSplineLayer(layer, options) {
    const opts = { ...this.options, ...options };
    const warnings = [];
    if (layer.type !== "spline" || !layer.data) {
      warnings.push("Layer is not a spline layer");
      return { svg: "", width: 0, height: 0, pathCount: 0, warnings };
    }
    const splineData = layer.data;
    const pathData = this.controlPointsToPathData(
      splineData.controlPoints,
      splineData.closed ?? false,
      opts.precision
    );
    const strokeAttr = opts.includeStrokes ? 'stroke="' + (splineData.stroke || "#000") + '" stroke-width="' + (splineData.strokeWidth || 1) + '"' : 'stroke="none"';
    const fillAttr = opts.includeFills ? 'fill="' + (splineData.fill || "none") + '"' : 'fill="none"';
    let transformAttr = "";
    if (opts.includeTransforms && layer.transform) {
      transformAttr = this.buildTransformAttribute(layer);
    }
    const bounds = this.calculateBounds(splineData.controlPoints);
    const viewBox = opts.viewBox || {
      x: bounds.minX - 10,
      y: bounds.minY - 10,
      width: bounds.maxX - bounds.minX + 20,
      height: bounds.maxY - bounds.minY + 20
    };
    const nl = opts.minify ? "" : "\n";
    const ind = opts.minify ? "" : "  ";
    let svg = '<?xml version="1.0" encoding="UTF-8"?>' + nl;
    svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
    svg += 'viewBox="' + viewBox.x + " " + viewBox.y + " " + viewBox.width + " " + viewBox.height + '" ';
    svg += 'width="' + viewBox.width + '" height="' + viewBox.height + '">' + nl;
    if (opts.includeMetadata) {
      svg += ind + "<!-- Exported from Weyl Compositor -->" + nl;
    }
    const trAttr = transformAttr ? ' transform="' + transformAttr + '"' : "";
    svg += ind + '<path d="' + pathData + '" ' + strokeAttr + " " + fillAttr + trAttr + "/>" + nl;
    svg += "</svg>";
    return { svg, width: viewBox.width, height: viewBox.height, pathCount: 1, warnings };
  }
  exportComposition(composition, layers, options) {
    const opts = { ...this.options, ...options };
    const warnings = [];
    const width = composition.settings.width;
    const height = composition.settings.height;
    const viewBox = opts.viewBox || { x: 0, y: 0, width, height };
    const nl = opts.minify ? "" : "\n";
    const ind = opts.minify ? "" : "  ";
    let svg = '<?xml version="1.0" encoding="UTF-8"?>' + nl;
    svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
    svg += 'viewBox="' + viewBox.x + " " + viewBox.y + " " + viewBox.width + " " + viewBox.height + '" ';
    svg += 'width="' + width + '" height="' + height + '">' + nl;
    let pathCount = 0;
    for (const layer of layers) {
      if (layer.type !== "spline" || !layer.data) continue;
      const splineData = layer.data;
      const pathData = this.controlPointsToPathData(
        splineData.controlPoints,
        splineData.closed ?? false,
        opts.precision
      );
      const strokeAttr = opts.includeStrokes ? 'stroke="' + (splineData.stroke || "#000") + '" stroke-width="' + (splineData.strokeWidth || 1) + '"' : 'stroke="none"';
      const fillAttr = opts.includeFills ? 'fill="' + (splineData.fill || "none") + '"' : 'fill="none"';
      let transformAttr = "";
      if (opts.includeTransforms && layer.transform) {
        transformAttr = this.buildTransformAttribute(layer);
      }
      const trAttr = transformAttr ? ' transform="' + transformAttr + '"' : "";
      svg += ind + '<g id="' + this.sanitizeId(layer.id) + '">' + nl;
      svg += ind + ind + '<path d="' + pathData + '" ' + strokeAttr + " " + fillAttr + trAttr + "/>" + nl;
      svg += ind + "</g>" + nl;
      pathCount++;
    }
    svg += "</svg>";
    return { svg, width, height, pathCount, warnings };
  }
  controlPointsToPathData(points, closed, precision = 3) {
    if (points.length === 0) return "";
    const fmt = (n) => n.toFixed(precision).replace(/.?0+$/, "");
    let d = "M" + fmt(points[0].x) + "," + fmt(points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const curr = points[i];
      const next = points[i + 1];
      const cp1 = curr.handleOut || { x: curr.x, y: curr.y };
      const cp2 = next.handleIn || { x: next.x, y: next.y };
      const isLine = Math.abs(cp1.x - curr.x) < 0.01 && Math.abs(cp1.y - curr.y) < 0.01 && Math.abs(cp2.x - next.x) < 0.01 && Math.abs(cp2.y - next.y) < 0.01;
      if (isLine) {
        d += " L" + fmt(next.x) + "," + fmt(next.y);
      } else {
        d += " C" + fmt(cp1.x) + "," + fmt(cp1.y) + " " + fmt(cp2.x) + "," + fmt(cp2.y) + " " + fmt(next.x) + "," + fmt(next.y);
      }
    }
    if (closed && points.length > 1) {
      d += " Z";
    }
    return d;
  }
  buildTransformAttribute(layer) {
    const transforms = [];
    const t = layer.transform;
    if (!t) return "";
    const pos = t.position?.value;
    if (pos && (pos.x || pos.y)) {
      transforms.push("translate(" + (pos.x || 0) + "," + (pos.y || 0) + ")");
    }
    const rot = t.rotation?.value;
    if (rot) {
      transforms.push("rotate(" + rot + ")");
    }
    const scale = t.scale?.value;
    if (scale && (scale.x !== 100 || scale.y !== 100)) {
      transforms.push("scale(" + (scale.x || 100) / 100 + "," + (scale.y || 100) / 100 + ")");
    }
    return transforms.join(" ");
  }
  calculateBounds(points) {
    if (points.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of points) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    return { minX, minY, maxX, maxY };
  }
  sanitizeId(id) {
    return id.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
}
const svgExportService = new SVGExportService();
function exportSplineLayer(layer, options) {
  return svgExportService.exportSplineLayer(layer, options).svg;
}
function exportLayers(layers, options) {
  const composition = {
    settings: {
      width: options?.viewBox?.width ?? 1920,
      height: options?.viewBox?.height ?? 1080
    }
  };
  return svgExportService.exportComposition(composition, layers, options).svg;
}

const _hoisted_1$X = { class: "project-panel" };
const _hoisted_2$W = { class: "panel-header" };
const _hoisted_3$U = { class: "header-actions" };
const _hoisted_4$T = { class: "dropdown-container" };
const _hoisted_5$T = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_6$T = ["disabled"];
const _hoisted_7$T = ["disabled"];
const _hoisted_8$R = { class: "dropdown-container" };
const _hoisted_9$R = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_10$Q = {
  key: 1,
  class: "search-bar"
};
const _hoisted_11$P = { class: "panel-content" };
const _hoisted_12$N = { class: "folder-tree" };
const _hoisted_13$N = ["onClick", "onDblclick"];
const _hoisted_14$J = ["onClick"];
const _hoisted_15$I = { class: "folder-name" };
const _hoisted_16$H = { class: "item-count" };
const _hoisted_17$G = {
  key: 0,
  class: "folder-contents"
};
const _hoisted_18$E = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_19$D = { class: "item-icon" };
const _hoisted_20$D = { class: "item-name" };
const _hoisted_21$B = { class: "item-info" };
const _hoisted_22$z = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_23$z = { class: "item-icon" };
const _hoisted_24$t = { class: "item-name" };
const _hoisted_25$t = { class: "item-info" };
const _hoisted_26$r = {
  key: 0,
  class: "empty-state"
};
const _hoisted_27$q = {
  key: 2,
  class: "panel-footer"
};
const _hoisted_28$p = { class: "item-details" };
const _hoisted_29$p = { class: "detail-label" };
const _hoisted_30$o = { class: "detail-info" };
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectionStore = useSelectionStore$1();
    const fileInputRef = ref(null);
    const showSearch = ref(false);
    const showNewMenu = ref(false);
    const showExportMenu = ref(false);
    const showDecomposeDialog = ref(false);
    const showVectorizeDialog = ref(false);
    const searchQuery = ref("");
    const selectedItem = ref(null);
    const expandedFolders = ref(["compositions", "footage"]);
    const customFolders = ref([]);
    const hasSelectedSplineLayer = computed(() => {
      const selectedLayerIds = selectionStore.selectedLayerIds;
      if (selectedLayerIds.length === 0) return false;
      const layers = store.getActiveCompLayers();
      const selectedLayer = layers.find((l) => l.id === selectedLayerIds[0]);
      return selectedLayer?.type === "spline";
    });
    const folders = computed(() => {
      const compositions = Object.values(store.project.compositions || {}).map((comp) => ({
        id: comp.id,
        name: comp.name,
        type: "composition",
        width: comp.settings.width,
        height: comp.settings.height,
        fps: comp.settings.fps,
        duration: comp.settings.frameCount
      }));
      const systemFolders = [
        {
          id: "compositions",
          name: "Compositions",
          items: compositions.length > 0 ? compositions : [{
            id: "comp-main",
            name: store.activeComposition?.name || "Main Comp",
            type: "composition",
            width: store.width,
            height: store.height,
            fps: store.fps,
            duration: store.frameCount
          }]
        },
        {
          id: "footage",
          name: "Footage",
          items: []
        },
        {
          id: "solids",
          name: "Solids",
          items: []
        }
      ];
      return [...systemFolders, ...customFolders.value];
    });
    const items = ref([]);
    const filteredFolders = computed(() => {
      if (!searchQuery.value) return folders.value;
      const query = searchQuery.value.toLowerCase();
      return folders.value.map((folder) => ({
        ...folder,
        items: folder.items.filter(
          (item) => item.name.toLowerCase().includes(query)
        )
      })).filter((folder) => folder.items.length > 0 || folder.name.toLowerCase().includes(query));
    });
    const filteredRootItems = computed(() => {
      if (!searchQuery.value) return items.value;
      const query = searchQuery.value.toLowerCase();
      return items.value.filter(
        (item) => item.name.toLowerCase().includes(query)
      );
    });
    const selectedItemDetails = computed(() => {
      if (!selectedItem.value) return null;
      for (const folder of folders.value) {
        const item2 = folder.items.find((i) => i.id === selectedItem.value);
        if (item2) {
          return {
            name: item2.name,
            info: getItemInfo(item2)
          };
        }
      }
      const item = items.value.find((i) => i.id === selectedItem.value);
      if (item) {
        return {
          name: item.name,
          info: getItemInfo(item)
        };
      }
      return null;
    });
    function toggleFolder(folderId) {
      const index = expandedFolders.value.indexOf(folderId);
      if (index >= 0) {
        expandedFolders.value.splice(index, 1);
      } else {
        expandedFolders.value.push(folderId);
      }
    }
    function selectItem(itemId) {
      selectedItem.value = itemId;
    }
    function openItem(item) {
      if (item.type === "composition") {
        store.switchComposition(item.id);
      } else if (item.type === "folder") {
        toggleFolder(item.id);
      } else if (item.type === "footage" || item.type === "solid") {
        const asset = store.project.assets[item.id];
        if (asset) {
          const layerType = item.type === "solid" ? "solid" : "image";
          const layer = store.addLayer(layerType, item.name);
          if (layer && asset.data) {
            store.updateLayerData(layer.id, { assetId: item.id });
          }
        }
      } else if (item.type === "audio") {
        const asset = store.project.assets[item.id];
        if (asset && asset.data) {
          fetch(asset.data).then((response) => response.blob()).then((blob) => {
            const file = new File([blob], item.name, { type: blob.type || "audio/mpeg" });
            Promise.resolve().then(() => audioStore).then(({ useAudioStore }) => {
              const audioStore = useAudioStore();
              const fps = store.activeComposition?.settings.frameRate || 16;
              audioStore.loadAudio(file, fps);
            });
          }).catch((err) => console.error("[ProjectPanel] Failed to load audio:", err));
        }
      }
    }
    function createNewComposition() {
      showNewMenu.value = false;
      emit("openCompositionSettings");
    }
    function createNewFolder() {
      showNewMenu.value = false;
      const folderNumber = customFolders.value.length + 1;
      const newFolder = {
        id: `folder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `Folder ${folderNumber}`,
        items: []
      };
      customFolders.value.push(newFolder);
      expandedFolders.value.push(newFolder.id);
      selectedItem.value = newFolder.id;
      console.log("[ProjectPanel] Created folder:", newFolder.name);
    }
    function createNewSolid() {
      showNewMenu.value = false;
      const layer = store.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", layer.id);
    }
    function createNewText() {
      showNewMenu.value = false;
      const layer = store.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", layer.id);
    }
    function createNewControl() {
      showNewMenu.value = false;
      const layer = store.createLayer("control", "Control");
      console.log("[ProjectPanel] Created control layer:", layer.id);
    }
    function createNewSpline() {
      showNewMenu.value = false;
      const layer = store.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", layer.id);
    }
    function createNewModel() {
      showNewMenu.value = false;
      const layer = store.createLayer("model", "3D Model");
      console.log("[ProjectPanel] Created model layer:", layer.id);
    }
    function createNewPointCloud() {
      showNewMenu.value = false;
      const layer = store.createLayer("pointcloud", "Point Cloud");
      console.log("[ProjectPanel] Created point cloud layer:", layer.id);
    }
    function openDecomposeDialog() {
      showNewMenu.value = false;
      showDecomposeDialog.value = true;
    }
    function openVectorizeDialog() {
      showNewMenu.value = false;
      showVectorizeDialog.value = true;
    }
    function onDecomposed(layers) {
      console.log("[ProjectPanel] Image decomposed into", layers.length, "layers");
    }
    function onVectorized(layerIds) {
      console.log("[ProjectPanel] Created", layerIds.length, "vectorized layers");
    }
    function getSelectedSplineLayer() {
      const selectedLayerIds = selectionStore.selectedLayerIds;
      if (selectedLayerIds.length === 0) return null;
      const layers = store.getActiveCompLayers();
      const layer = layers.find((l) => l.id === selectedLayerIds[0]);
      return layer?.type === "spline" ? layer : null;
    }
    function exportSelectedLayerSVG() {
      showExportMenu.value = false;
      const layer = getSelectedSplineLayer();
      if (!layer) {
        console.warn("[ProjectPanel] No spline layer selected");
        return;
      }
      try {
        const svg = exportSplineLayer(layer);
        navigator.clipboard.writeText(svg).then(() => {
          console.log("[ProjectPanel] SVG copied to clipboard");
        }).catch((err) => {
          console.error("[ProjectPanel] Failed to copy SVG:", err);
        });
      } catch (error) {
        console.error("[ProjectPanel] Failed to export SVG:", error);
      }
    }
    function exportCompositionSVG() {
      showExportMenu.value = false;
      const comp = store.activeComposition;
      if (!comp) {
        console.warn("[ProjectPanel] No active composition");
        return;
      }
      try {
        const svg = exportLayers(comp.layers, {
          viewBox: { x: 0, y: 0, width: comp.settings.width, height: comp.settings.height }
        });
        navigator.clipboard.writeText(svg).then(() => {
          console.log("[ProjectPanel] Composition SVG copied to clipboard");
        }).catch((err) => {
          console.error("[ProjectPanel] Failed to copy SVG:", err);
        });
      } catch (error) {
        console.error("[ProjectPanel] Failed to export composition SVG:", error);
      }
    }
    function downloadSVG(svgContent, filename) {
      const blob = new Blob([svgContent], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function exportSelectedLayerSVGDownload() {
      showExportMenu.value = false;
      const layer = getSelectedSplineLayer();
      if (!layer) {
        console.warn("[ProjectPanel] No spline layer selected");
        return;
      }
      try {
        const svg = exportSplineLayer(layer);
        const filename = `${layer.name.replace(/[^a-z0-9]/gi, "_")}.svg`;
        downloadSVG(svg, filename);
        console.log("[ProjectPanel] SVG downloaded:", filename);
      } catch (error) {
        console.error("[ProjectPanel] Failed to export SVG:", error);
      }
    }
    function exportCompositionSVGDownload() {
      showExportMenu.value = false;
      const comp = store.activeComposition;
      if (!comp) {
        console.warn("[ProjectPanel] No active composition");
        return;
      }
      try {
        const svg = exportLayers(comp.layers, {
          viewBox: { x: 0, y: 0, width: comp.settings.width, height: comp.settings.height }
        });
        const filename = `${comp.name.replace(/[^a-z0-9]/gi, "_")}.svg`;
        downloadSVG(svg, filename);
        console.log("[ProjectPanel] Composition SVG downloaded:", filename);
      } catch (error) {
        console.error("[ProjectPanel] Failed to export composition SVG:", error);
      }
    }
    function triggerFileImport() {
      fileInputRef.value?.click();
    }
    async function handleFileImport(event) {
      const input = event.target;
      const files = input.files;
      if (!files || files.length === 0) return;
      for (const file of Array.from(files)) {
        const type = getFileType(file);
        const newItem = {
          id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: file.name,
          type
        };
        if (type === "audio") {
          store.loadAudio(file);
        } else if (file.type.startsWith("video/")) {
          try {
            const layer = await store.createVideoLayer(file, true);
            newItem.id = layer.id;
            newItem.width = store.width;
            newItem.height = store.height;
            newItem.duration = store.frameCount;
            newItem.fps = store.fps;
            console.log("[ProjectPanel] Video layer created:", layer.id, layer.name);
          } catch (error) {
            console.error("[ProjectPanel] Failed to import video:", error);
            continue;
          }
        } else if (file.type.startsWith("image/")) {
          const imageUrl = URL.createObjectURL(file);
          const assetId = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          store.project.assets[assetId] = {
            id: assetId,
            type: "image",
            source: "file",
            width: 0,
            // Will be updated when image loads
            height: 0,
            data: imageUrl
          };
          const layer = store.createLayer("image", file.name.replace(/\.[^.]+$/, ""));
          layer.data = { assetId };
          newItem.id = layer.id;
        }
        const folder = folders.value.find((f) => f.id === "footage");
        if (folder) {
          folder.items.push(newItem);
        } else {
          items.value.push(newItem);
        }
        console.log("[ProjectPanel] Imported:", file.name, type);
      }
      input.value = "";
    }
    function getFileType(file) {
      const mime = file.type;
      if (mime.startsWith("audio/")) return "audio";
      if (mime.startsWith("video/")) return "footage";
      if (mime.startsWith("image/")) return "footage";
      return "footage";
    }
    function getItemIcon(type) {
      const icons = {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      };
      return icons[type] || "";
    }
    function getItemInfo(item) {
      if (item.type === "composition" || item.type === "footage") {
        const parts = [];
        if (item.width && item.height) {
          parts.push(`${item.width}${item.height}`);
        }
        if (item.fps) {
          parts.push(`${item.fps}fps`);
        }
        if (item.duration) {
          const seconds = item.duration / (item.fps || 30);
          parts.push(`${seconds.toFixed(1)}s`);
        }
        return parts.join("  ");
      }
      return "";
    }
    function onDragStart(item, event) {
      event.dataTransfer?.setData("application/project-item", JSON.stringify(item));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$X, [
        createBaseVNode("div", _hoisted_2$W, [
          _cache[9] || (_cache[9] = createBaseVNode("span", { class: "panel-title" }, "Project", -1)),
          createBaseVNode("div", _hoisted_3$U, [
            createBaseVNode("button", {
              onClick: triggerFileImport,
              title: "Import File (Ctrl+I)"
            }, ""),
            createBaseVNode("div", _hoisted_4$T, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => showExportMenu.value = !showExportMenu.value),
                title: "Export"
              }, ""),
              showExportMenu.value ? (openBlock(), createElementBlock("div", _hoisted_5$T, [
                createBaseVNode("button", {
                  onClick: exportSelectedLayerSVG,
                  disabled: !hasSelectedSplineLayer.value
                }, "  Export Selected Layer as SVG ", 8, _hoisted_6$T),
                createBaseVNode("button", { onClick: exportCompositionSVG }, "  Export Composition as SVG "),
                _cache[6] || (_cache[6] = createBaseVNode("hr", { class: "menu-divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: exportSelectedLayerSVGDownload,
                  disabled: !hasSelectedSplineLayer.value
                }, "  Download Selected as SVG ", 8, _hoisted_7$T),
                createBaseVNode("button", { onClick: exportCompositionSVGDownload }, "  Download Composition as SVG ")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$R, [
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => showNewMenu.value = !showNewMenu.value),
                title: "New Item"
              }, "+"),
              showNewMenu.value ? (openBlock(), createElementBlock("div", _hoisted_9$R, [
                createBaseVNode("button", { onClick: createNewComposition }, " New Composition"),
                createBaseVNode("button", { onClick: createNewFolder }, " New Folder"),
                _cache[7] || (_cache[7] = createBaseVNode("hr", { class: "menu-divider" }, null, -1)),
                createBaseVNode("button", { onClick: createNewSolid }, " New Solid"),
                createBaseVNode("button", { onClick: createNewText }, "T New Text"),
                createBaseVNode("button", { onClick: createNewControl }, " New Control"),
                createBaseVNode("button", { onClick: createNewSpline }, " New Spline"),
                createBaseVNode("button", { onClick: createNewModel }, " New 3D Model"),
                createBaseVNode("button", { onClick: createNewPointCloud }, " New Point Cloud"),
                _cache[8] || (_cache[8] = createBaseVNode("hr", { class: "menu-divider" }, null, -1)),
                createBaseVNode("button", { onClick: openDecomposeDialog }, " AI Layer Decompose"),
                createBaseVNode("button", { onClick: openVectorizeDialog }, " Vectorize Image")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => showSearch.value = !showSearch.value),
              title: "Search"
            }, "")
          ])
        ]),
        showDecomposeDialog.value ? (openBlock(), createBlock(DecomposeDialog, {
          key: 0,
          onClose: _cache[3] || (_cache[3] = ($event) => showDecomposeDialog.value = false),
          onDecomposed
        })) : createCommentVNode("", true),
        createVNode(VectorizeDialog, {
          visible: showVectorizeDialog.value,
          onClose: _cache[4] || (_cache[4] = ($event) => showVectorizeDialog.value = false),
          onCreated: onVectorized
        }, null, 8, ["visible"]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          multiple: "",
          accept: "image/*,video/*,audio/*,.json",
          style: { "display": "none" },
          onChange: handleFileImport
        }, null, 544),
        showSearch.value ? (openBlock(), createElementBlock("div", _hoisted_10$Q, [
          withDirectives(createBaseVNode("input", {
            type: "text",
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => searchQuery.value = $event),
            placeholder: "Search project...",
            class: "search-input"
          }, null, 512), [
            [vModelText, searchQuery.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_11$P, [
          createBaseVNode("div", _hoisted_12$N, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredFolders.value, (folder) => {
              return openBlock(), createElementBlock("div", {
                key: folder.id,
                class: "folder-item"
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["folder-header", { selected: selectedItem.value === folder.id }]),
                  onClick: ($event) => selectItem(folder.id),
                  onDblclick: ($event) => toggleFolder(folder.id)
                }, [
                  createBaseVNode("span", {
                    class: "expand-icon",
                    onClick: withModifiers(($event) => toggleFolder(folder.id), ["stop"])
                  }, toDisplayString(expandedFolders.value.includes(folder.id) ? "" : ""), 9, _hoisted_14$J),
                  _cache[10] || (_cache[10] = createBaseVNode("span", { class: "folder-icon" }, "", -1)),
                  createBaseVNode("span", _hoisted_15$I, toDisplayString(folder.name), 1),
                  createBaseVNode("span", _hoisted_16$H, toDisplayString(folder.items.length), 1)
                ], 42, _hoisted_13$N),
                expandedFolders.value.includes(folder.id) ? (openBlock(), createElementBlock("div", _hoisted_17$G, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(folder.items, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.id,
                      class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                      onClick: ($event) => selectItem(item.id),
                      onDblclick: ($event) => openItem(item),
                      draggable: "true",
                      onDragstart: ($event) => onDragStart(item, $event)
                    }, [
                      createBaseVNode("span", _hoisted_19$D, toDisplayString(getItemIcon(item.type)), 1),
                      createBaseVNode("span", _hoisted_20$D, toDisplayString(item.name), 1),
                      createBaseVNode("span", _hoisted_21$B, toDisplayString(getItemInfo(item)), 1)
                    ], 42, _hoisted_18$E);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredRootItems.value, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.id,
                class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                onClick: ($event) => selectItem(item.id),
                onDblclick: ($event) => openItem(item),
                draggable: "true",
                onDragstart: ($event) => onDragStart(item, $event)
              }, [
                createBaseVNode("span", _hoisted_23$z, toDisplayString(getItemIcon(item.type)), 1),
                createBaseVNode("span", _hoisted_24$t, toDisplayString(item.name), 1),
                createBaseVNode("span", _hoisted_25$t, toDisplayString(getItemInfo(item)), 1)
              ], 42, _hoisted_22$z);
            }), 128))
          ]),
          items.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_26$r, [..._cache[11] || (_cache[11] = [
            createBaseVNode("p", null, "No items in project", -1),
            createBaseVNode("p", { class: "hint" }, "Import footage or create compositions", -1)
          ])])) : createCommentVNode("", true)
        ]),
        selectedItemDetails.value ? (openBlock(), createElementBlock("div", _hoisted_27$q, [
          createBaseVNode("div", _hoisted_28$p, [
            createBaseVNode("span", _hoisted_29$p, toDisplayString(selectedItemDetails.value.name), 1),
            createBaseVNode("span", _hoisted_30$o, toDisplayString(selectedItemDetails.value.info), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ProjectPanel = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__scopeId", "data-v-8d446059"]]);

const _hoisted_1$W = {
  class: "effects-panel",
  role: "region",
  "aria-label": "Effects and Presets"
};
const _hoisted_2$V = { class: "panel-header" };
const _hoisted_3$T = { class: "header-actions" };
const _hoisted_4$S = { class: "panel-content" };
const _hoisted_5$S = {
  class: "tabs",
  role: "tablist",
  "aria-label": "Effects panel tabs"
};
const _hoisted_6$S = ["aria-selected"];
const _hoisted_7$S = ["aria-selected"];
const _hoisted_8$Q = ["aria-selected"];
const _hoisted_9$Q = {
  key: 0,
  class: "effects-list",
  id: "effects-tab-panel",
  role: "tabpanel",
  "aria-label": "Effects list"
};
const _hoisted_10$P = ["onClick"];
const _hoisted_11$O = { class: "expand-icon" };
const _hoisted_12$M = { class: "category-icon" };
const _hoisted_13$M = { class: "category-name" };
const _hoisted_14$I = { class: "effect-count" };
const _hoisted_15$H = {
  key: 0,
  class: "category-effects"
};
const _hoisted_16$G = ["onDblclick", "onDragstart"];
const _hoisted_17$F = { class: "effect-name" };
const _hoisted_18$D = ["onClick", "title", "aria-label", "aria-pressed"];
const _hoisted_19$C = { "aria-hidden": "true" };
const _hoisted_20$C = {
  key: 1,
  class: "presets-list"
};
const _hoisted_21$A = ["onClick"];
const _hoisted_22$y = { class: "expand-icon" };
const _hoisted_23$y = { class: "category-name" };
const _hoisted_24$s = { class: "preset-count" };
const _hoisted_25$s = {
  key: 0,
  class: "category-presets"
};
const _hoisted_26$q = ["onDblclick", "onDragstart"];
const _hoisted_27$p = { class: "preset-info" };
const _hoisted_28$o = { class: "preset-name" };
const _hoisted_29$o = { class: "preset-description" };
const _hoisted_30$n = {
  key: 2,
  class: "favorites-list"
};
const _hoisted_31$l = {
  key: 0,
  class: "empty-favorites"
};
const _hoisted_32$l = ["onDblclick", "onDragstart"];
const _hoisted_33$l = { class: "category-badge" };
const _hoisted_34$j = { class: "effect-name" };
const _hoisted_35$h = ["onClick"];
const STORAGE_VERSION = 1;
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "EffectsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const activeTab = ref("effects");
    const searchQuery = ref("");
    const expandedCategories = ref(["blur-sharpen", "color-correction"]);
    const expandedPresetCategories = ref(["Fade", "Scale"]);
    const favorites = ref([]);
    const STORAGE_KEY = "effect-favorites-v" + STORAGE_VERSION;
    onMounted(() => {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed) && parsed.every((item) => typeof item === "string")) {
            favorites.value = parsed;
          } else {
            favorites.value = [];
          }
        } catch {
          favorites.value = [];
        }
      }
    });
    function saveFavorites() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(favorites.value));
    }
    const allEffects = computed(() => {
      return Object.entries(EFFECT_DEFINITIONS).map(([key, def]) => ({
        key,
        name: def.name,
        category: def.category,
        description: def.description
      }));
    });
    const filteredCategories = computed(() => {
      const query = searchQuery.value.toLowerCase();
      return Object.entries(EFFECT_CATEGORIES).map(([key, cat]) => {
        const effects = allEffects.value.filter((e) => {
          if (e.category !== key) return false;
          if (query && !e.name.toLowerCase().includes(query)) return false;
          return true;
        });
        return {
          key,
          label: cat.label,
          icon: cat.icon,
          effects
        };
      }).filter((cat) => cat.effects.length > 0);
    });
    const groupedPresets = computed(() => {
      const query = searchQuery.value.toLowerCase();
      const groups = {};
      for (const preset of ANIMATION_PRESETS) {
        if (query && !preset.name.toLowerCase().includes(query)) continue;
        if (!groups[preset.category]) {
          groups[preset.category] = [];
        }
        groups[preset.category].push(preset);
      }
      return Object.entries(groups).map(([category, presets]) => ({
        category,
        presets
      }));
    });
    const favoriteEffects = computed(() => {
      return allEffects.value.filter((e) => favorites.value.includes(e.key));
    });
    function toggleCategory(category) {
      const index = expandedCategories.value.indexOf(category);
      if (index >= 0) {
        expandedCategories.value.splice(index, 1);
      } else {
        expandedCategories.value.push(category);
      }
    }
    function togglePresetCategory(category) {
      const index = expandedPresetCategories.value.indexOf(category);
      if (index >= 0) {
        expandedPresetCategories.value.splice(index, 1);
      } else {
        expandedPresetCategories.value.push(category);
      }
    }
    function toggleFavorite(effectKey) {
      const index = favorites.value.indexOf(effectKey);
      if (index >= 0) {
        favorites.value.splice(index, 1);
      } else {
        favorites.value.push(effectKey);
      }
      saveFavorites();
    }
    function getCategoryIcon(category) {
      return EFFECT_CATEGORIES[category]?.icon || "?";
    }
    function applyEffect(effectKey) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) {
        console.warn("No layer selected to apply effect");
        return;
      }
      store.addEffectToLayer(selectedLayer.id, effectKey);
    }
    function applyPreset(preset) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const startFrame = selectedLayer.inPoint;
      const endFrame = selectedLayer.outPoint;
      const duration = endFrame - startFrame;
      for (const propDef of preset.keyframes) {
        for (const kf of propDef.keyframes) {
          const frame = Math.round(startFrame + kf.time * duration);
          store.addKeyframe(selectedLayer.id, propDef.property, kf.value, frame);
        }
      }
    }
    function onDragStart(effectKey, event) {
      event.dataTransfer?.setData("application/effect", effectKey);
    }
    function onDragPreset(preset, event) {
      event.dataTransfer?.setData("application/preset", JSON.stringify(preset));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$W, [
        createBaseVNode("div", _hoisted_2$V, [
          _cache[4] || (_cache[4] = createBaseVNode("span", {
            class: "panel-title",
            id: "effects-panel-title"
          }, "Effects & Presets", -1)),
          createBaseVNode("div", _hoisted_3$T, [
            withDirectives(createBaseVNode("input", {
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              placeholder: "Search...",
              class: "search-input",
              "aria-label": "Search effects and presets"
            }, null, 512), [
              [vModelText, searchQuery.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$S, [
          createBaseVNode("div", _hoisted_5$S, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "effects" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "effects"),
              role: "tab",
              "aria-selected": activeTab.value === "effects",
              "aria-controls": "effects-tab-panel"
            }, " Effects ", 10, _hoisted_6$S),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "presets" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "presets"),
              role: "tab",
              "aria-selected": activeTab.value === "presets",
              "aria-controls": "presets-tab-panel"
            }, " Presets ", 10, _hoisted_7$S),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "favorites" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "favorites"),
              role: "tab",
              "aria-selected": activeTab.value === "favorites",
              "aria-controls": "favorites-tab-panel"
            }, " Favorites ", 10, _hoisted_8$Q)
          ]),
          activeTab.value === "effects" ? (openBlock(), createElementBlock("div", _hoisted_9$Q, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
              return openBlock(), createElementBlock("div", {
                key: category.key,
                class: "effect-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => toggleCategory(category.key)
                }, [
                  createBaseVNode("span", _hoisted_11$O, toDisplayString(expandedCategories.value.includes(category.key) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_12$M, toDisplayString(category.icon), 1),
                  createBaseVNode("span", _hoisted_13$M, toDisplayString(category.label), 1),
                  createBaseVNode("span", _hoisted_14$I, toDisplayString(category.effects.length), 1)
                ], 8, _hoisted_10$P),
                expandedCategories.value.includes(category.key) ? (openBlock(), createElementBlock("div", _hoisted_15$H, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.effects, (effect) => {
                    return openBlock(), createElementBlock("div", {
                      key: effect.key,
                      class: normalizeClass(["effect-item", { favorite: favorites.value.includes(effect.key) }]),
                      onDblclick: ($event) => applyEffect(effect.key),
                      onDragstart: ($event) => onDragStart(effect.key, $event),
                      draggable: "true"
                    }, [
                      createBaseVNode("span", _hoisted_17$F, toDisplayString(effect.name), 1),
                      createBaseVNode("button", {
                        class: "favorite-btn",
                        onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"]),
                        title: favorites.value.includes(effect.key) ? "Remove from favorites" : "Add to favorites",
                        "aria-label": favorites.value.includes(effect.key) ? `Remove ${effect.name} from favorites` : `Add ${effect.name} to favorites`,
                        "aria-pressed": favorites.value.includes(effect.key)
                      }, [
                        createBaseVNode("span", _hoisted_19$C, toDisplayString(favorites.value.includes(effect.key) ? "" : ""), 1)
                      ], 8, _hoisted_18$D)
                    ], 42, _hoisted_16$G);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "presets" ? (openBlock(), createElementBlock("div", _hoisted_20$C, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedPresets.value, (group) => {
              return openBlock(), createElementBlock("div", {
                key: group.category,
                class: "preset-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => togglePresetCategory(group.category)
                }, [
                  createBaseVNode("span", _hoisted_22$y, toDisplayString(expandedPresetCategories.value.includes(group.category) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_23$y, toDisplayString(group.category), 1),
                  createBaseVNode("span", _hoisted_24$s, toDisplayString(group.presets.length), 1)
                ], 8, _hoisted_21$A),
                expandedPresetCategories.value.includes(group.category) ? (openBlock(), createElementBlock("div", _hoisted_25$s, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(group.presets, (preset) => {
                    return openBlock(), createElementBlock("div", {
                      key: preset.id,
                      class: "preset-item",
                      onDblclick: ($event) => applyPreset(preset),
                      onDragstart: ($event) => onDragPreset(preset, $event),
                      draggable: "true"
                    }, [
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "preset-preview" }, [
                        createBaseVNode("span", { class: "preview-icon" }, "")
                      ], -1)),
                      createBaseVNode("div", _hoisted_27$p, [
                        createBaseVNode("span", _hoisted_28$o, toDisplayString(preset.name), 1),
                        createBaseVNode("span", _hoisted_29$o, toDisplayString(preset.description), 1)
                      ])
                    ], 40, _hoisted_26$q);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "favorites" ? (openBlock(), createElementBlock("div", _hoisted_30$n, [
            favoriteEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_31$l, [..._cache[6] || (_cache[6] = [
              createBaseVNode("p", null, "No favorites yet", -1),
              createBaseVNode("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
            ])])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(favoriteEffects.value, (effect) => {
              return openBlock(), createElementBlock("div", {
                key: effect.key,
                class: "effect-item",
                onDblclick: ($event) => applyEffect(effect.key),
                onDragstart: ($event) => onDragStart(effect.key, $event),
                draggable: "true"
              }, [
                createBaseVNode("span", _hoisted_33$l, toDisplayString(getCategoryIcon(effect.category)), 1),
                createBaseVNode("span", _hoisted_34$j, toDisplayString(effect.name), 1),
                createBaseVNode("button", {
                  class: "favorite-btn active",
                  onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"])
                }, "  ", 8, _hoisted_35$h)
              ], 40, _hoisted_32$l);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "panel-footer" }, [
          createBaseVNode("span", { class: "info-text" }, "Double-click or drag to apply")
        ], -1))
      ]);
    };
  }
});

const EffectsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__scopeId", "data-v-00012ead"]]);

const _hoisted_1$V = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$U = {
  key: 2,
  class: "scrub-unit"
};
const dragThreshold = 3;
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -Infinity },
    max: { default: Infinity },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const inputRef = ref(null);
    const isScrubbing = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const isDragging = ref(false);
    const defaultValue = computed(() => props.default ?? props.modelValue);
    const showReset = computed(() => props.default !== void 0);
    const displayValue = computed(() => {
      if (Number.isInteger(props.modelValue) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      e.preventDefault();
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onInputMouseDown(e) {
      if (props.disabled) return;
      if (e.button !== 0) return;
      const startX = e.clientX;
      const startY = e.clientY;
      isDragging.value = false;
      const onMouseMove = (moveEvent) => {
        const deltaX = Math.abs(moveEvent.clientX - startX);
        const deltaY = Math.abs(moveEvent.clientY - startY);
        if (!isDragging.value && (deltaX > dragThreshold || deltaY > dragThreshold)) {
          isDragging.value = true;
          isScrubbing.value = true;
          scrubStartX.value = startX;
          scrubStartValue.value = props.modelValue;
          document.body.style.cursor = "ew-resize";
          document.body.style.userSelect = "none";
          inputRef.value?.blur();
        }
        if (isDragging.value) {
          onScrubMove(moveEvent);
        }
      };
      const onMouseUp = () => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        if (isDragging.value) {
          isScrubbing.value = false;
          document.body.style.cursor = "";
          document.body.style.userSelect = "";
        }
        isDragging.value = false;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      let multiplier = props.sensitivity;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX * props.step * multiplier * 0.5;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onKeyDown(e) {
      if (props.disabled) return;
      let delta = 0;
      if (e.key === "ArrowUp") delta = props.step;
      else if (e.key === "ArrowDown") delta = -props.step;
      if (delta !== 0) {
        e.preventDefault();
        if (e.shiftKey) delta *= 10;
        if (e.ctrlKey || e.metaKey) delta *= 0.1;
        emit("update:modelValue", round(clamp(props.modelValue + delta)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    function reset() {
      if (props.default !== void 0) {
        emit("update:modelValue", props.default);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["scrubable-number", { disabled: __props.disabled, scrubbing: isScrubbing.value }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["scrub-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        !__props.label ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["scrub-handle", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub,
          title: "Drag to scrub value"
        }, "  ", 34)) : createCommentVNode("", true),
        createBaseVNode("input", {
          ref_key: "inputRef",
          ref: inputRef,
          type: "number",
          class: normalizeClass(["scrub-input", { scrubbing: isScrubbing.value }]),
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onKeydown: onKeyDown,
          onBlur,
          onMousedown: onInputMouseDown
        }, null, 42, _hoisted_1$V),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$U, toDisplayString(__props.unit), 1)) : createCommentVNode("", true),
        showReset.value && __props.modelValue !== defaultValue.value ? (openBlock(), createElementBlock("button", {
          key: 3,
          class: "reset-btn",
          onClick: reset,
          title: "Reset to default"
        }, [..._cache[0] || (_cache[0] = [
          createBaseVNode("i", { class: "pi pi-refresh" }, null, -1)
        ])])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const ScrubableNumber = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__scopeId", "data-v-26c41962"]]);

const _hoisted_1$U = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$T = {
  key: 2,
  class: "slider-unit"
};
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: true },
    gradient: {},
    disabled: { type: Boolean, default: false },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const trackRef = ref(null);
    const isScrubbing = ref(false);
    const isDragging = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const fillPercent = computed(() => {
      const range = props.max - props.min;
      if (range === 0) return 0;
      return (props.modelValue - props.min) / range * 100;
    });
    const displayValue = computed(() => {
      if (Number.isInteger(props.step) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      const range = props.max - props.min;
      let multiplier = 1;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX / 200 * range * multiplier;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onTrackClick(e) {
      if (props.disabled || !trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + percent * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function startThumbDrag(_e) {
      if (props.disabled) return;
      isDragging.value = true;
      document.addEventListener("mousemove", onThumbDrag);
      document.addEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onThumbDrag(e) {
      if (!trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + Math.max(0, Math.min(1, percent)) * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function stopThumbDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onThumbDrag);
      document.removeEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slider-input", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["slider-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "slider-track",
          ref_key: "trackRef",
          ref: trackRef,
          onMousedown: onTrackClick
        }, [
          createBaseVNode("div", {
            class: "slider-fill",
            style: normalizeStyle({ width: fillPercent.value + "%", background: __props.gradient || void 0 })
          }, null, 4),
          createBaseVNode("div", {
            class: "slider-thumb",
            style: normalizeStyle({ left: fillPercent.value + "%" }),
            onMousedown: withModifiers(startThumbDrag, ["stop"])
          }, null, 36)
        ], 544),
        __props.showValue ? (openBlock(), createElementBlock("input", {
          key: 1,
          type: "number",
          class: "slider-value",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onBlur
        }, null, 40, _hoisted_1$U)) : createCommentVNode("", true),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$T, toDisplayString(__props.unit), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const SliderInput = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["__scopeId", "data-v-f02d596e"]]);

const _hoisted_1$T = { class: "dial-marks" };
const _hoisted_2$S = {
  key: 0,
  class: "angle-value"
};
const _hoisted_3$S = ["value", "disabled"];
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const dialRef = ref(null);
    const isDragging = ref(false);
    const displayValue = computed(() => {
      return Math.round(props.modelValue * 10) / 10;
    });
    function normalizeAngle(angle) {
      return (angle % 360 + 360) % 360;
    }
    function startDrag(e) {
      if (props.disabled) return;
      isDragging.value = true;
      updateAngle(e);
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      updateAngle(e);
    }
    function updateAngle(e) {
      if (!dialRef.value) return;
      const rect = dialRef.value.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      let angle = Math.atan2(deltaX, -deltaY) * (180 / Math.PI);
      angle = normalizeAngle(angle);
      if (e.shiftKey) {
        angle = Math.round(angle / 45) * 45;
      }
      emit("update:modelValue", angle);
    }
    function stopDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mouseup", stopDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", normalizeAngle(value));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["angle-dial", { disabled: __props.disabled }])
      }, [
        createBaseVNode("div", {
          class: "dial",
          ref_key: "dialRef",
          ref: dialRef,
          style: normalizeStyle({ width: __props.size + "px", height: __props.size + "px" }),
          onMousedown: startDrag
        }, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "dial-ring" }, null, -1)),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "dial-center" }, null, -1)),
          createBaseVNode("div", {
            class: "dial-indicator",
            style: normalizeStyle({ transform: `rotate(${__props.modelValue}deg)` })
          }, null, 4),
          createBaseVNode("div", _hoisted_1$T, [
            (openBlock(), createElementBlock(Fragment, null, renderList(8, (i) => {
              return createBaseVNode("div", {
                class: "dial-mark",
                key: i,
                style: normalizeStyle({ transform: `rotate(${i * 45}deg)` })
              }, null, 4);
            }), 64))
          ])
        ], 36),
        __props.showValue ? (openBlock(), createElementBlock("div", _hoisted_2$S, [
          createBaseVNode("input", {
            type: "number",
            class: "angle-input",
            value: displayValue.value,
            disabled: __props.disabled,
            onInput,
            onBlur
          }, null, 40, _hoisted_3$S),
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "angle-unit" }, "", -1))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const AngleDial = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__scopeId", "data-v-0fa5dfd2"]]);

function hsvToRgb(h, s, v) {
  h = (h % 360 + 360) % 360;
  const c = v * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = v - c;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (d !== 0) {
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, v];
}
function hslToRgb$1(h, s, l) {
  h = (h % 360 + 360) % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsl$1(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, l];
}
function hexToRgb(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length === 6 || hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
      return [r, g, b];
    }
  }
  return null;
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "ff";
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  if (hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = parseInt(hex.slice(6, 8), 16) / 255;
    if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
      return [r, g, b, a];
    }
  }
  return null;
}
function rgbToHex(r, g, b) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function rgbaToHex(r, g, b, a) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}${toHex(a * 255)}`;
}
const STANDARD_SWATCHES = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
];

const _hoisted_1$S = {
  key: 0,
  class: "checkerboard"
};
const _hoisted_2$R = ["value"];
const _hoisted_3$R = { class: "mode-tabs" };
const _hoisted_4$R = ["onClick"];
const _hoisted_5$R = {
  key: 1,
  class: "rgb-sliders"
};
const _hoisted_6$R = { class: "color-slider" };
const _hoisted_7$R = ["value"];
const _hoisted_8$P = { class: "color-slider" };
const _hoisted_9$P = ["value"];
const _hoisted_10$O = { class: "color-slider" };
const _hoisted_11$N = ["value"];
const _hoisted_12$L = {
  key: 2,
  class: "hsl-sliders"
};
const _hoisted_13$L = { class: "color-slider" };
const _hoisted_14$H = ["value"];
const _hoisted_15$G = { class: "color-slider" };
const _hoisted_16$F = ["value"];
const _hoisted_17$E = { class: "color-slider" };
const _hoisted_18$C = ["value"];
const _hoisted_19$B = {
  key: 3,
  class: "alpha-slider"
};
const _hoisted_20$B = ["value"];
const _hoisted_21$z = { class: "swatches-section" };
const _hoisted_22$x = { class: "swatches-grid" };
const _hoisted_23$x = ["onClick"];
const _hoisted_24$r = {
  key: 4,
  class: "recent-section"
};
const _hoisted_25$r = { class: "swatches-grid" };
const _hoisted_26$p = ["onClick"];
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: false },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const modes = ["hsv", "rgb", "hsl"];
    const containerRef = ref(null);
    const panelRef = ref(null);
    const svSquareRef = ref(null);
    const hueSliderRef = ref(null);
    const alphaSliderRef = ref(null);
    const isOpen = ref(false);
    const currentMode = ref("hsv");
    const alphaValue = ref(1);
    const recentColors = ref([]);
    const rgb = ref([255, 255, 255]);
    const hsv = ref([0, 0, 1]);
    const hsl = ref([0, 0, 1]);
    const allSwatches = computed(() => props.swatches || STANDARD_SWATCHES);
    const panelStyle = computed(() => {
      if (!containerRef.value || !props.teleport) return {};
      const rect = containerRef.value.getBoundingClientRect();
      return {
        top: `${rect.bottom + 4}px`,
        left: `${rect.left}px`
      };
    });
    function updateFromHex(hex) {
      const parsed = hexToRgb(hex);
      if (parsed) {
        rgb.value = parsed;
        hsv.value = rgbToHsv(parsed[0], parsed[1], parsed[2]);
        hsl.value = rgbToHsl$1(parsed[0], parsed[1], parsed[2]);
      }
    }
    function emitColor() {
      const hex = rgbToHex(rgb.value[0], rgb.value[1], rgb.value[2]);
      emit("update:modelValue", hex);
    }
    function togglePicker() {
      isOpen.value = !isOpen.value;
    }
    function closePicker() {
      if (isOpen.value) {
        isOpen.value = false;
        addToRecent(props.modelValue);
      }
    }
    function addToRecent(color) {
      const index = recentColors.value.indexOf(color);
      if (index !== -1) {
        recentColors.value.splice(index, 1);
      }
      recentColors.value.unshift(color);
      if (recentColors.value.length > props.recentCount) {
        recentColors.value.pop();
      }
    }
    function selectSwatch(color) {
      emit("update:modelValue", color);
    }
    let isDraggingSV = false;
    function startSVDrag(e) {
      isDraggingSV = true;
      updateSV(e);
      document.addEventListener("mousemove", onSVDrag);
      document.addEventListener("mouseup", stopSVDrag);
    }
    function onSVDrag(e) {
      if (isDraggingSV) updateSV(e);
    }
    function updateSV(e) {
      if (!svSquareRef.value) return;
      const rect = svSquareRef.value.getBoundingClientRect();
      const s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
      hsv.value = [hsv.value[0], s, v];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopSVDrag() {
      isDraggingSV = false;
      document.removeEventListener("mousemove", onSVDrag);
      document.removeEventListener("mouseup", stopSVDrag);
    }
    let isDraggingHue = false;
    function startHueDrag(e) {
      isDraggingHue = true;
      updateHue(e);
      document.addEventListener("mousemove", onHueDrag);
      document.addEventListener("mouseup", stopHueDrag);
    }
    function onHueDrag(e) {
      if (isDraggingHue) updateHue(e);
    }
    function updateHue(e) {
      if (!hueSliderRef.value) return;
      const rect = hueSliderRef.value.getBoundingClientRect();
      const h = Math.max(0, Math.min(360, (e.clientX - rect.left) / rect.width * 360));
      hsv.value = [h, hsv.value[1], hsv.value[2]];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopHueDrag() {
      isDraggingHue = false;
      document.removeEventListener("mousemove", onHueDrag);
      document.removeEventListener("mouseup", stopHueDrag);
    }
    let draggingSlider = null;
    let sliderRect = null;
    function startSliderDrag(slider, e) {
      draggingSlider = slider;
      const track = e.target.closest(".slider-track");
      if (track) {
        sliderRect = track.getBoundingClientRect();
        updateSlider(e);
        document.addEventListener("mousemove", onSliderDrag);
        document.addEventListener("mouseup", stopSliderDrag);
      }
    }
    function onSliderDrag(e) {
      if (draggingSlider) updateSlider(e);
    }
    function updateSlider(e) {
      if (!sliderRect || !draggingSlider) return;
      const percent = Math.max(0, Math.min(1, (e.clientX - sliderRect.left) / sliderRect.width));
      switch (draggingSlider) {
        case "r":
          rgb.value = [Math.round(percent * 255), rgb.value[1], rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "g":
          rgb.value = [rgb.value[0], Math.round(percent * 255), rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "b":
          rgb.value = [rgb.value[0], rgb.value[1], Math.round(percent * 255)];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "h":
          hsl.value = [percent * 360, hsl.value[1], hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "s":
          hsl.value = [hsl.value[0], percent, hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "l":
          hsl.value = [hsl.value[0], hsl.value[1], percent];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
      }
      emitColor();
    }
    function stopSliderDrag() {
      draggingSlider = null;
      sliderRect = null;
      document.removeEventListener("mousemove", onSliderDrag);
      document.removeEventListener("mouseup", stopSliderDrag);
    }
    let isDraggingAlpha = false;
    function startAlphaDrag(e) {
      isDraggingAlpha = true;
      updateAlpha(e);
      document.addEventListener("mousemove", onAlphaDrag);
      document.addEventListener("mouseup", stopAlphaDrag);
    }
    function onAlphaDrag(e) {
      if (isDraggingAlpha) updateAlpha(e);
    }
    function updateAlpha(e) {
      if (!alphaSliderRef.value) return;
      const rect = alphaSliderRef.value.getBoundingClientRect();
      alphaValue.value = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    }
    function stopAlphaDrag() {
      isDraggingAlpha = false;
      document.removeEventListener("mousemove", onAlphaDrag);
      document.removeEventListener("mouseup", stopAlphaDrag);
    }
    function onHexInput(e) {
      const input = e.target;
      let value = input.value.trim();
      if (!value.startsWith("#")) {
        value = "#" + value;
      }
      if (/^#[0-9a-f]{6}$/i.test(value)) {
        emit("update:modelValue", value.toLowerCase());
      }
    }
    function onHexBlur(e) {
      const input = e.target;
      input.value = props.modelValue;
    }
    function onRgbInput(index, e) {
      const input = e.target;
      const value = Math.max(0, Math.min(255, parseInt(input.value) || 0));
      const newRgb = [...rgb.value];
      newRgb[index] = value;
      rgb.value = newRgb;
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onHslInput(index, e) {
      const input = e.target;
      let value = parseFloat(input.value) || 0;
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
        hsl.value = [value, hsl.value[1], hsl.value[2]];
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
        if (index === 1) hsl.value = [hsl.value[0], value, hsl.value[2]];
        else hsl.value = [hsl.value[0], hsl.value[1], value];
      }
      rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onAlphaInput(e) {
      const input = e.target;
      alphaValue.value = Math.max(0, Math.min(100, parseInt(input.value) || 0)) / 100;
    }
    function onClickOutside(e) {
      if (containerRef.value && !containerRef.value.contains(e.target) && panelRef.value && !panelRef.value.contains(e.target)) {
        closePicker();
      }
    }
    watch(() => props.modelValue, (newVal) => {
      updateFromHex(newVal);
    }, { immediate: true });
    onMounted(() => {
      document.addEventListener("mousedown", onClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("mousedown", onClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "color-picker",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("button", {
          class: "color-swatch",
          style: normalizeStyle({ backgroundColor: __props.modelValue }),
          onClick: togglePicker
        }, [
          __props.alpha ? (openBlock(), createElementBlock("span", _hoisted_1$S)) : createCommentVNode("", true)
        ], 4),
        createBaseVNode("input", {
          type: "text",
          class: "hex-input",
          value: __props.modelValue,
          onInput: onHexInput,
          onBlur: onHexBlur,
          onKeydown: _cache[0] || (_cache[0] = withKeys(($event) => $event.target.blur(), ["enter"]))
        }, null, 40, _hoisted_2$R),
        (openBlock(), createBlock(Teleport, {
          to: "body",
          disabled: !__props.teleport
        }, [
          isOpen.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "picker-panel",
            style: normalizeStyle(panelStyle.value),
            ref_key: "panelRef",
            ref: panelRef
          }, [
            createBaseVNode("div", _hoisted_3$R, [
              (openBlock(), createElementBlock(Fragment, null, renderList(modes, (mode) => {
                return createBaseVNode("button", {
                  key: mode,
                  class: normalizeClass({ active: currentMode.value === mode }),
                  onClick: ($event) => currentMode.value = mode
                }, toDisplayString(mode.toUpperCase()), 11, _hoisted_4$R);
              }), 64))
            ]),
            currentMode.value === "hsv" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: "sv-square",
                style: normalizeStyle({ backgroundColor: `hsl(${hsv.value[0]}, 100%, 50%)` }),
                onMousedown: startSVDrag,
                ref_key: "svSquareRef",
                ref: svSquareRef
              }, [
                _cache[13] || (_cache[13] = createBaseVNode("div", { class: "sv-white" }, null, -1)),
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "sv-black" }, null, -1)),
                createBaseVNode("div", {
                  class: "sv-cursor",
                  style: normalizeStyle({ left: hsv.value[1] * 100 + "%", top: (1 - hsv.value[2]) * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("div", {
                class: "hue-slider",
                onMousedown: startHueDrag,
                ref_key: "hueSliderRef",
                ref: hueSliderRef
              }, [
                createBaseVNode("div", {
                  class: "hue-cursor",
                  style: normalizeStyle({ left: hsv.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 544)
            ], 64)) : currentMode.value === "rgb" ? (openBlock(), createElementBlock("div", _hoisted_5$R, [
              createBaseVNode("div", _hoisted_6$R, [
                _cache[15] || (_cache[15] = createBaseVNode("label", null, "R", -1)),
                createBaseVNode("div", {
                  class: "slider-track r-track",
                  onMousedown: _cache[1] || (_cache[1] = ($event) => startSliderDrag("r", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[0] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[0],
                  min: "0",
                  max: "255",
                  onInput: _cache[2] || (_cache[2] = ($event) => onRgbInput(0, $event))
                }, null, 40, _hoisted_7$R)
              ]),
              createBaseVNode("div", _hoisted_8$P, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "G", -1)),
                createBaseVNode("div", {
                  class: "slider-track g-track",
                  onMousedown: _cache[3] || (_cache[3] = ($event) => startSliderDrag("g", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[1] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[1],
                  min: "0",
                  max: "255",
                  onInput: _cache[4] || (_cache[4] = ($event) => onRgbInput(1, $event))
                }, null, 40, _hoisted_9$P)
              ]),
              createBaseVNode("div", _hoisted_10$O, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "B", -1)),
                createBaseVNode("div", {
                  class: "slider-track b-track",
                  onMousedown: _cache[5] || (_cache[5] = ($event) => startSliderDrag("b", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[2] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[2],
                  min: "0",
                  max: "255",
                  onInput: _cache[6] || (_cache[6] = ($event) => onRgbInput(2, $event))
                }, null, 40, _hoisted_11$N)
              ])
            ])) : currentMode.value === "hsl" ? (openBlock(), createElementBlock("div", _hoisted_12$L, [
              createBaseVNode("div", _hoisted_13$L, [
                _cache[18] || (_cache[18] = createBaseVNode("label", null, "H", -1)),
                createBaseVNode("div", {
                  class: "slider-track hue-track",
                  onMousedown: _cache[7] || (_cache[7] = ($event) => startSliderDrag("h", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[0] / 360 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[0]),
                  min: "0",
                  max: "360",
                  onInput: _cache[8] || (_cache[8] = ($event) => onHslInput(0, $event))
                }, null, 40, _hoisted_14$H)
              ]),
              createBaseVNode("div", _hoisted_15$G, [
                _cache[19] || (_cache[19] = createBaseVNode("label", null, "S", -1)),
                createBaseVNode("div", {
                  class: "slider-track sat-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[9] || (_cache[9] = ($event) => startSliderDrag("s", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[1] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[1] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[10] || (_cache[10] = ($event) => onHslInput(1, $event))
                }, null, 40, _hoisted_16$F)
              ]),
              createBaseVNode("div", _hoisted_17$E, [
                _cache[20] || (_cache[20] = createBaseVNode("label", null, "L", -1)),
                createBaseVNode("div", {
                  class: "slider-track light-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[11] || (_cache[11] = ($event) => startSliderDrag("l", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[2] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[2] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[12] || (_cache[12] = ($event) => onHslInput(2, $event))
                }, null, 40, _hoisted_18$C)
              ])
            ])) : createCommentVNode("", true),
            __props.alpha ? (openBlock(), createElementBlock("div", _hoisted_19$B, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "A", -1)),
              createBaseVNode("div", {
                class: "slider-track alpha-track",
                style: normalizeStyle({ "--color": __props.modelValue }),
                onMousedown: startAlphaDrag,
                ref_key: "alphaSliderRef",
                ref: alphaSliderRef
              }, [
                createBaseVNode("div", {
                  class: "slider-cursor",
                  style: normalizeStyle({ left: alphaValue.value * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("input", {
                type: "number",
                value: Math.round(alphaValue.value * 100),
                min: "0",
                max: "100",
                onInput: onAlphaInput
              }, null, 40, _hoisted_20$B)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_21$z, [
              _cache[22] || (_cache[22] = createBaseVNode("div", { class: "swatches-label" }, "Swatches", -1)),
              createBaseVNode("div", _hoisted_22$x, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allSwatches.value, (swatch) => {
                  return openBlock(), createElementBlock("button", {
                    key: swatch,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: swatch }),
                    onClick: ($event) => selectSwatch(swatch)
                  }, null, 12, _hoisted_23$x);
                }), 128))
              ])
            ]),
            recentColors.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_24$r, [
              _cache[23] || (_cache[23] = createBaseVNode("div", { class: "swatches-label" }, "Recent", -1)),
              createBaseVNode("div", _hoisted_25$r, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(recentColors.value, (color) => {
                  return openBlock(), createElementBlock("button", {
                    key: color,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: color }),
                    onClick: ($event) => selectSwatch(color)
                  }, null, 12, _hoisted_26$p);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ], 8, ["disabled"]))
      ], 512);
    };
  }
});

const ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__scopeId", "data-v-98ed6487"]]);

const _hoisted_1$R = { class: "effect-controls" };
const _hoisted_2$Q = { class: "panel-header" };
const _hoisted_3$Q = { class: "header-row" };
const _hoisted_4$Q = {
  key: 0,
  class: "layer-badge"
};
const _hoisted_5$Q = { class: "layer-type-icon" };
const _hoisted_6$Q = ["disabled"];
const _hoisted_7$Q = {
  key: 0,
  class: "effect-menu"
};
const _hoisted_8$O = { class: "category-label" };
const _hoisted_9$O = { class: "cat-icon" };
const _hoisted_10$N = { class: "category-items" };
const _hoisted_11$M = ["onClick"];
const _hoisted_12$K = { class: "panel-content" };
const _hoisted_13$K = {
  key: 0,
  class: "empty-state"
};
const _hoisted_14$G = {
  key: 1,
  class: "empty-state"
};
const _hoisted_15$F = {
  key: 2,
  class: "effects-list"
};
const _hoisted_16$E = ["onDragstart", "onDragover", "onDrop"];
const _hoisted_17$D = ["onClick"];
const _hoisted_18$B = { class: "header-left" };
const _hoisted_19$A = { class: "arrow" };
const _hoisted_20$A = ["onClick"];
const _hoisted_21$y = { class: "effect-name" };
const _hoisted_22$w = { class: "header-right" };
const _hoisted_23$w = ["onClick"];
const _hoisted_24$q = {
  key: 0,
  class: "effect-params"
};
const _hoisted_25$q = { class: "param-header" };
const _hoisted_26$o = ["title"];
const _hoisted_27$o = ["onClick"];
const _hoisted_28$n = { class: "param-control" };
const _hoisted_29$n = {
  key: 0,
  class: "control-group"
};
const _hoisted_30$m = {
  key: 1,
  class: "control-group"
};
const _hoisted_31$k = {
  key: 2,
  class: "control-group point-group"
};
const _hoisted_32$k = ["checked", "onChange"];
const _hoisted_33$k = ["value", "onChange"];
const _hoisted_34$i = ["value"];
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "EffectControlsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const showAddMenu = ref(false);
    const menuRef = ref(null);
    const dragOverEffectId = ref(null);
    const draggedIndex = ref(null);
    const layer = computed(() => store.selectedLayer);
    const categories = EFFECT_CATEGORIES;
    function getEffectsByCategory(cat) {
      return Object.entries(EFFECT_DEFINITIONS).filter(([_, def]) => def.category === cat).map(([key, def]) => ({ key, ...def }));
    }
    function getParamDef(effectKey, paramKey) {
      const def = EFFECT_DEFINITIONS[effectKey];
      return def?.parameters.find((p) => formatParamKey(p.name) === paramKey);
    }
    function formatParamKey(name) {
      return name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function hasRange(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def && (def.min !== void 0 || def.max !== void 0);
    }
    function isCheckbox(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "checkbox";
    }
    function isAngleParam(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "angle";
    }
    function getParamOptions(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.options || [];
    }
    function getLayerIcon(type) {
      const icons = {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      };
      return icons[type] || "";
    }
    function addEffect(key) {
      if (layer.value) {
        store.addEffectToLayer(layer.value.id, key);
        showAddMenu.value = false;
      }
    }
    function removeEffect(effect) {
      if (layer.value) store.removeEffectFromLayer(layer.value.id, effect.id);
    }
    function toggleEffect(effect) {
      if (layer.value) store.toggleEffect(layer.value.id, effect.id);
    }
    function toggleExpand(effect) {
      effect.expanded = !effect.expanded;
    }
    function updateParam(effectId, paramKey, value) {
      if (layer.value) store.updateEffectParameter(layer.value.id, effectId, paramKey, value);
    }
    function updatePoint(effectId, paramKey, axis, val) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      if (!effect) return;
      const current = effect.parameters[paramKey].value;
      const newValue = { ...current, [axis]: val };
      store.updateEffectParameter(layer.value.id, effectId, paramKey, newValue);
    }
    function formatColor(val) {
      if (typeof val === "string") return val;
      return rgbaToHex(val.r, val.g, val.b, val.a ?? 1);
    }
    function updateColor(effectId, paramKey, hex) {
      const rgba = hexToRgba(hex);
      if (rgba && layer.value) {
        const val = { r: rgba[0], g: rgba[1], b: rgba[2], a: rgba[3] };
        store.updateEffectParameter(layer.value.id, effectId, paramKey, val);
      }
    }
    function toggleParamAnim(effectId, paramKey) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      const param = effect?.parameters[paramKey];
      if (param) {
        store.setEffectParamAnimated(layer.value.id, effectId, paramKey, !param.animated);
      }
    }
    function onDragStart(event, index) {
      draggedIndex.value = index;
      event.dataTransfer?.setData("application/effect-reorder", String(index));
      event.dataTransfer.effectAllowed = "move";
    }
    function onDragEnd() {
      draggedIndex.value = null;
      dragOverEffectId.value = null;
    }
    function onDragOver(event, effectId) {
      const data = event.dataTransfer?.types.includes("application/effect-reorder");
      if (data) {
        dragOverEffectId.value = effectId;
      }
    }
    function onDragLeave() {
      dragOverEffectId.value = null;
    }
    function onDrop(event, targetIndex) {
      dragOverEffectId.value = null;
      const fromIndexStr = event.dataTransfer?.getData("application/effect-reorder");
      if (!fromIndexStr || !layer.value) return;
      const fromIndex = parseInt(fromIndexStr, 10);
      if (fromIndex !== targetIndex && !isNaN(fromIndex)) {
        store.reorderEffects(layer.value.id, fromIndex, targetIndex);
      }
    }
    function onClickOutside(e) {
      if (menuRef.value && !menuRef.value.contains(e.target)) {
        showAddMenu.value = false;
      }
    }
    onMounted(() => window.addEventListener("mousedown", onClickOutside));
    onUnmounted(() => window.removeEventListener("mousedown", onClickOutside));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$R, [
        createBaseVNode("div", _hoisted_2$Q, [
          createBaseVNode("div", _hoisted_3$Q, [
            _cache[1] || (_cache[1] = createBaseVNode("h3", null, "Effect Controls", -1)),
            layer.value ? (openBlock(), createElementBlock("div", _hoisted_4$Q, [
              createBaseVNode("span", _hoisted_5$Q, toDisplayString(getLayerIcon(layer.value.type)), 1),
              createTextVNode(" " + toDisplayString(layer.value.name), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: "add-effect-wrapper",
            ref_key: "menuRef",
            ref: menuRef
          }, [
            createBaseVNode("button", {
              class: "add-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => showAddMenu.value = !showAddMenu.value),
              disabled: !layer.value
            }, [..._cache[2] || (_cache[2] = [
              createBaseVNode("span", { class: "icon" }, "+", -1),
              createTextVNode(" Add Effect ", -1)
            ])], 8, _hoisted_6$Q),
            showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_7$Q, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(categories), (catInfo, catKey) => {
                return openBlock(), createElementBlock("div", {
                  key: catKey,
                  class: "effect-category"
                }, [
                  createBaseVNode("div", _hoisted_8$O, [
                    createBaseVNode("span", _hoisted_9$O, toDisplayString(catInfo.icon), 1),
                    createTextVNode(" " + toDisplayString(catInfo.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_10$N, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getEffectsByCategory(catKey), (def) => {
                      return openBlock(), createElementBlock("button", {
                        key: def.key,
                        onClick: ($event) => addEffect(def.key)
                      }, toDisplayString(def.name), 9, _hoisted_11$M);
                    }), 128))
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 512)
        ]),
        createBaseVNode("div", _hoisted_12$K, [
          !layer.value ? (openBlock(), createElementBlock("div", _hoisted_13$K, " Select a layer to edit effects ")) : !layer.value.effects || layer.value.effects.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_14$G, " No effects applied ")) : (openBlock(), createElementBlock("div", _hoisted_15$F, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(layer.value.effects, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: normalizeClass(["effect-item", { collapsed: !effect.expanded, "drag-over": dragOverEffectId.value === effect.id }]),
                draggable: "true",
                onDragstart: ($event) => onDragStart($event, index),
                onDragend: onDragEnd,
                onDragover: withModifiers(($event) => onDragOver($event, effect.id), ["prevent"]),
                onDragleave: onDragLeave,
                onDrop: ($event) => onDrop($event, index)
              }, [
                createBaseVNode("div", {
                  class: "effect-header",
                  onClick: ($event) => toggleExpand(effect)
                }, [
                  createBaseVNode("div", _hoisted_18$B, [
                    createBaseVNode("span", _hoisted_19$A, toDisplayString(effect.expanded ? "" : ""), 1),
                    createBaseVNode("button", {
                      class: "icon-btn",
                      onClick: withModifiers(($event) => toggleEffect(effect), ["stop"])
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(["fx-icon", { disabled: !effect.enabled }])
                      }, "fx", 2)
                    ], 8, _hoisted_20$A),
                    createBaseVNode("span", _hoisted_21$y, toDisplayString(effect.name), 1)
                  ]),
                  createBaseVNode("div", _hoisted_22$w, [
                    createBaseVNode("button", {
                      class: "icon-btn delete",
                      onClick: withModifiers(($event) => removeEffect(effect), ["stop"]),
                      title: "Remove Effect"
                    }, "", 8, _hoisted_23$w)
                  ])
                ], 8, _hoisted_17$D),
                effect.expanded ? (openBlock(), createElementBlock("div", _hoisted_24$q, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(effect.parameters, (param, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: "param-row"
                    }, [
                      createBaseVNode("div", _hoisted_25$q, [
                        createBaseVNode("span", {
                          class: "param-name",
                          title: String(key)
                        }, toDisplayString(param.name), 9, _hoisted_26$o),
                        createBaseVNode("button", {
                          class: normalizeClass(["keyframe-toggle", { active: param.animated }]),
                          onClick: ($event) => toggleParamAnim(effect.id, String(key)),
                          title: "Toggle Animation"
                        }, "", 10, _hoisted_27$o)
                      ]),
                      createBaseVNode("div", _hoisted_28$n, [
                        param.type === "number" && isAngleParam(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("div", _hoisted_29$n, [
                          createVNode(AngleDial, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            size: 32,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            unit: ""
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "number" ? (openBlock(), createElementBlock("div", _hoisted_30$m, [
                          hasRange(effect.effectKey, String(key)) ? (openBlock(), createBlock(SliderInput, {
                            key: 0,
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            min: getParamDef(effect.effectKey, String(key))?.min ?? 0,
                            max: getParamDef(effect.effectKey, String(key))?.max ?? 100,
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 1,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : createCommentVNode("", true),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 0.1
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                        ])) : param.type === "position" ? (openBlock(), createElementBlock("div", _hoisted_31$k, [
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.x,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "x", v),
                            label: "X"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.y,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "y", v),
                            label: "Y"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "color" ? (openBlock(), createBlock(ColorPicker, {
                          key: 3,
                          modelValue: formatColor(param.value),
                          "onUpdate:modelValue": (v) => updateColor(effect.id, String(key), v),
                          alpha: true
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])) : param.type === "enum" && isCheckbox(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("input", {
                          key: 4,
                          type: "checkbox",
                          checked: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.checked)
                        }, null, 40, _hoisted_32$k)) : param.type === "enum" ? (openBlock(), createElementBlock("select", {
                          key: 5,
                          value: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.value),
                          class: "param-select"
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(getParamOptions(effect.effectKey, String(key)), (opt) => {
                            return openBlock(), createElementBlock("option", {
                              key: opt.value,
                              value: opt.value
                            }, toDisplayString(opt.label), 9, _hoisted_34$i);
                          }), 128))
                        ], 40, _hoisted_33$k)) : createCommentVNode("", true)
                      ])
                    ]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 42, _hoisted_16$E);
            }), 128))
          ]))
        ])
      ]);
    };
  }
});

const EffectControlsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__scopeId", "data-v-977fee95"]]);

const fontLogger = createLogger("Font");
const WEB_SAFE_FONTS = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
];
const GOOGLE_FONTS = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class FontService {
  systemFonts = [];
  loadedGoogleFonts = /* @__PURE__ */ new Set();
  initialized = false;
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    if (this.initialized) return;
    if ("queryLocalFonts" in window) {
      await this.loadSystemFonts();
    }
    this.initialized = true;
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const fonts = await window.queryLocalFonts();
      const familyMap = /* @__PURE__ */ new Map();
      for (const font of fonts) {
        if (!familyMap.has(font.family) || font.style === "Regular") {
          familyMap.set(font.family, {
            family: font.family,
            fullName: font.fullName,
            style: font.style,
            source: "system"
          });
        }
      }
      this.systemFonts = Array.from(familyMap.values()).sort((a, b) => a.family.localeCompare(b.family));
      fontLogger.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (error) {
      if (error.name === "NotAllowedError") {
        fontLogger.info("User denied font access permission");
      } else {
        fontLogger.error("Error loading system fonts:", error);
      }
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const categories = [];
    if (this.systemFonts.length > 0) {
      categories.push({
        name: "System Fonts",
        fonts: this.systemFonts
      });
    }
    categories.push({
      name: "Web Safe",
      fonts: WEB_SAFE_FONTS
    });
    categories.push({
      name: "Google Fonts",
      fonts: GOOGLE_FONTS.map((family) => ({
        family,
        fullName: family,
        style: "normal",
        source: "google"
      }))
    });
    return categories;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const families = /* @__PURE__ */ new Set();
    WEB_SAFE_FONTS.forEach((f) => families.add(f.family));
    GOOGLE_FONTS.forEach((f) => families.add(f));
    this.systemFonts.forEach((f) => families.add(f.family));
    return Array.from(families).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(family, weights = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(family)) return;
    if (!GOOGLE_FONTS.includes(family)) {
      fontLogger.warn(`Attempted to load non-whitelisted font: ${family}`);
      return;
    }
    const weightsStr = weights.join(";");
    const url = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(family)}:wght@${weightsStr}&display=swap`;
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = url;
    document.head.appendChild(link);
    try {
      await document.fonts.load(`400 16px "${family}"`);
      this.loadedGoogleFonts.add(family);
      fontLogger.debug(`Loaded Google Font: ${family}`);
    } catch (error) {
      fontLogger.error(`Failed to load Google Font: ${family}`, error);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(family) {
    if (WEB_SAFE_FONTS.some((f) => f.family === family)) {
      return true;
    }
    if (GOOGLE_FONTS.includes(family)) {
      await this.loadGoogleFont(family);
      return true;
    }
    if (this.systemFonts.some((f) => f.family === family)) {
      return true;
    }
    return this.isFontAvailable(family);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(family) {
    const testString = "mmmmmmmmmmlli";
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = "72px monospace";
    const fallbackWidth = ctx.measureText(testString).width;
    ctx.font = `72px "${family}", monospace`;
    const testWidth = ctx.measureText(testString).width;
    return fallbackWidth !== testWidth;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return WEB_SAFE_FONTS;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return GOOGLE_FONTS;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    if (!("queryLocalFonts" in window)) {
      fontLogger.info("Local Font Access API not available");
      return false;
    }
    await this.loadSystemFonts();
    return this.systemFonts.length > 0;
  }
}
const fontService = new FontService();

function generateId() {
  return `animator_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
}
function createAnimatableProp(value, name) {
  return {
    id: generateId(),
    name,
    type: typeof value === "number" ? "number" : typeof value === "string" ? "string" : "object",
    value,
    animated: false,
    keyframes: []
  };
}
const DEFAULT_RANGE_SELECTOR = {
  mode: "percent",
  start: createAnimatableProp(0, "Start"),
  end: createAnimatableProp(100, "End"),
  offset: createAnimatableProp(0, "Offset"),
  basedOn: "characters",
  shape: "square",
  randomizeOrder: false,
  randomSeed: 12345,
  ease: { high: 100, low: 0 }
};
const DEFAULT_ANIMATOR_PROPERTIES = {};
function createTextAnimator(name) {
  return {
    id: generateId(),
    name: name || "Animator 1",
    enabled: true,
    rangeSelector: { ...DEFAULT_RANGE_SELECTOR },
    properties: { ...DEFAULT_ANIMATOR_PROPERTIES }
  };
}
const TEXT_ANIMATOR_PRESETS = {
  typewriter: {
    type: "typewriter",
    name: "Typewriter",
    description: "Characters appear one by one from left to right",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Typewriter",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        end: createAnimatableProp(100, "End"),
        basedOn: "characters",
        shape: "square"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
        // Characters start invisible
      }
    })
  },
  fade_in_by_character: {
    type: "fade_in_by_character",
    name: "Fade In (Characters)",
    description: "Characters fade in from transparent",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Fade In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  fade_in_by_word: {
    type: "fade_in_by_word",
    name: "Fade In (Words)",
    description: "Words fade in from transparent",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Fade In Words",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "words",
        shape: "ramp_down"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  bounce_in: {
    type: "bounce_in",
    name: "Bounce In",
    description: "Characters bounce in from above",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Bounce In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: 0, y: -100 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  wave: {
    type: "wave",
    name: "Wave",
    description: "Characters move up and down in a wave pattern",
    duration: 60,
    create: (_duration) => ({
      id: generateId(),
      name: "Wave",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        offset: createAnimatablePropWithKeyframes(0, "Offset", [
          { frame: 0, value: 0 },
          { frame: 30, value: 100 },
          { frame: 60, value: 0 }
        ]),
        basedOn: "characters",
        shape: "triangle"
      },
      properties: {
        position: createAnimatableProp({ x: 0, y: -20 }, "Position")
      }
    })
  },
  scale_in: {
    type: "scale_in",
    name: "Scale In",
    description: "Characters scale up from zero",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Scale In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        scale: createAnimatableProp({ x: 0, y: 0 }, "Scale"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  rotate_in: {
    type: "rotate_in",
    name: "Rotate In",
    description: "Characters rotate into place",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Rotate In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        rotation: createAnimatableProp(-90, "Rotation"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  slide_in_left: {
    type: "slide_in_left",
    name: "Slide In (Left)",
    description: "Characters slide in from the left",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Slide Left",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: -100, y: 0 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  slide_in_right: {
    type: "slide_in_right",
    name: "Slide In (Right)",
    description: "Characters slide in from the right",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Slide Right",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: 100, y: 0 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  blur_in: {
    type: "blur_in",
    name: "Blur In",
    description: "Characters unblur as they appear",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Blur In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        blur: createAnimatableProp({ x: 20, y: 20 }, "Blur"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  random_fade: {
    type: "random_fade",
    name: "Random Fade",
    description: "Characters fade in randomly",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Random Fade",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "square",
        randomizeOrder: true,
        randomSeed: Math.floor(Math.random() * 99999)
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  }
};
function createAnimatablePropWithKeyframes(value, name, keyframes, type = "number") {
  return {
    id: generateId(),
    name,
    type,
    value,
    animated: keyframes.length > 0,
    keyframes: keyframes.map((kf) => ({
      id: generateId(),
      frame: kf.frame,
      value: kf.value,
      interpolation: "bezier",
      inHandle: { frame: -5, value: 0, enabled: true },
      outHandle: { frame: 5, value: 0, enabled: true },
      controlMode: "smooth"
    }))
  };
}
function applyTextAnimatorPreset(presetType, duration = 45) {
  const preset = TEXT_ANIMATOR_PRESETS[presetType];
  if (!preset) {
    return createTextAnimator();
  }
  return preset.create(duration);
}
const TEXT_ANIMATOR_PRESET_LIST = Object.values(TEXT_ANIMATOR_PRESETS);

const _hoisted_1$Q = { class: "text-properties" };
const _hoisted_2$P = { class: "prop-section" };
const _hoisted_3$P = ["value"];
const _hoisted_4$P = { class: "prop-section" };
const _hoisted_5$P = { class: "row font-row" };
const _hoisted_6$P = ["value"];
const _hoisted_7$P = ["label"];
const _hoisted_8$N = ["value"];
const _hoisted_9$N = { class: "style-toggles" };
const _hoisted_10$M = {
  key: 0,
  class: "row"
};
const _hoisted_11$L = ["disabled"];
const _hoisted_12$J = { class: "row" };
const _hoisted_13$J = { class: "row color-row" };
const _hoisted_14$F = { class: "color-item" };
const _hoisted_15$E = ["value"];
const _hoisted_16$D = { class: "color-item" };
const _hoisted_17$C = ["value"];
const _hoisted_18$A = { class: "row" };
const _hoisted_19$z = { class: "row" };
const _hoisted_20$z = { class: "align-buttons" };
const _hoisted_21$x = { class: "prop-section" };
const _hoisted_22$v = { class: "row" };
const _hoisted_23$v = { class: "vec2" };
const _hoisted_24$p = { class: "row" };
const _hoisted_25$p = { class: "vec2" };
const _hoisted_26$n = { class: "row" };
const _hoisted_27$n = { class: "vec2" };
const _hoisted_28$m = { class: "row" };
const _hoisted_29$m = { class: "row" };
const _hoisted_30$l = { class: "prop-section" };
const _hoisted_31$j = { class: "row" };
const _hoisted_32$j = ["value"];
const _hoisted_33$j = ["value"];
const _hoisted_34$h = { class: "row" };
const _hoisted_35$g = { class: "row" };
const _hoisted_36$f = { class: "row" };
const _hoisted_37$f = { class: "row checkbox-row" };
const _hoisted_38$f = ["checked"];
const _hoisted_39$f = { class: "row checkbox-row" };
const _hoisted_40$e = ["checked"];
const _hoisted_41$c = { class: "row checkbox-row" };
const _hoisted_42$b = ["checked"];
const _hoisted_43$b = { class: "prop-section" };
const _hoisted_44$b = { class: "row" };
const _hoisted_45$b = { class: "row" };
const _hoisted_46$b = { class: "row" };
const _hoisted_47$b = { class: "row" };
const _hoisted_48$b = { class: "row text-formatting-row" };
const _hoisted_49$b = { class: "format-toggles" };
const _hoisted_50$a = { class: "row text-formatting-row" };
const _hoisted_51$a = { class: "format-toggles" };
const _hoisted_52$9 = { class: "prop-section" };
const _hoisted_53$9 = { class: "row" };
const _hoisted_54$9 = { class: "row" };
const _hoisted_55$9 = { class: "row" };
const _hoisted_56$9 = { class: "prop-section checkbox" };
const _hoisted_57$8 = ["checked"];
const _hoisted_58$8 = { class: "prop-section animators-section" };
const _hoisted_59$8 = { class: "section-header" };
const _hoisted_60$7 = { class: "animator-add-controls" };
const _hoisted_61$7 = ["value"];
const _hoisted_62$7 = {
  key: 0,
  class: "no-animators"
};
const _hoisted_63$5 = ["onClick"];
const _hoisted_64$5 = { class: "expand-icon" };
const _hoisted_65$5 = ["checked", "onClick"];
const _hoisted_66$5 = ["value", "onInput"];
const _hoisted_67$5 = { class: "animator-actions" };
const _hoisted_68$5 = ["onClick"];
const _hoisted_69$5 = ["onClick"];
const _hoisted_70$5 = {
  key: 0,
  class: "animator-content"
};
const _hoisted_71$5 = { class: "subsection" };
const _hoisted_72$5 = { class: "row" };
const _hoisted_73$5 = ["value", "onChange"];
const _hoisted_74$4 = { class: "row" };
const _hoisted_75$4 = { class: "row" };
const _hoisted_76$4 = { class: "row" };
const _hoisted_77$4 = { class: "row" };
const _hoisted_78$4 = ["value", "onChange"];
const _hoisted_79$4 = { class: "row checkbox-row" };
const _hoisted_80$4 = ["checked", "onChange"];
const _hoisted_81$4 = { class: "subsection" };
const _hoisted_82$4 = { class: "property-row" };
const _hoisted_83$4 = { class: "prop-label" };
const _hoisted_84$4 = ["checked", "onChange"];
const _hoisted_85$4 = {
  key: 0,
  class: "vec2"
};
const _hoisted_86$4 = { class: "property-row" };
const _hoisted_87$4 = { class: "prop-label" };
const _hoisted_88$4 = ["checked", "onChange"];
const _hoisted_89$4 = {
  key: 0,
  class: "vec2"
};
const _hoisted_90$4 = { class: "property-row" };
const _hoisted_91$3 = { class: "prop-label" };
const _hoisted_92$3 = ["checked", "onChange"];
const _hoisted_93$3 = { class: "property-row" };
const _hoisted_94$3 = { class: "prop-label" };
const _hoisted_95$2 = ["checked", "onChange"];
const _hoisted_96$2 = { class: "property-row" };
const _hoisted_97$2 = { class: "prop-label" };
const _hoisted_98$2 = ["checked", "onChange"];
const _hoisted_99$2 = {
  key: 0,
  class: "vec2"
};
const _hoisted_100$2 = { class: "property-row" };
const _hoisted_101$2 = { class: "prop-label" };
const _hoisted_102$2 = ["checked", "onChange"];
const _hoisted_103$1 = { class: "property-row" };
const _hoisted_104$1 = { class: "prop-label" };
const _hoisted_105$1 = ["checked", "onChange"];
const _hoisted_106$1 = ["value", "onInput"];
const _hoisted_107$1 = { class: "property-row" };
const _hoisted_108$1 = { class: "prop-label" };
const _hoisted_109$1 = ["checked", "onChange"];
const _hoisted_110$1 = ["value", "onInput"];
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const fontCategories = ref([]);
    const hasSystemFonts = ref(false);
    const loadingFonts = ref(false);
    const expandedAnimators = ref(/* @__PURE__ */ new Set());
    const selectedPreset = ref("");
    const animatorPresets = TEXT_ANIMATOR_PRESET_LIST;
    onMounted(async () => {
      await fontService.initialize();
      fontCategories.value = fontService.getFontCategories();
      hasSystemFonts.value = fontService.hasSystemFonts();
    });
    async function requestFontAccess() {
      loadingFonts.value = true;
      try {
        const success = await fontService.requestSystemFontAccess();
        if (success) {
          fontCategories.value = fontService.getFontCategories();
          hasSystemFonts.value = true;
        }
      } finally {
        loadingFonts.value = false;
      }
    }
    const textData = computed(() => props.layer.data);
    const transform = computed(() => props.layer.transform);
    const splineLayers = computed(() => store.layers.filter((l) => l.type === "spline" || l.type === "path"));
    const animators = computed(() => textData.value.animators || []);
    function toggleAnimatorExpanded(animatorId) {
      if (expandedAnimators.value.has(animatorId)) {
        expandedAnimators.value.delete(animatorId);
      } else {
        expandedAnimators.value.add(animatorId);
      }
    }
    function addAnimator(presetType) {
      const newAnimator = presetType ? applyTextAnimatorPreset(presetType, 45) : createTextAnimator(`Animator ${animators.value.length + 1}`);
      const currentAnimators = [...animators.value, newAnimator];
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.add(newAnimator.id);
      emit("update");
    }
    function removeAnimator(animatorId) {
      const currentAnimators = animators.value.filter((a) => a.id !== animatorId);
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.delete(animatorId);
      emit("update");
    }
    function duplicateAnimator(animatorId) {
      const source = animators.value.find((a) => a.id === animatorId);
      if (!source) return;
      const duplicated = structuredClone(source);
      duplicated.id = `animator_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
      duplicated.name = `${source.name} (Copy)`;
      const currentAnimators = [...animators.value, duplicated];
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.add(duplicated.id);
      emit("update");
    }
    function toggleAnimatorEnabled(animatorId) {
      const animator = animators.value.find((a) => a.id === animatorId);
      if (!animator) return;
      const currentAnimators = animators.value.map(
        (a) => a.id === animatorId ? { ...a, enabled: !a.enabled } : a
      );
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateAnimatorName(animatorId, name) {
      const currentAnimators = animators.value.map(
        (a) => a.id === animatorId ? { ...a, name } : a
      );
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateRangeSelector(animatorId, key, value) {
      const currentAnimators = animators.value.map((a) => {
        if (a.id !== animatorId) return a;
        const updated = { ...a };
        if (key === "start" || key === "end" || key === "offset") {
          updated.rangeSelector = {
            ...updated.rangeSelector,
            [key]: {
              ...updated.rangeSelector[key],
              value
            }
          };
        } else {
          updated.rangeSelector = {
            ...updated.rangeSelector,
            [key]: value
          };
        }
        return updated;
      });
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateAnimatorProperty(animatorId, propKey, value) {
      const currentAnimators = animators.value.map((a) => {
        if (a.id !== animatorId) return a;
        const updated = { ...a };
        if (value === null || value === void 0) {
          const { [propKey]: removed, ...rest } = updated.properties;
          updated.properties = rest;
        } else {
          updated.properties = {
            ...updated.properties,
            [propKey]: {
              id: `prop_${Date.now()}`,
              name: propKey.charAt(0).toUpperCase() + propKey.slice(1),
              type: typeof value === "number" ? "number" : "object",
              value,
              animated: false,
              keyframes: []
            }
          };
        }
        return updated;
      });
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function getAnimatorPropertyValue(animator, propKey) {
      return animator.properties[propKey]?.value;
    }
    function hasAnimatorProperty(animator, propKey) {
      return propKey in animator.properties;
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const p = getProperty(name);
      return p ? p.value : null;
    }
    function updateText(val) {
      store.setPropertyValue(props.layer.id, "Source Text", val);
      store.updateLayerData(props.layer.id, { text: val });
      emit("update");
    }
    function updateData(key, val) {
      store.updateLayerData(props.layer.id, { [key]: val });
      const map = {
        "fill": "Fill Color",
        "stroke": "Stroke Color",
        "fontSize": "Font Size",
        "strokeWidth": "Stroke Width"
      };
      if (map[key]) {
        store.setPropertyValue(props.layer.id, map[key], val);
      }
      emit("update");
    }
    function updateAnimatable(name, val) {
      store.setPropertyValue(props.layer.id, name, val);
      const keyMap = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        "Tracking": "tracking",
        "Line Spacing": "lineSpacing",
        "Baseline Shift": "baselineShift",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      if (keyMap[name]) {
        store.updateLayerData(props.layer.id, { [keyMap[name]]: val });
      }
      emit("update");
    }
    function isPropertyAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function toggleKeyframe(name) {
      const prop = getProperty(name);
      if (!prop) return;
      const currentFrame = store.currentFrame;
      const existingKf = prop.keyframes?.find((kf) => kf.frame === currentFrame);
      if (existingKf) {
        store.removeKeyframe(props.layer.id, name, existingKf.id);
      } else {
        store.addKeyframe(props.layer.id, name, prop.value, currentFrame);
      }
      emit("update");
    }
    function updateTransform(propName, axis, val) {
      const prop = transform.value[propName];
      let newValue;
      if (axis) {
        newValue = { ...prop.value, [axis]: val };
      } else {
        newValue = val;
      }
      store.setPropertyValue(props.layer.id, `transform.${propName}`, newValue);
      emit("update");
    }
    function updateOpacity(val) {
      store.setPropertyValue(props.layer.id, "opacity", val);
      emit("update");
    }
    function toggleBold() {
      updateData("fontWeight", textData.value.fontWeight === "bold" ? "400" : "bold");
    }
    function toggleItalic() {
      updateData("fontStyle", textData.value.fontStyle === "italic" ? "normal" : "italic");
    }
    function toggleCase(caseType) {
      updateData("textCase", caseType);
    }
    function toggleVerticalAlign(align) {
      updateData("verticalAlign", align);
    }
    async function handleFontChange(family) {
      await fontService.ensureFont(family);
      updateData("fontFamily", family);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createBaseVNode("div", _hoisted_2$P, [
          _cache[42] || (_cache[42] = createBaseVNode("div", { class: "section-title" }, "Source Text", -1)),
          createBaseVNode("textarea", {
            value: textData.value.text,
            onInput: _cache[0] || (_cache[0] = (e) => updateText(e.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, _hoisted_3$P)
        ]),
        createBaseVNode("div", _hoisted_4$P, [
          _cache[48] || (_cache[48] = createBaseVNode("div", { class: "section-title" }, "Character", -1)),
          createBaseVNode("div", _hoisted_5$P, [
            createBaseVNode("select", {
              value: textData.value.fontFamily,
              onChange: _cache[1] || (_cache[1] = (e) => handleFontChange(e.target.value)),
              class: "font-select"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(fontCategories.value, (category) => {
                return openBlock(), createElementBlock("optgroup", {
                  key: category.name,
                  label: category.name
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.fonts, (font) => {
                    return openBlock(), createElementBlock("option", {
                      key: font.family,
                      value: font.family
                    }, toDisplayString(font.family), 9, _hoisted_8$N);
                  }), 128))
                ], 8, _hoisted_7$P);
              }), 128))
            ], 40, _hoisted_6$P),
            createBaseVNode("div", _hoisted_9$N, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontWeight === "bold" }),
                onClick: toggleBold
              }, "B", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontStyle === "italic" }),
                onClick: toggleItalic
              }, "I", 2)
            ])
          ]),
          !hasSystemFonts.value ? (openBlock(), createElementBlock("div", _hoisted_10$M, [
            createBaseVNode("button", {
              class: "font-access-btn",
              onClick: requestFontAccess,
              disabled: loadingFonts.value
            }, toDisplayString(loadingFonts.value ? "Loading..." : "+ Load System Fonts"), 9, _hoisted_11$L)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$J, [
            _cache[43] || (_cache[43] = createBaseVNode("label", null, "Size", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Font Size") || textData.value.fontSize,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("Font Size", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_13$J, [
            createBaseVNode("div", _hoisted_14$F, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.fill,
                onInput: _cache[3] || (_cache[3] = (e) => updateData("fill", e.target.value))
              }, null, 40, _hoisted_15$E),
              _cache[44] || (_cache[44] = createBaseVNode("span", null, "Fill", -1))
            ]),
            createBaseVNode("div", _hoisted_16$D, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.stroke || "#000000",
                onInput: _cache[4] || (_cache[4] = (e) => updateData("stroke", e.target.value))
              }, null, 40, _hoisted_17$C),
              _cache[45] || (_cache[45] = createBaseVNode("span", null, "Stroke", -1))
            ])
          ]),
          createBaseVNode("div", _hoisted_18$A, [
            _cache[46] || (_cache[46] = createBaseVNode("label", null, "Stroke Width", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Stroke Width") || textData.value.strokeWidth || 0,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_19$z, [
            _cache[47] || (_cache[47] = createBaseVNode("label", null, "Alignment", -1)),
            createBaseVNode("div", _hoisted_20$z, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "left" }),
                onClick: _cache[6] || (_cache[6] = ($event) => updateData("textAlign", "left"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "center" }),
                onClick: _cache[7] || (_cache[7] = ($event) => updateData("textAlign", "center"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "right" }),
                onClick: _cache[8] || (_cache[8] = ($event) => updateData("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_21$x, [
          _cache[54] || (_cache[54] = createBaseVNode("div", { class: "section-title" }, "Transform", -1)),
          createBaseVNode("div", _hoisted_22$v, [
            _cache[49] || (_cache[49] = createBaseVNode("label", null, "Position", -1)),
            createBaseVNode("div", _hoisted_23$v, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.x,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateTransform("position", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.y,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateTransform("position", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_24$p, [
            _cache[50] || (_cache[50] = createBaseVNode("label", null, "Anchor Pt", -1)),
            createBaseVNode("div", _hoisted_25$p, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.x,
                "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateTransform("anchorPoint", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.y,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateTransform("anchorPoint", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_26$n, [
            _cache[51] || (_cache[51] = createBaseVNode("label", null, "Scale %", -1)),
            createBaseVNode("div", _hoisted_27$n, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.x,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateTransform("scale", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.y,
                "onUpdate:modelValue": _cache[14] || (_cache[14] = (v) => updateTransform("scale", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_28$m, [
            _cache[52] || (_cache[52] = createBaseVNode("label", null, "Rotation", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: transform.value.rotation.value,
              "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateTransform("rotation", null, v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_29$m, [
            _cache[53] || (_cache[53] = createBaseVNode("label", null, "Opacity", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: __props.layer.opacity?.value ?? 100,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updateOpacity(v)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_30$l, [
          _cache[63] || (_cache[63] = createBaseVNode("div", { class: "section-title" }, "Path Options", -1)),
          createBaseVNode("div", _hoisted_31$j, [
            _cache[56] || (_cache[56] = createBaseVNode("label", null, "Path", -1)),
            createBaseVNode("select", {
              value: textData.value.pathLayerId || "",
              onChange: _cache[17] || (_cache[17] = (e) => updateData("pathLayerId", e.target.value || null)),
              class: "full-select"
            }, [
              _cache[55] || (_cache[55] = createBaseVNode("option", { value: "" }, "None", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (l) => {
                return openBlock(), createElementBlock("option", {
                  key: l.id,
                  value: l.id
                }, toDisplayString(l.type === "path" ? " " : " ") + toDisplayString(l.name), 9, _hoisted_33$j);
              }), 128))
            ], 40, _hoisted_32$j)
          ]),
          textData.value.pathLayerId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_34$h, [
              _cache[57] || (_cache[57] = createBaseVNode("label", null, "Path Offset %", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Offset") ?? textData.value.pathOffset ?? 0,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Path Offset", v)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isPropertyAnimated("Path Offset") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_35$g, [
              _cache[58] || (_cache[58] = createBaseVNode("label", null, "First Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("First Margin") ?? textData.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateAnimatable("First Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_36$f, [
              _cache[59] || (_cache[59] = createBaseVNode("label", null, "Last Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Last Margin") ?? textData.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Last Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$f, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathReversed,
                  onChange: _cache[22] || (_cache[22] = ($event) => updateData("pathReversed", !textData.value.pathReversed))
                }, null, 40, _hoisted_38$f),
                _cache[60] || (_cache[60] = createTextVNode(" Reverse Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_39$f, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathPerpendicularToPath ?? true,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateData("pathPerpendicularToPath", !textData.value.pathPerpendicularToPath))
                }, null, 40, _hoisted_40$e),
                _cache[61] || (_cache[61] = createTextVNode(" Perpendicular to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_41$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathForceAlignment,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateData("pathForceAlignment", !textData.value.pathForceAlignment))
                }, null, 40, _hoisted_42$b),
                _cache[62] || (_cache[62] = createTextVNode(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_43$b, [
          _cache[70] || (_cache[70] = createBaseVNode("div", { class: "section-title" }, "Advanced", -1)),
          createBaseVNode("div", _hoisted_44$b, [
            _cache[64] || (_cache[64] = createBaseVNode("label", null, "Tracking", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Tracking") || textData.value.tracking || 0,
              "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Tracking", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_45$b, [
            _cache[65] || (_cache[65] = createBaseVNode("label", null, "Line Spacing", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Line Spacing") || textData.value.lineSpacing || 0,
              "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateAnimatable("Line Spacing", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_46$b, [
            _cache[66] || (_cache[66] = createBaseVNode("label", null, "Baseline", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Baseline Shift") || textData.value.baselineShift || 0,
              "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateAnimatable("Baseline Shift", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_47$b, [
            _cache[67] || (_cache[67] = createBaseVNode("label", null, "Char Offset", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Character Offset") || textData.value.characterOffset || 0,
              "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateAnimatable("Character Offset", v)),
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_48$b, [
            _cache[68] || (_cache[68] = createBaseVNode("label", null, "Case", -1)),
            createBaseVNode("div", _hoisted_49$b, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "uppercase" }),
                onClick: _cache[29] || (_cache[29] = ($event) => toggleCase("uppercase")),
                title: "All Caps"
              }, "AA", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "smallcaps" }),
                onClick: _cache[30] || (_cache[30] = ($event) => toggleCase("smallcaps")),
                title: "Small Caps"
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "normal" || !textData.value.textCase }),
                onClick: _cache[31] || (_cache[31] = ($event) => toggleCase("normal")),
                title: "Normal"
              }, "Aa", 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_50$a, [
            _cache[69] || (_cache[69] = createBaseVNode("label", null, "Script", -1)),
            createBaseVNode("div", _hoisted_51$a, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "super" }),
                onClick: _cache[32] || (_cache[32] = ($event) => toggleVerticalAlign("super")),
                title: "Superscript"
              }, "X", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "sub" }),
                onClick: _cache[33] || (_cache[33] = ($event) => toggleVerticalAlign("sub")),
                title: "Subscript"
              }, "X", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "baseline" || !textData.value.verticalAlign }),
                onClick: _cache[34] || (_cache[34] = ($event) => toggleVerticalAlign("baseline")),
                title: "Normal"
              }, "X", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_52$9, [
          _cache[74] || (_cache[74] = createBaseVNode("div", { class: "section-title" }, "Paragraph", -1)),
          createBaseVNode("div", _hoisted_53$9, [
            _cache[71] || (_cache[71] = createBaseVNode("label", null, "First Line Indent", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: textData.value.firstLineIndent || 0,
              "onUpdate:modelValue": _cache[35] || (_cache[35] = (v) => updateData("firstLineIndent", v)),
              min: -500,
              max: 500
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_54$9, [
            _cache[72] || (_cache[72] = createBaseVNode("label", null, "Space Before", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: textData.value.spaceBefore || 0,
              "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateData("spaceBefore", v)),
              min: 0,
              max: 500
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_55$9, [
            _cache[73] || (_cache[73] = createBaseVNode("label", null, "Space After", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: textData.value.spaceAfter || 0,
              "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateData("spaceAfter", v)),
              min: 0,
              max: 500
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_56$9, [
          createBaseVNode("label", null, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: textData.value.perCharacter3D,
              onChange: _cache[38] || (_cache[38] = ($event) => updateData("perCharacter3D", !textData.value.perCharacter3D))
            }, null, 40, _hoisted_57$8),
            _cache[75] || (_cache[75] = createTextVNode(" Enable Per-Character 3D ", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_58$8, [
          createBaseVNode("div", _hoisted_59$8, [
            _cache[77] || (_cache[77] = createBaseVNode("div", { class: "section-title" }, "Animators", -1)),
            createBaseVNode("div", _hoisted_60$7, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[39] || (_cache[39] = ($event) => selectedPreset.value = $event),
                class: "preset-select"
              }, [
                _cache[76] || (_cache[76] = createBaseVNode("option", { value: "" }, "Add Preset...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(animatorPresets), (preset) => {
                  return openBlock(), createElementBlock("option", {
                    key: preset.type,
                    value: preset.type
                  }, toDisplayString(preset.name), 9, _hoisted_61$7);
                }), 128))
              ], 512), [
                [vModelSelect, selectedPreset.value]
              ]),
              createBaseVNode("button", {
                class: "add-btn",
                onClick: _cache[40] || (_cache[40] = ($event) => {
                  addAnimator(selectedPreset.value || void 0);
                  selectedPreset.value = "";
                }),
                title: "Add Animator"
              }, "+")
            ])
          ]),
          animators.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_62$7, " No animators. Add one to animate text per-character. ")) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(animators.value, (animator) => {
            return openBlock(), createElementBlock("div", {
              key: animator.id,
              class: "animator-item"
            }, [
              createBaseVNode("div", {
                class: "animator-header",
                onClick: ($event) => toggleAnimatorExpanded(animator.id)
              }, [
                createBaseVNode("span", _hoisted_64$5, toDisplayString(expandedAnimators.value.has(animator.id) ? "" : ""), 1),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: animator.enabled,
                  onClick: withModifiers(($event) => toggleAnimatorEnabled(animator.id), ["stop"]),
                  class: "animator-enabled"
                }, null, 8, _hoisted_65$5),
                createBaseVNode("input", {
                  type: "text",
                  value: animator.name,
                  onInput: (e) => updateAnimatorName(animator.id, e.target.value),
                  onClick: _cache[41] || (_cache[41] = withModifiers(() => {
                  }, ["stop"])),
                  class: "animator-name"
                }, null, 40, _hoisted_66$5),
                createBaseVNode("div", _hoisted_67$5, [
                  createBaseVNode("button", {
                    onClick: withModifiers(($event) => duplicateAnimator(animator.id), ["stop"]),
                    title: "Duplicate"
                  }, "", 8, _hoisted_68$5),
                  createBaseVNode("button", {
                    onClick: withModifiers(($event) => removeAnimator(animator.id), ["stop"]),
                    title: "Remove"
                  }, "", 8, _hoisted_69$5)
                ])
              ], 8, _hoisted_63$5),
              expandedAnimators.value.has(animator.id) ? (openBlock(), createElementBlock("div", _hoisted_70$5, [
                createBaseVNode("div", _hoisted_71$5, [
                  _cache[86] || (_cache[86] = createBaseVNode("div", { class: "subsection-title" }, "Range Selector", -1)),
                  createBaseVNode("div", _hoisted_72$5, [
                    _cache[79] || (_cache[79] = createBaseVNode("label", null, "Based On", -1)),
                    createBaseVNode("select", {
                      value: animator.rangeSelector.basedOn,
                      onChange: (e) => updateRangeSelector(animator.id, "basedOn", e.target.value),
                      class: "full-select"
                    }, [..._cache[78] || (_cache[78] = [
                      createBaseVNode("option", { value: "characters" }, "Characters", -1),
                      createBaseVNode("option", { value: "words" }, "Words", -1),
                      createBaseVNode("option", { value: "lines" }, "Lines", -1)
                    ])], 40, _hoisted_73$5)
                  ]),
                  createBaseVNode("div", _hoisted_74$4, [
                    _cache[80] || (_cache[80] = createBaseVNode("label", null, "Start %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.start.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "start", v),
                      min: 0,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_75$4, [
                    _cache[81] || (_cache[81] = createBaseVNode("label", null, "End %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.end.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "end", v),
                      min: 0,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_76$4, [
                    _cache[82] || (_cache[82] = createBaseVNode("label", null, "Offset %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.offset.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "offset", v),
                      min: -100,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_77$4, [
                    _cache[84] || (_cache[84] = createBaseVNode("label", null, "Shape", -1)),
                    createBaseVNode("select", {
                      value: animator.rangeSelector.shape,
                      onChange: (e) => updateRangeSelector(animator.id, "shape", e.target.value),
                      class: "full-select"
                    }, [..._cache[83] || (_cache[83] = [
                      createStaticVNode('<option value="square" data-v-99bd2cb8>Square</option><option value="ramp_up" data-v-99bd2cb8>Ramp Up</option><option value="ramp_down" data-v-99bd2cb8>Ramp Down</option><option value="triangle" data-v-99bd2cb8>Triangle</option><option value="round" data-v-99bd2cb8>Round</option><option value="smooth" data-v-99bd2cb8>Smooth</option>', 6)
                    ])], 40, _hoisted_78$4)
                  ]),
                  createBaseVNode("div", _hoisted_79$4, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: animator.rangeSelector.randomizeOrder,
                        onChange: ($event) => updateRangeSelector(animator.id, "randomizeOrder", !animator.rangeSelector.randomizeOrder)
                      }, null, 40, _hoisted_80$4),
                      _cache[85] || (_cache[85] = createTextVNode(" Randomize Order ", -1))
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_81$4, [
                  _cache[95] || (_cache[95] = createBaseVNode("div", { class: "subsection-title" }, "Properties", -1)),
                  createBaseVNode("div", _hoisted_82$4, [
                    createBaseVNode("label", _hoisted_83$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "position"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "position", hasAnimatorProperty(animator, "position") ? null : { x: 0, y: 0 })
                      }, null, 40, _hoisted_84$4),
                      _cache[87] || (_cache[87] = createTextVNode(" Position ", -1))
                    ]),
                    hasAnimatorProperty(animator, "position") ? (openBlock(), createElementBlock("div", _hoisted_85$4, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "position")?.x ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "position", { ...getAnimatorPropertyValue(animator, "position"), x: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "position")?.y ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "position", { ...getAnimatorPropertyValue(animator, "position"), y: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_86$4, [
                    createBaseVNode("label", _hoisted_87$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "scale"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "scale", hasAnimatorProperty(animator, "scale") ? null : { x: 100, y: 100 })
                      }, null, 40, _hoisted_88$4),
                      _cache[88] || (_cache[88] = createTextVNode(" Scale % ", -1))
                    ]),
                    hasAnimatorProperty(animator, "scale") ? (openBlock(), createElementBlock("div", _hoisted_89$4, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "scale")?.x ?? 100,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "scale", { ...getAnimatorPropertyValue(animator, "scale"), x: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "scale")?.y ?? 100,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "scale", { ...getAnimatorPropertyValue(animator, "scale"), y: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_90$4, [
                    createBaseVNode("label", _hoisted_91$3, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "rotation"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "rotation", hasAnimatorProperty(animator, "rotation") ? null : 0)
                      }, null, 40, _hoisted_92$3),
                      _cache[89] || (_cache[89] = createTextVNode(" Rotation ", -1))
                    ]),
                    hasAnimatorProperty(animator, "rotation") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "rotation") ?? 0,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "rotation", v),
                      min: -360,
                      max: 360
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_93$3, [
                    createBaseVNode("label", _hoisted_94$3, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "opacity"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "opacity", hasAnimatorProperty(animator, "opacity") ? null : 100)
                      }, null, 40, _hoisted_95$2),
                      _cache[90] || (_cache[90] = createTextVNode(" Opacity ", -1))
                    ]),
                    hasAnimatorProperty(animator, "opacity") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "opacity") ?? 100,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "opacity", v),
                      min: 0,
                      max: 100
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_96$2, [
                    createBaseVNode("label", _hoisted_97$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "blur"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "blur", hasAnimatorProperty(animator, "blur") ? null : { x: 0, y: 0 })
                      }, null, 40, _hoisted_98$2),
                      _cache[91] || (_cache[91] = createTextVNode(" Blur ", -1))
                    ]),
                    hasAnimatorProperty(animator, "blur") ? (openBlock(), createElementBlock("div", _hoisted_99$2, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "blur")?.x ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "blur", { ...getAnimatorPropertyValue(animator, "blur"), x: v }),
                        min: 0,
                        max: 100
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "blur")?.y ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "blur", { ...getAnimatorPropertyValue(animator, "blur"), y: v }),
                        min: 0,
                        max: 100
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_100$2, [
                    createBaseVNode("label", _hoisted_101$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "tracking"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "tracking", hasAnimatorProperty(animator, "tracking") ? null : 0)
                      }, null, 40, _hoisted_102$2),
                      _cache[92] || (_cache[92] = createTextVNode(" Tracking ", -1))
                    ]),
                    hasAnimatorProperty(animator, "tracking") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "tracking") ?? 0,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "tracking", v),
                      min: -200,
                      max: 200
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_103$1, [
                    createBaseVNode("label", _hoisted_104$1, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "fillColor"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "fillColor", hasAnimatorProperty(animator, "fillColor") ? null : "#ffffff")
                      }, null, 40, _hoisted_105$1),
                      _cache[93] || (_cache[93] = createTextVNode(" Fill Color ", -1))
                    ]),
                    hasAnimatorProperty(animator, "fillColor") ? (openBlock(), createElementBlock("input", {
                      key: 0,
                      type: "color",
                      value: getAnimatorPropertyValue(animator, "fillColor") || "#ffffff",
                      onInput: (e) => updateAnimatorProperty(animator.id, "fillColor", e.target.value),
                      class: "color-input"
                    }, null, 40, _hoisted_106$1)) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_107$1, [
                    createBaseVNode("label", _hoisted_108$1, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "strokeColor"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "strokeColor", hasAnimatorProperty(animator, "strokeColor") ? null : "#000000")
                      }, null, 40, _hoisted_109$1),
                      _cache[94] || (_cache[94] = createTextVNode(" Stroke Color ", -1))
                    ]),
                    hasAnimatorProperty(animator, "strokeColor") ? (openBlock(), createElementBlock("input", {
                      key: 0,
                      type: "color",
                      value: getAnimatorPropertyValue(animator, "strokeColor") || "#000000",
                      onInput: (e) => updateAnimatorProperty(animator.id, "strokeColor", e.target.value),
                      class: "color-input"
                    }, null, 40, _hoisted_110$1)) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]);
          }), 128))
        ])
      ]);
    };
  }
});

const TextProperties = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["__scopeId", "data-v-99bd2cb8"]]);

const BUILT_IN_PARTICLE_PRESETS = [
  {
    id: "builtin-particle-fire",
    name: "Fire",
    category: "particle",
    description: "Flickering flame effect",
    tags: ["fire", "flame", "hot"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 500,
      emissionRate: 50,
      lifespan: 1.5,
      startSize: 20,
      endSize: 5,
      startColor: "#ff6600",
      endColor: "#ffff00",
      gravity: -50,
      turbulenceStrength: 30,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-snow",
    name: "Snow",
    category: "particle",
    description: "Gentle falling snowflakes",
    tags: ["snow", "winter", "cold"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 20,
      lifespan: 5,
      startSize: 8,
      endSize: 6,
      startColor: "#ffffff",
      endColor: "#ccccff",
      gravity: 20,
      turbulenceStrength: 10,
      velocitySpread: 20
    }
  },
  {
    id: "builtin-particle-sparks",
    name: "Sparks",
    category: "particle",
    description: "Electric spark burst",
    tags: ["sparks", "electric", "energy"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 100,
      lifespan: 0.5,
      startSize: 4,
      endSize: 1,
      startColor: "#ffff00",
      endColor: "#ff8800",
      gravity: 100,
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-smoke",
    name: "Smoke",
    category: "particle",
    description: "Rising smoke plume",
    tags: ["smoke", "fog", "mist"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 100,
      emissionRate: 10,
      lifespan: 4,
      startSize: 30,
      endSize: 80,
      startColor: "#444444",
      endColor: "#888888",
      gravity: -30,
      turbulenceStrength: 20
    }
  },
  {
    id: "builtin-particle-confetti",
    name: "Confetti",
    category: "particle",
    description: "Colorful celebration confetti",
    tags: ["confetti", "celebration", "party"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 500,
      emissionRate: 100,
      lifespan: 3,
      startSize: 10,
      endSize: 8,
      gravity: 50,
      velocitySpread: 60,
      turbulenceStrength: 15
    }
  },
  {
    id: "builtin-particle-rain",
    name: "Rain",
    category: "particle",
    description: "Falling rain drops",
    tags: ["rain", "weather", "water"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 1e3,
      emissionRate: 200,
      lifespan: 1.5,
      startSize: 3,
      endSize: 2,
      startColor: "#88bbff",
      endColor: "#6699cc",
      gravity: 400,
      velocitySpread: 5
    }
  },
  {
    id: "builtin-particle-dust",
    name: "Dust",
    category: "particle",
    description: "Floating dust motes",
    tags: ["dust", "ambient", "atmosphere"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 5,
      lifespan: 8,
      startSize: 2,
      endSize: 1,
      startColor: "#ccccbb",
      endColor: "#888877",
      gravity: -2,
      turbulenceStrength: 5,
      velocitySpread: 360
    }
  },
  {
    id: "builtin-particle-magic",
    name: "Magic Sparkle",
    category: "particle",
    description: "Magical glowing particles",
    tags: ["magic", "sparkle", "glow", "fantasy"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 30,
      lifespan: 2,
      startSize: 8,
      endSize: 2,
      startColor: "#ff88ff",
      endColor: "#8844ff",
      gravity: -20,
      turbulenceStrength: 25,
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-bubbles",
    name: "Bubbles",
    category: "particle",
    description: "Rising soap bubbles",
    tags: ["bubbles", "water", "soap"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 100,
      emissionRate: 8,
      lifespan: 4,
      startSize: 15,
      endSize: 25,
      startColor: "#aaddff",
      endColor: "#ffffff",
      gravity: -30,
      turbulenceStrength: 15,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-leaves",
    name: "Falling Leaves",
    category: "particle",
    description: "Autumn leaves floating down",
    tags: ["leaves", "autumn", "nature", "fall"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 150,
      emissionRate: 10,
      lifespan: 5,
      startSize: 12,
      endSize: 10,
      startColor: "#dd8833",
      endColor: "#884422",
      gravity: 25,
      turbulenceStrength: 40,
      velocitySpread: 45
    }
  },
  {
    id: "builtin-particle-stars",
    name: "Twinkling Stars",
    category: "particle",
    description: "Starfield with twinkling effect",
    tags: ["stars", "night", "space", "twinkle"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 15,
      lifespan: 3,
      startSize: 4,
      endSize: 1,
      startColor: "#ffffff",
      endColor: "#ffffcc",
      gravity: 0,
      turbulenceStrength: 2,
      velocitySpread: 360
    }
  },
  {
    id: "builtin-particle-fireworks",
    name: "Fireworks",
    category: "particle",
    description: "Explosive firework burst",
    tags: ["fireworks", "explosion", "celebration"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 500,
      emissionRate: 200,
      lifespan: 1.5,
      startSize: 6,
      endSize: 2,
      startColor: "#ffff00",
      endColor: "#ff4400",
      gravity: 100,
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-aurora",
    name: "Aurora",
    category: "particle",
    description: "Northern lights effect",
    tags: ["aurora", "northern lights", "glow"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 20,
      lifespan: 4,
      startSize: 30,
      endSize: 50,
      startColor: "#00ff88",
      endColor: "#8844ff",
      gravity: -5,
      turbulenceStrength: 30,
      velocitySpread: 20
    }
  },
  {
    id: "builtin-particle-embers",
    name: "Embers",
    category: "particle",
    description: "Glowing fire embers",
    tags: ["embers", "fire", "glow", "heat"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 150,
      emissionRate: 25,
      lifespan: 3,
      startSize: 4,
      endSize: 1,
      startColor: "#ff6622",
      endColor: "#441100",
      gravity: -40,
      turbulenceStrength: 20,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-fog",
    name: "Dense Fog",
    category: "particle",
    description: "Thick rolling fog",
    tags: ["fog", "mist", "atmosphere", "weather"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 50,
      emissionRate: 3,
      lifespan: 10,
      startSize: 100,
      endSize: 200,
      startColor: "#888888",
      endColor: "#666666",
      gravity: 0,
      turbulenceStrength: 10,
      velocitySpread: 20
    }
  },
  {
    id: "builtin-particle-explosion",
    name: "Explosion",
    category: "particle",
    description: "Violent debris explosion",
    tags: ["explosion", "debris", "blast"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 500,
      lifespan: 0.8,
      startSize: 10,
      endSize: 3,
      startColor: "#ffaa00",
      endColor: "#331100",
      gravity: 150,
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-portal",
    name: "Portal Swirl",
    category: "particle",
    description: "Magical portal vortex",
    tags: ["portal", "vortex", "magic", "swirl"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 400,
      emissionRate: 60,
      lifespan: 2,
      startSize: 6,
      endSize: 2,
      startColor: "#00ddff",
      endColor: "#4400ff",
      gravity: 0,
      turbulenceStrength: 15,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-electricity",
    name: "Electricity",
    category: "particle",
    description: "Electric arcs and sparks",
    tags: ["electricity", "lightning", "energy"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 150,
      lifespan: 0.3,
      startSize: 3,
      endSize: 1,
      startColor: "#aaeeff",
      endColor: "#ffffff",
      gravity: 0,
      turbulenceStrength: 50,
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-hearts",
    name: "Hearts",
    category: "particle",
    description: "Floating heart particles",
    tags: ["hearts", "love", "romance", "valentine"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 100,
      emissionRate: 15,
      lifespan: 3,
      startSize: 15,
      endSize: 8,
      startColor: "#ff4466",
      endColor: "#ff88aa",
      gravity: -25,
      turbulenceStrength: 10,
      velocitySpread: 60
    }
  },
  {
    id: "builtin-particle-waterfall",
    name: "Waterfall",
    category: "particle",
    description: "Cascading water effect",
    tags: ["water", "waterfall", "cascade", "splash"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 600,
      emissionRate: 150,
      lifespan: 1.2,
      startSize: 5,
      endSize: 8,
      startColor: "#aaddff",
      endColor: "#ffffff",
      gravity: 300,
      turbulenceStrength: 10,
      velocitySpread: 15
    }
  },
  {
    id: "builtin-particle-fireflies",
    name: "Fireflies",
    category: "particle",
    description: "Gently glowing fireflies",
    tags: ["fireflies", "glow", "nature", "night"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 50,
      emissionRate: 3,
      lifespan: 6,
      startSize: 5,
      endSize: 3,
      startColor: "#ccff66",
      endColor: "#669933",
      gravity: -5,
      turbulenceStrength: 20,
      velocitySpread: 360
    }
  },
  {
    id: "builtin-particle-sandstorm",
    name: "Sandstorm",
    category: "particle",
    description: "Blowing desert sand",
    tags: ["sand", "desert", "storm", "wind"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 800,
      emissionRate: 200,
      lifespan: 2,
      startSize: 3,
      endSize: 2,
      startColor: "#cc9966",
      endColor: "#886644",
      gravity: 20,
      turbulenceStrength: 60,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-glitter",
    name: "Glitter",
    category: "particle",
    description: "Shimmering glitter particles",
    tags: ["glitter", "sparkle", "shine"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 400,
      emissionRate: 80,
      lifespan: 1.5,
      startSize: 3,
      endSize: 1,
      startColor: "#ffffff",
      endColor: "#ffdd88",
      gravity: 30,
      turbulenceStrength: 8,
      velocitySpread: 120
    }
  },
  {
    id: "builtin-particle-path-light",
    name: "Path Light",
    category: "particle",
    description: "Glowing lights that follow spline edges - perfect for logo edge tracing",
    tags: ["path", "light", "glow", "edge", "trace", "logo", "outline", "neon"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 40,
      // Moderate emission for smooth coverage
      lifespan: 2.5,
      // Long enough to traverse logo edges
      startSize: 6,
      // Visible glow point
      endSize: 2,
      // Fade out smaller
      startColor: "#ffffff",
      // Bright white core
      endColor: "#00ffff",
      // Cyan glow tail
      gravity: 0,
      // No gravity - follow path only
      turbulenceStrength: 3,
      // Minimal turbulence for clean edge following
      velocitySpread: 15
      // Tight spread along path tangent
    }
  },
  {
    id: "builtin-particle-path-light-warm",
    name: "Path Light (Warm)",
    category: "particle",
    description: "Warm glowing lights for edge tracing - gold/amber variant",
    tags: ["path", "light", "glow", "edge", "warm", "gold", "amber"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 40,
      lifespan: 2.5,
      startSize: 6,
      endSize: 2,
      startColor: "#ffffff",
      endColor: "#ffaa00",
      // Amber/gold glow
      gravity: 0,
      turbulenceStrength: 3,
      velocitySpread: 15
    }
  },
  {
    id: "builtin-particle-path-light-neon",
    name: "Path Light (Neon)",
    category: "particle",
    description: "Intense neon lights for edge tracing - magenta/pink variant",
    tags: ["path", "light", "glow", "edge", "neon", "pink", "magenta"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 60,
      // Higher emission for intense neon look
      lifespan: 1.8,
      startSize: 8,
      // Larger for neon glow
      endSize: 3,
      startColor: "#ff88ff",
      // Pink core
      endColor: "#ff00ff",
      // Magenta trail
      gravity: 0,
      turbulenceStrength: 5,
      velocitySpread: 20
    }
  },
  {
    id: "builtin-particle-path-comet",
    name: "Path Comet",
    category: "particle",
    description: "Comet-like particles with long trails - great for motion paths",
    tags: ["path", "comet", "trail", "motion", "streak"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 50,
      emissionRate: 10,
      // Sparse for distinct comets
      lifespan: 3,
      // Long life for visible trails
      startSize: 10,
      endSize: 1,
      // Sharp tail falloff
      startColor: "#ffffff",
      endColor: "#0066ff",
      // Blue trail
      gravity: 0,
      turbulenceStrength: 0,
      // No turbulence - pure path following
      velocitySpread: 5
      // Very tight to path
    }
  }
];
const BUILT_IN_PATH_EFFECT_PRESETS = [
  {
    id: "builtin-path-sketch",
    name: "Sketchy",
    category: "path-effect",
    description: "Hand-drawn sketch effect",
    tags: ["sketch", "hand-drawn", "rough"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    effects: [
      {
        id: "roughen-1",
        type: "roughen",
        enabled: true,
        order: 0,
        size: { id: "r-size", name: "Size", type: "number", value: 3, animated: false, keyframes: [] },
        detail: { id: "r-detail", name: "Detail", type: "number", value: 4, animated: false, keyframes: [] },
        seed: 12345
      }
    ]
  },
  {
    id: "builtin-path-wavy",
    name: "Wavy",
    category: "path-effect",
    description: "Smooth wave deformation",
    tags: ["wave", "smooth", "organic"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    effects: [
      {
        id: "wave-1",
        type: "wave",
        enabled: true,
        order: 0,
        amplitude: { id: "w-amp", name: "Amplitude", type: "number", value: 10, animated: false, keyframes: [] },
        frequency: { id: "w-freq", name: "Frequency", type: "number", value: 3, animated: false, keyframes: [] },
        phase: { id: "w-phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
        waveType: "sine"
      }
    ]
  }
];

const STORAGE_KEY = "weyl-presets";
const PRESET_VERSION = 1;
const usePresetStore = defineStore("presets", {
  state: () => ({
    presets: [],
    loaded: false
  }),
  getters: {
    /**
     * Get all presets including built-ins
     */
    allPresets() {
      return [
        ...BUILT_IN_PARTICLE_PRESETS,
        ...BUILT_IN_PATH_EFFECT_PRESETS,
        ...this.presets
      ];
    },
    /**
     * Get presets by category
     */
    byCategory() {
      return (category) => this.allPresets.filter((p) => p.category === category);
    },
    /**
     * Get particle presets
     */
    particlePresets() {
      return this.allPresets.filter((p) => p.category === "particle");
    },
    /**
     * Get path effect presets
     */
    pathEffectPresets() {
      return this.allPresets.filter((p) => p.category === "path-effect");
    },
    /**
     * Get camera shake presets
     */
    cameraShakePresets() {
      return this.allPresets.filter((p) => p.category === "camera-shake");
    },
    /**
     * Get camera trajectory presets
     */
    cameraTrajectoryPresets() {
      return this.allPresets.filter((p) => p.category === "camera-trajectory");
    },
    /**
     * Get text style presets
     */
    textStylePresets() {
      return this.allPresets.filter((p) => p.category === "text-style");
    },
    /**
     * Get animation presets
     */
    animationPresets() {
      return this.allPresets.filter((p) => p.category === "animation");
    },
    /**
     * Search presets by name or tags
     */
    search() {
      return (query, category) => {
        const q = query.toLowerCase();
        let results = this.allPresets;
        if (category) {
          results = results.filter((p) => p.category === category);
        }
        return results.filter(
          (p) => p.name.toLowerCase().includes(q) || p.description?.toLowerCase().includes(q) || p.tags?.some((t) => t.toLowerCase().includes(q))
        );
      };
    },
    /**
     * Get user-created presets (excludes built-ins)
     */
    userPresets() {
      return this.presets.filter((p) => !p.isBuiltIn);
    }
  },
  actions: {
    /**
     * Initialize the preset store from localStorage
     */
    initialize() {
      if (this.loaded) return;
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const data = JSON.parse(stored);
          this.presets = data.presets || [];
        }
      } catch (error) {
        console.warn("Failed to load presets from localStorage:", error);
        this.presets = [];
      }
      this.loaded = true;
    },
    /**
     * Save presets to localStorage
     */
    persist() {
      try {
        const collection = {
          version: PRESET_VERSION,
          presets: this.presets.filter((p) => !p.isBuiltIn),
          exportedAt: Date.now()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(collection));
      } catch (error) {
        console.error("Failed to save presets to localStorage:", error);
      }
    },
    /**
     * Generate a unique preset ID
     */
    generateId() {
      return `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },
    /**
     * Add a new preset
     */
    addPreset(preset) {
      const id = this.generateId();
      const now = Date.now();
      const newPreset = {
        ...preset,
        id,
        createdAt: now,
        updatedAt: now
      };
      this.presets.push(newPreset);
      this.persist();
      return id;
    },
    /**
     * Update an existing preset
     */
    updatePreset(id, updates) {
      const index = this.presets.findIndex((p) => p.id === id);
      if (index === -1) return false;
      if (this.presets[index].isBuiltIn) return false;
      this.presets[index] = {
        ...this.presets[index],
        ...updates,
        updatedAt: Date.now()
      };
      this.persist();
      return true;
    },
    /**
     * Delete a preset
     */
    deletePreset(id) {
      const index = this.presets.findIndex((p) => p.id === id);
      if (index === -1) return false;
      if (this.presets[index].isBuiltIn) return false;
      this.presets.splice(index, 1);
      this.persist();
      return true;
    },
    /**
     * Duplicate a preset
     */
    duplicatePreset(id) {
      const preset = this.allPresets.find((p) => p.id === id);
      if (!preset) return null;
      const duplicated = {
        ...preset,
        name: `${preset.name} (Copy)`,
        isBuiltIn: false
      };
      delete duplicated.id;
      delete duplicated.createdAt;
      delete duplicated.updatedAt;
      return this.addPreset(duplicated);
    },
    /**
     * Get a preset by ID
     */
    getPreset(id) {
      return this.allPresets.find((p) => p.id === id);
    },
    /**
     * Export presets to JSON string
     */
    exportPresets(presetIds) {
      const presetsToExport = presetIds ? this.allPresets.filter((p) => presetIds.includes(p.id)) : this.userPresets;
      const collection = {
        version: PRESET_VERSION,
        presets: presetsToExport,
        exportedAt: Date.now()
      };
      return JSON.stringify(collection, null, 2);
    },
    /**
     * Import presets from JSON string
     */
    importPresets(jsonString) {
      const errors = [];
      let imported = 0;
      try {
        const collection = JSON.parse(jsonString);
        if (!collection.presets || !Array.isArray(collection.presets)) {
          errors.push("Invalid preset collection format");
          return { imported, errors };
        }
        for (const preset of collection.presets) {
          try {
            if (!preset.name || !preset.category) {
              errors.push(`Skipped preset: missing name or category`);
              continue;
            }
            const existing = this.presets.find(
              (p) => p.name === preset.name && p.category === preset.category
            );
            if (existing) {
              this.updatePreset(existing.id, preset);
            } else {
              const { id, createdAt, updatedAt, ...presetData } = preset;
              this.addPreset(presetData);
            }
            imported++;
          } catch (err) {
            errors.push(`Failed to import preset "${preset.name}": ${err}`);
          }
        }
      } catch (err) {
        errors.push(`Failed to parse JSON: ${err}`);
      }
      return { imported, errors };
    },
    /**
     * Save current particle config as a preset
     */
    saveParticlePreset(name, config, options) {
      return this.addPreset({
        name,
        category: "particle",
        config,
        ...options
      });
    },
    /**
     * Save path effects as a preset
     */
    savePathEffectPreset(name, effects, options) {
      return this.addPreset({
        name,
        category: "path-effect",
        effects,
        ...options
      });
    },
    /**
     * Save camera shake config as a preset
     */
    saveCameraShakePreset(name, config, options) {
      return this.addPreset({
        name,
        category: "camera-shake",
        config,
        ...options
      });
    },
    /**
     * Save camera trajectory config as a preset
     */
    saveCameraTrajectoryPreset(name, config, options) {
      return this.addPreset({
        name,
        category: "camera-trajectory",
        config,
        ...options
      });
    },
    /**
     * Save text style as a preset
     */
    saveTextStylePreset(name, style, options) {
      return this.addPreset({
        name,
        category: "text-style",
        style,
        ...options
      });
    },
    /**
     * Clear all user presets
     */
    clearUserPresets() {
      this.presets = this.presets.filter((p) => p.isBuiltIn);
      this.persist();
    }
  }
});

const PARTICLE_UPDATE_SHADER = (
  /* wgsl */
  `
// Uniform buffer for simulation config
struct SimConfig {
  gravity: f32,
  windX: f32,
  windY: f32,
  friction: f32,
  deltaTime: f32,
  particleCount: u32,
  gravityWellCount: u32,
  vortexCount: u32,
}

// Gravity well data
struct GravityWell {
  x: f32,
  y: f32,
  radius: f32,
  strength: f32,
  falloff: f32,
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

// Vortex data
struct Vortex {
  x: f32,
  y: f32,
  radius: f32,
  strength: f32,
  inwardPull: f32,
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

@group(0) @binding(0) var<uniform> config: SimConfig;
@group(0) @binding(1) var<storage, read_write> positions: array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> velocities: array<vec4<f32>>;
@group(0) @binding(3) var<storage, read_write> properties: array<vec4<f32>>;
@group(0) @binding(4) var<storage, read> gravityWells: array<GravityWell>;
@group(0) @binding(5) var<storage, read> vortices: array<Vortex>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let idx = global_id.x;
  if (idx >= config.particleCount) {
    return;
  }

  // Load particle data
  var pos = positions[idx];
  var vel = velocities[idx];
  var props = properties[idx];

  let x = pos.x;
  let y = pos.y;
  var vx = vel.x;
  var vy = vel.y;
  let age = props.x;
  let lifetime = props.y;

  // Skip dead particles
  if (age > lifetime) {
    return;
  }

  // Store previous position
  pos.z = x;
  pos.w = y;

  // Apply gravity
  vy += config.gravity * 0.001 * config.deltaTime;

  // Apply wind
  vx += config.windX * config.deltaTime;
  vy += config.windY * config.deltaTime;

  // Apply gravity wells
  for (var i = 0u; i < config.gravityWellCount; i++) {
    let well = gravityWells[i];
    let dx = well.x - x;
    let dy = well.y - y;
    let dist = sqrt(dx * dx + dy * dy);

    if (dist < well.radius && dist > 0.001) {
      var force = well.strength * 0.0001;

      // Apply falloff
      if (well.falloff == 1.0) {
        // Linear
        force *= 1.0 - (dist / well.radius);
      } else if (well.falloff == 2.0) {
        // Quadratic
        let t = 1.0 - (dist / well.radius);
        force *= t * t;
      }
      // falloff == 0.0 is constant (no modification)

      // Normalize and apply
      let nx = dx / dist;
      let ny = dy / dist;
      vx += nx * force * config.deltaTime;
      vy += ny * force * config.deltaTime;
    }
  }

  // Apply vortices
  for (var i = 0u; i < config.vortexCount; i++) {
    let vortex = vortices[i];
    let dx = vortex.x - x;
    let dy = vortex.y - y;
    let dist = sqrt(dx * dx + dy * dy);

    if (dist < vortex.radius && dist > 0.001) {
      let influence = 1.0 - (dist / vortex.radius);
      let strength = vortex.strength * 0.0001 * influence;

      // Perpendicular (tangential) force
      let nx = dx / dist;
      let ny = dy / dist;
      let perpX = -ny;
      let perpY = nx;

      vx += perpX * strength * config.deltaTime;
      vy += perpY * strength * config.deltaTime;

      // Inward pull
      let inward = vortex.inwardPull * 0.0001 * influence;
      vx += nx * inward * config.deltaTime;
      vy += ny * inward * config.deltaTime;
    }
  }

  // Apply friction
  let frictionFactor = 1.0 - config.friction;
  vx *= frictionFactor;
  vy *= frictionFactor;

  // Update position
  pos.x = x + vx * config.deltaTime;
  pos.y = y + vy * config.deltaTime;

  // Update velocity
  vel.x = vx;
  vel.y = vy;

  // Increment age
  props.x = age + config.deltaTime;

  // Write back
  positions[idx] = pos;
  velocities[idx] = vel;
  properties[idx] = props;
}
`
);
const PARTICLE_SIZE_MODULATION_SHADER = (
  /* wgsl */
  `
struct ModConfig {
  particleCount: u32,
  sizeOverLifeEnabled: u32,
  sizeStart: f32,
  sizeEnd: f32,
  easingType: u32,  // 0=linear, 1=easeIn, 2=easeOut, 3=easeInOut
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

@group(0) @binding(0) var<uniform> config: ModConfig;
@group(0) @binding(1) var<storage, read_write> properties: array<vec4<f32>>;

fn easeInQuad(t: f32) -> f32 {
  return t * t;
}

fn easeOutQuad(t: f32) -> f32 {
  return t * (2.0 - t);
}

fn easeInOutQuad(t: f32) -> f32 {
  if (t < 0.5) {
    return 2.0 * t * t;
  }
  return -1.0 + (4.0 - 2.0 * t) * t;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let idx = global_id.x;
  if (idx >= config.particleCount) {
    return;
  }

  var props = properties[idx];
  let age = props.x;
  let lifetime = props.y;
  let baseSize = props.w;

  if (age > lifetime) {
    return;
  }

  if (config.sizeOverLifeEnabled == 1u) {
    var t = clamp(age / lifetime, 0.0, 1.0);

    // Apply easing
    if (config.easingType == 1u) {
      t = easeInQuad(t);
    } else if (config.easingType == 2u) {
      t = easeOutQuad(t);
    } else if (config.easingType == 3u) {
      t = easeInOutQuad(t);
    }

    let sizeMult = mix(config.sizeStart, config.sizeEnd, t);
    props.z = baseSize * sizeMult;
  }

  properties[idx] = props;
}
`
);
class ParticleGPUCompute {
  device = null;
  adapter = null;
  // Pipelines
  updatePipeline = null;
  modulationPipeline = null;
  // Buffers
  positionBuffer = null;
  velocityBuffer = null;
  propertiesBuffer = null;
  colorBuffer = null;
  configBuffer = null;
  gravityWellBuffer = null;
  vortexBuffer = null;
  modulationConfigBuffer = null;
  // Staging buffers for readback
  stagingPositionBuffer = null;
  stagingVelocityBuffer = null;
  stagingPropertiesBuffer = null;
  stagingColorBuffer = null;
  // Bind groups
  updateBindGroup = null;
  modulationBindGroup = null;
  // Config
  maxParticles = 0;
  initialized = false;
  // Static capability check
  static _capabilities = null;
  // ============================================================================
  // STATIC METHODS
  // ============================================================================
  /**
   * Check WebGPU availability and capabilities
   */
  static async checkCapabilities() {
    if (this._capabilities) {
      return this._capabilities;
    }
    if (!navigator.gpu) {
      this._capabilities = {
        available: false,
        adapter: null,
        device: null,
        maxWorkgroupSize: 0,
        maxBufferSize: 0
      };
      return this._capabilities;
    }
    try {
      const adapter = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (!adapter) {
        this._capabilities = {
          available: false,
          adapter: null,
          device: null,
          maxWorkgroupSize: 0,
          maxBufferSize: 0
        };
        return this._capabilities;
      }
      const device = await adapter.requestDevice({
        requiredLimits: {
          maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
          maxComputeWorkgroupSizeX: 256
        }
      });
      this._capabilities = {
        available: true,
        adapter,
        device,
        maxWorkgroupSize: device.limits.maxComputeWorkgroupSizeX,
        maxBufferSize: device.limits.maxStorageBufferBindingSize
      };
      return this._capabilities;
    } catch (error) {
      console.warn("WebGPU initialization failed:", error);
      this._capabilities = {
        available: false,
        adapter: null,
        device: null,
        maxWorkgroupSize: 0,
        maxBufferSize: 0
      };
      return this._capabilities;
    }
  }
  /**
   * Check if WebGPU compute is available
   */
  static async isAvailable() {
    const caps = await this.checkCapabilities();
    return caps.available;
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Initialize the GPU compute engine
   */
  async initialize(maxParticles) {
    const caps = await ParticleGPUCompute.checkCapabilities();
    if (!caps.available || !caps.device) {
      console.warn("WebGPU not available, using CPU fallback");
      return false;
    }
    this.device = caps.device;
    this.adapter = caps.adapter;
    this.maxParticles = maxParticles;
    try {
      await this.createPipelines();
      this.createBuffers();
      this.initialized = true;
      console.log(`WebGPU Particle Compute initialized for ${maxParticles} particles`);
      return true;
    } catch (error) {
      console.error("Failed to initialize WebGPU compute:", error);
      this.dispose();
      return false;
    }
  }
  /**
   * Create compute shader pipelines
   */
  async createPipelines() {
    if (!this.device) return;
    const updateShaderModule = this.device.createShaderModule({
      label: "Particle Update Shader",
      code: PARTICLE_UPDATE_SHADER
    });
    this.updatePipeline = this.device.createComputePipeline({
      label: "Particle Update Pipeline",
      layout: "auto",
      compute: {
        module: updateShaderModule,
        entryPoint: "main"
      }
    });
    const modulationShaderModule = this.device.createShaderModule({
      label: "Particle Modulation Shader",
      code: PARTICLE_SIZE_MODULATION_SHADER
    });
    this.modulationPipeline = this.device.createComputePipeline({
      label: "Particle Modulation Pipeline",
      layout: "auto",
      compute: {
        module: modulationShaderModule,
        entryPoint: "main"
      }
    });
  }
  /**
   * Create GPU buffers for particle data
   */
  createBuffers() {
    if (!this.device) return;
    const particleCount = this.maxParticles;
    this.positionBuffer = this.device.createBuffer({
      label: "Particle Positions",
      size: particleCount * 4 * 4,
      // 4 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.velocityBuffer = this.device.createBuffer({
      label: "Particle Velocities",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.propertiesBuffer = this.device.createBuffer({
      label: "Particle Properties",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.colorBuffer = this.device.createBuffer({
      label: "Particle Colors",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.configBuffer = this.device.createBuffer({
      label: "Simulation Config",
      size: 32,
      // 8 values * 4 bytes, aligned to 16
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.gravityWellBuffer = this.device.createBuffer({
      label: "Gravity Wells",
      size: 16 * 8 * 4,
      // 16 wells * 8 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.vortexBuffer = this.device.createBuffer({
      label: "Vortices",
      size: 16 * 8 * 4,
      // 16 vortices * 8 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.modulationConfigBuffer = this.device.createBuffer({
      label: "Modulation Config",
      size: 32,
      // 8 values * 4 bytes
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.stagingPositionBuffer = this.device.createBuffer({
      label: "Staging Positions",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingVelocityBuffer = this.device.createBuffer({
      label: "Staging Velocities",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingPropertiesBuffer = this.device.createBuffer({
      label: "Staging Properties",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingColorBuffer = this.device.createBuffer({
      label: "Staging Colors",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
  }
  // ============================================================================
  // DATA UPLOAD
  // ============================================================================
  /**
   * Upload particle data to GPU
   */
  uploadParticles(data) {
    if (!this.device || !this.initialized) return;
    this.device.queue.writeBuffer(this.positionBuffer, 0, data.positions);
    this.device.queue.writeBuffer(this.velocityBuffer, 0, data.velocities);
    this.device.queue.writeBuffer(this.propertiesBuffer, 0, data.properties);
    this.device.queue.writeBuffer(this.colorBuffer, 0, data.colors);
  }
  /**
   * Upload simulation config to GPU
   */
  uploadConfig(config, gravityWells, vortices) {
    if (!this.device || !this.initialized) return;
    const configData = new Float32Array([
      config.gravity,
      config.windX,
      config.windY,
      config.friction,
      config.deltaTime,
      0,
      0,
      0
      // Padding for alignment
    ]);
    const configView = new DataView(configData.buffer);
    configView.setUint32(20, config.maxParticles, true);
    configView.setUint32(24, gravityWells.length, true);
    configView.setUint32(28, vortices.length, true);
    this.device.queue.writeBuffer(this.configBuffer, 0, configData);
    const wellData = new Float32Array(16 * 8);
    gravityWells.forEach((well, i) => {
      if (i >= 16) return;
      const offset = i * 8;
      wellData[offset + 0] = well.x;
      wellData[offset + 1] = well.y;
      wellData[offset + 2] = well.radius;
      wellData[offset + 3] = well.strength;
      wellData[offset + 4] = well.falloff;
    });
    this.device.queue.writeBuffer(this.gravityWellBuffer, 0, wellData);
    const vortexData = new Float32Array(16 * 8);
    vortices.forEach((vortex, i) => {
      if (i >= 16) return;
      const offset = i * 8;
      vortexData[offset + 0] = vortex.x;
      vortexData[offset + 1] = vortex.y;
      vortexData[offset + 2] = vortex.radius;
      vortexData[offset + 3] = vortex.strength;
      vortexData[offset + 4] = vortex.inwardPull;
    });
    this.device.queue.writeBuffer(this.vortexBuffer, 0, vortexData);
  }
  // ============================================================================
  // COMPUTE DISPATCH
  // ============================================================================
  /**
   * Run the particle update compute shader
   */
  dispatchUpdate(particleCount) {
    if (!this.device || !this.initialized || !this.updatePipeline) return;
    if (!this.updateBindGroup) {
      this.updateBindGroup = this.device.createBindGroup({
        label: "Update Bind Group",
        layout: this.updatePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: this.configBuffer } },
          { binding: 1, resource: { buffer: this.positionBuffer } },
          { binding: 2, resource: { buffer: this.velocityBuffer } },
          { binding: 3, resource: { buffer: this.propertiesBuffer } },
          { binding: 4, resource: { buffer: this.gravityWellBuffer } },
          { binding: 5, resource: { buffer: this.vortexBuffer } }
        ]
      });
    }
    const commandEncoder = this.device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.updatePipeline);
    passEncoder.setBindGroup(0, this.updateBindGroup);
    const workgroupCount = Math.ceil(particleCount / 256);
    passEncoder.dispatchWorkgroups(workgroupCount);
    passEncoder.end();
    this.device.queue.submit([commandEncoder.finish()]);
  }
  /**
   * Run the size modulation compute shader
   */
  dispatchModulation(particleCount, sizeOverLifeEnabled, sizeStart, sizeEnd, easingType) {
    if (!this.device || !this.initialized || !this.modulationPipeline) return;
    const modConfig = new Uint32Array([
      particleCount,
      sizeOverLifeEnabled ? 1 : 0,
      0,
      0
      // Will be replaced with floats
    ]);
    const modConfigView = new DataView(modConfig.buffer);
    modConfigView.setFloat32(8, sizeStart, true);
    modConfigView.setFloat32(12, sizeEnd, true);
    modConfigView.setUint32(16, easingType, true);
    this.device.queue.writeBuffer(this.modulationConfigBuffer, 0, modConfig);
    if (!this.modulationBindGroup) {
      this.modulationBindGroup = this.device.createBindGroup({
        label: "Modulation Bind Group",
        layout: this.modulationPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: this.modulationConfigBuffer } },
          { binding: 1, resource: { buffer: this.propertiesBuffer } }
        ]
      });
    }
    const commandEncoder = this.device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.modulationPipeline);
    passEncoder.setBindGroup(0, this.modulationBindGroup);
    const workgroupCount = Math.ceil(particleCount / 256);
    passEncoder.dispatchWorkgroups(workgroupCount);
    passEncoder.end();
    this.device.queue.submit([commandEncoder.finish()]);
  }
  // ============================================================================
  // DATA READBACK
  // ============================================================================
  /**
   * Read particle data back from GPU
   * Note: This is async and can be slow - prefer keeping data on GPU when possible
   */
  async readbackParticles(particleCount) {
    if (!this.device || !this.initialized) {
      return {
        positions: new Float32Array(0),
        velocities: new Float32Array(0),
        properties: new Float32Array(0),
        colors: new Float32Array(0),
        count: 0
      };
    }
    const byteSize = particleCount * 4 * 4;
    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(this.positionBuffer, 0, this.stagingPositionBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.velocityBuffer, 0, this.stagingVelocityBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.propertiesBuffer, 0, this.stagingPropertiesBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.colorBuffer, 0, this.stagingColorBuffer, 0, byteSize);
    this.device.queue.submit([commandEncoder.finish()]);
    await this.stagingPositionBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingVelocityBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingPropertiesBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingColorBuffer.mapAsync(GPUMapMode.READ);
    const positions = new Float32Array(this.stagingPositionBuffer.getMappedRange().slice(0));
    const velocities = new Float32Array(this.stagingVelocityBuffer.getMappedRange().slice(0));
    const properties = new Float32Array(this.stagingPropertiesBuffer.getMappedRange().slice(0));
    const colors = new Float32Array(this.stagingColorBuffer.getMappedRange().slice(0));
    this.stagingPositionBuffer.unmap();
    this.stagingVelocityBuffer.unmap();
    this.stagingPropertiesBuffer.unmap();
    this.stagingColorBuffer.unmap();
    return {
      positions,
      velocities,
      properties,
      colors,
      count: particleCount
    };
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  /**
   * Dispose GPU resources
   */
  dispose() {
    this.positionBuffer?.destroy();
    this.velocityBuffer?.destroy();
    this.propertiesBuffer?.destroy();
    this.colorBuffer?.destroy();
    this.configBuffer?.destroy();
    this.gravityWellBuffer?.destroy();
    this.vortexBuffer?.destroy();
    this.modulationConfigBuffer?.destroy();
    this.stagingPositionBuffer?.destroy();
    this.stagingVelocityBuffer?.destroy();
    this.stagingPropertiesBuffer?.destroy();
    this.stagingColorBuffer?.destroy();
    this.positionBuffer = null;
    this.velocityBuffer = null;
    this.propertiesBuffer = null;
    this.colorBuffer = null;
    this.configBuffer = null;
    this.gravityWellBuffer = null;
    this.vortexBuffer = null;
    this.modulationConfigBuffer = null;
    this.stagingPositionBuffer = null;
    this.stagingVelocityBuffer = null;
    this.stagingPropertiesBuffer = null;
    this.stagingColorBuffer = null;
    this.updateBindGroup = null;
    this.modulationBindGroup = null;
    this.updatePipeline = null;
    this.modulationPipeline = null;
    this.device = null;
    this.adapter = null;
    this.initialized = false;
  }
  /**
   * Check if engine is initialized
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Get max particles this instance supports
   */
  getMaxParticles() {
    return this.maxParticles;
  }
}

const _hoisted_1$P = { class: "particle-properties" };
const _hoisted_2$O = { class: "property-section presets-section" };
const _hoisted_3$O = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$O = { class: "preset-controls" };
const _hoisted_5$O = { label: "Built-in" };
const _hoisted_6$O = ["value"];
const _hoisted_7$O = {
  key: 0,
  label: "User Presets"
};
const _hoisted_8$M = ["value"];
const _hoisted_9$M = ["disabled"];
const _hoisted_10$L = { class: "preset-actions" };
const _hoisted_11$K = ["disabled"];
const _hoisted_12$I = { class: "preset-dialog" };
const _hoisted_13$I = { class: "dialog-field" };
const _hoisted_14$E = { class: "dialog-field" };
const _hoisted_15$D = { class: "dialog-field" };
const _hoisted_16$C = { class: "dialog-actions" };
const _hoisted_17$B = ["disabled"];
const _hoisted_18$z = { class: "property-section" };
const _hoisted_19$y = {
  key: 0,
  class: "section-content"
};
const _hoisted_20$y = { class: "property-row" };
const _hoisted_21$w = ["value"];
const _hoisted_22$u = { class: "value-display" };
const _hoisted_23$u = { class: "property-row" };
const _hoisted_24$o = ["value"];
const _hoisted_25$o = { class: "value-display" };
const _hoisted_26$m = { class: "property-row" };
const _hoisted_27$m = ["value"];
const _hoisted_28$l = { class: "value-display" };
const _hoisted_29$l = { class: "property-row" };
const _hoisted_30$k = ["value"];
const _hoisted_31$i = { class: "value-display" };
const _hoisted_32$i = { class: "property-row" };
const _hoisted_33$i = ["value"];
const _hoisted_34$g = { class: "value-display" };
const _hoisted_35$f = { class: "property-row" };
const _hoisted_36$e = ["value"];
const _hoisted_37$e = { class: "property-row" };
const _hoisted_38$e = ["value"];
const _hoisted_39$e = { class: "value-display" };
const _hoisted_40$d = { class: "property-row checkbox-row" };
const _hoisted_41$b = { title: "When enabled, particles will be confined within any mask applied to this layer." };
const _hoisted_42$a = ["checked"];
const _hoisted_43$a = { class: "property-row checkbox-row gpu-row" };
const _hoisted_44$a = { title: "Use WebGPU for hardware-accelerated particle simulation. Dramatically improves performance with high particle counts." };
const _hoisted_45$a = ["checked", "disabled"];
const _hoisted_46$a = {
  key: 0,
  class: "gpu-status available"
};
const _hoisted_47$a = {
  key: 1,
  class: "gpu-status unavailable"
};
const _hoisted_48$a = { class: "property-section" };
const _hoisted_49$a = {
  key: 0,
  class: "section-content"
};
const _hoisted_50$9 = ["onClick"];
const _hoisted_51$9 = ["value", "onInput"];
const _hoisted_52$8 = { class: "enabled-toggle" };
const _hoisted_53$8 = ["checked", "onChange"];
const _hoisted_54$8 = ["onClick"];
const _hoisted_55$8 = {
  key: 0,
  class: "emitter-content"
};
const _hoisted_56$8 = { class: "property-row" };
const _hoisted_57$7 = ["value", "onInput"];
const _hoisted_58$7 = { class: "value-display" };
const _hoisted_59$7 = { class: "property-row" };
const _hoisted_60$6 = ["value", "onInput"];
const _hoisted_61$6 = { class: "value-display" };
const _hoisted_62$6 = { class: "property-row" };
const _hoisted_63$4 = ["value", "onInput"];
const _hoisted_64$4 = { class: "value-display" };
const _hoisted_65$4 = { class: "property-row" };
const _hoisted_66$4 = ["value", "onInput"];
const _hoisted_67$4 = { class: "value-display" };
const _hoisted_68$4 = { class: "property-row" };
const _hoisted_69$4 = ["value", "onInput"];
const _hoisted_70$4 = { class: "value-display" };
const _hoisted_71$4 = { class: "property-row" };
const _hoisted_72$4 = ["value", "onInput"];
const _hoisted_73$4 = { class: "value-display" };
const _hoisted_74$3 = { class: "property-row" };
const _hoisted_75$3 = ["value", "onInput"];
const _hoisted_76$3 = { class: "value-display" };
const _hoisted_77$3 = { class: "property-row" };
const _hoisted_78$3 = ["value", "onInput"];
const _hoisted_79$3 = { class: "value-display" };
const _hoisted_80$3 = { class: "property-row" };
const _hoisted_81$3 = ["value", "onInput"];
const _hoisted_82$3 = { class: "property-row" };
const _hoisted_83$3 = ["value", "onInput"];
const _hoisted_84$3 = { class: "value-display" };
const _hoisted_85$3 = { class: "property-row" };
const _hoisted_86$3 = ["value", "onInput"];
const _hoisted_87$3 = { class: "value-display" };
const _hoisted_88$3 = { class: "property-row" };
const _hoisted_89$3 = ["value", "onInput"];
const _hoisted_90$3 = { class: "value-display" };
const _hoisted_91$2 = { class: "property-row checkbox-row" };
const _hoisted_92$2 = { title: "Emit a burst of particles when audio beats are detected. Requires audio analysis." };
const _hoisted_93$2 = ["checked", "onChange"];
const _hoisted_94$2 = {
  key: 0,
  class: "property-row"
};
const _hoisted_95$1 = ["value", "onInput"];
const _hoisted_96$1 = { class: "value-display" };
const _hoisted_97$1 = { class: "property-row" };
const _hoisted_98$1 = ["value", "onChange"];
const _hoisted_99$1 = {
  key: 1,
  class: "property-row"
};
const _hoisted_100$1 = ["value", "onInput"];
const _hoisted_101$1 = { class: "value-display" };
const _hoisted_102$1 = {
  key: 2,
  class: "property-row"
};
const _hoisted_103 = ["value", "onInput"];
const _hoisted_104 = { class: "value-display" };
const _hoisted_105 = {
  key: 3,
  class: "property-row"
};
const _hoisted_106 = ["value", "onInput"];
const _hoisted_107 = { class: "value-display" };
const _hoisted_108 = {
  key: 4,
  class: "property-row"
};
const _hoisted_109 = ["value", "onInput"];
const _hoisted_110 = { class: "value-display" };
const _hoisted_111 = {
  key: 5,
  class: "property-row"
};
const _hoisted_112 = ["value", "onInput"];
const _hoisted_113 = { class: "value-display" };
const _hoisted_114 = {
  key: 6,
  class: "property-row"
};
const _hoisted_115 = ["value", "onInput"];
const _hoisted_116 = { class: "value-display" };
const _hoisted_117 = {
  key: 7,
  class: "property-row"
};
const _hoisted_118 = ["value", "onInput"];
const _hoisted_119 = { class: "value-display" };
const _hoisted_120 = {
  key: 8,
  class: "image-emission-controls"
};
const _hoisted_121 = { class: "property-row" };
const _hoisted_122 = ["value", "onChange"];
const _hoisted_123 = ["value"];
const _hoisted_124 = { class: "property-row" };
const _hoisted_125 = ["value", "onInput"];
const _hoisted_126 = { class: "value-display" };
const _hoisted_127 = { class: "property-row checkbox-row" };
const _hoisted_128 = { title: "Emit only from the edges of the masked area instead of filling it." };
const _hoisted_129 = ["checked", "onChange"];
const _hoisted_130 = {
  key: 9,
  class: "depth-emission-controls"
};
const _hoisted_131 = { class: "property-row" };
const _hoisted_132 = ["value", "onChange"];
const _hoisted_133 = ["value"];
const _hoisted_134 = { class: "property-row" };
const _hoisted_135 = ["value", "onInput"];
const _hoisted_136 = { class: "value-display" };
const _hoisted_137 = { class: "property-row" };
const _hoisted_138 = ["value", "onInput"];
const _hoisted_139 = { class: "value-display" };
const _hoisted_140 = {
  key: 10,
  class: "property-row checkbox-row"
};
const _hoisted_141 = { title: "When enabled, particles only emit from the outline/edge of the shape instead of filling the entire area." };
const _hoisted_142 = ["checked", "onChange"];
const _hoisted_143 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_144 = { class: "property-section" };
const _hoisted_145 = {
  key: 0,
  class: "section-content"
};
const _hoisted_146 = { class: "force-tabs" };
const _hoisted_147 = {
  key: 0,
  class: "force-list"
};
const _hoisted_148 = { class: "force-header" };
const _hoisted_149 = ["value", "onInput"];
const _hoisted_150 = { class: "enabled-toggle" };
const _hoisted_151 = ["checked", "onChange"];
const _hoisted_152 = ["onClick"];
const _hoisted_153 = { class: "property-row" };
const _hoisted_154 = ["value", "onInput"];
const _hoisted_155 = { class: "value-display" };
const _hoisted_156 = { class: "property-row" };
const _hoisted_157 = ["value", "onInput"];
const _hoisted_158 = { class: "value-display" };
const _hoisted_159 = { class: "property-row" };
const _hoisted_160 = ["value", "onInput"];
const _hoisted_161 = { class: "value-display" };
const _hoisted_162 = { class: "property-row" };
const _hoisted_163 = ["value", "onInput"];
const _hoisted_164 = { class: "value-display" };
const _hoisted_165 = { class: "property-row" };
const _hoisted_166 = ["value", "onChange"];
const _hoisted_167 = {
  key: 1,
  class: "force-list"
};
const _hoisted_168 = { class: "force-header" };
const _hoisted_169 = ["value", "onInput"];
const _hoisted_170 = { class: "enabled-toggle" };
const _hoisted_171 = ["checked", "onChange"];
const _hoisted_172 = ["onClick"];
const _hoisted_173 = { class: "property-row" };
const _hoisted_174 = ["value", "onInput"];
const _hoisted_175 = { class: "value-display" };
const _hoisted_176 = { class: "property-row" };
const _hoisted_177 = ["value", "onInput"];
const _hoisted_178 = { class: "value-display" };
const _hoisted_179 = { class: "property-row" };
const _hoisted_180 = ["value", "onInput"];
const _hoisted_181 = { class: "value-display" };
const _hoisted_182 = { class: "property-row" };
const _hoisted_183 = ["value", "onInput"];
const _hoisted_184 = { class: "value-display" };
const _hoisted_185 = { class: "property-row" };
const _hoisted_186 = ["value", "onInput"];
const _hoisted_187 = { class: "value-display" };
const _hoisted_188 = { class: "property-row" };
const _hoisted_189 = ["value", "onInput"];
const _hoisted_190 = { class: "value-display" };
const _hoisted_191 = { class: "property-section" };
const _hoisted_192 = {
  key: 0,
  class: "section-content"
};
const _hoisted_193 = { class: "force-header" };
const _hoisted_194 = { class: "enabled-toggle" };
const _hoisted_195 = ["checked", "onChange"];
const _hoisted_196 = ["onClick"];
const _hoisted_197 = { class: "property-row" };
const _hoisted_198 = ["value", "onInput"];
const _hoisted_199 = { class: "value-display" };
const _hoisted_200 = { class: "property-row" };
const _hoisted_201 = ["value", "onInput"];
const _hoisted_202 = { class: "value-display" };
const _hoisted_203 = { class: "property-row" };
const _hoisted_204 = ["value", "onInput"];
const _hoisted_205 = { class: "value-display" };
const _hoisted_206 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_207 = { class: "property-section" };
const _hoisted_208 = {
  key: 0,
  class: "section-content"
};
const _hoisted_209 = { class: "property-row" };
const _hoisted_210 = ["checked"];
const _hoisted_211 = { class: "property-row" };
const _hoisted_212 = ["value"];
const _hoisted_213 = { class: "value-display" };
const _hoisted_214 = { class: "property-row" };
const _hoisted_215 = ["value"];
const _hoisted_216 = { class: "value-display" };
const _hoisted_217 = { class: "property-row" };
const _hoisted_218 = ["value"];
const _hoisted_219 = { class: "value-display" };
const _hoisted_220 = { class: "property-row" };
const _hoisted_221 = ["value"];
const _hoisted_222 = { class: "value-display" };
const _hoisted_223 = { class: "property-row" };
const _hoisted_224 = ["value"];
const _hoisted_225 = { class: "value-display" };
const _hoisted_226 = { class: "property-row" };
const _hoisted_227 = ["value"];
const _hoisted_228 = { class: "value-display" };
const _hoisted_229 = { class: "property-row" };
const _hoisted_230 = ["value"];
const _hoisted_231 = { class: "value-display" };
const _hoisted_232 = { class: "property-row" };
const _hoisted_233 = ["value"];
const _hoisted_234 = { class: "value-display" };
const _hoisted_235 = { class: "property-row" };
const _hoisted_236 = ["value"];
const _hoisted_237 = { class: "value-display" };
const _hoisted_238 = { class: "property-section" };
const _hoisted_239 = {
  key: 0,
  class: "section-content"
};
const _hoisted_240 = { class: "property-row" };
const _hoisted_241 = ["checked"];
const _hoisted_242 = { class: "property-row" };
const _hoisted_243 = ["checked"];
const _hoisted_244 = { class: "property-row" };
const _hoisted_245 = ["value"];
const _hoisted_246 = { class: "value-display" };
const _hoisted_247 = { class: "property-row" };
const _hoisted_248 = ["value"];
const _hoisted_249 = { class: "value-display" };
const _hoisted_250 = { class: "property-row" };
const _hoisted_251 = ["value"];
const _hoisted_252 = { class: "value-display" };
const _hoisted_253 = { class: "property-row" };
const _hoisted_254 = ["checked"];
const _hoisted_255 = { class: "property-row" };
const _hoisted_256 = ["value"];
const _hoisted_257 = { class: "property-row" };
const _hoisted_258 = ["value"];
const _hoisted_259 = { class: "value-display" };
const _hoisted_260 = { class: "property-section" };
const _hoisted_261 = {
  key: 0,
  class: "section-content"
};
const _hoisted_262 = { class: "force-header" };
const _hoisted_263 = ["value", "onChange"];
const _hoisted_264 = ["value"];
const _hoisted_265 = { class: "enabled-toggle" };
const _hoisted_266 = ["checked", "onChange"];
const _hoisted_267 = ["onClick"];
const _hoisted_268 = { class: "property-row" };
const _hoisted_269 = ["value", "onChange"];
const _hoisted_270 = { class: "property-row" };
const _hoisted_271 = ["value", "onInput"];
const _hoisted_272 = { class: "value-display" };
const _hoisted_273 = { class: "property-row" };
const _hoisted_274 = ["value", "onInput"];
const _hoisted_275 = { class: "value-display" };
const _hoisted_276 = { class: "property-row" };
const _hoisted_277 = ["value", "onInput"];
const _hoisted_278 = { class: "value-display" };
const _hoisted_279 = { class: "property-row" };
const _hoisted_280 = ["value", "onInput"];
const _hoisted_281 = { class: "value-display" };
const _hoisted_282 = { class: "property-row" };
const _hoisted_283 = ["value", "onInput"];
const _hoisted_284 = { class: "value-display" };
const _hoisted_285 = { class: "property-row" };
const _hoisted_286 = ["value", "onInput"];
const _hoisted_287 = { class: "value-display" };
const _hoisted_288 = { class: "property-row" };
const _hoisted_289 = ["value", "onInput"];
const _hoisted_290 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_291 = { class: "property-section" };
const _hoisted_292 = {
  key: 0,
  class: "section-content"
};
const _hoisted_293 = { class: "modulation-header" };
const _hoisted_294 = ["value", "onChange"];
const _hoisted_295 = ["value"];
const _hoisted_296 = ["onClick"];
const _hoisted_297 = { class: "property-row" };
const _hoisted_298 = ["value", "onChange"];
const _hoisted_299 = { class: "property-row" };
const _hoisted_300 = ["value", "onInput"];
const _hoisted_301 = { class: "property-row" };
const _hoisted_302 = ["value", "onInput"];
const _hoisted_303 = { class: "property-row" };
const _hoisted_304 = ["value", "onChange"];
const _hoisted_305 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_306 = { class: "property-section" };
const _hoisted_307 = {
  key: 0,
  class: "section-content"
};
const _hoisted_308 = { class: "property-row" };
const _hoisted_309 = ["value"];
const _hoisted_310 = { class: "property-row" };
const _hoisted_311 = ["value"];
const _hoisted_312 = { class: "property-row checkbox-row" };
const _hoisted_313 = { title: "Use a custom image or sprite sheet instead of procedural shapes." };
const _hoisted_314 = ["checked"];
const _hoisted_315 = {
  key: 0,
  class: "property-row"
};
const _hoisted_316 = ["value"];
const _hoisted_317 = {
  key: 1,
  class: "property-row"
};
const _hoisted_318 = ["value"];
const _hoisted_319 = {
  key: 2,
  class: "property-row"
};
const _hoisted_320 = ["value"];
const _hoisted_321 = {
  key: 3,
  class: "property-row checkbox-row"
};
const _hoisted_322 = { title: "Animate through sprite sheet frames over time." };
const _hoisted_323 = ["checked"];
const _hoisted_324 = {
  key: 4,
  class: "property-row"
};
const _hoisted_325 = ["value"];
const _hoisted_326 = { class: "value-display" };
const _hoisted_327 = {
  key: 5,
  class: "property-row checkbox-row"
};
const _hoisted_328 = { title: "Each particle starts at a random frame in the sprite sheet." };
const _hoisted_329 = ["checked"];
const _hoisted_330 = { class: "property-row checkbox-row" };
const _hoisted_331 = { title: "Draw a trail behind moving particles showing their recent path." };
const _hoisted_332 = ["checked"];
const _hoisted_333 = {
  key: 6,
  class: "property-row"
};
const _hoisted_334 = ["value"];
const _hoisted_335 = { class: "value-display" };
const _hoisted_336 = {
  key: 7,
  class: "property-row"
};
const _hoisted_337 = ["value"];
const _hoisted_338 = { class: "value-display" };
const _hoisted_339 = { class: "property-row checkbox-row" };
const _hoisted_340 = { title: "Add a soft glow effect around particles. Great for fire, magic, and light effects." };
const _hoisted_341 = ["checked"];
const _hoisted_342 = {
  key: 8,
  class: "property-row"
};
const _hoisted_343 = ["value"];
const _hoisted_344 = { class: "value-display" };
const _hoisted_345 = {
  key: 9,
  class: "property-row"
};
const _hoisted_346 = ["value"];
const _hoisted_347 = { class: "value-display" };
const _hoisted_348 = { class: "property-row checkbox-row" };
const _hoisted_349 = { title: "Blur fast-moving particles to simulate camera motion blur." };
const _hoisted_350 = ["checked"];
const _hoisted_351 = {
  key: 10,
  class: "property-row"
};
const _hoisted_352 = ["value"];
const _hoisted_353 = { class: "value-display" };
const _hoisted_354 = {
  key: 11,
  class: "property-row"
};
const _hoisted_355 = ["value"];
const _hoisted_356 = { class: "value-display" };
const _hoisted_357 = { class: "property-row checkbox-row" };
const _hoisted_358 = { title: "Draw lines between nearby particles. Creates web/network/constellation effects." };
const _hoisted_359 = ["checked"];
const _hoisted_360 = {
  key: 12,
  class: "property-row"
};
const _hoisted_361 = ["value"];
const _hoisted_362 = { class: "value-display" };
const _hoisted_363 = {
  key: 13,
  class: "property-row"
};
const _hoisted_364 = ["value"];
const _hoisted_365 = { class: "value-display" };
const _hoisted_366 = {
  key: 14,
  class: "property-row"
};
const _hoisted_367 = ["value"];
const _hoisted_368 = { class: "value-display" };
const _hoisted_369 = {
  key: 15,
  class: "property-row"
};
const _hoisted_370 = ["value"];
const _hoisted_371 = { class: "value-display" };
const _hoisted_372 = {
  key: 16,
  class: "property-row checkbox-row"
};
const _hoisted_373 = { title: "Make connection lines more transparent as particles get farther apart." };
const _hoisted_374 = ["checked"];
const _hoisted_375 = { class: "particle-count" };
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const presetStore = usePresetStore();
    presetStore.initialize();
    const compositorStore = useCompositorStore();
    const imageLayers = computed(
      () => compositorStore.layers.filter((l) => l.type === "image" || l.type === "video" || l.type === "solid")
    );
    const depthLayers = computed(
      () => compositorStore.layers.filter(
        (l) => l.type === "image" && (l.name.toLowerCase().includes("depth") || l.data?.isDepthMap)
      )
    );
    const webgpuAvailable = ref(false);
    onMounted(async () => {
      webgpuAvailable.value = await ParticleGPUCompute.isAvailable();
    });
    const selectedPresetId = ref("");
    const showSaveDialog = ref(false);
    const newPresetName = ref("");
    const newPresetDescription = ref("");
    const newPresetTags = ref("");
    const builtInPresets = computed(
      () => presetStore.particlePresets.filter((p) => p.isBuiltIn)
    );
    const userPresets = computed(
      () => presetStore.particlePresets.filter((p) => !p.isBuiltIn)
    );
    const isBuiltInPreset = computed(() => {
      if (!selectedPresetId.value) return false;
      const preset = presetStore.getPreset(selectedPresetId.value);
      return preset?.isBuiltIn ?? false;
    });
    const props = __props;
    const emit = __emit;
    const expandedSectionsMap = ref(/* @__PURE__ */ new Map());
    const expandedEmittersMap = ref(/* @__PURE__ */ new Map());
    const forceTab = ref("wells");
    const expandedSections = computed({
      get: () => {
        const layerId = props.layer?.id;
        if (!layerId) return /* @__PURE__ */ new Set(["system", "emitters"]);
        if (!expandedSectionsMap.value.has(layerId)) {
          expandedSectionsMap.value.set(layerId, /* @__PURE__ */ new Set(["system", "emitters"]));
        }
        return expandedSectionsMap.value.get(layerId);
      },
      set: (val) => {
        const layerId = props.layer?.id;
        if (layerId) {
          expandedSectionsMap.value.set(layerId, val);
        }
      }
    });
    const expandedEmitters = computed({
      get: () => {
        const layerId = props.layer?.id;
        if (!layerId) return /* @__PURE__ */ new Set();
        if (!expandedEmittersMap.value.has(layerId)) {
          expandedEmittersMap.value.set(layerId, /* @__PURE__ */ new Set());
        }
        return expandedEmittersMap.value.get(layerId);
      },
      set: (val) => {
        const layerId = props.layer?.id;
        if (layerId) {
          expandedEmittersMap.value.set(layerId, val);
        }
      }
    });
    watch(() => props.layer?.id, (newId, oldId) => {
      if (newId && newId !== oldId) {
        if (!expandedSectionsMap.value.has(newId)) {
          expandedSectionsMap.value.set(newId, /* @__PURE__ */ new Set(["system", "emitters"]));
        }
        if (!expandedEmittersMap.value.has(newId)) {
          expandedEmittersMap.value.set(newId, /* @__PURE__ */ new Set());
        }
      }
    }, { immediate: true });
    watch(() => props.layer?.data, () => {
    }, { deep: true });
    const layerData = computed(() => {
      const data = props.layer.data;
      return data || {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          },
          // Sprite defaults
          spriteEnabled: false,
          spriteImageUrl: "",
          spriteColumns: 1,
          spriteRows: 1,
          spriteAnimate: false,
          spriteFrameRate: 10,
          spriteRandomStart: false
        },
        turbulenceFields: [],
        subEmitters: []
      };
    });
    const systemConfig = computed(() => layerData.value.systemConfig);
    const emitters = computed(() => layerData.value.emitters);
    const gravityWells = computed(() => layerData.value.gravityWells);
    const vortices = computed(() => layerData.value.vortices);
    const modulations = computed(() => layerData.value.modulations);
    const renderOptions = computed(() => layerData.value.renderOptions);
    const turbulenceFields = computed(() => layerData.value.turbulenceFields || []);
    const subEmitters = computed(() => layerData.value.subEmitters || []);
    const flocking = computed(() => layerData.value.flocking || {
      enabled: false,
      separationWeight: 50,
      separationRadius: 25,
      alignmentWeight: 50,
      alignmentRadius: 50,
      cohesionWeight: 50,
      cohesionRadius: 50,
      maxSpeed: 200,
      maxForce: 10,
      perceptionAngle: 270
    });
    const collision = computed(() => layerData.value.collision || {
      enabled: false,
      particleCollision: false,
      particleRadius: 5,
      bounciness: 0.5,
      friction: 0.1,
      boundaryEnabled: false,
      boundaryBehavior: "bounce",
      boundaryPadding: 0
    });
    const connections = computed(() => renderOptions.value.connections || {
      enabled: false,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: true
    });
    const particleCount = computed(() => props.particleCount);
    function toggleSection(section) {
      const current = expandedSections.value;
      const newSet = new Set(current);
      if (newSet.has(section)) {
        newSet.delete(section);
      } else {
        newSet.add(section);
      }
      expandedSections.value = newSet;
    }
    function toggleEmitter(id) {
      const current = expandedEmitters.value;
      const newSet = new Set(current);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      expandedEmitters.value = newSet;
    }
    function applySelectedPreset() {
      if (!selectedPresetId.value) return;
      const preset = presetStore.getPreset(selectedPresetId.value);
      if (!preset || preset.category !== "particle") return;
      const config = preset.config;
      const updates = {};
      if (config.maxParticles !== void 0) {
        updates.systemConfig = {
          ...systemConfig.value,
          maxParticles: config.maxParticles
        };
      }
      if (config.gravity) {
        updates.systemConfig = {
          ...updates.systemConfig || systemConfig.value,
          gravity: config.gravity.y || 0
        };
      }
      if (config.emissionRate || config.lifespan || config.startSize || config.endSize) {
        const defaultEmitter = emitters.value[0] || createDefaultEmitter();
        updates.emitters = [{
          ...defaultEmitter,
          emissionRate: config.emissionRate ?? defaultEmitter.emissionRate,
          lifespan: config.lifespan ?? defaultEmitter.lifespan,
          startSize: config.startSize ?? defaultEmitter.startSize,
          endSize: config.endSize ?? defaultEmitter.endSize,
          startColor: config.startColor ?? defaultEmitter.startColor,
          endColor: config.endColor ?? defaultEmitter.endColor,
          velocitySpread: config.velocitySpread ?? defaultEmitter.velocitySpread
        }];
      }
      if (config.turbulenceStrength !== void 0) {
        updates.turbulenceFields = [{
          id: "turbulence-from-preset",
          enabled: true,
          strength: config.turbulenceStrength,
          scale: 0.01,
          octaves: 3,
          persistence: 0.5,
          animationSpeed: 1
        }];
      }
      emit("update", updates);
    }
    function createDefaultEmitter() {
      return {
        id: `emitter_${Date.now()}`,
        enabled: true,
        emissionMode: "point",
        emissionRate: 50,
        emissionBurstSize: 10,
        emissionBurstInterval: 0,
        position: { x: 0, y: 0, z: 0 },
        direction: { x: 0, y: -1, z: 0 },
        spread: 30,
        velocity: { min: 50, max: 150 },
        lifespan: 2,
        startSize: 10,
        endSize: 2,
        startColor: "#ffffff",
        endColor: "#ffffff",
        startOpacity: 1,
        endOpacity: 0,
        rotation: { min: 0, max: 360 },
        rotationSpeed: { min: 0, max: 0 },
        velocitySpread: 30
      };
    }
    function saveCurrentAsPreset() {
      if (!newPresetName.value.trim()) return;
      const tags = newPresetTags.value.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      const emitter = emitters.value[0];
      const turbulence = turbulenceFields.value[0];
      presetStore.saveParticlePreset(
        newPresetName.value.trim(),
        {
          maxParticles: systemConfig.value.maxParticles,
          emissionRate: emitter?.emissionRate,
          lifespan: emitter?.lifespan,
          startSize: emitter?.startSize,
          endSize: emitter?.endSize,
          startColor: emitter?.startColor,
          endColor: emitter?.endColor,
          gravity: { x: 0, y: systemConfig.value.gravity, z: 0 },
          turbulenceStrength: turbulence?.strength,
          velocitySpread: emitter?.velocitySpread
        },
        {
          description: newPresetDescription.value.trim() || void 0,
          tags: tags.length > 0 ? tags : void 0
        }
      );
      showSaveDialog.value = false;
      newPresetName.value = "";
      newPresetDescription.value = "";
      newPresetTags.value = "";
    }
    function deleteSelectedPreset() {
      if (!selectedPresetId.value || isBuiltInPreset.value) return;
      if (confirm("Delete this preset?")) {
        presetStore.deletePreset(selectedPresetId.value);
        selectedPresetId.value = "";
      }
    }
    function updateSystemConfig(key, value) {
      emit("update", {
        systemConfig: { ...systemConfig.value, [key]: value }
      });
    }
    function updateEmitter(id, key, value) {
      const updated = emitters.value.map(
        (e) => e.id === id ? { ...e, [key]: value } : e
      );
      emit("update", { emitters: updated });
    }
    function updateEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateEmitter(id, "color", rgb);
    }
    function addEmitter() {
      const newEmitter = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${emitters.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: true,
        burstOnBeat: false,
        burstCount: 20
      };
      emit("update", { emitters: [...emitters.value, newEmitter] });
      expandedEmitters.value.add(newEmitter.id);
    }
    function removeEmitter(id) {
      emit("update", { emitters: emitters.value.filter((e) => e.id !== id) });
    }
    function updateGravityWell(id, key, value) {
      const updated = gravityWells.value.map(
        (w) => w.id === id ? { ...w, [key]: value } : w
      );
      emit("update", { gravityWells: updated });
    }
    function addGravityWell() {
      const newWell = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${gravityWells.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: true
      };
      emit("update", { gravityWells: [...gravityWells.value, newWell] });
    }
    function removeGravityWell(id) {
      emit("update", { gravityWells: gravityWells.value.filter((w) => w.id !== id) });
    }
    function updateVortex(id, key, value) {
      const updated = vortices.value.map(
        (v) => v.id === id ? { ...v, [key]: value } : v
      );
      emit("update", { vortices: updated });
    }
    function addVortex() {
      const newVortex = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${vortices.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: true
      };
      emit("update", { vortices: [...vortices.value, newVortex] });
    }
    function removeVortex(id) {
      emit("update", { vortices: vortices.value.filter((v) => v.id !== id) });
    }
    function updateModulation(id, key, value) {
      const updated = modulations.value.map(
        (m) => m.id === id ? { ...m, [key]: value } : m
      );
      emit("update", { modulations: updated });
    }
    function addModulation() {
      const newMod = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      emit("update", { modulations: [...modulations.value, newMod] });
    }
    function removeModulation(id) {
      emit("update", { modulations: modulations.value.filter((m) => m.id !== id) });
    }
    function updateRenderOption(key, value) {
      emit("update", {
        renderOptions: { ...renderOptions.value, [key]: value }
      });
    }
    function updateConnection(key, value) {
      emit("update", {
        renderOptions: {
          ...renderOptions.value,
          connections: { ...connections.value, [key]: value }
        }
      });
    }
    function updateTurbulence(id, key, value) {
      const updated = turbulenceFields.value.map(
        (t) => t.id === id ? { ...t, [key]: value } : t
      );
      emit("update", { turbulenceFields: updated });
    }
    function addTurbulence() {
      const newTurb = {
        id: `turb_${Date.now()}`,
        enabled: true,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      emit("update", { turbulenceFields: [...turbulenceFields.value, newTurb] });
    }
    function removeTurbulence(id) {
      emit("update", { turbulenceFields: turbulenceFields.value.filter((t) => t.id !== id) });
    }
    function updateFlocking(key, value) {
      emit("update", {
        flocking: { ...flocking.value, [key]: value }
      });
    }
    function updateCollision(key, value) {
      emit("update", {
        collision: { ...collision.value, [key]: value }
      });
    }
    function updateSubEmitter(id, key, value) {
      const updated = subEmitters.value.map(
        (s) => s.id === id ? { ...s, [key]: value } : s
      );
      emit("update", { subEmitters: updated });
    }
    function updateSubEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateSubEmitter(id, "color", rgb);
    }
    function addSubEmitter() {
      const newSub = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: true
      };
      emit("update", { subEmitters: [...subEmitters.value, newSub] });
    }
    function removeSubEmitter(id) {
      emit("update", { subEmitters: subEmitters.value.filter((s) => s.id !== id) });
    }
    function rgbToHex(rgb) {
      return "#" + rgb.map((c) => c.toString(16).padStart(2, "0")).join("");
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$P, [
        createBaseVNode("div", _hoisted_2$O, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("presets"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presets") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[72] || (_cache[72] = createBaseVNode("span", null, "Presets", -1))
          ]),
          expandedSections.value.has("presets") ? (openBlock(), createElementBlock("div", _hoisted_3$O, [
            createBaseVNode("div", _hoisted_4$O, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedPresetId.value = $event),
                class: "preset-select"
              }, [
                _cache[73] || (_cache[73] = createBaseVNode("option", { value: "" }, "Select a preset...", -1)),
                createBaseVNode("optgroup", _hoisted_5$O, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(builtInPresets.value, (p) => {
                    return openBlock(), createElementBlock("option", {
                      key: p.id,
                      value: p.id
                    }, toDisplayString(p.name), 9, _hoisted_6$O);
                  }), 128))
                ]),
                userPresets.value.length > 0 ? (openBlock(), createElementBlock("optgroup", _hoisted_7$O, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(userPresets.value, (p) => {
                    return openBlock(), createElementBlock("option", {
                      key: p.id,
                      value: p.id
                    }, toDisplayString(p.name), 9, _hoisted_8$M);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 512), [
                [vModelSelect, selectedPresetId.value]
              ]),
              createBaseVNode("button", {
                class: "preset-btn apply",
                onClick: applySelectedPreset,
                disabled: !selectedPresetId.value,
                title: "Apply Preset"
              }, " Apply ", 8, _hoisted_9$M)
            ]),
            createBaseVNode("div", _hoisted_10$L, [
              createBaseVNode("button", {
                class: "preset-btn save",
                onClick: _cache[2] || (_cache[2] = ($event) => showSaveDialog.value = true),
                title: "Save Current Settings as Preset"
              }, " Save Preset "),
              createBaseVNode("button", {
                class: "preset-btn delete",
                onClick: deleteSelectedPreset,
                disabled: !selectedPresetId.value || isBuiltInPreset.value,
                title: "Delete Preset"
              }, " Delete ", 8, _hoisted_11$K)
            ])
          ])) : createCommentVNode("", true)
        ]),
        showSaveDialog.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "preset-dialog-overlay",
          onClick: _cache[7] || (_cache[7] = withModifiers(($event) => showSaveDialog.value = false, ["self"]))
        }, [
          createBaseVNode("div", _hoisted_12$I, [
            _cache[77] || (_cache[77] = createBaseVNode("h3", null, "Save Particle Preset", -1)),
            createBaseVNode("div", _hoisted_13$I, [
              _cache[74] || (_cache[74] = createBaseVNode("label", null, "Name", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newPresetName.value = $event),
                type: "text",
                placeholder: "My Preset"
              }, null, 512), [
                [vModelText, newPresetName.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_14$E, [
              _cache[75] || (_cache[75] = createBaseVNode("label", null, "Description", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newPresetDescription.value = $event),
                type: "text",
                placeholder: "Optional description..."
              }, null, 512), [
                [vModelText, newPresetDescription.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_15$D, [
              _cache[76] || (_cache[76] = createBaseVNode("label", null, "Tags (comma-separated)", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newPresetTags.value = $event),
                type: "text",
                placeholder: "fire, glow, magic"
              }, null, 512), [
                [vModelText, newPresetTags.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_16$C, [
              createBaseVNode("button", {
                class: "dialog-btn cancel",
                onClick: _cache[6] || (_cache[6] = ($event) => showSaveDialog.value = false)
              }, "Cancel"),
              createBaseVNode("button", {
                class: "dialog-btn save",
                onClick: saveCurrentAsPreset,
                disabled: !newPresetName.value.trim()
              }, "Save", 8, _hoisted_17$B)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_18$z, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[8] || (_cache[8] = ($event) => toggleSection("system"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[78] || (_cache[78] = createBaseVNode("span", null, "System Settings", -1))
          ]),
          expandedSections.value.has("system") ? (openBlock(), createElementBlock("div", _hoisted_19$y, [
            createBaseVNode("div", _hoisted_20$y, [
              _cache[79] || (_cache[79] = createBaseVNode("label", { title: "Maximum number of particles that can exist at once. Higher values create denser effects but use more memory." }, "Max Particles", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.maxParticles,
                min: "100",
                max: "50000",
                step: "100",
                onInput: _cache[9] || (_cache[9] = ($event) => updateSystemConfig("maxParticles", Number($event.target.value)))
              }, null, 40, _hoisted_21$w),
              createBaseVNode("span", _hoisted_22$u, toDisplayString(systemConfig.value.maxParticles), 1)
            ]),
            createBaseVNode("div", _hoisted_23$u, [
              _cache[80] || (_cache[80] = createBaseVNode("label", { title: "Global gravity force. Positive values pull particles down, negative values push them up." }, "Gravity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.gravity,
                min: "-1000",
                max: "1000",
                step: "10",
                onInput: _cache[10] || (_cache[10] = ($event) => updateSystemConfig("gravity", Number($event.target.value)))
              }, null, 40, _hoisted_24$o),
              createBaseVNode("span", _hoisted_25$o, toDisplayString(systemConfig.value.gravity), 1)
            ]),
            createBaseVNode("div", _hoisted_26$m, [
              _cache[81] || (_cache[81] = createBaseVNode("label", { title: "Strength of the wind force applied to all particles. Creates directional drift." }, "Wind Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windStrength,
                min: "0",
                max: "1000",
                step: "10",
                onInput: _cache[11] || (_cache[11] = ($event) => updateSystemConfig("windStrength", Number($event.target.value)))
              }, null, 40, _hoisted_27$m),
              createBaseVNode("span", _hoisted_28$l, toDisplayString(systemConfig.value.windStrength), 1)
            ]),
            createBaseVNode("div", _hoisted_29$l, [
              _cache[82] || (_cache[82] = createBaseVNode("label", { title: "Direction of the wind in degrees. 0 = right, 90 = down, 180 = left, 270 = up." }, "Wind Direction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windDirection,
                min: "0",
                max: "360",
                step: "5",
                onInput: _cache[12] || (_cache[12] = ($event) => updateSystemConfig("windDirection", Number($event.target.value)))
              }, null, 40, _hoisted_30$k),
              createBaseVNode("span", _hoisted_31$i, toDisplayString(systemConfig.value.windDirection) + "", 1)
            ]),
            createBaseVNode("div", _hoisted_32$i, [
              _cache[83] || (_cache[83] = createBaseVNode("label", { title: "Air resistance that slows particles over time. 0 = no friction, 1 = maximum friction." }, "Friction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.friction,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[13] || (_cache[13] = ($event) => updateSystemConfig("friction", Number($event.target.value)))
              }, null, 40, _hoisted_33$i),
              createBaseVNode("span", _hoisted_34$g, toDisplayString(systemConfig.value.friction.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_35$f, [
              _cache[85] || (_cache[85] = createBaseVNode("label", { title: "What happens when particles hit the composition boundary. Kill = remove, Bounce = reflect, Wrap = appear on opposite side." }, "Boundary", -1)),
              createBaseVNode("select", {
                value: systemConfig.value.boundaryBehavior,
                onChange: _cache[14] || (_cache[14] = ($event) => updateSystemConfig("boundaryBehavior", $event.target.value))
              }, [..._cache[84] || (_cache[84] = [
                createBaseVNode("option", { value: "kill" }, "Kill", -1),
                createBaseVNode("option", { value: "bounce" }, "Bounce", -1),
                createBaseVNode("option", { value: "wrap" }, "Wrap", -1)
              ])], 40, _hoisted_36$e)
            ]),
            createBaseVNode("div", _hoisted_37$e, [
              _cache[86] || (_cache[86] = createBaseVNode("label", { title: "Frames to pre-simulate before frame 0. Creates a 'steady state' effect where particles are already in motion at the start." }, "Warmup Period", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.warmupPeriod,
                min: "0",
                max: "120",
                step: "1",
                onInput: _cache[15] || (_cache[15] = ($event) => updateSystemConfig("warmupPeriod", Number($event.target.value)))
              }, null, 40, _hoisted_38$e),
              createBaseVNode("span", _hoisted_39$e, toDisplayString(systemConfig.value.warmupPeriod) + "f", 1)
            ]),
            createBaseVNode("div", _hoisted_40$d, [
              createBaseVNode("label", _hoisted_41$b, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: systemConfig.value.respectMaskBoundary,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateSystemConfig("respectMaskBoundary", $event.target.checked))
                }, null, 40, _hoisted_42$a),
                _cache[87] || (_cache[87] = createTextVNode(" Respect Mask Boundary ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_43$a, [
              createBaseVNode("label", _hoisted_44$a, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: systemConfig.value.useGPU,
                  disabled: !webgpuAvailable.value,
                  onChange: _cache[17] || (_cache[17] = ($event) => updateSystemConfig("useGPU", $event.target.checked))
                }, null, 40, _hoisted_45$a),
                _cache[88] || (_cache[88] = createTextVNode(" GPU Acceleration ", -1)),
                webgpuAvailable.value ? (openBlock(), createElementBlock("span", _hoisted_46$a, "(WebGPU)")) : (openBlock(), createElementBlock("span", _hoisted_47$a, "(Not Available)"))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_48$a, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[18] || (_cache[18] = ($event) => toggleSection("emitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[90] || (_cache[90] = createBaseVNode("span", null, "Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addEmitter, ["stop"]),
              title: "Add Emitter"
            }, [..._cache[89] || (_cache[89] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("emitters") ? (openBlock(), createElementBlock("div", _hoisted_49$a, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (emitter) => {
              return openBlock(), createElementBlock("div", {
                key: emitter.id,
                class: "emitter-item"
              }, [
                createBaseVNode("div", {
                  class: "emitter-header",
                  onClick: ($event) => toggleEmitter(emitter.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedEmitters.value.has(emitter.id) ? "pi-chevron-down" : "pi-chevron-right"])
                  }, null, 2),
                  createBaseVNode("input", {
                    type: "text",
                    value: emitter.name,
                    onInput: ($event) => updateEmitter(emitter.id, "name", $event.target.value),
                    onClick: _cache[19] || (_cache[19] = withModifiers(() => {
                    }, ["stop"])),
                    class: "emitter-name"
                  }, null, 40, _hoisted_51$9),
                  createBaseVNode("label", _hoisted_52$8, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: emitter.enabled,
                      onChange: ($event) => updateEmitter(emitter.id, "enabled", $event.target.checked),
                      onClick: _cache[20] || (_cache[20] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 40, _hoisted_53$8)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: withModifiers(($event) => removeEmitter(emitter.id), ["stop"]),
                    title: "Remove"
                  }, [..._cache[91] || (_cache[91] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_54$8)
                ], 8, _hoisted_50$9),
                expandedEmitters.value.has(emitter.id) ? (openBlock(), createElementBlock("div", _hoisted_55$8, [
                  createBaseVNode("div", _hoisted_56$8, [
                    _cache[92] || (_cache[92] = createBaseVNode("label", { title: "Horizontal position of the emitter. 0 = left edge, 0.5 = center, 1 = right edge." }, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_57$7),
                    createBaseVNode("span", _hoisted_58$7, toDisplayString(emitter.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_59$7, [
                    _cache[93] || (_cache[93] = createBaseVNode("label", { title: "Vertical position of the emitter. 0 = top edge, 0.5 = center, 1 = bottom edge." }, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_60$6),
                    createBaseVNode("span", _hoisted_61$6, toDisplayString(emitter.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_62$6, [
                    _cache[94] || (_cache[94] = createBaseVNode("label", { title: "Primary emission direction in degrees. 0 = right, 90 = down, 180 = left, 270 = up." }, "Direction", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.direction,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "direction", Number($event.target.value))
                    }, null, 40, _hoisted_63$4),
                    createBaseVNode("span", _hoisted_64$4, toDisplayString(emitter.direction) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_65$4, [
                    _cache[95] || (_cache[95] = createBaseVNode("label", { title: "Cone angle for particle emission. 0 = tight beam, 180 = hemisphere, 360 = full sphere." }, "Spread", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.spread,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "spread", Number($event.target.value))
                    }, null, 40, _hoisted_66$4),
                    createBaseVNode("span", _hoisted_67$4, toDisplayString(emitter.spread) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_68$4, [
                    _cache[96] || (_cache[96] = createBaseVNode("label", { title: "Initial velocity of emitted particles in pixels per second." }, "Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speed,
                      min: "1",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speed", Number($event.target.value))
                    }, null, 40, _hoisted_69$4),
                    createBaseVNode("span", _hoisted_70$4, toDisplayString(emitter.speed), 1)
                  ]),
                  createBaseVNode("div", _hoisted_71$4, [
                    _cache[97] || (_cache[97] = createBaseVNode("label", { title: "Random variation in particle speed. Adds natural randomness to the emission." }, "Speed Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speedVariance,
                      min: "0",
                      max: "500",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speedVariance", Number($event.target.value))
                    }, null, 40, _hoisted_72$4),
                    createBaseVNode("span", _hoisted_73$4, toDisplayString(emitter.speedVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_74$3, [
                    _cache[98] || (_cache[98] = createBaseVNode("label", { title: "Diameter of each particle in pixels." }, "Size", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.size,
                      min: "1",
                      max: "400",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "size", Number($event.target.value))
                    }, null, 40, _hoisted_75$3),
                    createBaseVNode("span", _hoisted_76$3, toDisplayString(emitter.size) + "px", 1)
                  ]),
                  createBaseVNode("div", _hoisted_77$3, [
                    _cache[99] || (_cache[99] = createBaseVNode("label", { title: "Random variation in particle size. Creates more natural-looking effects." }, "Size Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.sizeVariance,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "sizeVariance", Number($event.target.value))
                    }, null, 40, _hoisted_78$3),
                    createBaseVNode("span", _hoisted_79$3, toDisplayString(emitter.sizeVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_80$3, [
                    _cache[100] || (_cache[100] = createBaseVNode("label", { title: "Base color of particles when they spawn." }, "Color", -1)),
                    createBaseVNode("input", {
                      type: "color",
                      value: rgbToHex(emitter.color),
                      onInput: ($event) => updateEmitterColor(emitter.id, $event.target.value)
                    }, null, 40, _hoisted_81$3)
                  ]),
                  createBaseVNode("div", _hoisted_82$3, [
                    _cache[101] || (_cache[101] = createBaseVNode("label", { title: "Number of particles spawned per second during continuous emission." }, "Emission Rate", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.emissionRate,
                      min: "0.1",
                      max: "100",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "emissionRate", Number($event.target.value))
                    }, null, 40, _hoisted_83$3),
                    createBaseVNode("span", _hoisted_84$3, toDisplayString(emitter.emissionRate.toFixed(1)) + "/s", 1)
                  ]),
                  createBaseVNode("div", _hoisted_85$3, [
                    _cache[102] || (_cache[102] = createBaseVNode("label", { title: "How long each particle lives in frames (at 16fps: 16 frames = 1 second)." }, "Lifetime", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.particleLifetime,
                      min: "1",
                      max: "300",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "particleLifetime", Number($event.target.value))
                    }, null, 40, _hoisted_86$3),
                    createBaseVNode("span", _hoisted_87$3, toDisplayString(emitter.particleLifetime) + "f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_88$3, [
                    _cache[103] || (_cache[103] = createBaseVNode("label", { title: "Percentage of max particles to spawn immediately at frame 0. Creates an instant 'explosion' of particles." }, "Initial Burst", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.initialBurst,
                      min: "0",
                      max: "1",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "initialBurst", Number($event.target.value))
                    }, null, 40, _hoisted_89$3),
                    createBaseVNode("span", _hoisted_90$3, toDisplayString((emitter.initialBurst * 100).toFixed(0)) + "%", 1)
                  ]),
                  createBaseVNode("div", _hoisted_91$2, [
                    createBaseVNode("label", _hoisted_92$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.burstOnBeat,
                        onChange: ($event) => updateEmitter(emitter.id, "burstOnBeat", $event.target.checked)
                      }, null, 40, _hoisted_93$2),
                      _cache[104] || (_cache[104] = createTextVNode(" Burst on Beat ", -1))
                    ])
                  ]),
                  emitter.burstOnBeat ? (openBlock(), createElementBlock("div", _hoisted_94$2, [
                    _cache[105] || (_cache[105] = createBaseVNode("label", { title: "Number of particles to emit on each detected audio beat." }, "Burst Count", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.burstCount,
                      min: "1",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "burstCount", Number($event.target.value))
                    }, null, 40, _hoisted_95$1),
                    createBaseVNode("span", _hoisted_96$1, toDisplayString(emitter.burstCount), 1)
                  ])) : createCommentVNode("", true),
                  _cache[124] || (_cache[124] = createBaseVNode("div", { class: "subsection-divider" }, "Emitter Shape", -1)),
                  createBaseVNode("div", _hoisted_97$1, [
                    _cache[107] || (_cache[107] = createBaseVNode("label", { title: "Geometry from which particles are emitted. Point = single location, others distribute particles across the shape." }, "Shape", -1)),
                    createBaseVNode("select", {
                      value: emitter.shape || "point",
                      onChange: ($event) => updateEmitter(emitter.id, "shape", $event.target.value)
                    }, [..._cache[106] || (_cache[106] = [
                      createStaticVNode('<option value="point" data-v-2cffc2c6>Point</option><option value="line" data-v-2cffc2c6>Line</option><option value="circle" data-v-2cffc2c6>Circle</option><option value="box" data-v-2cffc2c6>Box</option><option value="sphere" data-v-2cffc2c6>Sphere</option><option value="cone" data-v-2cffc2c6>Cone</option><option value="ring" data-v-2cffc2c6>Ring</option><option value="spline" data-v-2cffc2c6>Spline Path</option><option value="image" data-v-2cffc2c6>Image/Mask</option><option value="depthEdge" data-v-2cffc2c6>Depth Edges</option>', 10)
                    ])], 40, _hoisted_98$1)
                  ]),
                  emitter.shape === "circle" || emitter.shape === "sphere" || emitter.shape === "ring" ? (openBlock(), createElementBlock("div", _hoisted_99$1, [
                    _cache[108] || (_cache[108] = createBaseVNode("label", { title: "Outer radius of the emission shape as a fraction of composition size." }, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeRadius || 0.1,
                      min: "0.01",
                      max: "0.5",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeRadius", Number($event.target.value))
                    }, null, 40, _hoisted_100$1),
                    createBaseVNode("span", _hoisted_101$1, toDisplayString((emitter.shapeRadius || 0.1).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "ring" ? (openBlock(), createElementBlock("div", _hoisted_102$1, [
                    _cache[109] || (_cache[109] = createBaseVNode("label", { title: "Inner radius of the ring. Particles emit in the area between inner and outer radius." }, "Inner Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeInnerRadius || 0.05,
                      min: "0",
                      max: "0.4",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeInnerRadius", Number($event.target.value))
                    }, null, 40, _hoisted_103),
                    createBaseVNode("span", _hoisted_104, toDisplayString((emitter.shapeInnerRadius || 0.05).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "box" ? (openBlock(), createElementBlock("div", _hoisted_105, [
                    _cache[110] || (_cache[110] = createBaseVNode("label", { title: "Width of the box emission area as a fraction of composition width." }, "Width", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeWidth || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeWidth", Number($event.target.value))
                    }, null, 40, _hoisted_106),
                    createBaseVNode("span", _hoisted_107, toDisplayString((emitter.shapeWidth || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "box" ? (openBlock(), createElementBlock("div", _hoisted_108, [
                    _cache[111] || (_cache[111] = createBaseVNode("label", { title: "Height of the box emission area as a fraction of composition height." }, "Height", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeHeight || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeHeight", Number($event.target.value))
                    }, null, 40, _hoisted_109),
                    createBaseVNode("span", _hoisted_110, toDisplayString((emitter.shapeHeight || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "line" ? (openBlock(), createElementBlock("div", _hoisted_111, [
                    _cache[112] || (_cache[112] = createBaseVNode("label", { title: "Length of the line emission area as a fraction of composition size." }, "Length", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeWidth || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeWidth", Number($event.target.value))
                    }, null, 40, _hoisted_112),
                    createBaseVNode("span", _hoisted_113, toDisplayString((emitter.shapeWidth || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "cone" ? (openBlock(), createElementBlock("div", _hoisted_114, [
                    _cache[113] || (_cache[113] = createBaseVNode("label", { title: "Opening angle of the cone in degrees. 90 = hemisphere, 180 = full sphere." }, "Cone Angle", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.coneAngle || 45,
                      min: "1",
                      max: "180",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "coneAngle", Number($event.target.value))
                    }, null, 40, _hoisted_115),
                    createBaseVNode("span", _hoisted_116, toDisplayString(emitter.coneAngle || 45) + "", 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "cone" ? (openBlock(), createElementBlock("div", _hoisted_117, [
                    _cache[114] || (_cache[114] = createBaseVNode("label", { title: "Base radius of the cone as a fraction of composition size." }, "Cone Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.coneRadius || 0.1,
                      min: "0.01",
                      max: "0.5",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "coneRadius", Number($event.target.value))
                    }, null, 40, _hoisted_118),
                    createBaseVNode("span", _hoisted_119, toDisplayString((emitter.coneRadius || 0.1).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "image" ? (openBlock(), createElementBlock("div", _hoisted_120, [
                    createBaseVNode("div", _hoisted_121, [
                      _cache[116] || (_cache[116] = createBaseVNode("label", { title: "Select a layer to use as the emission mask. Particles emit from non-transparent pixels." }, "Source Layer", -1)),
                      createBaseVNode("select", {
                        value: emitter.imageSourceLayerId || "",
                        onChange: ($event) => updateEmitter(emitter.id, "imageSourceLayerId", $event.target.value || null)
                      }, [
                        _cache[115] || (_cache[115] = createBaseVNode("option", { value: "" }, "Select layer...", -1)),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                          return openBlock(), createElementBlock("option", {
                            key: layer.id,
                            value: layer.id
                          }, toDisplayString(layer.name), 9, _hoisted_123);
                        }), 128))
                      ], 40, _hoisted_122)
                    ]),
                    createBaseVNode("div", _hoisted_124, [
                      _cache[117] || (_cache[117] = createBaseVNode("label", { title: "Minimum alpha value (0-1) for a pixel to be considered for emission." }, "Alpha Threshold", -1)),
                      createBaseVNode("input", {
                        type: "range",
                        value: emitter.emissionThreshold || 0.1,
                        min: "0.01",
                        max: "1",
                        step: "0.01",
                        onInput: ($event) => updateEmitter(emitter.id, "emissionThreshold", Number($event.target.value))
                      }, null, 40, _hoisted_125),
                      createBaseVNode("span", _hoisted_126, toDisplayString((emitter.emissionThreshold || 0.1).toFixed(2)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_127, [
                      createBaseVNode("label", _hoisted_128, [
                        createBaseVNode("input", {
                          type: "checkbox",
                          checked: emitter.emitFromMaskEdge,
                          onChange: ($event) => updateEmitter(emitter.id, "emitFromMaskEdge", $event.target.checked)
                        }, null, 40, _hoisted_129),
                        _cache[118] || (_cache[118] = createTextVNode(" Edge Detection ", -1))
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  emitter.shape === "depthEdge" ? (openBlock(), createElementBlock("div", _hoisted_130, [
                    createBaseVNode("div", _hoisted_131, [
                      _cache[120] || (_cache[120] = createBaseVNode("label", { title: "Select a depth layer to use for edge detection. Particles emit from depth discontinuities (silhouette edges)." }, "Depth Layer", -1)),
                      createBaseVNode("select", {
                        value: emitter.depthSourceLayerId || "",
                        onChange: ($event) => updateEmitter(emitter.id, "depthSourceLayerId", $event.target.value || null)
                      }, [
                        _cache[119] || (_cache[119] = createBaseVNode("option", { value: "" }, "Select depth layer...", -1)),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(depthLayers.value, (layer) => {
                          return openBlock(), createElementBlock("option", {
                            key: layer.id,
                            value: layer.id
                          }, toDisplayString(layer.name), 9, _hoisted_133);
                        }), 128))
                      ], 40, _hoisted_132)
                    ]),
                    createBaseVNode("div", _hoisted_134, [
                      _cache[121] || (_cache[121] = createBaseVNode("label", { title: "Minimum depth gradient magnitude to be considered an edge. Lower = more edges detected." }, "Edge Threshold", -1)),
                      createBaseVNode("input", {
                        type: "range",
                        value: emitter.emissionThreshold || 0.05,
                        min: "0.01",
                        max: "0.5",
                        step: "0.01",
                        onInput: ($event) => updateEmitter(emitter.id, "emissionThreshold", Number($event.target.value))
                      }, null, 40, _hoisted_135),
                      createBaseVNode("span", _hoisted_136, toDisplayString((emitter.emissionThreshold || 0.05).toFixed(2)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_137, [
                      _cache[122] || (_cache[122] = createBaseVNode("label", { title: "Scale factor for converting depth values to Z position. Higher = more 3D separation." }, "Depth Scale", -1)),
                      createBaseVNode("input", {
                        type: "range",
                        value: emitter.depthScale || 500,
                        min: "0",
                        max: "2000",
                        step: "50",
                        onInput: ($event) => updateEmitter(emitter.id, "depthScale", Number($event.target.value))
                      }, null, 40, _hoisted_138),
                      createBaseVNode("span", _hoisted_139, toDisplayString(emitter.depthScale || 500), 1)
                    ])
                  ])) : createCommentVNode("", true),
                  emitter.shape !== "point" && emitter.shape !== "spline" && emitter.shape !== "image" && emitter.shape !== "depthEdge" ? (openBlock(), createElementBlock("div", _hoisted_140, [
                    createBaseVNode("label", _hoisted_141, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.emitFromEdge,
                        onChange: ($event) => updateEmitter(emitter.id, "emitFromEdge", $event.target.checked)
                      }, null, 40, _hoisted_142),
                      _cache[123] || (_cache[123] = createTextVNode(" Emit from Edge Only ", -1))
                    ])
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            emitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_143, " No emitters. Click + to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_144, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[21] || (_cache[21] = ($event) => toggleSection("forces"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[125] || (_cache[125] = createBaseVNode("span", null, "Force Fields", -1))
          ]),
          expandedSections.value.has("forces") ? (openBlock(), createElementBlock("div", _hoisted_145, [
            createBaseVNode("div", _hoisted_146, [
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "wells" }),
                onClick: _cache[22] || (_cache[22] = ($event) => forceTab.value = "wells")
              }, " Gravity Wells ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "vortices" }),
                onClick: _cache[23] || (_cache[23] = ($event) => forceTab.value = "vortices")
              }, " Vortices ", 2)
            ]),
            forceTab.value === "wells" ? (openBlock(), createElementBlock("div", _hoisted_147, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addGravityWell
              }, [..._cache[126] || (_cache[126] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Gravity Well ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(gravityWells.value, (well) => {
                return openBlock(), createElementBlock("div", {
                  key: well.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_148, [
                    createBaseVNode("input", {
                      type: "text",
                      value: well.name,
                      onInput: ($event) => updateGravityWell(well.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_149),
                    createBaseVNode("label", _hoisted_150, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: well.enabled,
                        onChange: ($event) => updateGravityWell(well.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_151)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeGravityWell(well.id)
                    }, [..._cache[127] || (_cache[127] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_152)
                  ]),
                  createBaseVNode("div", _hoisted_153, [
                    _cache[128] || (_cache[128] = createBaseVNode("label", { title: "Horizontal position of the gravity well. 0 = left edge, 0.5 = center, 1 = right edge." }, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_154),
                    createBaseVNode("span", _hoisted_155, toDisplayString(well.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_156, [
                    _cache[129] || (_cache[129] = createBaseVNode("label", { title: "Vertical position of the gravity well. 0 = top edge, 0.5 = center, 1 = bottom edge." }, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_157),
                    createBaseVNode("span", _hoisted_158, toDisplayString(well.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_159, [
                    _cache[130] || (_cache[130] = createBaseVNode("label", { title: "Attraction force strength. Positive = attract particles toward center, negative = repel particles away." }, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.strength,
                      min: "-1000",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateGravityWell(well.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_160),
                    createBaseVNode("span", _hoisted_161, toDisplayString(well.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_162, [
                    _cache[131] || (_cache[131] = createBaseVNode("label", { title: "Area of influence as a fraction of composition size. Particles outside this radius are unaffected." }, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_163),
                    createBaseVNode("span", _hoisted_164, toDisplayString(well.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_165, [
                    _cache[133] || (_cache[133] = createBaseVNode("label", { title: "How force decreases with distance. Linear = gradual, Quadratic = realistic physics, Constant = uniform force." }, "Falloff", -1)),
                    createBaseVNode("select", {
                      value: well.falloff,
                      onChange: ($event) => updateGravityWell(well.id, "falloff", $event.target.value)
                    }, [..._cache[132] || (_cache[132] = [
                      createBaseVNode("option", { value: "linear" }, "Linear", -1),
                      createBaseVNode("option", { value: "quadratic" }, "Quadratic", -1),
                      createBaseVNode("option", { value: "constant" }, "Constant", -1)
                    ])], 40, _hoisted_166)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            forceTab.value === "vortices" ? (openBlock(), createElementBlock("div", _hoisted_167, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addVortex
              }, [..._cache[134] || (_cache[134] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Vortex ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(vortices.value, (vortex) => {
                return openBlock(), createElementBlock("div", {
                  key: vortex.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_168, [
                    createBaseVNode("input", {
                      type: "text",
                      value: vortex.name,
                      onInput: ($event) => updateVortex(vortex.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_169),
                    createBaseVNode("label", _hoisted_170, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: vortex.enabled,
                        onChange: ($event) => updateVortex(vortex.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_171)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeVortex(vortex.id)
                    }, [..._cache[135] || (_cache[135] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_172)
                  ]),
                  createBaseVNode("div", _hoisted_173, [
                    _cache[136] || (_cache[136] = createBaseVNode("label", { title: "Horizontal position of the vortex center. 0 = left edge, 0.5 = center, 1 = right edge." }, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_174),
                    createBaseVNode("span", _hoisted_175, toDisplayString(vortex.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_176, [
                    _cache[137] || (_cache[137] = createBaseVNode("label", { title: "Vertical position of the vortex center. 0 = top edge, 0.5 = center, 1 = bottom edge." }, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_177),
                    createBaseVNode("span", _hoisted_178, toDisplayString(vortex.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_179, [
                    _cache[138] || (_cache[138] = createBaseVNode("label", { title: "Overall strength of the vortex force applied to particles." }, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.strength,
                      min: "0",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateVortex(vortex.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_180),
                    createBaseVNode("span", _hoisted_181, toDisplayString(vortex.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_182, [
                    _cache[139] || (_cache[139] = createBaseVNode("label", { title: "Area of influence as a fraction of composition size. Particles outside this radius are unaffected." }, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_183),
                    createBaseVNode("span", _hoisted_184, toDisplayString(vortex.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_185, [
                    _cache[140] || (_cache[140] = createBaseVNode("label", { title: "Angular velocity of the swirl in degrees per frame. Higher values create faster spinning." }, "Rotation Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.rotationSpeed,
                      min: "0",
                      max: "50",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "rotationSpeed", Number($event.target.value))
                    }, null, 40, _hoisted_186),
                    createBaseVNode("span", _hoisted_187, toDisplayString(vortex.rotationSpeed) + "/f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_188, [
                    _cache[141] || (_cache[141] = createBaseVNode("label", { title: "Force pulling particles toward the vortex center. Creates a spiral effect when combined with rotation." }, "Inward Pull", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.inwardPull,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "inwardPull", Number($event.target.value))
                    }, null, 40, _hoisted_189),
                    createBaseVNode("span", _hoisted_190, toDisplayString(vortex.inwardPull), 1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_191, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[24] || (_cache[24] = ($event) => toggleSection("turbulence"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[143] || (_cache[143] = createBaseVNode("span", null, "Turbulence", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addTurbulence, ["stop"]),
              title: "Add Turbulence Field"
            }, [..._cache[142] || (_cache[142] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("turbulence") ? (openBlock(), createElementBlock("div", _hoisted_192, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(turbulenceFields.value, (turb) => {
              return openBlock(), createElementBlock("div", {
                key: turb.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_193, [
                  _cache[145] || (_cache[145] = createBaseVNode("span", { class: "force-label" }, "Turbulence Field", -1)),
                  createBaseVNode("label", _hoisted_194, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: turb.enabled,
                      onChange: ($event) => updateTurbulence(turb.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_195)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeTurbulence(turb.id)
                  }, [..._cache[144] || (_cache[144] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_196)
                ]),
                createBaseVNode("div", _hoisted_197, [
                  _cache[146] || (_cache[146] = createBaseVNode("label", { title: "Size of the noise pattern. Smaller values = fine, detailed turbulence. Larger values = broad, sweeping motion." }, "Scale", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.scale,
                    min: "0.001",
                    max: "0.02",
                    step: "0.001",
                    onInput: ($event) => updateTurbulence(turb.id, "scale", Number($event.target.value))
                  }, null, 40, _hoisted_198),
                  createBaseVNode("span", _hoisted_199, toDisplayString(turb.scale.toFixed(3)), 1)
                ]),
                createBaseVNode("div", _hoisted_200, [
                  _cache[147] || (_cache[147] = createBaseVNode("label", { title: "How strongly turbulence affects particle movement. Higher values create more chaotic motion." }, "Strength", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.strength,
                    min: "0",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateTurbulence(turb.id, "strength", Number($event.target.value))
                  }, null, 40, _hoisted_201),
                  createBaseVNode("span", _hoisted_202, toDisplayString(turb.strength), 1)
                ]),
                createBaseVNode("div", _hoisted_203, [
                  _cache[148] || (_cache[148] = createBaseVNode("label", { title: "How fast the turbulence pattern changes over time. 0 = static noise, higher = animated turbulence." }, "Evolution", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.evolutionSpeed,
                    min: "0",
                    max: "1",
                    step: "0.01",
                    onInput: ($event) => updateTurbulence(turb.id, "evolutionSpeed", Number($event.target.value))
                  }, null, 40, _hoisted_204),
                  createBaseVNode("span", _hoisted_205, toDisplayString(turb.evolutionSpeed.toFixed(2)), 1)
                ])
              ]);
            }), 128)),
            turbulenceFields.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_206, " No turbulence fields. Add one for organic particle motion. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_207, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[25] || (_cache[25] = ($event) => toggleSection("flocking"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("flocking") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[149] || (_cache[149] = createBaseVNode("span", null, "Flocking", -1))
          ]),
          expandedSections.value.has("flocking") ? (openBlock(), createElementBlock("div", _hoisted_208, [
            createBaseVNode("div", _hoisted_209, [
              _cache[150] || (_cache[150] = createBaseVNode("label", { title: "Enable flocking (boids) behavior. Particles will exhibit collective movement patterns." }, "Enabled", -1)),
              createBaseVNode("input", {
                type: "checkbox",
                checked: flocking.value.enabled,
                onChange: _cache[26] || (_cache[26] = ($event) => updateFlocking("enabled", $event.target.checked))
              }, null, 40, _hoisted_210)
            ]),
            flocking.value.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _cache[160] || (_cache[160] = createBaseVNode("div", { class: "subsection-label" }, "Separation", -1)),
              createBaseVNode("div", _hoisted_211, [
                _cache[151] || (_cache[151] = createBaseVNode("label", { title: "How strongly particles avoid crowding each other." }, "Weight", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.separationWeight,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: _cache[27] || (_cache[27] = ($event) => updateFlocking("separationWeight", Number($event.target.value)))
                }, null, 40, _hoisted_212),
                createBaseVNode("span", _hoisted_213, toDisplayString(flocking.value.separationWeight), 1)
              ]),
              createBaseVNode("div", _hoisted_214, [
                _cache[152] || (_cache[152] = createBaseVNode("label", { title: "Distance at which particles start avoiding each other." }, "Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.separationRadius,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: _cache[28] || (_cache[28] = ($event) => updateFlocking("separationRadius", Number($event.target.value)))
                }, null, 40, _hoisted_215),
                createBaseVNode("span", _hoisted_216, toDisplayString(flocking.value.separationRadius) + "px", 1)
              ]),
              _cache[161] || (_cache[161] = createBaseVNode("div", { class: "subsection-label" }, "Alignment", -1)),
              createBaseVNode("div", _hoisted_217, [
                _cache[153] || (_cache[153] = createBaseVNode("label", { title: "How strongly particles try to match their neighbors' direction." }, "Weight", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.alignmentWeight,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: _cache[29] || (_cache[29] = ($event) => updateFlocking("alignmentWeight", Number($event.target.value)))
                }, null, 40, _hoisted_218),
                createBaseVNode("span", _hoisted_219, toDisplayString(flocking.value.alignmentWeight), 1)
              ]),
              createBaseVNode("div", _hoisted_220, [
                _cache[154] || (_cache[154] = createBaseVNode("label", { title: "Distance to look for neighbors to align with." }, "Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.alignmentRadius,
                  min: "1",
                  max: "200",
                  step: "1",
                  onInput: _cache[30] || (_cache[30] = ($event) => updateFlocking("alignmentRadius", Number($event.target.value)))
                }, null, 40, _hoisted_221),
                createBaseVNode("span", _hoisted_222, toDisplayString(flocking.value.alignmentRadius) + "px", 1)
              ]),
              _cache[162] || (_cache[162] = createBaseVNode("div", { class: "subsection-label" }, "Cohesion", -1)),
              createBaseVNode("div", _hoisted_223, [
                _cache[155] || (_cache[155] = createBaseVNode("label", { title: "How strongly particles are attracted to the center of nearby particles." }, "Weight", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.cohesionWeight,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: _cache[31] || (_cache[31] = ($event) => updateFlocking("cohesionWeight", Number($event.target.value)))
                }, null, 40, _hoisted_224),
                createBaseVNode("span", _hoisted_225, toDisplayString(flocking.value.cohesionWeight), 1)
              ]),
              createBaseVNode("div", _hoisted_226, [
                _cache[156] || (_cache[156] = createBaseVNode("label", { title: "Distance to look for neighbors for cohesion." }, "Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.cohesionRadius,
                  min: "1",
                  max: "200",
                  step: "1",
                  onInput: _cache[32] || (_cache[32] = ($event) => updateFlocking("cohesionRadius", Number($event.target.value)))
                }, null, 40, _hoisted_227),
                createBaseVNode("span", _hoisted_228, toDisplayString(flocking.value.cohesionRadius) + "px", 1)
              ]),
              _cache[163] || (_cache[163] = createBaseVNode("div", { class: "subsection-label" }, "Limits", -1)),
              createBaseVNode("div", _hoisted_229, [
                _cache[157] || (_cache[157] = createBaseVNode("label", { title: "Maximum speed particles can achieve." }, "Max Speed", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.maxSpeed,
                  min: "10",
                  max: "500",
                  step: "10",
                  onInput: _cache[33] || (_cache[33] = ($event) => updateFlocking("maxSpeed", Number($event.target.value)))
                }, null, 40, _hoisted_230),
                createBaseVNode("span", _hoisted_231, toDisplayString(flocking.value.maxSpeed), 1)
              ]),
              createBaseVNode("div", _hoisted_232, [
                _cache[158] || (_cache[158] = createBaseVNode("label", { title: "Maximum steering force applied to particles." }, "Max Force", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.maxForce,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: _cache[34] || (_cache[34] = ($event) => updateFlocking("maxForce", Number($event.target.value)))
                }, null, 40, _hoisted_233),
                createBaseVNode("span", _hoisted_234, toDisplayString(flocking.value.maxForce), 1)
              ]),
              createBaseVNode("div", _hoisted_235, [
                _cache[159] || (_cache[159] = createBaseVNode("label", { title: "Field of view for detecting neighbors (degrees)." }, "Perception", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: flocking.value.perceptionAngle,
                  min: "30",
                  max: "360",
                  step: "10",
                  onInput: _cache[35] || (_cache[35] = ($event) => updateFlocking("perceptionAngle", Number($event.target.value)))
                }, null, 40, _hoisted_236),
                createBaseVNode("span", _hoisted_237, toDisplayString(flocking.value.perceptionAngle) + "", 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_238, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[36] || (_cache[36] = ($event) => toggleSection("collision"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("collision") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[164] || (_cache[164] = createBaseVNode("span", null, "Collision", -1))
          ]),
          expandedSections.value.has("collision") ? (openBlock(), createElementBlock("div", _hoisted_239, [
            createBaseVNode("div", _hoisted_240, [
              _cache[165] || (_cache[165] = createBaseVNode("label", { title: "Enable collision detection for particles." }, "Enabled", -1)),
              createBaseVNode("input", {
                type: "checkbox",
                checked: collision.value.enabled,
                onChange: _cache[37] || (_cache[37] = ($event) => updateCollision("enabled", $event.target.checked))
              }, null, 40, _hoisted_241)
            ]),
            collision.value.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _cache[174] || (_cache[174] = createBaseVNode("div", { class: "subsection-label" }, "Particle Collisions", -1)),
              createBaseVNode("div", _hoisted_242, [
                _cache[166] || (_cache[166] = createBaseVNode("label", { title: "Enable particle-to-particle collision (performance intensive)." }, "P2P Collision", -1)),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: collision.value.particleCollision,
                  onChange: _cache[38] || (_cache[38] = ($event) => updateCollision("particleCollision", $event.target.checked))
                }, null, 40, _hoisted_243)
              ]),
              createBaseVNode("div", _hoisted_244, [
                _cache[167] || (_cache[167] = createBaseVNode("label", { title: "Collision radius around each particle." }, "Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: collision.value.particleRadius,
                  min: "1",
                  max: "50",
                  step: "1",
                  onInput: _cache[39] || (_cache[39] = ($event) => updateCollision("particleRadius", Number($event.target.value)))
                }, null, 40, _hoisted_245),
                createBaseVNode("span", _hoisted_246, toDisplayString(collision.value.particleRadius) + "px", 1)
              ]),
              createBaseVNode("div", _hoisted_247, [
                _cache[168] || (_cache[168] = createBaseVNode("label", { title: "How much velocity is retained after collision (0 = none, 1 = full)." }, "Bounciness", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: collision.value.bounciness,
                  min: "0",
                  max: "1",
                  step: "0.05",
                  onInput: _cache[40] || (_cache[40] = ($event) => updateCollision("bounciness", Number($event.target.value)))
                }, null, 40, _hoisted_248),
                createBaseVNode("span", _hoisted_249, toDisplayString(collision.value.bounciness.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_250, [
                _cache[169] || (_cache[169] = createBaseVNode("label", { title: "Velocity reduction on collision (0 = none, 1 = full stop)." }, "Friction", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: collision.value.friction,
                  min: "0",
                  max: "1",
                  step: "0.05",
                  onInput: _cache[41] || (_cache[41] = ($event) => updateCollision("friction", Number($event.target.value)))
                }, null, 40, _hoisted_251),
                createBaseVNode("span", _hoisted_252, toDisplayString(collision.value.friction.toFixed(2)), 1)
              ]),
              _cache[175] || (_cache[175] = createBaseVNode("div", { class: "subsection-label" }, "Boundary", -1)),
              createBaseVNode("div", _hoisted_253, [
                _cache[170] || (_cache[170] = createBaseVNode("label", { title: "Enable boundary collision at composition edges." }, "Boundary", -1)),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: collision.value.boundaryEnabled,
                  onChange: _cache[42] || (_cache[42] = ($event) => updateCollision("boundaryEnabled", $event.target.checked))
                }, null, 40, _hoisted_254)
              ]),
              createBaseVNode("div", _hoisted_255, [
                _cache[172] || (_cache[172] = createBaseVNode("label", { title: "What happens when particles hit the boundary." }, "Behavior", -1)),
                createBaseVNode("select", {
                  value: collision.value.boundaryBehavior,
                  onChange: _cache[43] || (_cache[43] = ($event) => updateCollision("boundaryBehavior", $event.target.value))
                }, [..._cache[171] || (_cache[171] = [
                  createBaseVNode("option", { value: "none" }, "None", -1),
                  createBaseVNode("option", { value: "bounce" }, "Bounce", -1),
                  createBaseVNode("option", { value: "wrap" }, "Wrap Around", -1),
                  createBaseVNode("option", { value: "kill" }, "Kill", -1)
                ])], 40, _hoisted_256)
              ]),
              createBaseVNode("div", _hoisted_257, [
                _cache[173] || (_cache[173] = createBaseVNode("label", { title: "Distance from composition edge for boundary." }, "Padding", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: collision.value.boundaryPadding,
                  min: "0",
                  max: "100",
                  step: "5",
                  onInput: _cache[44] || (_cache[44] = ($event) => updateCollision("boundaryPadding", Number($event.target.value)))
                }, null, 40, _hoisted_258),
                createBaseVNode("span", _hoisted_259, toDisplayString(collision.value.boundaryPadding) + "px", 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_260, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[45] || (_cache[45] = ($event) => toggleSection("subEmitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[177] || (_cache[177] = createBaseVNode("span", null, "Sub-Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addSubEmitter, ["stop"]),
              title: "Add Sub-Emitter"
            }, [..._cache[176] || (_cache[176] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("subEmitters") ? (openBlock(), createElementBlock("div", _hoisted_261, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(subEmitters.value, (sub) => {
              return openBlock(), createElementBlock("div", {
                key: sub.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_262, [
                  createBaseVNode("select", {
                    value: sub.parentEmitterId,
                    onChange: ($event) => updateSubEmitter(sub.id, "parentEmitterId", $event.target.value),
                    class: "sub-emitter-parent"
                  }, [
                    _cache[178] || (_cache[178] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_264);
                    }), 128))
                  ], 40, _hoisted_263),
                  createBaseVNode("label", _hoisted_265, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: sub.enabled,
                      onChange: ($event) => updateSubEmitter(sub.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_266)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeSubEmitter(sub.id)
                  }, [..._cache[179] || (_cache[179] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_267)
                ]),
                createBaseVNode("div", _hoisted_268, [
                  _cache[181] || (_cache[181] = createBaseVNode("label", { title: "Event that triggers sub-particle emission. 'On Death' spawns particles when parent particles expire." }, "Trigger", -1)),
                  createBaseVNode("select", {
                    value: sub.trigger,
                    onChange: ($event) => updateSubEmitter(sub.id, "trigger", $event.target.value)
                  }, [..._cache[180] || (_cache[180] = [
                    createBaseVNode("option", { value: "death" }, "On Death", -1)
                  ])], 40, _hoisted_269)
                ]),
                createBaseVNode("div", _hoisted_270, [
                  _cache[182] || (_cache[182] = createBaseVNode("label", { title: "Number of sub-particles spawned when the trigger event occurs." }, "Spawn Count", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spawnCount,
                    min: "1",
                    max: "10",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "spawnCount", Number($event.target.value))
                  }, null, 40, _hoisted_271),
                  createBaseVNode("span", _hoisted_272, toDisplayString(sub.spawnCount), 1)
                ]),
                createBaseVNode("div", _hoisted_273, [
                  _cache[183] || (_cache[183] = createBaseVNode("label", { title: "How much of the parent particle's velocity is passed to sub-particles. 0% = independent, 100% = same direction." }, "Inherit Velocity", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.inheritVelocity,
                    min: "0",
                    max: "1",
                    step: "0.1",
                    onInput: ($event) => updateSubEmitter(sub.id, "inheritVelocity", Number($event.target.value))
                  }, null, 40, _hoisted_274),
                  createBaseVNode("span", _hoisted_275, toDisplayString((sub.inheritVelocity * 100).toFixed(0)) + "%", 1)
                ]),
                createBaseVNode("div", _hoisted_276, [
                  _cache[184] || (_cache[184] = createBaseVNode("label", { title: "Diameter of sub-particles in pixels. Often smaller than parent particles for sparks/debris effects." }, "Size", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.size,
                    min: "1",
                    max: "100",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "size", Number($event.target.value))
                  }, null, 40, _hoisted_277),
                  createBaseVNode("span", _hoisted_278, toDisplayString(sub.size) + "px", 1)
                ]),
                createBaseVNode("div", _hoisted_279, [
                  _cache[185] || (_cache[185] = createBaseVNode("label", { title: "How long sub-particles live in frames. Usually shorter than parent particles." }, "Lifetime", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.lifetime,
                    min: "1",
                    max: "120",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "lifetime", Number($event.target.value))
                  }, null, 40, _hoisted_280),
                  createBaseVNode("span", _hoisted_281, toDisplayString(sub.lifetime) + "f", 1)
                ]),
                createBaseVNode("div", _hoisted_282, [
                  _cache[186] || (_cache[186] = createBaseVNode("label", { title: "Initial velocity of sub-particles in pixels per second." }, "Speed", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.speed,
                    min: "1",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateSubEmitter(sub.id, "speed", Number($event.target.value))
                  }, null, 40, _hoisted_283),
                  createBaseVNode("span", _hoisted_284, toDisplayString(sub.speed), 1)
                ]),
                createBaseVNode("div", _hoisted_285, [
                  _cache[187] || (_cache[187] = createBaseVNode("label", { title: "Angular spread of sub-particle emission. 360 = emit in all directions (explosion), 0 = emit in inherited direction." }, "Spread", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spread,
                    min: "0",
                    max: "360",
                    step: "5",
                    onInput: ($event) => updateSubEmitter(sub.id, "spread", Number($event.target.value))
                  }, null, 40, _hoisted_286),
                  createBaseVNode("span", _hoisted_287, toDisplayString(sub.spread) + "", 1)
                ]),
                createBaseVNode("div", _hoisted_288, [
                  _cache[188] || (_cache[188] = createBaseVNode("label", { title: "Color of sub-particles. Can differ from parent for visual variety." }, "Color", -1)),
                  createBaseVNode("input", {
                    type: "color",
                    value: rgbToHex(sub.color),
                    onInput: ($event) => updateSubEmitterColor(sub.id, $event.target.value)
                  }, null, 40, _hoisted_289)
                ])
              ]);
            }), 128)),
            subEmitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_290, " No sub-emitters. Add one for particle death effects. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_291, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[46] || (_cache[46] = ($event) => toggleSection("modulations"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[190] || (_cache[190] = createBaseVNode("span", null, "Modulations", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addModulation, ["stop"]),
              title: "Add Modulation"
            }, [..._cache[189] || (_cache[189] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("modulations") ? (openBlock(), createElementBlock("div", _hoisted_292, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(modulations.value, (mod) => {
              return openBlock(), createElementBlock("div", {
                key: mod.id,
                class: "modulation-item"
              }, [
                createBaseVNode("div", _hoisted_293, [
                  createBaseVNode("select", {
                    value: mod.emitterId,
                    onChange: ($event) => updateModulation(mod.id, "emitterId", $event.target.value)
                  }, [
                    _cache[191] || (_cache[191] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_295);
                    }), 128))
                  ], 40, _hoisted_294),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeModulation(mod.id)
                  }, [..._cache[192] || (_cache[192] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_296)
                ]),
                createBaseVNode("div", _hoisted_297, [
                  _cache[194] || (_cache[194] = createBaseVNode("label", { title: "Which particle property to animate over the particle's lifetime." }, "Property", -1)),
                  createBaseVNode("select", {
                    value: mod.property,
                    onChange: ($event) => updateModulation(mod.id, "property", $event.target.value)
                  }, [..._cache[193] || (_cache[193] = [
                    createStaticVNode('<option value="size" data-v-2cffc2c6>Size</option><option value="speed" data-v-2cffc2c6>Speed</option><option value="opacity" data-v-2cffc2c6>Opacity</option><option value="colorR" data-v-2cffc2c6>Color R</option><option value="colorG" data-v-2cffc2c6>Color G</option><option value="colorB" data-v-2cffc2c6>Color B</option>', 6)
                  ])], 40, _hoisted_298)
                ]),
                createBaseVNode("div", _hoisted_299, [
                  _cache[195] || (_cache[195] = createBaseVNode("label", { title: "Value of the property when the particle is born." }, "Start Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.startValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "startValue", Number($event.target.value))
                  }, null, 40, _hoisted_300)
                ]),
                createBaseVNode("div", _hoisted_301, [
                  _cache[196] || (_cache[196] = createBaseVNode("label", { title: "Value of the property when the particle dies." }, "End Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.endValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "endValue", Number($event.target.value))
                  }, null, 40, _hoisted_302)
                ]),
                createBaseVNode("div", _hoisted_303, [
                  _cache[198] || (_cache[198] = createBaseVNode("label", { title: "Interpolation curve between start and end values. Linear = constant rate, Ease Out = fast then slow." }, "Easing", -1)),
                  createBaseVNode("select", {
                    value: mod.easing,
                    onChange: ($event) => updateModulation(mod.id, "easing", $event.target.value)
                  }, [..._cache[197] || (_cache[197] = [
                    createStaticVNode('<option value="linear" data-v-2cffc2c6>Linear</option><option value="easeIn" data-v-2cffc2c6>Ease In</option><option value="easeOut" data-v-2cffc2c6>Ease Out</option><option value="easeInOut" data-v-2cffc2c6>Ease In Out</option><option value="bounce" data-v-2cffc2c6>Bounce</option><option value="elastic" data-v-2cffc2c6>Elastic</option>', 6)
                  ])], 40, _hoisted_304)
                ])
              ]);
            }), 128)),
            modulations.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_305, " No modulations. Add one to animate particle properties over lifetime. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_306, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[47] || (_cache[47] = ($event) => toggleSection("render"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[199] || (_cache[199] = createBaseVNode("span", null, "Render Options", -1))
          ]),
          expandedSections.value.has("render") ? (openBlock(), createElementBlock("div", _hoisted_307, [
            createBaseVNode("div", _hoisted_308, [
              _cache[201] || (_cache[201] = createBaseVNode("label", { title: "How particles blend with the background. Additive = bright/glowing, Multiply = darken, Screen = lighten." }, "Blend Mode", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.blendMode,
                onChange: _cache[48] || (_cache[48] = ($event) => updateRenderOption("blendMode", $event.target.value))
              }, [..._cache[200] || (_cache[200] = [
                createBaseVNode("option", { value: "normal" }, "Normal", -1),
                createBaseVNode("option", { value: "additive" }, "Additive", -1),
                createBaseVNode("option", { value: "multiply" }, "Multiply", -1),
                createBaseVNode("option", { value: "screen" }, "Screen", -1)
              ])], 40, _hoisted_309)
            ]),
            createBaseVNode("div", _hoisted_310, [
              _cache[203] || (_cache[203] = createBaseVNode("label", { title: "Visual shape used to render each particle." }, "Shape", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.particleShape,
                onChange: _cache[49] || (_cache[49] = ($event) => updateRenderOption("particleShape", $event.target.value))
              }, [..._cache[202] || (_cache[202] = [
                createBaseVNode("option", { value: "circle" }, "Circle", -1),
                createBaseVNode("option", { value: "square" }, "Square", -1),
                createBaseVNode("option", { value: "triangle" }, "Triangle", -1),
                createBaseVNode("option", { value: "star" }, "Star", -1)
              ])], 40, _hoisted_311)
            ]),
            createBaseVNode("div", _hoisted_312, [
              createBaseVNode("label", _hoisted_313, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.spriteEnabled,
                  onChange: _cache[50] || (_cache[50] = ($event) => updateRenderOption("spriteEnabled", $event.target.checked))
                }, null, 40, _hoisted_314),
                _cache[204] || (_cache[204] = createTextVNode(" Use Sprite ", -1))
              ])
            ]),
            renderOptions.value.spriteEnabled ? (openBlock(), createElementBlock("div", _hoisted_315, [
              _cache[205] || (_cache[205] = createBaseVNode("label", { title: "URL or data URI of the sprite image." }, "Sprite URL", -1)),
              createBaseVNode("input", {
                type: "text",
                value: renderOptions.value.spriteImageUrl,
                placeholder: "https://... or data:...",
                onChange: _cache[51] || (_cache[51] = ($event) => updateRenderOption("spriteImageUrl", $event.target.value))
              }, null, 40, _hoisted_316)
            ])) : createCommentVNode("", true),
            renderOptions.value.spriteEnabled ? (openBlock(), createElementBlock("div", _hoisted_317, [
              _cache[206] || (_cache[206] = createBaseVNode("label", { title: "Number of columns in the sprite sheet (1 for single image)." }, "Columns", -1)),
              createBaseVNode("input", {
                type: "number",
                value: renderOptions.value.spriteColumns,
                min: "1",
                max: "16",
                onChange: _cache[52] || (_cache[52] = ($event) => updateRenderOption("spriteColumns", Number($event.target.value)))
              }, null, 40, _hoisted_318)
            ])) : createCommentVNode("", true),
            renderOptions.value.spriteEnabled ? (openBlock(), createElementBlock("div", _hoisted_319, [
              _cache[207] || (_cache[207] = createBaseVNode("label", { title: "Number of rows in the sprite sheet (1 for single image)." }, "Rows", -1)),
              createBaseVNode("input", {
                type: "number",
                value: renderOptions.value.spriteRows,
                min: "1",
                max: "16",
                onChange: _cache[53] || (_cache[53] = ($event) => updateRenderOption("spriteRows", Number($event.target.value)))
              }, null, 40, _hoisted_320)
            ])) : createCommentVNode("", true),
            renderOptions.value.spriteEnabled && (renderOptions.value.spriteColumns > 1 || renderOptions.value.spriteRows > 1) ? (openBlock(), createElementBlock("div", _hoisted_321, [
              createBaseVNode("label", _hoisted_322, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.spriteAnimate,
                  onChange: _cache[54] || (_cache[54] = ($event) => updateRenderOption("spriteAnimate", $event.target.checked))
                }, null, 40, _hoisted_323),
                _cache[208] || (_cache[208] = createTextVNode(" Animate Frames ", -1))
              ])
            ])) : createCommentVNode("", true),
            renderOptions.value.spriteEnabled && renderOptions.value.spriteAnimate ? (openBlock(), createElementBlock("div", _hoisted_324, [
              _cache[209] || (_cache[209] = createBaseVNode("label", { title: "Frames per second for sprite animation." }, "Frame Rate", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.spriteFrameRate,
                min: "1",
                max: "60",
                step: "1",
                onInput: _cache[55] || (_cache[55] = ($event) => updateRenderOption("spriteFrameRate", Number($event.target.value)))
              }, null, 40, _hoisted_325),
              createBaseVNode("span", _hoisted_326, toDisplayString(renderOptions.value.spriteFrameRate) + " fps", 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.spriteEnabled && (renderOptions.value.spriteColumns > 1 || renderOptions.value.spriteRows > 1) ? (openBlock(), createElementBlock("div", _hoisted_327, [
              createBaseVNode("label", _hoisted_328, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.spriteRandomStart,
                  onChange: _cache[56] || (_cache[56] = ($event) => updateRenderOption("spriteRandomStart", $event.target.checked))
                }, null, 40, _hoisted_329),
                _cache[210] || (_cache[210] = createTextVNode(" Random Start Frame ", -1))
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_330, [
              createBaseVNode("label", _hoisted_331, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.renderTrails,
                  onChange: _cache[57] || (_cache[57] = ($event) => updateRenderOption("renderTrails", $event.target.checked))
                }, null, 40, _hoisted_332),
                _cache[211] || (_cache[211] = createTextVNode(" Render Trails ", -1))
              ])
            ]),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_333, [
              _cache[212] || (_cache[212] = createBaseVNode("label", { title: "Number of historical positions to show in the trail." }, "Trail Length", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailLength,
                min: "1",
                max: "20",
                step: "1",
                onInput: _cache[58] || (_cache[58] = ($event) => updateRenderOption("trailLength", Number($event.target.value)))
              }, null, 40, _hoisted_334),
              createBaseVNode("span", _hoisted_335, toDisplayString(renderOptions.value.trailLength), 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_336, [
              _cache[213] || (_cache[213] = createBaseVNode("label", { title: "How quickly trail opacity decreases. Higher values = faster fade." }, "Trail Falloff", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailOpacityFalloff,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[59] || (_cache[59] = ($event) => updateRenderOption("trailOpacityFalloff", Number($event.target.value)))
              }, null, 40, _hoisted_337),
              createBaseVNode("span", _hoisted_338, toDisplayString(renderOptions.value.trailOpacityFalloff.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_339, [
              createBaseVNode("label", _hoisted_340, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.glowEnabled,
                  onChange: _cache[60] || (_cache[60] = ($event) => updateRenderOption("glowEnabled", $event.target.checked))
                }, null, 40, _hoisted_341),
                _cache[214] || (_cache[214] = createTextVNode(" Enable Glow ", -1))
              ])
            ]),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_342, [
              _cache[215] || (_cache[215] = createBaseVNode("label", { title: "Size of the glow area around each particle." }, "Glow Radius", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowRadius,
                min: "1",
                max: "50",
                step: "1",
                onInput: _cache[61] || (_cache[61] = ($event) => updateRenderOption("glowRadius", Number($event.target.value)))
              }, null, 40, _hoisted_343),
              createBaseVNode("span", _hoisted_344, toDisplayString(renderOptions.value.glowRadius) + "px", 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_345, [
              _cache[216] || (_cache[216] = createBaseVNode("label", { title: "Brightness of the glow effect. 0 = no glow, 1 = maximum glow." }, "Glow Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowIntensity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[62] || (_cache[62] = ($event) => updateRenderOption("glowIntensity", Number($event.target.value)))
              }, null, 40, _hoisted_346),
              createBaseVNode("span", _hoisted_347, toDisplayString(renderOptions.value.glowIntensity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            _cache[226] || (_cache[226] = createBaseVNode("div", { class: "subsection-divider" }, "Motion Blur", -1)),
            createBaseVNode("div", _hoisted_348, [
              createBaseVNode("label", _hoisted_349, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.motionBlur,
                  onChange: _cache[63] || (_cache[63] = ($event) => updateRenderOption("motionBlur", $event.target.checked))
                }, null, 40, _hoisted_350),
                _cache[217] || (_cache[217] = createTextVNode(" Enable Motion Blur ", -1))
              ])
            ]),
            renderOptions.value.motionBlur ? (openBlock(), createElementBlock("div", _hoisted_351, [
              _cache[218] || (_cache[218] = createBaseVNode("label", { title: "How much blur to apply based on particle velocity." }, "Blur Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.motionBlurStrength,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[64] || (_cache[64] = ($event) => updateRenderOption("motionBlurStrength", Number($event.target.value)))
              }, null, 40, _hoisted_352),
              createBaseVNode("span", _hoisted_353, toDisplayString(renderOptions.value.motionBlurStrength.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.motionBlur ? (openBlock(), createElementBlock("div", _hoisted_354, [
              _cache[219] || (_cache[219] = createBaseVNode("label", { title: "Number of samples for blur quality. Higher = smoother but slower." }, "Blur Samples", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.motionBlurSamples,
                min: "1",
                max: "16",
                step: "1",
                onInput: _cache[65] || (_cache[65] = ($event) => updateRenderOption("motionBlurSamples", Number($event.target.value)))
              }, null, 40, _hoisted_355),
              createBaseVNode("span", _hoisted_356, toDisplayString(renderOptions.value.motionBlurSamples), 1)
            ])) : createCommentVNode("", true),
            _cache[227] || (_cache[227] = createBaseVNode("div", { class: "subsection-divider" }, "Particle Connections", -1)),
            createBaseVNode("div", _hoisted_357, [
              createBaseVNode("label", _hoisted_358, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.enabled,
                  onChange: _cache[66] || (_cache[66] = ($event) => updateConnection("enabled", $event.target.checked))
                }, null, 40, _hoisted_359),
                _cache[220] || (_cache[220] = createTextVNode(" Enable Connections ", -1))
              ])
            ]),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_360, [
              _cache[221] || (_cache[221] = createBaseVNode("label", { title: "Maximum distance in pixels between particles to draw a connection." }, "Max Distance", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxDistance,
                min: "10",
                max: "300",
                step: "10",
                onInput: _cache[67] || (_cache[67] = ($event) => updateConnection("maxDistance", Number($event.target.value)))
              }, null, 40, _hoisted_361),
              createBaseVNode("span", _hoisted_362, toDisplayString(connections.value.maxDistance) + "px", 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_363, [
              _cache[222] || (_cache[222] = createBaseVNode("label", { title: "Maximum number of connections each particle can have." }, "Max Connections", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxConnections,
                min: "1",
                max: "5",
                step: "1",
                onInput: _cache[68] || (_cache[68] = ($event) => updateConnection("maxConnections", Number($event.target.value)))
              }, null, 40, _hoisted_364),
              createBaseVNode("span", _hoisted_365, toDisplayString(connections.value.maxConnections), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_366, [
              _cache[223] || (_cache[223] = createBaseVNode("label", { title: "Thickness of connection lines in pixels." }, "Line Width", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineWidth,
                min: "0.5",
                max: "3",
                step: "0.1",
                onInput: _cache[69] || (_cache[69] = ($event) => updateConnection("lineWidth", Number($event.target.value)))
              }, null, 40, _hoisted_367),
              createBaseVNode("span", _hoisted_368, toDisplayString(connections.value.lineWidth.toFixed(1)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_369, [
              _cache[224] || (_cache[224] = createBaseVNode("label", { title: "Transparency of connection lines. 0 = invisible, 1 = fully opaque." }, "Line Opacity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineOpacity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[70] || (_cache[70] = ($event) => updateConnection("lineOpacity", Number($event.target.value)))
              }, null, 40, _hoisted_370),
              createBaseVNode("span", _hoisted_371, toDisplayString(connections.value.lineOpacity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_372, [
              createBaseVNode("label", _hoisted_373, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.fadeByDistance,
                  onChange: _cache[71] || (_cache[71] = ($event) => updateConnection("fadeByDistance", $event.target.checked))
                }, null, 40, _hoisted_374),
                _cache[225] || (_cache[225] = createTextVNode(" Fade by Distance ", -1))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_375, [
          _cache[228] || (_cache[228] = createBaseVNode("i", { class: "pi pi-circle-fill" }, null, -1)),
          createBaseVNode("span", null, toDisplayString(particleCount.value) + " particles", 1)
        ])
      ]);
    };
  }
});

const ParticleProperties = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["__scopeId", "data-v-2cffc2c6"]]);

const isVisible = ref(false);
const currentProperty = shallowRef(null);
const currentLayerId = ref("");
const currentPropertyPath = ref("");
function useExpressionEditor() {
  function openExpressionEditor(property, layerId, propertyPath = "") {
    currentProperty.value = property;
    currentLayerId.value = layerId;
    currentPropertyPath.value = propertyPath;
    isVisible.value = true;
  }
  function closeExpressionEditor() {
    isVisible.value = false;
  }
  function applyExpression(expression) {
    if (currentProperty.value) {
      currentProperty.value.expression = expression;
    }
    closeExpressionEditor();
  }
  function removeExpression() {
    if (currentProperty.value) {
      currentProperty.value.expression = void 0;
    }
    closeExpressionEditor();
  }
  return {
    // State
    isVisible,
    currentProperty,
    currentLayerId,
    currentPropertyPath,
    // Actions
    openExpressionEditor,
    closeExpressionEditor,
    applyExpression,
    removeExpression
  };
}

const _hoisted_1$O = ["title"];
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {},
    propertyPath: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expressionEditor = useExpressionEditor();
    const hasKeyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return false;
      return props.property.keyframes.some((k) => k.frame === store.currentFrame);
    });
    const hasExpression = computed(() => {
      return props.property.expression?.enabled ?? false;
    });
    const keyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return null;
      return props.property.keyframes.find((k) => k.frame === store.currentFrame) || null;
    });
    const iconClass = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "pi-circle-fill";
      }
      if (props.property.animated) {
        return "pi-circle";
      }
      return "pi-times";
    });
    const buttonTitle = computed(() => {
      const exprHint = "\nAlt+click: Add expression";
      if (hasExpression.value) {
        return "Expression active (Alt+click to edit)";
      }
      if (hasKeyframeAtCurrentFrame.value) {
        return "Remove keyframe at current frame" + exprHint;
      }
      if (props.property.animated) {
        return "Add keyframe at current frame" + exprHint;
      }
      return "Enable animation (add keyframe)" + exprHint;
    });
    function handleClick(event) {
      if (event.altKey) {
        expressionEditor.openExpressionEditor(
          props.property,
          props.layerId,
          props.propertyPath || ""
        );
      } else {
        toggleKeyframe();
      }
    }
    function toggleKeyframe() {
      if (hasKeyframeAtCurrentFrame.value) {
        removeKeyframe();
      } else {
        addKeyframe();
      }
    }
    function addKeyframe() {
      const defaultHandle = { frame: 0, value: 0, enabled: false };
      const newKeyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: store.currentFrame,
        value: props.property.value,
        interpolation: "linear",
        inHandle: { ...defaultHandle },
        outHandle: { ...defaultHandle },
        controlMode: "smooth"
      };
      if (!props.property.animated) {
        props.property.animated = true;
        emit("animationToggled", true);
      }
      props.property.keyframes.push(newKeyframe);
      props.property.keyframes.sort((a, b) => a.frame - b.frame);
      emit("keyframeAdded", newKeyframe);
    }
    function removeKeyframe() {
      const keyframe = keyframeAtCurrentFrame.value;
      if (!keyframe) return;
      const index = props.property.keyframes.findIndex((k) => k.id === keyframe.id);
      if (index >= 0) {
        props.property.keyframes.splice(index, 1);
        emit("keyframeRemoved", keyframe.id);
      }
      if (props.property.keyframes.length === 0) {
        props.property.animated = false;
        emit("animationToggled", false);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["keyframe-toggle", {
          animated: __props.property.animated,
          "has-keyframe": hasKeyframeAtCurrentFrame.value,
          "has-expression": hasExpression.value
        }]),
        onClick: handleClick,
        title: buttonTitle.value
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["pi", iconClass.value])
        }, null, 2)
      ], 10, _hoisted_1$O);
    };
  }
});

const KeyframeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__scopeId", "data-v-77908b49"]]);

const _hoisted_1$N = { class: "depthflow-properties" };
const _hoisted_2$N = { class: "property-section" };
const _hoisted_3$N = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$N = { class: "property-row" };
const _hoisted_5$N = ["value"];
const _hoisted_6$N = ["value"];
const _hoisted_7$N = { class: "property-row" };
const _hoisted_8$L = ["value"];
const _hoisted_9$L = ["value"];
const _hoisted_10$K = { class: "property-section" };
const _hoisted_11$J = {
  key: 0,
  class: "section-content"
};
const _hoisted_12$H = { class: "preset-grid" };
const _hoisted_13$H = ["onClick"];
const _hoisted_14$D = {
  key: 0,
  class: "property-row"
};
const _hoisted_15$C = ["value"];
const _hoisted_16$B = { class: "value-display" };
const _hoisted_17$A = { class: "property-section" };
const _hoisted_18$y = {
  key: 0,
  class: "section-content"
};
const _hoisted_19$x = { class: "property-row" };
const _hoisted_20$x = ["value"];
const _hoisted_21$v = { class: "value-display" };
const _hoisted_22$t = { class: "property-row" };
const _hoisted_23$t = ["value"];
const _hoisted_24$n = { class: "value-display" };
const _hoisted_25$n = { class: "property-row" };
const _hoisted_26$l = ["value"];
const _hoisted_27$l = { class: "value-display" };
const _hoisted_28$k = { class: "property-row" };
const _hoisted_29$k = ["value"];
const _hoisted_30$j = { class: "value-display" };
const _hoisted_31$h = { class: "property-section" };
const _hoisted_32$h = {
  key: 0,
  class: "section-content"
};
const _hoisted_33$h = { class: "property-row" };
const _hoisted_34$f = ["value"];
const _hoisted_35$e = { class: "value-display" };
const _hoisted_36$d = { class: "property-row" };
const _hoisted_37$d = ["value"];
const _hoisted_38$d = { class: "value-display" };
const _hoisted_39$d = {
  key: 0,
  class: "property-section"
};
const _hoisted_40$c = {
  key: 0,
  class: "section-content"
};
const _hoisted_41$a = { class: "property-row" };
const _hoisted_42$9 = ["value"];
const _hoisted_43$9 = { class: "value-display" };
const _hoisted_44$9 = { class: "property-row" };
const _hoisted_45$9 = ["value"];
const _hoisted_46$9 = { class: "value-display" };
const _hoisted_47$9 = { class: "property-row" };
const _hoisted_48$9 = ["value"];
const _hoisted_49$9 = { class: "value-display" };
const _hoisted_50$8 = { class: "property-row" };
const _hoisted_51$8 = ["value"];
const _hoisted_52$7 = { class: "value-display" };
const _hoisted_53$7 = {
  key: 2,
  class: "property-row"
};
const _hoisted_54$7 = ["value"];
const _hoisted_55$7 = { class: "value-display" };
const _hoisted_56$7 = { class: "property-section" };
const _hoisted_57$6 = {
  key: 0,
  class: "section-content"
};
const _hoisted_58$6 = { class: "property-row" };
const _hoisted_59$6 = ["value"];
const _hoisted_60$5 = { class: "value-display" };
const _hoisted_61$5 = { class: "property-row checkbox-row" };
const _hoisted_62$5 = ["checked"];
const _hoisted_63$3 = { class: "property-section" };
const _hoisted_64$3 = {
  key: 0,
  class: "sync-badge"
};
const _hoisted_65$3 = {
  key: 0,
  class: "section-content"
};
const _hoisted_66$3 = { class: "property-row checkbox-row" };
const _hoisted_67$3 = ["checked"];
const _hoisted_68$3 = { class: "property-row" };
const _hoisted_69$3 = ["value"];
const _hoisted_70$3 = ["value"];
const _hoisted_71$3 = { class: "property-row" };
const _hoisted_72$3 = ["value"];
const _hoisted_73$3 = { class: "value-display" };
const _hoisted_74$2 = { class: "property-row" };
const _hoisted_75$2 = ["value"];
const _hoisted_76$2 = { class: "value-display" };
const _hoisted_77$2 = { class: "property-row" };
const _hoisted_78$2 = ["value"];
const _hoisted_79$2 = { class: "value-display" };
const _hoisted_80$2 = { class: "property-row" };
const _hoisted_81$2 = ["value"];
const _hoisted_82$2 = { class: "value-display" };
const _hoisted_83$2 = { class: "property-row checkbox-row" };
const _hoisted_84$2 = ["checked"];
const _hoisted_85$2 = { style: { "margin-left": "16px" } };
const _hoisted_86$2 = ["checked"];
const _hoisted_87$2 = { class: "property-row" };
const _hoisted_88$2 = ["value"];
const _hoisted_89$2 = { class: "value-display" };
const _hoisted_90$2 = { class: "property-section" };
const _hoisted_91$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_92$1 = { class: "preview-container" };
const _hoisted_93$1 = { class: "preview-controls" };
const _hoisted_94$1 = { class: "frame-indicator" };
const previewSize = 200;
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const DEFAULT_CAMERA_SYNC_CONFIG = {
      sensitivityX: 0.5,
      sensitivityY: 0.5,
      sensitivityZ: 1e-3,
      sensitivityRotation: 1,
      baseZoom: 1,
      invertX: false,
      invertY: false,
      zoomClamp: { min: 0.5, max: 3 },
      offsetClamp: { min: -1, max: 1 }
    };
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const previewCanvas = ref(null);
    const isPreviewPlaying = ref(false);
    const previewFrame = ref(0);
    const previewAnimationId = ref(null);
    const expandedSections = ref(/* @__PURE__ */ new Set(["source", "preset", "camera"]));
    const presetIntensity = ref(1);
    const presets = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ];
    const config = computed(() => {
      const data = props.layer.data;
      return data || {
        sourceLayerId: "",
        depthLayerId: "",
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        }
      };
    });
    const depthflowConfig = computed(() => config.value.config);
    const totalFrames = computed(() => store.frameCount);
    const imageLayers = computed(
      () => store.layers.filter((l) => l.type === "image" || l.type === "generated")
    );
    const depthLayers = computed(
      () => store.layers.filter((l) => l.type === "depth" || l.type === "generated")
    );
    const cameraLayers = computed(
      () => store.layers.filter((l) => l.type === "camera")
    );
    const cameraSyncConfig = computed(() => {
      return config.value.cameraSyncConfig ?? DEFAULT_CAMERA_SYNC_CONFIG;
    });
    const isOrbitPreset = computed(
      () => ["circle_cw", "circle_ccw"].includes(depthflowConfig.value.preset)
    );
    const isSwingPreset = computed(
      () => ["horizontal_swing", "vertical_swing"].includes(depthflowConfig.value.preset)
    );
    const isDollyPreset = computed(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(depthflowConfig.value.preset)
    );
    const showPresetSettings = computed(
      () => isOrbitPreset.value || isSwingPreset.value || isDollyPreset.value
    );
    const presetSettingsTitle = computed(() => {
      if (isOrbitPreset.value) return "Orbit Settings";
      if (isSwingPreset.value) return "Swing Settings";
      if (isDollyPreset.value) return "Dolly Zoom Settings";
      return "Preset Settings";
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function updateConfig(key, value) {
      emit("update", { [key]: value });
    }
    function updateDepthflowConfig(key, value) {
      emit("update", {
        config: { ...depthflowConfig.value, [key]: value }
      });
    }
    function selectPreset(preset) {
      updateDepthflowConfig("preset", preset);
    }
    function updateCameraSyncConfig(key, value) {
      emit("update", {
        cameraSyncConfig: { ...cameraSyncConfig.value, [key]: value }
      });
    }
    function updatePresetIntensity(intensity) {
      presetIntensity.value = intensity;
      if (isOrbitPreset.value) {
        updateDepthflowConfig("orbitRadius", 0.1 * intensity);
      } else if (isSwingPreset.value) {
        updateDepthflowConfig("swingAmplitude", 0.1 * intensity);
      } else {
        updateDepthflowConfig("depthScale", 1 * intensity);
      }
    }
    function togglePreview() {
      isPreviewPlaying.value = !isPreviewPlaying.value;
      if (isPreviewPlaying.value) {
        playPreview();
      } else {
        if (previewAnimationId.value !== null) {
          cancelAnimationFrame(previewAnimationId.value);
          previewAnimationId.value = null;
        }
      }
    }
    function playPreview() {
      if (!isPreviewPlaying.value) return;
      previewFrame.value = (previewFrame.value + 1) % totalFrames.value;
      renderPreview();
      previewAnimationId.value = requestAnimationFrame(() => {
        setTimeout(playPreview, 1e3 / store.fps);
      });
    }
    function renderPreview() {
      const canvas = previewCanvas.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, previewSize, previewSize);
      ctx.fillStyle = "#333";
      ctx.fillRect(10, 10, previewSize - 20, previewSize - 20);
      ctx.fillStyle = "#666";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Depthflow Preview", previewSize / 2, previewSize / 2);
      ctx.fillText(`Frame ${previewFrame.value}`, previewSize / 2, previewSize / 2 + 16);
    }
    onMounted(() => {
      renderPreview();
    });
    onUnmounted(() => {
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
    });
    function onKeyframeChange() {
      emit("update", {});
    }
    function onAnimationToggled(animated) {
      console.log("[DepthflowProperties] Animation toggled:", animated);
      emit("update", {});
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$N, [
        createBaseVNode("div", _hoisted_2$N, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("source"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Source Selection", -1))
          ]),
          expandedSections.value.has("source") ? (openBlock(), createElementBlock("div", _hoisted_3$N, [
            createBaseVNode("div", _hoisted_4$N, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Source Layer", -1)),
              createBaseVNode("select", {
                value: config.value.sourceLayerId,
                onChange: _cache[1] || (_cache[1] = ($event) => updateConfig("sourceLayerId", $event.target.value))
              }, [
                _cache[34] || (_cache[34] = createBaseVNode("option", { value: "" }, "Select source...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_6$N);
                }), 128))
              ], 40, _hoisted_5$N)
            ]),
            createBaseVNode("div", _hoisted_7$N, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Depth Layer", -1)),
              createBaseVNode("select", {
                value: config.value.depthLayerId,
                onChange: _cache[2] || (_cache[2] = ($event) => updateConfig("depthLayerId", $event.target.value))
              }, [
                _cache[36] || (_cache[36] = createBaseVNode("option", { value: "" }, "Select depth map...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(depthLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_9$L);
                }), 128))
              ], 40, _hoisted_8$L)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_10$K, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[3] || (_cache[3] = ($event) => toggleSection("preset"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[38] || (_cache[38] = createBaseVNode("span", null, "Motion Preset", -1))
          ]),
          expandedSections.value.has("preset") ? (openBlock(), createElementBlock("div", _hoisted_11$J, [
            createBaseVNode("div", _hoisted_12$H, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.value,
                  class: normalizeClass(["preset-btn", { active: depthflowConfig.value.preset === preset.value }]),
                  onClick: ($event) => selectPreset(preset.value)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(preset.icon)
                  }, null, 2),
                  createBaseVNode("span", null, toDisplayString(preset.label), 1)
                ], 10, _hoisted_13$H);
              }), 64))
            ]),
            depthflowConfig.value.preset !== "static" ? (openBlock(), createElementBlock("div", _hoisted_14$D, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: presetIntensity.value,
                min: "0.1",
                max: "2",
                step: "0.1",
                onInput: _cache[4] || (_cache[4] = ($event) => updatePresetIntensity(Number($event.target.value)))
              }, null, 40, _hoisted_15$C),
              createBaseVNode("span", _hoisted_16$B, toDisplayString(presetIntensity.value.toFixed(1)) + "x", 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_17$A, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("camera"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[40] || (_cache[40] = createBaseVNode("span", null, "Camera Controls", -1))
          ]),
          expandedSections.value.has("camera") ? (openBlock(), createElementBlock("div", _hoisted_18$y, [
            createBaseVNode("div", _hoisted_19$x, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Zoom", -1)),
              config.value.animatedZoom ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedZoom,
                "layer-id": __props.layer.id,
                propertyPath: "data.animatedZoom",
                onKeyframeAdded: onKeyframeChange,
                onKeyframeRemoved: onKeyframeChange,
                onAnimationToggled
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.zoom,
                min: "0.5",
                max: "2",
                step: "0.01",
                onInput: _cache[6] || (_cache[6] = ($event) => updateDepthflowConfig("zoom", Number($event.target.value)))
              }, null, 40, _hoisted_20$x),
              createBaseVNode("span", _hoisted_21$v, toDisplayString(depthflowConfig.value.zoom.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_22$t, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Offset X", -1)),
              config.value.animatedOffsetX ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetX,
                "layer-id": __props.layer.id,
                propertyPath: "data.animatedOffsetX",
                onKeyframeAdded: onKeyframeChange,
                onKeyframeRemoved: onKeyframeChange,
                onAnimationToggled
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetX,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[7] || (_cache[7] = ($event) => updateDepthflowConfig("offsetX", Number($event.target.value)))
              }, null, 40, _hoisted_23$t),
              createBaseVNode("span", _hoisted_24$n, toDisplayString(depthflowConfig.value.offsetX.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_25$n, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Offset Y", -1)),
              config.value.animatedOffsetY ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetY,
                "layer-id": __props.layer.id,
                propertyPath: "data.animatedOffsetY",
                onKeyframeAdded: onKeyframeChange,
                onKeyframeRemoved: onKeyframeChange,
                onAnimationToggled
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetY,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[8] || (_cache[8] = ($event) => updateDepthflowConfig("offsetY", Number($event.target.value)))
              }, null, 40, _hoisted_26$l),
              createBaseVNode("span", _hoisted_27$l, toDisplayString(depthflowConfig.value.offsetY.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_28$k, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Rotation", -1)),
              config.value.animatedRotation ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedRotation,
                "layer-id": __props.layer.id,
                propertyPath: "data.animatedRotation",
                onKeyframeAdded: onKeyframeChange,
                onKeyframeRemoved: onKeyframeChange,
                onAnimationToggled
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.rotation,
                min: "-180",
                max: "180",
                step: "1",
                onInput: _cache[9] || (_cache[9] = ($event) => updateDepthflowConfig("rotation", Number($event.target.value)))
              }, null, 40, _hoisted_29$k),
              createBaseVNode("span", _hoisted_30$j, toDisplayString(depthflowConfig.value.rotation) + "", 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_31$h, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("depth"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[45] || (_cache[45] = createBaseVNode("span", null, "Depth Settings", -1))
          ]),
          expandedSections.value.has("depth") ? (openBlock(), createElementBlock("div", _hoisted_32$h, [
            createBaseVNode("div", _hoisted_33$h, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Depth Scale", -1)),
              config.value.animatedDepthScale ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedDepthScale,
                "layer-id": __props.layer.id,
                propertyPath: "data.animatedDepthScale",
                onKeyframeAdded: onKeyframeChange,
                onKeyframeRemoved: onKeyframeChange,
                onAnimationToggled
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.depthScale,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: _cache[11] || (_cache[11] = ($event) => updateDepthflowConfig("depthScale", Number($event.target.value)))
              }, null, 40, _hoisted_34$f),
              createBaseVNode("span", _hoisted_35$e, toDisplayString(depthflowConfig.value.depthScale.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_36$d, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Focus Depth", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.focusDepth,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[12] || (_cache[12] = ($event) => updateDepthflowConfig("focusDepth", Number($event.target.value)))
              }, null, 40, _hoisted_37$d),
              createBaseVNode("span", _hoisted_38$d, toDisplayString(depthflowConfig.value.focusDepth.toFixed(2)), 1)
            ]),
            _cache[48] || (_cache[48] = createBaseVNode("div", { class: "depth-hint" }, [
              createTextVNode(" Objects at focus depth stay stationary."),
              createBaseVNode("br"),
              createTextVNode(" Closer objects move more, distant objects move less. ")
            ], -1))
          ])) : createCommentVNode("", true)
        ]),
        showPresetSettings.value ? (openBlock(), createElementBlock("div", _hoisted_39$d, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("presetSettings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            createBaseVNode("span", null, toDisplayString(presetSettingsTitle.value), 1)
          ]),
          expandedSections.value.has("presetSettings") ? (openBlock(), createElementBlock("div", _hoisted_40$c, [
            isOrbitPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_41$a, [
                _cache[49] || (_cache[49] = createBaseVNode("label", null, "Orbit Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitRadius,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[14] || (_cache[14] = ($event) => updateDepthflowConfig("orbitRadius", Number($event.target.value)))
                }, null, 40, _hoisted_42$9),
                createBaseVNode("span", _hoisted_43$9, toDisplayString(depthflowConfig.value.orbitRadius.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_44$9, [
                _cache[50] || (_cache[50] = createBaseVNode("label", null, "Orbit Speed", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitSpeed,
                  min: "1",
                  max: "720",
                  step: "1",
                  onInput: _cache[15] || (_cache[15] = ($event) => updateDepthflowConfig("orbitSpeed", Number($event.target.value)))
                }, null, 40, _hoisted_45$9),
                createBaseVNode("span", _hoisted_46$9, toDisplayString(depthflowConfig.value.orbitSpeed) + "", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isSwingPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_47$9, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Amplitude", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingAmplitude,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[16] || (_cache[16] = ($event) => updateDepthflowConfig("swingAmplitude", Number($event.target.value)))
                }, null, 40, _hoisted_48$9),
                createBaseVNode("span", _hoisted_49$9, toDisplayString(depthflowConfig.value.swingAmplitude.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_50$8, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Frequency", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingFrequency,
                  min: "0.1",
                  max: "5",
                  step: "0.1",
                  onInput: _cache[17] || (_cache[17] = ($event) => updateDepthflowConfig("swingFrequency", Number($event.target.value)))
                }, null, 40, _hoisted_51$8),
                createBaseVNode("span", _hoisted_52$7, toDisplayString(depthflowConfig.value.swingFrequency.toFixed(1)) + " Hz", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isDollyPreset.value ? (openBlock(), createElementBlock("div", _hoisted_53$7, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Dolly Rate", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.dollyZoom,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[18] || (_cache[18] = ($event) => updateDepthflowConfig("dollyZoom", Number($event.target.value)))
              }, null, 40, _hoisted_54$7),
              createBaseVNode("span", _hoisted_55$7, toDisplayString(depthflowConfig.value.dollyZoom.toFixed(2)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_56$7, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[19] || (_cache[19] = ($event) => toggleSection("quality"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[54] || (_cache[54] = createBaseVNode("span", null, "Quality", -1))
          ]),
          expandedSections.value.has("quality") ? (openBlock(), createElementBlock("div", _hoisted_57$6, [
            createBaseVNode("div", _hoisted_58$6, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Edge Dilation", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.edgeDilation,
                min: "0",
                max: "50",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateDepthflowConfig("edgeDilation", Number($event.target.value)))
              }, null, 40, _hoisted_59$6),
              createBaseVNode("span", _hoisted_60$5, toDisplayString(depthflowConfig.value.edgeDilation) + "px", 1)
            ]),
            createBaseVNode("div", _hoisted_61$5, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: depthflowConfig.value.inpaintEdges,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateDepthflowConfig("inpaintEdges", $event.target.checked))
                }, null, 40, _hoisted_62$5),
                _cache[56] || (_cache[56] = createTextVNode(" Inpaint Edges ", -1))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_63$3, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[22] || (_cache[22] = ($event) => toggleSection("cameraSync"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("cameraSync") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[57] || (_cache[57] = createBaseVNode("span", null, "Camera Sync", -1)),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock("span", _hoisted_64$3, "Active")) : createCommentVNode("", true)
          ]),
          expandedSections.value.has("cameraSync") ? (openBlock(), createElementBlock("div", _hoisted_65$3, [
            createBaseVNode("div", _hoisted_66$3, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: config.value.cameraSyncEnabled ?? false,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateConfig("cameraSyncEnabled", $event.target.checked))
                }, null, 40, _hoisted_67$3),
                _cache[58] || (_cache[58] = createTextVNode(" Enable Camera Sync ", -1))
              ])
            ]),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_68$3, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Camera Layer", -1)),
                createBaseVNode("select", {
                  value: config.value.cameraSyncLayerId ?? "",
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConfig("cameraSyncLayerId", $event.target.value))
                }, [
                  _cache[59] || (_cache[59] = createBaseVNode("option", { value: "" }, "Select camera...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(cameraLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_70$3);
                  }), 128))
                ], 40, _hoisted_69$3)
              ]),
              _cache[68] || (_cache[68] = createBaseVNode("div", { class: "sync-hint" }, " Camera movement will drive parallax. Adjust sensitivity below. ", -1)),
              createBaseVNode("div", _hoisted_71$3, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "X Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityX,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[25] || (_cache[25] = ($event) => updateCameraSyncConfig("sensitivityX", Number($event.target.value)))
                }, null, 40, _hoisted_72$3),
                createBaseVNode("span", _hoisted_73$3, toDisplayString(cameraSyncConfig.value.sensitivityX.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_74$2, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Y Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityY,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[26] || (_cache[26] = ($event) => updateCameraSyncConfig("sensitivityY", Number($event.target.value)))
                }, null, 40, _hoisted_75$2),
                createBaseVNode("span", _hoisted_76$2, toDisplayString(cameraSyncConfig.value.sensitivityY.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_77$2, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Z Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityZ * 1e3,
                  min: "0",
                  max: "10",
                  step: "0.1",
                  onInput: _cache[27] || (_cache[27] = ($event) => updateCameraSyncConfig("sensitivityZ", Number($event.target.value) / 1e3))
                }, null, 40, _hoisted_78$2),
                createBaseVNode("span", _hoisted_79$2, toDisplayString((cameraSyncConfig.value.sensitivityZ * 1e3).toFixed(1)), 1)
              ]),
              createBaseVNode("div", _hoisted_80$2, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "Rotation Sens.", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityRotation,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[28] || (_cache[28] = ($event) => updateCameraSyncConfig("sensitivityRotation", Number($event.target.value)))
                }, null, 40, _hoisted_81$2),
                createBaseVNode("span", _hoisted_82$2, toDisplayString(cameraSyncConfig.value.sensitivityRotation.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_83$2, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertX,
                    onChange: _cache[29] || (_cache[29] = ($event) => updateCameraSyncConfig("invertX", $event.target.checked))
                  }, null, 40, _hoisted_84$2),
                  _cache[65] || (_cache[65] = createTextVNode(" Invert X ", -1))
                ]),
                createBaseVNode("label", _hoisted_85$2, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertY,
                    onChange: _cache[30] || (_cache[30] = ($event) => updateCameraSyncConfig("invertY", $event.target.checked))
                  }, null, 40, _hoisted_86$2),
                  _cache[66] || (_cache[66] = createTextVNode(" Invert Y ", -1))
                ])
              ]),
              createBaseVNode("div", _hoisted_87$2, [
                _cache[67] || (_cache[67] = createBaseVNode("label", null, "Base Zoom", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.baseZoom,
                  min: "0.5",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[31] || (_cache[31] = ($event) => updateCameraSyncConfig("baseZoom", Number($event.target.value)))
                }, null, 40, _hoisted_88$2),
                createBaseVNode("span", _hoisted_89$2, toDisplayString(cameraSyncConfig.value.baseZoom.toFixed(2)), 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_90$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[32] || (_cache[32] = ($event) => toggleSection("preview"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[69] || (_cache[69] = createBaseVNode("span", null, "Preview", -1))
          ]),
          expandedSections.value.has("preview") ? (openBlock(), createElementBlock("div", _hoisted_91$1, [
            createBaseVNode("div", _hoisted_92$1, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                class: "preview-canvas",
                width: previewSize,
                height: previewSize
              }, null, 512)
            ]),
            createBaseVNode("div", _hoisted_93$1, [
              createBaseVNode("button", {
                class: normalizeClass(["preview-btn", { active: isPreviewPlaying.value }]),
                onClick: togglePreview
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(isPreviewPlaying.value ? "pi pi-pause" : "pi pi-play")
                }, null, 2),
                createTextVNode(" " + toDisplayString(isPreviewPlaying.value ? "Pause" : "Play"), 1)
              ], 2),
              createBaseVNode("span", _hoisted_94$1, " Frame " + toDisplayString(previewFrame.value) + " / " + toDisplayString(totalFrames.value - 1), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const DepthflowProperties = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__scopeId", "data-v-47a0f072"]]);

const _hoisted_1$M = { class: "light-properties" };
const _hoisted_2$M = { class: "property-section" };
const _hoisted_3$M = { class: "section-content" };
const _hoisted_4$M = { class: "property-row" };
const _hoisted_5$M = ["value"];
const _hoisted_6$M = { class: "property-group" };
const _hoisted_7$M = { class: "property-group" };
const _hoisted_8$K = { class: "control-row" };
const _hoisted_9$K = { class: "property-group" };
const _hoisted_10$J = { class: "control-row" };
const _hoisted_11$I = { class: "property-group" };
const _hoisted_12$G = {
  key: 1,
  class: "property-row"
};
const _hoisted_13$G = ["value"];
const _hoisted_14$C = {
  key: 2,
  class: "property-group"
};
const _hoisted_15$B = {
  key: 3,
  class: "property-group"
};
const _hoisted_16$A = { class: "property-group checkbox-row" };
const _hoisted_17$z = ["checked"];
const _hoisted_18$x = { class: "property-group" };
const _hoisted_19$w = { class: "property-group" };
const _hoisted_20$w = {
  key: 5,
  class: "note"
};
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const lightData = computed(() => {
      return props.layer.data || {
        lightType: "spot",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0,
        coneAngle: 90,
        coneFeather: 50
      };
    });
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...lightData.value, [key]: value }
      });
      emit("update");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        createBaseVNode("div", _hoisted_2$M, [
          _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-header" }, "Light Settings", -1)),
          createBaseVNode("div", _hoisted_3$M, [
            createBaseVNode("div", _hoisted_4$M, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Type", -1)),
              createBaseVNode("select", {
                value: lightData.value.lightType,
                onChange: _cache[0] || (_cache[0] = ($event) => update("lightType", $event.target.value)),
                class: "type-select"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("option", { value: "parallel" }, "Parallel", -1),
                createBaseVNode("option", { value: "spot" }, "Spot", -1),
                createBaseVNode("option", { value: "point" }, "Point", -1),
                createBaseVNode("option", { value: "ambient" }, "Ambient", -1)
              ])], 40, _hoisted_5$M)
            ]),
            createBaseVNode("div", _hoisted_6$M, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: lightData.value.color,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => update("color", v))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$M, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("div", _hoisted_8$K, [
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.intensity,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => update("intensity", v)),
                  min: 0,
                  max: 500,
                  step: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ]),
            lightData.value.lightType === "spot" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_9$K, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "Cone Angle", -1)),
                createBaseVNode("div", _hoisted_10$J, [
                  createVNode(unref(AngleDial), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => update("coneAngle", v)),
                    size: 32
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => update("coneAngle", v)),
                    unit: ""
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11$I, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "Cone Feather", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.coneFeather ?? 50,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => update("coneFeather", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_12$G, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Falloff", -1)),
              createBaseVNode("select", {
                value: lightData.value.falloff,
                onChange: _cache[6] || (_cache[6] = ($event) => update("falloff", $event.target.value)),
                class: "type-select"
              }, [..._cache[18] || (_cache[18] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "smooth" }, "Smooth", -1),
                createBaseVNode("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
              ])], 40, _hoisted_13$G)
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" && lightData.value.lightType !== "parallel" ? (openBlock(), createElementBlock("div", _hoisted_14$C, [
              _cache[20] || (_cache[20] = createBaseVNode("label", null, "Radius", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.radius,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => update("radius", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_15$B, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Falloff Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.falloffDistance ?? 500,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => update("falloffDistance", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_16$A, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: lightData.value.castShadows,
                  onChange: _cache[9] || (_cache[9] = ($event) => update("castShadows", $event.target.checked))
                }, null, 40, _hoisted_17$z),
                _cache[22] || (_cache[22] = createTextVNode(" Casts Shadows ", -1))
              ])
            ]),
            lightData.value.castShadows ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
              createBaseVNode("div", _hoisted_18$x, [
                _cache[23] || (_cache[23] = createBaseVNode("label", null, "Shadow Darkness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.shadowDarkness ?? 100,
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => update("shadowDarkness", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$w, [
                _cache[24] || (_cache[24] = createBaseVNode("label", null, "Shadow Diffusion", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: lightData.value.shadowDiffusion ?? 0,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => update("shadowDiffusion", v)),
                  min: 0,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.castShadows ? (openBlock(), createElementBlock("div", _hoisted_20$w, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const LightProperties = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__scopeId", "data-v-8b65d6d1"]]);

const _hoisted_1$L = { class: "shape-properties" };
const _hoisted_2$L = { class: "prop-section" };
const _hoisted_3$L = { class: "expand-icon" };
const _hoisted_4$L = ["checked"];
const _hoisted_5$L = {
  key: 0,
  class: "section-content"
};
const _hoisted_6$L = { class: "property-row" };
const _hoisted_7$L = { class: "color-input-wrapper" };
const _hoisted_8$J = ["value"];
const _hoisted_9$J = { class: "property-row" };
const _hoisted_10$I = { class: "property-row" };
const _hoisted_11$H = { class: "property-row" };
const _hoisted_12$F = { class: "icon-toggle-group" };
const _hoisted_13$F = { class: "property-row" };
const _hoisted_14$B = { class: "icon-toggle-group" };
const _hoisted_15$A = { class: "property-row" };
const _hoisted_16$z = ["value"];
const _hoisted_17$y = {
  key: 0,
  class: "property-row"
};
const _hoisted_18$w = { class: "prop-section" };
const _hoisted_19$v = { class: "expand-icon" };
const _hoisted_20$v = ["checked"];
const _hoisted_21$u = {
  key: 0,
  class: "section-content"
};
const _hoisted_22$s = { class: "property-row" };
const _hoisted_23$s = { class: "color-input-wrapper" };
const _hoisted_24$m = ["value"];
const _hoisted_25$m = { class: "property-row" };
const _hoisted_26$k = { class: "prop-section" };
const _hoisted_27$k = { class: "expand-icon" };
const _hoisted_28$j = {
  key: 0,
  class: "section-content"
};
const _hoisted_29$j = { class: "property-row" };
const _hoisted_30$i = { class: "property-row" };
const _hoisted_31$g = { class: "property-row" };
const _hoisted_32$g = { class: "prop-section" };
const _hoisted_33$g = { class: "expand-icon" };
const _hoisted_34$e = {
  key: 0,
  class: "effect-count"
};
const _hoisted_35$d = {
  key: 0,
  class: "section-content"
};
const _hoisted_36$c = { class: "add-effect-row" };
const _hoisted_37$c = ["disabled"];
const _hoisted_38$c = { class: "effect-header" };
const _hoisted_39$c = ["onClick"];
const _hoisted_40$b = { class: "effect-name" };
const _hoisted_41$9 = { class: "effect-actions" };
const _hoisted_42$8 = ["onClick", "disabled"];
const _hoisted_43$8 = ["onClick", "disabled"];
const _hoisted_44$8 = ["onClick"];
const _hoisted_45$8 = {
  key: 0,
  class: "effect-params"
};
const _hoisted_46$8 = { class: "property-row" };
const _hoisted_47$8 = ["onClick"];
const _hoisted_48$8 = { class: "property-row" };
const _hoisted_49$8 = { class: "icon-toggle-group" };
const _hoisted_50$7 = ["onClick"];
const _hoisted_51$7 = ["onClick"];
const _hoisted_52$6 = ["onClick"];
const _hoisted_53$6 = { class: "property-row" };
const _hoisted_54$6 = ["onClick"];
const _hoisted_55$6 = { class: "property-row" };
const _hoisted_56$6 = ["onClick"];
const _hoisted_57$5 = { class: "property-row" };
const _hoisted_58$5 = { class: "property-row" };
const _hoisted_59$5 = ["onClick"];
const _hoisted_60$4 = { class: "property-row" };
const _hoisted_61$4 = ["onClick"];
const _hoisted_62$4 = { class: "property-row" };
const _hoisted_63$2 = ["onClick"];
const _hoisted_64$2 = { class: "property-row" };
const _hoisted_65$2 = ["onClick"];
const _hoisted_66$2 = { class: "property-row" };
const _hoisted_67$2 = ["onClick"];
const _hoisted_68$2 = { class: "property-row" };
const _hoisted_69$2 = ["onClick"];
const _hoisted_70$2 = { class: "property-row" };
const _hoisted_71$2 = { class: "icon-toggle-group" };
const _hoisted_72$2 = ["onClick"];
const _hoisted_73$2 = ["onClick"];
const _hoisted_74$1 = { class: "property-row" };
const _hoisted_75$1 = ["onClick"];
const _hoisted_76$1 = { class: "property-row" };
const _hoisted_77$1 = ["onClick"];
const _hoisted_78$1 = { class: "property-row" };
const _hoisted_79$1 = ["onClick"];
const _hoisted_80$1 = { class: "property-row" };
const _hoisted_81$1 = { class: "icon-toggle-group wide" };
const _hoisted_82$1 = ["onClick"];
const _hoisted_83$1 = ["onClick"];
const _hoisted_84$1 = ["onClick"];
const _hoisted_85$1 = {
  key: 0,
  class: "no-effects"
};
const _hoisted_86$1 = { class: "prop-section" };
const _hoisted_87$1 = { class: "expand-icon" };
const _hoisted_88$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_89$1 = { class: "property-row checkbox-row" };
const _hoisted_90$1 = ["checked"];
const _hoisted_91 = { class: "property-row info-row" };
const _hoisted_92 = { class: "info-value" };
const _hoisted_93 = { class: "prop-section" };
const _hoisted_94 = { class: "expand-icon" };
const _hoisted_95 = {
  key: 0,
  class: "attached-count"
};
const _hoisted_96 = {
  key: 0,
  class: "section-content"
};
const _hoisted_97 = {
  key: 0,
  class: "no-attached"
};
const _hoisted_98 = {
  key: 1,
  class: "attached-list"
};
const _hoisted_99 = ["onClick"];
const _hoisted_100 = { class: "attached-icon" };
const _hoisted_101 = { class: "attached-name" };
const _hoisted_102 = { class: "attached-usage" };
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["stroke", "fill", "trim"]);
    const newEffectType = ref("");
    const shapeData = computed(() => {
      return props.layer.data || {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#ffffff",
        strokeWidth: 2,
        strokeOpacity: 100,
        strokeLineCap: "round",
        strokeLineJoin: "round",
        fill: "",
        fillOpacity: 100,
        trimStart: 0,
        trimEnd: 100,
        trimOffset: 0
      };
    });
    const hasFill = computed(() => !!shapeData.value.fill && shapeData.value.fill !== "transparent");
    const hasStroke = computed(() => !!shapeData.value.stroke && (shapeData.value.strokeWidth ?? 0) > 0);
    const strokeLineCap = computed(() => shapeData.value.strokeLineCap || "round");
    const strokeLineJoin = computed(() => shapeData.value.strokeLineJoin || "round");
    const hasDashes = computed(() => (shapeData.value.strokeDashArray?.length ?? 0) > 0);
    const dashArrayString = computed(() => {
      return shapeData.value.strokeDashArray?.join(", ") || "";
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    const attachedLayers = computed(() => {
      const layerId = props.layer.id;
      const attached = [];
      for (const layer of store.layers) {
        if (layer.type === "text") {
          const textData = layer.data;
          if (textData?.pathLayerId === layerId) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Text on path"
            });
          }
        }
        if (layer.type === "camera") {
          const cameraData = layer.data;
          if (cameraData?.pathFollowing?.pathLayerId === layerId) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Camera path"
            });
          }
        }
        if (layer.type === "particles") {
          const particleData = layer.data;
          if (particleData?.emitters?.some((e) => e.shape === "spline" && e.splinePath?.layerId === layerId)) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Particle emitter"
            });
          }
        }
      }
      return attached;
    });
    function getLayerIcon(type) {
      const icons = {
        text: "T",
        camera: "",
        particles: ""
      };
      return icons[type] || "";
    }
    function selectLayer(layerId) {
      store.selectLayer(layerId);
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...shapeData.value, [key]: value }
      });
      emit("update");
    }
    function toggleFill(e) {
      const checked = e.target.checked;
      update("fill", checked ? "#ffffff" : "");
    }
    function toggleStroke(e) {
      const checked = e.target.checked;
      if (checked) {
        update("stroke", "#ffffff");
        if ((shapeData.value.strokeWidth ?? 0) <= 0) {
          update("strokeWidth", 2);
        }
      } else {
        update("strokeWidth", 0);
      }
    }
    function updateDashArray(e) {
      const input = e.target.value;
      if (!input.trim()) {
        update("strokeDashArray", []);
        return;
      }
      const values = input.split(",").map((v) => parseFloat(v.trim())).filter((v) => !isNaN(v) && v >= 0);
      update("strokeDashArray", values);
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      update(dataKey, value);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
    }
    function toggleKeyframe(propName, dataKey) {
      ensureProperty(propName, dataKey);
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function ensureProperty(propName, dataKey) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        const currentValue = shapeData.value[dataKey] ?? 0;
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: currentValue,
          animated: false,
          keyframes: [],
          group: propName.includes("Trim") ? "Trim Paths" : propName.includes("Stroke") ? "Stroke" : propName.includes("Fill") ? "Fill" : "Shape"
        });
      }
    }
    const pathEffects = computed(() => {
      return (shapeData.value.pathEffects || []).sort((a, b) => a.order - b.order);
    });
    function getEffectDisplayName(type) {
      const names = {
        offsetPath: "Offset Path",
        roughen: "Roughen",
        wiggle: "Wiggle Path",
        zigzag: "Zig Zag",
        wave: "Wave"
      };
      return names[type] || type;
    }
    function generateId() {
      return `effect_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
    }
    function createAnimatableProp(value, name) {
      return {
        id: generateId(),
        name,
        type: "number",
        value,
        animated: false,
        keyframes: []
      };
    }
    function addEffect() {
      if (!newEffectType.value) return;
      const effects = [...shapeData.value.pathEffects || []];
      const newOrder = effects.length > 0 ? Math.max(...effects.map((e) => e.order)) + 1 : 0;
      let newEffect;
      switch (newEffectType.value) {
        case "offsetPath":
          newEffect = {
            id: generateId(),
            type: "offsetPath",
            enabled: true,
            order: newOrder,
            amount: createAnimatableProp(0, "Offset Amount"),
            lineJoin: "round",
            miterLimit: createAnimatableProp(4, "Miter Limit")
          };
          break;
        case "roughen":
          newEffect = {
            id: generateId(),
            type: "roughen",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(5, "Roughen Size"),
            detail: createAnimatableProp(2, "Roughen Detail"),
            seed: Math.floor(Math.random() * 99999)
          };
          break;
        case "wiggle":
          newEffect = {
            id: generateId(),
            type: "wiggle",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(10, "Wiggle Size"),
            detail: createAnimatableProp(3, "Wiggle Detail"),
            temporalPhase: createAnimatableProp(0, "Temporal Phase"),
            spatialPhase: createAnimatableProp(0, "Spatial Phase"),
            correlation: createAnimatableProp(50, "Correlation"),
            seed: Math.floor(Math.random() * 99999)
          };
          break;
        case "zigzag":
          newEffect = {
            id: generateId(),
            type: "zigzag",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(10, "Zig Zag Size"),
            ridgesPerSegment: createAnimatableProp(5, "Ridges Per Segment"),
            pointType: "smooth"
          };
          break;
        case "wave":
          newEffect = {
            id: generateId(),
            type: "wave",
            enabled: true,
            order: newOrder,
            amplitude: createAnimatableProp(10, "Wave Amplitude"),
            frequency: createAnimatableProp(2, "Wave Frequency"),
            phase: createAnimatableProp(0, "Wave Phase"),
            waveType: "sine"
          };
          break;
        default:
          return;
      }
      effects.push(newEffect);
      update("pathEffects", effects);
      newEffectType.value = "";
    }
    function removeEffect(effectId) {
      const effects = (shapeData.value.pathEffects || []).filter((e) => e.id !== effectId);
      update("pathEffects", effects);
    }
    function toggleEffect(effectId) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (effect) {
        effect.enabled = !effect.enabled;
        update("pathEffects", effects);
      }
    }
    function moveEffect(index, direction) {
      const effects = [...shapeData.value.pathEffects || []].sort((a, b) => a.order - b.order);
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= effects.length) return;
      const tempOrder = effects[index].order;
      effects[index].order = effects[newIndex].order;
      effects[newIndex].order = tempOrder;
      update("pathEffects", effects);
    }
    function getEffectPropValue(effect, propName) {
      const prop = effect[propName];
      if (prop === void 0) return 0;
      if (typeof prop === "number") return prop;
      return prop.value;
    }
    function isEffectPropAnimated(effect, propName) {
      const prop = effect[propName];
      if (!prop || typeof prop === "number") return false;
      return prop.animated ?? false;
    }
    function updateEffectProp(effectId, propName, value) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      const prop = effect[propName];
      if (prop && typeof prop === "object") {
        prop.value = value;
      } else {
        effect[propName] = value;
      }
      update("pathEffects", effects);
    }
    function updateEffectMeta(effectId, key, value) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      effect[key] = value;
      update("pathEffects", effects);
    }
    function toggleEffectKeyframe(effectId, propName) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      const prop = effect[propName];
      if (!prop || typeof prop === "number") return;
      const frame = store.currentFrame;
      const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
      if (hasKeyframeAtFrame) {
        prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
        prop.animated = prop.keyframes.length > 0;
      } else {
        prop.keyframes.push({
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          frame,
          value: prop.value,
          easing: "linear"
        });
        prop.animated = true;
      }
      update("pathEffects", effects);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        createBaseVNode("div", _hoisted_2$L, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("stroke"))
          }, [
            createBaseVNode("span", _hoisted_3$L, toDisplayString(expandedSections.value.includes("stroke") ? "" : ""), 1),
            _cache[32] || (_cache[32] = createBaseVNode("span", { class: "section-title" }, "Stroke", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasStroke.value,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleStroke,
              class: "section-toggle"
            }, null, 40, _hoisted_4$L)
          ]),
          expandedSections.value.includes("stroke") && hasStroke.value ? (openBlock(), createElementBlock("div", _hoisted_5$L, [
            createBaseVNode("div", _hoisted_6$L, [
              _cache[33] || (_cache[33] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_7$L, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.stroke || "#ffffff",
                  onInput: _cache[2] || (_cache[2] = (e) => update("stroke", e.target.value))
                }, null, 40, _hoisted_8$J)
              ])
            ]),
            createBaseVNode("div", _hoisted_9$J, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Opacity") ?? shapeData.value.strokeOpacity ?? 100,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateAnimatable("Stroke Opacity", v, "strokeOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Opacity") }]),
                onClick: _cache[4] || (_cache[4] = ($event) => toggleKeyframe("Stroke Opacity", "strokeOpacity"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_10$I, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Width", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Width") ?? shapeData.value.strokeWidth ?? 2,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v, "strokeWidth")),
                min: 0,
                max: 500,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Width") }]),
                onClick: _cache[6] || (_cache[6] = ($event) => toggleKeyframe("Stroke Width", "strokeWidth"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_11$H, [
              _cache[36] || (_cache[36] = createBaseVNode("label", null, "Line Cap", -1)),
              createBaseVNode("div", _hoisted_12$F, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "butt" }),
                  onClick: _cache[7] || (_cache[7] = ($event) => update("strokeLineCap", "butt")),
                  title: "Butt Cap"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "round" }),
                  onClick: _cache[8] || (_cache[8] = ($event) => update("strokeLineCap", "round")),
                  title: "Round Cap"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "square" }),
                  onClick: _cache[9] || (_cache[9] = ($event) => update("strokeLineCap", "square")),
                  title: "Square Cap"
                }, "", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$F, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Line Join", -1)),
              createBaseVNode("div", _hoisted_14$B, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "miter" }),
                  onClick: _cache[10] || (_cache[10] = ($event) => update("strokeLineJoin", "miter")),
                  title: "Miter Join"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "round" }),
                  onClick: _cache[11] || (_cache[11] = ($event) => update("strokeLineJoin", "round")),
                  title: "Round Join"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "bevel" }),
                  onClick: _cache[12] || (_cache[12] = ($event) => update("strokeLineJoin", "bevel")),
                  title: "Bevel Join"
                }, "", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_15$A, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Dashes", -1)),
              createBaseVNode("input", {
                type: "text",
                class: "dash-input",
                value: dashArrayString.value,
                onChange: updateDashArray,
                placeholder: "e.g. 10, 5",
                title: "Comma-separated dash pattern"
              }, null, 40, _hoisted_16$z)
            ]),
            hasDashes.value ? (openBlock(), createElementBlock("div", _hoisted_17$y, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Dash Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Dash Offset") ?? shapeData.value.strokeDashOffset ?? 0,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateAnimatable("Dash Offset", v, "strokeDashOffset"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Dash Offset") }]),
                onClick: _cache[14] || (_cache[14] = ($event) => toggleKeyframe("Dash Offset", "strokeDashOffset"))
              }, "", 2)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_18$w, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[16] || (_cache[16] = ($event) => toggleSection("fill"))
          }, [
            createBaseVNode("span", _hoisted_19$v, toDisplayString(expandedSections.value.includes("fill") ? "" : ""), 1),
            _cache[40] || (_cache[40] = createBaseVNode("span", { class: "section-title" }, "Fill", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasFill.value,
              onClick: _cache[15] || (_cache[15] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleFill,
              class: "section-toggle"
            }, null, 40, _hoisted_20$v)
          ]),
          expandedSections.value.includes("fill") && hasFill.value ? (openBlock(), createElementBlock("div", _hoisted_21$u, [
            createBaseVNode("div", _hoisted_22$s, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_23$s, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.fill || "#ffffff",
                  onInput: _cache[17] || (_cache[17] = (e) => update("fill", e.target.value))
                }, null, 40, _hoisted_24$m)
              ])
            ]),
            createBaseVNode("div", _hoisted_25$m, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Fill Opacity") ?? shapeData.value.fillOpacity ?? 100,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Fill Opacity", v, "fillOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Fill Opacity") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Fill Opacity", "fillOpacity"))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_26$k, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[20] || (_cache[20] = ($event) => toggleSection("trim"))
          }, [
            createBaseVNode("span", _hoisted_27$k, toDisplayString(expandedSections.value.includes("trim") ? "" : ""), 1),
            _cache[43] || (_cache[43] = createBaseVNode("span", { class: "section-title" }, "Trim Paths", -1))
          ]),
          expandedSections.value.includes("trim") ? (openBlock(), createElementBlock("div", _hoisted_28$j, [
            createBaseVNode("div", _hoisted_29$j, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Start", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Start") ?? shapeData.value.trimStart ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Trim Start", v, "trimStart")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Start") }]),
                onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("Trim Start", "trimStart"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_30$i, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "End", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim End") ?? shapeData.value.trimEnd ?? 100,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updateAnimatable("Trim End", v, "trimEnd")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim End") }]),
                onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("Trim End", "trimEnd"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_31$g, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Offset") ?? shapeData.value.trimOffset ?? 0,
                "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Trim Offset", v, "trimOffset")),
                min: -360,
                max: 360,
                unit: ""
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Offset") }]),
                onClick: _cache[26] || (_cache[26] = ($event) => toggleKeyframe("Trim Offset", "trimOffset"))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$g, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[27] || (_cache[27] = ($event) => toggleSection("effects"))
          }, [
            createBaseVNode("span", _hoisted_33$g, toDisplayString(expandedSections.value.includes("effects") ? "" : ""), 1),
            _cache[47] || (_cache[47] = createBaseVNode("span", { class: "section-title" }, "Path Effects", -1)),
            pathEffects.value.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_34$e, toDisplayString(pathEffects.value.length), 1)) : createCommentVNode("", true)
          ]),
          expandedSections.value.includes("effects") ? (openBlock(), createElementBlock("div", _hoisted_35$d, [
            createBaseVNode("div", _hoisted_36$c, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => newEffectType.value = $event),
                class: "effect-select"
              }, [..._cache[48] || (_cache[48] = [
                createStaticVNode('<option value="" data-v-9b90aa5e>Add Effect...</option><option value="offsetPath" data-v-9b90aa5e>Offset Path</option><option value="roughen" data-v-9b90aa5e>Roughen</option><option value="wiggle" data-v-9b90aa5e>Wiggle Path</option><option value="zigzag" data-v-9b90aa5e>Zig Zag</option><option value="wave" data-v-9b90aa5e>Wave</option>', 6)
              ])], 512), [
                [vModelSelect, newEffectType.value]
              ]),
              createBaseVNode("button", {
                class: "add-btn",
                onClick: addEffect,
                disabled: !newEffectType.value
              }, "+", 8, _hoisted_37$c)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(pathEffects.value, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: "effect-item"
              }, [
                createBaseVNode("div", _hoisted_38$c, [
                  createBaseVNode("button", {
                    class: "effect-toggle",
                    onClick: ($event) => toggleEffect(effect.id)
                  }, toDisplayString(effect.enabled ? "" : ""), 9, _hoisted_39$c),
                  createBaseVNode("span", _hoisted_40$b, toDisplayString(getEffectDisplayName(effect.type)), 1),
                  createBaseVNode("div", _hoisted_41$9, [
                    createBaseVNode("button", {
                      class: "effect-action",
                      onClick: ($event) => moveEffect(index, -1),
                      disabled: index === 0,
                      title: "Move Up"
                    }, "", 8, _hoisted_42$8),
                    createBaseVNode("button", {
                      class: "effect-action",
                      onClick: ($event) => moveEffect(index, 1),
                      disabled: index === pathEffects.value.length - 1,
                      title: "Move Down"
                    }, "", 8, _hoisted_43$8),
                    createBaseVNode("button", {
                      class: "effect-action delete",
                      onClick: ($event) => removeEffect(effect.id),
                      title: "Delete"
                    }, "", 8, _hoisted_44$8)
                  ])
                ]),
                effect.enabled ? (openBlock(), createElementBlock("div", _hoisted_45$8, [
                  effect.type === "offsetPath" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("div", _hoisted_46$8, [
                      _cache[49] || (_cache[49] = createBaseVNode("label", null, "Amount", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "amount"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "amount", v),
                        min: -100,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "amount") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "amount")
                      }, "", 10, _hoisted_47$8)
                    ]),
                    createBaseVNode("div", _hoisted_48$8, [
                      _cache[50] || (_cache[50] = createBaseVNode("label", null, "Join", -1)),
                      createBaseVNode("div", _hoisted_49$8, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "miter" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "miter")
                        }, "", 10, _hoisted_50$7),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "round" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "round")
                        }, "", 10, _hoisted_51$7),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "bevel" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "bevel")
                        }, "", 10, _hoisted_52$6)
                      ])
                    ])
                  ], 64)) : effect.type === "roughen" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createBaseVNode("div", _hoisted_53$6, [
                      _cache[51] || (_cache[51] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_54$6)
                    ]),
                    createBaseVNode("div", _hoisted_55$6, [
                      _cache[52] || (_cache[52] = createBaseVNode("label", null, "Detail", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "detail"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "detail", v),
                        min: 1,
                        max: 10,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "detail") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "detail")
                      }, "", 10, _hoisted_56$6)
                    ]),
                    createBaseVNode("div", _hoisted_57$5, [
                      _cache[53] || (_cache[53] = createBaseVNode("label", null, "Seed", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: effect.seed ?? 12345,
                        "onUpdate:modelValue": (v) => updateEffectMeta(effect.id, "seed", v),
                        min: 0,
                        max: 99999,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])
                  ], 64)) : effect.type === "wiggle" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createBaseVNode("div", _hoisted_58$5, [
                      _cache[54] || (_cache[54] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_59$5)
                    ]),
                    createBaseVNode("div", _hoisted_60$4, [
                      _cache[55] || (_cache[55] = createBaseVNode("label", null, "Detail", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "detail"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "detail", v),
                        min: 1,
                        max: 10,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "detail") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "detail")
                      }, "", 10, _hoisted_61$4)
                    ]),
                    createBaseVNode("div", _hoisted_62$4, [
                      _cache[56] || (_cache[56] = createBaseVNode("label", null, "Correlation", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "correlation"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "correlation", v),
                        min: 0,
                        max: 100,
                        unit: "%"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "correlation") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "correlation")
                      }, "", 10, _hoisted_63$2)
                    ]),
                    createBaseVNode("div", _hoisted_64$2, [
                      _cache[57] || (_cache[57] = createBaseVNode("label", null, "Temp Phase", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "temporalPhase"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "temporalPhase", v),
                        min: 0,
                        max: 360,
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "temporalPhase") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "temporalPhase")
                      }, "", 10, _hoisted_65$2)
                    ])
                  ], 64)) : effect.type === "zigzag" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                    createBaseVNode("div", _hoisted_66$2, [
                      _cache[58] || (_cache[58] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_67$2)
                    ]),
                    createBaseVNode("div", _hoisted_68$2, [
                      _cache[59] || (_cache[59] = createBaseVNode("label", null, "Ridges", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "ridgesPerSegment"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "ridgesPerSegment", v),
                        min: 1,
                        max: 20,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "ridgesPerSegment") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "ridgesPerSegment")
                      }, "", 10, _hoisted_69$2)
                    ]),
                    createBaseVNode("div", _hoisted_70$2, [
                      _cache[60] || (_cache[60] = createBaseVNode("label", null, "Points", -1)),
                      createBaseVNode("div", _hoisted_71$2, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.pointType === "corner" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "pointType", "corner")
                        }, "", 10, _hoisted_72$2),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.pointType === "smooth" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "pointType", "smooth")
                        }, "", 10, _hoisted_73$2)
                      ])
                    ])
                  ], 64)) : effect.type === "wave" ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                    createBaseVNode("div", _hoisted_74$1, [
                      _cache[61] || (_cache[61] = createBaseVNode("label", null, "Amplitude", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "amplitude"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "amplitude", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "amplitude") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "amplitude")
                      }, "", 10, _hoisted_75$1)
                    ]),
                    createBaseVNode("div", _hoisted_76$1, [
                      _cache[62] || (_cache[62] = createBaseVNode("label", null, "Frequency", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "frequency"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "frequency", v),
                        min: 0.1,
                        max: 20,
                        step: 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "frequency") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "frequency")
                      }, "", 10, _hoisted_77$1)
                    ]),
                    createBaseVNode("div", _hoisted_78$1, [
                      _cache[63] || (_cache[63] = createBaseVNode("label", null, "Phase", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "phase"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "phase", v),
                        min: 0,
                        max: 360,
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "phase") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "phase")
                      }, "", 10, _hoisted_79$1)
                    ]),
                    createBaseVNode("div", _hoisted_80$1, [
                      _cache[64] || (_cache[64] = createBaseVNode("label", null, "Type", -1)),
                      createBaseVNode("div", _hoisted_81$1, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "sine" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "sine")
                        }, "", 10, _hoisted_82$1),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "triangle" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "triangle")
                        }, "", 10, _hoisted_83$1),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "square" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "square")
                        }, "", 10, _hoisted_84$1)
                      ])
                    ])
                  ], 64)) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            pathEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_85$1, " No path effects. Use the dropdown above to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_86$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_87$1, toDisplayString(expandedSections.value.includes("path") ? "" : ""), 1),
            _cache[65] || (_cache[65] = createBaseVNode("span", { class: "section-title" }, "Path", -1))
          ]),
          expandedSections.value.includes("path") ? (openBlock(), createElementBlock("div", _hoisted_88$1, [
            createBaseVNode("div", _hoisted_89$1, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: shapeData.value.closed,
                  onChange: _cache[30] || (_cache[30] = ($event) => update("closed", $event.target.checked))
                }, null, 40, _hoisted_90$1),
                _cache[66] || (_cache[66] = createTextVNode(" Closed Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_91, [
              _cache[67] || (_cache[67] = createBaseVNode("span", { class: "info-label" }, "Points:", -1)),
              createBaseVNode("span", _hoisted_92, toDisplayString(shapeData.value.controlPoints?.length || 0), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_93, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[31] || (_cache[31] = ($event) => toggleSection("attached"))
          }, [
            createBaseVNode("span", _hoisted_94, toDisplayString(expandedSections.value.includes("attached") ? "" : ""), 1),
            _cache[68] || (_cache[68] = createBaseVNode("span", { class: "section-title" }, "Motion Path Usage", -1)),
            attachedLayers.value.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_95, toDisplayString(attachedLayers.value.length), 1)) : createCommentVNode("", true)
          ]),
          expandedSections.value.includes("attached") ? (openBlock(), createElementBlock("div", _hoisted_96, [
            attachedLayers.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_97, [..._cache[69] || (_cache[69] = [
              createTextVNode(" No layers are using this shape as a motion path. ", -1),
              createBaseVNode("p", { class: "hint-text" }, "Text, cameras, and particles can follow this shape's outline.", -1)
            ])])) : (openBlock(), createElementBlock("div", _hoisted_98, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(attachedLayers.value, (attached) => {
                return openBlock(), createElementBlock("div", {
                  key: attached.id,
                  class: "attached-item",
                  onClick: ($event) => selectLayer(attached.id)
                }, [
                  createBaseVNode("span", _hoisted_100, toDisplayString(getLayerIcon(attached.type)), 1),
                  createBaseVNode("span", _hoisted_101, toDisplayString(attached.name), 1),
                  createBaseVNode("span", _hoisted_102, toDisplayString(attached.usage), 1)
                ], 8, _hoisted_99);
              }), 128))
            ]))
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ShapeProperties = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__scopeId", "data-v-9b90aa5e"]]);

const _hoisted_1$K = { class: "path-properties" };
const _hoisted_2$K = { class: "prop-section" };
const _hoisted_3$K = { class: "expand-icon" };
const _hoisted_4$K = ["checked"];
const _hoisted_5$K = {
  key: 0,
  class: "section-content"
};
const _hoisted_6$K = { class: "property-row" };
const _hoisted_7$K = { class: "color-input-wrapper" };
const _hoisted_8$I = ["value"];
const _hoisted_9$I = { class: "color-hex" };
const _hoisted_10$H = { class: "property-row" };
const _hoisted_11$G = { class: "property-row" };
const _hoisted_12$E = { class: "property-row preset-row" };
const _hoisted_13$E = { class: "preset-buttons" };
const _hoisted_14$A = ["onClick", "title"];
const _hoisted_15$z = { class: "prop-section" };
const _hoisted_16$y = { class: "expand-icon" };
const _hoisted_17$x = {
  key: 0,
  class: "section-content"
};
const _hoisted_18$v = { class: "property-row checkbox-row" };
const _hoisted_19$u = ["checked"];
const _hoisted_20$u = { class: "property-row info-row" };
const _hoisted_21$t = { class: "info-value" };
const _hoisted_22$r = { class: "property-row info-row" };
const _hoisted_23$r = { class: "info-value" };
const _hoisted_24$l = { class: "prop-section" };
const _hoisted_25$l = { class: "expand-icon" };
const _hoisted_26$j = {
  key: 0,
  class: "attached-count"
};
const _hoisted_27$j = {
  key: 0,
  class: "section-content"
};
const _hoisted_28$i = {
  key: 0,
  class: "no-attached"
};
const _hoisted_29$i = {
  key: 1,
  class: "attached-list"
};
const _hoisted_30$h = ["onClick"];
const _hoisted_31$f = { class: "attached-icon" };
const _hoisted_32$f = { class: "attached-name" };
const _hoisted_33$f = { class: "attached-usage" };
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "PathProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["guide", "path"]);
    const guidePresets = [
      { name: "Solid", color: "#00FFFF", dash: 0, gap: 0, icon: "" },
      { name: "Dotted", color: "#00FFFF", dash: 2, gap: 4, icon: "" },
      { name: "Dashed", color: "#00FFFF", dash: 10, gap: 5, icon: "- -" },
      { name: "Long Dash", color: "#00FFFF", dash: 20, gap: 10, icon: "" }
    ];
    const pathData = computed(() => {
      return props.layer.data || {
        pathData: "",
        controlPoints: [],
        closed: false,
        showGuide: true,
        guideColor: "#00FFFF",
        guideDashPattern: [10, 5]
      };
    });
    const dashValue = computed(() => pathData.value.guideDashPattern?.[0] ?? 10);
    const gapValue = computed(() => pathData.value.guideDashPattern?.[1] ?? 5);
    const attachedLayers = computed(() => {
      const layerId = props.layer.id;
      const attached = [];
      for (const layer of store.layers) {
        if (layer.type === "text") {
          const textData = layer.data;
          if (textData?.pathLayerId === layerId) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Text on path"
            });
          }
        }
        if (layer.type === "camera") {
          const cameraData = layer.data;
          if (cameraData?.trajectory?.splineLayerId === layerId) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Camera path"
            });
          }
        }
        if (layer.type === "particles") {
          const particleData = layer.data;
          if (particleData?.emitters?.some((e) => e.shape === "spline" && e.splinePath?.layerId === layerId)) {
            attached.push({
              id: layer.id,
              name: layer.name,
              type: layer.type,
              usage: "Particle emitter"
            });
          }
        }
      }
      return attached;
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...pathData.value, [key]: value }
      });
      emit("update");
    }
    function toggleGuide(e) {
      const checked = e.target.checked;
      update("showGuide", checked);
    }
    function updateDash(value) {
      const pattern = [value, pathData.value.guideDashPattern?.[1] ?? 5];
      update("guideDashPattern", pattern);
    }
    function updateGap(value) {
      const pattern = [pathData.value.guideDashPattern?.[0] ?? 10, value];
      update("guideDashPattern", pattern);
    }
    function applyPreset(preset) {
      update("guideColor", preset.color);
      if (preset.dash === 0 && preset.gap === 0) {
        update("guideDashPattern", [1, 0]);
      } else {
        update("guideDashPattern", [preset.dash, preset.gap]);
      }
    }
    function isPresetActive(preset) {
      const dash = pathData.value.guideDashPattern?.[0] ?? 10;
      const gap = pathData.value.guideDashPattern?.[1] ?? 5;
      if (preset.dash === 0 && preset.gap === 0) {
        return gap === 0;
      }
      return dash === preset.dash && gap === preset.gap;
    }
    function getLayerIcon(type) {
      const icons = {
        text: "T",
        camera: "",
        particles: ""
      };
      return icons[type] || "";
    }
    function selectLayer(layerId) {
      store.selectLayer(layerId);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        createBaseVNode("div", _hoisted_2$K, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("guide"))
          }, [
            createBaseVNode("span", _hoisted_3$K, toDisplayString(expandedSections.value.includes("guide") ? "" : ""), 1),
            _cache[8] || (_cache[8] = createBaseVNode("span", { class: "section-title" }, "Guide Line", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: pathData.value.showGuide,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleGuide,
              class: "section-toggle",
              title: "Show/hide guide line in editor"
            }, null, 40, _hoisted_4$K)
          ]),
          expandedSections.value.includes("guide") && pathData.value.showGuide ? (openBlock(), createElementBlock("div", _hoisted_5$K, [
            createBaseVNode("div", _hoisted_6$K, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_7$K, [
                createBaseVNode("input", {
                  type: "color",
                  value: pathData.value.guideColor || "#00FFFF",
                  onInput: _cache[2] || (_cache[2] = (e) => update("guideColor", e.target.value))
                }, null, 40, _hoisted_8$I),
                createBaseVNode("span", _hoisted_9$I, toDisplayString(pathData.value.guideColor || "#00FFFF"), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_10$H, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Dash", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: dashValue.value,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateDash(v)),
                min: 1,
                max: 50,
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_11$G, [
              _cache[11] || (_cache[11] = createBaseVNode("label", null, "Gap", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: gapValue.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateGap(v)),
                min: 1,
                max: 50,
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_12$E, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Presets", -1)),
              createBaseVNode("div", _hoisted_13$E, [
                (openBlock(), createElementBlock(Fragment, null, renderList(guidePresets, (preset) => {
                  return createBaseVNode("button", {
                    key: preset.name,
                    class: normalizeClass({ active: isPresetActive(preset) }),
                    onClick: ($event) => applyPreset(preset),
                    title: preset.name
                  }, toDisplayString(preset.icon), 11, _hoisted_14$A);
                }), 64))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_15$z, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_16$y, toDisplayString(expandedSections.value.includes("path") ? "" : ""), 1),
            _cache[13] || (_cache[13] = createBaseVNode("span", { class: "section-title" }, "Path", -1))
          ]),
          expandedSections.value.includes("path") ? (openBlock(), createElementBlock("div", _hoisted_17$x, [
            createBaseVNode("div", _hoisted_18$v, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathData.value.closed,
                  onChange: _cache[6] || (_cache[6] = ($event) => update("closed", $event.target.checked))
                }, null, 40, _hoisted_19$u),
                _cache[14] || (_cache[14] = createTextVNode(" Closed Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_20$u, [
              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "info-label" }, "Points:", -1)),
              createBaseVNode("span", _hoisted_21$t, toDisplayString(pathData.value.controlPoints?.length || 0), 1)
            ]),
            createBaseVNode("div", _hoisted_22$r, [
              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "info-label" }, "Animated:", -1)),
              createBaseVNode("span", _hoisted_23$r, toDisplayString(pathData.value.animated ? "Yes" : "No"), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_24$l, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("attached"))
          }, [
            createBaseVNode("span", _hoisted_25$l, toDisplayString(expandedSections.value.includes("attached") ? "" : ""), 1),
            _cache[17] || (_cache[17] = createBaseVNode("span", { class: "section-title" }, "Attached Elements", -1)),
            attachedLayers.value.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_26$j, toDisplayString(attachedLayers.value.length), 1)) : createCommentVNode("", true)
          ]),
          expandedSections.value.includes("attached") ? (openBlock(), createElementBlock("div", _hoisted_27$j, [
            attachedLayers.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_28$i, " No layers are using this path. ")) : (openBlock(), createElementBlock("div", _hoisted_29$i, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(attachedLayers.value, (attached) => {
                return openBlock(), createElementBlock("div", {
                  key: attached.id,
                  class: "attached-item",
                  onClick: ($event) => selectLayer(attached.id)
                }, [
                  createBaseVNode("span", _hoisted_31$f, toDisplayString(getLayerIcon(attached.type)), 1),
                  createBaseVNode("span", _hoisted_32$f, toDisplayString(attached.name), 1),
                  createBaseVNode("span", _hoisted_33$f, toDisplayString(attached.usage), 1)
                ], 8, _hoisted_30$h);
              }), 128))
            ]))
          ])) : createCommentVNode("", true)
        ]),
        _cache[18] || (_cache[18] = createBaseVNode("div", { class: "usage-hints" }, [
          createBaseVNode("p", { class: "hint-title" }, "Path Layer"),
          createBaseVNode("p", { class: "hint-text" }, " Motion paths are invisible guides used for: "),
          createBaseVNode("ul", { class: "hint-list" }, [
            createBaseVNode("li", null, "Text on path"),
            createBaseVNode("li", null, "Camera trajectories"),
            createBaseVNode("li", null, "Particle emitter paths")
          ])
        ], -1))
      ]);
    };
  }
});

const PathProperties = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__scopeId", "data-v-9ae86351"]]);

const _hoisted_1$J = { class: "video-properties" };
const _hoisted_2$J = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$J = { class: "section-content info-grid" };
const _hoisted_4$J = { class: "info-row" };
const _hoisted_5$J = { class: "info-value" };
const _hoisted_6$J = { class: "info-row" };
const _hoisted_7$J = { class: "info-value" };
const _hoisted_8$H = { class: "info-row" };
const _hoisted_9$H = { class: "info-value" };
const _hoisted_10$G = { class: "info-row" };
const _hoisted_11$F = { class: "info-value" };
const _hoisted_12$D = { class: "property-section" };
const _hoisted_13$D = { class: "section-content" };
const _hoisted_14$z = { class: "property-row" };
const _hoisted_15$y = { class: "property-row" };
const _hoisted_16$x = { class: "property-row" };
const _hoisted_17$w = { class: "checkbox-group" };
const _hoisted_18$u = { class: "checkbox-row" };
const _hoisted_19$t = ["checked"];
const _hoisted_20$t = { class: "checkbox-row" };
const _hoisted_21$s = ["checked"];
const _hoisted_22$q = { class: "property-section" };
const _hoisted_23$q = { class: "section-header" };
const _hoisted_24$k = { class: "header-toggle" };
const _hoisted_25$k = ["checked"];
const _hoisted_26$i = {
  key: 0,
  class: "section-content"
};
const _hoisted_27$i = { class: "property-row" };
const _hoisted_28$h = { class: "control-with-keyframe" };
const _hoisted_29$h = { class: "property-section" };
const _hoisted_30$g = { class: "section-content" };
const _hoisted_31$e = { class: "property-row" };
const _hoisted_32$e = ["value"];
const _hoisted_33$e = { class: "property-section" };
const _hoisted_34$d = { class: "section-header" };
const _hoisted_35$c = { class: "header-toggle" };
const _hoisted_36$b = ["checked"];
const _hoisted_37$b = {
  key: 0,
  class: "section-content"
};
const _hoisted_38$b = { class: "property-row" };
const _hoisted_39$b = { class: "control-with-keyframe" };
const _hoisted_40$a = { class: "property-row" };
const _hoisted_41$8 = ["value"];
const _hoisted_42$7 = { class: "preset-buttons" };
const _hoisted_43$7 = {
  key: 1,
  class: "property-section"
};
const _hoisted_44$7 = { class: "section-content" };
const _hoisted_45$7 = { class: "checkbox-group" };
const _hoisted_46$7 = { class: "checkbox-row" };
const _hoisted_47$7 = ["checked"];
const _hoisted_48$7 = {
  key: 0,
  class: "property-row"
};
const _hoisted_49$7 = { class: "control-with-keyframe" };
const _hoisted_50$6 = {
  key: 1,
  class: "property-row"
};
const _hoisted_51$6 = {
  key: 2,
  class: "waveform-container"
};
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const videoData = computed(() => {
      return props.layer.data || {
        assetId: null,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        speedMapEnabled: false,
        speedMap: void 0,
        // Backwards compatibility
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: true,
        audioLevel: 100,
        posterFrame: 0
      };
    });
    const assetInfo = computed(() => {
      const assetId = videoData.value.assetId;
      if (!assetId) return null;
      return store.assets[assetId] || null;
    });
    const audioLevel = computed(() => {
      return props.layer.audio?.level;
    });
    const speedMapEnabled = computed(() => {
      return videoData.value.speedMapEnabled ?? videoData.value.timeRemapEnabled ?? false;
    });
    const speedMapProperty = computed(() => {
      return videoData.value.speedMap ?? videoData.value.timeRemap;
    });
    const speedMapValue = computed(() => {
      const prop = speedMapProperty.value;
      if (!prop) return 0;
      return prop.value;
    });
    function formatDuration(seconds) {
      if (!seconds) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = Math.floor(seconds % 1 * (assetInfo.value?.fps || 30));
      return `${mins}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
    }
    function updateSpeed(val) {
      store.updateVideoLayerData(props.layer.id, { speed: val });
      emit("update");
    }
    function updateStartTime(val) {
      store.updateVideoLayerData(props.layer.id, { startTime: val });
      emit("update");
    }
    function updateEndTime(val) {
      store.updateVideoLayerData(props.layer.id, { endTime: val });
      emit("update");
    }
    function updateLoop(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { loop: target.checked });
      emit("update");
    }
    function updatePingPong(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { pingPong: target.checked });
      emit("update");
    }
    function toggleSpeedMap(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, {
        speedMapEnabled: target.checked,
        timeRemapEnabled: target.checked
        // Backwards compatibility
      });
      emit("update");
    }
    function updateSpeedMap(val) {
      const data = props.layer.data;
      if (data.speedMap) {
        data.speedMap.value = val;
      }
      if (data.timeRemap) {
        data.timeRemap.value = val;
      }
      emit("update");
    }
    function updateFrameBlending(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { frameBlending: target.value });
      emit("update");
    }
    const timewarpEnabled = computed(() => {
      return videoData.value.timewarpEnabled ?? false;
    });
    const timewarpSpeedProperty = computed(() => {
      return videoData.value.timewarpSpeed;
    });
    const timewarpSpeedValue = computed(() => {
      const prop = timewarpSpeedProperty.value;
      if (!prop) return 100;
      return prop.value;
    });
    function toggleTimewarp(e) {
      const target = e.target;
      const updates = {
        timewarpEnabled: target.checked
      };
      if (target.checked && !videoData.value.timewarpSpeed) {
        updates.timewarpSpeed = {
          value: 100,
          type: "number",
          animated: false,
          keyframes: []
        };
        updates.timewarpMethod = "frame-mix";
      }
      store.updateVideoLayerData(props.layer.id, updates);
      emit("update");
    }
    function updateTimewarpSpeed(val) {
      const data = props.layer.data;
      if (data.timewarpSpeed) {
        data.timewarpSpeed.value = val;
      }
      emit("update");
    }
    function updateTimewarpMethod(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, {
        timewarpMethod: target.value
      });
      emit("update");
    }
    function applyTimewarpPreset(preset) {
      import('./weyl-timewarp.js').then(({ createSpeedRampPreset }) => {
        const layerStart = props.layer.startFrame ?? 0;
        const layerEnd = props.layer.endFrame ?? store.frameCount;
        const duration = layerEnd - layerStart;
        const fps = store.fps || 30;
        const presetProperty = createSpeedRampPreset(preset, layerStart, duration, fps);
        store.updateVideoLayerData(props.layer.id, {
          timewarpEnabled: true,
          timewarpSpeed: presetProperty,
          timewarpMethod: "pixel-motion"
        });
        emit("update");
      });
    }
    function updateAudioEnabled(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { audioEnabled: target.checked });
      emit("update");
    }
    function updateAudioLevel(val) {
      store.updateVideoLayerData(props.layer.id, { audioLevel: val });
      emit("update");
    }
    function updateLevel(val) {
      if (props.layer.audio?.level) {
        props.layer.audio.level.value = val;
        emit("update");
      }
    }
    function onKeyframeChange() {
      emit("update");
    }
    function onAnimationToggled(animated) {
      console.log("[VideoProperties] Animation toggled:", animated);
      emit("update");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        assetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$J, [
          _cache[8] || (_cache[8] = createBaseVNode("div", { class: "section-header" }, "Video Info", -1)),
          createBaseVNode("div", _hoisted_3$J, [
            createBaseVNode("div", _hoisted_4$J, [
              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_5$J, toDisplayString(assetInfo.value.width) + "  " + toDisplayString(assetInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_6$J, [
              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_7$J, toDisplayString(formatDuration(assetInfo.value.duration)), 1)
            ]),
            createBaseVNode("div", _hoisted_8$H, [
              _cache[6] || (_cache[6] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_9$H, toDisplayString(assetInfo.value.fps?.toFixed(2) || "?") + " fps", 1)
            ]),
            createBaseVNode("div", _hoisted_10$G, [
              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "info-label" }, "Has Audio", -1)),
              createBaseVNode("span", _hoisted_11$F, toDisplayString(assetInfo.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_12$D, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-header" }, "Playback", -1)),
          createBaseVNode("div", _hoisted_13$D, [
            createBaseVNode("div", _hoisted_14$z, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.speed,
                "onUpdate:modelValue": updateSpeed,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$y, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Start Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.startTime,
                "onUpdate:modelValue": updateStartTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_16$x, [
              _cache[11] || (_cache[11] = createBaseVNode("label", null, "End Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.endTime || assetInfo.value?.duration || 0,
                "onUpdate:modelValue": updateEndTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_17$w, [
              createBaseVNode("label", _hoisted_18$u, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.loop,
                  onChange: updateLoop
                }, null, 40, _hoisted_19$t),
                _cache[12] || (_cache[12] = createBaseVNode("span", null, "Loop", -1))
              ]),
              createBaseVNode("label", _hoisted_20$t, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.pingPong,
                  onChange: updatePingPong
                }, null, 40, _hoisted_21$s),
                _cache[13] || (_cache[13] = createBaseVNode("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_22$q, [
          createBaseVNode("div", _hoisted_23$q, [
            _cache[15] || (_cache[15] = createBaseVNode("span", null, "Speed Map", -1)),
            createBaseVNode("label", _hoisted_24$k, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: speedMapEnabled.value,
                onChange: toggleSpeedMap
              }, null, 40, _hoisted_25$k)
            ])
          ]),
          speedMapEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_26$i, [
            createBaseVNode("div", _hoisted_27$i, [
              _cache[16] || (_cache[16] = createBaseVNode("label", null, "Map Time", -1)),
              createBaseVNode("div", _hoisted_28$h, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: speedMapValue.value,
                  "onUpdate:modelValue": updateSpeedMap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                speedMapProperty.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: speedMapProperty.value,
                  layerId: __props.layer.id,
                  propertyPath: "data.speedMap",
                  onKeyframeAdded: onKeyframeChange,
                  onKeyframeRemoved: onKeyframeChange,
                  onAnimationToggled
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[17] || (_cache[17] = createBaseVNode("p", { class: "hint" }, "Animate speed map to control video playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_29$h, [
          _cache[20] || (_cache[20] = createBaseVNode("div", { class: "section-header" }, "Frame Blending", -1)),
          createBaseVNode("div", _hoisted_30$g, [
            createBaseVNode("div", _hoisted_31$e, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Mode", -1)),
              createBaseVNode("select", {
                value: videoData.value.frameBlending,
                onChange: updateFrameBlending,
                class: "select-input"
              }, [..._cache[18] || (_cache[18] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "frame-mix" }, "Frame Mix", -1),
                createBaseVNode("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, _hoisted_32$e)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_33$e, [
          createBaseVNode("div", _hoisted_34$d, [
            _cache[21] || (_cache[21] = createBaseVNode("span", null, "Timewarp", -1)),
            createBaseVNode("label", _hoisted_35$c, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: timewarpEnabled.value,
                onChange: toggleTimewarp
              }, null, 40, _hoisted_36$b)
            ])
          ]),
          timewarpEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_37$b, [
            createBaseVNode("div", _hoisted_38$b, [
              _cache[22] || (_cache[22] = createBaseVNode("label", null, "Speed", -1)),
              createBaseVNode("div", _hoisted_39$b, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: timewarpSpeedValue.value,
                  "onUpdate:modelValue": updateTimewarpSpeed,
                  unit: "%",
                  min: 1,
                  max: 400,
                  precision: 1
                }, null, 8, ["modelValue"]),
                timewarpSpeedProperty.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: timewarpSpeedProperty.value,
                  layerId: __props.layer.id,
                  propertyPath: "data.timewarpSpeed",
                  onKeyframeAdded: onKeyframeChange,
                  onKeyframeRemoved: onKeyframeChange,
                  onAnimationToggled
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_40$a, [
              _cache[24] || (_cache[24] = createBaseVNode("label", null, "Method", -1)),
              createBaseVNode("select", {
                value: videoData.value.timewarpMethod || "frame-mix",
                onChange: updateTimewarpMethod,
                class: "select-input"
              }, [..._cache[23] || (_cache[23] = [
                createBaseVNode("option", { value: "whole-frames" }, "Whole Frames", -1),
                createBaseVNode("option", { value: "frame-mix" }, "Frame Mix", -1),
                createBaseVNode("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, _hoisted_41$8)
            ]),
            createBaseVNode("div", _hoisted_42$7, [
              createBaseVNode("button", {
                class: "preset-btn",
                onClick: _cache[0] || (_cache[0] = ($event) => applyTimewarpPreset("slow-fast")),
                title: "Start slow, end fast"
              }, "SlowFast"),
              createBaseVNode("button", {
                class: "preset-btn",
                onClick: _cache[1] || (_cache[1] = ($event) => applyTimewarpPreset("fast-slow")),
                title: "Start fast, end slow"
              }, "FastSlow"),
              createBaseVNode("button", {
                class: "preset-btn",
                onClick: _cache[2] || (_cache[2] = ($event) => applyTimewarpPreset("impact")),
                title: "Slow motion at impact point"
              }, "Impact"),
              createBaseVNode("button", {
                class: "preset-btn",
                onClick: _cache[3] || (_cache[3] = ($event) => applyTimewarpPreset("rewind")),
                title: "NormalReverseNormal"
              }, "Rewind")
            ]),
            _cache[25] || (_cache[25] = createBaseVNode("p", { class: "hint" }, "Keyframe Speed % for smooth speed ramps. Uses curve editor easing.", -1))
          ])) : createCommentVNode("", true)
        ]),
        assetInfo.value?.hasAudio !== false ? (openBlock(), createElementBlock("div", _hoisted_43$7, [
          _cache[30] || (_cache[30] = createBaseVNode("div", { class: "section-header" }, "Audio", -1)),
          createBaseVNode("div", _hoisted_44$7, [
            createBaseVNode("div", _hoisted_45$7, [
              createBaseVNode("label", _hoisted_46$7, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.audioEnabled,
                  onChange: updateAudioEnabled
                }, null, 40, _hoisted_47$7),
                _cache[26] || (_cache[26] = createBaseVNode("span", null, "Audio Enabled", -1))
              ])
            ]),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_48$7, [
              _cache[27] || (_cache[27] = createBaseVNode("label", null, "Level", -1)),
              createBaseVNode("div", _hoisted_49$7, [
                audioLevel.value ? (openBlock(), createBlock(unref(ScrubableNumber), {
                  key: 0,
                  modelValue: audioLevel.value.value,
                  "onUpdate:modelValue": updateLevel,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                audioLevel.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 1,
                  property: audioLevel.value,
                  layerId: __props.layer.id,
                  propertyPath: "audio.level",
                  onKeyframeAdded: onKeyframeChange,
                  onKeyframeRemoved: onKeyframeChange,
                  onAnimationToggled
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_50$6, [
              _cache[28] || (_cache[28] = createBaseVNode("label", null, "Volume", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.audioLevel,
                "onUpdate:modelValue": updateAudioLevel,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_51$6, [..._cache[29] || (_cache[29] = [
              createBaseVNode("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VideoProperties = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__scopeId", "data-v-b6db47b2"]]);

const DEFAULT_TRAJECTORY = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: false
};
const TRAJECTORY_PRESETS = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function applyEasing(t, easing) {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t;
    case "ease-out":
      return 1 - (1 - t) * (1 - t);
    case "ease-in-out":
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    case "bounce":
      if (t < 0.5) {
        return 8 * t * t * t * t;
      }
      const f = t - 1;
      return 1 - 8 * f * f * f * f;
    default:
      return t;
  }
}
function getTrajectoryPosition(config, t) {
  const easedT = applyEasing(t, config.easing);
  const { center, baseDistance, amplitude, loops, startPhase, type } = config;
  let position = { x: center.x, y: center.y, z: center.z - baseDistance };
  let target = { ...center };
  switch (type) {
    case "orbit":
    case "orbit_reverse": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI * Math.sign(amplitude);
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const maxAngle = Math.abs(amplitude) * Math.PI;
      const angle = Math.sin(easedT * Math.PI) * maxAngle;
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "dolly_in": {
      const distance = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "dolly_out": {
      const distance = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const panAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x + Math.sin(panAngle) * baseDistance,
        y: center.y,
        z: center.z + Math.cos(panAngle) * baseDistance - baseDistance
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const tiltAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x,
        y: center.y + Math.sin(tiltAngle) * baseDistance,
        z: center.z
      };
      break;
    }
    case "circle": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.cos(angle) * radius * 0.5,
        // Elliptical
        z: center.z - baseDistance + Math.cos(angle) * radius * 0.3
      };
      break;
    }
    case "figure8": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.sin(angle * 2) * radius * 0.3,
        z: center.z - baseDistance
      };
      break;
    }
    case "spiral_in": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "spiral_out": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      position = {
        x: center.x,
        y: center.y + easedT * amplitude,
        z: center.z - baseDistance
      };
      target = {
        x: center.x,
        y: center.y + easedT * amplitude * 0.5,
        // Target moves less
        z: center.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      position = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z - baseDistance
      };
      target = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const arcAngle = easedT * amplitude * 2 * Math.PI;
      position = {
        x: center.x + Math.sin(arcAngle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(arcAngle) * baseDistance
      };
      break;
    }
  }
  return { position, target };
}
function generateTrajectoryKeyframes(config, startFrame = 0, keyframeInterval = 5) {
  const positionKeyframes = [];
  const poiKeyframes = [];
  const zoomKeyframes = [];
  const numKeyframes = Math.ceil(config.duration / keyframeInterval) + 1;
  for (let i = 0; i < numKeyframes; i++) {
    const frame = startFrame + Math.min(i * keyframeInterval, config.duration);
    const t = Math.min(i * keyframeInterval, config.duration) / config.duration;
    const { position, target } = getTrajectoryPosition(config, t);
    positionKeyframes.push({
      frame,
      position,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    poiKeyframes.push({
      frame,
      pointOfInterest: target,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    if (config.type === "zoom_in" || config.type === "zoom_out") {
      const easedT = applyEasing(t, config.easing);
      const zoomMultiplier = config.type === "zoom_in" ? 1 + easedT * Math.abs(config.amplitude) : 1 - easedT * Math.abs(config.amplitude);
      zoomKeyframes.push({
        frame,
        zoom: 1778 * zoomMultiplier,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: positionKeyframes,
    pointOfInterest: poiKeyframes,
    zoom: zoomKeyframes.length > 0 ? zoomKeyframes : void 0
  };
}
function createTrajectoryFromPreset(preset, overrides) {
  return {
    ...DEFAULT_TRAJECTORY,
    ...TRAJECTORY_PRESETS[preset],
    type: preset,
    ...overrides
  };
}
function getTrajectoryDescription(type) {
  const descriptions = {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  };
  return descriptions[type] || "Unknown trajectory";
}
function getTrajectoryCategory(type) {
  const categories = {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  };
  return categories[type] || "Other";
}
function getTrajectoryTypesByCategory() {
  const types = Object.keys(TRAJECTORY_PRESETS);
  const grouped = {};
  for (const type of types) {
    const category = getTrajectoryCategory(type);
    if (!grouped[category]) {
      grouped[category] = [];
    }
    grouped[category].push(type);
  }
  return grouped;
}

const _hoisted_1$I = { class: "camera-properties" };
const _hoisted_2$I = { class: "prop-section" };
const _hoisted_3$I = { class: "expand-icon" };
const _hoisted_4$I = {
  key: 0,
  class: "section-content"
};
const _hoisted_5$I = { class: "property-row checkbox-row" };
const _hoisted_6$I = ["checked"];
const _hoisted_7$I = { class: "property-row" };
const _hoisted_8$G = { class: "property-row" };
const _hoisted_9$G = { class: "prop-section" };
const _hoisted_10$F = { class: "expand-icon" };
const _hoisted_11$E = ["checked"];
const _hoisted_12$C = {
  key: 0,
  class: "section-content"
};
const _hoisted_13$C = { class: "property-row" };
const _hoisted_14$y = { class: "property-row" };
const _hoisted_15$x = { class: "property-row" };
const _hoisted_16$w = { class: "prop-section" };
const _hoisted_17$v = { class: "expand-icon" };
const _hoisted_18$t = ["checked"];
const _hoisted_19$s = {
  key: 0,
  class: "section-content"
};
const _hoisted_20$s = { class: "property-row" };
const _hoisted_21$r = ["value"];
const _hoisted_22$p = ["value"];
const _hoisted_23$p = { class: "property-row" };
const _hoisted_24$j = { class: "property-row" };
const _hoisted_25$j = { class: "property-row" };
const _hoisted_26$h = { class: "property-row" };
const _hoisted_27$h = { class: "property-row checkbox-row" };
const _hoisted_28$g = ["checked"];
const _hoisted_29$g = { class: "property-row checkbox-row" };
const _hoisted_30$f = ["checked"];
const _hoisted_31$d = {
  key: 0,
  class: "property-row"
};
const _hoisted_32$d = { class: "prop-section" };
const _hoisted_33$d = { class: "expand-icon" };
const _hoisted_34$c = ["checked"];
const _hoisted_35$b = {
  key: 0,
  class: "section-content"
};
const _hoisted_36$a = { class: "property-row" };
const _hoisted_37$a = ["value"];
const _hoisted_38$a = { class: "property-row" };
const _hoisted_39$a = { class: "property-row" };
const _hoisted_40$9 = { class: "property-row" };
const _hoisted_41$7 = { class: "property-row" };
const _hoisted_42$6 = { class: "property-row" };
const _hoisted_43$6 = { class: "property-row checkbox-row" };
const _hoisted_44$6 = ["checked"];
const _hoisted_45$6 = { class: "prop-section" };
const _hoisted_46$6 = { class: "expand-icon" };
const _hoisted_47$6 = ["checked"];
const _hoisted_48$6 = {
  key: 0,
  class: "section-content"
};
const _hoisted_49$6 = { class: "property-row" };
const _hoisted_50$5 = { class: "property-row" };
const _hoisted_51$5 = { class: "property-row" };
const _hoisted_52$5 = { class: "property-row" };
const _hoisted_53$5 = { class: "property-row" };
const _hoisted_54$5 = ["value"];
const _hoisted_55$5 = { class: "property-row" };
const _hoisted_56$5 = { class: "property-row" };
const _hoisted_57$4 = { class: "prop-section" };
const _hoisted_58$4 = { class: "expand-icon" };
const _hoisted_59$4 = {
  key: 0,
  class: "section-content"
};
const _hoisted_60$3 = { class: "trajectory-grid" };
const _hoisted_61$3 = { class: "trajectory-group" };
const _hoisted_62$3 = { class: "trajectory-group" };
const _hoisted_63$1 = { class: "trajectory-group" };
const _hoisted_64$1 = { class: "trajectory-group" };
const _hoisted_65$1 = { class: "prop-section" };
const _hoisted_66$1 = { class: "expand-icon" };
const _hoisted_67$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_68$1 = { class: "property-row" };
const _hoisted_69$1 = { class: "property-row" };
const _hoisted_70$1 = { class: "property-row" };
const _hoisted_71$1 = { class: "property-row" };
const _hoisted_72$1 = { class: "property-row" };
const _hoisted_73$1 = { class: "property-row" };
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["settings", "dof"]);
    const cameraData = computed(() => {
      return props.layer.data || {
        cameraId: "",
        isActiveCamera: false
      };
    });
    const depthOfField = computed(() => {
      return cameraData.value.depthOfField || {
        enabled: false,
        focusDistance: 500,
        aperture: 2.8,
        blurLevel: 50
      };
    });
    const dofEnabled = computed(() => depthOfField.value.enabled);
    const pathFollowing = computed(() => {
      return cameraData.value.pathFollowing || {
        enabled: false,
        pathLayerId: "",
        parameter: { id: "", name: "Path Position", type: "number", value: 0, animated: false, keyframes: [], group: "Path Following" },
        lookAhead: 0.05,
        bankingStrength: 0,
        offsetY: 0,
        alignToPath: true,
        autoAdvance: false,
        autoAdvanceSpeed: 0.01
      };
    });
    const splineLayers = computed(() => {
      return store.layers.filter((l) => (l.type === "spline" || l.type === "path") && l.id !== props.layer.id);
    });
    const cameraShake = computed(() => {
      return cameraData.value.shake || {
        enabled: false,
        type: "handheld",
        intensity: 0.3,
        frequency: 1,
        rotationEnabled: true,
        rotationScale: 0.5,
        seed: Math.floor(Math.random() * 1e5),
        decay: 0,
        startFrame: 0,
        duration: 81
      };
    });
    const rackFocus = computed(() => {
      return cameraData.value.rackFocus || {
        enabled: false,
        startDistance: 500,
        endDistance: 2e3,
        duration: 30,
        startFrame: 0,
        easing: "ease-in-out",
        holdStart: 0,
        holdEnd: 0
      };
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...cameraData.value, [key]: value }
      });
      emit("update");
    }
    function toggleDOF(e) {
      const checked = e.target.checked;
      const newDOF = { ...depthOfField.value, enabled: checked };
      update("depthOfField", newDOF);
    }
    function togglePathFollowing(e) {
      const checked = e.target.checked;
      const newPath = { ...pathFollowing.value, enabled: checked };
      update("pathFollowing", newPath);
    }
    function updatePathLayer(e) {
      const layerId = e.target.value;
      const newPath = { ...pathFollowing.value, pathLayerId: layerId };
      update("pathFollowing", newPath);
    }
    function updatePathConfig(key, value) {
      const newPath = { ...pathFollowing.value, [key]: value };
      update("pathFollowing", newPath);
    }
    function toggleCameraShake(e) {
      const checked = e.target.checked;
      const newShake = { ...cameraShake.value, enabled: checked };
      update("shake", newShake);
    }
    function updateShakeConfig(key, value) {
      const newShake = { ...cameraShake.value, [key]: value };
      update("shake", newShake);
    }
    function toggleRackFocus(e) {
      const checked = e.target.checked;
      const newRackFocus = { ...rackFocus.value, enabled: checked };
      update("rackFocus", newRackFocus);
      if (checked) {
        const newDOF = { ...depthOfField.value, enabled: true };
        update("depthOfField", newDOF);
      }
    }
    function updateRackFocusConfig(key, value) {
      const newRackFocus = { ...rackFocus.value, [key]: value };
      update("rackFocus", newRackFocus);
    }
    function applyTrajectory(trajectoryType) {
      const comp = store.getActiveComp();
      const compSettings = comp?.settings || { width: 1920, height: 1080, frameCount: 81 };
      const trajectoryConfig = createTrajectoryFromPreset(trajectoryType, {
        duration: compSettings.frameCount,
        center: {
          x: compSettings.width / 2,
          y: compSettings.height / 2,
          z: 0
        }
      });
      const keyframes = generateTrajectoryKeyframes(trajectoryConfig, 0, 5);
      update("trajectoryKeyframes", {
        position: keyframes.position,
        pointOfInterest: keyframes.pointOfInterest,
        zoom: keyframes.zoom
      });
      emit("update");
    }
    function updatePathProperty(key, value) {
      const param = pathFollowing.value.parameter;
      const newParam = { ...param, value };
      const newPath = { ...pathFollowing.value, parameter: newParam };
      update("pathFollowing", newPath);
      const prop = getProperty("Path Position");
      if (prop) {
        prop.value = value;
      }
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      const animProp = cameraData.value[dataKey];
      if (animProp) {
        animProp.value = value;
        update(dataKey, animProp);
      }
      emit("update");
    }
    function updateDOFAnimatable(propName, value, dofKey) {
      const newDOF = { ...depthOfField.value, [dofKey]: value };
      update("depthOfField", newDOF);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      emit("update");
    }
    function ensureProperty(propName, defaultValue, group) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: defaultValue,
          animated: false,
          keyframes: [],
          group
        });
      }
    }
    function toggleKeyframe(propName, dataKey, defaultValue) {
      ensureProperty(propName, defaultValue, propName.includes("Focus") || propName.includes("Aperture") || propName.includes("Blur") ? "Depth of Field" : "Camera");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function togglePathKeyframe(propName) {
      ensureProperty(propName, pathFollowing.value.parameter?.value ?? 0, "Path Following");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function getVec3Value(propName, axis) {
      const dataKey = propName === "Position" ? "animatedPosition" : "animatedTarget";
      const animProp = cameraData.value[dataKey];
      if (animProp?.value) {
        return animProp.value[axis] ?? 0;
      }
      return 0;
    }
    function updateVec3Property(propName, axis, value, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const newValue = { ...animProp.value, [axis]: value };
      animProp.value = newValue;
      update(dataKey, animProp);
    }
    function toggleVec3Keyframe(propName, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const frame = store.currentFrame;
      const hasKeyframeAtFrame = animProp.keyframes.some((k) => k.frame === frame);
      if (hasKeyframeAtFrame) {
        animProp.keyframes = animProp.keyframes.filter((k) => k.frame !== frame);
        animProp.animated = animProp.keyframes.length > 0;
      } else {
        animProp.keyframes.push({
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          frame,
          value: { ...animProp.value },
          easing: "linear"
        });
        animProp.animated = true;
      }
      update(dataKey, animProp);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$I, [
        createBaseVNode("div", _hoisted_2$I, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("settings"))
          }, [
            createBaseVNode("span", _hoisted_3$I, toDisplayString(expandedSections.value.includes("settings") ? "" : ""), 1),
            _cache[74] || (_cache[74] = createBaseVNode("span", { class: "section-title" }, "Camera Settings", -1))
          ]),
          expandedSections.value.includes("settings") ? (openBlock(), createElementBlock("div", _hoisted_4$I, [
            createBaseVNode("div", _hoisted_5$I, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: cameraData.value.isActiveCamera,
                  onChange: _cache[1] || (_cache[1] = ($event) => update("isActiveCamera", $event.target.checked))
                }, null, 40, _hoisted_6$I),
                _cache[75] || (_cache[75] = createTextVNode(" Active Camera ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_7$I, [
              _cache[76] || (_cache[76] = createBaseVNode("label", null, "FOV", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("FOV") ?? 50,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("FOV", v, "animatedFov")),
                min: 10,
                max: 120,
                unit: ""
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("FOV") }]),
                onClick: _cache[3] || (_cache[3] = ($event) => toggleKeyframe("FOV", "animatedFov", 50))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_8$G, [
              _cache[77] || (_cache[77] = createBaseVNode("label", null, "Focal Length", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focal Length") ?? 50,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateAnimatable("Focal Length", v, "animatedFocalLength")),
                min: 10,
                max: 300,
                unit: "mm"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focal Length") }]),
                onClick: _cache[5] || (_cache[5] = ($event) => toggleKeyframe("Focal Length", "animatedFocalLength", 50))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_9$G, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("dof"))
          }, [
            createBaseVNode("span", _hoisted_10$F, toDisplayString(expandedSections.value.includes("dof") ? "" : ""), 1),
            _cache[78] || (_cache[78] = createBaseVNode("span", { class: "section-title" }, "Depth of Field", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: dofEnabled.value,
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleDOF,
              class: "section-toggle"
            }, null, 40, _hoisted_11$E)
          ]),
          expandedSections.value.includes("dof") && dofEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_12$C, [
            createBaseVNode("div", _hoisted_13$C, [
              _cache[79] || (_cache[79] = createBaseVNode("label", null, "Focus Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focus Distance") ?? depthOfField.value.focusDistance,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateDOFAnimatable("Focus Distance", v, "focusDistance")),
                min: 0,
                max: 1e4,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focus Distance") }]),
                onClick: _cache[9] || (_cache[9] = ($event) => toggleKeyframe("Focus Distance", "animatedFocusDistance", depthOfField.value.focusDistance))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_14$y, [
              _cache[80] || (_cache[80] = createBaseVNode("label", null, "Aperture", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Aperture") ?? depthOfField.value.aperture,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateDOFAnimatable("Aperture", v, "aperture")),
                min: 0.5,
                max: 32,
                step: 0.1,
                unit: "f/"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Aperture") }]),
                onClick: _cache[11] || (_cache[11] = ($event) => toggleKeyframe("Aperture", "animatedAperture", depthOfField.value.aperture))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_15$x, [
              _cache[81] || (_cache[81] = createBaseVNode("label", null, "Blur Level", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Blur Level") ?? depthOfField.value.blurLevel,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateDOFAnimatable("Blur Level", v, "blurLevel")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Blur Level") }]),
                onClick: _cache[13] || (_cache[13] = ($event) => toggleKeyframe("Blur Level", "animatedBlurLevel", depthOfField.value.blurLevel))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_16$w, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[15] || (_cache[15] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_17$v, toDisplayString(expandedSections.value.includes("path") ? "" : ""), 1),
            _cache[82] || (_cache[82] = createBaseVNode("span", { class: "section-title" }, "Path Following", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: pathFollowing.value.enabled,
              onClick: _cache[14] || (_cache[14] = withModifiers(() => {
              }, ["stop"])),
              onChange: togglePathFollowing,
              class: "section-toggle"
            }, null, 40, _hoisted_18$t)
          ]),
          expandedSections.value.includes("path") && pathFollowing.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_19$s, [
            createBaseVNode("div", _hoisted_20$s, [
              _cache[84] || (_cache[84] = createBaseVNode("label", null, "Path Layer", -1)),
              createBaseVNode("select", {
                class: "path-select",
                value: pathFollowing.value.pathLayerId,
                onChange: updatePathLayer
              }, [
                _cache[83] || (_cache[83] = createBaseVNode("option", { value: "" }, "Select Path...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.type === "path" ? " " : " ") + toDisplayString(layer.name), 9, _hoisted_22$p);
                }), 128))
              ], 40, _hoisted_21$r)
            ]),
            createBaseVNode("div", _hoisted_23$p, [
              _cache[85] || (_cache[85] = createBaseVNode("label", null, "Position", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Position") ?? pathFollowing.value.parameter?.value ?? 0,
                "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updatePathProperty("parameter", v)),
                min: 0,
                max: 1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Path Position") }]),
                onClick: _cache[17] || (_cache[17] = ($event) => togglePathKeyframe("Path Position"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_24$j, [
              _cache[86] || (_cache[86] = createBaseVNode("label", null, "Look Ahead", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.lookAhead ?? 0.05,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updatePathConfig("lookAhead", v)),
                min: 0,
                max: 0.5,
                step: 0.01,
                precision: 2
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$j, [
              _cache[87] || (_cache[87] = createBaseVNode("label", null, "Banking", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.bankingStrength ?? 0,
                "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updatePathConfig("bankingStrength", v)),
                min: 0,
                max: 1,
                step: 0.05
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_26$h, [
              _cache[88] || (_cache[88] = createBaseVNode("label", null, "Height Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.offsetY ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updatePathConfig("offsetY", v)),
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_27$h, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.alignToPath,
                  onChange: _cache[21] || (_cache[21] = ($event) => updatePathConfig("alignToPath", $event.target.checked))
                }, null, 40, _hoisted_28$g),
                _cache[89] || (_cache[89] = createTextVNode(" Align to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$g, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.autoAdvance,
                  onChange: _cache[22] || (_cache[22] = ($event) => updatePathConfig("autoAdvance", $event.target.checked))
                }, null, 40, _hoisted_30$f),
                _cache[90] || (_cache[90] = createTextVNode(" Auto Advance ", -1))
              ])
            ]),
            pathFollowing.value.autoAdvance ? (openBlock(), createElementBlock("div", _hoisted_31$d, [
              _cache[91] || (_cache[91] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.autoAdvanceSpeed ?? 0.01,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updatePathConfig("autoAdvanceSpeed", v)),
                min: 1e-3,
                max: 0.1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$d, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[25] || (_cache[25] = ($event) => toggleSection("shake"))
          }, [
            createBaseVNode("span", _hoisted_33$d, toDisplayString(expandedSections.value.includes("shake") ? "" : ""), 1),
            _cache[92] || (_cache[92] = createBaseVNode("span", { class: "section-title" }, "Camera Shake", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: cameraShake.value.enabled,
              onClick: _cache[24] || (_cache[24] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleCameraShake,
              class: "section-toggle"
            }, null, 40, _hoisted_34$c)
          ]),
          expandedSections.value.includes("shake") && cameraShake.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_35$b, [
            createBaseVNode("div", _hoisted_36$a, [
              _cache[94] || (_cache[94] = createBaseVNode("label", null, "Type", -1)),
              createBaseVNode("select", {
                class: "path-select",
                value: cameraShake.value.type,
                onChange: _cache[26] || (_cache[26] = ($event) => updateShakeConfig("type", $event.target.value))
              }, [..._cache[93] || (_cache[93] = [
                createBaseVNode("option", { value: "handheld" }, "Handheld", -1),
                createBaseVNode("option", { value: "impact" }, "Impact", -1),
                createBaseVNode("option", { value: "earthquake" }, "Earthquake", -1),
                createBaseVNode("option", { value: "subtle" }, "Subtle", -1)
              ])], 40, _hoisted_37$a)
            ]),
            createBaseVNode("div", _hoisted_38$a, [
              _cache[95] || (_cache[95] = createBaseVNode("label", null, "Intensity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: cameraShake.value.intensity,
                "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateShakeConfig("intensity", v)),
                min: 0,
                max: 1,
                step: 0.05,
                precision: 2
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_39$a, [
              _cache[96] || (_cache[96] = createBaseVNode("label", null, "Frequency", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: cameraShake.value.frequency,
                "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateShakeConfig("frequency", v)),
                min: 0.1,
                max: 5,
                step: 0.1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_40$9, [
              _cache[97] || (_cache[97] = createBaseVNode("label", null, "Decay", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: cameraShake.value.decay,
                "onUpdate:modelValue": _cache[29] || (_cache[29] = (v) => updateShakeConfig("decay", v)),
                min: 0,
                max: 1,
                step: 0.05,
                precision: 2
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_41$7, [
              _cache[98] || (_cache[98] = createBaseVNode("label", null, "Start Frame", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: cameraShake.value.startFrame,
                "onUpdate:modelValue": _cache[30] || (_cache[30] = (v) => updateShakeConfig("startFrame", v)),
                min: 0,
                step: 1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_42$6, [
              _cache[99] || (_cache[99] = createBaseVNode("label", null, "Duration", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: cameraShake.value.duration,
                "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateShakeConfig("duration", v)),
                min: 1,
                step: 1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_43$6, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: cameraShake.value.rotationEnabled,
                  onChange: _cache[32] || (_cache[32] = ($event) => updateShakeConfig("rotationEnabled", $event.target.checked))
                }, null, 40, _hoisted_44$6),
                _cache[100] || (_cache[100] = createTextVNode(" Include Rotation ", -1))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_45$6, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[34] || (_cache[34] = ($event) => toggleSection("rackFocus"))
          }, [
            createBaseVNode("span", _hoisted_46$6, toDisplayString(expandedSections.value.includes("rackFocus") ? "" : ""), 1),
            _cache[101] || (_cache[101] = createBaseVNode("span", { class: "section-title" }, "Rack Focus", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: rackFocus.value.enabled,
              onClick: _cache[33] || (_cache[33] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleRackFocus,
              class: "section-toggle"
            }, null, 40, _hoisted_47$6)
          ]),
          expandedSections.value.includes("rackFocus") && rackFocus.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_48$6, [
            createBaseVNode("div", _hoisted_49$6, [
              _cache[102] || (_cache[102] = createBaseVNode("label", null, "Start Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.startDistance,
                "onUpdate:modelValue": _cache[35] || (_cache[35] = (v) => updateRackFocusConfig("startDistance", v)),
                min: 0,
                max: 1e4,
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_50$5, [
              _cache[103] || (_cache[103] = createBaseVNode("label", null, "End Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.endDistance,
                "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateRackFocusConfig("endDistance", v)),
                min: 0,
                max: 1e4,
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_51$5, [
              _cache[104] || (_cache[104] = createBaseVNode("label", null, "Start Frame", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.startFrame,
                "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateRackFocusConfig("startFrame", v)),
                min: 0,
                step: 1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_52$5, [
              _cache[105] || (_cache[105] = createBaseVNode("label", null, "Duration", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.duration,
                "onUpdate:modelValue": _cache[38] || (_cache[38] = (v) => updateRackFocusConfig("duration", v)),
                min: 1,
                step: 1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_53$5, [
              _cache[107] || (_cache[107] = createBaseVNode("label", null, "Easing", -1)),
              createBaseVNode("select", {
                class: "path-select",
                value: rackFocus.value.easing,
                onChange: _cache[39] || (_cache[39] = ($event) => updateRackFocusConfig("easing", $event.target.value))
              }, [..._cache[106] || (_cache[106] = [
                createStaticVNode('<option value="linear" data-v-58f65401>Linear</option><option value="ease-in" data-v-58f65401>Ease In</option><option value="ease-out" data-v-58f65401>Ease Out</option><option value="ease-in-out" data-v-58f65401>Ease In/Out</option><option value="snap" data-v-58f65401>Snap</option>', 5)
              ])], 40, _hoisted_54$5)
            ]),
            createBaseVNode("div", _hoisted_55$5, [
              _cache[108] || (_cache[108] = createBaseVNode("label", null, "Hold Start", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.holdStart,
                "onUpdate:modelValue": _cache[40] || (_cache[40] = (v) => updateRackFocusConfig("holdStart", v)),
                min: 0,
                step: 1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_56$5, [
              _cache[109] || (_cache[109] = createBaseVNode("label", null, "Hold End", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: rackFocus.value.holdEnd,
                "onUpdate:modelValue": _cache[41] || (_cache[41] = (v) => updateRackFocusConfig("holdEnd", v)),
                min: 0,
                step: 1
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_57$4, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[42] || (_cache[42] = ($event) => toggleSection("trajectory"))
          }, [
            createBaseVNode("span", _hoisted_58$4, toDisplayString(expandedSections.value.includes("trajectory") ? "" : ""), 1),
            _cache[110] || (_cache[110] = createBaseVNode("span", { class: "section-title" }, "Trajectory Presets", -1))
          ]),
          expandedSections.value.includes("trajectory") ? (openBlock(), createElementBlock("div", _hoisted_59$4, [
            createBaseVNode("div", _hoisted_60$3, [
              createBaseVNode("div", _hoisted_61$3, [
                _cache[111] || (_cache[111] = createBaseVNode("div", { class: "trajectory-group-title" }, "Orbital", -1)),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[43] || (_cache[43] = ($event) => applyTrajectory("orbit"))
                }, "Orbit"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[44] || (_cache[44] = ($event) => applyTrajectory("orbit_reverse"))
                }, "Orbit Rev"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[45] || (_cache[45] = ($event) => applyTrajectory("swing1"))
                }, "Swing 1"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[46] || (_cache[46] = ($event) => applyTrajectory("swing2"))
                }, "Swing 2"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[47] || (_cache[47] = ($event) => applyTrajectory("circle"))
                }, "Circle"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[48] || (_cache[48] = ($event) => applyTrajectory("figure8"))
                }, "Figure 8")
              ]),
              createBaseVNode("div", _hoisted_62$3, [
                _cache[112] || (_cache[112] = createBaseVNode("div", { class: "trajectory-group-title" }, "Dolly/Zoom", -1)),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[49] || (_cache[49] = ($event) => applyTrajectory("dolly_in"))
                }, "Dolly In"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[50] || (_cache[50] = ($event) => applyTrajectory("dolly_out"))
                }, "Dolly Out"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[51] || (_cache[51] = ($event) => applyTrajectory("spiral_in"))
                }, "Spiral In"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[52] || (_cache[52] = ($event) => applyTrajectory("spiral_out"))
                }, "Spiral Out"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[53] || (_cache[53] = ($event) => applyTrajectory("zoom_in"))
                }, "Zoom In"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[54] || (_cache[54] = ($event) => applyTrajectory("zoom_out"))
                }, "Zoom Out")
              ]),
              createBaseVNode("div", _hoisted_63$1, [
                _cache[113] || (_cache[113] = createBaseVNode("div", { class: "trajectory-group-title" }, "Pan/Tilt", -1)),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[55] || (_cache[55] = ($event) => applyTrajectory("pan_left"))
                }, "Pan Left"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[56] || (_cache[56] = ($event) => applyTrajectory("pan_right"))
                }, "Pan Right"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[57] || (_cache[57] = ($event) => applyTrajectory("tilt_up"))
                }, "Tilt Up"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[58] || (_cache[58] = ($event) => applyTrajectory("tilt_down"))
                }, "Tilt Down")
              ]),
              createBaseVNode("div", _hoisted_64$1, [
                _cache[114] || (_cache[114] = createBaseVNode("div", { class: "trajectory-group-title" }, "Crane/Truck", -1)),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[59] || (_cache[59] = ($event) => applyTrajectory("crane_up"))
                }, "Crane Up"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[60] || (_cache[60] = ($event) => applyTrajectory("crane_down"))
                }, "Crane Down"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[61] || (_cache[61] = ($event) => applyTrajectory("truck_left"))
                }, "Truck Left"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[62] || (_cache[62] = ($event) => applyTrajectory("truck_right"))
                }, "Truck Right"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[63] || (_cache[63] = ($event) => applyTrajectory("arc_left"))
                }, "Arc Left"),
                createBaseVNode("button", {
                  class: "trajectory-btn",
                  onClick: _cache[64] || (_cache[64] = ($event) => applyTrajectory("arc_right"))
                }, "Arc Right")
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_65$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[65] || (_cache[65] = ($event) => toggleSection("position"))
          }, [
            createBaseVNode("span", _hoisted_66$1, toDisplayString(expandedSections.value.includes("position") ? "" : ""), 1),
            _cache[115] || (_cache[115] = createBaseVNode("span", { class: "section-title" }, "Position & Target", -1))
          ]),
          expandedSections.value.includes("position") ? (openBlock(), createElementBlock("div", _hoisted_67$1, [
            createBaseVNode("div", _hoisted_68$1, [
              _cache[116] || (_cache[116] = createBaseVNode("label", null, "Position X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "x"),
                "onUpdate:modelValue": _cache[66] || (_cache[66] = (v) => updateVec3Property("Position", "x", v, "animatedPosition"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Position") }]),
                onClick: _cache[67] || (_cache[67] = ($event) => toggleVec3Keyframe("Position", "animatedPosition"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_69$1, [
              _cache[117] || (_cache[117] = createBaseVNode("label", null, "Position Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "y"),
                "onUpdate:modelValue": _cache[68] || (_cache[68] = (v) => updateVec3Property("Position", "y", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_70$1, [
              _cache[118] || (_cache[118] = createBaseVNode("label", null, "Position Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "z"),
                "onUpdate:modelValue": _cache[69] || (_cache[69] = (v) => updateVec3Property("Position", "z", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            _cache[122] || (_cache[122] = createBaseVNode("div", { class: "property-row separator" }, [
              createBaseVNode("span", { class: "separator-line" })
            ], -1)),
            createBaseVNode("div", _hoisted_71$1, [
              _cache[119] || (_cache[119] = createBaseVNode("label", null, "Target X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "x"),
                "onUpdate:modelValue": _cache[70] || (_cache[70] = (v) => updateVec3Property("Target", "x", v, "animatedTarget"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Target") }]),
                onClick: _cache[71] || (_cache[71] = ($event) => toggleVec3Keyframe("Target", "animatedTarget"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_72$1, [
              _cache[120] || (_cache[120] = createBaseVNode("label", null, "Target Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "y"),
                "onUpdate:modelValue": _cache[72] || (_cache[72] = (v) => updateVec3Property("Target", "y", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_73$1, [
              _cache[121] || (_cache[121] = createBaseVNode("label", null, "Target Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "z"),
                "onUpdate:modelValue": _cache[73] || (_cache[73] = (v) => updateVec3Property("Target", "z", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const CameraProperties$1 = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-58f65401"]]);

const _hoisted_1$H = { class: "nested-comp-properties" };
const _hoisted_2$H = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$H = { class: "section-content info-grid" };
const _hoisted_4$H = { class: "info-row" };
const _hoisted_5$H = { class: "info-value" };
const _hoisted_6$H = { class: "info-row" };
const _hoisted_7$H = { class: "info-value" };
const _hoisted_8$F = { class: "info-row" };
const _hoisted_9$F = { class: "info-value" };
const _hoisted_10$E = { class: "info-row" };
const _hoisted_11$D = { class: "info-value" };
const _hoisted_12$B = { class: "property-section" };
const _hoisted_13$B = { class: "section-header" };
const _hoisted_14$x = { class: "header-toggle" };
const _hoisted_15$w = ["checked"];
const _hoisted_16$v = {
  key: 0,
  class: "section-content"
};
const _hoisted_17$u = { class: "property-row" };
const _hoisted_18$s = { class: "control-with-keyframe" };
const _hoisted_19$r = { class: "property-section" };
const _hoisted_20$r = { class: "section-header" };
const _hoisted_21$q = { class: "header-toggle" };
const _hoisted_22$o = ["checked"];
const _hoisted_23$o = {
  key: 0,
  class: "section-content"
};
const _hoisted_24$i = { class: "property-row" };
const _hoisted_25$i = { class: "property-section" };
const _hoisted_26$g = { class: "section-content" };
const _hoisted_27$g = { class: "checkbox-group" };
const _hoisted_28$f = { class: "checkbox-row" };
const _hoisted_29$f = ["checked"];
const _hoisted_30$e = {
  key: 0,
  class: "hint"
};
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "NestedCompProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const nestedCompData = computed(() => {
      const data = props.layer.data;
      return {
        compositionId: data?.compositionId ?? "",
        // New naming with backwards compatibility
        speedMapEnabled: data?.speedMapEnabled ?? data?.timeRemapEnabled ?? false,
        speedMap: data?.speedMap ?? data?.timeRemap,
        // Legacy (deprecated)
        timeRemapEnabled: data?.timeRemapEnabled ?? false,
        timeRemap: data?.timeRemap,
        flattenTransform: data?.flattenTransform ?? false,
        overrideFrameRate: data?.overrideFrameRate ?? false,
        frameRate: data?.frameRate
      };
    });
    const compInfo = computed(() => {
      if (!nestedCompData.value.compositionId) return null;
      const comp = store.project.compositions[nestedCompData.value.compositionId];
      if (!comp) return null;
      return {
        name: comp.name,
        width: comp.settings.width,
        height: comp.settings.height,
        frameCount: comp.settings.frameCount,
        fps: comp.settings.fps,
        duration: comp.settings.duration
      };
    });
    const speedMapEnabled = computed(() => {
      return nestedCompData.value.speedMapEnabled ?? nestedCompData.value.timeRemapEnabled ?? false;
    });
    const speedMapProperty = computed(() => {
      return nestedCompData.value.speedMap ?? nestedCompData.value.timeRemap;
    });
    const speedMapValue = computed(() => {
      const prop = speedMapProperty.value;
      if (!prop) return 0;
      return prop.value;
    });
    function formatDuration(seconds) {
      if (seconds === void 0) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(2);
      return `${mins}:${secs.padStart(5, "0")}`;
    }
    function enterNestedComp() {
      if (nestedCompData.value.compositionId) {
        store.enterNestedComp(nestedCompData.value.compositionId);
      }
    }
    function toggleSpeedMap(e) {
      const enabled = e.target.checked;
      const updates = {
        speedMapEnabled: enabled,
        timeRemapEnabled: enabled
        // Backwards compatibility
      };
      if (enabled && !nestedCompData.value.speedMap) {
        const newProp = createAnimatableProperty("Speed Map", 0, "number");
        updates.speedMap = newProp;
        updates.timeRemap = newProp;
      }
      store.updateLayerData(props.layer.id, updates);
      emit("update", updates);
    }
    function updateSpeedMap(value) {
      const prop = speedMapProperty.value;
      if (prop) {
        const speedMap = {
          ...prop,
          value
        };
        store.updateLayerData(props.layer.id, {
          speedMap,
          timeRemap: speedMap
          // Backwards compatibility
        });
        emit("update", { speedMap });
      }
    }
    function toggleFrameRateOverride(e) {
      const enabled = e.target.checked;
      const updates = {
        overrideFrameRate: enabled,
        frameRate: enabled ? compInfo.value?.fps || 30 : void 0
      };
      store.updateLayerData(props.layer.id, updates);
      emit("update", updates);
    }
    function updateFrameRate(value) {
      store.updateLayerData(props.layer.id, { frameRate: value });
      emit("update", { frameRate: value });
    }
    function updateFlattenTransform(e) {
      const enabled = e.target.checked;
      store.updateLayerData(props.layer.id, { flattenTransform: enabled });
      store.updateLayer(props.layer.id, { flattenTransform: enabled });
      emit("update", { flattenTransform: enabled });
    }
    function onKeyframeChange() {
      emit("update", {});
    }
    function onAnimationToggled(animated) {
      console.log("[NestedCompProperties] Animation toggled:", animated);
      emit("update", {});
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$H, [
        compInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$H, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "section-header" }, "Composition Info", -1)),
          createBaseVNode("div", _hoisted_3$H, [
            createBaseVNode("div", _hoisted_4$H, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "info-label" }, "Name", -1)),
              createBaseVNode("span", _hoisted_5$H, toDisplayString(compInfo.value.name), 1)
            ]),
            createBaseVNode("div", _hoisted_6$H, [
              _cache[1] || (_cache[1] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_7$H, toDisplayString(compInfo.value.width) + " x " + toDisplayString(compInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_8$F, [
              _cache[2] || (_cache[2] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_9$F, toDisplayString(compInfo.value.frameCount) + " frames (" + toDisplayString(formatDuration(compInfo.value.duration)) + ")", 1)
            ]),
            createBaseVNode("div", _hoisted_10$E, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_11$D, toDisplayString(compInfo.value.fps) + " fps", 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", { class: "property-section" }, [
          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, "Actions", -1)),
          createBaseVNode("div", { class: "section-content" }, [
            createBaseVNode("button", {
              class: "action-btn",
              onClick: enterNestedComp
            }, " Enter Composition ")
          ])
        ]),
        createBaseVNode("div", _hoisted_12$B, [
          createBaseVNode("div", _hoisted_13$B, [
            _cache[6] || (_cache[6] = createBaseVNode("span", null, "Speed Map", -1)),
            createBaseVNode("label", _hoisted_14$x, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: speedMapEnabled.value,
                onChange: toggleSpeedMap
              }, null, 40, _hoisted_15$w)
            ])
          ]),
          speedMapEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_16$v, [
            createBaseVNode("div", _hoisted_17$u, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "Map Time", -1)),
              createBaseVNode("div", _hoisted_18$s, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: speedMapValue.value,
                  "onUpdate:modelValue": updateSpeedMap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                speedMapProperty.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: speedMapProperty.value,
                  layerId: __props.layer.id,
                  propertyPath: "data.speedMap",
                  onKeyframeAdded: onKeyframeChange,
                  onKeyframeRemoved: onKeyframeChange,
                  onAnimationToggled
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[8] || (_cache[8] = createBaseVNode("p", { class: "hint" }, "Animate to control nested comp playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_19$r, [
          createBaseVNode("div", _hoisted_20$r, [
            _cache[9] || (_cache[9] = createBaseVNode("span", null, "Frame Rate Override", -1)),
            createBaseVNode("label", _hoisted_21$q, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: nestedCompData.value.overrideFrameRate,
                onChange: toggleFrameRateOverride
              }, null, 40, _hoisted_22$o)
            ])
          ]),
          nestedCompData.value.overrideFrameRate ? (openBlock(), createElementBlock("div", _hoisted_23$o, [
            createBaseVNode("div", _hoisted_24$i, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Frame Rate", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: nestedCompData.value.frameRate || compInfo.value?.fps || 30,
                "onUpdate:modelValue": updateFrameRate,
                min: 1,
                max: 120,
                step: 1,
                precision: 0,
                unit: "fps"
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_25$i, [
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "section-header" }, "Options", -1)),
          createBaseVNode("div", _hoisted_26$g, [
            createBaseVNode("div", _hoisted_27$g, [
              createBaseVNode("label", _hoisted_28$f, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: nestedCompData.value.flattenTransform,
                  onChange: updateFlattenTransform
                }, null, 40, _hoisted_29$f),
                _cache[11] || (_cache[11] = createBaseVNode("span", null, "Flatten Transform", -1))
              ])
            ]),
            nestedCompData.value.flattenTransform ? (openBlock(), createElementBlock("p", _hoisted_30$e, " 3D layers render in parent's 3D space. Effects are rasterized. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const NestedCompProperties = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-f1347182"]]);

function createDefaultCapProfile(type = "fillet") {
  return {
    type,
    radius: 2,
    segments: 8,
    depth: 2,
    tension: 0.5
  };
}
function generateCapProfileCurve(config) {
  const points = [];
  const { type, radius, segments, depth, customProfile } = config;
  switch (type) {
    case "flat":
      points.push(new Vector2(0, 0));
      points.push(new Vector2(0, depth));
      break;
    case "fillet":
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const angle = Math.PI / 2 * t;
        const x = radius * (1 - Math.cos(angle));
        const y = depth * Math.sin(angle);
        points.push(new Vector2(x, y));
      }
      break;
    case "convex":
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const bulge = Math.sin(Math.PI * t) * radius * 0.5;
        const x = -bulge;
        const y = depth * t;
        points.push(new Vector2(x, y));
      }
      break;
    case "concave":
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const scoop = Math.sin(Math.PI * t) * radius;
        const x = scoop;
        const y = depth * t;
        points.push(new Vector2(x, y));
      }
      break;
    case "steps":
      const stepCount = Math.max(2, Math.floor(segments / 2));
      const stepHeight = depth / stepCount;
      const stepWidth = radius / stepCount;
      for (let i = 0; i <= stepCount; i++) {
        points.push(new Vector2(i * stepWidth, i * stepHeight));
        if (i < stepCount) {
          points.push(new Vector2(i * stepWidth, (i + 1) * stepHeight));
        }
      }
      break;
    case "custom":
      if (customProfile && customProfile.length >= 2) {
        for (const pt of customProfile) {
          points.push(new Vector2(pt.x * radius, pt.y * depth));
        }
      } else {
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const angle = Math.PI / 2 * t;
          const x = radius * (1 - Math.cos(angle));
          const y = depth * Math.sin(angle);
          points.push(new Vector2(x, y));
        }
      }
      break;
  }
  return points;
}
class SVGExtrusionService {
  svgLoader;
  documentCache = /* @__PURE__ */ new Map();
  meshCache = /* @__PURE__ */ new Map();
  constructor() {
    this.svgLoader = new SVGLoader();
  }
  // ==========================================================================
  // SVG LOADING AND PARSING
  // ==========================================================================
  /**
   * Load and parse an SVG file from URL
   * @throws Error if URL is invalid or blocked for security reasons
   */
  async loadFromURL(url, name) {
    const validatedUrl = validateURL(url, "SVG loading", {
      allowData: true,
      allowBlob: true,
      allowHttp: true
      // Allow HTTP for local development
    });
    return new Promise((resolve, reject) => {
      this.svgLoader.load(
        validatedUrl,
        (data) => {
          const doc = this.parseSVGResult(data, name || url);
          this.documentCache.set(doc.id, doc);
          resolve(doc);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load and parse SVG from string content
   */
  loadFromString(svgString, name = "svg") {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
    const svgElement = svgDoc.querySelector("svg");
    if (!svgElement) {
      throw new Error("Invalid SVG: No SVG element found");
    }
    const data = this.svgLoader.parse(svgString);
    const doc = this.parseSVGResult(data, name);
    this.documentCache.set(doc.id, doc);
    return doc;
  }
  /**
   * Parse SVGLoader result into our format
   */
  parseSVGResult(data, name) {
    const id = `svg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const paths = [];
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    data.paths.forEach((shapePath, index) => {
      const shapes = SVGLoader.createShapes(shapePath);
      if (shapes.length === 0) return;
      const fillColor = shapePath.userData?.style?.fill;
      const color = new Color(
        fillColor && fillColor !== "none" ? fillColor : "#ffffff"
      );
      const fillOpacity = shapePath.userData?.style?.fillOpacity ?? 1;
      const strokeColor = shapePath.userData?.style?.stroke;
      const strokeWidth = shapePath.userData?.style?.strokeWidth ?? 0;
      const pathBounds = this.calculatePathBounds(shapes);
      minX = Math.min(minX, pathBounds.minX);
      minY = Math.min(minY, pathBounds.minY);
      maxX = Math.max(maxX, pathBounds.maxX);
      maxY = Math.max(maxY, pathBounds.maxY);
      paths.push({
        id: `${id}_path_${index}`,
        name: `Path ${index + 1}`,
        path: shapePath,
        shapes,
        color,
        fillOpacity,
        strokeColor: strokeColor && strokeColor !== "none" ? new Color(strokeColor) : null,
        strokeWidth,
        bounds: pathBounds,
        originalTransform: new Matrix4()
      });
    });
    const viewBox = {
      x: 0,
      y: 0,
      width: maxX - minX,
      height: maxY - minY
    };
    return {
      id,
      name,
      paths,
      viewBox,
      bounds: {
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  }
  /**
   * Calculate bounds for a set of shapes
   */
  calculatePathBounds(shapes) {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    for (const shape of shapes) {
      const points = shape.getPoints(50);
      for (const point of points) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
      for (const hole of shape.holes) {
        const holePoints = hole.getPoints(50);
        for (const point of holePoints) {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }
      }
    }
    const width = maxX - minX;
    const height = maxY - minY;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width,
      height,
      centerX: minX + width / 2,
      centerY: minY + height / 2
    };
  }
  // ==========================================================================
  // EXTRUSION
  // ==========================================================================
  /**
   * Create extruded geometry from an SVG path
   * Supports Cinema 4D/Blender style fillet caps for rounded edges
   */
  createExtrudedGeometry(path, config = {}) {
    const cacheKey = `${path.id}_${JSON.stringify(config)}`;
    const cached = this.meshCache.get(cacheKey);
    if (cached) return cached.clone();
    const useFrontCap = config.frontCapEnabled && config.frontCap;
    const useBackCap = config.backCapEnabled && config.backCap;
    const useFilletCaps = useFrontCap || useBackCap;
    let extrudeSettings = {
      depth: config.depth ?? 10,
      bevelEnabled: config.bevelEnabled ?? false,
      bevelThickness: config.bevelThickness ?? 1,
      bevelSize: config.bevelSize ?? 0.5,
      bevelOffset: config.bevelOffset ?? 0,
      bevelSegments: config.bevelSegments ?? 3,
      curveSegments: config.curveSegments ?? 12,
      steps: config.steps ?? 1
    };
    if (useFilletCaps && !config.bevelEnabled) {
      const frontCap = useFrontCap ? config.frontCap : createDefaultCapProfile("flat");
      if (useFrontCap && frontCap.type !== "flat") {
        extrudeSettings.bevelEnabled = true;
        extrudeSettings.bevelSize = frontCap.radius;
        extrudeSettings.bevelThickness = frontCap.depth;
        extrudeSettings.bevelSegments = frontCap.segments;
        extrudeSettings.bevelOffset = 0;
      }
    }
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ExtrudeGeometry(shape, extrudeSettings);
      geometries.push(geometry);
      if (useBackCap && config.backCap && config.backCap.type !== "flat") {
        const backCapGeom = this.createFilletCapGeometry(
          shape,
          config.backCap,
          config.depth ?? 10,
          "back"
        );
        if (backCapGeom) {
          geometries.push(backCapGeom);
        }
      }
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    finalGeometry.computeVertexNormals();
    this.meshCache.set(cacheKey, finalGeometry);
    return finalGeometry.clone();
  }
  /**
   * Create fillet cap geometry for front or back face
   * Uses LatheGeometry approach for rounded profile
   */
  createFilletCapGeometry(shape, capConfig, extrusionDepth, face) {
    if (capConfig.type === "flat") return null;
    const profilePoints = generateCapProfileCurve(capConfig);
    if (profilePoints.length < 2) return null;
    const capGeometries = [];
    const segments = capConfig.segments;
    for (let i = 0; i < segments; i++) {
      const profile = profilePoints[Math.min(i, profilePoints.length - 1)];
      const inset = profile.x;
      const zOffset = profile.y;
      if (inset > 0) {
        const scaleFactor = 1 - inset / 100;
        const layerShape = new ShapeGeometry(shape);
        const layerZ = face === "front" ? zOffset : extrusionDepth - zOffset;
        layerShape.scale(scaleFactor, scaleFactor, 1);
        layerShape.translate(0, 0, layerZ);
        capGeometries.push(layerShape);
      }
    }
    if (capGeometries.length === 0) return null;
    return this.mergeGeometries(capGeometries);
  }
  /**
   * Create extruded geometry with custom profile path
   * For advanced fillet caps, uses extrudePath option
   */
  createProfileExtrudedGeometry(path, profileCurve, config = {}) {
    const cacheKey = `${path.id}_profile_${JSON.stringify(config)}`;
    const cached = this.meshCache.get(cacheKey);
    if (cached) return cached.clone();
    const extrudeSettings = {
      steps: config.steps ?? 10,
      bevelEnabled: false,
      // Profile handles the shape
      curveSegments: config.curveSegments ?? 12,
      extrudePath: profileCurve
      // Use custom profile path
    };
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ExtrudeGeometry(shape, extrudeSettings);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    finalGeometry.computeVertexNormals();
    this.meshCache.set(cacheKey, finalGeometry);
    return finalGeometry.clone();
  }
  /**
   * Create a 3D profile path from cap configuration
   * Returns a THREE.Curve that can be used with extrudePath
   */
  createProfilePathFromCap(capConfig, extrusionDepth) {
    const profile2D = generateCapProfileCurve(capConfig);
    const points3D = profile2D.map(
      (p) => new Vector3(0, 0, p.y)
      // Use Y as depth (Z in 3D)
    );
    const mainDepthStart = capConfig.depth;
    const mainDepthEnd = extrusionDepth - capConfig.depth;
    points3D.push(new Vector3(0, 0, mainDepthStart));
    points3D.push(new Vector3(0, 0, mainDepthEnd));
    const backProfile = profile2D.slice().reverse();
    for (const p of backProfile) {
      points3D.push(new Vector3(0, 0, extrusionDepth - capConfig.depth + p.y));
    }
    return new CatmullRomCurve3(points3D);
  }
  /**
   * Create a flat (2D) geometry from SVG path
   */
  createFlatGeometry(path) {
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ShapeGeometry(shape);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    return finalGeometry;
  }
  /**
   * Merge multiple geometries into one
   */
  mergeGeometries(geometries) {
    let totalVertices = 0;
    let totalIndices = 0;
    let hasNormals = true;
    let hasUVs = true;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      if (pos) totalVertices += pos.count;
      const idx = geom.getIndex();
      if (idx) totalIndices += idx.count;
      else totalIndices += pos?.count ?? 0;
      if (!geom.getAttribute("normal")) hasNormals = false;
      if (!geom.getAttribute("uv")) hasUVs = false;
    }
    const positions = new Float32Array(totalVertices * 3);
    const normals = hasNormals ? new Float32Array(totalVertices * 3) : null;
    const uvs = hasUVs ? new Float32Array(totalVertices * 2) : null;
    const indices = new Uint32Array(totalIndices);
    let vertexOffset = 0;
    let indexOffset = 0;
    let indexVertexOffset = 0;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      const norm = geom.getAttribute("normal");
      const uv = geom.getAttribute("uv");
      const idx = geom.getIndex();
      if (pos) {
        positions.set(pos.array, vertexOffset * 3);
        if (normals && norm) {
          normals.set(norm.array, vertexOffset * 3);
        }
        if (uvs && uv) {
          uvs.set(uv.array, vertexOffset * 2);
        }
        if (idx) {
          for (let i = 0; i < idx.count; i++) {
            indices[indexOffset + i] = idx.getX(i) + indexVertexOffset;
          }
          indexOffset += idx.count;
        } else {
          for (let i = 0; i < pos.count; i++) {
            indices[indexOffset + i] = i + indexVertexOffset;
          }
          indexOffset += pos.count;
        }
        indexVertexOffset += pos.count;
        vertexOffset += pos.count;
      }
    }
    const merged = new BufferGeometry();
    merged.setAttribute("position", new BufferAttribute(positions, 3));
    if (normals) {
      merged.setAttribute("normal", new BufferAttribute(normals, 3));
    }
    if (uvs) {
      merged.setAttribute("uv", new BufferAttribute(uvs, 2));
    }
    merged.setIndex(new BufferAttribute(indices, 1));
    return merged;
  }
  // ==========================================================================
  // MESH CREATION
  // ==========================================================================
  /**
   * Create a 3D mesh from extruded SVG path
   */
  createMesh(path, extrusionConfig = {}, materialConfig = {}) {
    const geometry = this.createExtrudedGeometry(path, extrusionConfig);
    const material = this.createMaterial(path, materialConfig);
    const mesh = new Mesh(geometry, material);
    mesh.name = path.name;
    mesh.userData.svgPathId = path.id;
    return mesh;
  }
  /**
   * Create material for extruded mesh
   */
  createMaterial(path, config = {}) {
    const type = config.type ?? "standard";
    const color = config.color ?? `#${path.color.getHexString()}`;
    const side = this.getSide(config.side ?? "double");
    const baseParams = {
      color: new Color(color),
      transparent: config.transparent ?? path.fillOpacity < 1,
      opacity: config.opacity ?? path.fillOpacity,
      side
    };
    switch (type) {
      case "basic":
        return new MeshBasicMaterial(baseParams);
      case "physical":
        return new MeshPhysicalMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
      case "standard":
      default:
        return new MeshStandardMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
    }
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  // ==========================================================================
  // LAYER CREATION (LOGO WORKFLOW)
  // ==========================================================================
  /**
   * Create multiple layers from an SVG document for depth stacking
   * This is the main entry point for the logo workflow
   */
  createLayeredMeshes(document, layerConfigs) {
    const group = new Group();
    group.name = document.name;
    const centerX = document.bounds.minX + document.bounds.width / 2;
    const centerY = document.bounds.minY + document.bounds.height / 2;
    for (const config of layerConfigs) {
      const path = document.paths.find((p) => p.id === config.pathId);
      if (!path) continue;
      const mesh = this.createMesh(
        path,
        { depth: config.extrusionDepth },
        config.material
      );
      mesh.scale.setScalar(config.scale);
      mesh.position.set(
        config.position.x - centerX * config.scale,
        config.position.y + centerY * config.scale,
        // Flip Y
        config.position.z + config.depth
      );
      mesh.rotation.set(
        config.rotation.x * (Math.PI / 180),
        config.rotation.y * (Math.PI / 180),
        config.rotation.z * (Math.PI / 180)
      );
      group.add(mesh);
    }
    return group;
  }
  /**
   * Auto-generate layer configs for all paths in a document
   * Assigns incrementing depths to each path
   */
  generateAutoLayerConfigs(document, baseDepth = 0, depthIncrement = 5, extrusionDepth = 2) {
    return document.paths.map((path, index) => ({
      pathId: path.id,
      depth: baseDepth + index * depthIncrement,
      extrusionDepth,
      scale: 1,
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0, z: 0 },
      material: {
        type: "standard",
        color: `#${path.color.getHexString()}`,
        metalness: 0,
        roughness: 0.5,
        emissive: "#000000",
        emissiveIntensity: 0,
        opacity: path.fillOpacity,
        transparent: path.fillOpacity < 1,
        side: "double"
      }
    }));
  }
  // ==========================================================================
  // PARTICLE MESH GENERATION
  // ==========================================================================
  /**
   * Create a particle-ready mesh from SVG path
   * Optimized for instanced rendering
   */
  createParticleMesh(path, config = {}) {
    const extrusionDepth = config.extrusionDepth ?? 1;
    const scale = config.scale ?? 1;
    let geometry = this.createExtrudedGeometry(path, {
      depth: extrusionDepth,
      bevelEnabled: false,
      curveSegments: config.simplify ? 6 : 12
    });
    if (config.simplify) {
      geometry = this.simplifyGeometry(
        geometry,
        config.simplifyTolerance ?? 0.1
      );
    }
    if (config.centerOrigin !== false) {
      geometry.computeBoundingBox();
      const center = new Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);
    }
    if (scale !== 1) {
      geometry.scale(scale, scale, scale);
    }
    geometry.computeVertexNormals();
    return geometry;
  }
  /**
   * Simple geometry simplification (reduces vertex count)
   */
  simplifyGeometry(geometry, tolerance) {
    const position = geometry.getAttribute("position");
    const index = geometry.getIndex();
    if (!position) return geometry;
    const vertices = /* @__PURE__ */ new Map();
    const newPositions = [];
    const newIndices = [];
    const indexMap = /* @__PURE__ */ new Map();
    const roundToTolerance = (v) => Math.round(v / tolerance) * tolerance;
    for (let i = 0; i < position.count; i++) {
      const x = roundToTolerance(position.getX(i));
      const y = roundToTolerance(position.getY(i));
      const z = roundToTolerance(position.getZ(i));
      const key = `${x},${y},${z}`;
      if (!vertices.has(key)) {
        vertices.set(key, newPositions.length / 3);
        newPositions.push(x, y, z);
      }
      indexMap.set(i, vertices.get(key));
    }
    if (index) {
      for (let i = 0; i < index.count; i++) {
        const oldIdx = index.getX(i);
        newIndices.push(indexMap.get(oldIdx));
      }
    } else {
      for (let i = 0; i < position.count; i++) {
        newIndices.push(indexMap.get(i));
      }
    }
    const simplified = new BufferGeometry();
    simplified.setAttribute(
      "position",
      new Float32BufferAttribute(newPositions, 3)
    );
    simplified.setIndex(newIndices);
    simplified.computeVertexNormals();
    return simplified;
  }
  // ==========================================================================
  // STROKE/OUTLINE GEOMETRY
  // ==========================================================================
  /**
   * Create tube geometry from SVG stroke
   * Useful for neon-style effects or 3D outlines
   */
  createStrokeGeometry(path, tubeRadius = 1, tubularSegments = 64, radialSegments = 8) {
    const geometries = [];
    for (const shape of path.shapes) {
      const points = shape.getPoints(tubularSegments);
      const points3D = points.map((p) => new Vector3(p.x, -p.y, 0));
      const curve = new CatmullRomCurve3(points3D);
      const tubeGeometry = new TubeGeometry(
        curve,
        tubularSegments,
        tubeRadius,
        radialSegments,
        false
        // closed
      );
      geometries.push(tubeGeometry);
    }
    return geometries;
  }
  // ==========================================================================
  // UTILITY METHODS
  // ==========================================================================
  /**
   * Get cached document
   */
  getDocument(id) {
    return this.documentCache.get(id);
  }
  /**
   * Get all cached documents
   */
  getAllDocuments() {
    return Array.from(this.documentCache.values());
  }
  /**
   * Clear caches
   */
  clearCache() {
    this.documentCache.clear();
    for (const geometry of this.meshCache.values()) {
      geometry.dispose();
    }
    this.meshCache.clear();
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.clearCache();
  }
}
const svgExtrusionService = new SVGExtrusionService();

class MeshParticleManager {
  /** Registered mesh particles */
  meshRegistry = /* @__PURE__ */ new Map();
  /** Instanced mesh renderers */
  instancedMeshes = /* @__PURE__ */ new Map();
  /** Default material for mesh particles */
  defaultMaterial;
  /** Texture loader for thumbnails */
  textureLoader;
  constructor() {
    this.defaultMaterial = new MeshStandardMaterial({
      color: 16777215,
      metalness: 0,
      roughness: 0.5,
      side: DoubleSide
    });
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // MESH REGISTRATION
  // ==========================================================================
  /**
   * Register a mesh for use as particles
   */
  registerMesh(id, name, geometry, source, config) {
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();
    const registration = {
      id,
      name,
      source,
      geometry,
      boundingBox: geometry.boundingBox.clone(),
      boundingSphere: geometry.boundingSphere.clone(),
      vertexCount: geometry.getAttribute("position")?.count ?? 0,
      faceCount: geometry.index ? geometry.index.count / 3 : (geometry.getAttribute("position")?.count ?? 0) / 3,
      config
    };
    this.meshRegistry.set(id, registration);
    return registration;
  }
  /**
   * Register mesh from SVG path
   */
  registerFromSVG(svgDocumentId, svgPathId, name, options = {}) {
    const document2 = svgExtrusionService.getDocument(svgDocumentId);
    if (!document2) {
      console.warn(`SVG document not found: ${svgDocumentId}`);
      return null;
    }
    const path = document2.paths.find((p) => p.id === svgPathId);
    if (!path) {
      console.warn(`SVG path not found: ${svgPathId}`);
      return null;
    }
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: svgPathId
    });
    const id = `svg_particle_${svgDocumentId}_${svgPathId}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgDocumentId,
      svgPathId,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register mesh from parsed SVG path directly
   */
  registerFromSVGPath(path, name, options = {}) {
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: path.id
    });
    const id = `svg_particle_${path.id}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgPathId: path.id,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register a primitive shape as mesh particle
   */
  registerPrimitive(type, name, size = 1, detail = 1) {
    let geometry;
    switch (type) {
      case "cube":
        geometry = new BoxGeometry(size, size, size);
        break;
      case "sphere":
        geometry = new SphereGeometry(size / 2, 8 * detail, 6 * detail);
        break;
      case "cone":
        geometry = new ConeGeometry(size / 2, size, 8 * detail);
        break;
      case "cylinder":
        geometry = new CylinderGeometry(size / 2, size / 2, size, 8 * detail);
        break;
      case "torus":
        geometry = new TorusGeometry(size / 2, size / 6, 8 * detail, 12 * detail);
        break;
      case "tetrahedron":
        geometry = new TetrahedronGeometry(size / 2, detail - 1);
        break;
      case "octahedron":
        geometry = new OctahedronGeometry(size / 2, detail - 1);
        break;
      case "icosahedron":
        geometry = new IcosahedronGeometry(size / 2, detail - 1);
        break;
      default:
        geometry = new BoxGeometry(size, size, size);
    }
    const id = `primitive_${type}_${size}_${detail}`;
    const displayName = name ?? `${type?.charAt(0).toUpperCase()}${type?.slice(1)}`;
    return this.registerMesh(id, displayName, geometry, "primitive", {
      source: "primitive",
      primitiveType: type,
      primitiveSize: size,
      primitiveDetail: detail,
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0
    });
  }
  /**
   * Register a custom geometry
   */
  registerCustom(id, name, geometry, config) {
    return this.registerMesh(id, name, geometry, "custom", {
      source: "custom",
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0,
      ...config
    });
  }
  // ==========================================================================
  // INSTANCED MESH RENDERING
  // ==========================================================================
  /**
   * Create an instanced mesh for particle rendering
   */
  createInstancedMesh(meshId, maxInstances, material) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) {
      console.warn(`Mesh not found: ${meshId}`);
      return null;
    }
    const mat = material ?? this.createMaterialForMesh(registration);
    const instancedMesh = new InstancedMesh(
      registration.geometry,
      mat,
      maxInstances
    );
    instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);
    instancedMesh.count = 0;
    instancedMesh.frustumCulled = false;
    const instance = {
      mesh: instancedMesh,
      maxInstances,
      activeInstances: 0,
      geometry: registration.geometry,
      material: mat
    };
    this.instancedMeshes.set(meshId, instance);
    return instance;
  }
  /**
   * Update instanced mesh with particle data
   * @param meshId - Registered mesh ID
   * @param particles - Array of particle transforms
   */
  updateInstancedMesh(meshId, particles) {
    const instance = this.instancedMeshes.get(meshId);
    if (!instance) return;
    const matrix = new Matrix4();
    const quaternion = new Quaternion();
    const scaleVec = new Vector3();
    const count = Math.min(particles.length, instance.maxInstances);
    instance.mesh.count = count;
    instance.activeInstances = count;
    for (let i = 0; i < count; i++) {
      const p = particles[i];
      if (p.rotation instanceof Euler) {
        quaternion.setFromEuler(p.rotation);
      } else {
        quaternion.copy(p.rotation);
      }
      if (typeof p.scale === "number") {
        scaleVec.set(p.scale, p.scale, p.scale);
      } else {
        scaleVec.copy(p.scale);
      }
      matrix.compose(p.position, quaternion, scaleVec);
      instance.mesh.setMatrixAt(i, matrix);
      if (p.color && instance.mesh.instanceColor) {
        instance.mesh.setColorAt(i, p.color);
      }
    }
    instance.mesh.instanceMatrix.needsUpdate = true;
    if (instance.mesh.instanceColor) {
      instance.mesh.instanceColor.needsUpdate = true;
    }
  }
  /**
   * Create default material for a mesh
   */
  createMaterialForMesh(registration) {
    const config = registration.config;
    if (!config) {
      return this.defaultMaterial.clone();
    }
    return new MeshStandardMaterial({
      color: new Color(config.color ?? "#ffffff"),
      metalness: config.metalness ?? 0,
      roughness: config.roughness ?? 0.5,
      emissive: new Color(config.emissive ?? "#000000"),
      emissiveIntensity: config.emissiveIntensity ?? 0,
      side: DoubleSide
    });
  }
  // ==========================================================================
  // EMITTER INTEGRATION
  // ==========================================================================
  /**
   * Get EmitterShapeConfig for mesh emission
   * Particles emit from mesh vertices
   */
  getEmitterShapeConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const position = registration.geometry.getAttribute("position");
    const normal = registration.geometry.getAttribute("normal");
    if (!position) return null;
    const vertices = new Float32Array(position.array);
    const normals = normal ? new Float32Array(normal.array) : void 0;
    return {
      type: "mesh",
      meshVertices: vertices,
      meshNormals: normals
    };
  }
  /**
   * Get RenderConfig for mesh particle rendering
   */
  getRenderConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    return {
      mode: "mesh",
      meshGeometry: meshId
    };
  }
  // ==========================================================================
  // LOD MANAGEMENT
  // ==========================================================================
  /**
   * Add LOD levels to a registered mesh
   */
  addLODLevels(meshId, lodGeometries, lodDistances) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return;
    registration.lodGeometries = lodGeometries;
    registration.lodDistances = lodDistances;
  }
  /**
   * Get appropriate LOD geometry for distance
   */
  getLODGeometry(meshId, distance) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    if (!registration.lodGeometries || !registration.lodDistances) {
      return registration.geometry;
    }
    for (let i = registration.lodDistances.length - 1; i >= 0; i--) {
      if (distance >= registration.lodDistances[i]) {
        return registration.lodGeometries[i];
      }
    }
    return registration.geometry;
  }
  // ==========================================================================
  // THUMBNAIL GENERATION
  // ==========================================================================
  /**
   * Generate a thumbnail preview for a mesh
   */
  async generateThumbnail(meshId, size = 128) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const scene = new Scene();
    scene.background = new Color(1710618);
    const mesh = new Mesh(
      registration.geometry,
      new MeshStandardMaterial({
        color: 16777215,
        metalness: 0.3,
        roughness: 0.6
      })
    );
    scene.add(mesh);
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    const radius = registration.boundingSphere.radius;
    const distance = radius / Math.sin(camera.fov * Math.PI / 360);
    camera.position.set(distance * 0.8, distance * 0.5, distance * 0.8);
    camera.lookAt(registration.boundingSphere.center);
    const ambient = new AmbientLight(16777215, 0.5);
    const directional = new DirectionalLight(16777215, 1);
    directional.position.set(5, 10, 5);
    scene.add(ambient, directional);
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const renderer = new WebGLRenderer({
      canvas,
      antialias: true,
      preserveDrawingBuffer: true
    });
    renderer.setSize(size, size);
    renderer.render(scene, camera);
    const dataUrl = canvas.toDataURL("image/png");
    renderer.dispose();
    mesh.geometry.dispose();
    mesh.material.dispose();
    registration.thumbnail = dataUrl;
    return dataUrl;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a registered mesh
   */
  getMesh(id) {
    return this.meshRegistry.get(id);
  }
  /**
   * Get all registered meshes
   */
  getAllMeshes() {
    return Array.from(this.meshRegistry.values());
  }
  /**
   * Get meshes by source type
   */
  getMeshesBySource(source) {
    return Array.from(this.meshRegistry.values()).filter(
      (m) => m.source === source
    );
  }
  /**
   * Get instanced mesh renderer
   */
  getInstancedMesh(meshId) {
    return this.instancedMeshes.get(meshId);
  }
  /**
   * Check if a mesh is registered
   */
  hasMesh(id) {
    return this.meshRegistry.has(id);
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Unregister a mesh
   */
  unregisterMesh(id) {
    const registration = this.meshRegistry.get(id);
    if (registration) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.delete(id);
    const instance = this.instancedMeshes.get(id);
    if (instance) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const registration of this.meshRegistry.values()) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.clear();
    for (const instance of this.instancedMeshes.values()) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.clear();
    this.defaultMaterial.dispose();
  }
}
const meshParticleManager = new MeshParticleManager();

class SpriteSheetService {
  sheets = /* @__PURE__ */ new Map();
  textureLoader;
  constructor() {
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // LOADING
  // ==========================================================================
  /**
   * Load a sprite sheet from URL with grid-based layout
   */
  async loadFromGrid(url, columns, rows, options = {}) {
    const texture = await this.loadTexture(url);
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            // Flip Y for Three.js
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: {
            x,
            y,
            width: frameWidth,
            height: frameHeight
          }
        });
      }
    }
    const config = {
      id,
      name: options.name || url,
      url,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load a sprite sheet from URL with JSON metadata
   */
  async loadFromMetadata(imageUrl, metadataUrl, options = {}) {
    const [texture, metadataResponse] = await Promise.all([
      this.loadTexture(imageUrl),
      fetch(metadataUrl)
    ]);
    const metadata = await metadataResponse.json();
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frames = [];
    const frameEntries = Object.entries(metadata.frames);
    frameEntries.forEach(([name, frameData], index) => {
      const f = frameData.frame;
      frames.push({
        index,
        name,
        uv: {
          u: f.x / imageWidth,
          v: 1 - (f.y + f.h) / imageHeight,
          w: f.w / imageWidth,
          h: f.h / imageHeight
        },
        source: {
          x: f.x,
          y: f.y,
          width: f.w,
          height: f.h
        },
        duration: frameData.duration
      });
    });
    const columns = Math.ceil(Math.sqrt(frames.length));
    const rows = Math.ceil(frames.length / columns);
    const config = {
      id,
      name: options.name || imageUrl,
      url: imageUrl,
      texture,
      columns,
      rows,
      frames,
      totalFrames: frames.length,
      frameWidth: frames[0]?.source.width ?? 0,
      frameHeight: frames[0]?.source.height ?? 0,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: true
    };
    if (metadata.meta?.frameTags) {
      for (const tag of metadata.meta.frameTags) {
        const animFrames = [];
        for (let i = tag.from; i <= tag.to; i++) {
          animFrames.push(i);
        }
        config.animations.set(tag.name, {
          name: tag.name,
          frames: animFrames,
          frameRate: config.defaultFrameRate,
          loop: true,
          pingPong: tag.direction === "pingpong"
        });
      }
    }
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load texture from URL
   */
  loadTexture(url) {
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          texture.magFilter = NearestFilter;
          texture.minFilter = NearestFilter;
          texture.generateMipmaps = false;
          texture.colorSpace = SRGBColorSpace;
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Create a sprite sheet from an existing texture
   */
  createFromTexture(texture, columns, rows, options = {}) {
    const id = options.id || `spritesheet_${Date.now()}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: { x, y, width: frameWidth, height: frameHeight }
        });
      }
    }
    const config = {
      id,
      name: options.name || id,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  // ==========================================================================
  // ANIMATION MANAGEMENT
  // ==========================================================================
  /**
   * Add a custom animation to a sprite sheet
   */
  addAnimation(sheetId, animation) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) {
      console.warn(`Sprite sheet not found: ${sheetId}`);
      return;
    }
    sheet.animations.set(animation.name, animation);
  }
  /**
   * Get frame index for a specific time in an animation
   */
  getFrameAtTime(sheetId, animationName, timeMs) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) return 0;
    const animation = sheet.animations.get(animationName);
    if (!animation || animation.frames.length === 0) return 0;
    const frameDuration = 1e3 / animation.frameRate;
    const totalDuration = animation.frames.length * frameDuration;
    let t = timeMs;
    if (animation.loop) {
      if (animation.pingPong) {
        const fullCycle = totalDuration * 2 - frameDuration * 2;
        t = t % fullCycle;
        if (t > totalDuration - frameDuration) {
          t = fullCycle - t;
        }
      } else {
        t = t % totalDuration;
      }
    } else {
      t = Math.min(t, totalDuration - frameDuration);
    }
    const frameIndex = Math.floor(t / frameDuration);
    return animation.frames[Math.min(frameIndex, animation.frames.length - 1)];
  }
  /**
   * Get UV coordinates for a specific frame
   */
  getFrameUV(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || frameIndex < 0 || frameIndex >= sheet.frames.length) {
      return null;
    }
    return sheet.frames[frameIndex].uv;
  }
  // ==========================================================================
  // PARTICLE SYSTEM INTEGRATION
  // ==========================================================================
  /**
   * Get texture config for GPU particle system
   */
  getParticleTextureConfig(sheetId, animationName) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || !sheet.url) return null;
    const animation = animationName ? sheet.animations.get(animationName) : sheet.animations.get("all");
    return {
      diffuseMap: sheet.url,
      spriteSheetColumns: sheet.columns,
      spriteSheetRows: sheet.rows,
      animateSprite: true,
      spriteFrameRate: animation?.frameRate ?? sheet.defaultFrameRate,
      randomStartFrame: true
    };
  }
  /**
   * Create a Three.js SpriteMaterial for a specific frame
   */
  createSpriteMaterial(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture) return null;
    const frame = sheet.frames[frameIndex];
    if (!frame) return null;
    const texture = sheet.texture.clone();
    texture.offset.set(frame.uv.u, frame.uv.v);
    texture.repeat.set(frame.uv.w, frame.uv.h);
    texture.needsUpdate = true;
    return new SpriteMaterial({
      map: texture,
      transparent: true
    });
  }
  /**
   * Update a SpriteMaterial to show a specific frame
   */
  updateSpriteMaterialFrame(material, sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture || !material.map) return;
    const frame = sheet.frames[frameIndex];
    if (!frame) return;
    material.map.offset.set(frame.uv.u, frame.uv.v);
    material.map.repeat.set(frame.uv.w, frame.uv.h);
    material.map.needsUpdate = true;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a sprite sheet by ID
   */
  getSheet(id) {
    return this.sheets.get(id);
  }
  /**
   * Get all sprite sheets
   */
  getAllSheets() {
    return Array.from(this.sheets.values());
  }
  /**
   * Check if a sprite sheet exists
   */
  hasSheet(id) {
    return this.sheets.has(id);
  }
  /**
   * Get texture for a sprite sheet
   */
  getTexture(sheetId) {
    return this.sheets.get(sheetId)?.texture;
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Remove a sprite sheet
   */
  removeSheet(id) {
    const sheet = this.sheets.get(id);
    if (sheet?.texture) {
      sheet.texture.dispose();
    }
    this.sheets.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const sheet of this.sheets.values()) {
      if (sheet.texture) {
        sheet.texture.dispose();
      }
    }
    this.sheets.clear();
  }
}
const spriteSheetService = new SpriteSheetService();

class MaterialSystem {
  /** Texture cache */
  textureCache = /* @__PURE__ */ new Map();
  /** Material cache */
  materialCache = /* @__PURE__ */ new Map();
  /** Current environment map */
  envMap = null;
  /** Environment configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true
  };
  /** HDRI loader */
  rgbeLoader;
  exrLoader;
  /** Texture loader */
  textureLoader;
  /** PMREMGenerator for environment maps */
  pmremGenerator = null;
  /** Asset getter callback */
  assetGetter;
  constructor() {
    this.rgbeLoader = new RGBELoader();
    this.exrLoader = new EXRLoader();
    this.textureLoader = new TextureLoader();
  }
  /**
   * Initialize with WebGL renderer (required for PMREM)
   */
  initialize(renderer) {
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Set asset getter callback
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  // ============================================================================
  // TEXTURE LOADING
  // ============================================================================
  /**
   * Load a texture from URL or asset ID
   */
  async loadTexture(urlOrAssetId, mapType, options) {
    const cacheKey = `${urlOrAssetId}:${mapType}`;
    const cached = this.textureCache.get(cacheKey);
    if (cached) return cached;
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.configureTextureForMapType(texture, mapType);
          if (options?.repeat) {
            texture.repeat.set(options.repeat.x, options.repeat.y);
            texture.wrapS = RepeatWrapping;
            texture.wrapT = RepeatWrapping;
          }
          if (options?.offset) {
            texture.offset.set(options.offset.x, options.offset.y);
          }
          if (options?.rotation !== void 0) {
            texture.rotation = options.rotation * (Math.PI / 180);
          }
          this.textureCache.set(cacheKey, texture);
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Configure texture settings based on map type
   */
  configureTextureForMapType(texture, mapType) {
    texture.generateMipmaps = true;
    texture.minFilter = LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    switch (mapType) {
      case "albedo":
      case "emissive":
        texture.colorSpace = SRGBColorSpace;
        break;
      case "normal":
      case "roughness":
      case "metalness":
      case "ao":
      case "height":
      case "opacity":
      case "specular":
        texture.colorSpace = LinearSRGBColorSpace;
        break;
    }
  }
  // ============================================================================
  // PBR MATERIAL CREATION
  // ============================================================================
  /**
   * Create a PBR material from configuration
   */
  async createPBRMaterial(config) {
    const cached = this.materialCache.get(config.id);
    if (cached) return cached;
    const material = new MeshStandardMaterial({
      color: new Color(config.color),
      metalness: config.metalness,
      roughness: config.roughness,
      transparent: config.transparent,
      opacity: config.opacity,
      emissive: new Color(config.emissive),
      emissiveIntensity: config.emissiveIntensity,
      envMapIntensity: config.envMapIntensity,
      normalScale: new Vector2(config.normalScale, config.normalScale),
      displacementScale: config.displacementScale,
      displacementBias: config.displacementBias,
      aoMapIntensity: config.aoMapIntensity,
      flatShading: config.flatShading,
      wireframe: config.wireframe,
      depthWrite: config.depthWrite,
      depthTest: config.depthTest,
      side: this.getSide(config.side)
    });
    const texturePromises = [];
    if (config.maps.albedo) {
      texturePromises.push(
        this.loadTexture(config.maps.albedo, "albedo", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.map = tex;
        })
      );
    }
    if (config.maps.normal) {
      texturePromises.push(
        this.loadTexture(config.maps.normal, "normal", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.normalMap = tex;
        })
      );
    }
    if (config.maps.roughness) {
      texturePromises.push(
        this.loadTexture(config.maps.roughness, "roughness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.roughnessMap = tex;
        })
      );
    }
    if (config.maps.metalness) {
      texturePromises.push(
        this.loadTexture(config.maps.metalness, "metalness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.metalnessMap = tex;
        })
      );
    }
    if (config.maps.ao) {
      texturePromises.push(
        this.loadTexture(config.maps.ao, "ao", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.aoMap = tex;
        })
      );
    }
    if (config.maps.emissive) {
      texturePromises.push(
        this.loadTexture(config.maps.emissive, "emissive", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.emissiveMap = tex;
        })
      );
    }
    if (config.maps.height) {
      texturePromises.push(
        this.loadTexture(config.maps.height, "height", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.displacementMap = tex;
        })
      );
    }
    if (config.maps.opacity) {
      texturePromises.push(
        this.loadTexture(config.maps.opacity, "opacity", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.alphaMap = tex;
          material.transparent = true;
        })
      );
    }
    if (this.envMap && this.envConfig.enabled) {
      material.envMap = this.envMap;
    }
    await Promise.all(texturePromises);
    material.needsUpdate = true;
    this.materialCache.set(config.id, material);
    return material;
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  /**
   * Create default PBR material config
   */
  static createDefaultConfig(id, name) {
    return {
      id,
      name,
      color: "#ffffff",
      opacity: 1,
      transparent: false,
      metalness: 0,
      roughness: 0.5,
      envMapIntensity: 1,
      emissive: "#000000",
      emissiveIntensity: 1,
      normalScale: 1,
      displacementScale: 0,
      displacementBias: 0,
      aoMapIntensity: 1,
      maps: {},
      textureRepeat: { x: 1, y: 1 },
      textureOffset: { x: 0, y: 0 },
      textureRotation: 0,
      side: "double",
      flatShading: false,
      wireframe: false,
      depthWrite: true,
      depthTest: true
    };
  }
  // ============================================================================
  // ENVIRONMENT MAPS (HDRI)
  // ============================================================================
  /**
   * Load an environment map (HDR/EXR)
   */
  async loadEnvironmentMap(urlOrAssetId) {
    if (!this.pmremGenerator) {
      throw new Error("MaterialSystem not initialized. Call initialize() with renderer first.");
    }
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    const isEXR = url.toLowerCase().endsWith(".exr");
    const loader = isEXR ? this.exrLoader : this.rgbeLoader;
    return new Promise((resolve, reject) => {
      loader.load(
        url,
        (texture) => {
          const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
          texture.dispose();
          this.envMap = envMap;
          this.envConfig.enabled = true;
          this.updateMaterialsEnvMap();
          resolve(envMap);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Set environment configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (config.intensity !== void 0) {
      for (const material of this.materialCache.values()) {
        material.envMapIntensity = config.intensity;
      }
    }
  }
  /**
   * Get current environment map for scene background
   */
  getEnvironmentMap() {
    return this.envMap;
  }
  /**
   * Get environment config
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Update all materials with current environment map
   */
  updateMaterialsEnvMap() {
    for (const material of this.materialCache.values()) {
      material.envMap = this.envConfig.enabled ? this.envMap : null;
      material.envMapIntensity = this.envConfig.intensity;
      material.needsUpdate = true;
    }
  }
  // ============================================================================
  // MATERIAL PRESETS
  // ============================================================================
  /**
   * Get built-in material presets
   */
  static getPresets() {
    return [
      // Metals
      {
        id: "chrome",
        name: "Chrome",
        category: "Metal",
        config: {
          color: "#ffffff",
          metalness: 1,
          roughness: 0.05,
          envMapIntensity: 1.5
        }
      },
      {
        id: "brushed_steel",
        name: "Brushed Steel",
        category: "Metal",
        config: {
          color: "#c0c0c0",
          metalness: 1,
          roughness: 0.4
        }
      },
      {
        id: "gold",
        name: "Gold",
        category: "Metal",
        config: {
          color: "#ffd700",
          metalness: 1,
          roughness: 0.2
        }
      },
      {
        id: "copper",
        name: "Copper",
        category: "Metal",
        config: {
          color: "#b87333",
          metalness: 1,
          roughness: 0.3
        }
      },
      // Plastics
      {
        id: "glossy_plastic",
        name: "Glossy Plastic",
        category: "Plastic",
        config: {
          color: "#ff0000",
          metalness: 0,
          roughness: 0.1
        }
      },
      {
        id: "matte_plastic",
        name: "Matte Plastic",
        category: "Plastic",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.8
        }
      },
      // Glass
      {
        id: "clear_glass",
        name: "Clear Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0,
          opacity: 0.2,
          transparent: true,
          envMapIntensity: 2
        }
      },
      {
        id: "frosted_glass",
        name: "Frosted Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.5,
          opacity: 0.5,
          transparent: true
        }
      },
      // Natural
      {
        id: "clay",
        name: "Clay",
        category: "Natural",
        config: {
          color: "#d4a574",
          metalness: 0,
          roughness: 0.9
        }
      },
      {
        id: "stone",
        name: "Stone",
        category: "Natural",
        config: {
          color: "#808080",
          metalness: 0,
          roughness: 0.7
        }
      },
      // Emissive
      {
        id: "neon_glow",
        name: "Neon Glow",
        category: "Emissive",
        config: {
          color: "#000000",
          emissive: "#00ffff",
          emissiveIntensity: 2,
          metalness: 0,
          roughness: 0.5
        }
      },
      {
        id: "hot_metal",
        name: "Hot Metal",
        category: "Emissive",
        config: {
          color: "#ff4400",
          emissive: "#ff2200",
          emissiveIntensity: 1,
          metalness: 0.8,
          roughness: 0.4
        }
      }
    ];
  }
  /**
   * Create material from preset
   */
  async createFromPreset(presetId, materialId, overrides) {
    const preset = MaterialSystem.getPresets().find((p) => p.id === presetId);
    if (!preset) {
      throw new Error(`Preset not found: ${presetId}`);
    }
    const config = {
      ...MaterialSystem.createDefaultConfig(materialId, preset.name),
      ...preset.config,
      ...overrides,
      id: materialId
    };
    return this.createPBRMaterial(config);
  }
  // ============================================================================
  // MATERIAL UPDATES
  // ============================================================================
  /**
   * Update an existing material's properties
   */
  updateMaterial(materialId, updates) {
    const material = this.materialCache.get(materialId);
    if (!material) return;
    if (updates.color !== void 0) {
      material.color.set(updates.color);
    }
    if (updates.metalness !== void 0) {
      material.metalness = updates.metalness;
    }
    if (updates.roughness !== void 0) {
      material.roughness = updates.roughness;
    }
    if (updates.opacity !== void 0) {
      material.opacity = updates.opacity;
    }
    if (updates.transparent !== void 0) {
      material.transparent = updates.transparent;
    }
    if (updates.emissive !== void 0) {
      material.emissive.set(updates.emissive);
    }
    if (updates.emissiveIntensity !== void 0) {
      material.emissiveIntensity = updates.emissiveIntensity;
    }
    if (updates.envMapIntensity !== void 0) {
      material.envMapIntensity = updates.envMapIntensity;
    }
    if (updates.normalScale !== void 0) {
      material.normalScale.set(updates.normalScale, updates.normalScale);
    }
    if (updates.wireframe !== void 0) {
      material.wireframe = updates.wireframe;
    }
    if (updates.flatShading !== void 0) {
      material.flatShading = updates.flatShading;
    }
    if (updates.side !== void 0) {
      material.side = this.getSide(updates.side);
    }
    material.needsUpdate = true;
  }
  /**
   * Get a cached material
   */
  getMaterial(materialId) {
    return this.materialCache.get(materialId);
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  /**
   * Dispose a material
   */
  disposeMaterial(materialId) {
    const material = this.materialCache.get(materialId);
    if (material) {
      material.dispose();
      this.materialCache.delete(materialId);
    }
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const texture of this.textureCache.values()) {
      texture.dispose();
    }
    this.textureCache.clear();
    for (const material of this.materialCache.values()) {
      material.dispose();
    }
    this.materialCache.clear();
    if (this.envMap) {
      this.envMap.dispose();
      this.envMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
  }
}
const materialSystem = new MaterialSystem();

const useAssetStore = defineStore("assets", {
  state: () => ({
    // Materials
    materials: /* @__PURE__ */ new Map(),
    selectedMaterialId: null,
    // SVG Documents
    svgDocuments: /* @__PURE__ */ new Map(),
    selectedSvgId: null,
    // Mesh Particles
    meshParticles: /* @__PURE__ */ new Map(),
    selectedMeshParticleId: null,
    // Sprite Sheets
    spriteSheets: /* @__PURE__ */ new Map(),
    selectedSpriteSheetId: null,
    // Environment
    environment: {
      enabled: false,
      url: null,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true
    },
    environmentTexture: null,
    // Loading states
    isLoadingMaterial: false,
    isLoadingSvg: false,
    isLoadingMesh: false,
    isLoadingSpriteSheet: false,
    isLoadingEnvironment: false,
    // Error states
    lastError: null
  }),
  getters: {
    // Materials
    materialList: (state) => Array.from(state.materials.values()),
    selectedMaterial: (state) => state.selectedMaterialId ? state.materials.get(state.selectedMaterialId) ?? null : null,
    // SVG Documents
    svgDocumentList: (state) => Array.from(state.svgDocuments.values()),
    selectedSvgDocument: (state) => state.selectedSvgId ? state.svgDocuments.get(state.selectedSvgId) ?? null : null,
    // Mesh Particles
    meshParticleList: (state) => Array.from(state.meshParticles.values()),
    selectedMeshParticle: (state) => state.selectedMeshParticleId ? state.meshParticles.get(state.selectedMeshParticleId) ?? null : null,
    // Sprite Sheets
    spriteSheetList: (state) => Array.from(state.spriteSheets.values()),
    selectedSpriteSheet: (state) => state.selectedSpriteSheetId ? state.spriteSheets.get(state.selectedSpriteSheetId) ?? null : null,
    // Combined loading state
    isLoading: (state) => state.isLoadingMaterial || state.isLoadingSvg || state.isLoadingMesh || state.isLoadingSpriteSheet || state.isLoadingEnvironment
  },
  actions: {
    // ========================================================================
    // MATERIALS
    // ========================================================================
    /**
     * Create a new material from preset
     */
    createMaterialFromPreset(presetName, customName) {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const presetConfigs = {
        chrome: { color: "#ffffff", metalness: 1, roughness: 0.1 },
        gold: { color: "#ffd700", metalness: 1, roughness: 0.2 },
        silver: { color: "#c0c0c0", metalness: 1, roughness: 0.15 },
        copper: { color: "#b87333", metalness: 1, roughness: 0.3 },
        brass: { color: "#b5a642", metalness: 0.9, roughness: 0.25 },
        glass: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true },
        plastic: { color: "#ffffff", metalness: 0, roughness: 0.4 },
        rubber: { color: "#222222", metalness: 0, roughness: 0.9 },
        wood: { color: "#8b4513", metalness: 0, roughness: 0.7 },
        concrete: { color: "#808080", metalness: 0, roughness: 0.9 },
        emissive: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2 },
        holographic: { color: "#88ffff", metalness: 0.8, roughness: 0.2, emissive: "#ff00ff", emissiveIntensity: 0.5 }
      };
      const presetConfig = presetConfigs[presetName] || {};
      const config = this.createDefaultMaterialConfig(id, customName || presetName, presetConfig);
      const stored = {
        id,
        name: customName || presetName,
        config,
        presetName,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      storeLogger.debug("Created material from preset:", presetName, id);
      return id;
    },
    /**
     * Create a new empty material
     */
    createEmptyMaterial(name = "New Material") {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const config = this.createDefaultMaterialConfig(id, name);
      const stored = {
        id,
        name,
        config,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      return id;
    },
    /**
     * Helper to create a full default material config
     */
    createDefaultMaterialConfig(id, name, overrides = {}) {
      return {
        id,
        name,
        color: "#ffffff",
        opacity: 1,
        transparent: false,
        metalness: 0,
        roughness: 0.5,
        envMapIntensity: 1,
        emissive: "#000000",
        emissiveIntensity: 0,
        normalScale: 1,
        displacementScale: 0,
        displacementBias: 0,
        aoMapIntensity: 1,
        maps: {},
        textureRepeat: { x: 1, y: 1 },
        textureOffset: { x: 0, y: 0 },
        textureRotation: 0,
        side: "front",
        flatShading: false,
        wireframe: false,
        depthWrite: true,
        depthTest: true,
        ...overrides
      };
    },
    /**
     * Update material configuration
     */
    updateMaterial(id, updates) {
      const stored = this.materials.get(id);
      if (!stored) return;
      stored.config = { ...stored.config, ...updates };
      stored.modifiedAt = Date.now();
      this.materials.set(id, stored);
    },
    /**
     * Set texture for material
     */
    async setMaterialTexture(materialId, textureType, file) {
      const stored = this.materials.get(materialId);
      if (!stored) return;
      this.isLoadingMaterial = true;
      try {
        const url = URL.createObjectURL(file);
        stored.config[textureType] = url;
        stored.modifiedAt = Date.now();
        this.materials.set(materialId, stored);
      } catch (error) {
        this.lastError = `Failed to load texture: ${error}`;
      } finally {
        this.isLoadingMaterial = false;
      }
    },
    /**
     * Delete a material
     */
    deleteMaterial(id) {
      this.materials.delete(id);
      if (this.selectedMaterialId === id) {
        this.selectedMaterialId = null;
      }
    },
    /**
     * Get Three.js material from stored config
     * Note: This creates a simple THREE.MeshStandardMaterial without async texture loading
     * For full PBR with textures, use materialSystem.createPBRMaterial()
     */
    getThreeMaterial(id) {
      const stored = this.materials.get(id);
      if (!stored) return null;
      const config = stored.config;
      const material = new MeshStandardMaterial({
        color: new Color(config.color),
        metalness: config.metalness,
        roughness: config.roughness,
        transparent: config.transparent,
        opacity: config.opacity,
        flatShading: config.flatShading,
        wireframe: config.wireframe,
        side: config.side === "double" ? DoubleSide : config.side === "back" ? BackSide : FrontSide
      });
      if (config.emissive && config.emissive !== "#000000") {
        material.emissive = new Color(config.emissive);
        material.emissiveIntensity = config.emissiveIntensity;
      }
      return material;
    },
    // ========================================================================
    // SVG DOCUMENTS
    // ========================================================================
    /**
     * Import SVG from file
     */
    async importSvgFromFile(file) {
      this.isLoadingSvg = true;
      try {
        const text = await file.text();
        const name = file.name.replace(/\.svg$/i, "");
        const document = svgExtrusionService.loadFromString(text, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          // baseDepth
          5,
          // depthIncrement between layers
          2
          // extrusionDepth per layer
        );
        const id = document.id;
        const stored = {
          id,
          name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        storeLogger.debug("Imported SVG:", name, `${document.paths.length} paths`);
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Import SVG from URL
     */
    async importSvgFromUrl(url, name) {
      this.isLoadingSvg = true;
      try {
        const document = await svgExtrusionService.loadFromURL(url, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          5,
          2
        );
        const id = document.id;
        const stored = {
          id,
          name: document.name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Update layer config for an SVG path
     */
    updateSvgLayerConfig(svgId, pathIndex, config) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.layerConfigs.length) return;
      stored.layerConfigs[pathIndex] = { ...stored.layerConfigs[pathIndex], ...config };
      this.svgDocuments.set(svgId, stored);
    },
    /**
     * Get extruded geometries for all paths in an SVG
     */
    getExtrudedGeometries(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return [];
      return stored.document.paths.map((path, i) => {
        const config = stored.layerConfigs[i];
        return svgExtrusionService.createExtrudedGeometry(path, {
          depth: config.extrusionDepth
        });
      });
    },
    /**
     * Create a Three.js Group with all extruded SVG paths
     */
    createExtrudedGroup(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return null;
      return svgExtrusionService.createLayeredMeshes(
        stored.document,
        stored.layerConfigs
      );
    },
    /**
     * Delete an SVG document
     */
    deleteSvgDocument(id) {
      this.svgDocuments.delete(id);
      if (this.selectedSvgId === id) {
        this.selectedSvgId = null;
      }
    },
    // ========================================================================
    // MESH PARTICLES
    // ========================================================================
    /**
     * Register a primitive shape as mesh particle
     */
    registerPrimitiveMesh(type, name, size = 1) {
      const registration = meshParticleManager.registerPrimitive(type, name, size);
      const stored = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "primitive"
      };
      this.meshParticles.set(registration.id, stored);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Register an SVG path as mesh particle
     */
    registerSvgPathAsMesh(svgId, pathIndex, name, options) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.document.paths.length) return null;
      const path = stored.document.paths[pathIndex];
      const registration = meshParticleManager.registerFromSVG(
        svgId,
        path.id,
        name || `${stored.name}_${pathIndex}`,
        options
      );
      if (!registration) return null;
      const storedMesh = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "svg",
        sourceId: path.id
      };
      this.meshParticles.set(registration.id, storedMesh);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Get emitter config for mesh-based emission
     */
    getMeshEmitterConfig(meshId) {
      return meshParticleManager.getEmitterShapeConfig(meshId);
    },
    /**
     * Create instanced mesh for particle rendering
     */
    createInstancedMesh(meshId, maxInstances, materialId) {
      const material = materialId ? this.getThreeMaterial(materialId) : void 0;
      const result = meshParticleManager.createInstancedMesh(meshId, maxInstances, material || void 0);
      return result?.mesh || null;
    },
    /**
     * Delete a mesh particle
     */
    deleteMeshParticle(id) {
      meshParticleManager.unregisterMesh(id);
      this.meshParticles.delete(id);
      if (this.selectedMeshParticleId === id) {
        this.selectedMeshParticleId = null;
      }
    },
    // ========================================================================
    // SPRITE SHEETS
    // ========================================================================
    /**
     * Import sprite sheet from file
     */
    async importSpriteSheet(file, columns, rows, options) {
      this.isLoadingSpriteSheet = true;
      try {
        const url = URL.createObjectURL(file);
        const config = await spriteSheetService.loadFromGrid(url, columns, rows, {
          name: options?.name || file.name.replace(/\.[^.]+$/, ""),
          frameRate: options?.frameRate
        });
        const stored = {
          id: config.id,
          name: config.name || config.id,
          config,
          textureUrl: url
        };
        this.spriteSheets.set(config.id, stored);
        this.selectedSpriteSheetId = config.id;
        return { success: true, assetId: config.id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Sprite sheet import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSpriteSheet = false;
      }
    },
    /**
     * Add animation to sprite sheet
     */
    addSpriteAnimation(sheetId, name, frames, options) {
      spriteSheetService.addAnimation(sheetId, {
        name,
        frames,
        frameRate: options?.frameRate ?? 24,
        loop: options?.loop ?? true,
        pingPong: options?.pingPong ?? false
      });
    },
    /**
     * Get particle texture config for GPU particles
     */
    getParticleTextureConfig(sheetId) {
      return spriteSheetService.getParticleTextureConfig(sheetId);
    },
    /**
     * Delete a sprite sheet
     */
    deleteSpriteSheet(id) {
      const stored = this.spriteSheets.get(id);
      if (stored?.textureUrl) {
        URL.revokeObjectURL(stored.textureUrl);
      }
      spriteSheetService.removeSheet(id);
      this.spriteSheets.delete(id);
      if (this.selectedSpriteSheetId === id) {
        this.selectedSpriteSheetId = null;
      }
    },
    // ========================================================================
    // ENVIRONMENT
    // ========================================================================
    /**
     * Load HDRI environment map
     */
    async loadEnvironment(file, options) {
      this.isLoadingEnvironment = true;
      try {
        const url = URL.createObjectURL(file);
        this.environment = {
          ...this.environment,
          url,
          intensity: options?.intensity ?? this.environment.intensity,
          rotation: options?.rotation ?? this.environment.rotation,
          useAsBackground: options?.useAsBackground ?? this.environment.useAsBackground,
          enabled: true
        };
        storeLogger.debug("Environment loaded:", file.name);
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Load environment from preset URL
     */
    async loadEnvironmentPreset(presetUrl, presetName) {
      this.isLoadingEnvironment = true;
      try {
        this.environment = {
          ...this.environment,
          url: presetUrl,
          presetName,
          enabled: true
        };
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment preset load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Update environment settings
     */
    updateEnvironment(settings) {
      this.environment = { ...this.environment, ...settings };
    },
    /**
     * Clear environment
     */
    clearEnvironment() {
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      this.environment = {
        enabled: false,
        url: null,
        intensity: 1,
        rotation: 0,
        backgroundBlur: 0,
        useAsBackground: true
      };
      this.environmentTexture = null;
    },
    // ========================================================================
    // UTILITIES
    // ========================================================================
    /**
     * Clear last error
     */
    clearError() {
      this.lastError = null;
    },
    /**
     * Dispose all assets and free resources
     */
    dispose() {
      for (const stored of this.materials.values()) {
        for (const key of Object.keys(stored.config)) {
          const value = stored.config[key];
          if (typeof value === "string" && value.startsWith("blob:")) {
            URL.revokeObjectURL(value);
          }
        }
      }
      for (const stored of this.spriteSheets.values()) {
        if (stored.textureUrl.startsWith("blob:")) {
          URL.revokeObjectURL(stored.textureUrl);
        }
      }
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      svgExtrusionService.dispose();
      meshParticleManager.dispose();
      spriteSheetService.dispose();
      materialSystem.dispose();
      this.materials.clear();
      this.svgDocuments.clear();
      this.meshParticles.clear();
      this.spriteSheets.clear();
      this.selectedMaterialId = null;
      this.selectedSvgId = null;
      this.selectedMeshParticleId = null;
      this.selectedSpriteSheetId = null;
      this.clearEnvironment();
    }
  }
});

const _hoisted_1$G = { class: "model-3d-properties" };
const _hoisted_2$G = { class: "property-section" };
const _hoisted_3$G = {
  key: 0,
  class: "property-group"
};
const _hoisted_4$G = { class: "info-row" };
const _hoisted_5$G = { class: "value" };
const _hoisted_6$G = {
  key: 0,
  class: "info-row"
};
const _hoisted_7$G = { class: "value" };
const _hoisted_8$E = {
  key: 1,
  class: "info-row"
};
const _hoisted_9$E = { class: "value" };
const _hoisted_10$D = { class: "property-section" };
const _hoisted_11$C = { class: "section-content" };
const _hoisted_12$A = { class: "property-group" };
const _hoisted_13$A = { class: "vector3-input" };
const _hoisted_14$w = { class: "input-item" };
const _hoisted_15$v = { class: "input-item" };
const _hoisted_16$u = { class: "input-item" };
const _hoisted_17$t = { class: "property-group" };
const _hoisted_18$r = { class: "vector3-input" };
const _hoisted_19$q = { class: "input-item" };
const _hoisted_20$q = { class: "input-item" };
const _hoisted_21$p = { class: "input-item" };
const _hoisted_22$n = { class: "property-group" };
const _hoisted_23$n = { class: "vector3-input" };
const _hoisted_24$h = { class: "input-item" };
const _hoisted_25$h = { class: "input-item" };
const _hoisted_26$f = { class: "input-item" };
const _hoisted_27$f = { class: "checkbox-label" };
const _hoisted_28$e = ["checked"];
const _hoisted_29$e = { class: "property-section" };
const _hoisted_30$d = { class: "section-content" };
const _hoisted_31$c = { class: "property-group" };
const _hoisted_32$c = ["value"];
const _hoisted_33$c = { class: "property-section" };
const _hoisted_34$b = { class: "section-content" };
const _hoisted_35$a = { class: "property-row" };
const _hoisted_36$9 = { class: "checkbox-label" };
const _hoisted_37$9 = ["checked"];
const _hoisted_38$9 = { class: "property-row" };
const _hoisted_39$9 = { class: "checkbox-label" };
const _hoisted_40$8 = ["checked"];
const _hoisted_41$6 = { class: "property-row" };
const _hoisted_42$5 = { class: "checkbox-label" };
const _hoisted_43$5 = ["checked"];
const _hoisted_44$5 = { class: "property-row" };
const _hoisted_45$5 = { class: "checkbox-label" };
const _hoisted_46$5 = ["checked"];
const _hoisted_47$5 = {
  key: 0,
  class: "property-section"
};
const _hoisted_48$5 = { class: "section-content" };
const _hoisted_49$5 = { class: "property-group" };
const _hoisted_50$4 = { class: "property-group" };
const _hoisted_51$4 = { class: "property-row" };
const _hoisted_52$4 = { class: "checkbox-label" };
const _hoisted_53$4 = ["checked"];
const _hoisted_54$4 = { class: "property-row" };
const _hoisted_55$4 = { class: "checkbox-label" };
const _hoisted_56$4 = ["checked"];
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "Model3DProperties",
  props: {
    layerId: {}
  },
  emits: ["open-material-editor"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const assetStore = useAssetStore();
    const sections = reactive({
      transform: true,
      material: true,
      display: false,
      pointCloud: true
    });
    const layer = computed(() => store.layers.find((l) => l.id === props.layerId));
    const layerData = computed(() => layer.value?.data);
    const isPointCloud = computed(() => layer.value?.type === "pointcloud");
    const position = computed(() => {
      const val = layer.value?.transform.position.value;
      return val ? { x: val.x || 0, y: val.y || 0, z: val.z || 0 } : { x: 0, y: 0, z: 0 };
    });
    const rotation = computed(() => {
      const val = layer.value?.transform.rotation.value;
      if (typeof val === "number") {
        return { x: 0, y: 0, z: val };
      }
      return val ? { x: val.x || 0, y: val.y || 0, z: val.z || 0 } : { x: 0, y: 0, z: 0 };
    });
    const scale = computed(() => {
      const val = layer.value?.transform.scale.value;
      return val ? { x: val.x || 100, y: val.y || 100, z: val.z || 100 } : { x: 100, y: 100, z: 100 };
    });
    const selectedMaterialId = ref("");
    const materials = computed(() => assetStore.materialList);
    const uniformScale = ref(true);
    const showWireframe = ref(false);
    const showBoundingBox = ref(false);
    const castShadows = ref(true);
    const receiveShadows = ref(true);
    const pointSize = ref(2);
    const pointColor = ref("#ffffff");
    const useVertexColors = ref(true);
    const sizeAttenuation = ref(true);
    watch(() => props.layerId, () => {
      if (layerData.value) {
        selectedMaterialId.value = layerData.value.materialId || "";
        showWireframe.value = layerData.value.wireframe || false;
        showBoundingBox.value = layerData.value.showBoundingBox || false;
        castShadows.value = layerData.value.castShadows ?? true;
        receiveShadows.value = layerData.value.receiveShadows ?? true;
        if (isPointCloud.value) {
          pointSize.value = layerData.value.pointSize || 2;
          pointColor.value = layerData.value.pointColor || "#ffffff";
          useVertexColors.value = layerData.value.useVertexColors ?? true;
          sizeAttenuation.value = layerData.value.sizeAttenuation ?? true;
        }
      }
    }, { immediate: true });
    function toggleSection(section) {
      sections[section] = !sections[section];
    }
    function updatePosition(axis, value) {
      const current = { ...position.value };
      current[axis] = value;
      store.updateLayerTransform(props.layerId, "position", current);
    }
    function updateRotation(axis, value) {
      const current = { ...rotation.value };
      current[axis] = value;
      store.updateLayerTransform(props.layerId, "rotation", current);
    }
    function updateScale(axis, value) {
      if (uniformScale.value) {
        store.updateLayerTransform(props.layerId, "scale", { x: value, y: value, z: value });
      } else {
        const current = { ...scale.value };
        current[axis] = value;
        store.updateLayerTransform(props.layerId, "scale", current);
      }
    }
    function toggleUniformScale() {
      uniformScale.value = !uniformScale.value;
    }
    function assignMaterial() {
      store.updateLayerData(props.layerId, { materialId: selectedMaterialId.value || null });
    }
    function openMaterialEditor() {
      emit("open-material-editor");
    }
    function toggleWireframe() {
      showWireframe.value = !showWireframe.value;
      store.updateLayerData(props.layerId, { wireframe: showWireframe.value });
    }
    function toggleBoundingBox() {
      showBoundingBox.value = !showBoundingBox.value;
      store.updateLayerData(props.layerId, { showBoundingBox: showBoundingBox.value });
    }
    function toggleCastShadows() {
      castShadows.value = !castShadows.value;
      store.updateLayerData(props.layerId, { castShadows: castShadows.value });
    }
    function toggleReceiveShadows() {
      receiveShadows.value = !receiveShadows.value;
      store.updateLayerData(props.layerId, { receiveShadows: receiveShadows.value });
    }
    function updatePointSize(value) {
      pointSize.value = value;
      store.updateLayerData(props.layerId, { pointSize: value });
    }
    function updatePointColor(value) {
      pointColor.value = value;
      store.updateLayerData(props.layerId, { pointColor: value });
    }
    function toggleVertexColors() {
      useVertexColors.value = !useVertexColors.value;
      store.updateLayerData(props.layerId, { useVertexColors: useVertexColors.value });
    }
    function toggleSizeAttenuation() {
      sizeAttenuation.value = !sizeAttenuation.value;
      store.updateLayerData(props.layerId, { sizeAttenuation: sizeAttenuation.value });
    }
    function formatNumber(num) {
      return num.toLocaleString();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        createBaseVNode("div", _hoisted_2$G, [
          _cache[17] || (_cache[17] = createBaseVNode("div", { class: "section-header" }, [
            createBaseVNode("span", null, "3D Model Properties")
          ], -1)),
          layerData.value ? (openBlock(), createElementBlock("div", _hoisted_3$G, [
            createBaseVNode("div", _hoisted_4$G, [
              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "label" }, "Source", -1)),
              createBaseVNode("span", _hoisted_5$G, toDisplayString(layerData.value.sourceFile || "Unknown"), 1)
            ]),
            layerData.value.vertexCount ? (openBlock(), createElementBlock("div", _hoisted_6$G, [
              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "label" }, "Vertices", -1)),
              createBaseVNode("span", _hoisted_7$G, toDisplayString(formatNumber(layerData.value.vertexCount)), 1)
            ])) : createCommentVNode("", true),
            layerData.value.faceCount ? (openBlock(), createElementBlock("div", _hoisted_8$E, [
              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "label" }, "Faces", -1)),
              createBaseVNode("span", _hoisted_9$E, toDisplayString(formatNumber(layerData.value.faceCount)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_10$D, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("transform"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["icon", sections.transform ? "expanded" : ""])
            }, "", 2),
            _cache[18] || (_cache[18] = createBaseVNode("span", null, "Transform", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_11$C, [
            createBaseVNode("div", _hoisted_12$A, [
              _cache[22] || (_cache[22] = createBaseVNode("label", null, "Position", -1)),
              createBaseVNode("div", _hoisted_13$A, [
                createBaseVNode("div", _hoisted_14$w, [
                  _cache[19] || (_cache[19] = createBaseVNode("span", { class: "axis x" }, "X", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: position.value.x,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => updatePosition("x", $event)),
                    step: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_15$v, [
                  _cache[20] || (_cache[20] = createBaseVNode("span", { class: "axis y" }, "Y", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: position.value.y,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updatePosition("y", $event)),
                    step: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_16$u, [
                  _cache[21] || (_cache[21] = createBaseVNode("span", { class: "axis z" }, "Z", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: position.value.z,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updatePosition("z", $event)),
                    step: 1
                  }, null, 8, ["modelValue"])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_17$t, [
              _cache[26] || (_cache[26] = createBaseVNode("label", null, "Rotation", -1)),
              createBaseVNode("div", _hoisted_18$r, [
                createBaseVNode("div", _hoisted_19$q, [
                  _cache[23] || (_cache[23] = createBaseVNode("span", { class: "axis x" }, "X", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: rotation.value.x,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => updateRotation("x", $event)),
                    step: 1,
                    unit: ""
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_20$q, [
                  _cache[24] || (_cache[24] = createBaseVNode("span", { class: "axis y" }, "Y", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: rotation.value.y,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateRotation("y", $event)),
                    step: 1,
                    unit: ""
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$p, [
                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "axis z" }, "Z", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: rotation.value.z,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => updateRotation("z", $event)),
                    step: 1,
                    unit: ""
                  }, null, 8, ["modelValue"])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_22$n, [
              _cache[31] || (_cache[31] = createBaseVNode("label", null, "Scale", -1)),
              createBaseVNode("div", _hoisted_23$n, [
                createBaseVNode("div", _hoisted_24$h, [
                  _cache[27] || (_cache[27] = createBaseVNode("span", { class: "axis x" }, "X", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: scale.value.x,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => updateScale("x", $event)),
                    step: 1,
                    unit: "%"
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_25$h, [
                  _cache[28] || (_cache[28] = createBaseVNode("span", { class: "axis y" }, "Y", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: scale.value.y,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => updateScale("y", $event)),
                    step: 1,
                    unit: "%"
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_26$f, [
                  _cache[29] || (_cache[29] = createBaseVNode("span", { class: "axis z" }, "Z", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: scale.value.z,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => updateScale("z", $event)),
                    step: 1,
                    unit: "%"
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("label", _hoisted_27$f, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: uniformScale.value,
                  onChange: toggleUniformScale
                }, null, 40, _hoisted_28$e),
                _cache[30] || (_cache[30] = createTextVNode(" Uniform Scale ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.transform]
          ])
        ]),
        createBaseVNode("div", _hoisted_29$e, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("material"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["icon", sections.material ? "expanded" : ""])
            }, "", 2),
            _cache[32] || (_cache[32] = createBaseVNode("span", null, "Material", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_30$d, [
            createBaseVNode("div", _hoisted_31$c, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Assigned Material", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => selectedMaterialId.value = $event),
                onChange: assignMaterial,
                class: "material-select"
              }, [
                _cache[33] || (_cache[33] = createBaseVNode("option", { value: "" }, "None (Use Model Default)", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(materials.value, (mat) => {
                  return openBlock(), createElementBlock("option", {
                    key: mat.id,
                    value: mat.id
                  }, toDisplayString(mat.name), 9, _hoisted_32$c);
                }), 128))
              ], 544), [
                [vModelSelect, selectedMaterialId.value]
              ])
            ]),
            createBaseVNode("button", {
              class: "action-btn",
              onClick: openMaterialEditor
            }, [..._cache[35] || (_cache[35] = [
              createBaseVNode("i", { class: "icon" }, "", -1),
              createTextVNode(" Open Material Editor ", -1)
            ])])
          ], 512), [
            [vShow, sections.material]
          ])
        ]),
        createBaseVNode("div", _hoisted_33$c, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[12] || (_cache[12] = ($event) => toggleSection("display"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["icon", sections.display ? "expanded" : ""])
            }, "", 2),
            _cache[36] || (_cache[36] = createBaseVNode("span", null, "Display", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_34$b, [
            createBaseVNode("div", _hoisted_35$a, [
              createBaseVNode("label", _hoisted_36$9, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: showWireframe.value,
                  onChange: toggleWireframe
                }, null, 40, _hoisted_37$9),
                _cache[37] || (_cache[37] = createTextVNode(" Show Wireframe ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_38$9, [
              createBaseVNode("label", _hoisted_39$9, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: showBoundingBox.value,
                  onChange: toggleBoundingBox
                }, null, 40, _hoisted_40$8),
                _cache[38] || (_cache[38] = createTextVNode(" Show Bounding Box ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_41$6, [
              createBaseVNode("label", _hoisted_42$5, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: castShadows.value,
                  onChange: toggleCastShadows
                }, null, 40, _hoisted_43$5),
                _cache[39] || (_cache[39] = createTextVNode(" Cast Shadows ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_44$5, [
              createBaseVNode("label", _hoisted_45$5, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: receiveShadows.value,
                  onChange: toggleReceiveShadows
                }, null, 40, _hoisted_46$5),
                _cache[40] || (_cache[40] = createTextVNode(" Receive Shadows ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.display]
          ])
        ]),
        isPointCloud.value ? (openBlock(), createElementBlock("div", _hoisted_47$5, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("pointCloud"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["icon", sections.pointCloud ? "expanded" : ""])
            }, "", 2),
            _cache[41] || (_cache[41] = createBaseVNode("span", null, "Point Cloud", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_48$5, [
            createBaseVNode("div", _hoisted_49$5, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Point Size", -1)),
              createVNode(unref(SliderInput), {
                modelValue: pointSize.value,
                "onUpdate:modelValue": updatePointSize,
                min: 0.1,
                max: 20,
                step: 0.1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_50$4, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Point Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: pointColor.value,
                "onUpdate:modelValue": updatePointColor
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_51$4, [
              createBaseVNode("label", _hoisted_52$4, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: useVertexColors.value,
                  onChange: toggleVertexColors
                }, null, 40, _hoisted_53$4),
                _cache[44] || (_cache[44] = createTextVNode(" Use Vertex Colors ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_54$4, [
              createBaseVNode("label", _hoisted_55$4, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: sizeAttenuation.value,
                  onChange: toggleSizeAttenuation
                }, null, 40, _hoisted_56$4),
                _cache[45] || (_cache[45] = createTextVNode(" Size Attenuation ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.pointCloud]
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const Model3DProperties = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__scopeId", "data-v-d0878f07"]]);

const _hoisted_1$F = { class: "audio-properties" };
const _hoisted_2$F = { class: "property-section" };
const _hoisted_3$F = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$F = { class: "property-row" };
const _hoisted_5$F = { class: "value-display" };
const _hoisted_6$F = { class: "property-row" };
const _hoisted_7$F = { class: "value-display" };
const _hoisted_8$D = { class: "property-row" };
const _hoisted_9$D = { class: "value-display" };
const _hoisted_10$C = { class: "property-row" };
const _hoisted_11$B = {
  key: 0,
  class: "peak-count"
};
const _hoisted_12$z = { class: "property-section" };
const _hoisted_13$z = { class: "mapping-count" };
const _hoisted_14$v = {
  key: 0,
  class: "section-content"
};
const _hoisted_15$u = { class: "mapping-header" };
const _hoisted_16$t = { class: "mapping-enabled" };
const _hoisted_17$s = ["onUpdate:modelValue"];
const _hoisted_18$q = { class: "mapping-name" };
const _hoisted_19$p = ["onClick"];
const _hoisted_20$p = {
  key: 0,
  class: "mapping-details"
};
const _hoisted_21$o = { class: "property-row" };
const _hoisted_22$m = ["onUpdate:modelValue"];
const _hoisted_23$m = ["label"];
const _hoisted_24$g = ["value"];
const _hoisted_25$g = { class: "property-row" };
const _hoisted_26$e = ["onUpdate:modelValue"];
const _hoisted_27$e = ["label"];
const _hoisted_28$d = ["value"];
const _hoisted_29$d = { class: "property-row" };
const _hoisted_30$c = ["onUpdate:modelValue"];
const _hoisted_31$b = { class: "value-display" };
const _hoisted_32$b = { class: "property-row" };
const _hoisted_33$b = ["onUpdate:modelValue"];
const _hoisted_34$a = { class: "value-display" };
const _hoisted_35$9 = { class: "property-row" };
const _hoisted_36$8 = ["onUpdate:modelValue"];
const _hoisted_37$8 = { class: "value-display" };
const _hoisted_38$8 = { class: "property-row" };
const _hoisted_39$8 = ["onUpdate:modelValue"];
const _hoisted_40$7 = ["onUpdate:modelValue"];
const _hoisted_41$5 = { class: "property-row" };
const _hoisted_42$4 = ["onUpdate:modelValue"];
const _hoisted_43$4 = { class: "value-display" };
const _hoisted_44$4 = { class: "property-row" };
const _hoisted_45$4 = ["onUpdate:modelValue"];
const _hoisted_46$4 = { class: "value-display" };
const _hoisted_47$4 = { class: "property-row" };
const _hoisted_48$4 = ["onUpdate:modelValue"];
const _hoisted_49$4 = { class: "property-row" };
const _hoisted_50$3 = ["onUpdate:modelValue"];
const _hoisted_51$3 = {
  key: 0,
  class: "property-row"
};
const _hoisted_52$3 = ["onUpdate:modelValue"];
const _hoisted_53$3 = { class: "value-display" };
const _hoisted_54$3 = { class: "property-row checkbox-row" };
const _hoisted_55$3 = ["onUpdate:modelValue"];
const _hoisted_56$3 = ["onClick"];
const _hoisted_57$3 = { class: "property-section" };
const _hoisted_58$3 = {
  key: 0,
  class: "section-content"
};
const _hoisted_59$3 = { class: "property-row" };
const _hoisted_60$2 = ["value"];
const _hoisted_61$2 = { class: "visualizer-canvas-container" };
const _hoisted_62$2 = { class: "visualizer-value" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "AudioProperties",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(/* @__PURE__ */ new Set(["peaks", "mappings"]));
    const expandedMappings = ref(/* @__PURE__ */ new Set());
    const peakConfig = ref({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    });
    const peakData = ref(null);
    const mappings = ref([]);
    const visualizerFeature = ref("amplitude");
    const visualizerCanvas = ref(null);
    const allFeatures = computed(() => getAllFeatures());
    const featuresByCategory = computed(() => getFeaturesByCategory());
    const targetsByCategory = computed(() => getTargetsByCategory());
    const playheadPosition = computed(
      () => store.currentFrame / store.frameCount * 100
    );
    const currentFeatureValue = computed(() => {
      if (!store.audioAnalysis) return 0;
      return getFeatureAtFrame(store.audioAnalysis, visualizerFeature.value, store.currentFrame);
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleMappingExpanded(id) {
      if (expandedMappings.value.has(id)) {
        expandedMappings.value.delete(id);
      } else {
        expandedMappings.value.add(id);
      }
    }
    function detectPeaks$1() {
      if (!store.audioAnalysis) return;
      const weights = store.audioAnalysis.amplitudeEnvelope;
      peakData.value = detectPeaks(weights, peakConfig.value);
      store.setPeakData(peakData.value);
    }
    function addMapping() {
      const mapping = createDefaultAudioMapping();
      mappings.value.push(mapping);
      expandedMappings.value.add(mapping.id);
      store.addAudioMapping(mapping);
    }
    function removeMapping(id) {
      const index = mappings.value.findIndex((m) => m.id === id);
      if (index >= 0) {
        mappings.value.splice(index, 1);
        expandedMappings.value.delete(id);
        store.removeAudioMapping(id);
      }
    }
    function drawVisualizer() {
      const canvas = visualizerCanvas.value;
      if (!canvas || !store.audioAnalysis) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, width, height);
      let featureData = [];
      const analysis = store.audioAnalysis;
      switch (visualizerFeature.value) {
        case "amplitude":
          featureData = analysis.amplitudeEnvelope;
          break;
        case "rms":
          featureData = analysis.rmsEnergy;
          break;
        case "spectralCentroid":
          featureData = analysis.spectralCentroid;
          break;
        case "bass":
          featureData = analysis.frequencyBands.bass;
          break;
        case "mid":
          featureData = analysis.frequencyBands.mid;
          break;
        case "high":
          featureData = analysis.frequencyBands.high;
          break;
        case "sub":
          featureData = analysis.frequencyBands.sub;
          break;
        case "lowMid":
          featureData = analysis.frequencyBands.lowMid;
          break;
        case "highMid":
          featureData = analysis.frequencyBands.highMid;
          break;
        case "spectralFlux":
          featureData = analysis.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          featureData = analysis.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          featureData = analysis.spectralRolloff || [];
          break;
        case "spectralFlatness":
          featureData = analysis.spectralFlatness || [];
          break;
        case "chromaEnergy":
          featureData = analysis.chromaFeatures?.chromaEnergy || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if (analysis.chromaFeatures?.chroma) {
            const pitchIndex = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(visualizerFeature.value);
            featureData = analysis.chromaFeatures.chroma.map((frame) => frame[pitchIndex] || 0);
          }
          break;
        case "onsets":
          featureData = new Array(analysis.frameCount).fill(0);
          for (const onset of analysis.onsets) {
            if (onset < featureData.length) featureData[onset] = 1;
          }
          break;
        case "peaks":
          if (peakData.value) {
            featureData = new Array(analysis.frameCount).fill(0);
            for (const peakIndex of peakData.value.indices) {
              if (peakIndex < featureData.length) featureData[peakIndex] = 1;
            }
          }
          break;
      }
      if (featureData.length === 0) return;
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < featureData.length; i++) {
        const x = i / featureData.length * width;
        const y = height - featureData[i] * height * 0.9 - 5;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      if (peakData.value && visualizerFeature.value !== "peaks") {
        ctx.fillStyle = "#ff6b6b";
        for (const peakIndex of peakData.value.indices) {
          const x = peakIndex / featureData.length * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.strokeStyle = "rgba(255, 107, 107, 0.3)";
          ctx.stroke();
        }
      }
    }
    watch(
      () => [store.audioAnalysis, visualizerFeature.value, peakData.value],
      () => {
        drawVisualizer();
      }
    );
    watch(
      mappings,
      (newMappings) => {
        for (const mapping of newMappings) {
          store.updateAudioMapping(mapping.id, mapping);
        }
      },
      { deep: true }
    );
    onMounted(() => {
      drawVisualizer();
      const existingMappings = store.getAudioMappings();
      if (existingMappings.length > 0) {
        mappings.value = [...existingMappings];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createBaseVNode("div", _hoisted_2$F, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("peaks"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[7] || (_cache[7] = createBaseVNode("span", null, "Peak Detection", -1))
          ]),
          expandedSections.value.has("peaks") ? (openBlock(), createElementBlock("div", _hoisted_3$F, [
            createBaseVNode("div", _hoisted_4$F, [
              _cache[8] || (_cache[8] = createBaseVNode("label", null, "Threshold", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => peakConfig.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.01"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.threshold,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_5$F, toDisplayString(peakConfig.value.threshold.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_6$F, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Min Peak Distance", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => peakConfig.value.minPeaksDistance = $event),
                min: "1",
                max: "60",
                step: "1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.minPeaksDistance,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_7$F, toDisplayString(peakConfig.value.minPeaksDistance) + " frames", 1)
            ]),
            createBaseVNode("div", _hoisted_8$D, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Multiply", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => peakConfig.value.multiply = $event),
                min: "0.1",
                max: "5",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.multiply,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$D, toDisplayString(peakConfig.value.multiply.toFixed(1)) + "x", 1)
            ]),
            createBaseVNode("div", _hoisted_10$C, [
              createBaseVNode("button", {
                class: "action-btn",
                onClick: detectPeaks$1
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("i", { class: "pi pi-bolt" }, null, -1),
                createTextVNode(" Detect Peaks ", -1)
              ])]),
              peakData.value ? (openBlock(), createElementBlock("span", _hoisted_11$B, toDisplayString(peakData.value.count) + " peaks found ", 1)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_12$z, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[4] || (_cache[4] = ($event) => toggleSection("mappings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[12] || (_cache[12] = createBaseVNode("span", null, "Audio Mappings", -1)),
            createBaseVNode("span", _hoisted_13$z, toDisplayString(mappings.value.length), 1)
          ]),
          expandedSections.value.has("mappings") ? (openBlock(), createElementBlock("div", _hoisted_14$v, [
            createBaseVNode("button", {
              class: "action-btn add-mapping-btn",
              onClick: addMapping
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
              createTextVNode(" Add Mapping ", -1)
            ])]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(mappings.value, (mapping) => {
              return openBlock(), createElementBlock("div", {
                key: mapping.id,
                class: "mapping-item"
              }, [
                createBaseVNode("div", _hoisted_15$u, [
                  createBaseVNode("label", _hoisted_16$t, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ($event) => mapping.enabled = $event
                    }, null, 8, _hoisted_17$s), [
                      [vModelCheckbox, mapping.enabled]
                    ])
                  ]),
                  createBaseVNode("span", _hoisted_18$q, toDisplayString(unref(getFeatureDisplayName)(mapping.feature)) + "  " + toDisplayString(unref(getTargetDisplayName)(mapping.target)), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: ($event) => removeMapping(mapping.id)
                  }, [..._cache[14] || (_cache[14] = [
                    createBaseVNode("i", { class: "pi pi-times" }, null, -1)
                  ])], 8, _hoisted_19$p)
                ]),
                expandedMappings.value.has(mapping.id) ? (openBlock(), createElementBlock("div", _hoisted_20$p, [
                  createBaseVNode("div", _hoisted_21$o, [
                    _cache[15] || (_cache[15] = createBaseVNode("label", null, "Feature", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.feature = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(featuresByCategory.value, (feats, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(feats, (feat) => {
                            return openBlock(), createElementBlock("option", {
                              key: feat,
                              value: feat
                            }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_24$g);
                          }), 128))
                        ], 8, _hoisted_23$m);
                      }), 128))
                    ], 8, _hoisted_22$m), [
                      [vModelSelect, mapping.feature]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_25$g, [
                    _cache[16] || (_cache[16] = createBaseVNode("label", null, "Target", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.target = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targetsByCategory.value, (targets, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                            return openBlock(), createElementBlock("option", {
                              key: target,
                              value: target
                            }, toDisplayString(unref(getTargetDisplayName)(target)), 9, _hoisted_28$d);
                          }), 128))
                        ], 8, _hoisted_27$e);
                      }), 128))
                    ], 8, _hoisted_26$e), [
                      [vModelSelect, mapping.target]
                    ])
                  ]),
                  _cache[30] || (_cache[30] = createBaseVNode("div", { class: "subsection-header" }, "Basic Controls", -1)),
                  createBaseVNode("div", _hoisted_29$d, [
                    _cache[17] || (_cache[17] = createBaseVNode("label", null, "Sensitivity", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.sensitivity = $event,
                      min: "0.1",
                      max: "5",
                      step: "0.1"
                    }, null, 8, _hoisted_30$c), [
                      [
                        vModelText,
                        mapping.sensitivity,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_31$b, toDisplayString(mapping.sensitivity.toFixed(1)) + "x", 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$b, [
                    _cache[18] || (_cache[18] = createBaseVNode("label", null, "Threshold", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.threshold = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_33$b), [
                      [
                        vModelText,
                        mapping.threshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_34$a, toDisplayString(mapping.threshold.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$9, [
                    _cache[19] || (_cache[19] = createBaseVNode("label", null, "Smoothing", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.smoothing = $event,
                      min: "0",
                      max: "0.99",
                      step: "0.01"
                    }, null, 8, _hoisted_36$8), [
                      [
                        vModelText,
                        mapping.smoothing,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_37$8, toDisplayString(mapping.smoothing.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$8, [
                    _cache[20] || (_cache[20] = createBaseVNode("label", null, "Min/Max", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.min = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_39$8), [
                      [
                        vModelText,
                        mapping.min,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "separator" }, "-", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.max = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_40$7), [
                      [
                        vModelText,
                        mapping.max,
                        void 0,
                        { number: true }
                      ]
                    ])
                  ]),
                  _cache[31] || (_cache[31] = createBaseVNode("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                  createBaseVNode("div", _hoisted_41$5, [
                    _cache[22] || (_cache[22] = createBaseVNode("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.amplitudeCurve = $event,
                      min: "0.1",
                      max: "4",
                      step: "0.1"
                    }, null, 8, _hoisted_42$4), [
                      [
                        vModelText,
                        mapping.amplitudeCurve,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_43$4, toDisplayString(mapping.amplitudeCurve?.toFixed(1) || "1.0"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$4, [
                    _cache[23] || (_cache[23] = createBaseVNode("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.release = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_45$4), [
                      [
                        vModelText,
                        mapping.release,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_46$4, toDisplayString(mapping.release?.toFixed(2) || "0.50"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$4, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", null, "Curve", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.curve = $event,
                      class: "curve-select"
                    }, [..._cache[24] || (_cache[24] = [
                      createStaticVNode('<option value="linear" data-v-9de93668>Linear</option><option value="exponential" data-v-9de93668>Exponential</option><option value="logarithmic" data-v-9de93668>Logarithmic</option><option value="smoothstep" data-v-9de93668>Smoothstep</option><option value="bounce" data-v-9de93668>Bounce</option>', 5)
                    ])], 8, _hoisted_48$4), [
                      [vModelSelect, mapping.curve]
                    ])
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("div", { class: "subsection-header" }, "Beat Response", -1)),
                  createBaseVNode("div", _hoisted_49$4, [
                    _cache[27] || (_cache[27] = createBaseVNode("label", null, "On Beat", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.beatResponse = $event,
                      class: "beat-select"
                    }, [..._cache[26] || (_cache[26] = [
                      createBaseVNode("option", { value: "none" }, "None", -1),
                      createBaseVNode("option", { value: "flip" }, "Flip (reverse direction)", -1),
                      createBaseVNode("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                      createBaseVNode("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                    ])], 8, _hoisted_50$3), [
                      [vModelSelect, mapping.beatResponse]
                    ])
                  ]),
                  mapping.beatResponse !== "none" ? (openBlock(), createElementBlock("div", _hoisted_51$3, [
                    _cache[28] || (_cache[28] = createBaseVNode("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.beatThreshold = $event,
                      min: "0.01",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_52$3), [
                      [
                        vModelText,
                        mapping.beatThreshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_53$3, toDisplayString(mapping.beatThreshold?.toFixed(2) || "0.50"), 1)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_54$3, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": ($event) => mapping.invert = $event
                      }, null, 8, _hoisted_55$3), [
                        [vModelCheckbox, mapping.invert]
                      ]),
                      _cache[29] || (_cache[29] = createTextVNode(" Invert Output ", -1))
                    ])
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  class: "expand-btn",
                  onClick: ($event) => toggleMappingExpanded(mapping.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedMappings.value.has(mapping.id) ? "pi-chevron-up" : "pi-chevron-down"])
                  }, null, 2)
                ], 8, _hoisted_56$3)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_57$3, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("visualizer"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Feature Visualizer", -1))
          ]),
          expandedSections.value.has("visualizer") ? (openBlock(), createElementBlock("div", _hoisted_58$3, [
            createBaseVNode("div", _hoisted_59$3, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Feature", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => visualizerFeature.value = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allFeatures.value, (feat) => {
                  return openBlock(), createElementBlock("option", {
                    key: feat,
                    value: feat
                  }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_60$2);
                }), 128))
              ], 512), [
                [vModelSelect, visualizerFeature.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_61$2, [
              createBaseVNode("canvas", {
                ref_key: "visualizerCanvas",
                ref: visualizerCanvas,
                class: "visualizer-canvas",
                width: "240",
                height: "60"
              }, null, 512),
              createBaseVNode("div", {
                class: "visualizer-playhead",
                style: normalizeStyle({ left: `${playheadPosition.value}%` })
              }, null, 4)
            ]),
            createBaseVNode("div", _hoisted_62$2, " Current: " + toDisplayString(currentFeatureValue.value.toFixed(3)), 1)
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AudioProperties = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-9de93668"]]);

const _hoisted_1$E = { class: "depth-properties" };
const _hoisted_2$E = { class: "prop-section" };
const _hoisted_3$E = { class: "row" };
const _hoisted_4$E = ["value"];
const _hoisted_5$E = {
  key: 0,
  class: "row"
};
const _hoisted_6$E = ["value"];
const _hoisted_7$E = { class: "row checkbox-row" };
const _hoisted_8$C = ["checked"];
const _hoisted_9$C = { class: "prop-section" };
const _hoisted_10$B = { class: "row checkbox-row" };
const _hoisted_11$A = ["checked"];
const _hoisted_12$y = { class: "row" };
const _hoisted_13$y = { class: "row" };
const _hoisted_14$u = {
  key: 0,
  class: "prop-section"
};
const _hoisted_15$t = { class: "row" };
const _hoisted_16$s = { class: "row" };
const _hoisted_17$r = { class: "row color-row" };
const _hoisted_18$p = ["value"];
const _hoisted_19$o = {
  key: 1,
  class: "prop-section"
};
const _hoisted_20$o = { class: "row" };
const _hoisted_21$n = { class: "row" };
const _hoisted_22$l = { class: "row checkbox-row" };
const _hoisted_23$l = ["checked"];
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "DepthProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const depthData = computed(() => props.layer.data);
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    function getAnimatableValue(prop) {
      return prop?.value ?? 0;
    }
    function isAnimated(propName) {
      const prop = depthData.value[propName];
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value) {
      const prop = depthData.value[propName];
      if (prop) {
        emit("update", {
          [propName]: { ...prop, value }
        });
      }
    }
    function toggleKeyframe(propName) {
      const prop = depthData.value[propName];
      if (prop) {
        store.addKeyframe(props.layer.id, `data.${propName}`, store.currentFrame, prop.value);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createBaseVNode("div", _hoisted_2$E, [
          _cache[18] || (_cache[18] = createBaseVNode("div", { class: "section-title" }, "Visualization", -1)),
          createBaseVNode("div", _hoisted_3$E, [
            _cache[14] || (_cache[14] = createBaseVNode("label", null, "Mode", -1)),
            createBaseVNode("select", {
              value: depthData.value.visualizationMode,
              onChange: _cache[0] || (_cache[0] = ($event) => updateData("visualizationMode", $event.target.value))
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1),
              createBaseVNode("option", { value: "colormap" }, "Colormap", -1),
              createBaseVNode("option", { value: "contour" }, "Contour Lines", -1),
              createBaseVNode("option", { value: "3d-mesh" }, "3D Mesh Preview", -1)
            ])], 40, _hoisted_4$E)
          ]),
          depthData.value.visualizationMode === "colormap" || depthData.value.visualizationMode === "contour" ? (openBlock(), createElementBlock("div", _hoisted_5$E, [
            _cache[16] || (_cache[16] = createBaseVNode("label", null, "Color Map", -1)),
            createBaseVNode("select", {
              value: depthData.value.colorMap,
              onChange: _cache[1] || (_cache[1] = ($event) => updateData("colorMap", $event.target.value))
            }, [..._cache[15] || (_cache[15] = [
              createStaticVNode('<option value="turbo" data-v-6bec3775>Turbo (Rainbow)</option><option value="viridis" data-v-6bec3775>Viridis (Blue-Green-Yellow)</option><option value="plasma" data-v-6bec3775>Plasma (Purple-Orange)</option><option value="inferno" data-v-6bec3775>Inferno (Black-Red-Yellow)</option><option value="magma" data-v-6bec3775>Magma (Black-Purple-White)</option><option value="grayscale" data-v-6bec3775>Grayscale</option>', 6)
            ])], 40, _hoisted_6$E)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_7$E, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: depthData.value.invert,
                onChange: _cache[2] || (_cache[2] = ($event) => updateData("invert", !depthData.value.invert))
              }, null, 40, _hoisted_8$C),
              _cache[17] || (_cache[17] = createTextVNode(" Invert Depth ", -1))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$C, [
          _cache[22] || (_cache[22] = createBaseVNode("div", { class: "section-title" }, "Depth Range", -1)),
          createBaseVNode("div", _hoisted_10$B, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: depthData.value.autoNormalize,
                onChange: _cache[3] || (_cache[3] = ($event) => updateData("autoNormalize", !depthData.value.autoNormalize))
              }, null, 40, _hoisted_11$A),
              _cache[19] || (_cache[19] = createTextVNode(" Auto Normalize ", -1))
            ])
          ]),
          !depthData.value.autoNormalize ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_12$y, [
              _cache[20] || (_cache[20] = createBaseVNode("label", null, "Min Depth", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: depthData.value.minDepth,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateData("minDepth", v)),
                min: 0,
                max: 1,
                precision: 3
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_13$y, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Max Depth", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: depthData.value.maxDepth,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateData("maxDepth", v)),
                min: 0,
                max: 1,
                precision: 3
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : createCommentVNode("", true)
        ]),
        depthData.value.visualizationMode === "contour" ? (openBlock(), createElementBlock("div", _hoisted_14$u, [
          _cache[26] || (_cache[26] = createBaseVNode("div", { class: "section-title" }, "Contour Settings", -1)),
          createBaseVNode("div", _hoisted_15$t, [
            _cache[23] || (_cache[23] = createBaseVNode("label", null, "Levels", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: depthData.value.contourLevels,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updateData("contourLevels", v)),
              min: 2,
              max: 50,
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_16$s, [
            _cache[24] || (_cache[24] = createBaseVNode("label", null, "Line Width", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: depthData.value.contourWidth,
              "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => updateData("contourWidth", v)),
              min: 0.1,
              max: 5,
              precision: 1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_17$r, [
            _cache[25] || (_cache[25] = createBaseVNode("label", null, "Line Color", -1)),
            createBaseVNode("input", {
              type: "color",
              value: depthData.value.contourColor,
              onInput: _cache[8] || (_cache[8] = ($event) => updateData("contourColor", $event.target.value))
            }, null, 40, _hoisted_18$p)
          ])
        ])) : createCommentVNode("", true),
        depthData.value.visualizationMode === "3d-mesh" ? (openBlock(), createElementBlock("div", _hoisted_19$o, [
          _cache[30] || (_cache[30] = createBaseVNode("div", { class: "section-title" }, "3D Mesh Settings", -1)),
          createBaseVNode("div", _hoisted_20$o, [
            _cache[27] || (_cache[27] = createBaseVNode("label", null, "Displacement", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getAnimatableValue(depthData.value.meshDisplacement),
              "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateAnimatable("meshDisplacement", v)),
              min: 0,
              max: 500,
              precision: 1
            }, null, 8, ["modelValue"]),
            createBaseVNode("button", {
              class: normalizeClass(["keyframe-btn", { active: isAnimated("meshDisplacement") }]),
              onClick: _cache[10] || (_cache[10] = ($event) => toggleKeyframe("meshDisplacement")),
              title: "Add keyframe"
            }, "", 2)
          ]),
          createBaseVNode("div", _hoisted_21$n, [
            _cache[28] || (_cache[28] = createBaseVNode("label", null, "Resolution", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: depthData.value.meshResolution,
              "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateData("meshResolution", v)),
              min: 8,
              max: 256,
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_22$l, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: depthData.value.wireframe,
                onChange: _cache[12] || (_cache[12] = ($event) => updateData("wireframe", !depthData.value.wireframe))
              }, null, 40, _hoisted_23$l),
              _cache[29] || (_cache[29] = createTextVNode(" Wireframe ", -1))
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const DepthProperties = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__scopeId", "data-v-6bec3775"]]);

const _hoisted_1$D = { class: "normal-properties" };
const _hoisted_2$D = { class: "prop-section" };
const _hoisted_3$D = { class: "row" };
const _hoisted_4$D = ["value"];
const _hoisted_5$D = { class: "row" };
const _hoisted_6$D = ["value"];
const _hoisted_7$D = { class: "prop-section" };
const _hoisted_8$B = { class: "row flip-toggles" };
const _hoisted_9$B = ["checked"];
const _hoisted_10$A = ["checked"];
const _hoisted_11$z = ["checked"];
const _hoisted_12$x = {
  key: 0,
  class: "prop-section"
};
const _hoisted_13$x = { class: "row" };
const _hoisted_14$t = { class: "row" };
const _hoisted_15$s = { class: "row color-row" };
const _hoisted_16$r = ["value"];
const _hoisted_17$q = {
  key: 1,
  class: "prop-section"
};
const _hoisted_18$o = { class: "row" };
const _hoisted_19$n = { class: "row" };
const _hoisted_20$n = { class: "row" };
const _hoisted_21$m = { class: "row" };
const _hoisted_22$k = { class: "row" };
const _hoisted_23$k = { class: "light-preview" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "NormalProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const normalData = computed(() => props.layer.data);
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    function updateLightDirection(axis, value) {
      emit("update", {
        lightDirection: {
          ...normalData.value.lightDirection,
          [axis]: value
        }
      });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        createBaseVNode("div", _hoisted_2$D, [
          _cache[17] || (_cache[17] = createBaseVNode("div", { class: "section-title" }, "Visualization", -1)),
          createBaseVNode("div", _hoisted_3$D, [
            _cache[14] || (_cache[14] = createBaseVNode("label", null, "Mode", -1)),
            createBaseVNode("select", {
              value: normalData.value.visualizationMode,
              onChange: _cache[0] || (_cache[0] = ($event) => updateData("visualizationMode", $event.target.value))
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "rgb" }, "RGB (Raw Normals)", -1),
              createBaseVNode("option", { value: "hemisphere" }, "Hemisphere", -1),
              createBaseVNode("option", { value: "arrows" }, "Normal Arrows", -1),
              createBaseVNode("option", { value: "lit" }, "Lit Preview", -1)
            ])], 40, _hoisted_4$D)
          ]),
          createBaseVNode("div", _hoisted_5$D, [
            _cache[16] || (_cache[16] = createBaseVNode("label", null, "Format", -1)),
            createBaseVNode("select", {
              value: normalData.value.format,
              onChange: _cache[1] || (_cache[1] = ($event) => updateData("format", $event.target.value))
            }, [..._cache[15] || (_cache[15] = [
              createBaseVNode("option", { value: "opengl" }, "OpenGL (Y-up)", -1),
              createBaseVNode("option", { value: "directx" }, "DirectX (Y-down)", -1)
            ])], 40, _hoisted_6$D)
          ])
        ]),
        createBaseVNode("div", _hoisted_7$D, [
          _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-title" }, "Axis Adjustment", -1)),
          createBaseVNode("div", _hoisted_8$B, [
            createBaseVNode("label", {
              class: normalizeClass(["flip-toggle", { active: normalData.value.flipX }])
            }, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: normalData.value.flipX,
                onChange: _cache[2] || (_cache[2] = ($event) => updateData("flipX", !normalData.value.flipX))
              }, null, 40, _hoisted_9$B),
              _cache[18] || (_cache[18] = createTextVNode(" Flip X ", -1))
            ], 2),
            createBaseVNode("label", {
              class: normalizeClass(["flip-toggle", { active: normalData.value.flipY }])
            }, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: normalData.value.flipY,
                onChange: _cache[3] || (_cache[3] = ($event) => updateData("flipY", !normalData.value.flipY))
              }, null, 40, _hoisted_10$A),
              _cache[19] || (_cache[19] = createTextVNode(" Flip Y ", -1))
            ], 2),
            createBaseVNode("label", {
              class: normalizeClass(["flip-toggle", { active: normalData.value.flipZ }])
            }, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: normalData.value.flipZ,
                onChange: _cache[4] || (_cache[4] = ($event) => updateData("flipZ", !normalData.value.flipZ))
              }, null, 40, _hoisted_11$z),
              _cache[20] || (_cache[20] = createTextVNode(" Flip Z ", -1))
            ], 2)
          ])
        ]),
        normalData.value.visualizationMode === "arrows" ? (openBlock(), createElementBlock("div", _hoisted_12$x, [
          _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-title" }, "Arrow Display", -1)),
          createBaseVNode("div", _hoisted_13$x, [
            _cache[22] || (_cache[22] = createBaseVNode("label", null, "Density", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.arrowDensity,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateData("arrowDensity", v)),
              min: 4,
              max: 64,
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_14$t, [
            _cache[23] || (_cache[23] = createBaseVNode("label", null, "Scale", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.arrowScale,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updateData("arrowScale", v)),
              min: 0.1,
              max: 5,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_15$s, [
            _cache[24] || (_cache[24] = createBaseVNode("label", null, "Color", -1)),
            createBaseVNode("input", {
              type: "color",
              value: normalData.value.arrowColor,
              onInput: _cache[7] || (_cache[7] = ($event) => updateData("arrowColor", $event.target.value))
            }, null, 40, _hoisted_16$r)
          ])
        ])) : createCommentVNode("", true),
        normalData.value.visualizationMode === "lit" ? (openBlock(), createElementBlock("div", _hoisted_17$q, [
          _cache[31] || (_cache[31] = createBaseVNode("div", { class: "section-title" }, "Lighting", -1)),
          createBaseVNode("div", _hoisted_18$o, [
            _cache[26] || (_cache[26] = createBaseVNode("label", null, "Light X", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.lightDirection.x,
              "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateLightDirection("x", v)),
              min: -1,
              max: 1,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_19$n, [
            _cache[27] || (_cache[27] = createBaseVNode("label", null, "Light Y", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.lightDirection.y,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateLightDirection("y", v)),
              min: -1,
              max: 1,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_20$n, [
            _cache[28] || (_cache[28] = createBaseVNode("label", null, "Light Z", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.lightDirection.z,
              "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateLightDirection("z", v)),
              min: -1,
              max: 1,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_21$m, [
            _cache[29] || (_cache[29] = createBaseVNode("label", null, "Intensity", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.lightIntensity,
              "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateData("lightIntensity", v)),
              min: 0,
              max: 3,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_22$k, [
            _cache[30] || (_cache[30] = createBaseVNode("label", null, "Ambient", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: normalData.value.ambientIntensity,
              "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateData("ambientIntensity", v)),
              min: 0,
              max: 1,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_23$k, [
            createBaseVNode("div", {
              class: "light-indicator",
              style: normalizeStyle({
                left: `${(normalData.value.lightDirection.x + 1) * 50}%`,
                top: `${(1 - normalData.value.lightDirection.y) * 50}%`,
                opacity: Math.max(0.3, normalData.value.lightDirection.z)
              })
            }, null, 4)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const NormalProperties = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__scopeId", "data-v-dc1523f3"]]);

const TYPE_TO_CATEGORY = {
  depth: ["depth"],
  normal: ["normal"],
  edge: ["edge", "lineart", "scribble"],
  segment: ["segmentation"],
  pose: ["pose", "video"],
  // Include video pose preprocessors
  video: ["video", "normal"],
  // Video includes NormalCrafter
  custom: ["depth", "normal", "pose", "edge", "lineart", "scribble", "segmentation", "video", "other"]
};
const DEFAULT_PREPROCESSORS = {
  depth: "depth_anything_v2",
  normal: "normal_bae",
  edge: "canny",
  segment: "oneformer_ade20k",
  pose: "dwpose",
  video: "normalcrafter",
  custom: "depth_anything_v2"
};
const PREPROCESSOR_REGISTRY = {
  // DEPTH
  depth_anything_v2: {
    id: "depth_anything_v2",
    display_name: "Depth Anything V2",
    description: "State-of-the-art monocular depth estimation",
    category: "depth",
    inputs: {
      ckpt_name: { type: "combo", options: ["depth_anything_v2_vitl.pth", "depth_anything_v2_vitb.pth", "depth_anything_v2_vits.pth"], default: "depth_anything_v2_vitl.pth" },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  midas: {
    id: "midas",
    display_name: "MiDaS Depth",
    description: "MiDaS depth estimation with multiple model options",
    category: "depth",
    inputs: {
      a: { type: "float", default: 6.28, min: 0, max: 20 },
      bg_threshold: { type: "float", default: 0.1, min: 0, max: 1, step: 0.01 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  zoe_depth: {
    id: "zoe_depth",
    display_name: "ZoeDepth",
    description: "Zero-shot depth estimation",
    category: "depth",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  leres: {
    id: "leres",
    display_name: "LeReS Depth",
    description: "Learning to Recover 3D Scene Shape from a Single Image",
    category: "depth",
    inputs: {
      rm_nearest: { type: "float", default: 0, min: 0, max: 1, step: 0.01 },
      rm_background: { type: "float", default: 0, min: 0, max: 1, step: 0.01 },
      boost: { type: "bool", default: false },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  marigold: {
    id: "marigold",
    display_name: "Marigold Depth",
    description: "Diffusion-based depth estimation",
    category: "depth",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  depth_fm: {
    id: "depth_fm",
    display_name: "DepthFM",
    description: "Fast Monocular Depth Estimation with Flow Matching",
    category: "depth",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // NORMAL
  normal_bae: {
    id: "normal_bae",
    display_name: "Normal BAE",
    description: "Boundary-Aware Normal estimation",
    category: "normal",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  normal_dsine: {
    id: "normal_dsine",
    display_name: "DSINE Normal",
    description: "Rethinking Inductive Biases for Surface Normal Estimation",
    category: "normal",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // POSE
  dwpose: {
    id: "dwpose",
    display_name: "DWPose",
    description: "Effective Whole-body Pose Estimation (best quality)",
    category: "pose",
    inputs: {
      detect_hand: { type: "bool", default: true },
      detect_body: { type: "bool", default: true },
      detect_face: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  openpose: {
    id: "openpose",
    display_name: "OpenPose",
    description: "Classic pose estimation",
    category: "pose",
    inputs: {
      detect_hand: { type: "bool", default: false },
      detect_body: { type: "bool", default: true },
      detect_face: { type: "bool", default: false },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  animal_pose: {
    id: "animal_pose",
    display_name: "Animal Pose",
    description: "Pose estimation for animals",
    category: "pose",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  mediapipe_face: {
    id: "mediapipe_face",
    display_name: "MediaPipe Face",
    description: "Face mesh detection using MediaPipe",
    category: "pose",
    inputs: {
      max_faces: { type: "int", default: 10, min: 1, max: 20 },
      min_confidence: { type: "float", default: 0.5, min: 0, max: 1, step: 0.01 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  densepose: {
    id: "densepose",
    display_name: "DensePose",
    description: "Dense human pose estimation",
    category: "pose",
    inputs: {
      cmap: { type: "combo", options: ["viridis", "parula"], default: "viridis" },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // EDGE DETECTION
  canny: {
    id: "canny",
    display_name: "Canny Edge",
    description: "Classic Canny edge detection",
    category: "edge",
    inputs: {
      low_threshold: { type: "int", default: 100, min: 0, max: 255 },
      high_threshold: { type: "int", default: 200, min: 0, max: 255 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  hed: {
    id: "hed",
    display_name: "HED",
    description: "Holistically-Nested Edge Detection",
    category: "edge",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  softedge_hed: {
    id: "softedge_hed",
    display_name: "Soft Edge HED",
    description: "Soft edge variant of HED",
    category: "edge",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  pidinet: {
    id: "pidinet",
    display_name: "PidiNet",
    description: "Pixel Difference Networks for edge detection",
    category: "edge",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  softedge_pidinet: {
    id: "softedge_pidinet",
    display_name: "Soft Edge PidiNet",
    description: "Soft edge variant of PidiNet",
    category: "edge",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  teed: {
    id: "teed",
    display_name: "TEED",
    description: "Tiny and Efficient Edge Detector",
    category: "edge",
    inputs: {
      safe_steps: { type: "int", default: 2, min: 0, max: 10 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // LINEART
  lineart: {
    id: "lineart",
    display_name: "LineArt",
    description: "Realistic lineart extraction",
    category: "lineart",
    inputs: {
      coarse: { type: "bool", default: false },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  lineart_coarse: {
    id: "lineart_coarse",
    display_name: "LineArt Coarse",
    description: "Coarse lineart extraction",
    category: "lineart",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  lineart_anime: {
    id: "lineart_anime",
    display_name: "LineArt Anime",
    description: "Anime-style lineart extraction",
    category: "lineart",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  lineart_manga: {
    id: "lineart_manga",
    display_name: "LineArt Manga",
    description: "Manga-style lineart extraction",
    category: "lineart",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  anime_face_segment: {
    id: "anime_face_segment",
    display_name: "Anime Face Segment",
    description: "Anime face segmentation",
    category: "lineart",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // SCRIBBLE
  scribble_hed: {
    id: "scribble_hed",
    display_name: "Scribble HED",
    description: "HED-based scribble extraction",
    category: "scribble",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  scribble_pidinet: {
    id: "scribble_pidinet",
    display_name: "Scribble PidiNet",
    description: "PidiNet-based scribble extraction",
    category: "scribble",
    inputs: {
      safe: { type: "bool", default: true },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  scribble_xdog: {
    id: "scribble_xdog",
    display_name: "Scribble XDoG",
    description: "Extended Difference of Gaussians scribble",
    category: "scribble",
    inputs: {
      threshold: { type: "int", default: 32, min: 0, max: 255 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  binary: {
    id: "binary",
    display_name: "Binary",
    description: "Binary threshold conversion",
    category: "scribble",
    inputs: {
      bin_threshold: { type: "int", default: 100, min: 0, max: 255 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // SEGMENTATION
  sam: {
    id: "sam",
    display_name: "SAM",
    description: "Segment Anything Model",
    category: "segmentation",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  oneformer_ade20k: {
    id: "oneformer_ade20k",
    display_name: "OneFormer ADE20K",
    description: "OneFormer trained on ADE20K (150 classes)",
    category: "segmentation",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  oneformer_coco: {
    id: "oneformer_coco",
    display_name: "OneFormer COCO",
    description: "OneFormer trained on COCO (133 classes)",
    category: "segmentation",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  uniformer: {
    id: "uniformer",
    display_name: "UniFormer",
    description: "Unified segmentation model",
    category: "segmentation",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  color_shuffle: {
    id: "color_shuffle",
    display_name: "Color Shuffle",
    description: "Shuffle colors for data augmentation",
    category: "segmentation",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // OTHER
  mlsd: {
    id: "mlsd",
    display_name: "M-LSD",
    description: "Mobile Line Segment Detection",
    category: "other",
    inputs: {
      score_thr: { type: "float", default: 0.1, min: 0, max: 1, step: 0.01 },
      dist_thr: { type: "float", default: 0.1, min: 0, max: 1, step: 0.01 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  tile: {
    id: "tile",
    display_name: "Tile",
    description: "Tile preprocessor for upscaling workflows",
    category: "other",
    inputs: {
      pyrUp_iters: { type: "int", default: 3, min: 0, max: 10 },
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  inpaint: {
    id: "inpaint",
    display_name: "Inpaint Preprocessor",
    description: "Prepare mask for inpainting",
    category: "other",
    source: "controlnet_aux",
    inputs: {
      resolution: { type: "int", default: 512, min: 64, max: 2048, step: 8 }
    }
  },
  // ========================================================================
  // NORMALCRAFTER (from Binyr/NormalCrafter + AIWarper/ComfyUI-NormalCrafterWrapper)
  // Video-to-Normal diffusion model - temporally consistent normal sequences
  // ========================================================================
  normalcrafter: {
    id: "normalcrafter",
    display_name: "NormalCrafter (Video)",
    description: "Temporally consistent normal maps from video - ICCV 2025 (Binyr)",
    category: "normal",
    source: "normalcrafter",
    is_video: true,
    inputs: {
      seed: { type: "int", default: 42, min: 0, max: 2147483647 },
      max_res_dimension: { type: "int", default: 1024, min: 256, max: 2048 },
      window_size: { type: "int", default: 14, min: 1, max: 32 },
      time_step_size: { type: "int", default: 10, min: 1, max: 20 },
      decode_chunk_size: { type: "int", default: 4, min: 1, max: 16 },
      fps_for_time_ids: { type: "int", default: 7, min: 1, max: 60 },
      motion_bucket_id: { type: "int", default: 127, min: 0, max: 255 },
      noise_aug_strength: { type: "float", default: 0, min: 0, max: 1 }
    }
  },
  // ========================================================================
  // VIDEO POSE (from kijai/ComfyUI-WanAnimatePreprocess)
  // For Wan 2.2 video animation preprocessing
  // ========================================================================
  vitpose: {
    id: "vitpose",
    display_name: "ViTPose + Face (Video)",
    description: "ViTPose detection with face for video animation (Kijai)",
    category: "video",
    source: "wan_animate",
    is_video: true,
    inputs: {
      width: { type: "int", default: 832, min: 64, max: 2048 },
      height: { type: "int", default: 480, min: 64, max: 2048 }
    }
  },
  vitpose_draw: {
    id: "vitpose_draw",
    display_name: "Draw ViTPose Skeleton",
    description: "Render ViTPose skeleton visualization (Kijai)",
    category: "video",
    source: "wan_animate",
    inputs: {
      width: { type: "int", default: 832, min: 64, max: 2048 },
      height: { type: "int", default: 480, min: 64, max: 2048 },
      retarget_padding: { type: "int", default: 16, min: 0, max: 512 },
      body_stick_width: { type: "int", default: -1, min: -1, max: 20 },
      hand_stick_width: { type: "int", default: -1, min: -1, max: 20 },
      draw_head: { type: "bool", default: true }
    }
  },
  vitpose_one_to_all: {
    id: "vitpose_one_to_all",
    display_name: "Pose One-to-All Animation",
    description: "Transfer single pose to video sequence (Kijai)",
    category: "video",
    source: "wan_animate",
    is_video: true,
    inputs: {
      width: { type: "int", default: 832, min: 64, max: 2048, step: 2 },
      height: { type: "int", default: 480, min: 64, max: 2048, step: 2 },
      align_to: { type: "combo", options: ["ref", "pose", "none"], default: "ref" },
      draw_face_points: { type: "combo", options: ["full", "weak", "none"], default: "full" },
      draw_head: { type: "combo", options: ["full", "weak", "none"], default: "full" }
    }
  }
};
function getPreprocessorsForType(generationType) {
  const categories = TYPE_TO_CATEGORY[generationType] || TYPE_TO_CATEGORY.custom;
  return Object.values(PREPROCESSOR_REGISTRY).filter(
    (p) => categories.includes(p.category)
  );
}
function getDefaultPreprocessor(generationType) {
  return DEFAULT_PREPROCESSORS[generationType] || "depth_anything_v2";
}
async function executePreprocessor(preprocessorId, imageData, options = {}) {
  const startTime = Date.now();
  try {
    const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
    const response = await fetch(`/weyl/preprocessors/${preprocessorId}/execute`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        image: base64Data,
        options
      })
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
    }
    const result = await response.json();
    return {
      success: true,
      result_image: result.result_image,
      execution_time: Date.now() - startTime
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
      execution_time: Date.now() - startTime
    };
  }
}
async function renderLayerToImage(layerId, frame, resolution = 512) {
  try {
    const engine = window.__weylEngine;
    if (!engine) {
      console.error("[PreprocessorService] Engine not available");
      return null;
    }
    const canvas = await engine.renderLayerToCanvas(layerId, frame, resolution);
    if (!canvas) {
      console.error("[PreprocessorService] Failed to render layer");
      return null;
    }
    return canvas.toDataURL("image/png");
  } catch (error) {
    console.error("[PreprocessorService] Error rendering layer:", error);
    return null;
  }
}
async function generateFromLayer(sourceLayerId, targetLayerId, preprocessorId, options = {}, frame = 0, onProgress) {
  try {
    onProgress?.("Rendering source layer...");
    const sourceImage = await renderLayerToImage(sourceLayerId, frame, options.resolution || 512);
    if (!sourceImage) {
      return { success: false, error: "Failed to render source layer" };
    }
    onProgress?.("Processing with " + (PREPROCESSOR_REGISTRY[preprocessorId]?.display_name || preprocessorId) + "...");
    const result = await executePreprocessor(preprocessorId, sourceImage, options);
    if (!result.success || !result.result_image) {
      return { success: false, error: result.error || "Preprocessor failed" };
    }
    onProgress?.("Creating asset...");
    const assetId = await createAssetFromBase64(result.result_image, `generated_${preprocessorId}_${Date.now()}.png`);
    if (!assetId) {
      return { success: false, error: "Failed to create asset" };
    }
    return { success: true, assetId };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function createAssetFromBase64(base64Data, filename) {
  try {
    const { useCompositorStore } = await Promise.resolve().then(() => compositorStore);
    const store = useCompositorStore();
    const assetId = `generated_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const dimensions = await getImageDimensions(`data:image/png;base64,${base64Data}`);
    const asset = {
      id: assetId,
      type: "image",
      // Generated images are stored as image assets
      source: "generated",
      width: dimensions.width,
      height: dimensions.height,
      data: `data:image/png;base64,${base64Data}`,
      filename
    };
    store.project.assets[assetId] = asset;
    return assetId;
  } catch (error) {
    console.error("[PreprocessorService] Error creating asset:", error);
    return null;
  }
}
function getImageDimensions(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
    };
    img.onerror = () => {
      resolve({ width: 512, height: 512 });
    };
    img.src = dataUrl;
  });
}

const _hoisted_1$C = { class: "generated-properties" };
const _hoisted_2$C = { class: "status-icon" };
const _hoisted_3$C = { class: "status-text" };
const _hoisted_4$C = {
  key: 0,
  class: "status-time"
};
const _hoisted_5$C = {
  key: 0,
  class: "error-message"
};
const _hoisted_6$C = { class: "prop-section" };
const _hoisted_7$C = { class: "row" };
const _hoisted_8$A = ["value"];
const _hoisted_9$A = { class: "row" };
const _hoisted_10$z = ["value"];
const _hoisted_11$y = ["label"];
const _hoisted_12$w = ["value"];
const _hoisted_13$w = {
  key: 0,
  class: "model-description"
};
const _hoisted_14$s = { class: "prop-section" };
const _hoisted_15$r = { class: "row" };
const _hoisted_16$q = ["value"];
const _hoisted_17$p = ["value"];
const _hoisted_18$n = { class: "row checkbox-row" };
const _hoisted_19$m = ["checked"];
const _hoisted_20$m = { class: "prop-section" };
const _hoisted_21$l = { class: "action-buttons" };
const _hoisted_22$j = ["disabled"];
const _hoisted_23$j = { class: "btn-icon" };
const _hoisted_24$f = ["disabled"];
const _hoisted_25$f = {
  key: 0,
  class: "hint"
};
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "GeneratedProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const progressMessage = ref("");
    const generatedData = computed(() => props.layer.data);
    const sourceLayers = computed(() => {
      return store.layers.filter(
        (l) => l.id !== props.layer.id && ["image", "video", "solid", "text", "spline", "shape"].includes(l.type)
      );
    });
    const availablePreprocessors = computed(() => {
      return getPreprocessorsForType(generatedData.value.generationType || "depth");
    });
    const preprocessorGroups = computed(() => {
      const groups = {};
      for (const p of availablePreprocessors.value) {
        const category = p.category.charAt(0).toUpperCase() + p.category.slice(1);
        if (!groups[category]) {
          groups[category] = [];
        }
        groups[category].push(p);
      }
      return groups;
    });
    const currentPreprocessor = computed(() => {
      const model = generatedData.value.model || getDefaultPreprocessor(generatedData.value.generationType || "depth");
      return PREPROCESSOR_REGISTRY[model] || null;
    });
    const statusIcon = computed(() => {
      switch (generatedData.value.status) {
        case "pending":
          return "";
        case "generating":
          return "";
        case "complete":
          return "";
        case "error":
          return "";
        default:
          return "";
      }
    });
    const statusText = computed(() => {
      switch (generatedData.value.status) {
        case "pending":
          return "Not generated";
        case "generating":
          return progressMessage.value || "Generating...";
        case "complete":
          return "Complete";
        case "error":
          return "Error";
        default:
          return "Unknown";
      }
    });
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    function onGenerationTypeChange(type) {
      updateData("generationType", type);
      updateData("model", getDefaultPreprocessor(type));
    }
    async function regenerate() {
      const sourceLayerId = generatedData.value.sourceLayerId;
      if (!sourceLayerId) {
        emit("update", { status: "error", errorMessage: "No source layer selected" });
        return;
      }
      const preprocessorId = generatedData.value.model || getDefaultPreprocessor(generatedData.value.generationType || "depth");
      emit("update", { status: "generating", errorMessage: void 0 });
      progressMessage.value = "Starting...";
      try {
        const result = await generateFromLayer(
          sourceLayerId,
          props.layer.id,
          preprocessorId,
          {
            resolution: 512
            // TODO: Make configurable
          },
          store.currentFrame,
          (status) => {
            progressMessage.value = status;
          }
        );
        if (result.success && result.assetId) {
          emit("update", {
            status: "complete",
            generatedAssetId: result.assetId,
            lastGenerated: (/* @__PURE__ */ new Date()).toISOString(),
            errorMessage: void 0
          });
        } else {
          emit("update", {
            status: "error",
            errorMessage: result.error || "Generation failed"
          });
        }
      } catch (error) {
        emit("update", {
          status: "error",
          errorMessage: error instanceof Error ? error.message : "Unknown error"
        });
      } finally {
        progressMessage.value = "";
      }
    }
    function clearGenerated() {
      emit("update", {
        status: "pending",
        generatedAssetId: null,
        lastGenerated: void 0,
        errorMessage: void 0
      });
    }
    function formatTime(isoString) {
      const date = new Date(isoString);
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$C, [
        createBaseVNode("div", {
          class: normalizeClass(["status-banner", generatedData.value.status])
        }, [
          createBaseVNode("span", _hoisted_2$C, toDisplayString(statusIcon.value), 1),
          createBaseVNode("span", _hoisted_3$C, toDisplayString(statusText.value), 1),
          generatedData.value.lastGenerated ? (openBlock(), createElementBlock("span", _hoisted_4$C, toDisplayString(formatTime(generatedData.value.lastGenerated)), 1)) : createCommentVNode("", true)
        ], 2),
        generatedData.value.status === "error" && generatedData.value.errorMessage ? (openBlock(), createElementBlock("div", _hoisted_5$C, toDisplayString(generatedData.value.errorMessage), 1)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_6$C, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "section-title" }, "Generation Settings", -1)),
          createBaseVNode("div", _hoisted_7$C, [
            _cache[5] || (_cache[5] = createBaseVNode("label", null, "Type", -1)),
            createBaseVNode("select", {
              value: generatedData.value.generationType,
              onChange: _cache[0] || (_cache[0] = ($event) => onGenerationTypeChange($event.target.value))
            }, [..._cache[4] || (_cache[4] = [
              createStaticVNode('<option value="depth" data-v-4fd61ebe>Depth Map</option><option value="normal" data-v-4fd61ebe>Normal Map</option><option value="edge" data-v-4fd61ebe>Edge Detection</option><option value="pose" data-v-4fd61ebe>Pose Estimation</option><option value="video" data-v-4fd61ebe>Video (Pose/Normal)</option><option value="segment" data-v-4fd61ebe>Segmentation</option><option value="custom" data-v-4fd61ebe>All Models</option>', 7)
            ])], 40, _hoisted_8$A)
          ]),
          createBaseVNode("div", _hoisted_9$A, [
            _cache[6] || (_cache[6] = createBaseVNode("label", null, "Model", -1)),
            createBaseVNode("select", {
              value: generatedData.value.model,
              onChange: _cache[1] || (_cache[1] = ($event) => updateData("model", $event.target.value))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(preprocessorGroups.value, (preprocessors, category) => {
                return openBlock(), createElementBlock("optgroup", {
                  key: category,
                  label: category
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(preprocessors, (p) => {
                    return openBlock(), createElementBlock("option", {
                      key: p.id,
                      value: p.id
                    }, toDisplayString(p.display_name), 9, _hoisted_12$w);
                  }), 128))
                ], 8, _hoisted_11$y);
              }), 128))
            ], 40, _hoisted_10$z)
          ]),
          currentPreprocessor.value ? (openBlock(), createElementBlock("div", _hoisted_13$w, toDisplayString(currentPreprocessor.value.description), 1)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_14$s, [
          _cache[11] || (_cache[11] = createBaseVNode("div", { class: "section-title" }, "Source", -1)),
          createBaseVNode("div", _hoisted_15$r, [
            _cache[9] || (_cache[9] = createBaseVNode("label", null, "Source Layer", -1)),
            createBaseVNode("select", {
              value: generatedData.value.sourceLayerId || "",
              onChange: _cache[2] || (_cache[2] = ($event) => updateData("sourceLayerId", $event.target.value || null))
            }, [
              _cache[8] || (_cache[8] = createBaseVNode("option", { value: "" }, "None", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(sourceLayers.value, (layer) => {
                return openBlock(), createElementBlock("option", {
                  key: layer.id,
                  value: layer.id
                }, toDisplayString(layer.name), 9, _hoisted_17$p);
              }), 128))
            ], 40, _hoisted_16$q)
          ]),
          createBaseVNode("div", _hoisted_18$n, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: generatedData.value.autoRegenerate,
                onChange: _cache[3] || (_cache[3] = ($event) => updateData("autoRegenerate", !generatedData.value.autoRegenerate))
              }, null, 40, _hoisted_19$m),
              _cache[10] || (_cache[10] = createTextVNode(" Auto-regenerate on source change ", -1))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_20$m, [
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "section-title" }, "Actions", -1)),
          createBaseVNode("div", _hoisted_21$l, [
            createBaseVNode("button", {
              class: "action-btn primary",
              onClick: regenerate,
              disabled: generatedData.value.status === "generating" || !generatedData.value.sourceLayerId
            }, [
              createBaseVNode("span", _hoisted_23$j, toDisplayString(generatedData.value.status === "generating" ? "..." : ""), 1),
              createTextVNode(" " + toDisplayString(generatedData.value.status === "generating" ? "Generating..." : "Generate"), 1)
            ], 8, _hoisted_22$j),
            createBaseVNode("button", {
              class: "action-btn",
              onClick: clearGenerated,
              disabled: generatedData.value.status === "generating"
            }, " Clear ", 8, _hoisted_24$f)
          ]),
          !generatedData.value.sourceLayerId ? (openBlock(), createElementBlock("p", _hoisted_25$f, " Select a source layer to generate from ")) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const GeneratedProperties = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-4fd61ebe"]]);

const _hoisted_1$B = { class: "group-properties" };
const _hoisted_2$B = { class: "prop-section" };
const _hoisted_3$B = { class: "row color-row" };
const _hoisted_4$B = { class: "color-picker-wrapper" };
const _hoisted_5$B = ["value"];
const _hoisted_6$B = { class: "color-hex" };
const _hoisted_7$B = { class: "color-presets" };
const _hoisted_8$z = ["title", "onClick"];
const _hoisted_9$z = { class: "prop-section" };
const _hoisted_10$y = { class: "row checkbox-row" };
const _hoisted_11$x = ["checked"];
const _hoisted_12$v = { class: "row checkbox-row" };
const _hoisted_13$v = ["checked"];
const _hoisted_14$r = { class: "row checkbox-row" };
const _hoisted_15$q = ["checked"];
const _hoisted_16$p = { class: "prop-section" };
const _hoisted_17$o = { class: "info-row" };
const _hoisted_18$m = { class: "info-value" };
const _hoisted_19$l = {
  key: 0,
  class: "child-list"
};
const _hoisted_20$l = ["onClick"];
const _hoisted_21$k = { class: "child-icon" };
const _hoisted_22$i = { class: "child-name" };
const _hoisted_23$i = {
  key: 1,
  class: "empty-hint"
};
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "GroupProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const groupData = computed(() => props.layer.data);
    const childLayers = computed(() => {
      return store.layers.filter((l) => l.parentId === props.layer.id);
    });
    const childCount = computed(() => childLayers.value.length);
    const colorPresets = [
      { name: "Red", color: "#e74c3c" },
      { name: "Orange", color: "#e67e22" },
      { name: "Yellow", color: "#f1c40f" },
      { name: "Green", color: "#2ecc71" },
      { name: "Cyan", color: "#1abc9c" },
      { name: "Blue", color: "#3498db" },
      { name: "Purple", color: "#9b59b6" },
      { name: "Pink", color: "#e91e63" },
      { name: "Gray", color: "#888888" }
    ];
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    function selectLayer(layerId) {
      store.selectLayer(layerId);
    }
    function getLayerIcon(type) {
      const icons = {
        image: "",
        video: "",
        solid: "",
        null: "",
        text: "T",
        spline: "",
        shape: "",
        particles: "",
        camera: "",
        light: "",
        group: "",
        audio: "",
        depth: "",
        normal: "",
        generated: ""
      };
      return icons[type] || "";
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        createBaseVNode("div", _hoisted_2$B, [
          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-title" }, "Group Appearance", -1)),
          createBaseVNode("div", _hoisted_3$B, [
            _cache[4] || (_cache[4] = createBaseVNode("label", null, "Label Color", -1)),
            createBaseVNode("div", _hoisted_4$B, [
              createBaseVNode("input", {
                type: "color",
                value: groupData.value.color,
                onInput: _cache[0] || (_cache[0] = ($event) => updateData("color", $event.target.value))
              }, null, 40, _hoisted_5$B),
              createBaseVNode("span", _hoisted_6$B, toDisplayString(groupData.value.color), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$B, [
            (openBlock(), createElementBlock(Fragment, null, renderList(colorPresets, (preset) => {
              return createBaseVNode("button", {
                key: preset.color,
                class: "preset-btn",
                style: normalizeStyle({ backgroundColor: preset.color }),
                title: preset.name,
                onClick: ($event) => updateData("color", preset.color)
              }, null, 12, _hoisted_8$z);
            }), 64))
          ])
        ]),
        createBaseVNode("div", _hoisted_9$z, [
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "section-title" }, "Group Behavior", -1)),
          createBaseVNode("div", _hoisted_10$y, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: groupData.value.collapsed,
                onChange: _cache[1] || (_cache[1] = ($event) => updateData("collapsed", !groupData.value.collapsed))
              }, null, 40, _hoisted_11$x),
              _cache[6] || (_cache[6] = createTextVNode(" Collapsed in Timeline ", -1))
            ]),
            _cache[7] || (_cache[7] = createBaseVNode("span", {
              class: "hint-icon",
              title: "Hide child layers in the timeline panel"
            }, "?", -1))
          ]),
          createBaseVNode("div", _hoisted_12$v, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: groupData.value.passThrough,
                onChange: _cache[2] || (_cache[2] = ($event) => updateData("passThrough", !groupData.value.passThrough))
              }, null, 40, _hoisted_13$v),
              _cache[8] || (_cache[8] = createTextVNode(" Pass-Through Mode ", -1))
            ]),
            _cache[9] || (_cache[9] = createBaseVNode("span", {
              class: "hint-icon",
              title: "Blend modes of child layers affect layers outside the group"
            }, "?", -1))
          ]),
          createBaseVNode("div", _hoisted_14$r, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: groupData.value.isolate,
                onChange: _cache[3] || (_cache[3] = ($event) => updateData("isolate", !groupData.value.isolate))
              }, null, 40, _hoisted_15$q),
              _cache[10] || (_cache[10] = createTextVNode(" Isolate Group ", -1))
            ]),
            _cache[11] || (_cache[11] = createBaseVNode("span", {
              class: "hint-icon",
              title: "Only show this group's contents in the viewer"
            }, "?", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_16$p, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-title" }, "Contents", -1)),
          createBaseVNode("div", _hoisted_17$o, [
            _cache[13] || (_cache[13] = createBaseVNode("span", { class: "info-label" }, "Child Layers", -1)),
            createBaseVNode("span", _hoisted_18$m, toDisplayString(childCount.value), 1)
          ]),
          childLayers.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_19$l, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(childLayers.value, (child) => {
              return openBlock(), createElementBlock("div", {
                key: child.id,
                class: "child-item",
                onClick: ($event) => selectLayer(child.id)
              }, [
                createBaseVNode("span", _hoisted_21$k, toDisplayString(getLayerIcon(child.type)), 1),
                createBaseVNode("span", _hoisted_22$i, toDisplayString(child.name), 1)
              ], 8, _hoisted_20$l);
            }), 128))
          ])) : (openBlock(), createElementBlock("p", _hoisted_23$i, " No child layers. Parent other layers to this group. "))
        ])
      ]);
    };
  }
});

const GroupProperties = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-44844758"]]);

const _hoisted_1$A = { class: "control-properties" };
const _hoisted_2$A = { class: "prop-section" };
const _hoisted_3$A = { class: "row" };
const _hoisted_4$A = { class: "row" };
const _hoisted_5$A = ["value"];
const _hoisted_6$A = { class: "row color-row" };
const _hoisted_7$A = { class: "color-picker-wrapper" };
const _hoisted_8$y = ["value"];
const _hoisted_9$y = { class: "color-hex" };
const _hoisted_10$x = { class: "prop-section" };
const _hoisted_11$w = { class: "row checkbox-row" };
const _hoisted_12$u = ["checked"];
const _hoisted_13$u = { class: "row checkbox-row" };
const _hoisted_14$q = ["checked"];
const _hoisted_15$p = { class: "prop-section" };
const _hoisted_16$o = { class: "color-presets" };
const _hoisted_17$n = ["title", "onClick"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "ControlProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const controlData = computed(() => props.layer.data);
    const colorPresets = [
      { name: "Yellow", color: "#ffcc00" },
      { name: "Red", color: "#e74c3c" },
      { name: "Orange", color: "#e67e22" },
      { name: "Green", color: "#2ecc71" },
      { name: "Cyan", color: "#1abc9c" },
      { name: "Blue", color: "#3498db" },
      { name: "Purple", color: "#9b59b6" },
      { name: "Pink", color: "#e91e63" },
      { name: "White", color: "#ffffff" }
    ];
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$A, [
        createBaseVNode("div", _hoisted_2$A, [
          _cache[9] || (_cache[9] = createBaseVNode("div", { class: "section-title" }, "Visual Settings", -1)),
          createBaseVNode("div", _hoisted_3$A, [
            _cache[5] || (_cache[5] = createBaseVNode("label", null, "Icon Size", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: controlData.value.size,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => updateData("size", v)),
              min: 10,
              max: 200,
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_4$A, [
            _cache[7] || (_cache[7] = createBaseVNode("label", null, "Icon Shape", -1)),
            createBaseVNode("select", {
              value: controlData.value.iconShape,
              onChange: _cache[1] || (_cache[1] = ($event) => updateData("iconShape", $event.target.value))
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("option", { value: "crosshair" }, "Crosshair", -1),
              createBaseVNode("option", { value: "diamond" }, "Diamond", -1),
              createBaseVNode("option", { value: "circle" }, "Circle", -1),
              createBaseVNode("option", { value: "square" }, "Square", -1)
            ])], 40, _hoisted_5$A)
          ]),
          createBaseVNode("div", _hoisted_6$A, [
            _cache[8] || (_cache[8] = createBaseVNode("label", null, "Icon Color", -1)),
            createBaseVNode("div", _hoisted_7$A, [
              createBaseVNode("input", {
                type: "color",
                value: controlData.value.iconColor,
                onInput: _cache[2] || (_cache[2] = ($event) => updateData("iconColor", $event.target.value))
              }, null, 40, _hoisted_8$y),
              createBaseVNode("span", _hoisted_9$y, toDisplayString(controlData.value.iconColor), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_10$x, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-title" }, "Display Options", -1)),
          createBaseVNode("div", _hoisted_11$w, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: controlData.value.showIcon,
                onChange: _cache[3] || (_cache[3] = ($event) => updateData("showIcon", !controlData.value.showIcon))
              }, null, 40, _hoisted_12$u),
              _cache[10] || (_cache[10] = createTextVNode(" Show Icon ", -1))
            ]),
            _cache[11] || (_cache[11] = createBaseVNode("span", {
              class: "hint-icon",
              title: "Display the control icon in the viewport"
            }, "?", -1))
          ]),
          createBaseVNode("div", _hoisted_13$u, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: controlData.value.showAxes,
                onChange: _cache[4] || (_cache[4] = ($event) => updateData("showAxes", !controlData.value.showAxes))
              }, null, 40, _hoisted_14$q),
              _cache[12] || (_cache[12] = createTextVNode(" Show Axes ", -1))
            ]),
            _cache[13] || (_cache[13] = createBaseVNode("span", {
              class: "hint-icon",
              title: "Display XYZ axis indicators"
            }, "?", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_15$p, [
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "section-title" }, "Color Presets", -1)),
          createBaseVNode("div", _hoisted_16$o, [
            (openBlock(), createElementBlock(Fragment, null, renderList(colorPresets, (preset) => {
              return createBaseVNode("button", {
                key: preset.color,
                class: "preset-btn",
                style: normalizeStyle({ backgroundColor: preset.color }),
                title: preset.name,
                onClick: ($event) => updateData("iconColor", preset.color)
              }, null, 12, _hoisted_17$n);
            }), 64))
          ])
        ]),
        _cache[16] || (_cache[16] = createBaseVNode("div", { class: "prop-section" }, [
          createBaseVNode("div", { class: "info-note" }, " Control layers are invisible in renders. Use them as parent objects to control groups of layers. ")
        ], -1))
      ]);
    };
  }
});

const ControlProperties = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__scopeId", "data-v-8eb36db9"]]);

const _hoisted_1$z = { class: "matte-properties" };
const _hoisted_2$z = { class: "prop-section" };
const _hoisted_3$z = { class: "row" };
const _hoisted_4$z = ["value"];
const _hoisted_5$z = ["value"];
const _hoisted_6$z = { class: "row" };
const _hoisted_7$z = ["value"];
const _hoisted_8$x = { class: "prop-section" };
const _hoisted_9$x = { class: "row" };
const _hoisted_10$w = { class: "row" };
const _hoisted_11$v = { class: "row" };
const _hoisted_12$t = { class: "row checkbox-row" };
const _hoisted_13$t = ["checked"];
const _hoisted_14$p = { class: "prop-section" };
const _hoisted_15$o = { class: "preview-buttons" };
const _hoisted_16$n = ["onClick", "title"];
const _hoisted_17$m = { class: "prop-section" };
const _hoisted_18$l = { class: "action-buttons" };
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "MatteProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const matteData = computed(() => props.layer.data);
    const sourceLayers = computed(() => {
      return store.layers.filter(
        (l) => l.id !== props.layer.id && ["image", "video", "solid", "text", "shape", "spline"].includes(l.type)
      );
    });
    const previewModes = [
      { value: "matte", label: "Matte", description: "View matte as grayscale" },
      { value: "composite", label: "Result", description: "View composited result" },
      { value: "overlay", label: "Overlay", description: "View matte overlaid on source" }
    ];
    function updateData(key, value) {
      emit("update", { [key]: value });
    }
    function resetToDefaults() {
      emit("update", {
        matteType: "luminance",
        invert: false,
        threshold: 0.5,
        feather: 0,
        expansion: 0,
        previewMode: "matte"
      });
    }
    function invertMatte() {
      updateData("invert", !matteData.value.invert);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        createBaseVNode("div", _hoisted_2$z, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-title" }, "Matte Source", -1)),
          createBaseVNode("div", _hoisted_3$z, [
            _cache[7] || (_cache[7] = createBaseVNode("label", null, "Source Layer", -1)),
            createBaseVNode("select", {
              value: matteData.value.sourceLayerId || "",
              onChange: _cache[0] || (_cache[0] = ($event) => updateData("sourceLayerId", $event.target.value || null))
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("option", { value: "" }, "None (Self)", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(sourceLayers.value, (layer) => {
                return openBlock(), createElementBlock("option", {
                  key: layer.id,
                  value: layer.id
                }, toDisplayString(layer.name), 9, _hoisted_5$z);
              }), 128))
            ], 40, _hoisted_4$z)
          ]),
          createBaseVNode("div", _hoisted_6$z, [
            _cache[9] || (_cache[9] = createBaseVNode("label", null, "Extract From", -1)),
            createBaseVNode("select", {
              value: matteData.value.matteType,
              onChange: _cache[1] || (_cache[1] = ($event) => updateData("matteType", $event.target.value))
            }, [..._cache[8] || (_cache[8] = [
              createStaticVNode('<option value="luminance" data-v-1c9209dc>Luminance</option><option value="alpha" data-v-1c9209dc>Alpha Channel</option><option value="red" data-v-1c9209dc>Red Channel</option><option value="green" data-v-1c9209dc>Green Channel</option><option value="blue" data-v-1c9209dc>Blue Channel</option><option value="hue" data-v-1c9209dc>Hue</option><option value="saturation" data-v-1c9209dc>Saturation</option>', 7)
            ])], 40, _hoisted_7$z)
          ])
        ]),
        createBaseVNode("div", _hoisted_8$x, [
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "section-title" }, "Adjustments", -1)),
          createBaseVNode("div", _hoisted_9$x, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Threshold", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: matteData.value.threshold,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateData("threshold", v)),
              min: 0,
              max: 1,
              precision: 2
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_10$w, [
            _cache[12] || (_cache[12] = createBaseVNode("label", null, "Feather", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: matteData.value.feather,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateData("feather", v)),
              min: 0,
              max: 100,
              precision: 1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_11$v, [
            _cache[13] || (_cache[13] = createBaseVNode("label", null, "Expansion", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: matteData.value.expansion,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateData("expansion", v)),
              min: -50,
              max: 50,
              precision: 1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_12$t, [
            createBaseVNode("label", null, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: matteData.value.invert,
                onChange: _cache[5] || (_cache[5] = ($event) => updateData("invert", !matteData.value.invert))
              }, null, 40, _hoisted_13$t),
              _cache[14] || (_cache[14] = createTextVNode(" Invert Matte ", -1))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_14$p, [
          _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-title" }, "Preview", -1)),
          createBaseVNode("div", _hoisted_15$o, [
            (openBlock(), createElementBlock(Fragment, null, renderList(previewModes, (mode) => {
              return createBaseVNode("button", {
                key: mode.value,
                class: normalizeClass(["preview-btn", { active: matteData.value.previewMode === mode.value }]),
                onClick: ($event) => updateData("previewMode", mode.value),
                title: mode.description
              }, toDisplayString(mode.label), 11, _hoisted_16$n);
            }), 64))
          ])
        ]),
        createBaseVNode("div", _hoisted_17$m, [
          _cache[17] || (_cache[17] = createBaseVNode("div", { class: "section-title" }, "Quick Actions", -1)),
          createBaseVNode("div", _hoisted_18$l, [
            createBaseVNode("button", {
              class: "action-btn",
              onClick: resetToDefaults
            }, " Reset Defaults "),
            createBaseVNode("button", {
              class: "action-btn",
              onClick: invertMatte
            }, toDisplayString(matteData.value.invert ? "Un-invert" : "Invert"), 1)
          ])
        ])
      ]);
    };
  }
});

const MatteProperties = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__scopeId", "data-v-1c9209dc"]]);

const _hoisted_1$y = ["title"];
const _hoisted_2$y = {
  viewBox: "0 0 16 16",
  class: "link-icon"
};
const _hoisted_3$y = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_4$y = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_5$y = ["x1", "y1", "x2", "y2"];
const _hoisted_6$y = ["cx", "cy"];
const _hoisted_7$y = { class: "drop-label" };
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "PropertyLink",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const containerRef = ref(null);
    const isDragging = ref(false);
    const dragStart = ref({ x: 0, y: 0 });
    const dragEnd = ref({ x: 0, y: 0 });
    const currentDropTarget = ref(null);
    const hasLink = computed(() => !!props.linkedTo);
    const linkTargetName = computed(() => {
      if (!props.linkedTo) return "";
      return `${props.linkedTo.layerId}.${props.linkedTo.property}`;
    });
    const lineStyle = computed(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    }));
    const dropTargetStyle = computed(() => {
      if (!currentDropTarget.value) return {};
      const rect = currentDropTarget.value.rect;
      return {
        position: "fixed",
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        zIndex: 9999
      };
    });
    function findDropTargets() {
      const targets = [];
      const elements = document.querySelectorAll("[data-link-target]");
      elements.forEach((el) => {
        const htmlEl = el;
        const layerId = htmlEl.dataset.linkLayerId;
        const property = htmlEl.dataset.linkTarget;
        const label = htmlEl.dataset.linkLabel || property;
        if (layerId === props.layerId && property === props.property) {
          return;
        }
        if (layerId && property) {
          targets.push({
            layerId,
            property,
            label,
            element: htmlEl,
            rect: htmlEl.getBoundingClientRect()
          });
        }
      });
      return targets;
    }
    function findTargetAtPosition(x, y, targets) {
      for (const target of targets) {
        const rect = target.rect;
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return target;
        }
      }
      return null;
    }
    let dropTargets = [];
    function startDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      const rect = containerRef.value?.getBoundingClientRect();
      if (rect) {
        dragStart.value = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      } else {
        dragStart.value = { x: clientX, y: clientY };
      }
      dragEnd.value = { x: clientX, y: clientY };
      isDragging.value = true;
      dropTargets = findDropTargets();
      window.addEventListener("mousemove", onDrag);
      window.addEventListener("mouseup", endDrag);
      window.addEventListener("touchmove", onDrag);
      window.addEventListener("touchend", endDrag);
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      dragEnd.value = { x: clientX, y: clientY };
      dropTargets.forEach((t) => {
        t.rect = t.element.getBoundingClientRect();
      });
      currentDropTarget.value = findTargetAtPosition(clientX, clientY, dropTargets);
    }
    function endDrag(e) {
      if (!isDragging.value) return;
      const clientX = "changedTouches" in e ? e.changedTouches[0].clientX : e.clientX;
      const clientY = "changedTouches" in e ? e.changedTouches[0].clientY : e.clientY;
      const target = findTargetAtPosition(clientX, clientY, dropTargets);
      if (target) {
        emit("link", { layerId: target.layerId, property: target.property });
      }
      isDragging.value = false;
      currentDropTarget.value = null;
      dropTargets = [];
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    }
    function clearLink() {
      emit("unlink");
    }
    onUnmounted(() => {
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "property-link-container",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["link-handle", { dragging: isDragging.value, linked: hasLink.value }]),
          onMousedown: startDrag,
          onTouchstart: withModifiers(startDrag, ["prevent"]),
          title: hasLink.value ? `Linked to: ${linkTargetName.value}` : "Drag to link property"
        }, [
          (openBlock(), createElementBlock("svg", _hoisted_2$y, [
            _cache[0] || (_cache[0] = createBaseVNode("circle", {
              cx: "8",
              cy: "8",
              r: "3",
              fill: "currentColor"
            }, null, -1)),
            !hasLink.value ? (openBlock(), createElementBlock("path", _hoisted_3$y)) : (openBlock(), createElementBlock("path", _hoisted_4$y))
          ]))
        ], 42, _hoisted_1$y),
        hasLink.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "clear-link-btn",
          onClick: clearLink,
          title: "Remove link"
        }, "  ")) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "property-link-line",
            style: normalizeStyle(lineStyle.value)
          }, [
            createBaseVNode("line", {
              x1: dragStart.value.x,
              y1: dragStart.value.y,
              x2: dragEnd.value.x,
              y2: dragEnd.value.y,
              stroke: "#4a90d9",
              "stroke-width": "2",
              "stroke-dasharray": "4 2"
            }, null, 8, _hoisted_5$y),
            createBaseVNode("circle", {
              cx: dragEnd.value.x,
              cy: dragEnd.value.y,
              r: "6",
              fill: "#4a90d9",
              stroke: "#fff",
              "stroke-width": "1"
            }, null, 8, _hoisted_6$y)
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value && currentDropTarget.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "drop-target-highlight",
            style: normalizeStyle(dropTargetStyle.value)
          }, [
            createBaseVNode("span", _hoisted_7$y, toDisplayString(currentDropTarget.value.label), 1)
          ], 4)) : createCommentVNode("", true)
        ]))
      ], 512);
    };
  }
});

const PropertyLink = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-10380f63"]]);

const _hoisted_1$x = {
  key: 0,
  class: "driver-list"
};
const _hoisted_2$x = { class: "expand-icon" };
const _hoisted_3$x = { class: "count" };
const _hoisted_4$x = {
  key: 0,
  class: "driver-items"
};
const _hoisted_5$x = { class: "driver-header" };
const _hoisted_6$x = ["onClick"];
const _hoisted_7$x = { class: "driver-info" };
const _hoisted_8$w = { class: "target" };
const _hoisted_9$w = {
  key: 0,
  class: "source"
};
const _hoisted_10$v = {
  key: 1,
  class: "source audio"
};
const _hoisted_11$u = {
  key: 2,
  class: "source time"
};
const _hoisted_12$s = ["onClick"];
const _hoisted_13$s = {
  key: 0,
  class: "driver-transforms"
};
const _hoisted_14$o = ["title"];
const _hoisted_15$n = {
  key: 1,
  class: "add-driver-section"
};
const _hoisted_16$m = {
  key: 0,
  class: "add-menu"
};
const _hoisted_17$l = { class: "menu-section" };
const _hoisted_18$k = { class: "menu-section" };
const _hoisted_19$k = { class: "menu-section" };
const _hoisted_20$k = { class: "menu-section" };
const _hoisted_21$j = { class: "menu-actions" };
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(__props) {
    const props = __props;
    const store = useCompositorStore();
    const expanded = ref(true);
    const showAddMenu = ref(false);
    const newDriver = ref({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    });
    const drivers = computed(() => {
      return store.getDriversForLayer(props.layerId);
    });
    function formatProperty(prop) {
      if (!prop) return "?";
      const names = {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        "opacity": "Opacity"
      };
      return names[prop] || prop;
    }
    function getSourceLayerName(layerId) {
      if (!layerId) return "?";
      const layer = store.layers.find((l) => l.id === layerId);
      return layer?.name || layerId.slice(0, 8);
    }
    function formatTransform(t) {
      switch (t.type) {
        case "scale":
          return `Scale: ${t.factor}`;
        case "offset":
          return `Offset: ${t.amount}`;
        case "clamp":
          return `Clamp: ${t.min}-${t.max}`;
        case "smooth":
          return `Smooth: ${t.smoothing}`;
        case "threshold":
          return `Threshold: ${t.threshold}`;
        default:
          return t.type;
      }
    }
    function toggleDriver(driverId) {
      store.togglePropertyDriver(driverId);
    }
    function removeDriver(driverId) {
      store.removePropertyDriver(driverId);
    }
    function createAudioDriver() {
      store.createAudioPropertyDriver(
        props.layerId,
        newDriver.value.targetProperty,
        newDriver.value.audioFeature,
        {
          scale: newDriver.value.scale,
          threshold: newDriver.value.threshold > 0 ? newDriver.value.threshold : void 0
        }
      );
      showAddMenu.value = false;
    }
    return (_ctx, _cache) => {
      return drivers.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", {
          class: "driver-list-header",
          onClick: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
        }, [
          createBaseVNode("span", _hoisted_2$x, toDisplayString(expanded.value ? "" : ""), 1),
          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "title" }, "Property Drivers", -1)),
          createBaseVNode("span", _hoisted_3$x, "(" + toDisplayString(drivers.value.length) + ")", 1)
        ]),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_4$x, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(drivers.value, (driver) => {
            return openBlock(), createElementBlock("div", {
              key: driver.id,
              class: normalizeClass(["driver-item", { disabled: !driver.enabled }])
            }, [
              createBaseVNode("div", _hoisted_5$x, [
                createBaseVNode("button", {
                  class: normalizeClass(["toggle-btn", { active: driver.enabled }]),
                  onClick: ($event) => toggleDriver(driver.id),
                  title: "Toggle driver"
                }, "  ", 10, _hoisted_6$x),
                createBaseVNode("div", _hoisted_7$x, [
                  createBaseVNode("span", _hoisted_8$w, toDisplayString(formatProperty(driver.targetProperty)), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "arrow" }, "", -1)),
                  driver.sourceType === "property" ? (openBlock(), createElementBlock("span", _hoisted_9$w, toDisplayString(getSourceLayerName(driver.sourceLayerId)) + "." + toDisplayString(formatProperty(driver.sourceProperty)), 1)) : driver.sourceType === "audio" ? (openBlock(), createElementBlock("span", _hoisted_10$v, "  " + toDisplayString(driver.audioFeature), 1)) : driver.sourceType === "time" ? (openBlock(), createElementBlock("span", _hoisted_11$u, "  Time ")) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: "remove-btn",
                  onClick: ($event) => removeDriver(driver.id),
                  title: "Remove driver"
                }, "  ", 8, _hoisted_12$s)
              ]),
              driver.transforms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$s, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(driver.transforms, (t, i) => {
                  return openBlock(), createElementBlock("span", {
                    key: i,
                    class: "transform-chip",
                    title: formatTransform(t)
                  }, toDisplayString(t.type), 9, _hoisted_14$o);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_15$n, [
          createBaseVNode("button", {
            class: "add-driver-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => showAddMenu.value = !showAddMenu.value)
          }, " + Add Audio Driver "),
          showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_16$m, [
            createBaseVNode("div", _hoisted_17$l, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Audio Feature:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newDriver.value.audioFeature = $event)
              }, [..._cache[9] || (_cache[9] = [
                createStaticVNode('<option value="amplitude" data-v-ffb799cf>Amplitude</option><option value="bass" data-v-ffb799cf>Bass</option><option value="mid" data-v-ffb799cf>Mid</option><option value="high" data-v-ffb799cf>High</option><option value="rms" data-v-ffb799cf>RMS</option>', 5)
              ])], 512), [
                [vModelSelect, newDriver.value.audioFeature]
              ])
            ]),
            createBaseVNode("div", _hoisted_18$k, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Target Property:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newDriver.value.targetProperty = $event)
              }, [..._cache[11] || (_cache[11] = [
                createStaticVNode('<option value="transform.position.x" data-v-ffb799cf>Position X</option><option value="transform.position.y" data-v-ffb799cf>Position Y</option><option value="transform.scale.x" data-v-ffb799cf>Scale X</option><option value="transform.scale.y" data-v-ffb799cf>Scale Y</option><option value="transform.rotation" data-v-ffb799cf>Rotation</option><option value="opacity" data-v-ffb799cf>Opacity</option>', 6)
              ])], 512), [
                [vModelSelect, newDriver.value.targetProperty]
              ])
            ]),
            createBaseVNode("div", _hoisted_19$k, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Scale:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newDriver.value.scale = $event),
                step: "10"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.scale,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_20$k, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Threshold:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newDriver.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.threshold,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_21$j, [
              createBaseVNode("button", { onClick: createAudioDriver }, "Create"),
              createBaseVNode("button", {
                onClick: _cache[6] || (_cache[6] = ($event) => showAddMenu.value = false)
              }, "Cancel")
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});

const DriverList = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-ffb799cf"]]);

const _hoisted_1$w = { class: "properties-panel" };
const _hoisted_2$w = { class: "panel-header" };
const _hoisted_3$w = { class: "panel-title" };
const _hoisted_4$w = {
  key: 0,
  class: "panel-content"
};
const _hoisted_5$w = { class: "property-section" };
const _hoisted_6$w = { class: "expand-icon" };
const _hoisted_7$w = {
  key: 0,
  class: "section-content"
};
const _hoisted_8$v = {
  key: 0,
  class: "solo-indicator"
};
const _hoisted_9$v = { class: "property-row" };
const _hoisted_10$u = { class: "value-group" };
const _hoisted_11$t = { class: "value-group" };
const _hoisted_12$r = { class: "value-group scale-group" };
const _hoisted_13$r = { class: "property-row" };
const _hoisted_14$n = { class: "value-group" };
const _hoisted_15$m = { class: "property-row" };
const _hoisted_16$l = { class: "value-group" };
const _hoisted_17$k = { class: "property-row" };
const _hoisted_18$j = { class: "value-group" };
const _hoisted_19$j = { class: "property-row" };
const _hoisted_20$j = { class: "value-group" };
const _hoisted_21$i = { class: "value-group" };
const _hoisted_22$h = { class: "value-group opacity-value" };
const _hoisted_23$h = { class: "property-section" };
const _hoisted_24$e = { class: "expand-icon" };
const _hoisted_25$e = {
  key: 0,
  class: "section-content"
};
const _hoisted_26$d = { class: "property-row" };
const _hoisted_27$d = ["value"];
const _hoisted_28$c = ["value"];
const _hoisted_29$c = { class: "property-row" };
const _hoisted_30$b = ["value"];
const _hoisted_31$a = { class: "property-row" };
const _hoisted_32$a = ["checked"];
const _hoisted_33$a = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "PropertiesPanel",
  setup(__props) {
    const soloedProperty = inject("soloedProperty", ref(null));
    const store = useCompositorStore();
    const expandedSections = ref(["transform"]);
    const scaleLocked = ref(true);
    const layerName = ref("");
    const transform = ref({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100, z: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0, z: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    });
    const blendMode = ref("normal");
    const keyframes = ref([]);
    const blendModes = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ];
    const selectedLayer = computed(() => store.selectedLayer);
    const showAnchor = computed(() => {
      const solo = soloedProperty.value;
      if (!solo) return true;
      if (solo === "anchor") return true;
      if (solo === "animated") {
        return selectedLayer.value?.transform?.anchorPoint?.animated || false;
      }
      return false;
    });
    const showPosition = computed(() => {
      const solo = soloedProperty.value;
      if (!solo) return true;
      if (solo === "position") return true;
      if (solo === "animated") {
        return selectedLayer.value?.transform?.position?.animated || false;
      }
      return false;
    });
    const showScale = computed(() => {
      const solo = soloedProperty.value;
      if (!solo) return true;
      if (solo === "scale") return true;
      if (solo === "animated") {
        return selectedLayer.value?.transform?.scale?.animated || false;
      }
      return false;
    });
    const showRotation = computed(() => {
      const solo = soloedProperty.value;
      if (!solo) return true;
      if (solo === "rotation") return true;
      if (solo === "animated") {
        const t = selectedLayer.value?.transform;
        return t?.rotation?.animated || t?.rotationX?.animated || t?.rotationY?.animated || t?.rotationZ?.animated || t?.orientation?.animated || false;
      }
      return false;
    });
    const showOpacity = computed(() => {
      const solo = soloedProperty.value;
      if (!solo) return true;
      if (solo === "opacity") return true;
      if (solo === "animated") {
        return selectedLayer.value?.opacity?.animated || false;
      }
      return false;
    });
    const soloModeActive = computed(() => soloedProperty.value !== null);
    const availableParents = computed(() => {
      if (!selectedLayer.value) return [];
      const selfId = selectedLayer.value.id;
      const getDescendantIds = (layerId) => {
        const children = store.layers.filter((l) => l.parentId === layerId);
        let ids = children.map((c) => c.id);
        for (const child of children) {
          ids = ids.concat(getDescendantIds(child.id));
        }
        return ids;
      };
      const descendantIds = new Set(getDescendantIds(selfId));
      return store.layers.filter(
        (l) => l.id !== selfId && !descendantIds.has(l.id) && l.type !== "camera"
        // Camera layers shouldn't be parents
      );
    });
    const layerPropertiesComponent = computed(() => {
      if (!selectedLayer.value) return null;
      switch (selectedLayer.value.type) {
        case "text":
          return markRaw(TextProperties);
        case "particles":
        case "particle":
          return markRaw(ParticleProperties);
        case "depthflow":
          return markRaw(DepthflowProperties);
        case "light":
          return markRaw(LightProperties);
        case "spline":
          return markRaw(ShapeProperties);
        case "path":
          return markRaw(PathProperties);
        case "video":
          return markRaw(VideoProperties);
        case "camera":
          return markRaw(CameraProperties$1);
        case "nestedComp":
          return markRaw(NestedCompProperties);
        case "model":
        case "pointcloud":
          return markRaw(Model3DProperties);
        case "shape":
          return markRaw(ShapeProperties);
        case "audio":
          return markRaw(AudioProperties);
        case "depth":
          return markRaw(DepthProperties);
        case "normal":
          return markRaw(NormalProperties);
        case "generated":
          return markRaw(GeneratedProperties);
        case "group":
          return markRaw(GroupProperties);
        case "control":
          return markRaw(ControlProperties);
        case "matte":
          return markRaw(MatteProperties);
        case "solid":
        case "image":
        case "null":
          return null;
        default:
          return null;
      }
    });
    function syncTransformFromLayer(layer) {
      if (!layer) return;
      layerName.value = layer.name;
      const t = layer.transform;
      transform.value = {
        position: {
          x: t?.position?.value?.x ?? 0,
          y: t?.position?.value?.y ?? 0,
          z: t?.position?.value?.z ?? 0
        },
        scale: { x: t?.scale?.value?.x ?? 100, y: t?.scale?.value?.y ?? 100, z: t?.scale?.value?.z ?? 100 },
        rotation: t?.rotation?.value ?? 0,
        anchorPoint: { x: t?.anchorPoint?.value?.x ?? 0, y: t?.anchorPoint?.value?.y ?? 0, z: t?.anchorPoint?.value?.z ?? 0 },
        opacity: layer.opacity?.value ?? 100,
        // 3D properties
        orientationX: t?.orientation?.value?.x ?? 0,
        orientationY: t?.orientation?.value?.y ?? 0,
        orientationZ: t?.orientation?.value?.z ?? 0,
        rotationX: t?.rotationX?.value ?? 0,
        rotationY: t?.rotationY?.value ?? 0,
        rotationZ: t?.rotationZ?.value ?? 0
      };
      blendMode.value = layer.blendMode || "normal";
    }
    watch(selectedLayer, (layer) => {
      syncTransformFromLayer(layer);
    }, { immediate: true });
    watch(
      () => selectedLayer.value?.transform,
      () => {
        syncTransformFromLayer(selectedLayer.value);
      },
      { deep: true }
    );
    watch(
      () => selectedLayer.value?.opacity?.value,
      (newVal) => {
        if (newVal !== void 0) {
          transform.value.opacity = newVal;
        }
      }
    );
    watch(() => transform.value.scale.x, (newX, oldX) => {
      if (scaleLocked.value && newX !== oldX) {
        const ratio = newX / oldX;
        transform.value.scale.y = Math.round(transform.value.scale.y * ratio * 10) / 10;
      }
    });
    function toggleSection(section) {
      const index = expandedSections.value.indexOf(section);
      if (index >= 0) {
        expandedSections.value.splice(index, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function updateTransform() {
      if (!selectedLayer.value) return;
      const t = selectedLayer.value.transform;
      const v = transform.value;
      if (t?.position) {
        t.position.value = { x: v.position.x, y: v.position.y, z: v.position.z };
      }
      if (t?.scale) {
        t.scale.value = { x: v.scale.x, y: v.scale.y, z: v.scale.z };
      }
      if (t?.rotation) {
        t.rotation.value = v.rotation;
      }
      if (t?.anchorPoint) {
        t.anchorPoint.value = { x: v.anchorPoint.x, y: v.anchorPoint.y, z: v.anchorPoint.z };
      }
      if (selectedLayer.value.opacity) {
        selectedLayer.value.opacity.value = v.opacity;
      }
      if (selectedLayer.value.threeD) {
        if (t?.orientation) {
          t.orientation.value = { x: v.orientationX, y: v.orientationY, z: v.orientationZ };
        }
        if (t?.rotationX) t.rotationX.value = v.rotationX;
        if (t?.rotationY) t.rotationY.value = v.rotationY;
        if (t?.rotationZ) t.rotationZ.value = v.rotationZ;
      }
      onLayerUpdate();
    }
    function updateBlendMode() {
      if (selectedLayer.value) {
        selectedLayer.value.blendMode = blendMode.value;
      }
    }
    function toggle3D(event) {
      if (!selectedLayer.value) return;
      const threeD = event.target.checked;
      store.updateLayer(selectedLayer.value.id, { threeD });
      if (threeD && selectedLayer.value.transform) {
        const t = selectedLayer.value.transform;
        if (t.position.value.z === void 0) {
          t.position.value.z = 0;
        }
        if (t.scale.value.z === void 0) {
          t.scale.value.z = 100;
        }
        if (t.anchorPoint.value.z === void 0) {
          t.anchorPoint.value.z = 0;
        }
        if (!t.orientation) {
          t.orientation = createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3");
        }
        if (!t.rotationX) {
          t.rotationX = createAnimatableProperty("rotationX", 0, "number");
        }
        if (!t.rotationY) {
          t.rotationY = createAnimatableProperty("rotationY", 0, "number");
        }
        if (!t.rotationZ) {
          t.rotationZ = createAnimatableProperty("rotationZ", 0, "number");
        }
      }
    }
    function hasKeyframe(property) {
      return keyframes.value.includes(property);
    }
    function toggleKeyframe(property) {
      const index = keyframes.value.indexOf(property);
      if (index >= 0) {
        keyframes.value.splice(index, 1);
      } else {
        keyframes.value.push(property);
        console.log(`Added keyframe for ${property} at frame ${store.currentFrame}`);
      }
    }
    function onLayerUpdate(dataUpdates) {
      if (!selectedLayer.value) return;
      if (dataUpdates && Object.keys(dataUpdates).length > 0) {
        store.updateLayerData(selectedLayer.value.id, dataUpdates);
      } else {
        store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    function updateParent(event) {
      if (!selectedLayer.value) return;
      const parentId = event.target.value || null;
      store.setLayerParent(selectedLayer.value.id, parentId);
    }
    function getDriverForProperty(property) {
      if (!selectedLayer.value) return null;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === property && d.sourceType === "property");
      if (driver && driver.sourceLayerId && driver.sourceProperty) {
        return {
          layerId: driver.sourceLayerId,
          property: driver.sourceProperty
        };
      }
      return null;
    }
    function onPropertyLink(targetProperty, source) {
      if (!selectedLayer.value) return;
      store.createPropertyLink(
        selectedLayer.value.id,
        targetProperty,
        source.layerId,
        source.property,
        { blendMode: "add" }
      );
      console.log(`[PropertiesPanel] Linked ${selectedLayer.value.id}.${targetProperty} <- ${source.layerId}.${source.property}`);
    }
    function onPropertyUnlink(targetProperty) {
      if (!selectedLayer.value) return;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === targetProperty && d.sourceType === "property");
      if (driver) {
        store.removePropertyDriver(driver.id);
        console.log(`[PropertiesPanel] Unlinked ${selectedLayer.value.id}.${targetProperty}`);
      }
    }
    function resetTransform() {
      if (!selectedLayer.value) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const centerX = comp.settings.width / 2;
      const centerY = comp.settings.height / 2;
      transform.value.anchorPoint.x = centerX;
      transform.value.anchorPoint.y = centerY;
      transform.value.anchorPoint.z = 0;
      transform.value.position.x = centerX;
      transform.value.position.y = centerY;
      transform.value.position.z = 0;
      transform.value.scale.x = 100;
      transform.value.scale.y = 100;
      transform.value.scale.z = 100;
      transform.value.rotation = 0;
      transform.value.rotationX = 0;
      transform.value.rotationY = 0;
      transform.value.rotationZ = 0;
      transform.value.orientationX = 0;
      transform.value.orientationY = 0;
      transform.value.orientationZ = 0;
      transform.value.opacity = 100;
      updateTransform();
    }
    function hasDriver(property) {
      if (!selectedLayer.value) return false;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      return drivers.some((d) => d.targetProperty === property && d.enabled);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("div", _hoisted_2$w, [
          createBaseVNode("span", _hoisted_3$w, "Properties: " + toDisplayString(selectedLayer.value?.name || "No Selection"), 1)
        ]),
        selectedLayer.value ? (openBlock(), createElementBlock("div", _hoisted_4$w, [
          createBaseVNode("div", _hoisted_5$w, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_6$w, toDisplayString(expandedSections.value.includes("transform") ? "" : ""), 1),
              _cache[32] || (_cache[32] = createBaseVNode("span", { class: "section-title" }, "Layer Transform", -1)),
              createBaseVNode("span", {
                class: "reset-link",
                onClick: withModifiers(resetTransform, ["stop"])
              }, "Reset")
            ]),
            expandedSections.value.includes("transform") ? (openBlock(), createElementBlock("div", _hoisted_7$w, [
              soloModeActive.value ? (openBlock(), createElementBlock("div", _hoisted_8$v, [
                createTextVNode(" Showing: " + toDisplayString(unref(soloedProperty) === "animated" ? "Animated Properties" : unref(soloedProperty)?.charAt(0).toUpperCase() + unref(soloedProperty)?.slice(1)) + " ", 1),
                _cache[33] || (_cache[33] = createBaseVNode("span", { class: "solo-hint" }, "(Press same key to show all)", -1))
              ])) : createCommentVNode("", true),
              withDirectives(createBaseVNode("div", _hoisted_9$v, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("anchorPoint") }]),
                  onClick: _cache[1] || (_cache[1] = ($event) => toggleKeyframe("anchorPoint"))
                }, "", 2),
                _cache[34] || (_cache[34] = createBaseVNode("label", null, "Anchor Point", -1)),
                createBaseVNode("div", _hoisted_10$u, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      _cache[2] || (_cache[2] = ($event) => transform.value.anchorPoint.x = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      _cache[3] || (_cache[3] = ($event) => transform.value.anchorPoint.y = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.anchorPoint.z,
                    "onUpdate:modelValue": [
                      _cache[4] || (_cache[4] = ($event) => transform.value.anchorPoint.z = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ], 512), [
                [vShow, showAnchor.value]
              ]),
              withDirectives(createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.position.x") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("position") }]),
                  onClick: _cache[5] || (_cache[5] = ($event) => toggleKeyframe("position"))
                }, "", 2),
                selectedLayer.value ? (openBlock(), createBlock(PropertyLink, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.position.x",
                  linkedTo: getDriverForProperty("transform.position.x"),
                  onLink: _cache[6] || (_cache[6] = (target) => onPropertyLink("transform.position.x", target)),
                  onUnlink: _cache[7] || (_cache[7] = () => onPropertyUnlink("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[35] || (_cache[35] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_11$t, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.x,
                    "onUpdate:modelValue": [
                      _cache[8] || (_cache[8] = ($event) => transform.value.position.x = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.y,
                    "onUpdate:modelValue": [
                      _cache[9] || (_cache[9] = ($event) => transform.value.position.y = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.position.z,
                    "onUpdate:modelValue": [
                      _cache[10] || (_cache[10] = ($event) => transform.value.position.z = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ], 2), [
                [vShow, showPosition.value]
              ]),
              withDirectives(createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.scale.x") || hasDriver("transform.scale.y") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("scale") }]),
                  onClick: _cache[11] || (_cache[11] = ($event) => toggleKeyframe("scale"))
                }, "", 2),
                _cache[36] || (_cache[36] = createBaseVNode("label", null, "Scale", -1)),
                createBaseVNode("div", _hoisted_12$r, [
                  createBaseVNode("button", {
                    class: normalizeClass(["link-btn", { active: scaleLocked.value }]),
                    onClick: _cache[12] || (_cache[12] = ($event) => scaleLocked.value = !scaleLocked.value),
                    title: "Constrain Proportions"
                  }, toDisplayString(scaleLocked.value ? "" : ""), 3),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.x,
                    "onUpdate:modelValue": [
                      _cache[13] || (_cache[13] = ($event) => transform.value.scale.x = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.y,
                    "onUpdate:modelValue": [
                      _cache[14] || (_cache[14] = ($event) => transform.value.scale.y = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.scale.z,
                    "onUpdate:modelValue": [
                      _cache[15] || (_cache[15] = ($event) => transform.value.scale.z = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ], 2), [
                [vShow, showScale.value]
              ]),
              selectedLayer.value?.threeD ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                withDirectives(createBaseVNode("div", _hoisted_13$r, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("orientation") }]),
                    onClick: _cache[16] || (_cache[16] = ($event) => toggleKeyframe("orientation"))
                  }, "", 2),
                  _cache[37] || (_cache[37] = createBaseVNode("label", null, "Orientation", -1)),
                  createBaseVNode("div", _hoisted_14$n, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationX,
                      "onUpdate:modelValue": [
                        _cache[17] || (_cache[17] = ($event) => transform.value.orientationX = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationY,
                      "onUpdate:modelValue": [
                        _cache[18] || (_cache[18] = ($event) => transform.value.orientationY = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationZ,
                      "onUpdate:modelValue": [
                        _cache[19] || (_cache[19] = ($event) => transform.value.orientationZ = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ], 512), [
                  [vShow, showRotation.value]
                ]),
                withDirectives(createBaseVNode("div", _hoisted_15$m, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationX") }]),
                    onClick: _cache[20] || (_cache[20] = ($event) => toggleKeyframe("rotationX"))
                  }, "", 2),
                  _cache[38] || (_cache[38] = createBaseVNode("label", null, "X Rotation", -1)),
                  createBaseVNode("div", _hoisted_16$l, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationX,
                      "onUpdate:modelValue": [
                        _cache[21] || (_cache[21] = ($event) => transform.value.rotationX = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ], 512), [
                  [vShow, showRotation.value]
                ]),
                withDirectives(createBaseVNode("div", _hoisted_17$k, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationY") }]),
                    onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("rotationY"))
                  }, "", 2),
                  _cache[39] || (_cache[39] = createBaseVNode("label", null, "Y Rotation", -1)),
                  createBaseVNode("div", _hoisted_18$j, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationY,
                      "onUpdate:modelValue": [
                        _cache[23] || (_cache[23] = ($event) => transform.value.rotationY = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ], 512), [
                  [vShow, showRotation.value]
                ]),
                withDirectives(createBaseVNode("div", _hoisted_19$j, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationZ") }]),
                    onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("rotationZ"))
                  }, "", 2),
                  _cache[40] || (_cache[40] = createBaseVNode("label", null, "Z Rotation", -1)),
                  createBaseVNode("div", _hoisted_20$j, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationZ,
                      "onUpdate:modelValue": [
                        _cache[25] || (_cache[25] = ($event) => transform.value.rotationZ = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ], 512), [
                  [vShow, showRotation.value]
                ])
              ], 64)) : withDirectives((openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.rotation") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotation") }]),
                  onClick: _cache[26] || (_cache[26] = ($event) => toggleKeyframe("rotation"))
                }, "", 2),
                _cache[41] || (_cache[41] = createBaseVNode("label", null, "Rotation", -1)),
                createBaseVNode("div", _hoisted_21$i, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.rotation,
                    "onUpdate:modelValue": [
                      _cache[27] || (_cache[27] = ($event) => transform.value.rotation = $event),
                      updateTransform
                    ],
                    suffix: ""
                  }, null, 8, ["modelValue"])
                ])
              ], 2)), [
                [vShow, showRotation.value]
              ]),
              withDirectives(createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("opacity") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("opacity") }]),
                  onClick: _cache[28] || (_cache[28] = ($event) => toggleKeyframe("opacity"))
                }, "", 2),
                _cache[42] || (_cache[42] = createBaseVNode("label", null, "Opacity", -1)),
                createBaseVNode("div", _hoisted_22$h, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.opacity,
                    "onUpdate:modelValue": [
                      _cache[29] || (_cache[29] = ($event) => transform.value.opacity = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 100,
                    suffix: "%"
                  }, null, 8, ["modelValue"])
                ])
              ], 2), [
                [vShow, showOpacity.value]
              ])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_23$h, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[30] || (_cache[30] = ($event) => toggleSection("options"))
            }, [
              createBaseVNode("span", _hoisted_24$e, toDisplayString(expandedSections.value.includes("options") ? "" : ""), 1),
              _cache[43] || (_cache[43] = createBaseVNode("span", { class: "section-title" }, "Layer Options", -1))
            ]),
            expandedSections.value.includes("options") ? (openBlock(), createElementBlock("div", _hoisted_25$e, [
              createBaseVNode("div", _hoisted_26$d, [
                _cache[45] || (_cache[45] = createBaseVNode("label", null, "Parent", -1)),
                createBaseVNode("select", {
                  class: "parent-select",
                  value: selectedLayer.value?.parentId || "",
                  onChange: updateParent
                }, [
                  _cache[44] || (_cache[44] = createBaseVNode("option", { value: "" }, "None", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (parent) => {
                    return openBlock(), createElementBlock("option", {
                      key: parent.id,
                      value: parent.id
                    }, toDisplayString(parent.name), 9, _hoisted_28$c);
                  }), 128))
                ], 40, _hoisted_27$d)
              ]),
              createBaseVNode("div", _hoisted_29$c, [
                _cache[46] || (_cache[46] = createBaseVNode("label", null, "Blend Mode", -1)),
                withDirectives(createBaseVNode("select", {
                  class: "blend-select",
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => blendMode.value = $event),
                  onChange: updateBlendMode
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(blendModes, (mode) => {
                    return createBaseVNode("option", {
                      key: mode.value,
                      value: mode.value
                    }, toDisplayString(mode.label), 9, _hoisted_30$b);
                  }), 64))
                ], 544), [
                  [vModelSelect, blendMode.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_31$a, [
                _cache[47] || (_cache[47] = createBaseVNode("label", null, "3D Layer", -1)),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: selectedLayer.value?.threeD,
                  onChange: toggle3D,
                  class: "checkbox-input"
                }, null, 40, _hoisted_32$a)
              ])
            ])) : createCommentVNode("", true)
          ]),
          layerPropertiesComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(layerPropertiesComponent.value), {
            key: 0,
            layer: selectedLayer.value,
            onUpdate: onLayerUpdate
          }, null, 40, ["layer"])) : createCommentVNode("", true),
          selectedLayer.value ? (openBlock(), createBlock(DriverList, {
            key: 1,
            layerId: selectedLayer.value.id
          }, null, 8, ["layerId"])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_33$a, [..._cache[48] || (_cache[48] = [
          createBaseVNode("p", null, "No layer selected", -1),
          createBaseVNode("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
});

const PropertiesPanel = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-73cde0f2"]]);

const _hoisted_1$v = { class: "camera-properties" };
const _hoisted_2$v = { class: "panel-header" };
const _hoisted_3$v = { class: "camera-name" };
const _hoisted_4$v = {
  key: 0,
  class: "properties-content"
};
const _hoisted_5$v = { class: "property-section" };
const _hoisted_6$v = { class: "property-row" };
const _hoisted_7$v = ["value"];
const _hoisted_8$u = { class: "property-section" };
const _hoisted_9$u = { class: "toggle-icon" };
const _hoisted_10$t = { class: "section-content" };
const _hoisted_11$s = { class: "property-group" };
const _hoisted_12$q = { class: "xyz-inputs" };
const _hoisted_13$q = {
  key: 0,
  class: "property-group"
};
const _hoisted_14$m = { class: "xyz-inputs" };
const _hoisted_15$l = { class: "property-group" };
const _hoisted_16$k = { class: "xyz-inputs" };
const _hoisted_17$j = { class: "property-group" };
const _hoisted_18$i = { class: "property-group" };
const _hoisted_19$i = { class: "property-group" };
const _hoisted_20$i = { class: "property-section" };
const _hoisted_21$h = { class: "toggle-icon" };
const _hoisted_22$g = { class: "section-content" };
const _hoisted_23$g = { class: "preset-row" };
const _hoisted_24$d = ["onClick"];
const _hoisted_25$d = { class: "property-group" };
const _hoisted_26$c = { class: "property-group" };
const _hoisted_27$c = { class: "property-group" };
const _hoisted_28$b = { class: "property-group" };
const _hoisted_29$b = ["value"];
const _hoisted_30$a = { class: "property-section" };
const _hoisted_31$9 = { class: "toggle-icon" };
const _hoisted_32$9 = { class: "section-content" };
const _hoisted_33$9 = { class: "property-group checkbox-group" };
const _hoisted_34$9 = ["checked"];
const _hoisted_35$8 = { class: "property-group" };
const _hoisted_36$7 = { class: "property-group" };
const _hoisted_37$7 = { class: "property-group" };
const _hoisted_38$7 = { class: "property-group checkbox-group" };
const _hoisted_39$7 = ["checked"];
const _hoisted_40$6 = { class: "property-section" };
const _hoisted_41$4 = { class: "toggle-icon" };
const _hoisted_42$3 = { class: "section-content" };
const _hoisted_43$3 = { class: "property-group" };
const _hoisted_44$3 = { class: "property-group" };
const _hoisted_45$3 = { class: "property-group" };
const _hoisted_46$3 = { class: "property-group" };
const _hoisted_47$3 = { class: "property-group" };
const _hoisted_48$3 = { class: "property-section" };
const _hoisted_49$3 = { class: "toggle-icon" };
const _hoisted_50$2 = { class: "section-content" };
const _hoisted_51$2 = { class: "property-group" };
const _hoisted_52$2 = { class: "property-group" };
const _hoisted_53$2 = { class: "property-group" };
const _hoisted_54$2 = { class: "property-section" };
const _hoisted_55$2 = { class: "toggle-icon" };
const _hoisted_56$2 = { class: "section-content" };
const _hoisted_57$2 = { class: "property-group" };
const _hoisted_58$2 = ["value"];
const _hoisted_59$2 = { class: "property-section" };
const _hoisted_60$1 = { class: "toggle-icon" };
const _hoisted_61$1 = { class: "section-content" };
const _hoisted_62$1 = { class: "property-group" };
const _hoisted_63 = { class: "property-group" };
const _hoisted_64 = { class: "property-section" };
const _hoisted_65 = { class: "toggle-icon" };
const _hoisted_66 = { class: "section-content" };
const _hoisted_67 = { class: "property-group" };
const _hoisted_68 = ["label"];
const _hoisted_69 = ["value"];
const _hoisted_70 = { class: "trajectory-description" };
const _hoisted_71 = { class: "property-group" };
const _hoisted_72 = { class: "property-group" };
const _hoisted_73 = {
  key: 0,
  class: "property-group"
};
const _hoisted_74 = { class: "property-group" };
const _hoisted_75 = { class: "property-group checkbox-group" };
const _hoisted_76 = { class: "property-group" };
const _hoisted_77 = { class: "property-group" };
const _hoisted_78 = { class: "property-section" };
const _hoisted_79 = { class: "toggle-icon" };
const _hoisted_80 = { class: "section-content" };
const _hoisted_81 = { class: "property-group" };
const _hoisted_82 = { class: "shake-description" };
const _hoisted_83 = { class: "property-group" };
const _hoisted_84 = { class: "property-group" };
const _hoisted_85 = { class: "property-group" };
const _hoisted_86 = { class: "property-group checkbox-group" };
const _hoisted_87 = {
  key: 0,
  class: "property-group"
};
const _hoisted_88 = { class: "property-group" };
const _hoisted_89 = { class: "property-group" };
const _hoisted_90 = {
  key: 1,
  class: "no-camera"
};
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "camera" && selectedLayer.data) {
        const cameraData = selectedLayer.data;
        return store.getCamera(cameraData.cameraId);
      }
      return store.activeCamera;
    });
    const expandedSections = reactive({
      transform: true,
      lens: true,
      dof: false,
      iris: false,
      highlight: false,
      autoOrient: false,
      clipping: false,
      trajectory: false,
      shake: false
    });
    const trajectoryConfig = reactive({
      ...DEFAULT_TRAJECTORY
    });
    const shakeConfig = reactive({
      ...DEFAULT_SHAKE_CONFIG
    });
    ref(false);
    const shakeDuration = ref(81);
    let activeCameraShake = null;
    const trajectoryTypesByCategory = computed(() => getTrajectoryTypesByCategory());
    const trajectoryDescription = computed(() => getTrajectoryDescription(trajectoryConfig.type));
    const isOrbitalTrajectory = computed(() => {
      const orbitalTypes = ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"];
      return orbitalTypes.includes(trajectoryConfig.type);
    });
    function formatTrajectoryName(type) {
      return type.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    }
    const previewAnimationId = ref(null);
    function previewTrajectory() {
      if (!camera.value) return;
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
      const startTime = performance.now();
      const duration = trajectoryConfig.duration / 30 * 1e3;
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
        )
      };
      function animate() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const { position, target } = getTrajectoryPosition(config, t);
        store.updateCamera(camera.value.id, {
          position,
          pointOfInterest: target
        });
        if (t < 1) {
          previewAnimationId.value = requestAnimationFrame(animate);
        } else {
          previewAnimationId.value = null;
        }
      }
      animate();
    }
    function applyTrajectory() {
      if (!camera.value) return;
      const baseDistance = Math.sqrt(
        Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
      );
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance
      };
      const keyframes = generateTrajectoryKeyframes(config, store.currentFrame);
      for (const kf of keyframes.position) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          position: kf.position,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      for (const kf of keyframes.pointOfInterest) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          pointOfInterest: kf.pointOfInterest,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      if (keyframes.zoom) {
        for (const kf of keyframes.zoom) {
          store.addCameraKeyframe(camera.value.id, {
            frame: kf.frame,
            zoom: kf.zoom,
            temporalInterpolation: kf.temporalInterpolation
          });
        }
      }
      console.log(`Applied ${keyframes.position.length} camera trajectory keyframes`);
    }
    function applyShakePreset(preset) {
      const presetConfig = SHAKE_PRESETS[preset];
      Object.assign(shakeConfig, presetConfig, { type: preset });
    }
    function previewShake() {
      if (!camera.value) return;
      activeCameraShake = createCameraShake(
        shakeConfig.type,
        shakeConfig,
        store.currentFrame,
        shakeDuration.value
      );
      const originalPosition = { ...camera.value.position };
      const originalOrientation = { ...camera.value.orientation };
      const startTime = performance.now();
      const duration = shakeDuration.value / 30 * 1e3;
      function animate() {
        const elapsed = performance.now() - startTime;
        const frame = Math.floor(elapsed / 1e3 * 30) + store.currentFrame;
        if (elapsed < duration && activeCameraShake) {
          const offset = activeCameraShake.getOffset(frame);
          store.updateCamera(camera.value.id, {
            position: {
              x: originalPosition.x + offset.position.x,
              y: originalPosition.y + offset.position.y,
              z: originalPosition.z + offset.position.z
            },
            orientation: {
              x: originalOrientation.x + offset.rotation.x,
              y: originalOrientation.y + offset.rotation.y,
              z: originalOrientation.z + offset.rotation.z
            }
          });
          requestAnimationFrame(animate);
        } else {
          store.updateCamera(camera.value.id, {
            position: originalPosition,
            orientation: originalOrientation
          });
          activeCameraShake = null;
        }
      }
      requestAnimationFrame(animate);
    }
    function applyShakeKeyframes() {
      if (!camera.value) return;
      const shake = createCameraShake(
        shakeConfig.type,
        shakeConfig,
        store.currentFrame,
        shakeDuration.value
      );
      const existingKeyframes = camera.value.keyframes || [];
      const shakenKeyframes = shake.generateKeyframes(existingKeyframes, 2);
      for (const kf of shakenKeyframes) {
        store.addCameraKeyframe(camera.value.id, kf);
      }
      console.log(`Applied ${shakenKeyframes.length} camera shake keyframes`);
    }
    function toggleSection(section) {
      expandedSections[section] = !expandedSections[section];
    }
    function updateProperty(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, { [key]: value });
    }
    function updatePosition(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        position: { ...camera.value.position, [axis]: value }
      });
    }
    function updatePOI(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        pointOfInterest: { ...camera.value.pointOfInterest, [axis]: value }
      });
    }
    function updateOrientation(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        orientation: { ...camera.value.orientation, [axis]: value }
      });
    }
    function updateFocalLength(value) {
      if (!camera.value) return;
      const angleOfView = focalLengthToFOV(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        focalLength: value,
        angleOfView
      });
    }
    function updateAngleOfView(value) {
      if (!camera.value) return;
      const focalLength = fovToFocalLength(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        angleOfView: value,
        focalLength
      });
    }
    function updateDOF(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        depthOfField: { ...camera.value.depthOfField, [key]: value }
      });
    }
    function updateIris(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        iris: { ...camera.value.iris, [key]: value }
      });
    }
    function updateHighlight(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        highlight: { ...camera.value.highlight, [key]: value }
      });
    }
    function applyPreset(preset) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        focalLength: preset.focalLength,
        angleOfView: preset.angleOfView,
        zoom: preset.zoom
      });
    }
    function createCamera() {
      store.createCameraLayer();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$v, [
        createBaseVNode("div", _hoisted_2$v, [
          _cache[57] || (_cache[57] = createBaseVNode("span", { class: "panel-title" }, "Camera", -1)),
          createBaseVNode("span", _hoisted_3$v, toDisplayString(camera.value?.name ?? "No Camera"), 1)
        ]),
        camera.value ? (openBlock(), createElementBlock("div", _hoisted_4$v, [
          createBaseVNode("div", _hoisted_5$v, [
            _cache[59] || (_cache[59] = createBaseVNode("div", { class: "section-header" }, "Type", -1)),
            createBaseVNode("div", _hoisted_6$v, [
              createBaseVNode("select", {
                value: camera.value.type,
                onChange: _cache[0] || (_cache[0] = ($event) => updateProperty("type", $event.target.value)),
                class: "type-select"
              }, [..._cache[58] || (_cache[58] = [
                createBaseVNode("option", { value: "one-node" }, "One-Node Camera", -1),
                createBaseVNode("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, _hoisted_7$v)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$u, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_9$u, toDisplayString(expandedSections.transform ? "" : ""), 1),
              _cache[60] || (_cache[60] = createTextVNode(" Transform ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_10$t, [
              createBaseVNode("div", _hoisted_11$s, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_12$q, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updatePosition("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updatePosition("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.z,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updatePosition("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              camera.value.type === "two-node" ? (openBlock(), createElementBlock("div", _hoisted_13$q, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Point of Interest", -1)),
                createBaseVNode("div", _hoisted_14$m, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updatePOI("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updatePOI("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.z,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => updatePOI("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_15$l, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Orientation", -1)),
                createBaseVNode("div", _hoisted_16$k, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.x,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateOrientation("x", v)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.y,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateOrientation("y", v)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.z,
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateOrientation("z", v)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$j, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "X Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.xRotation,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateProperty("xRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_18$i, [
                _cache[65] || (_cache[65] = createBaseVNode("label", null, "Y Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.yRotation,
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateProperty("yRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$i, [
                _cache[66] || (_cache[66] = createBaseVNode("label", null, "Z Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.zRotation,
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateProperty("zRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.transform]
            ])
          ]),
          createBaseVNode("div", _hoisted_20$i, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("lens"))
            }, [
              createBaseVNode("span", _hoisted_21$h, toDisplayString(expandedSections.lens ? "" : ""), 1),
              _cache[67] || (_cache[67] = createTextVNode(" Lens ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_22$g, [
              createBaseVNode("div", _hoisted_23$g, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(CAMERA_PRESETS), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.name,
                    class: normalizeClass({ active: Math.abs(camera.value.focalLength - preset.focalLength) < 0.5 }),
                    onClick: ($event) => applyPreset(preset)
                  }, toDisplayString(preset.name), 11, _hoisted_24$d);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_25$d, [
                _cache[68] || (_cache[68] = createBaseVNode("label", null, "Focal Length", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.focalLength,
                  "onUpdate:modelValue": updateFocalLength,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_26$c, [
                _cache[69] || (_cache[69] = createBaseVNode("label", null, "Angle of View", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.angleOfView,
                  "onUpdate:modelValue": updateAngleOfView,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_27$c, [
                _cache[70] || (_cache[70] = createBaseVNode("label", null, "Film Size", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.filmSize,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateProperty("filmSize", v)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_28$b, [
                _cache[72] || (_cache[72] = createBaseVNode("label", null, "Measure Film Size", -1)),
                createBaseVNode("select", {
                  value: camera.value.measureFilmSize,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateProperty("measureFilmSize", $event.target.value))
                }, [..._cache[71] || (_cache[71] = [
                  createBaseVNode("option", { value: "horizontal" }, "Horizontal", -1),
                  createBaseVNode("option", { value: "vertical" }, "Vertical", -1),
                  createBaseVNode("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, _hoisted_29$b)
              ])
            ], 512), [
              [vShow, expandedSections.lens]
            ])
          ]),
          createBaseVNode("div", _hoisted_30$a, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[17] || (_cache[17] = ($event) => toggleSection("dof"))
            }, [
              createBaseVNode("span", _hoisted_31$9, toDisplayString(expandedSections.dof ? "" : ""), 1),
              _cache[73] || (_cache[73] = createTextVNode(" Depth of Field ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_32$9, [
              createBaseVNode("div", _hoisted_33$9, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: camera.value.depthOfField.enabled,
                    onChange: _cache[18] || (_cache[18] = ($event) => updateDOF("enabled", $event.target.checked))
                  }, null, 40, _hoisted_34$9),
                  _cache[74] || (_cache[74] = createTextVNode(" Enable DOF ", -1))
                ])
              ]),
              camera.value.depthOfField.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_35$8, [
                  _cache[75] || (_cache[75] = createBaseVNode("label", null, "Focus Distance", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updateDOF("focusDistance", v)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_36$7, [
                  _cache[76] || (_cache[76] = createBaseVNode("label", null, "f-Stop", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.fStop,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateDOF("fStop", v)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_37$7, [
                  _cache[77] || (_cache[77] = createBaseVNode("label", null, "Blur Level", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: camera.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateDOF("blurLevel", v)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_38$7, [
                  createBaseVNode("label", null, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: camera.value.depthOfField.lockToZoom,
                      onChange: _cache[22] || (_cache[22] = ($event) => updateDOF("lockToZoom", $event.target.checked))
                    }, null, 40, _hoisted_39$7),
                    _cache[78] || (_cache[78] = createTextVNode(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : createCommentVNode("", true)
            ], 512), [
              [vShow, expandedSections.dof]
            ])
          ]),
          createBaseVNode("div", _hoisted_40$6, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[23] || (_cache[23] = ($event) => toggleSection("iris"))
            }, [
              createBaseVNode("span", _hoisted_41$4, toDisplayString(expandedSections.iris ? "" : ""), 1),
              _cache[79] || (_cache[79] = createTextVNode(" Iris ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_42$3, [
              createBaseVNode("div", _hoisted_43$3, [
                createBaseVNode("label", null, "Shape (" + toDisplayString(Math.round(camera.value.iris.shape)) + "-gon)", 1),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.shape,
                  "onUpdate:modelValue": _cache[24] || (_cache[24] = (v) => updateIris("shape", v)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_44$3, [
                _cache[80] || (_cache[80] = createBaseVNode("label", null, "Rotation", -1)),
                createVNode(unref(AngleDial), {
                  modelValue: camera.value.iris.rotation,
                  "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateIris("rotation", v)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_45$3, [
                _cache[81] || (_cache[81] = createBaseVNode("label", null, "Roundness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.roundness,
                  "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateIris("roundness", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_46$3, [
                _cache[82] || (_cache[82] = createBaseVNode("label", null, "Aspect Ratio", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.aspectRatio,
                  "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateIris("aspectRatio", v)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_47$3, [
                _cache[83] || (_cache[83] = createBaseVNode("label", null, "Diffraction Fringe", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.diffractionFringe,
                  "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateIris("diffractionFringe", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.iris]
            ])
          ]),
          createBaseVNode("div", _hoisted_48$3, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("highlight"))
            }, [
              createBaseVNode("span", _hoisted_49$3, toDisplayString(expandedSections.highlight ? "" : ""), 1),
              _cache[84] || (_cache[84] = createTextVNode(" Highlight ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_50$2, [
              createBaseVNode("div", _hoisted_51$2, [
                _cache[85] || (_cache[85] = createBaseVNode("label", null, "Gain", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.gain,
                  "onUpdate:modelValue": _cache[30] || (_cache[30] = (v) => updateHighlight("gain", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_52$2, [
                _cache[86] || (_cache[86] = createBaseVNode("label", null, "Threshold", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.threshold,
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateHighlight("threshold", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_53$2, [
                _cache[87] || (_cache[87] = createBaseVNode("label", null, "Saturation", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.saturation,
                  "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateHighlight("saturation", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.highlight]
            ])
          ]),
          createBaseVNode("div", _hoisted_54$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[33] || (_cache[33] = ($event) => toggleSection("autoOrient"))
            }, [
              createBaseVNode("span", _hoisted_55$2, toDisplayString(expandedSections.autoOrient ? "" : ""), 1),
              _cache[88] || (_cache[88] = createTextVNode(" Auto-Orient ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_56$2, [
              createBaseVNode("div", _hoisted_57$2, [
                createBaseVNode("select", {
                  value: camera.value.autoOrient,
                  onChange: _cache[34] || (_cache[34] = ($event) => updateProperty("autoOrient", $event.target.value))
                }, [..._cache[89] || (_cache[89] = [
                  createBaseVNode("option", { value: "off" }, "Off", -1),
                  createBaseVNode("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  createBaseVNode("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, _hoisted_58$2)
              ])
            ], 512), [
              [vShow, expandedSections.autoOrient]
            ])
          ]),
          createBaseVNode("div", _hoisted_59$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[35] || (_cache[35] = ($event) => toggleSection("clipping"))
            }, [
              createBaseVNode("span", _hoisted_60$1, toDisplayString(expandedSections.clipping ? "" : ""), 1),
              _cache[90] || (_cache[90] = createTextVNode(" Clipping ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_61$1, [
              createBaseVNode("div", _hoisted_62$1, [
                _cache[91] || (_cache[91] = createBaseVNode("label", null, "Near Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.nearClip,
                  "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateProperty("nearClip", v)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_63, [
                _cache[92] || (_cache[92] = createBaseVNode("label", null, "Far Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.farClip,
                  "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateProperty("farClip", v)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.clipping]
            ])
          ]),
          createBaseVNode("div", _hoisted_64, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[38] || (_cache[38] = ($event) => toggleSection("trajectory"))
            }, [
              createBaseVNode("span", _hoisted_65, toDisplayString(expandedSections.trajectory ? "" : ""), 1),
              _cache[93] || (_cache[93] = createTextVNode(" Trajectory ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_66, [
              createBaseVNode("div", _hoisted_67, [
                _cache[94] || (_cache[94] = createBaseVNode("label", null, "Motion Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[39] || (_cache[39] = ($event) => trajectoryConfig.type = $event),
                  class: "trajectory-select"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(trajectoryTypesByCategory.value, (types, category) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: category,
                      label: category
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(types, (type) => {
                        return openBlock(), createElementBlock("option", {
                          key: type,
                          value: type
                        }, toDisplayString(formatTrajectoryName(type)), 9, _hoisted_69);
                      }), 128))
                    ], 8, _hoisted_68);
                  }), 128))
                ], 512), [
                  [vModelSelect, trajectoryConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_70, toDisplayString(trajectoryDescription.value), 1),
              createBaseVNode("div", _hoisted_71, [
                _cache[95] || (_cache[95] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.duration,
                  "onUpdate:modelValue": _cache[40] || (_cache[40] = (v) => trajectoryConfig.duration = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_72, [
                _cache[96] || (_cache[96] = createBaseVNode("label", null, "Amplitude", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: Math.abs(trajectoryConfig.amplitude),
                  "onUpdate:modelValue": _cache[41] || (_cache[41] = (v) => trajectoryConfig.amplitude = v * Math.sign(trajectoryConfig.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              isOrbitalTrajectory.value ? (openBlock(), createElementBlock("div", _hoisted_73, [
                _cache[97] || (_cache[97] = createBaseVNode("label", null, "Loops", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.loops,
                  "onUpdate:modelValue": _cache[42] || (_cache[42] = (v) => trajectoryConfig.loops = v),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_74, [
                _cache[99] || (_cache[99] = createBaseVNode("label", null, "Easing", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => trajectoryConfig.easing = $event)
                }, [..._cache[98] || (_cache[98] = [
                  createStaticVNode('<option value="linear" data-v-6f99837e>Linear</option><option value="ease-in" data-v-6f99837e>Ease In</option><option value="ease-out" data-v-6f99837e>Ease Out</option><option value="ease-in-out" data-v-6f99837e>Ease In-Out</option><option value="bounce" data-v-6f99837e>Bounce</option>', 5)
                ])], 512), [
                  [vModelSelect, trajectoryConfig.easing]
                ])
              ]),
              createBaseVNode("div", _hoisted_75, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => trajectoryConfig.audioReactive = $event)
                  }, null, 512), [
                    [vModelCheckbox, trajectoryConfig.audioReactive]
                  ]),
                  _cache[100] || (_cache[100] = createTextVNode(" Audio Reactive ", -1))
                ])
              ]),
              trajectoryConfig.audioReactive ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_76, [
                  _cache[102] || (_cache[102] = createBaseVNode("label", null, "Audio Feature", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[45] || (_cache[45] = ($event) => trajectoryConfig.audioFeature = $event)
                  }, [..._cache[101] || (_cache[101] = [
                    createStaticVNode('<option value="amplitude" data-v-6f99837e>Amplitude</option><option value="bass" data-v-6f99837e>Bass</option><option value="mid" data-v-6f99837e>Mid</option><option value="high" data-v-6f99837e>High</option><option value="onsets" data-v-6f99837e>Onsets</option>', 5)
                  ])], 512), [
                    [vModelSelect, trajectoryConfig.audioFeature]
                  ])
                ]),
                createBaseVNode("div", _hoisted_77, [
                  _cache[103] || (_cache[103] = createBaseVNode("label", null, "Sensitivity", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: trajectoryConfig.audioSensitivity ?? 1,
                    "onUpdate:modelValue": _cache[46] || (_cache[46] = (v) => trajectoryConfig.audioSensitivity = v),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("div", { class: "trajectory-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewTrajectory
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyTrajectory
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.trajectory]
            ])
          ]),
          createBaseVNode("div", _hoisted_78, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[47] || (_cache[47] = ($event) => toggleSection("shake"))
            }, [
              createBaseVNode("span", _hoisted_79, toDisplayString(expandedSections.shake ? "" : ""), 1),
              _cache[104] || (_cache[104] = createTextVNode(" Camera Shake ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_80, [
              createBaseVNode("div", _hoisted_81, [
                _cache[106] || (_cache[106] = createBaseVNode("label", null, "Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[48] || (_cache[48] = ($event) => shakeConfig.type = $event),
                  onChange: _cache[49] || (_cache[49] = ($event) => applyShakePreset(shakeConfig.type))
                }, [..._cache[105] || (_cache[105] = [
                  createStaticVNode('<option value="handheld" data-v-6f99837e>Handheld</option><option value="subtle" data-v-6f99837e>Subtle</option><option value="impact" data-v-6f99837e>Impact</option><option value="earthquake" data-v-6f99837e>Earthquake</option><option value="custom" data-v-6f99837e>Custom</option>', 5)
                ])], 544), [
                  [vModelSelect, shakeConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_82, [
                shakeConfig.type === "handheld" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode("Simulates natural handheld camera movement")
                ], 64)) : shakeConfig.type === "subtle" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode("Gentle shake for atmospheric tension")
                ], 64)) : shakeConfig.type === "impact" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createTextVNode("Sharp, sudden shake for impacts or explosions")
                ], 64)) : shakeConfig.type === "earthquake" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                  createTextVNode("Violent, sustained shaking")
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                  createTextVNode("Custom shake parameters")
                ], 64))
              ]),
              createBaseVNode("div", _hoisted_83, [
                _cache[107] || (_cache[107] = createBaseVNode("label", null, "Intensity", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.intensity,
                  "onUpdate:modelValue": _cache[50] || (_cache[50] = (v) => shakeConfig.intensity = v),
                  min: 0,
                  max: 1,
                  step: 0.05
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_84, [
                _cache[108] || (_cache[108] = createBaseVNode("label", null, "Frequency", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.frequency,
                  "onUpdate:modelValue": _cache[51] || (_cache[51] = (v) => shakeConfig.frequency = v),
                  min: 0.1,
                  max: 5,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_85, [
                _cache[109] || (_cache[109] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: shakeDuration.value,
                  "onUpdate:modelValue": _cache[52] || (_cache[52] = (v) => shakeDuration.value = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_86, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[53] || (_cache[53] = ($event) => shakeConfig.rotationEnabled = $event)
                  }, null, 512), [
                    [vModelCheckbox, shakeConfig.rotationEnabled]
                  ]),
                  _cache[110] || (_cache[110] = createTextVNode(" Rotation Shake ", -1))
                ])
              ]),
              shakeConfig.rotationEnabled ? (openBlock(), createElementBlock("div", _hoisted_87, [
                _cache[111] || (_cache[111] = createBaseVNode("label", null, "Rotation Scale", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.rotationScale,
                  "onUpdate:modelValue": _cache[54] || (_cache[54] = (v) => shakeConfig.rotationScale = v),
                  min: 0,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_88, [
                _cache[112] || (_cache[112] = createBaseVNode("label", null, "Decay", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.decay,
                  "onUpdate:modelValue": _cache[55] || (_cache[55] = (v) => shakeConfig.decay = v),
                  min: 0,
                  max: 1,
                  step: 0.05
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_89, [
                _cache[113] || (_cache[113] = createBaseVNode("label", null, "Seed", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: shakeConfig.seed,
                  "onUpdate:modelValue": _cache[56] || (_cache[56] = (v) => shakeConfig.seed = v),
                  min: 0,
                  max: 99999,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", { class: "shake-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewShake
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyShakeKeyframes
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.shake]
            ])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_90, [
          _cache[114] || (_cache[114] = createBaseVNode("p", null, "No camera selected", -1)),
          createBaseVNode("button", { onClick: createCamera }, "Create Camera")
        ]))
      ]);
    };
  }
});

const CameraProperties = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-6f99837e"]]);

const _hoisted_1$u = { class: "audio-panel" };
const _hoisted_2$u = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$u = { class: "audio-info" };
const _hoisted_4$u = { class: "file-info" };
const _hoisted_5$u = { class: "file-details" };
const _hoisted_6$u = { class: "file-name" };
const _hoisted_7$u = { class: "file-meta" };
const _hoisted_8$t = { class: "control-section" };
const _hoisted_9$t = { class: "control-row" };
const _hoisted_10$s = { class: "waveform-section" };
const _hoisted_11$r = { class: "waveform-display" };
const _hoisted_12$p = { class: "linker-section" };
const _hoisted_13$p = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "AudioPanel",
  setup(__props) {
    const store = useCompositorStore();
    const audioFileInput = ref(null);
    const waveformCanvas = ref(null);
    const masterVolume = computed({
      get: () => store.audioVolume,
      set: (val) => store.setAudioVolume(val)
    });
    const isMuted = computed({
      get: () => store.audioMuted,
      set: (val) => store.setAudioMuted(val)
    });
    const hasAudio = computed(() => !!store.audioBuffer);
    const audioFileName = computed(() => store.audioFile?.name || "Unknown");
    const audioSampleRate = computed(() => store.audioBuffer ? `${(store.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "");
    const audioDuration = computed(() => {
      if (!store.audioBuffer) return "0:00";
      const m = Math.floor(store.audioBuffer.duration / 60);
      const s = Math.floor(store.audioBuffer.duration % 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    });
    function loadAudioFile() {
      audioFileInput.value?.click();
    }
    async function handleAudioFileSelected(e) {
      const input = e.target;
      if (input.files?.length) await store.loadAudio(input.files[0]);
      input.value = "";
    }
    function removeAudio() {
      store.clearAudio();
    }
    function toggleMute() {
      store.toggleAudioMute();
    }
    function drawWaveform() {
      if (!waveformCanvas.value || !store.audioBuffer) return;
      const canvas = waveformCanvas.value;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 60 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      const data = store.audioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / rect.width);
      const amp = 30;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, rect.width, 60);
      ctx.beginPath();
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1;
      for (let i = 0; i < rect.width; i++) {
        let min = 1;
        let max = -1;
        for (let j = 0; j < step; j++) {
          const datum = data[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.stroke();
      const px = store.currentFrame / store.frameCount * rect.width;
      ctx.fillStyle = "#fff";
      ctx.fillRect(px, 0, 1, 60);
    }
    watch(() => [store.audioBuffer, store.currentFrame], drawWaveform);
    onMounted(() => {
      if (hasAudio.value) {
        setTimeout(drawWaveform, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$u, [
        createBaseVNode("div", { class: "panel-header" }, [
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "panel-title" }, "Audio Source", -1)),
          createBaseVNode("div", { class: "header-actions" }, [
            createBaseVNode("button", {
              onClick: loadAudioFile,
              title: "Load Audio"
            }, [..._cache[1] || (_cache[1] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ])
        ]),
        hasAudio.value ? (openBlock(), createElementBlock("div", _hoisted_2$u, [
          createBaseVNode("div", _hoisted_3$u, [
            createBaseVNode("div", _hoisted_4$u, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "file-icon" }, "", -1)),
              createBaseVNode("div", _hoisted_5$u, [
                createBaseVNode("span", _hoisted_6$u, toDisplayString(audioFileName.value), 1),
                createBaseVNode("span", _hoisted_7$u, toDisplayString(audioDuration.value) + "  " + toDisplayString(audioSampleRate.value), 1)
              ]),
              createBaseVNode("button", {
                class: "remove-btn",
                onClick: removeAudio,
                title: "Remove Audio"
              }, "")
            ])
          ]),
          createBaseVNode("div", _hoisted_8$t, [
            createBaseVNode("div", _hoisted_9$t, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Master Vol", -1)),
              createVNode(unref(SliderInput), {
                modelValue: masterVolume.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => masterVolume.value = $event),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["mute-btn", { active: isMuted.value }]),
                onClick: toggleMute,
                title: "Mute"
              }, toDisplayString(isMuted.value ? "" : ""), 3)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$s, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Waveform")
            ], -1)),
            createBaseVNode("div", _hoisted_11$r, [
              createBaseVNode("canvas", {
                ref_key: "waveformCanvas",
                ref: waveformCanvas,
                class: "waveform-canvas"
              }, null, 512)
            ])
          ]),
          createBaseVNode("div", _hoisted_12$p, [
            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "linker-header" }, "Audio Linker", -1)),
            createVNode(AudioProperties)
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_13$p, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "empty-icon" }, "", -1)),
          _cache[8] || (_cache[8] = createBaseVNode("p", null, "No audio loaded", -1)),
          createBaseVNode("button", {
            class: "load-btn",
            onClick: loadAudioFile
          }, "Load Audio File"),
          _cache[9] || (_cache[9] = createBaseVNode("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
        ])),
        createBaseVNode("input", {
          ref_key: "audioFileInput",
          ref: audioFileInput,
          type: "file",
          accept: "audio/*",
          style: { "display": "none" },
          onChange: handleAudioFileSelected
        }, null, 544)
      ]);
    };
  }
});

const AudioPanel = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-63f3ca66"]]);

const _hoisted_1$t = {
  key: 0,
  class: "texture-preview"
};
const _hoisted_2$t = ["src", "alt"];
const _hoisted_3$t = { class: "texture-info" };
const _hoisted_4$t = { class: "texture-name" };
const _hoisted_5$t = { class: "texture-size" };
const _hoisted_6$t = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_7$t = { class: "map-label" };
const _hoisted_8$s = {
  key: 0,
  class: "texture-settings"
};
const _hoisted_9$s = { class: "setting-row" };
const _hoisted_10$r = { class: "repeat-inputs" };
const _hoisted_11$q = { class: "setting-row" };
const _hoisted_12$o = { class: "offset-inputs" };
const _hoisted_13$o = {
  key: 0,
  class: "setting-row"
};
const acceptedFormats = "image/png,image/jpeg,image/webp,image/exr";
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "TextureUpload",
  props: {
    mapType: {},
    textureUrl: {},
    textureName: {},
    repeatX: {},
    repeatY: {},
    offsetX: {},
    offsetY: {},
    normalScale: {},
    showSettings: { type: Boolean }
  },
  emits: ["upload", "remove", "update:repeatX", "update:repeatY", "update:offsetX", "update:offsetY", "update:normalScale"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const previewUrl = ref(props.textureUrl || "");
    const textureSize = ref("");
    const mapLabels = {
      albedo: "Albedo / Color",
      normal: "Normal Map",
      roughness: "Roughness",
      metalness: "Metalness",
      ao: "Ambient Occlusion",
      emissive: "Emissive",
      height: "Height / Displacement",
      opacity: "Opacity / Alpha",
      specular: "Specular"
    };
    const mapLabel = computed(() => mapLabels[props.mapType] || props.mapType);
    const hasTexture = computed(() => !!previewUrl.value || !!props.textureUrl);
    function openFilePicker() {
      fileInput.value?.click();
    }
    function onDragOver(e) {
      isDragging.value = true;
    }
    function onDragLeave(e) {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        handleFile(input.files[0]);
      }
    }
    function handleFile(file) {
      if (!file.type.startsWith("image/")) {
        console.warn("Invalid file type:", file.type);
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target?.result;
        previewUrl.value = dataUrl;
        const img = new Image();
        img.onload = () => {
          textureSize.value = `${img.width} x ${img.height}`;
        };
        img.src = dataUrl;
        emit("upload", file, dataUrl);
      };
      reader.readAsDataURL(file);
    }
    function removeTexture() {
      previewUrl.value = "";
      textureSize.value = "";
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["texture-upload", { "has-texture": hasTexture.value, "drag-over": isDragging.value }])
      }, [
        createBaseVNode("div", {
          class: "upload-zone",
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasTexture.value ? (openBlock(), createElementBlock("div", _hoisted_1$t, [
            createBaseVNode("img", {
              src: previewUrl.value,
              alt: __props.mapType
            }, null, 8, _hoisted_2$t),
            createBaseVNode("div", _hoisted_3$t, [
              createBaseVNode("span", _hoisted_4$t, toDisplayString(__props.textureName), 1),
              createBaseVNode("span", _hoisted_5$t, toDisplayString(textureSize.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeTexture, ["stop"]),
              title: "Remove texture"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_6$t, [
            _cache[6] || (_cache[6] = createBaseVNode("i", { class: "pi pi-image" }, null, -1)),
            createBaseVNode("span", _hoisted_7$t, toDisplayString(mapLabel.value), 1),
            _cache[7] || (_cache[7] = createBaseVNode("span", { class: "hint" }, "Click or drop image", -1))
          ]))
        ], 32),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 544),
        hasTexture.value && __props.showSettings ? (openBlock(), createElementBlock("div", _hoisted_8$s, [
          createBaseVNode("div", _hoisted_9$s, [
            _cache[9] || (_cache[9] = createBaseVNode("label", null, "Repeat", -1)),
            createBaseVNode("div", _hoisted_10$r, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatX,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:repeatX", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"]),
              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "separator" }, "x", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatY,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:repeatY", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$q, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Offset", -1)),
            createBaseVNode("div", _hoisted_12$o, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetX,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:offsetX", $event)),
                step: 0.01
              }, null, 8, ["modelValue"]),
              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "separator" }, ",", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetY,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:offsetY", $event)),
                step: 0.01
              }, null, 8, ["modelValue"])
            ])
          ]),
          __props.mapType === "normal" ? (openBlock(), createElementBlock("div", _hoisted_13$o, [
            _cache[12] || (_cache[12] = createBaseVNode("label", null, "Strength", -1)),
            createVNode(unref(SliderInput), {
              modelValue: __props.normalScale,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:normalScale", $event)),
              min: 0,
              max: 2,
              step: 0.1
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const TextureUpload = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-fccc4721"]]);

const _hoisted_1$s = { class: "material-editor" };
const _hoisted_2$s = { class: "editor-header" };
const _hoisted_3$s = ["value"];
const _hoisted_4$s = { class: "property-section" };
const _hoisted_5$s = { class: "section-content" };
const _hoisted_6$s = { class: "property-group" };
const _hoisted_7$s = { class: "property-group" };
const _hoisted_8$r = { class: "property-group" };
const _hoisted_9$r = { class: "property-group" };
const _hoisted_10$q = { class: "property-row checkbox-row" };
const _hoisted_11$p = ["checked"];
const _hoisted_12$n = { class: "property-section" };
const _hoisted_13$n = { class: "section-content" };
const _hoisted_14$l = { class: "property-group" };
const _hoisted_15$k = { class: "property-group" };
const _hoisted_16$j = { class: "property-section" };
const _hoisted_17$i = { class: "section-content" };
const _hoisted_18$h = { class: "texture-grid" };
const _hoisted_19$h = {
  key: 0,
  class: "texture-global-settings"
};
const _hoisted_20$h = { class: "setting-row" };
const _hoisted_21$g = { class: "repeat-inputs" };
const _hoisted_22$f = { class: "property-section" };
const _hoisted_23$f = { class: "section-content" };
const _hoisted_24$c = { class: "property-group" };
const _hoisted_25$c = { class: "property-row checkbox-row" };
const _hoisted_26$b = ["checked"];
const _hoisted_27$b = { class: "property-row checkbox-row" };
const _hoisted_28$a = ["checked"];
const _hoisted_29$a = { class: "property-row" };
const _hoisted_30$9 = ["value"];
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "MaterialEditor",
  props: {
    modelValue: {},
    layerId: {},
    materialId: {},
    config: {}
  },
  emits: ["update:modelValue", "save-preset", "update", "texture-upload"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultMaterial = {
      color: "#ffffff",
      metalness: 0,
      roughness: 0.5,
      opacity: 1,
      transparent: false,
      emissive: "#000000",
      emissiveIntensity: 0,
      normalScale: 1,
      envMapIntensity: 1,
      flatShading: false,
      wireframe: false,
      side: "front",
      maps: {},
      textureRepeat: { x: 1, y: 1 }
    };
    const presets = [
      {
        id: "chrome",
        name: "Chrome",
        config: { color: "#ffffff", metalness: 1, roughness: 0.1 }
      },
      {
        id: "gold",
        name: "Gold",
        config: { color: "#ffd700", metalness: 1, roughness: 0.2 }
      },
      {
        id: "copper",
        name: "Copper",
        config: { color: "#b87333", metalness: 1, roughness: 0.3 }
      },
      {
        id: "plastic",
        name: "Plastic",
        config: { color: "#ffffff", metalness: 0, roughness: 0.4 }
      },
      {
        id: "rubber",
        name: "Rubber",
        config: { color: "#222222", metalness: 0, roughness: 0.9 }
      },
      {
        id: "glass",
        name: "Glass",
        config: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true }
      },
      {
        id: "emissive",
        name: "Emissive",
        config: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2, metalness: 0, roughness: 0.5 }
      },
      {
        id: "matte",
        name: "Matte",
        config: { color: "#cccccc", metalness: 0, roughness: 1 }
      }
    ];
    const material = reactive({ ...defaultMaterial, ...props.modelValue, ...props.config });
    const selectedPreset = ref("");
    const sections = reactive({
      basic: true,
      emissive: false,
      textures: true,
      environment: false
    });
    const hasAnyTexture = computed(() => {
      return Object.values(material.maps).some((url) => !!url);
    });
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    function toggleSection(section) {
      sections[section] = !sections[section];
    }
    function updateMaterial(key, value) {
      material[key] = value;
      selectedPreset.value = "";
      emitUpdate();
    }
    function updateTextureRepeat(axis, value) {
      material.textureRepeat[axis] = value;
      emitUpdate();
    }
    function uploadTexture(mapType, file, dataUrl) {
      material.maps[mapType] = dataUrl;
      emitUpdate();
      emit("texture-upload", mapType, file);
    }
    function removeTexture(mapType) {
      delete material.maps[mapType];
      emitUpdate();
    }
    function applyPreset() {
      if (!selectedPreset.value) return;
      const preset = presets.find((p) => p.id === selectedPreset.value);
      if (preset) {
        Object.assign(material, { ...defaultMaterial, ...preset.config });
        emitUpdate();
      }
    }
    function resetMaterial() {
      Object.assign(material, defaultMaterial);
      selectedPreset.value = "";
      emitUpdate();
    }
    function saveMaterial() {
      const name = prompt("Enter preset name:");
      if (name) {
        emit("save-preset", name, { ...material });
      }
    }
    function emitUpdate() {
      emit("update:modelValue", { ...material });
      emit("update", { ...material });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$s, [
        createBaseVNode("div", _hoisted_2$s, [
          _cache[36] || (_cache[36] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-palette" }),
            createBaseVNode("span", null, "Material")
          ], -1)),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
            onChange: applyPreset,
            class: "preset-select"
          }, [
            _cache[35] || (_cache[35] = createBaseVNode("option", { value: "" }, "Custom", -1)),
            (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
              return createBaseVNode("option", {
                key: preset.id,
                value: preset.id
              }, toDisplayString(preset.name), 9, _hoisted_3$s);
            }), 64))
          ], 544), [
            [vModelSelect, selectedPreset.value]
          ])
        ]),
        createBaseVNode("div", _hoisted_4$s, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("basic"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.basic ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[37] || (_cache[37] = createBaseVNode("span", null, "Basic Properties", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_5$s, [
            createBaseVNode("div", _hoisted_6$s, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Base Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.color,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateMaterial("color", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$s, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Metalness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.metalness,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateMaterial("metalness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_8$r, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Roughness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.roughness,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => updateMaterial("roughness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_9$r, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.opacity,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateMaterial("opacity", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_10$q, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.transparent,
                  onChange: _cache[6] || (_cache[6] = ($event) => updateMaterial("transparent", $event.target.checked))
                }, null, 40, _hoisted_11$p),
                _cache[42] || (_cache[42] = createTextVNode(" Transparent ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.basic]
          ])
        ]),
        createBaseVNode("div", _hoisted_12$n, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("emissive"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.emissive ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[43] || (_cache[43] = createBaseVNode("span", null, "Emissive", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_13$n, [
            createBaseVNode("div", _hoisted_14$l, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Emissive Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.emissive,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => updateMaterial("emissive", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$k, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.emissiveIntensity,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => updateMaterial("emissiveIntensity", $event)),
                min: 0,
                max: 5,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ], 512), [
            [vShow, sections.emissive]
          ])
        ]),
        createBaseVNode("div", _hoisted_16$j, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("textures"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.textures ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[46] || (_cache[46] = createBaseVNode("span", null, "Texture Maps", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_17$i, [
            createBaseVNode("div", _hoisted_18$h, [
              createVNode(TextureUpload, {
                mapType: "albedo",
                textureUrl: material.maps?.albedo,
                onUpload: _cache[11] || (_cache[11] = (file, dataUrl) => uploadTexture("albedo", file, dataUrl)),
                onRemove: _cache[12] || (_cache[12] = ($event) => removeTexture("albedo"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "normal",
                textureUrl: material.maps?.normal,
                normalScale: material.normalScale,
                showSettings: !!material.maps?.normal,
                onUpload: _cache[13] || (_cache[13] = (file, dataUrl) => uploadTexture("normal", file, dataUrl)),
                onRemove: _cache[14] || (_cache[14] = ($event) => removeTexture("normal")),
                "onUpdate:normalScale": _cache[15] || (_cache[15] = ($event) => updateMaterial("normalScale", $event))
              }, null, 8, ["textureUrl", "normalScale", "showSettings"]),
              createVNode(TextureUpload, {
                mapType: "roughness",
                textureUrl: material.maps?.roughness,
                onUpload: _cache[16] || (_cache[16] = (file, dataUrl) => uploadTexture("roughness", file, dataUrl)),
                onRemove: _cache[17] || (_cache[17] = ($event) => removeTexture("roughness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "metalness",
                textureUrl: material.maps?.metalness,
                onUpload: _cache[18] || (_cache[18] = (file, dataUrl) => uploadTexture("metalness", file, dataUrl)),
                onRemove: _cache[19] || (_cache[19] = ($event) => removeTexture("metalness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "ao",
                textureUrl: material.maps?.ao,
                onUpload: _cache[20] || (_cache[20] = (file, dataUrl) => uploadTexture("ao", file, dataUrl)),
                onRemove: _cache[21] || (_cache[21] = ($event) => removeTexture("ao"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "emissive",
                textureUrl: material.maps?.emissive,
                onUpload: _cache[22] || (_cache[22] = (file, dataUrl) => uploadTexture("emissive", file, dataUrl)),
                onRemove: _cache[23] || (_cache[23] = ($event) => removeTexture("emissive"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "height",
                textureUrl: material.maps?.height,
                onUpload: _cache[24] || (_cache[24] = (file, dataUrl) => uploadTexture("height", file, dataUrl)),
                onRemove: _cache[25] || (_cache[25] = ($event) => removeTexture("height"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "opacity",
                textureUrl: material.maps?.opacity,
                onUpload: _cache[26] || (_cache[26] = (file, dataUrl) => uploadTexture("opacity", file, dataUrl)),
                onRemove: _cache[27] || (_cache[27] = ($event) => removeTexture("opacity"))
              }, null, 8, ["textureUrl"])
            ]),
            hasAnyTexture.value ? (openBlock(), createElementBlock("div", _hoisted_19$h, [
              createBaseVNode("div", _hoisted_20$h, [
                _cache[48] || (_cache[48] = createBaseVNode("label", null, "UV Repeat", -1)),
                createBaseVNode("div", _hoisted_21$g, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.x ?? 1,
                    "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => updateTextureRepeat("x", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"]),
                  _cache[47] || (_cache[47] = createBaseVNode("span", { class: "separator" }, "x", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.y ?? 1,
                    "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => updateTextureRepeat("y", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ])
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, sections.textures]
          ])
        ]),
        createBaseVNode("div", _hoisted_22$f, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[30] || (_cache[30] = ($event) => toggleSection("environment"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.environment ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[49] || (_cache[49] = createBaseVNode("span", null, "Environment", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_23$f, [
            createBaseVNode("div", _hoisted_24$c, [
              _cache[50] || (_cache[50] = createBaseVNode("label", null, "Environment Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.envMapIntensity,
                "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => updateMaterial("envMapIntensity", $event)),
                min: 0,
                max: 3,
                step: 0.1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.flatShading,
                  onChange: _cache[32] || (_cache[32] = ($event) => updateMaterial("flatShading", $event.target.checked))
                }, null, 40, _hoisted_26$b),
                _cache[51] || (_cache[51] = createTextVNode(" Flat Shading ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_27$b, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.wireframe,
                  onChange: _cache[33] || (_cache[33] = ($event) => updateMaterial("wireframe", $event.target.checked))
                }, null, 40, _hoisted_28$a),
                _cache[52] || (_cache[52] = createTextVNode(" Wireframe ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$a, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Side", -1)),
              createBaseVNode("select", {
                value: material.side,
                onChange: _cache[34] || (_cache[34] = ($event) => updateMaterial("side", $event.target.value)),
                class: "type-select"
              }, [..._cache[53] || (_cache[53] = [
                createBaseVNode("option", { value: "front" }, "Front", -1),
                createBaseVNode("option", { value: "back" }, "Back", -1),
                createBaseVNode("option", { value: "double" }, "Double", -1)
              ])], 40, _hoisted_30$9)
            ])
          ], 512), [
            [vShow, sections.environment]
          ])
        ]),
        createBaseVNode("div", { class: "editor-actions" }, [
          createBaseVNode("button", {
            class: "action-btn",
            onClick: resetMaterial
          }, [..._cache[55] || (_cache[55] = [
            createBaseVNode("i", { class: "pi pi-refresh" }, null, -1),
            createTextVNode(" Reset ", -1)
          ])]),
          createBaseVNode("button", {
            class: "action-btn primary",
            onClick: saveMaterial
          }, [..._cache[56] || (_cache[56] = [
            createBaseVNode("i", { class: "pi pi-save" }, null, -1),
            createTextVNode(" Save as Preset ", -1)
          ])])
        ])
      ]);
    };
  }
});

const MaterialEditor = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-1b454841"]]);

const _hoisted_1$r = { class: "asset-uploader" };
const _hoisted_2$r = {
  key: 0,
  class: "asset-preview"
};
const _hoisted_3$r = { class: "preview-content" };
const _hoisted_4$r = ["src"];
const _hoisted_5$r = {
  key: 1,
  class: "preview-icon"
};
const _hoisted_6$r = { class: "asset-info" };
const _hoisted_7$r = { class: "asset-name" };
const _hoisted_8$q = { class: "asset-meta" };
const _hoisted_9$q = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_10$p = { class: "upload-label" };
const _hoisted_11$o = { class: "upload-hint" };
const _hoisted_12$m = { class: "upload-formats" };
const _hoisted_13$m = ["accept", "multiple"];
const _hoisted_14$k = {
  key: 0,
  class: "upload-progress"
};
const _hoisted_15$j = { class: "progress-bar" };
const _hoisted_16$i = { class: "progress-text" };
const _hoisted_17$h = {
  key: 1,
  class: "error-message"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "AssetUploader",
  props: {
    assetType: { default: "image" },
    label: {},
    multiple: { type: Boolean, default: false },
    maxSizeMB: { default: 100 },
    accept: {},
    buttonText: {}
  },
  emits: ["upload", "upload-multiple", "remove", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const isLoading = ref(false);
    const progress = ref(0);
    const progressText = ref("");
    const errorMessage = ref("");
    const assetName = ref("");
    const assetMeta = ref("");
    const previewImage = ref(null);
    const hasAsset = ref(false);
    const assetConfigs = {
      model: {
        formats: [".gltf", ".glb", ".obj", ".fbx", ".dae", ".usdz"],
        icon: "pi-box",
        hint: "Drop 3D model file"
      },
      pointcloud: {
        formats: [".ply", ".pcd", ".xyz", ".pts", ".las"],
        icon: "pi-th-large",
        hint: "Drop point cloud file"
      },
      texture: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".exr", ".hdr"],
        icon: "pi-image",
        hint: "Drop texture image"
      },
      material: {
        formats: [".json", ".mtl"],
        icon: "pi-palette",
        hint: "Drop material file"
      },
      hdri: {
        formats: [".hdr", ".exr", ".jpg", ".png"],
        icon: "pi-globe",
        hint: "Drop HDRI environment"
      },
      svg: {
        formats: [".svg"],
        icon: "pi-star",
        hint: "Drop SVG file"
      },
      spritesheet: {
        formats: [".png", ".jpg", ".webp", ".json"],
        icon: "pi-th-large",
        hint: "Drop sprite sheet"
      },
      lut: {
        formats: [".cube", ".3dl", ".png"],
        icon: "pi-sliders-h",
        hint: "Drop LUT file"
      },
      depth_map: {
        formats: [".png", ".jpg", ".exr"],
        icon: "pi-map",
        hint: "Drop depth map"
      },
      image: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".gif"],
        icon: "pi-image",
        hint: "Drop image file"
      },
      video: {
        formats: [".mp4", ".webm", ".mov"],
        icon: "pi-video",
        hint: "Drop video file"
      },
      audio: {
        formats: [".mp3", ".wav", ".ogg", ".m4a"],
        icon: "pi-volume-up",
        hint: "Drop audio file"
      }
    };
    const config = computed(() => assetConfigs[props.assetType] || assetConfigs.image);
    const acceptedFormats = computed(() => {
      if (props.accept) {
        return props.accept;
      }
      const formats = config.value.formats;
      return formats.map((f) => {
        if (f === ".jpg") return "image/jpeg";
        if (f === ".png") return "image/png";
        if (f === ".webp") return "image/webp";
        if (f === ".gif") return "image/gif";
        if (f === ".svg") return "image/svg+xml";
        if (f === ".mp4") return "video/mp4";
        if (f === ".webm") return "video/webm";
        if (f === ".mp3") return "audio/mpeg";
        if (f === ".wav") return "audio/wav";
        if (f === ".ogg") return "audio/ogg";
        return f;
      }).join(",");
    });
    const acceptedFormatsDisplay = computed(() => {
      return config.value.formats.join(", ");
    });
    const placeholderIcon = computed(() => config.value.icon);
    const hint = computed(() => config.value.hint);
    const label = computed(() => props.buttonText || props.label || `Upload ${props.assetType}`);
    const assetTypeIcon = computed(() => {
      return config.value.icon;
    });
    function openFilePicker() {
      if (hasAsset.value) return;
      fileInput.value?.click();
    }
    function onDragOver() {
      isDragging.value = true;
    }
    function onDragLeave() {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(files));
        } else {
          handleFile(files[0]);
        }
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(input.files));
        } else {
          handleFile(input.files[0]);
        }
      }
    }
    async function handleFile(file) {
      errorMessage.value = "";
      const sizeMB = file.size / (1024 * 1024);
      if (sizeMB > props.maxSizeMB) {
        errorMessage.value = `File too large (max ${props.maxSizeMB}MB)`;
        emit("error", errorMessage.value);
        return;
      }
      const ext = "." + file.name.split(".").pop()?.toLowerCase();
      const validFormats = props.accept ? props.accept.split(",").map((f) => f.trim().toLowerCase()) : config.value.formats;
      const isValidExt = validFormats.some((f) => f === ext || f.includes("*") || f.includes("/"));
      if (!isValidExt && !props.accept) {
        errorMessage.value = `Invalid format. Accepted: ${acceptedFormatsDisplay.value}`;
        emit("error", errorMessage.value);
        return;
      }
      const mimeTypeMap = {
        // Images
        ".png": ["image/png"],
        ".jpg": ["image/jpeg"],
        ".jpeg": ["image/jpeg"],
        ".gif": ["image/gif"],
        ".webp": ["image/webp"],
        ".svg": ["image/svg+xml"],
        ".exr": ["image/x-exr", "application/octet-stream"],
        // EXR often has generic MIME
        ".hdr": ["image/vnd.radiance", "application/octet-stream"],
        // Video
        ".mp4": ["video/mp4"],
        ".webm": ["video/webm"],
        ".mov": ["video/quicktime"],
        // Audio
        ".mp3": ["audio/mpeg"],
        ".wav": ["audio/wav", "audio/wave", "audio/x-wav"],
        ".ogg": ["audio/ogg", "application/ogg"],
        ".m4a": ["audio/mp4", "audio/x-m4a"],
        // 3D Models
        ".gltf": ["model/gltf+json", "application/json"],
        ".glb": ["model/gltf-binary", "application/octet-stream"],
        ".obj": ["text/plain", "application/octet-stream"],
        ".fbx": ["application/octet-stream"],
        // Data files
        ".json": ["application/json", "text/json"],
        ".cube": ["text/plain", "application/octet-stream"],
        // LUT files
        // Fonts
        ".ttf": ["font/ttf", "application/x-font-ttf"],
        ".otf": ["font/otf", "application/x-font-otf"],
        ".woff": ["font/woff", "application/font-woff"],
        ".woff2": ["font/woff2", "application/font-woff2"]
      };
      const expectedMimes = mimeTypeMap[ext];
      if (expectedMimes && file.type && !expectedMimes.includes(file.type) && !file.type.includes("octet-stream")) {
        errorMessage.value = `File type mismatch: expected ${expectedMimes.join(" or ")}, got ${file.type}`;
        emit("error", errorMessage.value);
        return;
      }
      isLoading.value = true;
      progress.value = 0;
      progressText.value = "Loading...";
      try {
        let dataUrl;
        if (file.type.startsWith("image/")) {
          dataUrl = await readFileAsDataUrl(file);
          previewImage.value = dataUrl;
        } else {
          previewImage.value = null;
        }
        assetName.value = file.name;
        assetMeta.value = formatFileSize(file.size);
        hasAsset.value = true;
        emit("upload", file, dataUrl);
      } catch (err) {
        errorMessage.value = "Failed to load file";
        emit("error", errorMessage.value);
      } finally {
        isLoading.value = false;
      }
    }
    function handleMultipleFiles(files) {
      const validFiles = files.filter((file) => {
        const ext = "." + file.name.split(".").pop()?.toLowerCase();
        const sizeMB = file.size / (1024 * 1024);
        return config.value.formats.includes(ext) && sizeMB <= props.maxSizeMB;
      });
      if (validFiles.length === 0) {
        errorMessage.value = "No valid files found";
        emit("error", errorMessage.value);
        return;
      }
      emit("upload-multiple", validFiles);
      assetName.value = `${validFiles.length} files`;
      assetMeta.value = formatFileSize(validFiles.reduce((sum, f) => sum + f.size, 0));
      hasAsset.value = true;
    }
    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.onprogress = (e) => {
          if (e.lengthComputable) {
            progress.value = Math.round(e.loaded / e.total * 100);
            progressText.value = `${progress.value}%`;
          }
        };
        reader.readAsDataURL(file);
      });
    }
    function formatFileSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
    function removeAsset() {
      hasAsset.value = false;
      assetName.value = "";
      assetMeta.value = "";
      previewImage.value = null;
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        createBaseVNode("div", {
          class: normalizeClass(["drop-zone", { "drag-over": isDragging.value, "has-asset": hasAsset.value }]),
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasAsset.value ? (openBlock(), createElementBlock("div", _hoisted_2$r, [
            createBaseVNode("div", _hoisted_3$r, [
              previewImage.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: previewImage.value,
                class: "preview-image"
              }, null, 8, _hoisted_4$r)) : (openBlock(), createElementBlock("div", _hoisted_5$r, [
                createBaseVNode("i", {
                  class: normalizeClass(["pi", assetTypeIcon.value])
                }, null, 2)
              ]))
            ]),
            createBaseVNode("div", _hoisted_6$r, [
              createBaseVNode("span", _hoisted_7$r, toDisplayString(assetName.value), 1),
              createBaseVNode("span", _hoisted_8$q, toDisplayString(assetMeta.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeAsset, ["stop"]),
              title: "Remove"
            }, [..._cache[0] || (_cache[0] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_9$q, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", placeholderIcon.value])
            }, null, 2),
            createBaseVNode("span", _hoisted_10$p, toDisplayString(label.value), 1),
            createBaseVNode("span", _hoisted_11$o, toDisplayString(hint.value), 1),
            createBaseVNode("span", _hoisted_12$m, toDisplayString(acceptedFormatsDisplay.value), 1)
          ]))
        ], 34),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats.value,
          multiple: __props.multiple,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 40, _hoisted_13$m),
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_14$k, [
          createBaseVNode("div", _hoisted_15$j, [
            createBaseVNode("div", {
              class: "progress-fill",
              style: normalizeStyle({ width: `${progress.value}%` })
            }, null, 4)
          ]),
          createBaseVNode("span", _hoisted_16$i, toDisplayString(progressText.value), 1)
        ])) : createCommentVNode("", true),
        errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_17$h, [
          _cache[1] || (_cache[1] = createBaseVNode("i", { class: "pi pi-exclamation-triangle" }, null, -1)),
          createTextVNode(" " + toDisplayString(errorMessage.value), 1)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetUploader = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-d42b9f28"]]);

const _hoisted_1$q = { class: "environment-settings" };
const _hoisted_2$q = { class: "settings-header" };
const _hoisted_3$q = { class: "enable-toggle" };
const _hoisted_4$q = ["checked"];
const _hoisted_5$q = {
  key: 0,
  class: "settings-content"
};
const _hoisted_6$q = { class: "setting-group" };
const _hoisted_7$q = {
  key: 0,
  class: "setting-group"
};
const _hoisted_8$p = { class: "preset-grid" };
const _hoisted_9$p = ["onClick"];
const _hoisted_10$o = { class: "setting-group" };
const _hoisted_11$n = { class: "setting-group" };
const _hoisted_12$l = { class: "rotation-control" };
const _hoisted_13$l = { class: "setting-group" };
const _hoisted_14$j = { class: "checkbox-label" };
const _hoisted_15$i = ["checked"];
const _hoisted_16$h = {
  key: 1,
  class: "setting-group"
};
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "EnvironmentSettings",
  props: {
    modelValue: {},
    config: {}
  },
  emits: ["update:modelValue", "load-hdri", "update", "load", "clear"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultConfig = {
      enabled: false,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true,
      toneMapping: true
    };
    const configState = reactive({ ...defaultConfig, ...props.modelValue, ...props.config });
    const selectedPreset = ref(null);
    const config = configState;
    const presets = [
      { id: "studio", name: "Studio", color: "linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%)" },
      { id: "outdoor", name: "Outdoor", color: "linear-gradient(135deg, #87CEEB 0%, #98D8C8 100%)" },
      { id: "sunset", name: "Sunset", color: "linear-gradient(135deg, #ff6b6b 0%, #ffa600 100%)" },
      { id: "night", name: "Night", color: "linear-gradient(135deg, #1a1a3e 0%, #0d0d1a 100%)" }
    ];
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    function updateConfig(key, value) {
      configState[key] = value;
      emitUpdate();
    }
    function onHdriUpload(file, dataUrl) {
      if (dataUrl) {
        configState.url = dataUrl;
        selectedPreset.value = null;
        emitUpdate();
        emit("load-hdri", dataUrl);
        emit("load", file);
      }
    }
    function onHdriRemove() {
      configState.url = void 0;
      emitUpdate();
      emit("clear");
    }
    function applyPreset(preset) {
      selectedPreset.value = preset.id;
      if (preset.url) {
        configState.url = preset.url;
        emit("load-hdri", preset.url);
      }
      emitUpdate();
    }
    function emitUpdate() {
      emit("update:modelValue", { ...configState });
      emit("update", { ...configState });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$q, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-globe" }),
            createBaseVNode("span", null, "Environment")
          ], -1)),
          createBaseVNode("label", _hoisted_3$q, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: unref(config).enabled,
              onChange: _cache[0] || (_cache[0] = ($event) => updateConfig("enabled", $event.target.checked))
            }, null, 40, _hoisted_4$q),
            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "toggle-label" }, "Enabled", -1))
          ])
        ]),
        unref(config).enabled ? (openBlock(), createElementBlock("div", _hoisted_5$q, [
          createBaseVNode("div", _hoisted_6$q, [
            _cache[8] || (_cache[8] = createBaseVNode("label", { class: "group-label" }, "Environment Map (HDRI)", -1)),
            createVNode(AssetUploader, {
              assetType: "hdri",
              label: "Upload HDRI",
              onUpload: onHdriUpload,
              onRemove: onHdriRemove
            })
          ]),
          !unref(config).url ? (openBlock(), createElementBlock("div", _hoisted_7$q, [
            _cache[9] || (_cache[9] = createBaseVNode("label", { class: "group-label" }, "Quick Presets", -1)),
            createBaseVNode("div", _hoisted_8$p, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.id,
                  class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                  onClick: ($event) => applyPreset(preset)
                }, [
                  createBaseVNode("div", {
                    class: "preset-preview",
                    style: normalizeStyle({ background: preset.color })
                  }, null, 4),
                  createBaseVNode("span", null, toDisplayString(preset.name), 1)
                ], 10, _hoisted_9$p);
              }), 64))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_10$o, [
            _cache[10] || (_cache[10] = createBaseVNode("label", null, "Intensity", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).intensity,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => updateConfig("intensity", $event)),
              min: 0,
              max: 3,
              step: 0.1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_11$n, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Rotation", -1)),
            createBaseVNode("div", _hoisted_12$l, [
              createVNode(unref(AngleDial), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateConfig("rotation", $event)),
                size: 36
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateConfig("rotation", $event)),
                unit: ""
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_13$l, [
            createBaseVNode("label", _hoisted_14$j, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: unref(config).useAsBackground,
                onChange: _cache[4] || (_cache[4] = ($event) => updateConfig("useAsBackground", $event.target.checked))
              }, null, 40, _hoisted_15$i),
              _cache[12] || (_cache[12] = createTextVNode(" Use as Background ", -1))
            ])
          ]),
          unref(config).useAsBackground ? (openBlock(), createElementBlock("div", _hoisted_16$h, [
            _cache[13] || (_cache[13] = createBaseVNode("label", null, "Background Blur", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).backgroundBlur,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateConfig("backgroundBlur", $event)),
              min: 0,
              max: 1,
              step: 0.05
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const EnvironmentSettings = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-90d48964"]]);

const _hoisted_1$p = { class: "assets-panel" };
const _hoisted_2$p = { class: "asset-tabs" };
const _hoisted_3$p = ["onClick", "title"];
const _hoisted_4$p = { class: "tab-icon" };
const _hoisted_5$p = { class: "tab-label" };
const _hoisted_6$p = { class: "asset-content" };
const _hoisted_7$p = {
  key: 0,
  class: "tab-panel"
};
const _hoisted_8$o = { class: "panel-toolbar" };
const _hoisted_9$o = ["value"];
const _hoisted_10$n = { class: "material-list" };
const _hoisted_11$m = ["onClick"];
const _hoisted_12$k = { class: "material-name" };
const _hoisted_13$k = ["onClick"];
const _hoisted_14$i = {
  key: 1,
  class: "tab-panel"
};
const _hoisted_15$h = { class: "panel-toolbar" };
const _hoisted_16$g = { class: "svg-list" };
const _hoisted_17$g = ["onClick"];
const _hoisted_18$g = { class: "svg-preview" };
const _hoisted_19$g = { class: "path-count" };
const _hoisted_20$g = { class: "svg-name" };
const _hoisted_21$f = { class: "svg-actions" };
const _hoisted_22$e = ["onClick"];
const _hoisted_23$e = ["onClick"];
const _hoisted_24$b = ["onClick"];
const _hoisted_25$b = {
  key: 0,
  class: "svg-details"
};
const _hoisted_26$a = { class: "path-list" };
const _hoisted_27$a = { class: "path-name" };
const _hoisted_28$9 = { class: "path-config" };
const _hoisted_29$9 = ["value", "onInput"];
const _hoisted_30$8 = ["value", "onInput"];
const _hoisted_31$8 = {
  key: 2,
  class: "tab-panel"
};
const _hoisted_32$8 = { class: "panel-toolbar" };
const _hoisted_33$8 = { class: "mesh-list" };
const _hoisted_34$8 = ["onClick"];
const _hoisted_35$7 = { class: "mesh-icon" };
const _hoisted_36$6 = { key: 0 };
const _hoisted_37$6 = { key: 1 };
const _hoisted_38$6 = { key: 2 };
const _hoisted_39$6 = { class: "mesh-info" };
const _hoisted_40$5 = { class: "mesh-name" };
const _hoisted_41$3 = { class: "mesh-verts" };
const _hoisted_42$2 = ["onClick"];
const _hoisted_43$2 = {
  key: 0,
  class: "mesh-details"
};
const _hoisted_44$2 = { class: "detail-row" };
const _hoisted_45$2 = { class: "value" };
const _hoisted_46$2 = { class: "detail-row" };
const _hoisted_47$2 = { class: "value" };
const _hoisted_48$2 = { class: "detail-row" };
const _hoisted_49$2 = { class: "value" };
const _hoisted_50$1 = {
  key: 3,
  class: "tab-panel"
};
const _hoisted_51$1 = { class: "panel-toolbar" };
const _hoisted_52$1 = { class: "sprite-list" };
const _hoisted_53$1 = ["onClick"];
const _hoisted_54$1 = ["src"];
const _hoisted_55$1 = { class: "sprite-info" };
const _hoisted_56$1 = { class: "sprite-name" };
const _hoisted_57$1 = { class: "sprite-frames" };
const _hoisted_58$1 = ["onClick"];
const _hoisted_59$1 = {
  key: 0,
  class: "sprite-import-dialog"
};
const _hoisted_60 = {
  key: 0,
  class: "sprite-config"
};
const _hoisted_61 = {
  key: 4,
  class: "tab-panel"
};
const _hoisted_62 = {
  key: 0,
  class: "loading-overlay"
};
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "AssetsPanel",
  emits: ["create-layers-from-svg", "use-mesh-as-emitter", "environment-update", "environment-load", "environment-clear"],
  setup(__props, { emit: __emit }) {
    const assetStore = useAssetStore();
    useCompositorStore();
    const tabs = [
      { id: "materials", label: "Materials", icon: "", tooltip: "PBR Materials" },
      { id: "svg", label: "SVG", icon: "", tooltip: "SVG Logos & Shapes" },
      { id: "meshes", label: "Meshes", icon: "", tooltip: "Mesh Particles" },
      { id: "sprites", label: "Sprites", icon: "", tooltip: "Sprite Sheets" },
      { id: "environment", label: "Env", icon: "", tooltip: "Environment Map" }
    ];
    const activeTab = ref("materials");
    const materialPresets = [
      "chrome",
      "gold",
      "silver",
      "copper",
      "brass",
      "glass",
      "plastic",
      "rubber",
      "wood",
      "concrete",
      "emissive",
      "holographic"
    ];
    const selectedPreset = ref("");
    const materials = computed(() => assetStore.materialList);
    const svgDocuments = computed(() => assetStore.svgDocumentList);
    const meshParticles = computed(() => assetStore.meshParticleList);
    const spriteSheets = computed(() => assetStore.spriteSheetList);
    const environment = computed(() => assetStore.environment);
    const selectedMaterial = computed(() => assetStore.selectedMaterial);
    const selectedSvg = computed(() => assetStore.selectedSvgDocument);
    const selectedMesh = computed(() => assetStore.selectedMeshParticle);
    const selectedPrimitive = ref("");
    const showSpriteImport = ref(false);
    const pendingSpriteFile = ref(null);
    const spriteColumns = ref(4);
    const spriteRows = ref(4);
    const spriteFrameRate = ref(24);
    function createMaterial() {
      assetStore.createEmptyMaterial("New Material");
    }
    function createFromPreset() {
      if (selectedPreset.value) {
        assetStore.createMaterialFromPreset(selectedPreset.value);
        selectedPreset.value = "";
      }
    }
    function selectMaterial(id) {
      assetStore.selectedMaterialId = id;
    }
    function deleteMaterial(id) {
      assetStore.deleteMaterial(id);
    }
    function onMaterialUpdate(updates) {
      if (assetStore.selectedMaterialId) {
        assetStore.updateMaterial(assetStore.selectedMaterialId, updates);
      }
    }
    function onTextureUpload(textureType, file) {
      if (assetStore.selectedMaterialId) {
        assetStore.setMaterialTexture(assetStore.selectedMaterialId, textureType, file);
      }
    }
    function getMaterialPreviewStyle(mat) {
      return {
        backgroundColor: mat.config.color || "#808080",
        backgroundImage: mat.config.albedoMap ? `url(${mat.config.albedoMap})` : "none",
        backgroundSize: "cover"
      };
    }
    async function onSvgUpload(file) {
      await assetStore.importSvgFromFile(file);
    }
    function selectSvg(id) {
      assetStore.selectedSvgId = id;
    }
    function deleteSvg(id) {
      assetStore.deleteSvgDocument(id);
    }
    function updatePathDepth(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 0;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { depth: value });
    }
    function updatePathExtrusion(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 2;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { extrusionDepth: value });
    }
    function createLayersFromSvg(svgId) {
      emit("create-layers-from-svg", svgId);
    }
    function registerSvgAsMesh(svgId) {
      const svg = assetStore.svgDocuments.get(svgId);
      if (!svg) return;
      svg.document.paths.forEach((_, i) => {
        assetStore.registerSvgPathAsMesh(svgId, i);
      });
      activeTab.value = "meshes";
    }
    function addPrimitiveMesh() {
      if (selectedPrimitive.value) {
        assetStore.registerPrimitiveMesh(selectedPrimitive.value);
        selectedPrimitive.value = "";
      }
    }
    function selectMesh(id) {
      assetStore.selectedMeshParticleId = id;
    }
    function deleteMesh(id) {
      assetStore.deleteMeshParticle(id);
    }
    function useAsEmitterShape() {
      if (assetStore.selectedMeshParticleId) {
        emit("use-mesh-as-emitter", assetStore.selectedMeshParticleId);
      }
    }
    function onSpriteFileSelect(file) {
      pendingSpriteFile.value = file;
    }
    async function importSpriteSheet() {
      if (!pendingSpriteFile.value) return;
      await assetStore.importSpriteSheet(
        pendingSpriteFile.value,
        spriteColumns.value,
        spriteRows.value,
        { frameRate: spriteFrameRate.value }
      );
      cancelSpriteImport();
    }
    function cancelSpriteImport() {
      showSpriteImport.value = false;
      pendingSpriteFile.value = null;
      spriteColumns.value = 4;
      spriteRows.value = 4;
      spriteFrameRate.value = 24;
    }
    function selectSprite(id) {
      assetStore.selectedSpriteSheetId = id;
    }
    function deleteSprite(id) {
      assetStore.deleteSpriteSheet(id);
    }
    function onEnvironmentUpdate(settings) {
      assetStore.updateEnvironment(settings);
      emit("environment-update", settings);
    }
    async function onEnvironmentLoad(file) {
      await assetStore.loadEnvironment(file);
      emit("environment-load", assetStore.environment);
    }
    function onEnvironmentClear() {
      assetStore.clearEnvironment();
      emit("environment-clear");
    }
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        createBaseVNode("div", _hoisted_2$p, [
          (openBlock(), createElementBlock(Fragment, null, renderList(tabs, (tab) => {
            return createBaseVNode("button", {
              key: tab.id,
              class: normalizeClass({ active: activeTab.value === tab.id }),
              onClick: ($event) => activeTab.value = tab.id,
              title: tab.tooltip
            }, [
              createBaseVNode("span", _hoisted_4$p, toDisplayString(tab.icon), 1),
              createBaseVNode("span", _hoisted_5$p, toDisplayString(tab.label), 1)
            ], 10, _hoisted_3$p);
          }), 64))
        ]),
        createBaseVNode("div", _hoisted_6$p, [
          activeTab.value === "materials" ? (openBlock(), createElementBlock("div", _hoisted_7$p, [
            createBaseVNode("div", _hoisted_8$o, [
              createBaseVNode("button", {
                onClick: createMaterial,
                title: "New Material"
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" New ", -1)
              ])]),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
                onChange: createFromPreset,
                class: "preset-select"
              }, [
                _cache[8] || (_cache[8] = createBaseVNode("option", { value: "" }, "From Preset...", -1)),
                (openBlock(), createElementBlock(Fragment, null, renderList(materialPresets, (preset) => {
                  return createBaseVNode("option", {
                    key: preset,
                    value: preset
                  }, toDisplayString(preset), 9, _hoisted_9$o);
                }), 64))
              ], 544), [
                [vModelSelect, selectedPreset.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_10$n, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(materials.value, (mat) => {
                return openBlock(), createElementBlock("div", {
                  key: mat.id,
                  class: normalizeClass(["material-item", { selected: mat.id === unref(assetStore).selectedMaterialId }]),
                  onClick: ($event) => selectMaterial(mat.id)
                }, [
                  createBaseVNode("div", {
                    class: "material-preview",
                    style: normalizeStyle(getMaterialPreviewStyle(mat))
                  }, null, 4),
                  createBaseVNode("span", _hoisted_12$k, toDisplayString(mat.name), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMaterial(mat.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[9] || (_cache[9] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_13$k)
                ], 10, _hoisted_11$m);
              }), 128))
            ]),
            selectedMaterial.value ? (openBlock(), createBlock(MaterialEditor, {
              key: 0,
              "material-id": selectedMaterial.value.id,
              config: selectedMaterial.value.config,
              onUpdate: onMaterialUpdate,
              onTextureUpload
            }, null, 8, ["material-id", "config"])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "svg" ? (openBlock(), createElementBlock("div", _hoisted_14$i, [
            createBaseVNode("div", _hoisted_15$h, [
              createVNode(AssetUploader, {
                accept: ".svg",
                "asset-type": "svg",
                onUpload: onSvgUpload,
                "button-text": "Import SVG"
              })
            ]),
            createBaseVNode("div", _hoisted_16$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(svgDocuments.value, (svg) => {
                return openBlock(), createElementBlock("div", {
                  key: svg.id,
                  class: normalizeClass(["svg-item", { selected: svg.id === unref(assetStore).selectedSvgId }]),
                  onClick: ($event) => selectSvg(svg.id)
                }, [
                  createBaseVNode("div", _hoisted_18$g, [
                    createBaseVNode("span", _hoisted_19$g, toDisplayString(svg.document.paths.length) + " paths", 1)
                  ]),
                  createBaseVNode("span", _hoisted_20$g, toDisplayString(svg.name), 1),
                  createBaseVNode("div", _hoisted_21$f, [
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => createLayersFromSvg(svg.id), ["stop"]),
                      title: "Create Layers"
                    }, [..._cache[10] || (_cache[10] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_22$e),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => registerSvgAsMesh(svg.id), ["stop"]),
                      title: "Use as Particle"
                    }, [..._cache[11] || (_cache[11] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_23$e),
                    createBaseVNode("button", {
                      class: "delete-btn",
                      onClick: withModifiers(($event) => deleteSvg(svg.id), ["stop"]),
                      title: "Delete"
                    }, [..._cache[12] || (_cache[12] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_24$b)
                  ])
                ], 10, _hoisted_17$g);
              }), 128))
            ]),
            selectedSvg.value ? (openBlock(), createElementBlock("div", _hoisted_25$b, [
              createBaseVNode("h4", null, toDisplayString(selectedSvg.value.name), 1),
              createBaseVNode("div", _hoisted_26$a, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(selectedSvg.value.document.paths, (path, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: path.id,
                    class: "path-item"
                  }, [
                    createBaseVNode("span", _hoisted_27$a, toDisplayString(path.id), 1),
                    createBaseVNode("div", {
                      class: "path-color",
                      style: normalizeStyle({ backgroundColor: path.fill || path.stroke || "#888" })
                    }, null, 4),
                    createBaseVNode("div", _hoisted_28$9, [
                      createBaseVNode("label", null, [
                        _cache[13] || (_cache[13] = createTextVNode(" Depth ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.depth || 0,
                          onInput: ($event) => updatePathDepth(i, $event),
                          step: "1"
                        }, null, 40, _hoisted_29$9)
                      ]),
                      createBaseVNode("label", null, [
                        _cache[14] || (_cache[14] = createTextVNode(" Extrusion ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.extrusionDepth || 2,
                          onInput: ($event) => updatePathExtrusion(i, $event),
                          step: "0.5"
                        }, null, 40, _hoisted_30$8)
                      ])
                    ])
                  ]);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "meshes" ? (openBlock(), createElementBlock("div", _hoisted_31$8, [
            createBaseVNode("div", _hoisted_32$8, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedPrimitive.value = $event),
                onChange: addPrimitiveMesh,
                class: "primitive-select"
              }, [..._cache[15] || (_cache[15] = [
                createStaticVNode('<option value="" data-v-5051fa15>Add Primitive...</option><option value="cube" data-v-5051fa15>Cube</option><option value="sphere" data-v-5051fa15>Sphere</option><option value="cone" data-v-5051fa15>Cone</option><option value="cylinder" data-v-5051fa15>Cylinder</option><option value="torus" data-v-5051fa15>Torus</option><option value="tetrahedron" data-v-5051fa15>Tetrahedron</option><option value="octahedron" data-v-5051fa15>Octahedron</option><option value="icosahedron" data-v-5051fa15>Icosahedron</option>', 9)
              ])], 544), [
                [vModelSelect, selectedPrimitive.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_33$8, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(meshParticles.value, (mesh) => {
                return openBlock(), createElementBlock("div", {
                  key: mesh.id,
                  class: normalizeClass(["mesh-item", { selected: mesh.id === unref(assetStore).selectedMeshParticleId }]),
                  onClick: ($event) => selectMesh(mesh.id)
                }, [
                  createBaseVNode("div", _hoisted_35$7, [
                    mesh.source === "primitive" ? (openBlock(), createElementBlock("span", _hoisted_36$6, "")) : mesh.source === "svg" ? (openBlock(), createElementBlock("span", _hoisted_37$6, "")) : (openBlock(), createElementBlock("span", _hoisted_38$6, ""))
                  ]),
                  createBaseVNode("div", _hoisted_39$6, [
                    createBaseVNode("span", _hoisted_40$5, toDisplayString(mesh.name), 1),
                    createBaseVNode("span", _hoisted_41$3, toDisplayString(mesh.registration.vertexCount) + " verts", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMesh(mesh.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[16] || (_cache[16] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_42$2)
                ], 10, _hoisted_34$8);
              }), 128))
            ]),
            selectedMesh.value ? (openBlock(), createElementBlock("div", _hoisted_43$2, [
              createBaseVNode("h4", null, toDisplayString(selectedMesh.value.name), 1),
              createBaseVNode("div", _hoisted_44$2, [
                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "label" }, "Source:", -1)),
                createBaseVNode("span", _hoisted_45$2, toDisplayString(selectedMesh.value.source), 1)
              ]),
              createBaseVNode("div", _hoisted_46$2, [
                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "label" }, "Vertices:", -1)),
                createBaseVNode("span", _hoisted_47$2, toDisplayString(selectedMesh.value.registration.vertexCount), 1)
              ]),
              createBaseVNode("div", _hoisted_48$2, [
                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "label" }, "Bounding Radius:", -1)),
                createBaseVNode("span", _hoisted_49$2, toDisplayString(selectedMesh.value.registration.boundingSphere.radius.toFixed(2)), 1)
              ]),
              createBaseVNode("button", {
                class: "action-btn",
                onClick: useAsEmitterShape
              }, " Use as Emitter Shape ")
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "sprites" ? (openBlock(), createElementBlock("div", _hoisted_50$1, [
            createBaseVNode("div", _hoisted_51$1, [
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => showSpriteImport.value = true),
                title: "Import Sprite Sheet"
              }, [..._cache[20] || (_cache[20] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" Import ", -1)
              ])])
            ]),
            createBaseVNode("div", _hoisted_52$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(spriteSheets.value, (sprite) => {
                return openBlock(), createElementBlock("div", {
                  key: sprite.id,
                  class: normalizeClass(["sprite-item", { selected: sprite.id === unref(assetStore).selectedSpriteSheetId }]),
                  onClick: ($event) => selectSprite(sprite.id)
                }, [
                  createBaseVNode("img", {
                    src: sprite.textureUrl,
                    class: "sprite-preview"
                  }, null, 8, _hoisted_54$1),
                  createBaseVNode("div", _hoisted_55$1, [
                    createBaseVNode("span", _hoisted_56$1, toDisplayString(sprite.name), 1),
                    createBaseVNode("span", _hoisted_57$1, toDisplayString(sprite.config.totalFrames) + " frames", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteSprite(sprite.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[21] || (_cache[21] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_58$1)
                ], 10, _hoisted_53$1);
              }), 128))
            ]),
            showSpriteImport.value ? (openBlock(), createElementBlock("div", _hoisted_59$1, [
              _cache[25] || (_cache[25] = createBaseVNode("h4", null, "Import Sprite Sheet", -1)),
              createVNode(AssetUploader, {
                accept: "image/*",
                "asset-type": "sprite",
                onUpload: onSpriteFileSelect,
                "button-text": "Select Image"
              }),
              pendingSpriteFile.value ? (openBlock(), createElementBlock("div", _hoisted_60, [
                createBaseVNode("label", null, [
                  _cache[22] || (_cache[22] = createTextVNode(" Columns ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => spriteColumns.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteColumns.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[23] || (_cache[23] = createTextVNode(" Rows ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => spriteRows.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteRows.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[24] || (_cache[24] = createTextVNode(" Frame Rate ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => spriteFrameRate.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteFrameRate.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("div", { class: "dialog-actions" }, [
                  createBaseVNode("button", {
                    onClick: importSpriteSheet,
                    class: "confirm-btn"
                  }, "Import"),
                  createBaseVNode("button", {
                    onClick: cancelSpriteImport,
                    class: "cancel-btn"
                  }, "Cancel")
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "environment" ? (openBlock(), createElementBlock("div", _hoisted_61, [
            createVNode(EnvironmentSettings, {
              config: environment.value,
              onUpdate: onEnvironmentUpdate,
              onLoad: onEnvironmentLoad,
              onClear: onEnvironmentClear
            }, null, 8, ["config"])
          ])) : createCommentVNode("", true)
        ]),
        unref(assetStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_62, [..._cache[26] || (_cache[26] = [
          createBaseVNode("div", { class: "spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(assetStore).lastError ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "error-toast",
          onClick: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(assetStore).clearError && unref(assetStore).clearError(...args))
        }, toDisplayString(unref(assetStore).lastError), 1)) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-5051fa15"]]);

function isWebCodecsSupported() {
  return typeof VideoEncoder !== "undefined" && typeof VideoFrame !== "undefined";
}
async function getSupportedCodecs() {
  if (!isWebCodecsSupported()) return [];
  const codecs = [];
  const testConfigs = [
    { codec: "avc1.42E01F", name: "avc" },
    // H.264 Baseline
    { codec: "avc1.640028", name: "avc" },
    // H.264 High
    { codec: "vp9", name: "vp9" },
    { codec: "vp8", name: "vp8" }
  ];
  for (const { codec, name } of testConfigs) {
    try {
      const support = await VideoEncoder.isConfigSupported({
        codec,
        width: 1920,
        height: 1080,
        bitrate: 5e6
      });
      if (support.supported && !codecs.includes(name)) {
        codecs.push(name);
      }
    } catch {
    }
  }
  return codecs;
}
class WebCodecsVideoEncoder {
  config;
  encoder = null;
  webmMuxer = null;
  mp4Muxer = null;
  frameCount = 0;
  totalBytesWritten = 0;
  onProgress;
  constructor(config) {
    this.config = config;
  }
  /**
   * Initialize the encoder
   */
  async initialize(onProgress) {
    if (!isWebCodecsSupported()) {
      throw new Error("WebCodecs API is not supported in this browser");
    }
    this.onProgress = onProgress;
    this.frameCount = 0;
    this.totalBytesWritten = 0;
    this.webmMuxer = null;
    this.mp4Muxer = null;
    const codecString = this.getCodecString();
    const bitrate = this.getBitrate();
    const support = await VideoEncoder.isConfigSupported({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate
    });
    if (!support.supported) {
      throw new Error(`Unsupported encoder configuration: ${codecString}`);
    }
    if (this.config.codec === "avc") {
      this.mp4Muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: "avc",
          width: this.config.width,
          height: this.config.height
        },
        fastStart: "in-memory"
        // Moves moov atom to beginning for streaming
      });
    } else {
      const webmCodec = this.config.codec === "vp9" ? "V_VP9" : "V_VP8";
      this.webmMuxer = new Muxer$1({
        target: new ArrayBufferTarget$1(),
        video: {
          codec: webmCodec,
          width: this.config.width,
          height: this.config.height
        }
      });
    }
    this.encoder = new VideoEncoder({
      output: (chunk, metadata) => {
        this.handleChunk(chunk, metadata);
      },
      error: (error) => {
        exportLogger.error("VideoEncoder: Encoding error:", error);
        throw error;
      }
    });
    this.encoder.configure({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate,
      framerate: this.config.frameRate
    });
  }
  /**
   * Encode a single frame
   */
  async encodeFrame(imageData, frameIndex, totalFrames, keyFrame = false) {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    let frame;
    if (imageData instanceof ImageData) {
      frame = new VideoFrame(imageData.data, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate,
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        format: "RGBA"
      });
    } else {
      frame = new VideoFrame(imageData, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate
      });
    }
    const isKeyFrame = keyFrame || frameIndex === 0 || frameIndex % 30 === 0;
    this.encoder.encode(frame, { keyFrame: isKeyFrame });
    frame.close();
    this.frameCount++;
    if (this.onProgress) {
      this.onProgress({
        framesEncoded: this.frameCount,
        totalFrames,
        percentage: this.frameCount / totalFrames * 100,
        bytesWritten: this.totalBytesWritten
      });
    }
  }
  /**
   * Finish encoding and return the video blob
   */
  async finalize() {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    await this.encoder.flush();
    this.encoder.close();
    this.encoder = null;
    let blob;
    let mimeType;
    if (this.mp4Muxer) {
      this.mp4Muxer.finalize();
      const buffer = this.mp4Muxer.target.buffer;
      blob = new Blob([buffer], { type: "video/mp4" });
      mimeType = "video/mp4";
      this.mp4Muxer = null;
    } else if (this.webmMuxer) {
      this.webmMuxer.finalize();
      const buffer = this.webmMuxer.target.buffer;
      blob = new Blob([buffer], { type: "video/webm" });
      mimeType = "video/webm";
      this.webmMuxer = null;
    } else {
      throw new Error("No muxer initialized");
    }
    return {
      blob,
      mimeType,
      duration: this.frameCount / this.config.frameRate,
      frameCount: this.frameCount,
      size: blob.size
    };
  }
  /**
   * Cancel encoding
   */
  cancel() {
    if (this.encoder) {
      this.encoder.close();
      this.encoder = null;
    }
    this.webmMuxer = null;
    this.mp4Muxer = null;
  }
  // ============================================================================
  // Private Methods
  // ============================================================================
  handleChunk(chunk, metadata) {
    if (this.mp4Muxer) {
      this.mp4Muxer.addVideoChunk(chunk, metadata);
    } else if (this.webmMuxer) {
      this.webmMuxer.addVideoChunk(chunk, metadata);
    }
    this.totalBytesWritten += chunk.byteLength;
  }
  getCodecString() {
    switch (this.config.codec) {
      case "avc":
        return "avc1.640028";
      case "vp9":
        return "vp09.00.10.08";
      case "vp8":
        return "vp8";
      default:
        return "avc1.640028";
    }
  }
  getBitrate() {
    if (this.config.bitrate) {
      return this.config.bitrate;
    }
    const pixels = this.config.width * this.config.height;
    const baseRate = pixels * this.config.frameRate;
    switch (this.config.quality) {
      case "low":
        return Math.round(baseRate * 0.05);
      case "medium":
        return Math.round(baseRate * 0.1);
      case "high":
        return Math.round(baseRate * 0.2);
      case "lossless":
        return Math.round(baseRate * 0.5);
      default:
        return Math.round(baseRate * 0.1);
    }
  }
}
function downloadVideo(video, filename) {
  const extension = video.mimeType.includes("webm") ? "webm" : "mp4";
  const fullFilename = filename.includes(".") ? filename : `${filename}.${extension}`;
  const url = URL.createObjectURL(video.blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fullFilename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

const FORMAT_MIME = {
  png: "image/png",
  jpeg: "image/jpeg",
  webp: "image/webp"
};
const BACKEND_FORMATS = ["tiff", "exr", "dpx"];
function isBrowserFormat(format) {
  return !BACKEND_FORMATS.includes(format);
}
function formatFrameNumber(pattern, frame) {
  return pattern.replace(/\{frame:(\d+)d\}/g, (_, digits) => {
    return frame.toString().padStart(parseInt(digits), "0");
  });
}
function generateFilename(pattern, frame, format) {
  const base = formatFrameNumber(pattern, frame);
  return `${base}.${format}`;
}
async function exportCanvasToBlob(canvas, format, quality = 95) {
  const mime = FORMAT_MIME[format];
  if (!mime) {
    throw new Error(`Format ${format} not supported in browser`);
  }
  const qualityValue = format === "png" ? void 0 : quality / 100;
  if (canvas instanceof OffscreenCanvas) {
    return await canvas.convertToBlob({ type: mime, quality: qualityValue });
  } else {
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => {
          if (blob) resolve(blob);
          else reject(new Error("Failed to create blob"));
        },
        mime,
        qualityValue
      );
    });
  }
}
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
async function exportViaBackend(frames, options, backendUrl = "/weyl/export") {
  const result = {
    success: false,
    frames: [],
    totalSize: 0,
    errors: [],
    warnings: []
  };
  try {
    const frameData = [];
    for (const { canvas, frameNumber } of frames) {
      const dataUrl = canvas.toDataURL("image/png");
      frameData.push({ frame: frameNumber, data: dataUrl });
    }
    const response = await fetch(backendUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        frames: frameData,
        format: options.format,
        bitDepth: options.bitDepth || 16,
        colorSpace: options.colorSpace || "sRGB",
        filenamePattern: options.filenamePattern,
        outputDir: options.outputDir
      })
    });
    if (!response.ok) {
      throw new Error(`Backend export failed: ${response.statusText}`);
    }
    const data = await response.json();
    if (data.success) {
      result.success = true;
      result.frames = data.frames;
      result.totalSize = data.totalSize;
    } else {
      result.errors = data.errors || ["Unknown backend error"];
    }
  } catch (error) {
    result.errors.push(`Backend export error: ${error}`);
  }
  return result;
}
async function exportFrameSequence(renderFrame, options, onProgress) {
  const result = {
    success: false,
    frames: [],
    totalSize: 0,
    errors: [],
    warnings: []
  };
  const { format, quality, filenamePattern, startFrame, endFrame } = options;
  const totalFrames = endFrame - startFrame + 1;
  const isBrowser = isBrowserFormat(format);
  try {
    if (isBrowser) {
      for (let frame = startFrame; frame <= endFrame; frame++) {
        try {
          const canvas = await renderFrame(frame);
          const blob = await exportCanvasToBlob(canvas, format, quality);
          const filename = generateFilename(filenamePattern, frame, format);
          result.frames.push({
            frameNumber: frame,
            filename,
            blob,
            size: blob.size
          });
          result.totalSize += blob.size;
          onProgress?.(frame - startFrame + 1, totalFrames);
        } catch (error) {
          result.errors.push(`Frame ${frame}: ${error}`);
        }
      }
      result.success = result.frames.length > 0;
    } else {
      const frames = [];
      for (let frame = startFrame; frame <= endFrame; frame++) {
        try {
          const canvas = await renderFrame(frame);
          frames.push({ canvas, frameNumber: frame });
          onProgress?.(frame - startFrame + 1, totalFrames);
        } catch (error) {
          result.errors.push(`Frame ${frame}: ${error}`);
        }
      }
      if (frames.length > 0) {
        result.warnings.push(
          `${format.toUpperCase()} export requires backend processing`
        );
        const backendResult = await exportViaBackend(frames, options);
        Object.assign(result, backendResult);
      }
    }
  } catch (error) {
    result.errors.push(`Export failed: ${error}`);
  }
  return result;
}
function getFormatInfo(format) {
  const info = {
    png: {
      name: "PNG",
      description: "Lossless compression, 8-bit RGBA",
      extension: "png",
      requiresBackend: false,
      supportsAlpha: true,
      bitDepths: [8],
      lossy: false
    },
    jpeg: {
      name: "JPEG",
      description: "Lossy compression, 8-bit RGB",
      extension: "jpg",
      requiresBackend: false,
      supportsAlpha: false,
      bitDepths: [8],
      lossy: true
    },
    webp: {
      name: "WebP",
      description: "Modern format, lossy or lossless",
      extension: "webp",
      requiresBackend: false,
      supportsAlpha: true,
      bitDepths: [8],
      lossy: true
    },
    tiff: {
      name: "TIFF",
      description: "Professional format, 8/16-bit",
      extension: "tiff",
      requiresBackend: true,
      supportsAlpha: true,
      bitDepths: [8, 16],
      lossy: false
    },
    exr: {
      name: "OpenEXR",
      description: "HDR format, 16/32-bit float",
      extension: "exr",
      requiresBackend: true,
      supportsAlpha: true,
      bitDepths: [16, 32],
      lossy: false
    },
    dpx: {
      name: "DPX",
      description: "Film industry format, 10/16-bit",
      extension: "dpx",
      requiresBackend: true,
      supportsAlpha: false,
      bitDepths: [10, 16],
      lossy: false
    }
  };
  return info[format];
}

const _hoisted_1$o = { class: "export-panel" };
const _hoisted_2$o = { class: "panel-content" };
const _hoisted_3$o = { class: "control-section" };
const _hoisted_4$o = { class: "mode-toggle" };
const _hoisted_5$o = ["disabled"];
const _hoisted_6$o = ["disabled"];
const _hoisted_7$o = {
  key: 0,
  class: "control-section"
};
const _hoisted_8$n = { class: "control-row" };
const _hoisted_9$n = ["disabled"];
const _hoisted_10$m = ["value"];
const _hoisted_11$l = { class: "control-row" };
const _hoisted_12$j = ["disabled"];
const _hoisted_13$j = {
  key: 1,
  class: "control-section"
};
const _hoisted_14$h = { class: "control-row" };
const _hoisted_15$g = ["disabled"];
const _hoisted_16$f = ["disabled"];
const _hoisted_17$f = ["disabled"];
const _hoisted_18$f = ["disabled"];
const _hoisted_19$f = {
  key: 0,
  class: "control-row"
};
const _hoisted_20$f = ["disabled"];
const _hoisted_21$e = { class: "quality-value" };
const _hoisted_22$d = { class: "format-info" };
const _hoisted_23$d = { class: "format-desc" };
const _hoisted_24$a = { class: "control-section" };
const _hoisted_25$a = { class: "info-grid" };
const _hoisted_26$9 = { class: "info-item" };
const _hoisted_27$9 = { class: "info-value" };
const _hoisted_28$8 = { class: "info-item" };
const _hoisted_29$8 = { class: "info-value" };
const _hoisted_30$7 = { class: "info-item" };
const _hoisted_31$7 = { class: "info-value" };
const _hoisted_32$7 = { class: "info-item" };
const _hoisted_33$7 = { class: "info-value" };
const _hoisted_34$7 = {
  key: 2,
  class: "progress-section"
};
const _hoisted_35$6 = { class: "progress-header" };
const _hoisted_36$5 = { key: 0 };
const _hoisted_37$5 = { class: "progress-bar" };
const _hoisted_38$5 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_39$5 = { class: "actions-section" };
const _hoisted_40$4 = ["disabled"];
const _hoisted_41$2 = {
  key: 3,
  class: "warning-message"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "ExportPanel",
  setup(__props) {
    const store = useCompositorStore();
    const exportMode = ref("video");
    const webCodecsSupported = ref(false);
    const backendAvailable = ref(false);
    const availableCodecs = ref([]);
    const selectedCodec = ref("avc");
    const selectedQuality = ref("high");
    const isExporting = ref(false);
    const exportComplete = ref(false);
    const encodedVideo = ref(null);
    const currentEncoder = ref(null);
    const exportProgress = ref({
      framesEncoded: 0,
      totalFrames: 0,
      percentage: 0,
      bytesWritten: 0
    });
    const sequenceFormat = ref("png");
    const sequenceQuality = ref(95);
    const sequenceResult = ref(null);
    const sequenceFormatInfo = computed(() => getFormatInfo(sequenceFormat.value));
    const activeComp = computed(() => store.getActiveComp());
    const outputWidth = computed(() => activeComp.value?.settings.width || 1024);
    const outputHeight = computed(() => activeComp.value?.settings.height || 1024);
    const frameRate = computed(() => activeComp.value?.settings.fps || 16);
    const totalFrames = computed(() => activeComp.value?.settings.frameCount || 81);
    const duration = computed(() => {
      const seconds = totalFrames.value / frameRate.value;
      const m = Math.floor(seconds / 60);
      const s = (seconds % 60).toFixed(2);
      return m > 0 ? `${m}m ${s}s` : `${s}s`;
    });
    const canExport = computed(() => {
      if (isExporting.value || store.layers.length === 0) return false;
      if (exportMode.value === "video") return webCodecsSupported.value;
      return true;
    });
    const exportStatusText = computed(() => {
      if (exportComplete.value) return "Export complete!";
      if (isExporting.value) {
        if (exportMode.value === "sequence") return "Rendering frames...";
        return "Encoding...";
      }
      return "Ready";
    });
    onMounted(async () => {
      webCodecsSupported.value = isWebCodecsSupported();
      if (webCodecsSupported.value) {
        const codecs = await getSupportedCodecs();
        availableCodecs.value = [];
        if (codecs.includes("avc")) {
          availableCodecs.value.push({ value: "avc", label: "H.264 (MP4)" });
        }
        if (codecs.includes("vp9")) {
          availableCodecs.value.push({ value: "vp9", label: "VP9 (WebM)" });
        }
        if (codecs.includes("vp8")) {
          availableCodecs.value.push({ value: "vp8", label: "VP8 (WebM)" });
        }
        if (availableCodecs.value.length > 0) {
          selectedCodec.value = availableCodecs.value[0].value;
        }
      }
    });
    async function startExport() {
      if (!canExport.value) return;
      isExporting.value = true;
      exportComplete.value = false;
      encodedVideo.value = null;
      sequenceResult.value = null;
      if (exportMode.value === "sequence") {
        await startFrameSequenceExport();
      } else {
        await startVideoExport();
      }
    }
    async function startFrameSequenceExport() {
      try {
        const result = await exportFrameSequence(
          async (frame) => {
            store.setFrame(frame);
            await new Promise((resolve) => setTimeout(resolve, 10));
            const glCanvas = document.querySelector(".three-canvas canvas");
            if (glCanvas) {
              const canvas2 = document.createElement("canvas");
              canvas2.width = outputWidth.value;
              canvas2.height = outputHeight.value;
              const ctx2 = canvas2.getContext("2d");
              if (ctx2) {
                ctx2.drawImage(glCanvas, 0, 0, canvas2.width, canvas2.height);
              }
              return canvas2;
            }
            const canvas = document.createElement("canvas");
            canvas.width = outputWidth.value;
            canvas.height = outputHeight.value;
            const ctx = canvas.getContext("2d");
            if (ctx) {
              ctx.fillStyle = "#050505";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "#fff";
              ctx.font = "24px sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(`Frame ${frame}`, canvas.width / 2, canvas.height / 2);
            }
            return canvas;
          },
          {
            format: sequenceFormat.value,
            quality: sequenceQuality.value,
            filenamePattern: `${activeComp.value?.name || "frame"}_{frame:04d}`,
            outputDir: "",
            startFrame: 0,
            endFrame: totalFrames.value - 1
          },
          (current, total) => {
            exportProgress.value = {
              framesEncoded: current,
              totalFrames: total,
              percentage: current / total * 100,
              bytesWritten: 0
            };
          }
        );
        sequenceResult.value = result;
        exportComplete.value = result.success;
        if (result.errors.length > 0) {
          console.warn("Frame sequence export warnings:", result.errors);
        }
      } catch (error) {
        console.error("Frame sequence export failed:", error);
        alert(`Export failed: ${error.message}`);
      } finally {
        isExporting.value = false;
      }
    }
    async function startVideoExport() {
      const config = {
        width: outputWidth.value,
        height: outputHeight.value,
        frameRate: frameRate.value,
        codec: selectedCodec.value,
        quality: selectedQuality.value
      };
      const encoder = new WebCodecsVideoEncoder(config);
      currentEncoder.value = encoder;
      try {
        await encoder.initialize((progress) => {
          exportProgress.value = progress;
        });
        const canvas = new OffscreenCanvas(outputWidth.value, outputHeight.value);
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("Could not get 2D context");
        for (let frame = 0; frame < totalFrames.value; frame++) {
          if (!isExporting.value) break;
          store.setFrame(frame);
          await new Promise((resolve) => setTimeout(resolve, 10));
          const frameImage = await captureCurrentFrame(canvas, ctx);
          await encoder.encodeFrame(frameImage, frame, totalFrames.value);
        }
        if (isExporting.value) {
          encodedVideo.value = await encoder.finalize();
          exportComplete.value = true;
        }
      } catch (error) {
        console.error("Export failed:", error);
        alert(`Export failed: ${error.message}`);
      } finally {
        isExporting.value = false;
        currentEncoder.value = null;
      }
    }
    async function captureCurrentFrame(canvas, ctx) {
      const glCanvas = document.querySelector(".three-canvas canvas");
      if (glCanvas) {
        ctx.drawImage(glCanvas, 0, 0, canvas.width, canvas.height);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, "#050505");
        gradient.addColorStop(1, "#0a0a0a");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Frame " + store.currentFrame, canvas.width / 2, canvas.height / 2);
      }
      return canvas;
    }
    function cancelExport() {
      isExporting.value = false;
      if (currentEncoder.value) {
        currentEncoder.value.cancel();
        currentEncoder.value = null;
      }
    }
    function downloadExport() {
      if (encodedVideo.value) {
        const compName = activeComp.value?.name || "composition";
        downloadVideo(encodedVideo.value, `${compName}-export`);
      }
    }
    function downloadSequence() {
      if (!sequenceResult.value || sequenceResult.value.frames.length === 0) return;
      if (sequenceResult.value.frames.length <= 10) {
        for (const frame of sequenceResult.value.frames) {
          if (frame.blob) {
            downloadBlob(frame.blob, frame.filename);
          }
        }
      } else {
        console.log("Large sequence export - downloading first 10 frames");
        const sampleFrames = sequenceResult.value.frames.slice(0, 10);
        for (const frame of sampleFrames) {
          if (frame.blob) {
            downloadBlob(frame.blob, frame.filename);
          }
        }
        alert(
          `Downloaded first 10 frames as sample.
Full ZIP export requires JSZip library.
Total frames: ${sequenceResult.value.frames.length}`
        );
      }
    }
    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$o, [
        _cache[23] || (_cache[23] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Export")
        ], -1)),
        createBaseVNode("div", _hoisted_2$o, [
          createBaseVNode("div", _hoisted_3$o, [
            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Export Mode")
            ], -1)),
            createBaseVNode("div", _hoisted_4$o, [
              createBaseVNode("button", {
                class: normalizeClass(["mode-btn", { active: exportMode.value === "video" }]),
                onClick: _cache[0] || (_cache[0] = ($event) => exportMode.value = "video"),
                disabled: isExporting.value
              }, " Video ", 10, _hoisted_5$o),
              createBaseVNode("button", {
                class: normalizeClass(["mode-btn", { active: exportMode.value === "sequence" }]),
                onClick: _cache[1] || (_cache[1] = ($event) => exportMode.value = "sequence"),
                disabled: isExporting.value
              }, " Frame Sequence ", 10, _hoisted_6$o)
            ])
          ]),
          exportMode.value === "video" ? (openBlock(), createElementBlock("div", _hoisted_7$o, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Video Format")
            ], -1)),
            createBaseVNode("div", _hoisted_8$n, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "Codec", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedCodec.value = $event),
                disabled: isExporting.value
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableCodecs.value, (codec) => {
                  return openBlock(), createElementBlock("option", {
                    key: codec.value,
                    value: codec.value
                  }, toDisplayString(codec.label), 9, _hoisted_10$m);
                }), 128))
              ], 8, _hoisted_9$n), [
                [vModelSelect, selectedCodec.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_11$l, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Quality", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedQuality.value = $event),
                disabled: isExporting.value
              }, [..._cache[8] || (_cache[8] = [
                createBaseVNode("option", { value: "low" }, "Low (smaller file)", -1),
                createBaseVNode("option", { value: "medium" }, "Medium", -1),
                createBaseVNode("option", { value: "high" }, "High", -1),
                createBaseVNode("option", { value: "lossless" }, "Lossless (largest)", -1)
              ])], 8, _hoisted_12$j), [
                [vModelSelect, selectedQuality.value]
              ])
            ])
          ])) : createCommentVNode("", true),
          exportMode.value === "sequence" ? (openBlock(), createElementBlock("div", _hoisted_13$j, [
            _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Sequence Format")
            ], -1)),
            createBaseVNode("div", _hoisted_14$h, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Format", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => sequenceFormat.value = $event),
                disabled: isExporting.value
              }, [
                _cache[11] || (_cache[11] = createBaseVNode("option", { value: "png" }, "PNG (Lossless)", -1)),
                _cache[12] || (_cache[12] = createBaseVNode("option", { value: "jpeg" }, "JPEG (Lossy)", -1)),
                _cache[13] || (_cache[13] = createBaseVNode("option", { value: "webp" }, "WebP (Modern)", -1)),
                createBaseVNode("option", {
                  value: "tiff",
                  disabled: !backendAvailable.value
                }, "TIFF 16-bit (Backend)", 8, _hoisted_16$f),
                createBaseVNode("option", {
                  value: "exr",
                  disabled: !backendAvailable.value
                }, "OpenEXR HDR (Backend)", 8, _hoisted_17$f),
                createBaseVNode("option", {
                  value: "dpx",
                  disabled: !backendAvailable.value
                }, "DPX Film (Backend)", 8, _hoisted_18$f)
              ], 8, _hoisted_15$g), [
                [vModelSelect, sequenceFormat.value]
              ])
            ]),
            sequenceFormat.value === "jpeg" || sequenceFormat.value === "webp" ? (openBlock(), createElementBlock("div", _hoisted_19$f, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Quality", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => sequenceQuality.value = $event),
                min: "1",
                max: "100",
                disabled: isExporting.value
              }, null, 8, _hoisted_20$f), [
                [
                  vModelText,
                  sequenceQuality.value,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_21$e, toDisplayString(sequenceQuality.value) + "%", 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_22$d, [
              createBaseVNode("div", {
                class: normalizeClass(["info-badge", sequenceFormatInfo.value.requiresBackend ? "backend" : "browser"])
              }, toDisplayString(sequenceFormatInfo.value.requiresBackend ? "Backend Required" : "Browser Export"), 3),
              createBaseVNode("span", _hoisted_23$d, toDisplayString(sequenceFormatInfo.value.description), 1)
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_24$a, [
            _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Output")
            ], -1)),
            createBaseVNode("div", _hoisted_25$a, [
              createBaseVNode("div", _hoisted_26$9, [
                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "info-label" }, "Size", -1)),
                createBaseVNode("span", _hoisted_27$9, toDisplayString(outputWidth.value) + " x " + toDisplayString(outputHeight.value), 1)
              ]),
              createBaseVNode("div", _hoisted_28$8, [
                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
                createBaseVNode("span", _hoisted_29$8, toDisplayString(frameRate.value) + " fps", 1)
              ]),
              createBaseVNode("div", _hoisted_30$7, [
                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
                createBaseVNode("span", _hoisted_31$7, toDisplayString(duration.value), 1)
              ]),
              createBaseVNode("div", _hoisted_32$7, [
                _cache[20] || (_cache[20] = createBaseVNode("span", { class: "info-label" }, "Total Frames", -1)),
                createBaseVNode("span", _hoisted_33$7, toDisplayString(totalFrames.value), 1)
              ])
            ])
          ]),
          isExporting.value || exportComplete.value ? (openBlock(), createElementBlock("div", _hoisted_34$7, [
            createBaseVNode("div", _hoisted_35$6, [
              createBaseVNode("span", null, toDisplayString(exportStatusText.value), 1),
              isExporting.value ? (openBlock(), createElementBlock("span", _hoisted_36$5, toDisplayString(exportProgress.value.percentage.toFixed(1)) + "%", 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_37$5, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value.percentage}%` })
              }, null, 4)
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_38$5, [
              createBaseVNode("span", null, "Frame " + toDisplayString(exportProgress.value.framesEncoded) + " / " + toDisplayString(exportProgress.value.totalFrames), 1),
              createBaseVNode("span", null, toDisplayString(formatBytes(exportProgress.value.bytesWritten)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_39$5, [
            !isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "export-btn primary",
              disabled: !canExport.value,
              onClick: startExport
            }, toDisplayString(exportMode.value === "video" ? "Export Video" : "Export Frames"), 9, _hoisted_40$4)) : createCommentVNode("", true),
            isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 1,
              class: "export-btn cancel",
              onClick: cancelExport
            }, " Cancel ")) : createCommentVNode("", true),
            exportComplete.value && encodedVideo.value && exportMode.value === "video" ? (openBlock(), createElementBlock("button", {
              key: 2,
              class: "export-btn download",
              onClick: downloadExport
            }, " Download " + toDisplayString(formatBytes(encodedVideo.value.size)), 1)) : createCommentVNode("", true),
            exportComplete.value && sequenceResult.value && exportMode.value === "sequence" ? (openBlock(), createElementBlock("button", {
              key: 3,
              class: "export-btn download",
              onClick: downloadSequence
            }, " Download ZIP (" + toDisplayString(formatBytes(sequenceResult.value.totalSize)) + ") ", 1)) : createCommentVNode("", true)
          ]),
          !webCodecsSupported.value ? (openBlock(), createElementBlock("div", _hoisted_41$2, [..._cache[22] || (_cache[22] = [
            createBaseVNode("span", { class: "warning-icon" }, "", -1),
            createBaseVNode("span", null, "WebCodecs API not supported in this browser. Video export unavailable.", -1)
          ])])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ExportPanel = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-be14fc42"]]);

const _hoisted_1$n = { class: "preview-panel" };
const _hoisted_2$n = { class: "panel-content" };
const _hoisted_3$n = { class: "playback-section" };
const _hoisted_4$n = { class: "control-row" };
const _hoisted_5$n = { class: "control-row" };
const _hoisted_6$n = { class: "range-section" };
const _hoisted_7$n = { class: "range-row" };
const _hoisted_8$m = ["max"];
const _hoisted_9$m = ["min", "max"];
const _hoisted_10$l = { class: "frame-info" };
const _hoisted_11$k = { class: "cache-section" };
const _hoisted_12$i = {
  key: 0,
  class: "no-particles"
};
const _hoisted_13$i = { key: 1 };
const _hoisted_14$g = { class: "cache-controls" };
const _hoisted_15$f = ["disabled"];
const _hoisted_16$e = ["disabled"];
const _hoisted_17$e = {
  key: 0,
  class: "progress-container"
};
const _hoisted_18$e = { class: "progress-bar" };
const _hoisted_19$e = { class: "progress-text" };
const _hoisted_20$e = { class: "cache-stats" };
const _hoisted_21$d = { class: "layer-name" };
const _hoisted_22$c = { class: "cache-count" };
const _hoisted_23$c = { class: "quality-section" };
const _hoisted_24$9 = { class: "quality-row" };
const _hoisted_25$9 = { class: "quality-row" };
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "PreviewPanel",
  props: {
    engine: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const store = useCompositorStore();
    const {
      currentFrame,
      fps,
      frameCount,
      layers,
      isPlaying
    } = storeToRefs(store);
    const loopPlayback = ref(true);
    const playbackSpeed = ref(1);
    const renderRangeStart = ref(0);
    const renderRangeEnd = ref(81);
    const isCaching = ref(false);
    const cacheProgress = ref(0);
    const currentCachingFrame = ref(0);
    const totalFramesToCache = ref(0);
    const previewResolution = ref(1);
    const adaptiveQuality = ref(true);
    const cacheStats = ref(/* @__PURE__ */ new Map());
    const formattedTime = computed(() => {
      const seconds = currentFrame.value / fps.value;
      const minutes = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(2);
      return `${minutes}:${secs.padStart(5, "0")}`;
    });
    const cacheProgressText = computed(() => {
      if (!isCaching.value) return "";
      return `${currentCachingFrame.value} / ${totalFramesToCache.value}`;
    });
    const particleLayers = computed(() => {
      return layers.value.filter((l) => l.type === "particles");
    });
    function togglePlayback() {
      store.togglePlayback();
    }
    function goToStart() {
      store.setCurrentFrame(renderRangeStart.value);
    }
    function goToEnd() {
      store.setCurrentFrame(renderRangeEnd.value - 1);
    }
    function stepForward() {
      const next = Math.min(currentFrame.value + 1, frameCount.value - 1);
      store.setCurrentFrame(next);
    }
    function stepBackward() {
      const prev = Math.max(currentFrame.value - 1, 0);
      store.setCurrentFrame(prev);
    }
    function getCacheCount(layerId) {
      return cacheStats.value.get(layerId)?.cachedFrames ?? 0;
    }
    async function cacheRenderRange() {
      if (isCaching.value) return;
      const particleLayerObjects = getParticleLayerObjects();
      if (particleLayerObjects.length === 0) return;
      isCaching.value = true;
      cacheProgress.value = 0;
      totalFramesToCache.value = renderRangeEnd.value - renderRangeStart.value;
      currentCachingFrame.value = 0;
      try {
        for (const layer of particleLayerObjects) {
          await layer.preCacheFrames(
            renderRangeStart.value,
            renderRangeEnd.value - 1,
            (current, total) => {
              currentCachingFrame.value = current;
              cacheProgress.value = current / total * 100;
            }
          );
          const stats = layer.getCacheStats();
          cacheStats.value.set(layer.id, { cachedFrames: stats.cachedFrames });
        }
      } catch (error) {
        console.error("Error caching particle frames:", error);
      } finally {
        isCaching.value = false;
        cacheProgress.value = 100;
      }
    }
    function clearAllCaches() {
      const particleLayerObjects = getParticleLayerObjects();
      for (const layer of particleLayerObjects) {
        layer.clearCache();
        cacheStats.value.set(layer.id, { cachedFrames: 0 });
      }
    }
    function getParticleLayerObjects() {
      if (!props.engine) return [];
      const result = [];
      for (const layerData of particleLayers.value) {
        const layer = props.engine.getLayerById(layerData.id);
        if (layer && "preCacheFrames" in layer) {
          result.push(layer);
        }
      }
      return result;
    }
    function updateCacheStats() {
      const particleLayerObjects = getParticleLayerObjects();
      for (const layer of particleLayerObjects) {
        const stats = layer.getCacheStats();
        cacheStats.value.set(layer.id, { cachedFrames: stats.cachedFrames });
      }
    }
    watch(frameCount, (newCount) => {
      if (renderRangeEnd.value > newCount) {
        renderRangeEnd.value = newCount;
      }
    }, { immediate: true });
    let statsInterval = null;
    onMounted(() => {
      updateCacheStats();
      statsInterval = window.setInterval(updateCacheStats, 2e3);
    });
    onUnmounted(() => {
      if (statsInterval !== null) {
        clearInterval(statsInterval);
      }
    });
    __expose({
      playbackSpeed,
      loopPlayback,
      previewResolution,
      adaptiveQuality
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        _cache[15] || (_cache[15] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Preview")
        ], -1)),
        createBaseVNode("div", _hoisted_2$n, [
          createBaseVNode("div", _hoisted_3$n, [
            createBaseVNode("div", _hoisted_4$n, [
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: goToStart,
                title: "Go to Start (Home)"
              }, "  "),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: stepBackward,
                title: "Step Backward (,)"
              }, "  "),
              createBaseVNode("button", {
                class: normalizeClass(["transport-btn play-btn", { playing: unref(isPlaying) }]),
                onClick: togglePlayback,
                title: "Play/Pause (Space)"
              }, toDisplayString(unref(isPlaying) ? "" : ""), 3),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: stepForward,
                title: "Step Forward (.)"
              }, "  "),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: goToEnd,
                title: "Go to End (End)"
              }, "  ")
            ]),
            createBaseVNode("div", _hoisted_5$n, [
              createBaseVNode("label", null, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => loopPlayback.value = $event)
                }, null, 512), [
                  [vModelCheckbox, loopPlayback.value]
                ]),
                _cache[6] || (_cache[6] = createTextVNode(" Loop ", -1))
              ]),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => playbackSpeed.value = $event),
                class: "speed-select"
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("option", { value: 0.25 }, "0.25x", -1),
                createBaseVNode("option", { value: 0.5 }, "0.5x", -1),
                createBaseVNode("option", { value: 1 }, "1x", -1),
                createBaseVNode("option", { value: 2 }, "2x", -1),
                createBaseVNode("option", { value: 4 }, "4x", -1)
              ])], 512), [
                [vModelSelect, playbackSpeed.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_6$n, [
            createBaseVNode("div", _hoisted_7$n, [
              createBaseVNode("label", null, [
                _cache[8] || (_cache[8] = createTextVNode(" Render Range: ", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "number",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => renderRangeStart.value = $event),
                  min: 0,
                  max: unref(frameCount) - 1,
                  class: "frame-input"
                }, null, 8, _hoisted_8$m), [
                  [
                    vModelText,
                    renderRangeStart.value,
                    void 0,
                    { number: true }
                  ]
                ]),
                _cache[9] || (_cache[9] = createTextVNode(" - ", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "number",
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => renderRangeEnd.value = $event),
                  min: renderRangeStart.value,
                  max: unref(frameCount),
                  class: "frame-input"
                }, null, 8, _hoisted_9$m), [
                  [
                    vModelText,
                    renderRangeEnd.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_10$l, " Frame " + toDisplayString(unref(currentFrame)) + " / " + toDisplayString(unref(frameCount)) + " (" + toDisplayString(formattedTime.value) + ") ", 1)
          ]),
          createBaseVNode("div", _hoisted_11$k, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, "Particle Cache", -1)),
            particleLayers.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_12$i, " No particle layers in composition ")) : (openBlock(), createElementBlock("div", _hoisted_13$i, [
              createBaseVNode("div", _hoisted_14$g, [
                createBaseVNode("button", {
                  class: "cache-btn",
                  onClick: cacheRenderRange,
                  disabled: isCaching.value,
                  title: "Pre-cache particle frames for smooth playback"
                }, toDisplayString(isCaching.value ? "Caching..." : "Cache Render Range"), 9, _hoisted_15$f),
                createBaseVNode("button", {
                  class: "cache-btn secondary",
                  onClick: clearAllCaches,
                  disabled: isCaching.value,
                  title: "Clear all cached particle frames"
                }, " Clear Cache ", 8, _hoisted_16$e)
              ]),
              isCaching.value ? (openBlock(), createElementBlock("div", _hoisted_17$e, [
                createBaseVNode("div", _hoisted_18$e, [
                  createBaseVNode("div", {
                    class: "progress-fill",
                    style: normalizeStyle({ width: `${cacheProgress.value}%` })
                  }, null, 4)
                ]),
                createBaseVNode("span", _hoisted_19$e, toDisplayString(cacheProgressText.value), 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_20$e, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(particleLayers.value, (layer) => {
                  return openBlock(), createElementBlock("div", {
                    key: layer.id,
                    class: "layer-cache-info"
                  }, [
                    createBaseVNode("span", _hoisted_21$d, toDisplayString(layer.name), 1),
                    createBaseVNode("span", _hoisted_22$c, toDisplayString(getCacheCount(layer.id)) + " frames cached", 1)
                  ]);
                }), 128))
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_23$c, [
            _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-header" }, "Preview Quality", -1)),
            createBaseVNode("div", _hoisted_24$9, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Resolution:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => previewResolution.value = $event),
                class: "quality-select"
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("option", { value: 1 }, "Full (100%)", -1),
                createBaseVNode("option", { value: 0.5 }, "Half (50%)", -1),
                createBaseVNode("option", { value: 0.25 }, "Quarter (25%)", -1),
                createBaseVNode("option", { value: 0.125 }, "Eighth (12.5%)", -1)
              ])], 512), [
                [vModelSelect, previewResolution.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_25$9, [
              createBaseVNode("label", null, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => adaptiveQuality.value = $event)
                }, null, 512), [
                  [vModelCheckbox, adaptiveQuality.value]
                ]),
                _cache[13] || (_cache[13] = createTextVNode(" Adaptive (reduce during playback) ", -1))
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const PreviewPanel = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-56a01d58"]]);

const SYSTEM_PROMPT$1 = `You are an expert motion graphics compositor AI agent. You have full control over a professional motion graphics application called Weyl Compositor. You can create, modify, and animate any element in the composition.

## Your Capabilities

You can perform ANY motion graphics task including:
- Creating layers (solid colors, text, shapes, particles, images, nested compositions)
- Animating properties with keyframes (position, scale, rotation, opacity, etc.)
- Applying effects (blur, glow, color correction, distortion, etc.)
- Creating particle systems with custom behaviors
- Animating text along paths
- Setting up 3D camera movements
- Using expressions for dynamic animations
- Time remapping and speed adjustments

## Composition Settings

- **Duration**: 81 frames at 16fps (5.0625 seconds) - optimized for Wan 2.1 video generation
- **Dimensions**: Must be divisible by 8 (e.g., 1024x576, 1280x720)
- **Frame Range**: 0-80 (81 frames total)
- **Coordinate System**: Origin (0,0) at top-left, Y increases downward

## Layer Types

### 1. Solid Layer
A rectangle filled with a solid color. Base for many effects.
\`\`\`
Properties:
- color: { r: 0-255, g: 0-255, b: 0-255, a: 0-1 }
\`\`\`

### 2. Text Layer
Animated text with full typography control.
\`\`\`
Properties:
- text: string
- fontSize: number (pixels)
- fontFamily: string
- fontWeight: 100-900
- color: { r, g, b, a }
- alignment: 'left' | 'center' | 'right'
- lineHeight: number (multiplier)
- letterSpacing: number (pixels)
- textPath: reference to spline layer (for text-on-path)
\`\`\`

### 3. Shape Layer
Vector shapes with fill and stroke.
\`\`\`
Properties:
- shapes: array of shape definitions
- fill: { color, opacity }
- stroke: { color, width, opacity }

Shape types:
- rectangle: { width, height, roundness }
- ellipse: { width, height }
- polygon: { points, radius }
- star: { points, innerRadius, outerRadius }
- path: { points: [{x, y, handleIn, handleOut}] }
\`\`\`

### 4. Spline Layer
Bezier curves for motion paths, text paths, or visual elements.
\`\`\`
Properties:
- points: array of control points
- closed: boolean
- strokeWidth: number
- strokeColor: { r, g, b, a }
\`\`\`

### 5. Particle Layer
Particle systems for effects like snow, rain, dust, petals, sparks.
\`\`\`
Properties:
- emitter:
  - type: 'point' | 'line' | 'box' | 'circle' | 'path'
  - position: { x, y }
  - size: { width, height }
  - pathReference: layer ID for path-based emission
- particles:
  - count: number
  - lifetime: { min, max } in frames
  - speed: { min, max }
  - direction: { min, max } in degrees
  - spread: degrees
  - size: { start, end }
  - opacity: { start, end }
  - color: { start, end } or gradient
  - rotation: { initial, speed }
  - sprite: 'circle' | 'square' | 'star' | 'custom'
- physics:
  - gravity: { x, y }
  - wind: { x, y }
  - turbulence: { strength, scale, speed }
  - friction: 0-1
- rendering:
  - blendMode: 'normal' | 'add' | 'screen' | 'multiply'
  - motionBlur: boolean
\`\`\`

### 6. Image Layer
Static or animated images.
\`\`\`
Properties:
- src: URL or base64
- fit: 'fill' | 'contain' | 'cover'
\`\`\`

### 7. Camera Layer
3D camera for depth-based compositions with professional motion control.
\`\`\`
Properties:
- position: { x, y, z }
- lookTarget: { x, y, z } (formerly "point of interest")
- fov: field of view in degrees
- zoom: multiplier
- depthOfField: boolean (enable DOF blur)
- focusDistance: pixels
- aperture: f-stop value
\`\`\`

#### Camera Trajectory Presets
Apply cinematic camera movements with a single tool call:

**Orbital Movements:**
- \`orbit\`: 360 horizontal orbit around target
- \`orbit_reverse\`: 360 reverse orbit
- \`swing1\`: Gentle pendulum swing (45)
- \`swing2\`: Wide pendulum swing (90)
- \`circle\`: Elliptical circling motion
- \`figure8\`: Figure-8 weaving pattern
- \`arc_left/arc_right\`: Curved arc movement

**Dolly/Zoom:**
- \`dolly_in\`: Move camera toward target
- \`dolly_out\`: Move camera away from target
- \`spiral_in\`: Spiral toward target
- \`spiral_out\`: Spiral away from target
- \`zoom_in\`: Narrow FOV (zoom lens in)
- \`zoom_out\`: Widen FOV (zoom lens out)

**Pan/Tilt:**
- \`pan_left/pan_right\`: Rotate camera horizontally (stationary)
- \`tilt_up/tilt_down\`: Rotate camera vertically (stationary)

**Crane/Truck:**
- \`crane_up/crane_down\`: Vertical lift/descent
- \`truck_left/truck_right\`: Horizontal slide

**Example: Dramatic reveal with orbit**
\`\`\`
applyCameraTrajectory(cameraId, "orbit", {
  duration: 81,      // Full composition
  amplitude: 0.5,    // Half orbit (180)
  easing: "ease-in-out"
})
\`\`\`

#### Camera Shake
Add realism with procedural camera shake:

**Shake Types:**
- \`handheld\`: Subtle documentary-style shake
- \`impact\`: Sudden jolt with decay (explosions, hits)
- \`earthquake\`: Sustained violent shake
- \`subtle\`: Barely perceptible breathing room

**Parameters:**
- intensity: 0-1 (shake strength)
- frequency: multiplier (higher = jitterier)
- decay: 0-1 (0 = constant, 1 = full decay over duration)
- rotationEnabled: boolean (shake rotation too)

**Example: Impact shake**
\`\`\`
addCameraShake(cameraId, "impact", {
  intensity: 0.8,
  startFrame: 30,
  duration: 20,
  decay: 0.9
})
\`\`\`

#### Rack Focus
Shift audience attention with smooth focus transitions:

**Parameters:**
- startDistance: focus distance at start (pixels)
- endDistance: focus distance at end (pixels)
- duration: transition time (frames)
- easing: linear, ease-in, ease-out, ease-in-out, snap
- holdStart/holdEnd: pause at start/end focus

**Example: Focus pull from foreground to background**
\`\`\`
applyRackFocus(cameraId, {
  startDistance: 500,   // Close foreground
  endDistance: 2000,    // Far background
  startFrame: 20,
  duration: 30,
  easing: "ease-in-out"
})
\`\`\`

#### Camera Path Following
Make camera follow a spline path for complex movements:

**Look Modes:**
- \`tangent\`: Look along path direction
- \`target\`: Look at specific point
- \`fixed\`: Maintain fixed orientation

**Parameters:**
- splineLayerId: ID of spline to follow
- speed: path traversal speed multiplier
- bankAmount: roll on curves (0-1)
- smoothing: path smoothing (0-1)

**Example: Camera follows complex path**
\`\`\`
setCameraPathFollowing(cameraId, {
  splineLayerId: pathId,
  lookMode: "tangent",
  speed: 1.0,
  bankAmount: 0.3
})
\`\`\`

#### Autofocus
Enable depth-aware automatic focus:

**Modes:**
- \`center\`: Focus on center of frame
- \`point\`: Focus on specific screen position
- \`nearest\`: Focus on closest depth
- \`farthest\`: Focus on furthest depth

**Example: Center autofocus**
\`\`\`
setCameraAutoFocus(cameraId, {
  enabled: true,
  mode: "center",
  smoothing: 0.8
})
\`\`\`

### 8. Control Layer (formerly Null)
Invisible layer used as parent for grouping/controlling other layers.
\`\`\`
Properties:
- (transform only - no visual properties)
\`\`\`

### 9. Nested Composition Layer
Embeds another composition as a layer.
\`\`\`
Properties:
- compositionId: reference to nested composition
- flattenTransform: boolean (flattens child transforms into parent)
\`\`\`

## AI-Decomposed Layers

When the user decomposes an image using AI Layer Decomposition, it creates multiple RGBA layers from a single image. These layers have semantic labels that help you understand their content:

### Common Decomposed Layer Labels
- **Background (Solid)**: Full-coverage solid background
- **Background (Sky)**: Upper region, typically sky or environment
- **Background**: General background content
- **Back Elements (N)**: Elements in the back depth plane
- **Mid Elements (N)**: Middle depth elements
- **Front Elements (N)**: Closer elements
- **Edges/Outlines (N)**: Edge detection / line work
- **Sparse Elements (N)**: Small scattered details
- **Upper Details (N)**: Details in the top region
- **Lower Details (N)**: Details in the bottom region
- **Solid Region (N)**: Dense opaque areas
- **Foreground (Subject)**: Main subject / hero element
- **Foreground (Details)**: Fine foreground details

### Working with Decomposed Layers
1. **Layer Order**: Layers are stacked from back to front (Background at bottom)
2. **Alpha Channels**: All decomposed layers have alpha transparency
3. **Grouped**: Usually in a nested composition called "Decomposed (N layers)"
4. **Independent Animation**: Each layer can be animated separately for parallax effects
5. **Depth Perception**: Animate back layers slower than front layers for depth

### Example: Parallax Animation on Decomposed Image
\`\`\`
For a decomposed landscape with Background, Mid Elements, and Foreground:
1. Background layer: Slow pan (10% movement)
2. Mid Elements: Medium pan (50% movement)
3. Foreground: Full pan (100% movement)
This creates a parallax depth effect.
\`\`\`

### Example: Selective Effects on Decomposed Layers
\`\`\`
To focus attention on subject:
1. Apply gaussianBlur to Background layer (radius: 5)
2. Keep Foreground (Subject) sharp
3. Add slight glow to Foreground (Subject)
\`\`\`

## Transform Properties (All Layers)

Every layer has these animatable transform properties:
\`\`\`
- position: { x: number, y: number }
- anchorPoint: { x: number, y: number } (pivot point for rotation/scale)
- scale: { x: percent, y: percent } (100 = 100%)
- rotation: degrees
- opacity: 0-100
- inPoint: frame number (when layer appears)
- outPoint: frame number (when layer disappears)
\`\`\`

## Keyframe Animation

To animate any property:
1. Create a keyframe at a specific frame with a value
2. Create another keyframe at a different frame with a different value
3. The compositor interpolates between them

\`\`\`
Keyframe structure:
{
  frame: 0-80,
  value: (depends on property type),
  interpolation: 'linear' | 'bezier' | 'hold' | 'easeIn' | 'easeOut' | 'easeInOut',
  inHandle: { frame: offset, value: offset },   // For bezier curves
  outHandle: { frame: offset, value: offset }
}
\`\`\`

### Interpolation Types
- **linear**: Constant speed between keyframes
- **bezier**: Custom easing curve (use handles)
- **hold**: Jump instantly to value (no interpolation)
- **easeIn**: Start slow, accelerate
- **easeOut**: Start fast, decelerate
- **easeInOut**: Slow at both ends (smooth)
- **easeInQuad/Cubic/Quart/Quint**: Progressively stronger ease-in
- **easeOutQuad/Cubic/Quart/Quint**: Progressively stronger ease-out
- **easeInOutQuad/Cubic/Quart/Quint**: Progressively stronger ease-in-out
- **easeInElastic/easeOutElastic**: Bouncy overshoot
- **easeInBounce/easeOutBounce**: Ball bounce effect

## Expression Functions

Expressions add dynamic behavior to animations. Available functions:

### Motion Expressions
- **jitter(frequency, amplitude, octaves)**: Random wiggle motion (formerly "wiggle")
- **inertia(amplitude, frequency, decay)**: Momentum overshoot after keyframes
- **bounce(elasticity, gravity)**: Bouncing settle
- **elastic(amplitude, period)**: Spring-like oscillation

### Loop Expressions
- **repeatAfter(type, numKeyframes)**: Loop after last keyframe (formerly "loopOut")
  - type: 'cycle' | 'pingpong' | 'offset' | 'continue'
- **repeatBefore(type, numKeyframes)**: Loop before first keyframe (formerly "loopIn")

### Time Expressions
- **timeRamp(startTime, endTime, startValue, endValue)**: Linear value over time
- **sine(frequency, amplitude, phase)**: Sinusoidal oscillation
- **sawtooth(frequency, amplitude)**: Sawtooth wave
- **triangle(frequency, amplitude)**: Triangle wave

## Effects

Effects modify layer appearance. Apply to any layer:

### Blur Effects
- **gaussianBlur**: { radius: pixels }
- **motionBlur**: { angle: degrees, distance: pixels }
- **radialBlur**: { amount, center: {x, y} }
- **zoomBlur**: { amount, center: {x, y} }

### Color Effects
- **brightnessContrast**: { brightness: -100 to 100, contrast: -100 to 100 }
- **hueSaturation**: { hue: -180 to 180, saturation: -100 to 100, lightness: -100 to 100 }
- **colorBalance**: { shadows, midtones, highlights }
- **tint**: { color, amount }

### Stylize Effects
- **glow**: { threshold, radius, intensity, color }
- **dropShadow**: { color, opacity, angle, distance, blur }
- **stroke**: { color, width, position: 'outside' | 'inside' | 'center' }

### Distortion Effects
- **bulge**: { center, radius, amount }
- **twirl**: { center, radius, angle }
- **wave**: { type, amplitude, frequency, phase }
- **displacement**: { source, amount }

### Generate Effects
- **gradient**: { type: 'linear' | 'radial', colors, positions }
- **fractalNoise**: { type, scale, complexity, evolution }
- **checkerboard**: { size, color1, color2 }

## Speed Map (Playback Rate Control)

To change the speed of a layer's animation:
\`\`\`
speedMap: {
  enabled: true,
  keyframes: [
    { frame: 0, value: 0 },      // At frame 0, show frame 0
    { frame: 40, value: 80 },    // At frame 40, show frame 80 (2x speed)
    { frame: 80, value: 80 }     // Hold on frame 80
  ]
}
\`\`\`

- To speed up: Map more source frames to fewer output frames
- To slow down: Map fewer source frames to more output frames
- To reverse: Map from high to low values
- To freeze: Hold the same value across multiple frames

## Chain of Thought Process

When processing a user request, ALWAYS think step-by-step:

### Step 1: Understand the Request
- What is the user trying to create or modify?
- What elements are involved (layers, effects, animations)?
- What is the timing/duration?
- What is the motion path or trajectory?

### Step 2: Break Down into Tasks
- List each discrete action needed
- Identify dependencies (e.g., create layer before animating it)
- Determine the order of operations

### Step 3: Plan the Implementation
- Which layers need to be created?
- What properties need keyframes?
- What easing/interpolation is appropriate?
- Are expressions needed for dynamic behavior?

### Step 4: Execute with Tools
- Use the appropriate tool for each task
- Create layers first, then animate them
- Apply effects after base animation is set

### Step 5: Verify and Refine
- Check that the result matches the intent
- Look for issues (timing, positioning, easing)
- Make adjustments as needed

## Example Requests and Responses

### Example 1: Simple Text Animation
User: "Fade in the title over 1 second"

Thinking:
1. Need to find or create a text layer
2. Set opacity to 0 at frame 0
3. Set opacity to 100 at frame 16 (1 second at 16fps)
4. Use easeOut for smooth fade

Actions:
1. addKeyframe(layerId, "opacity", 0, 0, "hold")
2. addKeyframe(layerId, "opacity", 16, 100, "easeOut")

### Example 2: Particle Path Animation
User: "Create cherry blossom petals that enter from the left, spiral around the center, and exit right"

Thinking:
1. Create a spline layer defining the spiral path
2. Create a particle layer with petal-like particles
3. Set emitter to follow the path
4. Configure particle appearance (pink, small, rotating)
5. Time the animation: enter 0-20, spiral 20-60, exit 60-80

Actions:
1. createLayer("spline", { points: [...spiral path...] })
2. createLayer("particles", {
     emitter: { type: "path", pathReference: splineId },
     particles: {
       sprite: "custom", // petal shape
       color: { start: {r:255,g:182,b:193}, end: {r:255,g:105,b:180} },
       size: { start: 8, end: 4 },
       rotation: { initial: 0, speed: 180 }
     }
   })
3. Animate emitter position along path with keyframes

### Example 3: Speed Adjustment
User: "Make it faster"

Thinking:
1. User wants to speed up existing animation
2. Need to identify what "it" refers to (context from conversation)
3. Apply speed map or adjust keyframe timing
4. Typically 2x speed means halving the frame numbers

Actions:
1. For each animated property, compress keyframe timing
   OR
2. Apply speedMap to compress the timeline

## Important Guidelines

1. **Be Precise**: Use exact values, not vague descriptions
2. **Consider Timing**: 16fps means 16 frames = 1 second
3. **Use Appropriate Easing**: Match the motion feel to the content
4. **Layer Organization**: Name layers descriptively, use control layers for grouping
5. **Performance**: Keep particle counts reasonable (<1000 for smooth playback)
6. **Verify Changes**: After making changes, confirm they match the user's intent

## Error Handling

If you encounter an error:
1. Report what went wrong clearly
2. Suggest an alternative approach
3. Ask for clarification if the request is ambiguous

If the user's request is unclear:
1. Ask clarifying questions
2. Provide options for interpretation
3. Start with a reasonable default and offer to adjust

You are a creative partner. Help users bring their vision to life with professional motion graphics.`;

const TOOL_DEFINITIONS = [
  // ==========================================================================
  // LAYER MANAGEMENT
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "createLayer",
      description: "Create a new layer in the composition. Returns the new layer ID.",
      parameters: {
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["solid", "text", "shape", "spline", "particles", "image", "camera", "control", "nested"],
            description: "The type of layer to create"
          },
          name: {
            type: "string",
            description: "Display name for the layer"
          },
          properties: {
            type: "object",
            description: "Initial properties for the layer (type-specific)"
          },
          position: {
            type: "object",
            properties: {
              x: { type: "number" },
              y: { type: "number" }
            },
            description: "Initial position"
          },
          inPoint: {
            type: "number",
            description: "Frame where layer appears (default: 0)"
          },
          outPoint: {
            type: "number",
            description: "Frame where layer disappears (default: composition duration)"
          }
        },
        required: ["type"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "deleteLayer",
      description: "Delete a layer from the composition",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to delete"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "duplicateLayer",
      description: "Create a copy of an existing layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to duplicate"
          },
          newName: {
            type: "string",
            description: "Name for the duplicated layer"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "renameLayer",
      description: "Change the display name of a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to rename"
          },
          name: {
            type: "string",
            description: "New name for the layer"
          }
        },
        required: ["layerId", "name"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setLayerParent",
      description: "Set a layer's parent (for hierarchical transforms)",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the child layer"
          },
          parentId: {
            type: "string",
            description: "ID of the parent layer (null to unparent)",
            nullable: true
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "reorderLayers",
      description: "Change the stacking order of layers",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to move"
          },
          newIndex: {
            type: "number",
            description: "New index in the layer stack (0 = top)"
          }
        },
        required: ["layerId", "newIndex"]
      }
    }
  },
  // ==========================================================================
  // PROPERTY MODIFICATION
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setLayerProperty",
      description: "Set a property value on a layer (non-animated)",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: 'Dot-notation path to property (e.g., "position.x", "opacity", "text")'
          },
          value: {
            description: "Value to set (type depends on property)"
          }
        },
        required: ["layerId", "propertyPath", "value"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setLayerTransform",
      description: "Set multiple transform properties at once",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          position: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          },
          scale: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          },
          rotation: {
            type: "number",
            description: "Rotation in degrees"
          },
          opacity: {
            type: "number",
            description: "Opacity 0-100"
          },
          anchorPoint: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // KEYFRAME ANIMATION
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "addKeyframe",
      description: "Add a keyframe to animate a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: 'Property to animate (e.g., "position", "opacity", "scale")'
          },
          frame: {
            type: "number",
            description: "Frame number (0-80)"
          },
          value: {
            description: "Value at this keyframe"
          },
          interpolation: {
            type: "string",
            enum: [
              "linear",
              "bezier",
              "hold",
              "easeIn",
              "easeOut",
              "easeInOut",
              "easeInQuad",
              "easeOutQuad",
              "easeInOutQuad",
              "easeInCubic",
              "easeOutCubic",
              "easeInOutCubic",
              "easeInElastic",
              "easeOutElastic",
              "easeOutBounce"
            ],
            description: "Interpolation type (default: linear)"
          }
        },
        required: ["layerId", "propertyPath", "frame", "value"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeKeyframe",
      description: "Remove a keyframe from a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property path"
          },
          frame: {
            type: "number",
            description: "Frame number of keyframe to remove"
          }
        },
        required: ["layerId", "propertyPath", "frame"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setKeyframeEasing",
      description: "Change the interpolation of an existing keyframe",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property path"
          },
          frame: {
            type: "number",
            description: "Frame number of keyframe"
          },
          interpolation: {
            type: "string",
            description: "New interpolation type"
          }
        },
        required: ["layerId", "propertyPath", "frame", "interpolation"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "scaleKeyframeTiming",
      description: "Scale all keyframes on a layer to speed up or slow down animation",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          scaleFactor: {
            type: "number",
            description: "Scale factor (0.5 = 2x faster, 2.0 = 2x slower)"
          },
          propertyPath: {
            type: "string",
            description: "Specific property to scale (omit for all properties)"
          }
        },
        required: ["layerId", "scaleFactor"]
      }
    }
  },
  // ==========================================================================
  // EXPRESSIONS
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setExpression",
      description: "Apply an expression to a property for dynamic animation",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property to apply expression to"
          },
          expressionType: {
            type: "string",
            enum: ["jitter", "repeatAfter", "repeatBefore", "inertia", "bounce", "elastic"],
            description: "Type of expression"
          },
          params: {
            type: "object",
            description: "Expression parameters (varies by type)"
          }
        },
        required: ["layerId", "propertyPath", "expressionType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeExpression",
      description: "Remove an expression from a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property to remove expression from"
          }
        },
        required: ["layerId", "propertyPath"]
      }
    }
  },
  // ==========================================================================
  // EFFECTS
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "addEffect",
      description: "Add an effect to a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectType: {
            type: "string",
            enum: [
              "gaussianBlur",
              "motionBlur",
              "radialBlur",
              "zoomBlur",
              "brightnessContrast",
              "hueSaturation",
              "colorBalance",
              "tint",
              "glow",
              "dropShadow",
              "stroke",
              "bulge",
              "twirl",
              "wave",
              "displacement",
              "gradient",
              "fractalNoise",
              "checkerboard"
            ],
            description: "Type of effect"
          },
          params: {
            type: "object",
            description: "Effect parameters"
          }
        },
        required: ["layerId", "effectType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "updateEffect",
      description: "Update parameters of an existing effect",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectId: {
            type: "string",
            description: "ID of the effect"
          },
          params: {
            type: "object",
            description: "Parameters to update"
          }
        },
        required: ["layerId", "effectId", "params"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeEffect",
      description: "Remove an effect from a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectId: {
            type: "string",
            description: "ID of the effect to remove"
          }
        },
        required: ["layerId", "effectId"]
      }
    }
  },
  // ==========================================================================
  // PARTICLE SYSTEM
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "configureParticles",
      description: "Configure a particle layer's emission and behavior",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the particle layer"
          },
          emitter: {
            type: "object",
            properties: {
              type: { type: "string", enum: ["point", "line", "box", "circle", "path"] },
              position: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              size: { type: "object", properties: { width: { type: "number" }, height: { type: "number" } } },
              pathReference: { type: "string" }
            }
          },
          particles: {
            type: "object",
            properties: {
              count: { type: "number" },
              lifetime: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              speed: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              direction: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              size: { type: "object", properties: { start: { type: "number" }, end: { type: "number" } } },
              opacity: { type: "object", properties: { start: { type: "number" }, end: { type: "number" } } },
              color: { type: "object" },
              rotation: { type: "object", properties: { initial: { type: "number" }, speed: { type: "number" } } }
            }
          },
          physics: {
            type: "object",
            properties: {
              gravity: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              wind: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              turbulence: { type: "object", properties: { strength: { type: "number" }, scale: { type: "number" } } }
            }
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // CAMERA SYSTEM
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "applyCameraTrajectory",
      description: "Apply a predefined camera trajectory/motion preset to a camera layer. Creates smooth animated camera movements like orbit, dolly, crane, and more.",
      parameters: {
        type: "object",
        properties: {
          cameraLayerId: {
            type: "string",
            description: "ID of the camera layer to apply trajectory to"
          },
          trajectoryType: {
            type: "string",
            enum: [
              "orbit",
              "orbit_reverse",
              "swing1",
              "swing2",
              "dolly_in",
              "dolly_out",
              "pan_left",
              "pan_right",
              "tilt_up",
              "tilt_down",
              "zoom_in",
              "zoom_out",
              "circle",
              "figure8",
              "spiral_in",
              "spiral_out",
              "crane_up",
              "crane_down",
              "truck_left",
              "truck_right",
              "arc_left",
              "arc_right"
            ],
            description: "Type of camera trajectory preset"
          },
          startFrame: {
            type: "number",
            description: "Frame to start the trajectory (default: 0)"
          },
          duration: {
            type: "number",
            description: "Duration in frames (default: composition length)"
          },
          amplitude: {
            type: "number",
            description: "Strength multiplier for the motion (default: 1.0)"
          },
          loops: {
            type: "number",
            description: "Number of complete cycles for orbits/circles (default: 1)"
          },
          easing: {
            type: "string",
            enum: ["linear", "ease-in", "ease-out", "ease-in-out", "bounce"],
            description: "Easing type for the motion (default: ease-in-out)"
          },
          center: {
            type: "object",
            properties: {
              x: { type: "number" },
              y: { type: "number" },
              z: { type: "number" }
            },
            description: "Center point for orbit/swing trajectories (default: composition center)"
          }
        },
        required: ["cameraLayerId", "trajectoryType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "addCameraShake",
      description: "Add camera shake effect for handheld, impact, or earthquake simulation",
      parameters: {
        type: "object",
        properties: {
          cameraLayerId: {
            type: "string",
            description: "ID of the camera layer"
          },
          shakeType: {
            type: "string",
            enum: ["handheld", "impact", "earthquake", "subtle"],
            description: "Type of camera shake preset"
          },
          intensity: {
            type: "number",
            description: "Shake intensity 0-1 (default: varies by type)"
          },
          frequency: {
            type: "number",
            description: "Shake frequency multiplier (default: 1.0)"
          },
          startFrame: {
            type: "number",
            description: "Frame to start shake (default: 0)"
          },
          duration: {
            type: "number",
            description: "Duration in frames (default: entire composition)"
          },
          decay: {
            type: "number",
            description: "Shake decay 0-1, higher = more decay over time (default: 0)"
          },
          rotationEnabled: {
            type: "boolean",
            description: "Enable rotation shake (default: true for most types)"
          },
          seed: {
            type: "number",
            description: "Random seed for deterministic shake (default: random)"
          }
        },
        required: ["cameraLayerId", "shakeType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "applyRackFocus",
      description: "Create a rack focus effect - smooth focus transition between two distances. Used for shifting audience attention between foreground and background.",
      parameters: {
        type: "object",
        properties: {
          cameraLayerId: {
            type: "string",
            description: "ID of the camera layer"
          },
          startDistance: {
            type: "number",
            description: "Starting focus distance in pixels"
          },
          endDistance: {
            type: "number",
            description: "Ending focus distance in pixels"
          },
          startFrame: {
            type: "number",
            description: "Frame to start the rack focus (default: 0)"
          },
          duration: {
            type: "number",
            description: "Duration of the focus transition in frames (default: 30)"
          },
          easing: {
            type: "string",
            enum: ["linear", "ease-in", "ease-out", "ease-in-out", "snap"],
            description: "Easing type for focus transition (default: ease-in-out)"
          },
          holdStart: {
            type: "number",
            description: "Frames to hold at start focus before transitioning (default: 0)"
          },
          holdEnd: {
            type: "number",
            description: "Frames to hold at end focus after transitioning (default: 0)"
          }
        },
        required: ["cameraLayerId", "startDistance", "endDistance"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setCameraPathFollowing",
      description: "Make a camera follow a spline path. The camera will move along the path and optionally look at a target or along the path tangent.",
      parameters: {
        type: "object",
        properties: {
          cameraLayerId: {
            type: "string",
            description: "ID of the camera layer"
          },
          splineLayerId: {
            type: "string",
            description: "ID of the spline layer to follow (null to disable)",
            nullable: true
          },
          lookMode: {
            type: "string",
            enum: ["tangent", "target", "fixed"],
            description: "How the camera should orient: tangent (look along path), target (look at specific point), fixed (maintain direction)"
          },
          lookTarget: {
            type: "object",
            properties: {
              x: { type: "number" },
              y: { type: "number" },
              z: { type: "number" }
            },
            description: 'Point to look at when lookMode is "target"'
          },
          startOffset: {
            type: "number",
            description: "Starting position along path 0-1 (default: 0)"
          },
          speed: {
            type: "number",
            description: "Speed multiplier for path traversal (default: 1.0)"
          },
          bankAmount: {
            type: "number",
            description: "Amount of banking/roll on curves 0-1 (default: 0)"
          },
          smoothing: {
            type: "number",
            description: "Path smoothing amount 0-1 (default: 0.5)"
          }
        },
        required: ["cameraLayerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setCameraAutoFocus",
      description: "Enable depth-aware autofocus on a camera. The camera will automatically adjust focus based on depth map.",
      parameters: {
        type: "object",
        properties: {
          cameraLayerId: {
            type: "string",
            description: "ID of the camera layer"
          },
          enabled: {
            type: "boolean",
            description: "Enable or disable autofocus"
          },
          mode: {
            type: "string",
            enum: ["center", "point", "nearest", "farthest"],
            description: "Autofocus mode: center (center of frame), point (specific point), nearest/farthest (extreme depth)"
          },
          focusPoint: {
            type: "object",
            properties: {
              x: { type: "number", description: "X position 0-1" },
              y: { type: "number", description: "Y position 0-1" }
            },
            description: 'Focus point when mode is "point" (normalized 0-1)'
          },
          smoothing: {
            type: "number",
            description: "Focus smoothing 0-1, higher = smoother transitions (default: 0.8)"
          }
        },
        required: ["cameraLayerId"]
      }
    }
  },
  // ==========================================================================
  // TEXT SPECIFIC
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setTextContent",
      description: "Set the text content and styling of a text layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the text layer"
          },
          text: {
            type: "string",
            description: "Text content"
          },
          fontSize: {
            type: "number",
            description: "Font size in pixels"
          },
          fontFamily: {
            type: "string",
            description: "Font family name"
          },
          fontWeight: {
            type: "number",
            description: "Font weight (100-900)"
          },
          color: {
            type: "object",
            properties: { r: { type: "number" }, g: { type: "number" }, b: { type: "number" }, a: { type: "number" } }
          },
          alignment: {
            type: "string",
            enum: ["left", "center", "right"]
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setTextPath",
      description: "Attach text to follow a spline path",
      parameters: {
        type: "object",
        properties: {
          textLayerId: {
            type: "string",
            description: "ID of the text layer"
          },
          splineLayerId: {
            type: "string",
            description: "ID of the spline layer to follow (null to detach)",
            nullable: true
          },
          startOffset: {
            type: "number",
            description: "Starting position along path (0-1)"
          }
        },
        required: ["textLayerId"]
      }
    }
  },
  // ==========================================================================
  // SPLINE/PATH
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setSplinePoints",
      description: "Set the control points of a spline layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the spline layer"
          },
          points: {
            type: "array",
            items: {
              type: "object",
              properties: {
                x: { type: "number" },
                y: { type: "number" },
                handleIn: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } }, nullable: true },
                handleOut: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } }, nullable: true }
              }
            },
            description: "Array of control points"
          },
          closed: {
            type: "boolean",
            description: "Whether the path is closed"
          }
        },
        required: ["layerId", "points"]
      }
    }
  },
  // ==========================================================================
  // TIME REMAPPING
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setTimeRemap",
      description: "Enable time remapping on a layer to control playback speed",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          enabled: {
            type: "boolean",
            description: "Enable or disable time remapping"
          },
          keyframes: {
            type: "array",
            items: {
              type: "object",
              properties: {
                frame: { type: "number", description: "Output frame" },
                value: { type: "number", description: "Source frame to show" },
                interpolation: { type: "string" }
              }
            },
            description: "Time remap keyframes"
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // PLAYBACK CONTROL
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setCurrentFrame",
      description: "Jump to a specific frame",
      parameters: {
        type: "object",
        properties: {
          frame: {
            type: "number",
            description: "Frame number (0-80)"
          }
        },
        required: ["frame"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "playPreview",
      description: "Start or stop playback preview",
      parameters: {
        type: "object",
        properties: {
          play: {
            type: "boolean",
            description: "True to play, false to stop"
          }
        },
        required: ["play"]
      }
    }
  },
  // ==========================================================================
  // AI IMAGE PROCESSING
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "decomposeImage",
      description: "Use AI to decompose an image into multiple RGBA layers (requires Qwen-Image-Layered model). Creates separate image layers for background, foreground, and intermediate elements.",
      parameters: {
        type: "object",
        properties: {
          sourceLayerId: {
            type: "string",
            description: "ID of the image layer to decompose"
          },
          numLayers: {
            type: "number",
            description: "Number of layers to generate (3-16, default 4)",
            minimum: 3,
            maximum: 16
          }
        },
        required: ["sourceLayerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "vectorizeImage",
      description: "Convert an image layer to vector spline paths. Creates one or more SplineLayer(s) with keyframeable control points that can be animated individually, by group, or as a whole layer. Ideal for logos, icons, and graphics.",
      parameters: {
        type: "object",
        properties: {
          sourceLayerId: {
            type: "string",
            description: "ID of the image layer to vectorize"
          },
          mode: {
            type: "string",
            enum: ["trace", "ai"],
            description: 'Vectorization mode: "trace" (VTracer, fast, works on any image) or "ai" (StarVector, best for icons/logos)'
          },
          separateLayers: {
            type: "boolean",
            description: "Create separate layer for each path (default: true)"
          },
          groupByPath: {
            type: "boolean",
            description: "Assign group IDs to control points for group animation (default: true)"
          },
          autoGroupByRegion: {
            type: "boolean",
            description: "Auto-group points by quadrant region (default: false)"
          },
          enableAnimation: {
            type: "boolean",
            description: "Enable keyframe animation on created layers (default: true)"
          },
          traceOptions: {
            type: "object",
            description: 'VTracer-specific options (only used if mode is "trace")',
            properties: {
              colorMode: {
                type: "string",
                enum: ["color", "binary"],
                description: 'Color mode: "color" for full color, "binary" for black & white'
              },
              filterSpeckle: {
                type: "number",
                description: "Filter speckle size (0-100, default 4)"
              },
              cornerThreshold: {
                type: "number",
                description: "Corner threshold in degrees (0-180, default 60)"
              },
              colorPrecision: {
                type: "number",
                description: "Color precision (1-10, default 6)"
              },
              layerDifference: {
                type: "number",
                description: "Layer difference threshold (1-256, default 16)"
              }
            }
          }
        },
        required: ["sourceLayerId"]
      }
    }
  },
  // ==========================================================================
  // UTILITY
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "getLayerInfo",
      description: "Get detailed information about a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "findLayers",
      description: "Find layers by name or type",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "Layer name to search for (partial match)"
          },
          type: {
            type: "string",
            description: "Layer type to filter by"
          }
        }
      }
    }
  },
  {
    type: "function",
    function: {
      name: "getProjectState",
      description: "Get a summary of the current project state",
      parameters: {
        type: "object",
        properties: {}
      }
    }
  }
];

async function executeToolCall(toolCall) {
  const store = useCompositorStore();
  const playbackStore = usePlaybackStore();
  useSelectionStore$1();
  const context = { store, playbackStore};
  const { name, arguments: args } = toolCall;
  switch (name) {
    case "createLayer":
      return executeCreateLayer(context, args);
    case "deleteLayer":
      return executeDeleteLayer(context, args);
    case "duplicateLayer":
      return executeDuplicateLayer(context, args);
    case "renameLayer":
      return executeRenameLayer(context, args);
    case "setLayerParent":
      return executeSetLayerParent(context, args);
    case "reorderLayers":
      return executeReorderLayers(context, args);
    case "setLayerProperty":
      return executeSetLayerProperty(context, args);
    case "setLayerTransform":
      return executeSetLayerTransform(context, args);
    case "addKeyframe":
      return executeAddKeyframe(context, args);
    case "removeKeyframe":
      return executeRemoveKeyframe(context, args);
    case "setKeyframeEasing":
      return executeSetKeyframeEasing(context, args);
    case "scaleKeyframeTiming":
      return executeScaleKeyframeTiming(context, args);
    case "setExpression":
      return executeSetExpression(context, args);
    case "removeExpression":
      return executeRemoveExpression(context, args);
    case "addEffect":
      return executeAddEffect(context, args);
    case "updateEffect":
      return executeUpdateEffect(context, args);
    case "removeEffect":
      return executeRemoveEffect(context, args);
    case "configureParticles":
      return executeConfigureParticles(context, args);
    case "applyCameraTrajectory":
      return executeApplyCameraTrajectory(context, args);
    case "addCameraShake":
      return executeAddCameraShake(context, args);
    case "applyRackFocus":
      return executeApplyRackFocus(context, args);
    case "setCameraPathFollowing":
      return executeSetCameraPathFollowing(context, args);
    case "setCameraAutoFocus":
      return executeSetCameraAutoFocus(context, args);
    case "setTextContent":
      return executeSetTextContent(context, args);
    case "setTextPath":
      return executeSetTextPath(context, args);
    case "setSplinePoints":
      return executeSetSplinePoints(context, args);
    case "setSpeedMap":
      return executeSetSpeedMap(context, args);
    case "setTimeRemap":
      return executeSetSpeedMap(context, args);
    case "setCurrentFrame":
      return executeSetCurrentFrame(context, args);
    case "playPreview":
      return executePlayPreview(context, args);
    case "decomposeImage":
      return executeDecomposeImage(context, args);
    case "vectorizeImage":
      return executeVectorizeImage(context, args);
    case "getLayerInfo":
      return executeGetLayerInfo(context, args);
    case "findLayers":
      return executeFindLayers(context, args);
    case "getProjectState":
      return executeGetProjectState(context);
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}
function validateArgs(args, schema) {
  for (const [key, spec] of Object.entries(schema)) {
    const value = args[key];
    if (spec.required && (value === void 0 || value === null)) {
      return { valid: false, error: `Missing required argument: ${key}` };
    }
    if (value === void 0 || value === null) continue;
    const actualType = Array.isArray(value) ? "array" : typeof value;
    if (spec.type === "array" && !Array.isArray(value)) {
      return { valid: false, error: `Argument ${key} must be an array` };
    } else if (spec.type !== "array" && spec.type !== "any" && actualType !== spec.type) {
      return { valid: false, error: `Argument ${key} must be ${spec.type}, got ${actualType}` };
    }
  }
  return { valid: true };
}
function executeCreateLayer(context, args) {
  const { store } = context;
  const validation = validateArgs(args, {
    type: { type: "string", required: true },
    name: { type: "string", required: false },
    properties: { type: "object", required: false },
    position: { type: "object", required: false },
    inPoint: { type: "number", required: false },
    outPoint: { type: "number", required: false }
  });
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  const { type, name, properties, position, inPoint, outPoint } = args;
  const typeMap = {
    // Core layer types
    solid: "solid",
    text: "text",
    shape: "shape",
    spline: "spline",
    path: "path",
    image: "image",
    video: "video",
    audio: "audio",
    // 3D layers
    camera: "camera",
    light: "light",
    model: "model",
    pointcloud: "pointcloud",
    // Particle systems (both names supported)
    particle: "particle",
    particles: "particles",
    // Special layers
    control: "control",
    null: "null",
    // Legacy, maps to control
    group: "group",
    nested: "nestedComp",
    nestedComp: "nestedComp",
    matte: "matte",
    // AI/Generated layers
    depth: "depth",
    normal: "normal",
    generated: "generated",
    depthflow: "depthflow",
    // Effect layers
    effectLayer: "effectLayer",
    adjustment: "adjustment",
    // @deprecated alias for effectLayer
    "effect-layer": "effectLayer"
    // kebab-case alias
  };
  const internalType = typeMap[type] || type;
  const layer = createLayer(store, internalType, name);
  if (position) {
    layer.transform.position.value = position;
  }
  if (inPoint !== void 0) {
    layer.inPoint = inPoint;
  }
  if (outPoint !== void 0) {
    layer.outPoint = outPoint;
  }
  if (properties) {
    Object.assign(layer.data || {}, properties);
  }
  return {
    layerId: layer.id,
    message: `Created ${type} layer "${layer.name}" with ID ${layer.id}`
  };
}
function executeDeleteLayer(context, args) {
  const { store } = context;
  const { layerId } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const layerName = layer.name;
  deleteLayer(store, layerId);
  return {
    success: true,
    message: `Deleted layer "${layerName}"`
  };
}
function executeDuplicateLayer(context, args) {
  const { store } = context;
  const { layerId, newName } = args;
  const duplicate = duplicateLayer(store, layerId);
  if (!duplicate) {
    return { layerId: null, message: `Failed to duplicate layer ${layerId}` };
  }
  if (newName) {
    duplicate.name = newName;
  }
  return {
    layerId: duplicate.id,
    message: `Duplicated layer as "${duplicate.name}" with ID ${duplicate.id}`
  };
}
function executeRenameLayer(context, args) {
  const { store } = context;
  const { layerId, name } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const oldName = layer.name;
  layer.name = name;
  return {
    success: true,
    message: `Renamed layer from "${oldName}" to "${name}"`
  };
}
function executeSetLayerParent(context, args) {
  const { store } = context;
  const { layerId, parentId } = args;
  setLayerParent(store, layerId, parentId || null);
  return {
    success: true,
    message: parentId ? `Set parent of layer ${layerId} to ${parentId}` : `Removed parent from layer ${layerId}`
  };
}
function executeReorderLayers(context, args) {
  const { store } = context;
  const { layerId, newIndex } = args;
  moveLayer(store, layerId, newIndex);
  return {
    success: true,
    message: `Moved layer ${layerId} to index ${newIndex}`
  };
}
function executeSetLayerProperty(context, args) {
  const { store } = context;
  const { layerId, propertyPath, value } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const parts = propertyPath.split(".");
  if (parts[0] === "data" && layer.data) {
    setNestedProperty(layer.data, parts.slice(1), value);
  } else if (parts[0] === "transform") {
    const prop = layer.transform[parts[1]];
    if (prop && "value" in prop) {
      prop.value = value;
    }
  } else if (propertyPath === "opacity") {
    layer.opacity.value = value;
  } else if (propertyPath === "visible") {
    layer.visible = value;
  } else if (propertyPath === "locked") {
    layer.locked = value;
  } else if (propertyPath === "inPoint") {
    layer.inPoint = value;
  } else if (propertyPath === "outPoint") {
    layer.outPoint = value;
  } else {
    if (layer.data) {
      setNestedProperty(layer.data, parts, value);
    }
  }
  return {
    success: true,
    message: `Set ${propertyPath} to ${JSON.stringify(value)}`
  };
}
function executeSetLayerTransform(context, args) {
  const { store } = context;
  const { layerId, position, scale, rotation, opacity, anchorPoint } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const changes = [];
  if (position !== void 0) {
    layer.transform.position.value = position;
    changes.push("position");
  }
  if (scale !== void 0) {
    layer.transform.scale.value = scale;
    changes.push("scale");
  }
  if (rotation !== void 0) {
    layer.transform.rotation.value = rotation;
    changes.push("rotation");
  }
  if (opacity !== void 0) {
    layer.opacity.value = opacity;
    changes.push("opacity");
  }
  if (anchorPoint !== void 0) {
    const originProp = layer.transform.origin || layer.transform.anchorPoint;
    if (originProp) {
      originProp.value = anchorPoint;
    }
    changes.push("origin");
  }
  return {
    success: true,
    message: `Updated transform: ${changes.join(", ")}`
  };
}
function executeAddKeyframe(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame, value, interpolation } = args;
  const keyframe = addKeyframe(store, layerId, propertyPath, value, frame);
  if (!keyframe) {
    return { keyframeId: null, message: `Failed to add keyframe at frame ${frame}` };
  }
  if (interpolation && keyframe) {
    setKeyframeInterpolation(
      store,
      layerId,
      propertyPath,
      keyframe.id,
      interpolation
    );
  }
  return {
    keyframeId: keyframe.id,
    message: `Added keyframe at frame ${frame} for ${propertyPath}`
  };
}
function executeRemoveKeyframe(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  const keyframe = property.keyframes.find((k) => k.frame === frame);
  if (!keyframe) {
    return { success: false, message: `No keyframe at frame ${frame}` };
  }
  removeKeyframe(store, layerId, propertyPath, keyframe.id);
  return {
    success: true,
    message: `Removed keyframe at frame ${frame} from ${propertyPath}`
  };
}
function executeSetKeyframeEasing(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame, interpolation } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  const keyframe = property.keyframes.find((k) => k.frame === frame);
  if (!keyframe) {
    return { success: false, message: `No keyframe at frame ${frame}` };
  }
  setKeyframeInterpolation(
    store,
    layerId,
    propertyPath,
    keyframe.id,
    interpolation
  );
  return {
    success: true,
    message: `Set interpolation to ${interpolation} at frame ${frame}`
  };
}
function executeScaleKeyframeTiming(context, args) {
  const { store } = context;
  const { layerId, scaleFactor, propertyPath } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const propertiesToScale = propertyPath ? [propertyPath] : ["position", "scale", "rotation", "opacity", "anchorPoint"];
  let scaledCount = 0;
  for (const propPath of propertiesToScale) {
    const property = findPropertyByPath(layer, propPath);
    if (property?.keyframes && property.keyframes.length > 0) {
      for (const kf of property.keyframes) {
        kf.frame = Math.round(kf.frame * scaleFactor);
      }
      property.keyframes.sort((a, b) => a.frame - b.frame);
      scaledCount += property.keyframes.length;
    }
  }
  return {
    success: true,
    message: `Scaled ${scaledCount} keyframes by factor ${scaleFactor}`
  };
}
function executeSetExpression(context, args) {
  const { store } = context;
  const { layerId, propertyPath, expressionType, params } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  property.expression = {
    enabled: true,
    type: "preset",
    name: expressionType,
    params: params || {}
  };
  return {
    success: true,
    message: `Applied ${expressionType} expression to ${propertyPath}`
  };
}
function executeRemoveExpression(context, args) {
  const { store } = context;
  const { layerId, propertyPath } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  property.expression = void 0;
  return {
    success: true,
    message: `Removed expression from ${propertyPath}`
  };
}
function executeAddEffect(context, args) {
  const { store } = context;
  const { layerId, effectType, params } = args;
  addEffectToLayer(store, layerId, effectType);
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  const effect = layer?.effects?.[layer.effects.length - 1];
  if (!effect) {
    return { effectId: null, message: `Failed to add effect ${effectType}` };
  }
  if (params) {
    for (const [key, value] of Object.entries(params)) {
      updateEffectParameter(store, layerId, effect.id, key, value);
    }
  }
  return {
    effectId: effect.id,
    message: `Added ${effectType} effect to layer`
  };
}
function executeUpdateEffect(context, args) {
  const { store } = context;
  const { layerId, effectId, params } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer?.effects) {
    return { success: false, message: `Layer ${layerId} not found or has no effects` };
  }
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect) {
    return { success: false, message: `Effect ${effectId} not found` };
  }
  for (const [key, value] of Object.entries(params)) {
    updateEffectParameter(store, layerId, effectId, key, value);
  }
  return {
    success: true,
    message: `Updated ${Object.keys(params).length} effect parameters`
  };
}
function executeRemoveEffect(context, args) {
  const { store } = context;
  const { layerId, effectId } = args;
  removeEffectFromLayer(store, layerId, effectId);
  return {
    success: true,
    message: `Removed effect ${effectId}`
  };
}
function executeConfigureParticles(context, args) {
  const { store } = context;
  const { layerId, emitter, particles, physics } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "particles") {
    return { success: false, message: `Particle layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Particle layer has no data` };
  }
  const particleData = layer.data;
  if (emitter && particleData.emitters?.[0]) {
    Object.assign(particleData.emitters[0], emitter);
  }
  if (particles && particleData.emitters?.[0]) {
    Object.assign(particleData.emitters[0], particles);
  }
  if (physics && particleData.systemConfig) {
    if (physics.gravity) {
      particleData.systemConfig.gravity = physics.gravity.y || 0;
    }
    if (physics.wind) {
      particleData.systemConfig.windStrength = Math.sqrt(
        physics.wind.x ** 2 + physics.wind.y ** 2
      );
      particleData.systemConfig.windDirection = Math.atan2(
        physics.wind.y,
        physics.wind.x
      ) * (180 / Math.PI);
    }
  }
  return {
    success: true,
    message: `Configured particle system`
  };
}
function executeApplyCameraTrajectory(context, args) {
  const { store } = context;
  const {
    cameraLayerId,
    trajectoryType,
    startFrame = 0,
    duration,
    amplitude,
    loops,
    easing,
    center
  } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === cameraLayerId);
  if (!layer || layer.type !== "camera") {
    return { success: false, keyframeCount: 0, message: `Camera layer ${cameraLayerId} not found` };
  }
  const comp = store.getActiveComp();
  const compSettings = comp?.settings || { width: 1920, height: 1080, frameCount: 81 };
  const trajectoryConfig = createTrajectoryFromPreset(trajectoryType, {
    duration: duration ?? compSettings.frameCount,
    amplitude: amplitude ?? void 0,
    loops: loops ?? void 0,
    easing: easing ?? void 0,
    center: center ?? {
      x: compSettings.width / 2,
      y: compSettings.height / 2,
      z: 0
    }
  });
  const keyframes = generateTrajectoryKeyframes(trajectoryConfig, startFrame, 5);
  if (!layer.data) {
    layer.data = {};
  }
  const cameraData = layer.data;
  if (!cameraData.camera) {
    cameraData.camera = {
      type: "two-node",
      position: { x: compSettings.width / 2, y: compSettings.height / 2, z: -1500 },
      pointOfInterest: { x: compSettings.width / 2, y: compSettings.height / 2, z: 0 },
      zoom: 1778,
      depthOfField: false,
      focusDistance: 1500,
      aperture: 2.8,
      blurLevel: 100,
      xRotation: 0,
      yRotation: 0,
      zRotation: 0
    };
  }
  cameraData.trajectoryKeyframes = {
    position: keyframes.position.filter((kf) => kf.position !== void 0).map((kf) => ({ frame: kf.frame, position: kf.position })),
    pointOfInterest: keyframes.pointOfInterest.filter((kf) => kf.pointOfInterest !== void 0).map((kf) => ({ frame: kf.frame, pointOfInterest: kf.pointOfInterest })),
    zoom: keyframes.zoom?.filter((kf) => kf.zoom !== void 0).map((kf) => ({ frame: kf.frame, zoom: kf.zoom }))
  };
  for (const kf of keyframes.position) {
    if (kf.position) {
      addKeyframe(store, cameraLayerId, "cameraPosition", kf.position, kf.frame);
    }
  }
  const totalKeyframes = keyframes.position.length + keyframes.pointOfInterest.length + (keyframes.zoom?.length || 0);
  return {
    success: true,
    keyframeCount: totalKeyframes,
    message: `Applied ${trajectoryType} trajectory with ${totalKeyframes} keyframes`
  };
}
function executeAddCameraShake(context, args) {
  const { store } = context;
  const {
    cameraLayerId,
    shakeType,
    intensity,
    frequency,
    startFrame = 0,
    duration,
    decay,
    rotationEnabled,
    seed
  } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === cameraLayerId);
  if (!layer || layer.type !== "camera") {
    return { success: false, message: `Camera layer ${cameraLayerId} not found` };
  }
  const comp = store.getActiveComp();
  const compDuration = comp?.settings.frameCount || 81;
  const shakeConfig = {
    intensity,
    frequency,
    decay,
    rotationEnabled,
    seed: seed ?? Math.floor(Math.random() * 1e5)
  };
  if (!layer.data) {
    layer.data = {};
  }
  const cameraData = layer.data;
  cameraData.shake = {
    enabled: true,
    type: shakeType,
    intensity: shakeConfig.intensity ?? 0.3,
    frequency: shakeConfig.frequency ?? 1,
    rotationEnabled: shakeConfig.rotationEnabled ?? true,
    rotationScale: 0.5,
    seed: shakeConfig.seed,
    decay: shakeConfig.decay ?? 0,
    startFrame,
    duration: duration ?? compDuration
  };
  return {
    success: true,
    message: `Added ${shakeType} camera shake (intensity: ${cameraData.shake.intensity}, duration: ${cameraData.shake.duration} frames)`
  };
}
function executeApplyRackFocus(context, args) {
  const { store } = context;
  const {
    cameraLayerId,
    startDistance,
    endDistance,
    startFrame = 0,
    duration = 30,
    easing = "ease-in-out",
    holdStart = 0,
    holdEnd = 0
  } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === cameraLayerId);
  if (!layer || layer.type !== "camera") {
    return { success: false, keyframeCount: 0, message: `Camera layer ${cameraLayerId} not found` };
  }
  const rackFocusConfig = createRackFocus(startDistance, endDistance, duration, {
    startFrame,
    easing,
    holdStart,
    holdEnd
  });
  const focusKeyframes = generateRackFocusKeyframes(rackFocusConfig, 2);
  if (!layer.data) {
    layer.data = {};
  }
  const cameraData = layer.data;
  if (cameraData.camera) {
    cameraData.camera.depthOfField = true;
  }
  cameraData.rackFocus = {
    enabled: true,
    ...rackFocusConfig
  };
  for (const kf of focusKeyframes) {
    if (kf.focusDistance !== void 0) {
      addKeyframe(store, cameraLayerId, "focusDistance", kf.focusDistance, kf.frame);
    }
  }
  return {
    success: true,
    keyframeCount: focusKeyframes.length,
    message: `Applied rack focus from ${startDistance}px to ${endDistance}px over ${duration} frames`
  };
}
function executeSetCameraPathFollowing(context, args) {
  const { store } = context;
  const {
    cameraLayerId,
    splineLayerId,
    lookMode = "tangent",
    lookTarget,
    startOffset = 0,
    speed = 1,
    bankAmount = 0,
    smoothing = 0.5
  } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === cameraLayerId);
  if (!layer || layer.type !== "camera") {
    return { success: false, message: `Camera layer ${cameraLayerId} not found` };
  }
  if (splineLayerId) {
    const splineLayer = store.getActiveCompLayers().find((l) => l.id === splineLayerId);
    if (!splineLayer || splineLayer.type !== "spline") {
      return { success: false, message: `Spline layer ${splineLayerId} not found` };
    }
  }
  if (!layer.data) {
    layer.data = {};
  }
  const cameraData = layer.data;
  cameraData.pathFollowingConfig = {
    enabled: !!splineLayerId,
    splineLayerId: splineLayerId || null,
    lookMode,
    lookTarget: lookTarget || null,
    startOffset,
    speed,
    bankAmount,
    smoothing
  };
  return {
    success: true,
    message: splineLayerId ? `Camera now follows spline ${splineLayerId} (mode: ${lookMode})` : `Camera path following disabled`
  };
}
function executeSetCameraAutoFocus(context, args) {
  const { store } = context;
  const {
    cameraLayerId,
    enabled = true,
    mode = "center",
    focusPoint,
    smoothing = 0.8
  } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === cameraLayerId);
  if (!layer || layer.type !== "camera") {
    return { success: false, message: `Camera layer ${cameraLayerId} not found` };
  }
  if (!layer.data) {
    layer.data = {};
  }
  const cameraData = layer.data;
  if (enabled && cameraData.camera) {
    cameraData.camera.depthOfField = true;
  }
  const mappedMode = mode === "face" ? "center" : mode;
  cameraData.autoFocus = {
    enabled,
    mode: mappedMode,
    focusPoint: focusPoint || { x: 0.5, y: 0.5 },
    smoothing,
    threshold: 10,
    sampleRadius: 0.1
  };
  return {
    success: true,
    message: enabled ? `Enabled ${mode} autofocus (smoothing: ${smoothing})` : `Disabled autofocus`
  };
}
function executeSetTextContent(context, args) {
  const { store } = context;
  const { layerId, text, fontSize, fontFamily, fontWeight, color, alignment } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "text") {
    return { success: false, message: `Text layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Text layer has no data` };
  }
  const textData = layer.data;
  if (text !== void 0) textData.text = text;
  if (fontSize !== void 0) textData.fontSize = fontSize;
  if (fontFamily !== void 0) textData.fontFamily = fontFamily;
  if (fontWeight !== void 0) textData.fontWeight = String(fontWeight);
  if (color !== void 0) {
    textData.fill = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a ?? 1})`;
  }
  if (alignment !== void 0) textData.textAlign = alignment;
  return {
    success: true,
    message: `Updated text content`
  };
}
function executeSetTextPath(context, args) {
  const { store } = context;
  const { textLayerId, splineLayerId, startOffset } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === textLayerId);
  if (!layer || layer.type !== "text") {
    return { success: false, message: `Text layer ${textLayerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Text layer has no data` };
  }
  const textData = layer.data;
  textData.pathLayerId = splineLayerId || null;
  if (startOffset !== void 0) {
    textData.pathOffset = startOffset;
  }
  return {
    success: true,
    message: splineLayerId ? `Attached text to path ${splineLayerId}` : `Detached text from path`
  };
}
function executeSetSplinePoints(context, args) {
  const { store } = context;
  const { layerId, points, closed } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline") {
    return { success: false, message: `Spline layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Spline layer has no data` };
  }
  const splineData = layer.data;
  splineData.controlPoints = points.map((p, index) => ({
    id: `cp_${Date.now()}_${index}`,
    x: p.x,
    y: p.y,
    handleIn: p.handleIn || null,
    handleOut: p.handleOut || null,
    type: p.handleIn || p.handleOut ? "smooth" : "corner"
  }));
  if (closed !== void 0) {
    splineData.closed = closed;
  }
  return {
    success: true,
    message: `Set ${points.length} control points on spline`
  };
}
function executeSetSpeedMap(context, args) {
  const { store } = context;
  const { layerId, enabled, keyframes } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  if (!layer.data) {
    layer.data = {};
  }
  layer.data.speedMap = {
    enabled: enabled !== false,
    keyframes: keyframes || []
  };
  layer.data.timeRemap = layer.data.speedMap;
  return {
    success: true,
    message: enabled ? `Enabled speed map` : `Disabled speed map`
  };
}
function executeSetCurrentFrame(context, args) {
  const { store} = context;
  const { frame } = args;
  const comp = store.getActiveComp();
  const frameCount = comp?.settings.frameCount || 81;
  const clampedFrame = Math.max(0, Math.min(frame, frameCount - 1));
  store.setFrame(clampedFrame);
  return {
    frame: clampedFrame,
    message: `Jumped to frame ${clampedFrame}`
  };
}
function executePlayPreview(context, args) {
  const { store, playbackStore } = context;
  const { play } = args;
  if (play) {
    const comp = store.getActiveComp();
    if (comp) {
      playbackStore.play(
        comp.settings.fps,
        comp.settings.frameCount,
        comp.currentFrame,
        (frame) => store.setFrame(frame)
      );
    }
  } else {
    playbackStore.stop();
  }
  return {
    playing: play,
    message: play ? `Started playback` : `Stopped playback`
  };
}
async function executeDecomposeImage(context, args) {
  const { store } = context;
  const { sourceLayerId, numLayers = 4 } = args;
  const sourceLayer = store.getActiveCompLayers().find((l) => l.id === sourceLayerId);
  if (!sourceLayer) {
    throw new Error(`Source layer ${sourceLayerId} not found`);
  }
  if (sourceLayer.type !== "image") {
    throw new Error(`Layer ${sourceLayerId} is not an image layer`);
  }
  const layerData = sourceLayer.data;
  const sourceUrl = layerData?.source || layerData?.url || layerData?.assetId;
  if (!sourceUrl) {
    throw new Error(`Source layer has no image source`);
  }
  let imageDataUrl;
  if (sourceUrl.startsWith("data:")) {
    imageDataUrl = sourceUrl;
  } else {
    imageDataUrl = await new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => reject(new Error("Failed to load source image"));
      img.src = sourceUrl;
    });
  }
  const service = getLayerDecompositionService();
  const decomposedLayers = await service.decomposeWithAutoSetup(
    imageDataUrl,
    { numLayers },
    (stage, message) => {
      console.log(`[AI Decompose] ${stage}: ${message}`);
    }
  );
  const createdLayerIds = [];
  for (let i = decomposedLayers.length - 1; i >= 0; i--) {
    const decomposed = decomposedLayers[i];
    const layer = createLayer(store, "image", decomposed.label);
    if (layer.data) {
      layer.data.source = decomposed.image;
    }
    createdLayerIds.push(layer.id);
  }
  store.pushHistory();
  return {
    layerIds: createdLayerIds,
    message: `Decomposed image into ${decomposedLayers.length} layers: ${decomposedLayers.map((l) => l.label).join(", ")}`
  };
}
async function executeVectorizeImage(context, args) {
  const { store } = context;
  const {
    sourceLayerId,
    mode = "trace",
    separateLayers = true,
    groupByPath = true,
    autoGroupByRegion = false,
    enableAnimation = true,
    traceOptions = {}
  } = args;
  const sourceLayer = store.getActiveCompLayers().find((l) => l.id === sourceLayerId);
  if (!sourceLayer) {
    throw new Error(`Source layer ${sourceLayerId} not found`);
  }
  if (sourceLayer.type !== "image" && sourceLayer.type !== "video" && sourceLayer.type !== "solid") {
    throw new Error(`Layer ${sourceLayerId} must be an image, video, or solid layer`);
  }
  const layerData = sourceLayer.data;
  let imageDataUrl;
  if (layerData?.source) {
    imageDataUrl = layerData.source;
  } else if (layerData?.assetId) {
    const asset = store.project?.assets[layerData.assetId];
    if (!asset?.data) throw new Error("Asset data not found");
    imageDataUrl = asset.data;
  } else if (layerData?.url) {
    imageDataUrl = layerData.url;
  } else {
    throw new Error("Source layer has no image source");
  }
  if (!imageDataUrl.startsWith("data:")) {
    imageDataUrl = await new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => reject(new Error("Failed to load source image"));
      img.src = imageDataUrl;
    });
  }
  const vectorizeService = getVectorizeService();
  const result = await vectorizeService.vectorize(
    imageDataUrl,
    {
      mode,
      traceOptions: {
        colorMode: traceOptions.colorMode || "color",
        filterSpeckle: traceOptions.filterSpeckle ?? 4,
        cornerThreshold: traceOptions.cornerThreshold ?? 60,
        colorPrecision: traceOptions.colorPrecision ?? 6,
        layerDifference: traceOptions.layerDifference ?? 16
      }
    },
    (stage, message) => {
      console.log(`[AI Vectorize] ${stage}: ${message}`);
    }
  );
  let paths = filterSmallPaths(result.paths, 2);
  paths = normalizeControlPoints(paths, {
    groupByPath,
    prefix: "vec"
  });
  const createdLayerIds = [];
  if (separateLayers) {
    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      let controlPoints = path.controlPoints;
      if (autoGroupByRegion) {
        controlPoints = autoGroupPoints(controlPoints, { method: "quadrant" });
      }
      const layer = createLayer(store, "spline", `Vector Path ${i + 1}`);
      if (layer.data) {
        Object.assign(layer.data, {
          controlPoints,
          closed: path.closed,
          stroke: path.stroke || "#00ff00",
          strokeWidth: 2,
          fill: path.fill || "",
          animated: enableAnimation
        });
      }
      createdLayerIds.push(layer.id);
    }
  } else {
    const allPoints = [];
    let pointIdx = 0;
    for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
      const path = paths[pathIdx];
      for (const cp of path.controlPoints) {
        allPoints.push({
          ...cp,
          id: `vec_${pointIdx++}`,
          group: `path_${pathIdx}`
        });
      }
    }
    let controlPoints = allPoints;
    if (autoGroupByRegion) {
      controlPoints = autoGroupPoints(allPoints, { method: "quadrant" });
    }
    const layer = createLayer(store, "spline", "Vectorized Paths");
    if (layer.data) {
      Object.assign(layer.data, {
        controlPoints,
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: "",
        animated: enableAnimation
      });
    }
    createdLayerIds.push(layer.id);
  }
  store.pushHistory();
  return {
    layerIds: createdLayerIds,
    message: `Vectorized image into ${createdLayerIds.length} spline layer(s) with ${result.pathCount} paths`
  };
}
function executeGetLayerInfo(context, args) {
  const { store } = context;
  const { layerId } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { layer: null, message: `Layer ${layerId} not found` };
  }
  return {
    layer: {
      id: layer.id,
      name: layer.name,
      type: layer.type,
      visible: layer.visible,
      locked: layer.locked,
      inPoint: layer.inPoint,
      outPoint: layer.outPoint,
      transform: {
        position: layer.transform.position,
        scale: layer.transform.scale,
        rotation: layer.transform.rotation,
        origin: layer.transform.origin,
        // @deprecated alias for backwards compatibility
        anchorPoint: layer.transform.origin || layer.transform.anchorPoint
      },
      opacity: layer.opacity,
      effects: layer.effects?.map((e) => ({
        id: e.id,
        effectKey: e.effectKey,
        name: e.name,
        enabled: e.enabled
      }))
    },
    message: `Layer info for "${layer.name}"`
  };
}
function executeFindLayers(context, args) {
  const { store } = context;
  const { name, type } = args;
  let layers = store.getActiveCompLayers();
  if (name) {
    const lowerName = name.toLowerCase();
    layers = layers.filter((l) => l.name.toLowerCase().includes(lowerName));
  }
  if (type) {
    layers = layers.filter((l) => l.type === type);
  }
  return {
    layers: layers.map((l) => ({
      id: l.id,
      name: l.name,
      type: l.type
    })),
    message: `Found ${layers.length} layer(s)`
  };
}
function executeGetProjectState(context, _args) {
  const { store } = context;
  const comp = store.getActiveComp();
  return {
    state: {
      composition: comp ? {
        id: comp.id,
        name: comp.name,
        width: comp.settings.width,
        height: comp.settings.height,
        frameCount: comp.settings.frameCount,
        fps: comp.settings.fps,
        currentFrame: comp.currentFrame
      } : null,
      layerCount: store.getActiveCompLayers().length,
      layers: store.getActiveCompLayers().map((l) => ({
        id: l.id,
        name: l.name,
        type: l.type,
        visible: l.visible
      }))
    },
    message: `Project state summary`
  };
}
function setNestedProperty(obj, path, value) {
  let current = obj;
  for (let i = 0; i < path.length - 1; i++) {
    if (!(path[i] in current)) {
      current[path[i]] = {};
    }
    current = current[path[i]];
  }
  current[path[path.length - 1]] = value;
}

function serializeProjectState(includeKeyframes = true) {
  const store = useCompositorStore();
  const comp = store.getActiveComp();
  if (!comp) {
    return JSON.stringify({ error: "No active composition" }, null, 2);
  }
  const state = {
    composition: serializeComposition(comp),
    layers: store.getActiveCompLayers().map(
      (layer) => serializeLayer(layer, includeKeyframes)
    ),
    selectedLayerIds: [...store.selectedLayerIds],
    currentFrame: comp.currentFrame
  };
  return JSON.stringify(state, null, 2);
}
function serializeComposition(comp) {
  return {
    id: comp.id,
    name: comp.name,
    width: comp.settings.width,
    height: comp.settings.height,
    frameCount: comp.settings.frameCount,
    fps: comp.settings.fps,
    duration: comp.settings.duration
  };
}
function serializeLayer(layer, includeKeyframes) {
  const serialized = {
    id: layer.id,
    name: layer.name,
    type: layer.type,
    visible: layer.visible,
    locked: layer.locked,
    startFrame: layer.startFrame ?? layer.inPoint ?? 0,
    endFrame: layer.endFrame ?? layer.outPoint ?? 80,
    parentId: layer.parentId,
    transform: {
      position: serializeAnimatableProperty(layer.transform.position, includeKeyframes),
      scale: serializeAnimatableProperty(layer.transform.scale, includeKeyframes),
      rotation: serializeAnimatableProperty(layer.transform.rotation, includeKeyframes),
      // Use origin (new name) with fallback to anchorPoint for backwards compatibility
      origin: serializeAnimatableProperty(layer.transform.origin || layer.transform.anchorPoint, includeKeyframes)
    },
    opacity: serializeAnimatableProperty(layer.opacity, includeKeyframes)
  };
  if (layer.effects && layer.effects.length > 0) {
    serialized.effects = layer.effects.map(serializeEffect);
  }
  if (layer.data) {
    serialized.data = serializeLayerData(layer.type, layer.data);
  }
  return serialized;
}
function serializeAnimatableProperty(prop, includeKeyframes) {
  const serialized = {
    value: prop.value,
    animated: prop.animated || false
  };
  if (prop.keyframes && prop.keyframes.length > 0) {
    serialized.keyframeCount = prop.keyframes.length;
    if (includeKeyframes) {
      serialized.keyframes = prop.keyframes.map((kf) => ({
        frame: kf.frame,
        value: kf.value,
        interpolation: kf.interpolation
      }));
    }
  }
  return serialized;
}
function serializeEffect(effect) {
  const parameters = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    parameters[key] = param.value;
  }
  return {
    id: effect.id,
    name: effect.name,
    type: effect.effectKey,
    enabled: effect.enabled,
    parameters
  };
}
function serializeLayerData(type, data) {
  switch (type) {
    case "text":
      return {
        text: data.text,
        fontFamily: data.fontFamily,
        fontSize: data.fontSize,
        fill: data.fill,
        textAlign: data.textAlign,
        pathLayerId: data.pathLayerId
      };
    case "solid":
      return {
        color: data.color,
        width: data.width,
        height: data.height
      };
    case "spline":
      return {
        pointCount: data.controlPoints?.length || 0,
        closed: data.closed,
        stroke: data.stroke,
        strokeWidth: data.strokeWidth
      };
    case "particles":
      return {
        emitterCount: data.emitters?.length || 0,
        maxParticles: data.systemConfig?.maxParticles,
        gravity: data.systemConfig?.gravity,
        firstEmitter: data.emitters?.[0] ? {
          x: data.emitters[0].x,
          y: data.emitters[0].y,
          direction: data.emitters[0].direction,
          spread: data.emitters[0].spread,
          speed: data.emitters[0].speed,
          emissionRate: data.emitters[0].emissionRate,
          particleLifetime: data.emitters[0].particleLifetime,
          color: data.emitters[0].color
        } : null
      };
    case "image":
      return {
        assetId: data.assetId,
        fit: data.fit
      };
    case "video":
      return {
        assetId: data.assetId,
        loop: data.loop,
        speed: data.speed
      };
    case "camera":
      return {
        cameraId: data.cameraId,
        isActiveCamera: data.isActiveCamera
      };
    case "shape":
      return {
        shapeCount: data.shapes?.length || 0,
        fill: data.fill,
        stroke: data.stroke,
        strokeWidth: data.strokeWidth
      };
    case "nestedComp":
      return {
        compositionId: data.compositionId,
        hasSpeedMap: !!(data.speedMap ?? data.timeRemap)
      };
    case "depthflow":
      return {
        sourceLayerId: data.sourceLayerId,
        depthLayerId: data.depthLayerId,
        preset: data.config?.preset
      };
    case "light":
      return {
        lightType: data.lightType,
        color: data.color,
        intensity: data.intensity
      };
    default:
      return Object.fromEntries(
        Object.entries(data).slice(0, 10)
      );
  }
}

const DEFAULT_CONFIG = {
  model: "gpt-4o",
  maxTokens: 4096,
  temperature: 0.3,
  // Lower for more deterministic tool use
  maxIterations: 10,
  autoVerify: true
};
class AICompositorAgent {
  config;
  state;
  abortController = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.state = {
      isProcessing: false,
      currentTask: null,
      messages: [],
      lastError: null,
      iterationCount: 0
    };
  }
  // ==========================================================================
  // PUBLIC API
  // ==========================================================================
  /**
   * Process a user instruction
   * This is the main entry point for the AI agent
   */
  async processInstruction(instruction) {
    if (this.state.isProcessing) {
      throw new Error("Agent is already processing a request");
    }
    this.state.isProcessing = true;
    this.state.currentTask = instruction;
    this.state.lastError = null;
    this.state.iterationCount = 0;
    this.abortController = new AbortController();
    try {
      this.addMessage({ role: "user", content: instruction, timestamp: Date.now() });
      const projectState = serializeProjectState();
      const contextualPrompt = this.buildContextualPrompt(instruction, projectState);
      const response = await this.runAgentLoop(contextualPrompt);
      this.addMessage({ role: "assistant", content: response, timestamp: Date.now() });
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      this.state.lastError = errorMessage;
      throw error;
    } finally {
      this.state.isProcessing = false;
      this.state.currentTask = null;
      this.abortController = null;
    }
  }
  /**
   * Cancel the current operation
   */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
  /**
   * Clear conversation history
   */
  clearHistory() {
    this.state.messages = [];
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get conversation history
   */
  getHistory() {
    return [...this.state.messages];
  }
  // ==========================================================================
  // PRIVATE METHODS
  // ==========================================================================
  addMessage(message) {
    this.state.messages.push(message);
  }
  buildContextualPrompt(instruction, projectState) {
    return `${SYSTEM_PROMPT$1}

## Current Project State
\`\`\`json
${projectState}
\`\`\`

## User Request
${instruction}

## Instructions
1. Analyze the user's request carefully
2. Think step-by-step about what needs to be done
3. Use the available tools to make changes
4. After making changes, verify they match the user's intent
5. Provide a clear summary of what you did`;
  }
  async runAgentLoop(initialPrompt) {
    let currentMessages = [
      { role: "system", content: SYSTEM_PROMPT$1 },
      { role: "user", content: initialPrompt }
    ];
    while (this.state.iterationCount < this.config.maxIterations) {
      if (this.abortController?.signal.aborted) {
        throw new Error("Operation cancelled");
      }
      this.state.iterationCount++;
      const response = await this.callLLM(currentMessages);
      if (response.toolCalls && response.toolCalls.length > 0) {
        const toolResults = await this.executeToolCalls(response.toolCalls);
        currentMessages.push({
          role: "assistant",
          content: response.content,
          tool_calls: response.toolCalls
        });
        for (const result of toolResults) {
          currentMessages.push({
            role: "tool",
            content: JSON.stringify(result),
            tool_call_id: result.toolCallId
          });
        }
        continue;
      }
      return response.content;
    }
    return "Maximum iterations reached. Please try a simpler request or break it into steps.";
  }
  async callLLM(messages) {
    const response = await fetch("/weyl/api/ai/agent", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: this.config.model,
        messages,
        tools: TOOL_DEFINITIONS,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature
      }),
      signal: this.abortController?.signal
    });
    const result = await response.json();
    if (result.status !== "success") {
      throw new Error(result.message || "LLM API error");
    }
    return {
      content: result.data.content || "",
      toolCalls: result.data.toolCalls
    };
  }
  async executeToolCalls(toolCalls) {
    const results = [];
    for (const call of toolCalls) {
      try {
        const result = await executeToolCall(call);
        results.push({
          toolCallId: call.id,
          success: true,
          result
        });
      } catch (error) {
        results.push({
          toolCallId: call.id,
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    return results;
  }
}
let agentInstance = null;
function getAIAgent() {
  if (!agentInstance) {
    agentInstance = new AICompositorAgent();
  }
  return agentInstance;
}

const _hoisted_1$m = {
  class: "ai-chat-panel",
  role: "region",
  "aria-label": "AI Compositor Agent"
};
const _hoisted_2$m = { class: "panel-header" };
const _hoisted_3$m = { class: "header-actions" };
const _hoisted_4$m = {
  key: 0,
  class: "welcome-message"
};
const _hoisted_5$m = { class: "example-prompts" };
const _hoisted_6$m = ["onClick"];
const _hoisted_7$m = { class: "message-header" };
const _hoisted_8$l = { class: "role-label" };
const _hoisted_9$l = { class: "timestamp" };
const _hoisted_10$k = ["innerHTML"];
const _hoisted_11$j = {
  key: 0,
  class: "tool-calls"
};
const _hoisted_12$h = { class: "tool-icon" };
const _hoisted_13$h = { class: "tool-name" };
const _hoisted_14$f = {
  key: 1,
  class: "message assistant processing"
};
const _hoisted_15$e = { class: "message-content" };
const _hoisted_16$d = { class: "processing-text" };
const _hoisted_17$d = { class: "input-area" };
const _hoisted_18$d = ["onKeydown", "disabled"];
const _hoisted_19$d = ["disabled"];
const _hoisted_20$d = {
  key: 0,
  class: "spinner"
};
const _hoisted_21$c = { key: 1 };
const _hoisted_22$b = { class: "status-bar" };
const _hoisted_23$b = { class: "status-text" };
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "AIChatPanel",
  setup(__props) {
    const selectedModel = ref("gpt-4o");
    const inputText = ref("");
    const messages = ref([]);
    const isProcessing = ref(false);
    const processingText = ref("Thinking...");
    const messagesContainer = ref(null);
    const apiConnected = ref(false);
    const apiError = ref(false);
    const examplePrompts = [
      "Fade in a title over 1 second",
      "Create floating particles that drift upward",
      "Make the selected layer bounce in from the left",
      "Add a glow effect to all text layers"
    ];
    const statusText = computed(() => {
      if (isProcessing.value) return `Processing with ${selectedModel.value}...`;
      if (apiError.value) return "API not configured";
      if (apiConnected.value) return `Ready (${selectedModel.value})`;
      return "Checking API status...";
    });
    async function checkApiStatus() {
      try {
        const response = await fetch("/weyl/api/status");
        const data = await response.json();
        if (data.status === "success") {
          apiConnected.value = data.providers.openai || data.providers.anthropic;
          apiError.value = !apiConnected.value;
        }
      } catch {
        apiConnected.value = false;
        apiError.value = true;
      }
    }
    async function sendMessage() {
      const text = inputText.value.trim();
      if (!text || isProcessing.value) return;
      inputText.value = "";
      isProcessing.value = true;
      processingText.value = "Thinking...";
      try {
        const agent = getAIAgent();
        agent.config.model = selectedModel.value;
        await agent.processInstruction(text);
        messages.value = agent.getHistory();
        scrollToBottom();
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        messages.value.push({
          role: "assistant",
          content: `Error: ${errorMessage}`,
          timestamp: Date.now()
        });
      } finally {
        isProcessing.value = false;
      }
    }
    function clearHistory() {
      const agent = getAIAgent();
      agent.clearHistory();
      messages.value = [];
    }
    function useExample(example) {
      inputText.value = example;
      sendMessage();
    }
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    function formatContent(content) {
      const formatted = content.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>").replace(/\n/g, "<br>");
      return purify.sanitize(formatted);
    }
    function formatToolName(name) {
      return name.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).trim();
    }
    function getToolIcon(name) {
      const icons = {
        createLayer: "+",
        deleteLayer: "-",
        duplicateLayer: "++",
        addKeyframe: "K",
        removeKeyframe: "-K",
        addEffect: "fx",
        setLayerProperty: "=",
        setLayerTransform: "T",
        configureParticles: "P",
        setTextContent: "A",
        setSplinePoints: "~"
      };
      return icons[name] || "*";
    }
    function scrollToBottom() {
      nextTick(() => {
        if (messagesContainer.value) {
          messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
        }
      });
    }
    onMounted(() => {
      checkApiStatus();
    });
    watch(messages, scrollToBottom, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$m, [
          _cache[4] || (_cache[4] = createBaseVNode("span", { class: "panel-title" }, "AI Agent", -1)),
          createBaseVNode("div", _hoisted_3$m, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
              class: "model-selector",
              "aria-label": "Select AI model"
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("option", { value: "gpt-4o" }, "GPT-4o", -1),
              createBaseVNode("option", { value: "claude-sonnet" }, "Claude Sonnet", -1)
            ])], 512), [
              [vModelSelect, selectedModel.value]
            ]),
            createBaseVNode("button", {
              class: "clear-btn",
              onClick: clearHistory,
              title: "Clear conversation",
              "aria-label": "Clear conversation history"
            }, " Clear ")
          ])
        ]),
        createBaseVNode("div", {
          class: "chat-messages",
          ref_key: "messagesContainer",
          ref: messagesContainer
        }, [
          messages.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_4$m, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "welcome-icon" }, "AI", -1)),
            _cache[6] || (_cache[6] = createBaseVNode("h3", null, "AI Compositor Agent", -1)),
            _cache[7] || (_cache[7] = createBaseVNode("p", null, " Describe the motion graphics you want to create, and I'll build it for you. ", -1)),
            createBaseVNode("div", _hoisted_5$m, [
              (openBlock(), createElementBlock(Fragment, null, renderList(examplePrompts, (example) => {
                return createBaseVNode("button", {
                  key: example,
                  class: "example-btn",
                  onClick: ($event) => useExample(example)
                }, toDisplayString(example), 9, _hoisted_6$m);
              }), 64))
            ])
          ])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(messages.value, (message, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["message", message.role])
            }, [
              createBaseVNode("div", _hoisted_7$m, [
                createBaseVNode("span", _hoisted_8$l, toDisplayString(message.role === "user" ? "You" : "AI Agent"), 1),
                createBaseVNode("span", _hoisted_9$l, toDisplayString(formatTime(message.timestamp)), 1)
              ]),
              createBaseVNode("div", {
                class: "message-content",
                innerHTML: formatContent(message.content)
              }, null, 8, _hoisted_10$k),
              message.toolCalls && message.toolCalls.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_11$j, [
                _cache[8] || (_cache[8] = createBaseVNode("div", { class: "tool-calls-header" }, "Actions taken:", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(message.toolCalls, (call, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: i,
                    class: "tool-call"
                  }, [
                    createBaseVNode("span", _hoisted_12$h, toDisplayString(getToolIcon(call.name)), 1),
                    createBaseVNode("span", _hoisted_13$h, toDisplayString(formatToolName(call.name)), 1)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128)),
          isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_14$f, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "message-header" }, [
              createBaseVNode("span", { class: "role-label" }, "AI Agent")
            ], -1)),
            createBaseVNode("div", _hoisted_15$e, [
              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "processing-dots" }, [
                createBaseVNode("span"),
                createBaseVNode("span"),
                createBaseVNode("span")
              ], -1)),
              createBaseVNode("span", _hoisted_16$d, toDisplayString(processingText.value), 1)
            ])
          ])) : createCommentVNode("", true)
        ], 512),
        createBaseVNode("div", _hoisted_17$d, [
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputText.value = $event),
            onKeydown: [
              withKeys(withModifiers(sendMessage, ["exact", "prevent"]), ["enter"]),
              _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
              }, ["shift", "stop"]), ["enter"]))
            ],
            placeholder: "Describe the animation you want to create...",
            disabled: isProcessing.value,
            rows: "2",
            "aria-label": "Message input"
          }, null, 40, _hoisted_18$d), [
            [vModelText, inputText.value]
          ]),
          createBaseVNode("button", {
            class: "send-btn",
            onClick: sendMessage,
            disabled: !inputText.value.trim() || isProcessing.value,
            "aria-label": "Send message"
          }, [
            isProcessing.value ? (openBlock(), createElementBlock("span", _hoisted_20$d)) : (openBlock(), createElementBlock("span", _hoisted_21$c, "Send"))
          ], 8, _hoisted_19$d)
        ]),
        createBaseVNode("div", _hoisted_22$b, [
          createBaseVNode("span", {
            class: normalizeClass(["status-indicator", { connected: apiConnected.value, error: apiError.value }])
          }, null, 2),
          createBaseVNode("span", _hoisted_23$b, toDisplayString(statusText.value), 1)
        ])
      ]);
    };
  }
});

const AIChatPanel = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-7a978920"]]);

const MODEL_INFO = {
  "depth-anything": {
    type: "depth-anything",
    name: "Depth Anything",
    description: "Monocular depth estimation with high accuracy",
    memoryRequired: 1500
  },
  "depth-anything-v2": {
    type: "depth-anything-v2",
    name: "Depth Anything V2",
    description: "Improved depth estimation with better details",
    memoryRequired: 2e3
  },
  "normal-crafter": {
    type: "normal-crafter",
    name: "NormalCrafter",
    description: "Normal map generation from images",
    memoryRequired: 1200
  },
  "mat-seg": {
    type: "mat-seg",
    name: "Material Segmentation",
    description: "Segment materials and surfaces",
    memoryRequired: 800
  },
  "segment-anything": {
    type: "segment-anything",
    name: "Segment Anything (SAM)",
    description: "Zero-shot image segmentation",
    memoryRequired: 2500
  },
  "segment-anything-2": {
    type: "segment-anything-2",
    name: "Segment Anything 2",
    description: "Improved segmentation with video support",
    memoryRequired: 3e3
  },
  "stable-diffusion": {
    type: "stable-diffusion",
    name: "Stable Diffusion 1.5",
    description: "Text-to-image generation",
    memoryRequired: 4e3
  },
  "sdxl": {
    type: "sdxl",
    name: "Stable Diffusion XL",
    description: "High-resolution text-to-image",
    memoryRequired: 6e3
  },
  "flux": {
    type: "flux",
    name: "FLUX",
    description: "State-of-the-art text-to-image",
    memoryRequired: 8e3
  }
};
class AIGenerationService {
  modelStatus = /* @__PURE__ */ new Map();
  loadErrors = /* @__PURE__ */ new Map();
  loadTimes = /* @__PURE__ */ new Map();
  baseUrl = "/weyl/ai";
  constructor() {
    for (const type of Object.keys(MODEL_INFO)) {
      this.modelStatus.set(type, "not-loaded");
    }
  }
  // ========================================
  // MODEL MANAGEMENT
  // ========================================
  /**
   * Get information about a model
   */
  getModelInfo(type) {
    const base = MODEL_INFO[type];
    return {
      ...base,
      status: this.modelStatus.get(type) || "not-loaded",
      error: this.loadErrors.get(type),
      loadTime: this.loadTimes.get(type)
    };
  }
  /**
   * Get all available models
   */
  getAllModels() {
    return Object.keys(MODEL_INFO).map((type) => this.getModelInfo(type));
  }
  /**
   * Get currently loaded models
   */
  getLoadedModels() {
    return this.getAllModels().filter((m) => m.status === "ready");
  }
  /**
   * Check if a model is available
   */
  isModelAvailable(type) {
    return this.modelStatus.get(type) === "ready";
  }
  /**
   * Load a model
   */
  async loadModel(type) {
    const currentStatus = this.modelStatus.get(type);
    if (currentStatus === "ready") return true;
    if (currentStatus === "loading") {
      return this.waitForModelReady(type);
    }
    this.modelStatus.set(type, "loading");
    this.loadErrors.delete(type);
    const startTime = performance.now();
    try {
      const response = await fetch(`${this.baseUrl}/load`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: type })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to load model: ${response.status}`);
      }
      this.loadTimes.set(type, performance.now() - startTime);
      this.modelStatus.set(type, "ready");
      return true;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      this.loadErrors.set(type, message);
      this.modelStatus.set(type, "error");
      return false;
    }
  }
  /**
   * Unload a model to free memory
   */
  async unloadModel(type) {
    const currentStatus = this.modelStatus.get(type);
    if (currentStatus !== "ready") return true;
    this.modelStatus.set(type, "unloading");
    try {
      const response = await fetch(`${this.baseUrl}/unload`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ model: type })
      });
      if (!response.ok) {
        throw new Error(`Failed to unload model: ${response.status}`);
      }
      this.modelStatus.set(type, "not-loaded");
      this.loadTimes.delete(type);
      return true;
    } catch (error) {
      this.modelStatus.set(type, "ready");
      return false;
    }
  }
  async waitForModelReady(type, timeout = 6e4) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const status = this.modelStatus.get(type);
      if (status === "ready") return true;
      if (status === "error") return false;
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    return false;
  }
  // ========================================
  // DEPTH ESTIMATION
  // ========================================
  /**
   * Estimate depth from an image
   */
  async estimateDepth(image, options = { model: "depth-anything" }) {
    const startTime = performance.now();
    const loaded = await this.loadModel(options.model);
    if (!loaded) {
      return {
        success: false,
        error: `Failed to load ${options.model}`,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
    try {
      const formData = new FormData();
      formData.append("image", await this.imageToBlob(image));
      formData.append("options", JSON.stringify(options));
      const response = await fetch(`${this.baseUrl}/depth`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        throw new Error(`Depth estimation failed: ${response.status}`);
      }
      const blob = await response.blob();
      const imageData = await this.blobToImageData(blob);
      return {
        success: true,
        data: imageData,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
  }
  // ========================================
  // NORMAL MAP GENERATION
  // ========================================
  /**
   * Generate normal map from an image
   */
  async generateNormalMap(image, options = { model: "normal-crafter" }) {
    const startTime = performance.now();
    const loaded = await this.loadModel(options.model);
    if (!loaded) {
      return {
        success: false,
        error: `Failed to load ${options.model}`,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
    try {
      const formData = new FormData();
      formData.append("image", await this.imageToBlob(image));
      formData.append("options", JSON.stringify(options));
      const response = await fetch(`${this.baseUrl}/normal`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        throw new Error(`Normal map generation failed: ${response.status}`);
      }
      const blob = await response.blob();
      const imageData = await this.blobToImageData(blob);
      return {
        success: true,
        data: imageData,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
  }
  // ========================================
  // SEGMENTATION
  // ========================================
  /**
   * Segment an image
   */
  async segment(image, options) {
    const startTime = performance.now();
    const loaded = await this.loadModel(options.model);
    if (!loaded) {
      return {
        success: false,
        error: `Failed to load ${options.model}`,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
    try {
      const formData = new FormData();
      formData.append("image", await this.imageToBlob(image));
      formData.append("options", JSON.stringify(options));
      const response = await fetch(`${this.baseUrl}/segment`, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        throw new Error(`Segmentation failed: ${response.status}`);
      }
      const result = await response.json();
      const masks = await Promise.all(
        (result.masks || []).map(
          (maskBase64) => this.base64ToImageData(maskBase64)
        )
      );
      return {
        success: true,
        data: masks[0],
        // Primary mask
        masks,
        labels: result.labels,
        confidence: result.confidence,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
  }
  /**
   * Interactive segmentation with point/box prompts (SAM)
   */
  async segmentInteractive(image, point, box) {
    return this.segment(image, {
      model: "segment-anything-2",
      point,
      box
    });
  }
  // ========================================
  // IMAGE GENERATION
  // ========================================
  /**
   * Generate an image from text prompt
   */
  async generate(options) {
    const startTime = performance.now();
    const loaded = await this.loadModel(options.model);
    if (!loaded) {
      return {
        success: false,
        error: `Failed to load ${options.model}`,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
    try {
      const response = await fetch(`${this.baseUrl}/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(options)
      });
      if (!response.ok) {
        throw new Error(`Generation failed: ${response.status}`);
      }
      const blob = await response.blob();
      const imageData = await this.blobToImageData(blob);
      return {
        success: true,
        data: imageData,
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        processingTime: performance.now() - startTime,
        modelUsed: options.model
      };
    }
  }
  // ========================================
  // UTILITY METHODS
  // ========================================
  async imageToBlob(image) {
    if (image instanceof Blob) {
      return image;
    }
    if (image instanceof HTMLCanvasElement) {
      return new Promise((resolve, reject) => {
        image.toBlob((blob) => {
          if (blob) resolve(blob);
          else reject(new Error("Failed to convert canvas to blob"));
        }, "image/png");
      });
    }
    const canvas = new OffscreenCanvas(image.width, image.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(image, 0, 0);
    return canvas.convertToBlob({ type: "image/png" });
  }
  async blobToImageData(blob) {
    const bitmap = await createImageBitmap(blob);
    const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bitmap, 0, 0);
    return ctx.getImageData(0, 0, bitmap.width, bitmap.height);
  }
  async base64ToImageData(base64) {
    const response = await fetch(`data:image/png;base64,${base64}`);
    const blob = await response.blob();
    return this.blobToImageData(blob);
  }
  /**
   * Check backend connection
   */
  async checkConnection() {
    try {
      const response = await fetch(`${this.baseUrl}/status`);
      return response.ok;
    } catch {
      return false;
    }
  }
  /**
   * Get backend status
   */
  async getBackendStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/status`);
      if (!response.ok) {
        throw new Error("Backend unavailable");
      }
      return await response.json();
    } catch {
      return {
        connected: false,
        gpuAvailable: false,
        vramTotal: 0,
        vramUsed: 0,
        loadedModels: []
      };
    }
  }
  /**
   * Set the base URL for AI backend
   */
  setBaseUrl(url) {
    this.baseUrl = url;
  }
}
const aiGeneration = new AIGenerationService();

const _hoisted_1$l = {
  class: "ai-generate-panel",
  role: "region",
  "aria-label": "AI Generation Tools"
};
const _hoisted_2$l = { class: "panel-content" };
const _hoisted_3$l = { class: "section" };
const _hoisted_4$l = { class: "source-options" };
const _hoisted_5$l = {
  key: 0,
  class: "layer-info"
};
const _hoisted_6$l = { key: 0 };
const _hoisted_7$l = {
  key: 1,
  class: "no-selection"
};
const _hoisted_8$k = {
  key: 1,
  class: "file-upload"
};
const _hoisted_9$k = {
  key: 0,
  class: "file-name"
};
const _hoisted_10$j = { class: "section" };
const _hoisted_11$i = { class: "generation-types" };
const _hoisted_12$g = ["onClick", "title"];
const _hoisted_13$g = { class: "type-icon" };
const _hoisted_14$e = { class: "type-label" };
const _hoisted_15$d = { class: "section" };
const _hoisted_16$c = ["value"];
const _hoisted_17$c = {
  key: 0,
  class: "model-info"
};
const _hoisted_18$c = { class: "memory-badge" };
const _hoisted_19$c = { class: "section" };
const _hoisted_20$c = {
  key: 0,
  class: "options-group"
};
const _hoisted_21$b = { class: "option-row" };
const _hoisted_22$a = { class: "option-row" };
const _hoisted_23$a = {
  key: 1,
  class: "options-group"
};
const _hoisted_24$8 = { class: "option-row" };
const _hoisted_25$8 = { class: "value" };
const _hoisted_26$8 = { class: "option-row" };
const _hoisted_27$8 = { class: "value" };
const _hoisted_28$7 = {
  key: 2,
  class: "options-group"
};
const _hoisted_29$7 = { class: "option-row" };
const _hoisted_30$6 = { class: "section" };
const _hoisted_31$6 = { class: "output-options" };
const _hoisted_32$6 = { class: "option-row" };
const _hoisted_33$6 = { class: "option-row" };
const _hoisted_34$6 = { class: "option-row" };
const _hoisted_35$5 = { class: "section" };
const _hoisted_36$4 = ["disabled"];
const _hoisted_37$4 = {
  key: 0,
  class: "spinner"
};
const _hoisted_38$4 = { key: 1 };
const _hoisted_39$4 = {
  key: 1,
  class: "preview-section"
};
const _hoisted_40$3 = ["src"];
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "AIGeneratePanel",
  setup(__props) {
    const store = useCompositorStore();
    const selectionStore = useSelectionStore$1();
    const sourceType = ref("layer");
    const uploadedFile = ref(null);
    const uploadedFileName = ref("");
    const selectedType = ref("depth");
    const selectedModel = ref("depth-anything");
    const models = ref([]);
    const depthOptions = ref({
      colorMap: "grayscale",
      normalize: true
    });
    const normalOptions = ref({
      strength: 100,
      smoothing: 0
    });
    const segmentOptions = ref({
      autoMask: true
    });
    const outputTarget = ref("layer");
    const isGenerating = ref(false);
    const statusMessage = ref("");
    const statusType = ref("info");
    const previewUrl = ref(null);
    const generationTypes = [
      { id: "depth", label: "Depth", icon: "", description: "Estimate depth from image" },
      { id: "normal", label: "Normal", icon: "", description: "Generate normal map" },
      { id: "segment", label: "Segment", icon: "", description: "Segment objects" }
    ];
    const selectedLayerName = computed(() => {
      const layerId = selectionStore.selectedLayerIds[0];
      if (!layerId) return null;
      const layer = store.layers.find((l) => l.id === layerId);
      return layer?.name || null;
    });
    const availableModels = computed(() => {
      switch (selectedType.value) {
        case "depth":
          return models.value.filter(
            (m) => m.type === "depth-anything" || m.type === "depth-anything-v2"
          );
        case "normal":
          return models.value.filter((m) => m.type === "normal-crafter");
        case "segment":
          return models.value.filter(
            (m) => m.type === "segment-anything" || m.type === "segment-anything-2"
          );
        default:
          return models.value;
      }
    });
    const selectedModelInfo = computed(() => {
      return models.value.find((m) => m.type === selectedModel.value);
    });
    const canGenerate = computed(() => {
      if (sourceType.value === "layer" && !selectedLayerName.value) return false;
      if (sourceType.value === "file" && !uploadedFile.value) return false;
      return true;
    });
    const generateButtonText = computed(() => {
      if (isGenerating.value) return "Generating...";
      switch (selectedType.value) {
        case "depth":
          return "Generate Depth Map";
        case "normal":
          return "Generate Normal Map";
        case "segment":
          return "Segment Image";
        default:
          return "Generate";
      }
    });
    function handleFileSelect(event) {
      const input = event.target;
      const file = input.files?.[0];
      if (file) {
        uploadedFile.value = file;
        uploadedFileName.value = file.name;
      }
    }
    async function refreshModels() {
      try {
        models.value = aiGeneration.getAllModels();
        statusMessage.value = "Model status refreshed";
        statusType.value = "info";
      } catch (error) {
        statusMessage.value = "Failed to refresh models";
        statusType.value = "error";
      }
    }
    async function generate() {
      if (!canGenerate.value || isGenerating.value) return;
      isGenerating.value = true;
      statusMessage.value = "Starting generation...";
      statusType.value = "info";
      previewUrl.value = null;
      try {
        let sourceImage = null;
        if (sourceType.value === "file" && uploadedFile.value) {
          sourceImage = uploadedFile.value;
        } else if (sourceType.value === "canvas") {
          statusMessage.value = "Canvas capture not yet implemented";
          statusType.value = "error";
          return;
        } else if (sourceType.value === "layer") {
          statusMessage.value = "Layer capture not yet implemented";
          statusType.value = "error";
          return;
        }
        if (!sourceImage) {
          statusMessage.value = "No source image available";
          statusType.value = "error";
          return;
        }
        statusMessage.value = `Running ${selectedType.value} estimation...`;
        let result;
        switch (selectedType.value) {
          case "depth":
            result = await aiGeneration.estimateDepth(sourceImage, {
              model: selectedModel.value,
              normalize: depthOptions.value.normalize,
              colorMap: depthOptions.value.colorMap
            });
            break;
          case "normal":
            result = await aiGeneration.generateNormalMap(sourceImage, {
              model: "normal-crafter",
              strength: normalOptions.value.strength / 100,
              smoothing: normalOptions.value.smoothing / 100
            });
            break;
          case "segment":
            result = await aiGeneration.segmentImage(sourceImage, {
              model: selectedModel.value
            });
            break;
        }
        if (result?.success && result.data) {
          statusMessage.value = `Generation complete in ${result.processingTime.toFixed(0)}ms`;
          statusType.value = "success";
          const canvas = document.createElement("canvas");
          canvas.width = result.data.width;
          canvas.height = result.data.height;
          const ctx = canvas.getContext("2d");
          if (ctx) {
            ctx.putImageData(result.data, 0, 0);
            previewUrl.value = canvas.toDataURL();
          }
          if (outputTarget.value === "download" && previewUrl.value) {
            const a = document.createElement("a");
            a.href = previewUrl.value;
            a.download = `${selectedType.value}_map.png`;
            a.click();
          } else if (outputTarget.value === "layer") {
            statusMessage.value += " - Create layer feature pending";
          }
        } else {
          statusMessage.value = result?.error || "Generation failed";
          statusType.value = "error";
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown error";
        statusMessage.value = `Error: ${message}`;
        statusType.value = "error";
      } finally {
        isGenerating.value = false;
      }
    }
    onMounted(() => {
      refreshModels();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", { class: "panel-header" }, [
          _cache[14] || (_cache[14] = createBaseVNode("span", { class: "panel-title" }, "AI Generate", -1)),
          createBaseVNode("button", {
            class: "refresh-btn",
            onClick: refreshModels,
            title: "Refresh model status"
          }, [..._cache[13] || (_cache[13] = [
            createBaseVNode("i", { class: "pi pi-refresh" }, null, -1)
          ])])
        ]),
        createBaseVNode("div", _hoisted_2$l, [
          createBaseVNode("div", _hoisted_3$l, [
            _cache[15] || (_cache[15] = createBaseVNode("div", { class: "section-header" }, "Source", -1)),
            createBaseVNode("div", _hoisted_4$l, [
              createBaseVNode("button", {
                class: normalizeClass({ active: sourceType.value === "layer" }),
                onClick: _cache[0] || (_cache[0] = ($event) => sourceType.value = "layer")
              }, " Selected Layer ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: sourceType.value === "canvas" }),
                onClick: _cache[1] || (_cache[1] = ($event) => sourceType.value = "canvas")
              }, " Canvas Frame ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: sourceType.value === "file" }),
                onClick: _cache[2] || (_cache[2] = ($event) => sourceType.value = "file")
              }, " Upload File ", 2)
            ]),
            sourceType.value === "layer" ? (openBlock(), createElementBlock("div", _hoisted_5$l, [
              selectedLayerName.value ? (openBlock(), createElementBlock("span", _hoisted_6$l, toDisplayString(selectedLayerName.value), 1)) : (openBlock(), createElementBlock("span", _hoisted_7$l, "No layer selected"))
            ])) : createCommentVNode("", true),
            sourceType.value === "file" ? (openBlock(), createElementBlock("div", _hoisted_8$k, [
              createBaseVNode("input", {
                type: "file",
                ref: "fileInput",
                accept: "image/*",
                onChange: handleFileSelect,
                style: { "display": "none" }
              }, null, 544),
              createBaseVNode("button", {
                class: "upload-btn",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$refs.fileInput?.click())
              }, " Select Image... "),
              uploadedFileName.value ? (openBlock(), createElementBlock("span", _hoisted_9$k, toDisplayString(uploadedFileName.value), 1)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_10$j, [
            _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-header" }, "Generation Type", -1)),
            createBaseVNode("div", _hoisted_11$i, [
              (openBlock(), createElementBlock(Fragment, null, renderList(generationTypes, (type) => {
                return createBaseVNode("button", {
                  key: type.id,
                  class: normalizeClass({ active: selectedType.value === type.id }),
                  onClick: ($event) => selectedType.value = type.id,
                  title: type.description
                }, [
                  createBaseVNode("span", _hoisted_13$g, toDisplayString(type.icon), 1),
                  createBaseVNode("span", _hoisted_14$e, toDisplayString(type.label), 1)
                ], 10, _hoisted_12$g);
              }), 64))
            ])
          ]),
          createBaseVNode("div", _hoisted_15$d, [
            _cache[17] || (_cache[17] = createBaseVNode("div", { class: "section-header" }, "Model", -1)),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => selectedModel.value = $event),
              class: "model-select"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(availableModels.value, (model) => {
                return openBlock(), createElementBlock("option", {
                  key: model.type,
                  value: model.type
                }, toDisplayString(model.name), 9, _hoisted_16$c);
              }), 128))
            ], 512), [
              [vModelSelect, selectedModel.value]
            ]),
            selectedModelInfo.value ? (openBlock(), createElementBlock("div", _hoisted_17$c, [
              createBaseVNode("span", _hoisted_18$c, toDisplayString(selectedModelInfo.value.memoryRequired) + "MB", 1),
              createBaseVNode("span", {
                class: normalizeClass(["status-badge", selectedModelInfo.value.status])
              }, toDisplayString(selectedModelInfo.value.status), 3)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_19$c, [
            _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-header" }, "Options", -1)),
            selectedType.value === "depth" ? (openBlock(), createElementBlock("div", _hoisted_20$c, [
              createBaseVNode("label", _hoisted_21$b, [
                _cache[19] || (_cache[19] = createBaseVNode("span", null, "Color Map", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => depthOptions.value.colorMap = $event)
                }, [..._cache[18] || (_cache[18] = [
                  createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1),
                  createBaseVNode("option", { value: "viridis" }, "Viridis", -1),
                  createBaseVNode("option", { value: "plasma" }, "Plasma", -1),
                  createBaseVNode("option", { value: "magma" }, "Magma", -1)
                ])], 512), [
                  [vModelSelect, depthOptions.value.colorMap]
                ])
              ]),
              createBaseVNode("label", _hoisted_22$a, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => depthOptions.value.normalize = $event)
                }, null, 512), [
                  [vModelCheckbox, depthOptions.value.normalize]
                ]),
                _cache[20] || (_cache[20] = createBaseVNode("span", null, "Normalize output", -1))
              ])
            ])) : createCommentVNode("", true),
            selectedType.value === "normal" ? (openBlock(), createElementBlock("div", _hoisted_23$a, [
              createBaseVNode("label", _hoisted_24$8, [
                _cache[21] || (_cache[21] = createBaseVNode("span", null, "Strength", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "range",
                  min: "0",
                  max: "100",
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => normalOptions.value.strength = $event)
                }, null, 512), [
                  [
                    vModelText,
                    normalOptions.value.strength,
                    void 0,
                    { number: true }
                  ]
                ]),
                createBaseVNode("span", _hoisted_25$8, toDisplayString(normalOptions.value.strength) + "%", 1)
              ]),
              createBaseVNode("label", _hoisted_26$8, [
                _cache[22] || (_cache[22] = createBaseVNode("span", null, "Smoothing", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "range",
                  min: "0",
                  max: "100",
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => normalOptions.value.smoothing = $event)
                }, null, 512), [
                  [
                    vModelText,
                    normalOptions.value.smoothing,
                    void 0,
                    { number: true }
                  ]
                ]),
                createBaseVNode("span", _hoisted_27$8, toDisplayString(normalOptions.value.smoothing) + "%", 1)
              ])
            ])) : createCommentVNode("", true),
            selectedType.value === "segment" ? (openBlock(), createElementBlock("div", _hoisted_28$7, [
              _cache[24] || (_cache[24] = createBaseVNode("div", { class: "option-row" }, [
                createBaseVNode("span", null, "Click on canvas to set point")
              ], -1)),
              createBaseVNode("label", _hoisted_29$7, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => segmentOptions.value.autoMask = $event)
                }, null, 512), [
                  [vModelCheckbox, segmentOptions.value.autoMask]
                ]),
                _cache[23] || (_cache[23] = createBaseVNode("span", null, "Auto-mask to layer", -1))
              ])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_30$6, [
            _cache[29] || (_cache[29] = createBaseVNode("div", { class: "section-header" }, "Output", -1)),
            createBaseVNode("div", _hoisted_31$6, [
              createBaseVNode("label", _hoisted_32$6, [
                withDirectives(createBaseVNode("input", {
                  type: "radio",
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => outputTarget.value = $event),
                  value: "layer"
                }, null, 512), [
                  [vModelRadio, outputTarget.value]
                ]),
                _cache[26] || (_cache[26] = createBaseVNode("span", null, "Create new layer", -1))
              ]),
              createBaseVNode("label", _hoisted_33$6, [
                withDirectives(createBaseVNode("input", {
                  type: "radio",
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => outputTarget.value = $event),
                  value: "mask"
                }, null, 512), [
                  [vModelRadio, outputTarget.value]
                ]),
                _cache[27] || (_cache[27] = createBaseVNode("span", null, "Apply as layer mask", -1))
              ]),
              createBaseVNode("label", _hoisted_34$6, [
                withDirectives(createBaseVNode("input", {
                  type: "radio",
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => outputTarget.value = $event),
                  value: "download"
                }, null, 512), [
                  [vModelRadio, outputTarget.value]
                ]),
                _cache[28] || (_cache[28] = createBaseVNode("span", null, "Download file", -1))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_35$5, [
            createBaseVNode("button", {
              class: "generate-btn",
              disabled: !canGenerate.value || isGenerating.value,
              onClick: generate
            }, [
              isGenerating.value ? (openBlock(), createElementBlock("span", _hoisted_37$4)) : (openBlock(), createElementBlock("span", _hoisted_38$4, toDisplayString(generateButtonText.value), 1))
            ], 8, _hoisted_36$4)
          ]),
          statusMessage.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["status-message", statusType.value])
          }, toDisplayString(statusMessage.value), 3)) : createCommentVNode("", true),
          previewUrl.value ? (openBlock(), createElementBlock("div", _hoisted_39$4, [
            _cache[30] || (_cache[30] = createBaseVNode("div", { class: "section-header" }, "Preview", -1)),
            createBaseVNode("img", {
              src: previewUrl.value,
              class: "preview-image",
              alt: "Generation preview"
            }, null, 8, _hoisted_40$3)
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AIGeneratePanel = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-29f0d380"]]);

const _hoisted_1$k = { class: "align-panel" };
const _hoisted_2$k = { class: "panel-content" };
const _hoisted_3$k = { class: "control-section" };
const _hoisted_4$k = { class: "align-target-toggle" };
const _hoisted_5$k = { class: "control-section" };
const _hoisted_6$k = { class: "align-buttons" };
const _hoisted_7$k = ["disabled"];
const _hoisted_8$j = ["disabled"];
const _hoisted_9$j = ["disabled"];
const _hoisted_10$i = ["disabled"];
const _hoisted_11$h = ["disabled"];
const _hoisted_12$f = ["disabled"];
const _hoisted_13$f = { class: "control-section" };
const _hoisted_14$d = { class: "align-buttons" };
const _hoisted_15$c = ["disabled"];
const _hoisted_16$b = ["disabled"];
const _hoisted_17$b = { class: "selection-info" };
const _hoisted_18$b = { key: 0 };
const _hoisted_19$b = { key: 1 };
const _hoisted_20$b = { key: 2 };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "AlignPanel",
  setup(__props) {
    const store = useCompositorStore();
    const alignTarget = ref("composition");
    const selectedCount = computed(() => store.selectedLayerIds.length);
    const canAlign = computed(() => selectedCount.value >= 1);
    const canDistribute = computed(() => selectedCount.value >= 3);
    function alignLayers(direction) {
      const layerIds = store.selectedLayerIds;
      if (layerIds.length === 0) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const layers = layerIds.map((id) => store.getLayerById(id)).filter(Boolean);
      if (layers.length === 0) return;
      let targetBounds;
      if (alignTarget.value === "composition") {
        targetBounds = {
          left: 0,
          right: comp.settings.width,
          top: 0,
          bottom: comp.settings.height,
          centerX: comp.settings.width / 2,
          centerY: comp.settings.height / 2
        };
      } else {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const layer of layers) {
          if (!layer) continue;
          const pos = layer.transform?.position?.value || { x: 0, y: 0 };
          minX = Math.min(minX, pos.x);
          maxX = Math.max(maxX, pos.x);
          minY = Math.min(minY, pos.y);
          maxY = Math.max(maxY, pos.y);
        }
        targetBounds = {
          left: minX,
          right: maxX,
          top: minY,
          bottom: maxY,
          centerX: (minX + maxX) / 2,
          centerY: (minY + maxY) / 2
        };
      }
      for (const layer of layers) {
        if (!layer || !layer.transform?.position) continue;
        const pos = { ...layer.transform.position.value };
        switch (direction) {
          case "left":
            pos.x = targetBounds.left;
            break;
          case "centerH":
            pos.x = targetBounds.centerX;
            break;
          case "right":
            pos.x = targetBounds.right;
            break;
          case "top":
            pos.y = targetBounds.top;
            break;
          case "centerV":
            pos.y = targetBounds.centerY;
            break;
          case "bottom":
            pos.y = targetBounds.bottom;
            break;
        }
        layer.transform.position.value = pos;
      }
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    }
    function distributeLayers(direction) {
      const layerIds = store.selectedLayerIds;
      if (layerIds.length < 3) return;
      const layers = layerIds.map((id) => store.getLayerById(id)).filter(Boolean).filter((l) => l?.transform?.position);
      if (layers.length < 3) return;
      const sorted = [...layers].sort((a, b) => {
        const posA = a.transform.position.value;
        const posB = b.transform.position.value;
        return direction === "horizontal" ? posA.x - posB.x : posA.y - posB.y;
      });
      const first = sorted[0].transform.position.value;
      const last = sorted[sorted.length - 1].transform.position.value;
      const totalDistance = direction === "horizontal" ? last.x - first.x : last.y - first.y;
      const spacing = totalDistance / (sorted.length - 1);
      for (let i = 1; i < sorted.length - 1; i++) {
        const layer = sorted[i];
        const pos = { ...layer.transform.position.value };
        if (direction === "horizontal") {
          pos.x = first.x + spacing * i;
        } else {
          pos.y = first.y + spacing * i;
        }
        layer.transform.position.value = pos;
      }
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        _cache[22] || (_cache[22] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Align")
        ], -1)),
        createBaseVNode("div", _hoisted_2$k, [
          createBaseVNode("div", _hoisted_3$k, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Align Layers To")
            ], -1)),
            createBaseVNode("div", _hoisted_4$k, [
              createBaseVNode("button", {
                class: normalizeClass(["target-btn", { active: alignTarget.value === "composition" }]),
                onClick: _cache[0] || (_cache[0] = ($event) => alignTarget.value = "composition"),
                title: "Align layers to composition bounds"
              }, " Composition ", 2),
              createBaseVNode("button", {
                class: normalizeClass(["target-btn", { active: alignTarget.value === "selection" }]),
                onClick: _cache[1] || (_cache[1] = ($event) => alignTarget.value = "selection"),
                title: "Align layers to selection bounds"
              }, " Selection ", 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_5$k, [
            _cache[18] || (_cache[18] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Align")
            ], -1)),
            createBaseVNode("div", _hoisted_6$k, [
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[2] || (_cache[2] = ($event) => alignLayers("left")),
                disabled: !canAlign.value,
                title: "Align Left Edges"
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "3",
                    y: "4",
                    width: "2",
                    height: "16",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "7",
                    y: "6",
                    width: "10",
                    height: "4",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "7",
                    y: "14",
                    width: "14",
                    height: "4",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_7$k),
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[3] || (_cache[3] = ($event) => alignLayers("centerH")),
                disabled: !canAlign.value,
                title: "Align Horizontal Centers"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "11",
                    y: "4",
                    width: "2",
                    height: "16",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "5",
                    y: "6",
                    width: "14",
                    height: "4",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "3",
                    y: "14",
                    width: "18",
                    height: "4",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_8$j),
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[4] || (_cache[4] = ($event) => alignLayers("right")),
                disabled: !canAlign.value,
                title: "Align Right Edges"
              }, [..._cache[13] || (_cache[13] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "19",
                    y: "4",
                    width: "2",
                    height: "16",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "7",
                    y: "6",
                    width: "10",
                    height: "4",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "3",
                    y: "14",
                    width: "14",
                    height: "4",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_9$j),
              _cache[17] || (_cache[17] = createBaseVNode("div", { class: "separator" }, null, -1)),
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[5] || (_cache[5] = ($event) => alignLayers("top")),
                disabled: !canAlign.value,
                title: "Align Top Edges"
              }, [..._cache[14] || (_cache[14] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "4",
                    y: "3",
                    width: "16",
                    height: "2",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "6",
                    y: "7",
                    width: "4",
                    height: "10",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "14",
                    y: "7",
                    width: "4",
                    height: "14",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_10$i),
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[6] || (_cache[6] = ($event) => alignLayers("centerV")),
                disabled: !canAlign.value,
                title: "Align Vertical Centers"
              }, [..._cache[15] || (_cache[15] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "4",
                    y: "11",
                    width: "16",
                    height: "2",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "6",
                    y: "5",
                    width: "4",
                    height: "14",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "14",
                    y: "3",
                    width: "4",
                    height: "18",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_11$h),
              createBaseVNode("button", {
                class: "align-btn",
                onClick: _cache[7] || (_cache[7] = ($event) => alignLayers("bottom")),
                disabled: !canAlign.value,
                title: "Align Bottom Edges"
              }, [..._cache[16] || (_cache[16] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "4",
                    y: "19",
                    width: "16",
                    height: "2",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "6",
                    y: "7",
                    width: "4",
                    height: "10",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "14",
                    y: "3",
                    width: "4",
                    height: "14",
                    fill: "currentColor"
                  })
                ], -1)
              ])], 8, _hoisted_12$f)
            ])
          ]),
          createBaseVNode("div", _hoisted_13$f, [
            _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Distribute")
            ], -1)),
            createBaseVNode("div", _hoisted_14$d, [
              createBaseVNode("button", {
                class: "align-btn wide",
                onClick: _cache[8] || (_cache[8] = ($event) => distributeLayers("horizontal")),
                disabled: !canDistribute.value,
                title: "Distribute Horizontally"
              }, [..._cache[19] || (_cache[19] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "3",
                    y: "6",
                    width: "4",
                    height: "12",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "10",
                    y: "8",
                    width: "4",
                    height: "8",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "17",
                    y: "6",
                    width: "4",
                    height: "12",
                    fill: "currentColor"
                  })
                ], -1),
                createBaseVNode("span", null, "Horizontal", -1)
              ])], 8, _hoisted_15$c),
              createBaseVNode("button", {
                class: "align-btn wide",
                onClick: _cache[9] || (_cache[9] = ($event) => distributeLayers("vertical")),
                disabled: !canDistribute.value,
                title: "Distribute Vertically"
              }, [..._cache[20] || (_cache[20] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  class: "align-icon"
                }, [
                  createBaseVNode("rect", {
                    x: "6",
                    y: "3",
                    width: "12",
                    height: "4",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "8",
                    y: "10",
                    width: "8",
                    height: "4",
                    fill: "currentColor"
                  }),
                  createBaseVNode("rect", {
                    x: "6",
                    y: "17",
                    width: "12",
                    height: "4",
                    fill: "currentColor"
                  })
                ], -1),
                createBaseVNode("span", null, "Vertical", -1)
              ])], 8, _hoisted_16$b)
            ])
          ]),
          createBaseVNode("div", _hoisted_17$b, [
            selectedCount.value === 0 ? (openBlock(), createElementBlock("span", _hoisted_18$b, "No layers selected")) : selectedCount.value === 1 ? (openBlock(), createElementBlock("span", _hoisted_19$b, "1 layer selected")) : (openBlock(), createElementBlock("span", _hoisted_20$b, toDisplayString(selectedCount.value) + " layers selected", 1))
          ])
        ])
      ]);
    };
  }
});

const AlignPanel = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-70fd61e4"]]);

const CAMERA_BODY_SIZE = 40;
const CAMERA_LENS_LENGTH = 30;
function generateCameraBody(camera) {
  const lines = [];
  const color = "#ffcc00";
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const halfSize = CAMERA_BODY_SIZE / 2;
  const bodyBack = addVec3(pos, scaleVec3(forward, -CAMERA_BODY_SIZE));
  const corners = [];
  for (let z = 0; z < 2; z++) {
    const zOffset = z === 0 ? pos : bodyBack;
    for (let x = -1; x <= 1; x += 2) {
      for (let y = -1; y <= 1; y += 2) {
        corners.push(addVec3(
          addVec3(zOffset, scaleVec3(right, x * halfSize)),
          scaleVec3(up, y * halfSize)
        ));
      }
    }
  }
  lines.push({ start: corners[0], end: corners[1], color });
  lines.push({ start: corners[1], end: corners[3], color });
  lines.push({ start: corners[3], end: corners[2], color });
  lines.push({ start: corners[2], end: corners[0], color });
  lines.push({ start: corners[4], end: corners[5], color });
  lines.push({ start: corners[5], end: corners[7], color });
  lines.push({ start: corners[7], end: corners[6], color });
  lines.push({ start: corners[6], end: corners[4], color });
  lines.push({ start: corners[0], end: corners[4], color });
  lines.push({ start: corners[1], end: corners[5], color });
  lines.push({ start: corners[2], end: corners[6], color });
  lines.push({ start: corners[3], end: corners[7], color });
  const lensEnd = addVec3(pos, scaleVec3(forward, CAMERA_LENS_LENGTH));
  const lensPoints = 8;
  for (let i = 0; i < lensPoints; i++) {
    const angle = i / lensPoints * Math.PI * 2;
    const nextAngle = (i + 1) / lensPoints * Math.PI * 2;
    const p1 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(angle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(angle) * halfSize * 0.5)
    );
    const p2 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(nextAngle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(nextAngle) * halfSize * 0.5)
    );
    lines.push({ start: p1, end: p2, color });
    lines.push({ start: p1, end: lensEnd, color });
  }
  return lines;
}
function generateFrustum(camera, compWidth, compHeight, maxDistance = 2e3) {
  const lines = [];
  const color = "#7c9cff";
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  const aspect = compWidth / compHeight;
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const near = camera.nearClip;
  const far = Math.min(camera.farClip, maxDistance);
  const nearHalfHeight = near * Math.tan(fovY * Math.PI / 360);
  const nearHalfWidth = nearHalfHeight * aspect;
  const farHalfHeight = far * Math.tan(fovY * Math.PI / 360);
  const farHalfWidth = farHalfHeight * aspect;
  const nearCenter = addVec3(pos, scaleVec3(forward, near));
  const nearCorners = [
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, -nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, -nearHalfHeight))
  ];
  const farCenter = addVec3(pos, scaleVec3(forward, far));
  const farCorners = [
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, -farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, -farHalfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: nearCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: farCorners[i], end: farCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: farCorners[i], color });
  }
  return lines;
}
function generateCompositionBounds(compWidth, compHeight) {
  const color = "#00ff88";
  const corners = [
    vec3(0, 0, 0),
    vec3(compWidth, 0, 0),
    vec3(compWidth, compHeight, 0),
    vec3(0, compHeight, 0)
  ];
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  lines.push({ start: corners[0], end: corners[2], color: "#005533" });
  lines.push({ start: corners[1], end: corners[3], color: "#005533" });
  return lines;
}
function generatePOILine(camera) {
  if (camera.type !== "two-node") {
    return null;
  }
  return {
    start: camera.position,
    end: camera.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function generateFocalPlane(camera, compWidth, compHeight) {
  if (!camera.depthOfField.enabled) {
    return [];
  }
  const color = "#ff00ff";
  const lines = [];
  const pos = camera.position;
  const focusDist = camera.depthOfField.focusDistance;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const center = addVec3(pos, scaleVec3(forward, focusDist));
  const halfWidth = compWidth / 4;
  const halfHeight = compHeight / 4;
  const corners = [
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, -halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, -halfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  return lines;
}
function generateCameraVisualization(camera, compWidth, compHeight, showFrustum = true, showBounds = true, showFocalPlane = false) {
  return {
    body: generateCameraBody(camera),
    frustum: showFrustum ? generateFrustum(camera, compWidth, compHeight) : [],
    compositionBounds: showBounds ? generateCompositionBounds(compWidth, compHeight) : [],
    poiLine: generatePOILine(camera),
    focalPlane: showFocalPlane ? generateFocalPlane(camera, compWidth, compHeight) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function getCameraViewMatrices(camera, compWidth, compHeight) {
  const aspect = compWidth / compHeight;
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  let target;
  if (camera.type === "two-node") {
    target = camera.pointOfInterest;
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    const forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
    target = addVec3(camera.position, scaleVec3(forward, 1e3));
  }
  const view = lookAtMat4(camera.position, target, vec3(0, -1, 0));
  const projection = perspectiveMat4(fovY, aspect, camera.nearClip, camera.farClip);
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function getOrthoViewMatrices(viewType, compWidth, compHeight, customView) {
  const aspect = compWidth / compHeight;
  let view;
  let size = 1e3;
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  switch (viewType) {
    case "front":
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "back":
      view = lookAtMat4(
        vec3(centerX, centerY, 2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "left":
      view = lookAtMat4(
        vec3(-2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "right":
      view = lookAtMat4(
        vec3(centerX + 2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "top":
      view = lookAtMat4(
        vec3(centerX, -2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, 1)
      );
      break;
    case "bottom":
      view = lookAtMat4(
        vec3(centerX, centerY + 2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (customView) {
        const phi = customView.orbitPhi * Math.PI / 180;
        const theta = customView.orbitTheta * Math.PI / 180;
        const dist = customView.orbitDistance;
        const eye = vec3(
          customView.orbitCenter.x + dist * Math.sin(phi) * Math.sin(theta),
          customView.orbitCenter.y + dist * Math.cos(phi),
          customView.orbitCenter.z + dist * Math.sin(phi) * Math.cos(theta)
        );
        view = lookAtMat4(
          eye,
          customView.orbitCenter,
          vec3(0, -1, 0)
        );
        size = 1e3 / customView.orthoZoom;
      } else {
        view = lookAtMat4(
          vec3(centerX, centerY, -2e3),
          vec3(centerX, centerY, 0),
          vec3(0, -1, 0)
        );
      }
      break;
    default:
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
  }
  const projection = orthographicMat4(
    -size * aspect,
    size * aspect,
    -size,
    size,
    1,
    1e4
  );
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function multiplyMat4Local(a, b) {
  const ae = a.elements;
  const be = b.elements;
  const result = new Float32Array(16);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      let sum = 0;
      for (let i = 0; i < 4; i++) {
        sum += ae[row + i * 4] * be[i + col * 4];
      }
      result[row + col * 4] = sum;
    }
  }
  return { elements: result };
}
function projectToScreen(point, viewProjection, screenWidth, screenHeight) {
  const transformed = transformPoint(viewProjection, point);
  const vp = viewProjection.elements;
  const w = point.x * vp[3] + point.y * vp[7] + point.z * vp[11] + vp[15];
  if (w <= 0) {
    return { x: 0, y: 0, z: transformed.z, visible: false };
  }
  const x = (transformed.x / w * 0.5 + 0.5) * screenWidth;
  const y = (-transformed.y / w * 0.5 + 0.5) * screenHeight;
  return {
    x,
    y,
    z: transformed.z / w,
    visible: true
  };
}
function generate3DAxes(center, length = 100) {
  return [
    { start: center, end: addVec3(center, vec3(length, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: center, end: addVec3(center, vec3(0, length, 0)), color: "#00ff00" },
    // Y - Green
    { start: center, end: addVec3(center, vec3(0, 0, length)), color: "#0000ff" }
    // Z - Blue
  ];
}
function generateGrid(compWidth, compHeight, spacing = 100) {
  const lines = [];
  const color = "#333333";
  const centerColor = "#444444";
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  const extent = Math.max(compWidth, compHeight);
  for (let x = -extent; x <= extent + compWidth; x += spacing) {
    const isCenter = Math.abs(x - centerX) < spacing / 2;
    lines.push({
      start: vec3(x, -extent, 0),
      end: vec3(x, extent + compHeight, 0),
      color: isCenter ? centerColor : color
    });
  }
  for (let y = -extent; y <= extent + compHeight; y += spacing) {
    const isCenter = Math.abs(y - centerY) < spacing / 2;
    lines.push({
      start: vec3(-extent, y, 0),
      end: vec3(extent + compWidth, y, 0),
      color: isCenter ? centerColor : color
    });
  }
  return lines;
}

const _hoisted_1$j = ["onClick"];
const _hoisted_2$j = { class: "view-header" };
const _hoisted_3$j = ["value", "onChange"];
const _hoisted_4$j = { class: "view-tools" };
const _hoisted_5$j = ["onClick"];
const _hoisted_6$j = ["onMousedown", "onWheel"];
const _hoisted_7$j = { class: "view-info" };
const _hoisted_8$i = { class: "view-name" };
const _hoisted_9$i = {
  key: 0,
  class: "view-coords"
};
const _hoisted_10$h = { class: "layout-controls" };
const _hoisted_11$g = ["onClick", "title"];
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "ViewportRenderer",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => store.activeCamera);
    const compWidth = computed(() => store.width);
    const compHeight = computed(() => store.height);
    const viewportState = computed(() => store.viewportState);
    const viewOptions = computed(() => store.viewOptions);
    const layers = computed(() => {
      return store.layers.filter((l) => l.type !== "camera").map((l) => ({
        id: l.id,
        name: l.name,
        position: {
          x: l.transform.position.value.x,
          y: l.transform.position.value.y,
          z: 0
          // 2D layers at z=0
        },
        selected: store.selectedLayerIds.includes(l.id)
      }));
    });
    const canvasRefs = ref([null, null, null, null]);
    const contexts = ref([null, null, null, null]);
    const isDragging = ref(false);
    const dragStartPos = ref({ x: 0, y: 0 });
    const dragViewIndex = ref(0);
    const dragButton = ref(0);
    const layoutOptions = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ];
    const layout = computed(() => viewportState.value.layout);
    const activeViewIndex = computed(() => viewportState.value.activeViewIndex);
    const customViews = computed(() => viewportState.value.customViews);
    const activeViews = computed(() => {
      switch (viewportState.value.layout) {
        case "1-view":
          return [viewportState.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return viewportState.value.views.slice(0, 2);
        case "4-view":
          return viewportState.value.views.slice(0, 4);
        default:
          return [viewportState.value.views[0]];
      }
    });
    function setCanvasRef(el, index) {
      canvasRefs.value[index] = el;
      if (el) {
        contexts.value[index] = el.getContext("2d");
      }
    }
    function isCustomView(viewType) {
      return viewType.startsWith("custom-");
    }
    function getViewDisplayName(viewType) {
      const names = {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        "front": "Front",
        "back": "Back",
        "left": "Left",
        "right": "Right",
        "top": "Top",
        "bottom": "Bottom"
      };
      return names[viewType];
    }
    function setActiveView(index) {
      store.updateViewportState({
        activeViewIndex: index
      });
    }
    function updateViewType(index, viewType) {
      const newViews = [...viewportState.value.views];
      newViews[index] = viewType;
      store.updateViewportState({
        views: newViews
      });
    }
    function setLayout(newLayout) {
      const defaultFourViews = ["active-camera", "top", "front", "right"];
      let newViews = [...viewportState.value.views];
      while (newViews.length < 4) {
        newViews.push(defaultFourViews[newViews.length] || "front");
      }
      store.updateViewportState({
        layout: newLayout,
        views: newViews,
        activeViewIndex: Math.min(viewportState.value.activeViewIndex, getViewCount(newLayout) - 1)
      });
    }
    function getViewCount(layout2) {
      switch (layout2) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function resetCustomView(viewType) {
      const defaultView = {
        orbitCenter: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      store.updateViewportState({
        customViews: {
          ...viewportState.value.customViews,
          [viewType]: defaultView
        }
      });
    }
    function onCanvasMouseDown(e, viewIndex) {
      isDragging.value = true;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      dragViewIndex.value = viewIndex;
      dragButton.value = e.button;
      document.addEventListener("mousemove", onCanvasMouseMove);
      document.addEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasMouseMove(e) {
      if (!isDragging.value) return;
      const dx = e.clientX - dragStartPos.value.x;
      const dy = e.clientY - dragStartPos.value.y;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      const viewType = activeViews.value[dragViewIndex.value];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        if (dragButton.value === 0) {
          const newTheta = customView.orbitTheta + dx * 0.5;
          const newPhi = Math.max(1, Math.min(179, customView.orbitPhi + dy * 0.5));
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orbitTheta: newTheta,
                orbitPhi: newPhi
              }
            }
          });
        } else if (dragButton.value === 1 || dragButton.value === 2) {
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orthoOffset: {
                  x: customView.orthoOffset.x + dx,
                  y: customView.orthoOffset.y + dy
                }
              }
            }
          });
        }
      }
    }
    function onCanvasMouseUp() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onCanvasMouseMove);
      document.removeEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasWheel(e, viewIndex) {
      e.preventDefault();
      const viewType = activeViews.value[viewIndex];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [viewType]: {
              ...customView,
              orbitDistance: customView.orbitDistance * zoomFactor
            }
          }
        });
      }
    }
    function render() {
      activeViews.value.forEach((viewType, index) => {
        const canvas = canvasRefs.value[index];
        const ctx = contexts.value[index];
        if (!canvas || !ctx) return;
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, rect.width, rect.height);
        let matrices;
        if (viewType === "active-camera" && camera.value) {
          matrices = getCameraViewMatrices(camera.value, compWidth.value, compHeight.value);
        } else if (isCustomView(viewType)) {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value, customViews.value[viewType]);
        } else {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value);
        }
        const lines = [];
        if (viewOptions.value.showGrid) {
          lines.push(...generateGrid(compWidth.value, compHeight.value));
        }
        if (viewOptions.value.show3DReferenceAxes) {
          lines.push(...generate3DAxes(vec3(compWidth.value / 2, compHeight.value / 2, 0)));
        }
        if (viewOptions.value.showCompositionBounds) {
          const viz = generateCameraVisualization(
            camera.value ?? createDummyCamera(),
            compWidth.value,
            compHeight.value,
            false,
            true,
            false
          );
          lines.push(...viz.compositionBounds);
        }
        if (viewType !== "active-camera" && camera.value) {
          const showWireframe = viewOptions.value.cameraWireframes === "always" || viewOptions.value.cameraWireframes === "selected";
          if (showWireframe) {
            const viz = generateCameraVisualization(
              camera.value,
              compWidth.value,
              compHeight.value,
              true,
              false,
              viewOptions.value.showFocalPlane
            );
            lines.push(...viz.body);
            lines.push(...viz.frustum);
            lines.push(...viz.focalPlane);
            if (viz.poiLine) {
              lines.push(viz.poiLine);
            }
          }
        }
        for (const line of lines) {
          const start = projectToScreen(line.start, matrices.viewProjection, rect.width, rect.height);
          const end = projectToScreen(line.end, matrices.viewProjection, rect.width, rect.height);
          if (!start.visible && !end.visible) continue;
          ctx.beginPath();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 1;
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
        if (viewOptions.value.showLayerHandles) {
          for (const layer of layers.value) {
            const pos = projectToScreen(layer.position, matrices.viewProjection, rect.width, rect.height);
            if (!pos.visible) continue;
            ctx.beginPath();
            ctx.fillStyle = layer.selected ? "#ffcc00" : "#888888";
            ctx.arc(pos.x, pos.y, layer.selected ? 6 : 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "10px sans-serif";
            ctx.fillText(layer.name, pos.x + 8, pos.y + 4);
          }
        }
      });
    }
    function createDummyCamera() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: compWidth.value / 2, y: compHeight.value / 2, z: -1500 },
        pointOfInterest: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: false,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let animationId;
    function animate() {
      render();
      animationId = requestAnimationFrame(animate);
    }
    function onKeyDown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA" || document.activeElement?.tagName === "SELECT") {
        return;
      }
      const activeView = activeViews.value[activeViewIndex.value];
      switch (e.code) {
        case "Numpad1":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "back");
          } else {
            updateViewType(activeViewIndex.value, "front");
          }
          e.preventDefault();
          break;
        case "Numpad3":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "left");
          } else {
            updateViewType(activeViewIndex.value, "right");
          }
          e.preventDefault();
          break;
        case "Numpad7":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "bottom");
          } else {
            updateViewType(activeViewIndex.value, "top");
          }
          e.preventDefault();
          break;
        case "Numpad0":
          updateViewType(activeViewIndex.value, "active-camera");
          e.preventDefault();
          break;
        case "Numpad5":
          if (!isCustomView(activeView)) {
            const targetView = "custom-1";
            let theta = 0;
            let phi = 90;
            switch (activeView) {
              case "front":
                theta = 0;
                phi = 90;
                break;
              case "back":
                theta = 180;
                phi = 90;
                break;
              case "left":
                theta = -90;
                phi = 90;
                break;
              case "right":
                theta = 90;
                phi = 90;
                break;
              case "top":
                theta = 0;
                phi = 1;
                break;
              case "bottom":
                theta = 0;
                phi = 179;
                break;
              default:
                theta = 45;
                phi = 60;
            }
            store.updateViewportState({
              customViews: {
                ...viewportState.value.customViews,
                [targetView]: {
                  ...viewportState.value.customViews[targetView],
                  orbitTheta: theta,
                  orbitPhi: phi
                }
              }
            });
            updateViewType(activeViewIndex.value, targetView);
          } else {
            const theta = customViews.value[activeView].orbitTheta % 360;
            const phi = customViews.value[activeView].orbitPhi;
            let closestView = "front";
            if (phi < 30) {
              closestView = "top";
            } else if (phi > 150) {
              closestView = "bottom";
            } else {
              const normalizedTheta = (theta % 360 + 360) % 360;
              if (normalizedTheta >= 315 || normalizedTheta < 45) {
                closestView = "front";
              } else if (normalizedTheta >= 45 && normalizedTheta < 135) {
                closestView = "right";
              } else if (normalizedTheta >= 135 && normalizedTheta < 225) {
                closestView = "back";
              } else {
                closestView = "left";
              }
            }
            updateViewType(activeViewIndex.value, closestView);
          }
          e.preventDefault();
          break;
        case "NumpadDecimal":
        case "Period":
          focusOnSelectedLayer();
          e.preventDefault();
          break;
        case "Home":
          if (isCustomView(activeView)) {
            resetCustomView(activeView);
          }
          e.preventDefault();
          break;
        case "KeyG":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showGrid: !viewOptions.value.showGrid
            });
            e.preventDefault();
          }
          break;
        case "KeyH":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showLayerHandles: !viewOptions.value.showLayerHandles
            });
            e.preventDefault();
          }
          break;
        case "KeyC":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            store.updateViewOptions({
              showCompositionBounds: !viewOptions.value.showCompositionBounds
            });
            e.preventDefault();
          }
          break;
        case "KeyA":
          if (!e.ctrlKey && !e.metaKey && e.shiftKey) {
            store.updateViewOptions({
              show3DReferenceAxes: !viewOptions.value.show3DReferenceAxes
            });
            e.preventDefault();
          }
          break;
      }
    }
    function focusOnSelectedLayer() {
      const selectedLayer = store.layers.find((l) => store.selectedLayerIds.includes(l.id));
      if (!selectedLayer) return;
      const pos = selectedLayer.transform.position.value;
      const width = 100;
      const height = 100;
      const activeView = activeViews.value[activeViewIndex.value];
      if (isCustomView(activeView)) {
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [activeView]: {
              ...customViews.value[activeView],
              orbitCenter: { x: pos.x + width / 2, y: pos.y + height / 2, z: 0 },
              orbitDistance: Math.max(width, height) * 3
              // Zoom to fit
            }
          }
        });
      }
    }
    onMounted(() => {
      animate();
      window.addEventListener("keydown", onKeyDown);
    });
    onUnmounted(() => {
      cancelAnimationFrame(animationId);
      window.removeEventListener("keydown", onKeyDown);
    });
    watch([camera, viewportState, viewOptions, layers], () => {
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["viewport-renderer", [`layout-${layout.value}`]])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(activeViews.value, (viewType, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass(["view-panel", { active: index === activeViewIndex.value }]),
            onClick: ($event) => setActiveView(index)
          }, [
            createBaseVNode("div", _hoisted_2$j, [
              createBaseVNode("select", {
                value: viewType,
                onChange: ($event) => updateViewType(index, $event.target.value),
                class: "view-select"
              }, [..._cache[1] || (_cache[1] = [
                createStaticVNode('<option value="active-camera" data-v-6a91f63d>Active Camera</option><option value="custom-1" data-v-6a91f63d>Custom View 1</option><option value="custom-2" data-v-6a91f63d>Custom View 2</option><option value="custom-3" data-v-6a91f63d>Custom View 3</option><option value="front" data-v-6a91f63d>Front</option><option value="back" data-v-6a91f63d>Back</option><option value="left" data-v-6a91f63d>Left</option><option value="right" data-v-6a91f63d>Right</option><option value="top" data-v-6a91f63d>Top</option><option value="bottom" data-v-6a91f63d>Bottom</option>', 10)
              ])], 40, _hoisted_3$j),
              createBaseVNode("div", _hoisted_4$j, [
                isCustomView(viewType) ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: withModifiers(($event) => resetCustomView(viewType), ["stop"]),
                  title: "Reset View"
                }, [..._cache[2] || (_cache[2] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])], 8, _hoisted_5$j)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("canvas", {
              ref_for: true,
              ref: (el) => setCanvasRef(el, index),
              class: "view-canvas",
              onMousedown: ($event) => onCanvasMouseDown($event, index),
              onWheel: ($event) => onCanvasWheel($event, index),
              onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, null, 40, _hoisted_6$j),
            createBaseVNode("div", _hoisted_7$j, [
              createBaseVNode("span", _hoisted_8$i, toDisplayString(getViewDisplayName(viewType)), 1),
              isCustomView(viewType) ? (openBlock(), createElementBlock("span", _hoisted_9$i, " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitTheta ?? 0)) + " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitPhi ?? 0)) + " ", 1)) : createCommentVNode("", true)
            ])
          ], 10, _hoisted_1$j);
        }), 128)),
        createBaseVNode("div", _hoisted_10$h, [
          (openBlock(), createElementBlock(Fragment, null, renderList(layoutOptions, (layoutOption) => {
            return createBaseVNode("button", {
              key: layoutOption.value,
              class: normalizeClass({ active: layout.value === layoutOption.value }),
              onClick: ($event) => setLayout(layoutOption.value),
              title: layoutOption.label
            }, toDisplayString(layoutOption.icon), 11, _hoisted_11$g);
          }), 64))
        ])
      ], 2);
    };
  }
});

const ViewportRenderer = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-6a91f63d"]]);

class SceneManager {
  /** The main Three.js scene */
  scene;
  /** Group for composition layers (rendered content) */
  compositionGroup;
  /** Group for UI overlay elements */
  overlayGroup;
  /** Group for debug helpers */
  debugGroup;
  /** Environment map texture */
  environmentMap = null;
  /** Environment map configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true,
    toneMapping: true
  };
  /** PMREM Generator for environment maps */
  pmremGenerator = null;
  /** HDRI loaders */
  rgbeLoader = null;
  exrLoader = null;
  /** Composition bounds frame */
  compositionBounds = null;
  /** Composition grid helper */
  compositionGrid = null;
  /** Dark overlay outside composition */
  outsideOverlay = null;
  /** Composition dimensions */
  compositionWidth = 1920;
  compositionHeight = 1080;
  /** O(1) layer lookup map - optimization for frequent ID-based lookups */
  layerLookupMap = /* @__PURE__ */ new Map();
  /** Track Z positions to avoid unnecessary sorting */
  zPositionCache = /* @__PURE__ */ new Map();
  needsZSort = false;
  constructor(backgroundColor = null) {
    this.scene = new Scene();
    this.scene.name = "WeylScene";
    if (backgroundColor) {
      this.scene.background = new Color(backgroundColor);
    } else {
      this.scene.background = null;
    }
    this.compositionGroup = new Group();
    this.compositionGroup.name = "composition";
    this.scene.add(this.compositionGroup);
    this.overlayGroup = new Group();
    this.overlayGroup.name = "overlay";
    this.overlayGroup.renderOrder = 1e3;
    this.scene.add(this.overlayGroup);
    this.debugGroup = new Group();
    this.debugGroup.name = "debug";
    this.debugGroup.visible = false;
    this.scene.add(this.debugGroup);
    this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const ambient = new AmbientLight(16777215, 0.6);
    ambient.name = "ambientLight";
    this.scene.add(ambient);
    const keyLight = new DirectionalLight(16777215, 0.8);
    keyLight.name = "keyLight";
    keyLight.position.set(1e3, -1e3, 2e3);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    this.scene.add(keyLight);
    const fillLight = new DirectionalLight(16777215, 0.3);
    fillLight.name = "fillLight";
    fillLight.position.set(-500, 500, 1e3);
    this.scene.add(fillLight);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(object) {
    this.compositionGroup.add(object);
    this.markNeedsZSort();
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.set(layerId, object);
    }
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(object) {
    this.compositionGroup.remove(object);
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.delete(layerId);
    }
    this.zPositionCache.delete(object);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let hasChanges = false;
      for (const child of this.compositionGroup.children) {
        const cachedZ = this.zPositionCache.get(child);
        const currentZ = child.position.z || 0;
        if (cachedZ === void 0 || cachedZ !== currentZ) {
          hasChanges = true;
          break;
        }
      }
      if (!hasChanges) {
        return;
      }
    }
    this.compositionGroup.children.sort((a, b) => {
      return (a.position.z || 0) - (b.position.z || 0);
    });
    for (const child of this.compositionGroup.children) {
      this.zPositionCache.set(child, child.position.z || 0);
    }
    this.needsZSort = false;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = true;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(object) {
    this.overlayGroup.add(object);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(object) {
    this.overlayGroup.remove(object);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    while (this.overlayGroup.children.length > 0) {
      const child = this.overlayGroup.children[0];
      this.overlayGroup.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(object) {
    this.scene.add(object);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(object) {
    this.scene.remove(object);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(visible) {
    this.debugGroup.visible = visible;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(size = 500) {
    const existing = this.debugGroup.getObjectByName("axisHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new AxesHelper(size);
    helper.name = "axisHelper";
    this.debugGroup.add(helper);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(size = 2e3, divisions = 40) {
    const existing = this.debugGroup.getObjectByName("gridHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new GridHelper(size, divisions, 4473924, 2236962);
    helper.name = "gridHelper";
    helper.rotation.x = Math.PI / 2;
    this.debugGroup.add(helper);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(color) {
    if (color) {
      this.scene.background = new Color(color);
    } else {
      this.scene.background = null;
    }
  }
  /**
   * Get current background color
   */
  getBackground() {
    if (this.scene.background instanceof Color) {
      return "#" + this.scene.background.getHexString();
    }
    return null;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize PMREM generator (requires WebGL renderer)
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport(renderer) {
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
    }
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Load and set an environment map from URL (HDR, EXR, or standard image)
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    if (!this.pmremGenerator) {
      throw new Error("Environment support not initialized. Call initializeEnvironmentSupport() first.");
    }
    if (config) {
      Object.assign(this.envConfig, config);
    }
    this.envConfig.url = url;
    this.envConfig.enabled = true;
    const isHDR = url.toLowerCase().endsWith(".hdr");
    const isEXR = url.toLowerCase().endsWith(".exr");
    return new Promise((resolve, reject) => {
      if (isHDR) {
        if (!this.rgbeLoader) {
          this.rgbeLoader = new RGBELoader();
        }
        this.rgbeLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else if (isEXR) {
        if (!this.exrLoader) {
          this.exrLoader = new EXRLoader();
        }
        this.exrLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else {
        const loader = new TextureLoader();
        loader.load(
          url,
          (texture) => {
            texture.mapping = EquirectangularReflectionMapping;
            this.processEnvironmentTexture(texture, resolve);
          },
          void 0,
          reject
        );
      }
    });
  }
  /**
   * Process loaded environment texture
   */
  processEnvironmentTexture(texture, resolve) {
    const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
    texture.dispose();
    this.setEnvironmentMapTexture(envMap);
    resolve(envMap);
  }
  /**
   * Set environment map from pre-loaded texture
   */
  setEnvironmentMapTexture(texture) {
    if (this.environmentMap && this.environmentMap !== texture) {
      this.environmentMap.dispose();
    }
    this.environmentMap = texture;
    if (texture && this.envConfig.enabled) {
      this.scene.environment = texture;
      if (this.envConfig.useAsBackground) {
        this.scene.background = texture;
        this.scene.backgroundIntensity = this.envConfig.intensity;
        this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
        this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
      }
      this.scene.environmentIntensity = this.envConfig.intensity;
      this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
    } else {
      this.scene.environment = null;
      if (this.envConfig.useAsBackground) {
        this.scene.background = null;
      }
    }
  }
  /**
   * Update environment map configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (this.environmentMap) {
      if (this.envConfig.enabled) {
        this.scene.environment = this.environmentMap;
        this.scene.environmentIntensity = this.envConfig.intensity;
        this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
        if (this.envConfig.useAsBackground) {
          this.scene.background = this.environmentMap;
          this.scene.backgroundIntensity = this.envConfig.intensity;
          this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
          this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
        }
      } else {
        this.scene.environment = null;
        if (this.envConfig.useAsBackground) {
          this.scene.background = null;
        }
      }
    }
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Get current environment map texture
   */
  getEnvironmentMap() {
    return this.environmentMap;
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.setEnvironmentConfig({ enabled });
  }
  /**
   * Set environment intensity
   */
  setEnvironmentIntensity(intensity) {
    this.setEnvironmentConfig({ intensity });
  }
  /**
   * Set environment rotation (degrees)
   */
  setEnvironmentRotation(rotation) {
    this.setEnvironmentConfig({ rotation });
  }
  /**
   * Set background blur amount (0-1)
   */
  setBackgroundBlur(blur) {
    this.setEnvironmentConfig({ backgroundBlur: blur });
  }
  /**
   * Toggle using HDRI as background
   */
  setUseAsBackground(use) {
    this.setEnvironmentConfig({ useAsBackground: use });
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(width, height) {
    this.compositionWidth = width;
    this.compositionHeight = height;
    this.updateCompositionBounds();
    this.updateCompositionGrid();
    this.updateOutsideOverlay();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    if (this.compositionBounds) {
      this.overlayGroup.remove(this.compositionBounds);
      this.compositionBounds.geometry.dispose();
      this.compositionBounds.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const points = [
      new Vector3(0, 0, 0),
      new Vector3(w, 0, 0),
      new Vector3(w, -h, 0),
      new Vector3(0, -h, 0)
    ];
    const geometry = new BufferGeometry().setFromPoints(points);
    const material = new LineBasicMaterial({
      color: 4886745,
      linewidth: 2,
      depthTest: false
    });
    this.compositionBounds = new LineLoop(geometry, material);
    this.compositionBounds.name = "compositionBounds";
    this.compositionBounds.renderOrder = 998;
    this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(visible) {
    if (this.compositionBounds) {
      this.compositionBounds.visible = visible;
    }
  }
  /**
   * Create or update composition grid
   * Shows a grid inside the composition area for spatial reference
   */
  updateCompositionGrid(divisions = 20) {
    try {
      if (this.compositionGrid) {
        this.overlayGroup.remove(this.compositionGrid);
        this.compositionGrid.traverse((obj) => {
          if (obj instanceof Line) {
            obj.geometry.dispose();
            obj.material.dispose();
          }
        });
      }
      const w = this.compositionWidth;
      const h = this.compositionHeight;
      const gridGroup = new Group();
      gridGroup.name = "compositionGrid";
      const material = new LineBasicMaterial({
        color: 3355443,
        transparent: true,
        opacity: 0.5,
        depthTest: false
      });
      const stepX = w / divisions;
      for (let i = 0; i <= divisions; i++) {
        const x = i * stepX;
        const points = [
          new Vector3(x, 0, 0),
          new Vector3(x, -h, 0)
        ];
        const geometry = new BufferGeometry().setFromPoints(points);
        const line = new Line(geometry, material.clone());
        gridGroup.add(line);
      }
      const stepY = h / divisions;
      for (let i = 0; i <= divisions; i++) {
        const y = -i * stepY;
        const points = [
          new Vector3(0, y, 0),
          new Vector3(w, y, 0)
        ];
        const geometry = new BufferGeometry().setFromPoints(points);
        const line = new Line(geometry, material.clone());
        gridGroup.add(line);
      }
      const centerX = w / 2;
      const centerY = -h / 2;
      const axisLength = Math.min(w, h) / 4;
      const xAxisMaterial = new LineBasicMaterial({
        color: 16729156,
        transparent: true,
        opacity: 0.9,
        depthTest: false,
        linewidth: 2
      });
      const xAxisPoints = [
        new Vector3(centerX, centerY, 0),
        new Vector3(centerX + axisLength, centerY, 0)
      ];
      const xAxisGeom = new BufferGeometry().setFromPoints(xAxisPoints);
      gridGroup.add(new Line(xAxisGeom, xAxisMaterial));
      const yAxisMaterial = new LineBasicMaterial({
        color: 4521796,
        transparent: true,
        opacity: 0.9,
        depthTest: false,
        linewidth: 2
      });
      const yAxisPoints = [
        new Vector3(centerX, centerY, 0),
        new Vector3(centerX, centerY + axisLength, 0)
      ];
      const yAxisGeom = new BufferGeometry().setFromPoints(yAxisPoints);
      gridGroup.add(new Line(yAxisGeom, yAxisMaterial));
      const zAxisMaterial = new LineBasicMaterial({
        color: 4474111,
        transparent: true,
        opacity: 0.9,
        depthTest: false,
        linewidth: 2
      });
      const zAxisPoints = [
        new Vector3(centerX, centerY, 0),
        new Vector3(centerX, centerY, axisLength)
      ];
      const zAxisGeom = new BufferGeometry().setFromPoints(zAxisPoints);
      gridGroup.add(new Line(zAxisGeom, zAxisMaterial));
      try {
        const originMarkerGeom = new SphereGeometry(4, 8, 8);
        const originMarkerMat = new MeshBasicMaterial({
          color: 16777215,
          transparent: true,
          opacity: 0.8,
          depthTest: false
        });
        const originMarker = new Mesh(originMarkerGeom, originMarkerMat);
        originMarker.position.set(centerX, centerY, 0);
        originMarker.renderOrder = 998;
        gridGroup.add(originMarker);
      } catch (meshError) {
        console.warn("[SceneManager] Could not create origin marker mesh, using crosshair fallback");
        const crossSize = 8;
        const crossMat = new LineBasicMaterial({ color: 16777215, depthTest: false });
        const crossH = new BufferGeometry().setFromPoints([
          new Vector3(centerX - crossSize, centerY, 0),
          new Vector3(centerX + crossSize, centerY, 0)
        ]);
        const crossV = new BufferGeometry().setFromPoints([
          new Vector3(centerX, centerY - crossSize, 0),
          new Vector3(centerX, centerY + crossSize, 0)
        ]);
        gridGroup.add(new Line(crossH, crossMat));
        gridGroup.add(new Line(crossV, crossMat.clone()));
      }
      const centerMaterial = new LineBasicMaterial({
        color: 5592405,
        transparent: true,
        opacity: 0.5,
        depthTest: false
      });
      const vCenterPoints = [
        new Vector3(centerX, 0, 0),
        new Vector3(centerX, -h, 0)
      ];
      const vCenterGeom = new BufferGeometry().setFromPoints(vCenterPoints);
      gridGroup.add(new Line(vCenterGeom, centerMaterial));
      const hCenterPoints = [
        new Vector3(0, centerY, 0),
        new Vector3(w, centerY, 0)
      ];
      const hCenterGeom = new BufferGeometry().setFromPoints(hCenterPoints);
      gridGroup.add(new Line(hCenterGeom, centerMaterial.clone()));
      gridGroup.renderOrder = 997;
      this.compositionGrid = gridGroup;
      this.overlayGroup.add(gridGroup);
    } catch (error) {
      console.warn("[SceneManager] Failed to create composition grid:", error);
    }
  }
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    if (this.compositionGrid) {
      this.compositionGrid.visible = visible;
    }
  }
  /**
   * Create dark overlay outside composition bounds
   * Creates a large plane with a rectangular hole for the composition area
   */
  updateOutsideOverlay() {
    try {
      if (this.outsideOverlay) {
        this.overlayGroup.remove(this.outsideOverlay);
        this.outsideOverlay.geometry.dispose();
        this.outsideOverlay.material.dispose();
      }
      const w = this.compositionWidth;
      const h = this.compositionHeight;
      const size = Math.max(w, h) * 10;
      const outer = new Shape();
      outer.moveTo(-size, size);
      outer.lineTo(size + w, size);
      outer.lineTo(size + w, -size - h);
      outer.lineTo(-size, -size - h);
      outer.lineTo(-size, size);
      const hole = new Path$1();
      hole.moveTo(0, 0);
      hole.lineTo(0, -h);
      hole.lineTo(w, -h);
      hole.lineTo(w, 0);
      hole.lineTo(0, 0);
      outer.holes.push(hole);
      const geometry = new ShapeGeometry(outer);
      const material = new MeshBasicMaterial({
        color: 0,
        transparent: true,
        opacity: 0.6,
        side: DoubleSide,
        depthTest: false
      });
      this.outsideOverlay = new Mesh(geometry, material);
      this.outsideOverlay.name = "outsideOverlay";
      this.outsideOverlay.position.z = -2;
      this.outsideOverlay.renderOrder = 996;
      this.overlayGroup.add(this.outsideOverlay);
    } catch (error) {
      console.warn("[SceneManager] Failed to create outside overlay:", error);
    }
  }
  /**
   * Show/hide outside overlay
   */
  setOutsideOverlayVisible(visible) {
    if (this.outsideOverlay) {
      this.outsideOverlay.visible = visible;
    }
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(raycaster) {
    return raycaster.intersectObjects(this.compositionGroup.children, true);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(layerId) {
    return this.layerLookupMap.get(layerId) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(object) {
    if (object instanceof Mesh) {
      object.geometry?.dispose();
      if (Array.isArray(object.material)) {
        object.material.forEach((m) => {
          this.disposeMaterial(m);
        });
      } else if (object.material) {
        this.disposeMaterial(object.material);
      }
    }
    while (object.children.length > 0) {
      const child = object.children[0];
      object.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(material) {
    const mat = material;
    mat.map?.dispose();
    mat.normalMap?.dispose();
    mat.roughnessMap?.dispose();
    mat.metalnessMap?.dispose();
    mat.aoMap?.dispose();
    mat.emissiveMap?.dispose();
    mat.alphaMap?.dispose();
    mat.envMap?.dispose();
    material.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    while (this.compositionGroup.children.length > 0) {
      const child = this.compositionGroup.children[0];
      this.compositionGroup.remove(child);
      this.disposeObject(child);
    }
    this.layerLookupMap.clear();
    this.zPositionCache.clear();
    this.clearOverlay();
    while (this.debugGroup.children.length > 0) {
      const child = this.debugGroup.children[0];
      this.debugGroup.remove(child);
      this.disposeObject(child);
    }
    if (this.environmentMap) {
      this.environmentMap.dispose();
      this.environmentMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
    this.scene.clear();
  }
}

class RenderPipeline {
  renderer;
  composer;
  scene;
  camera;
  // Render targets
  colorTarget;
  depthTarget;
  // Frame capture
  captureCanvas;
  captureCtx;
  // Depth capture material
  depthMaterial;
  // Normal material for normal pass
  normalMaterial;
  // Dimensions
  width;
  height;
  pixelRatio;
  // Render mode
  renderMode = "color";
  // DOF pass
  bokehPass = null;
  dofConfig = {
    enabled: false,
    focusDistance: 500,
    aperture: 0.025,
    maxBlur: 0.01
  };
  // SSAO pass
  ssaoPass = null;
  ssaoConfig = {
    enabled: false,
    kernelRadius: 8,
    minDistance: 5e-3,
    maxDistance: 0.1,
    intensity: 1,
    output: "default"
  };
  // Bloom pass (for emissive objects and lights)
  bloomPass = null;
  bloomConfig = {
    enabled: false,
    strength: 1.5,
    radius: 0.4,
    threshold: 0.85
  };
  // Motion blur processor (canvas-based, applied post-render)
  motionBlurProcessor;
  motionBlurConfig = {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  };
  previousFrameTransform = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1
  };
  constructor(config, scene, camera) {
    this.scene = scene;
    this.camera = camera;
    this.width = config.width;
    this.height = config.height;
    this.pixelRatio = config.pixelRatio ?? Math.min(window.devicePixelRatio, 2);
    this.renderer = new WebGLRenderer({
      canvas: config.canvas,
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      preserveDrawingBuffer: true,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: false,
      depth: true
    });
    this.renderer.setPixelRatio(this.pixelRatio);
    this.renderer.setSize(this.width, this.height);
    try {
      this.renderer.outputColorSpace = SRGBColorSpace;
      this.renderer.toneMapping = ACESFilmicToneMapping;
      this.renderer.toneMappingExposure = 1;
    } catch (e) {
      console.warn("[RenderPipeline] Could not set color space/tone mapping:", e);
      try {
        this.renderer.toneMappingExposure = 1;
      } catch {
      }
    }
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer = new EffectComposer(this.renderer, this.colorTarget);
    this.setupDefaultPasses();
    this.captureCanvas = new OffscreenCanvas(scaledWidth, scaledHeight);
    this.captureCtx = this.captureCanvas.getContext("2d");
    this.depthMaterial = this.createDepthMaterial();
    this.normalMaterial = new MeshNormalMaterial();
    this.motionBlurProcessor = new MotionBlurProcessor(scaledWidth, scaledHeight);
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      type: HalfFloatType,
      colorSpace: SRGBColorSpace,
      depthBuffer: true,
      stencilBuffer: false,
      samples: 4
      // MSAA
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = UnsignedIntType;
    return target;
  }
  createDepthTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      depthBuffer: true,
      stencilBuffer: false
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = FloatType;
    return target;
  }
  createDepthMaterial() {
    return new ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: false,
      depthTest: false
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const renderPass = new RenderPass(this.scene.scene, this.camera.camera);
    this.composer.addPass(renderPass);
    const outputPass = new OutputPass();
    this.composer.addPass(outputPass);
  }
  /**
   * Add a post-processing pass
   */
  addPass(pass) {
    const outputIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "OutputPass"
    );
    if (outputIndex > -1) {
      this.composer.insertPass(pass, outputIndex);
    } else {
      this.composer.addPass(pass);
    }
  }
  /**
   * Remove a post-processing pass
   */
  removePass(pass) {
    this.composer.removePass(pass);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(config) {
    this.dofConfig = { ...this.dofConfig, ...config };
    if (this.dofConfig.enabled) {
      if (!this.bokehPass) {
        this.createBokehPass();
      }
      this.updateBokehPass();
    } else {
      if (this.bokehPass) {
        this.composer.removePass(this.bokehPass);
        this.bokehPass = null;
      }
    }
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    this.bokehPass = new BokehPass(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    );
    this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const uniforms = this.bokehPass.uniforms;
    if (uniforms) {
      uniforms.focus.value = this.dofConfig.focusDistance;
      uniforms.aperture.value = this.dofConfig.aperture;
      uniforms.maxblur.value = this.dofConfig.maxBlur;
    }
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(distance) {
    this.setDOF({ focusDistance: distance });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(aperture) {
    this.setDOF({ aperture });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(enabled) {
    this.setDOF({ enabled });
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   */
  setSSAO(config) {
    this.ssaoConfig = { ...this.ssaoConfig, ...config };
    if (this.ssaoConfig.enabled) {
      if (!this.ssaoPass) {
        this.createSSAOPass();
      }
      this.updateSSAOPass();
    } else {
      if (this.ssaoPass) {
        this.composer.removePass(this.ssaoPass);
        this.ssaoPass = null;
      }
    }
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return { ...this.ssaoConfig };
  }
  /**
   * Create the SSAO pass
   */
  createSSAOPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.ssaoPass = new SSAOPass(
      this.scene.scene,
      this.camera.camera,
      scaledWidth,
      scaledHeight
    );
    const renderPassIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "RenderPass"
    );
    if (renderPassIndex > -1) {
      this.composer.insertPass(this.ssaoPass, renderPassIndex + 1);
    } else {
      this.addPass(this.ssaoPass);
    }
  }
  /**
   * Update SSAO pass parameters
   */
  updateSSAOPass() {
    if (!this.ssaoPass) return;
    this.ssaoPass.kernelRadius = this.ssaoConfig.kernelRadius;
    this.ssaoPass.minDistance = this.ssaoConfig.minDistance;
    this.ssaoPass.maxDistance = this.ssaoConfig.maxDistance;
    const outputMap = {
      "default": SSAOPass.OUTPUT.Default,
      "ssao": SSAOPass.OUTPUT.SSAO,
      "blur": SSAOPass.OUTPUT.Blur,
      "depth": SSAOPass.OUTPUT.Depth,
      "normal": SSAOPass.OUTPUT.Normal
    };
    this.ssaoPass.output = outputMap[this.ssaoConfig.output];
  }
  /**
   * Enable/disable SSAO (convenience method)
   */
  setSSAOEnabled(enabled) {
    this.setSSAO({ enabled });
  }
  /**
   * Set SSAO intensity (convenience method)
   */
  setSSAOIntensity(intensity) {
    this.setSSAO({ intensity });
  }
  /**
   * Set SSAO kernel radius (convenience method)
   */
  setSSAORadius(radius) {
    this.setSSAO({ kernelRadius: radius });
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, particles) glow
   */
  setBloom(config) {
    this.bloomConfig = { ...this.bloomConfig, ...config };
    if (this.bloomConfig.enabled) {
      if (!this.bloomPass) {
        this.createBloomPass();
      }
      this.updateBloomPass();
    } else {
      if (this.bloomPass) {
        this.composer.removePass(this.bloomPass);
        this.bloomPass = null;
      }
    }
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return { ...this.bloomConfig };
  }
  /**
   * Create the bloom pass
   */
  createBloomPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.bloomPass = new UnrealBloomPass(
      new Vector2(scaledWidth, scaledHeight),
      this.bloomConfig.strength,
      this.bloomConfig.radius,
      this.bloomConfig.threshold
    );
    const ssaoIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "SSAOPass"
    );
    if (ssaoIndex > -1) {
      this.composer.insertPass(this.bloomPass, ssaoIndex + 1);
    } else {
      const renderIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "RenderPass"
      );
      if (renderIndex > -1) {
        this.composer.insertPass(this.bloomPass, renderIndex + 1);
      } else {
        this.addPass(this.bloomPass);
      }
    }
  }
  /**
   * Update bloom pass parameters
   */
  updateBloomPass() {
    if (!this.bloomPass) return;
    this.bloomPass.strength = this.bloomConfig.strength;
    this.bloomPass.radius = this.bloomConfig.radius;
    this.bloomPass.threshold = this.bloomConfig.threshold;
  }
  /**
   * Enable/disable bloom (convenience method)
   */
  setBloomEnabled(enabled) {
    this.setBloom({ enabled });
  }
  /**
   * Set bloom intensity (convenience method)
   */
  setBloomStrength(strength) {
    this.setBloom({ strength });
  }
  /**
   * Set bloom threshold (convenience method)
   */
  setBloomThreshold(threshold) {
    this.setBloom({ threshold });
  }
  // ============================================================================
  // MOTION BLUR CONFIGURATION
  // ============================================================================
  /**
   * Configure motion blur
   */
  setMotionBlur(config) {
    this.motionBlurConfig = { ...this.motionBlurConfig, ...config };
    this.motionBlurProcessor.setSettings({
      enabled: this.motionBlurConfig.enabled,
      type: this.motionBlurConfig.type,
      shutterAngle: this.motionBlurConfig.shutterAngle,
      shutterPhase: this.motionBlurConfig.shutterPhase,
      samplesPerFrame: this.motionBlurConfig.samplesPerFrame
    });
  }
  /**
   * Enable/disable motion blur
   */
  setMotionBlurEnabled(enabled) {
    this.setMotionBlur({ enabled });
  }
  /**
   * Set motion blur type
   */
  setMotionBlurType(type) {
    this.setMotionBlur({ type });
  }
  /**
   * Set shutter angle (0-720, 180 = standard film)
   */
  setMotionBlurShutterAngle(shutterAngle) {
    this.setMotionBlur({ shutterAngle });
  }
  /**
   * Apply a motion blur preset by name
   */
  setMotionBlurPreset(presetName) {
    const preset = MOTION_BLUR_PRESETS[presetName];
    if (preset) {
      this.setMotionBlur({
        enabled: true,
        type: preset.type || "standard",
        shutterAngle: preset.shutterAngle || 180,
        shutterPhase: preset.shutterPhase || -90,
        samplesPerFrame: preset.samplesPerFrame || 16,
        preset: presetName
      });
    }
  }
  /**
   * Get current motion blur configuration
   */
  getMotionBlurConfig() {
    return { ...this.motionBlurConfig };
  }
  /**
   * Get the motion blur processor (for advanced use)
   */
  getMotionBlurProcessor() {
    return this.motionBlurProcessor;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ();
    this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.render(this.scene.scene, this.camera.camera);
    this.renderer.setRenderTarget(prevTarget);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  // Depth visualization pass for post-processing
  depthVisualizationPass = null;
  // Normal visualization pass for post-processing
  normalVisualizationPass = null;
  /**
   * Set the render mode (color, depth, normal)
   * Uses post-processing to visualize depth/normals from the depth buffer
   * This works with ALL geometry including text since it reads from the depth buffer
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    if (this.depthVisualizationPass) {
      this.composer.removePass(this.depthVisualizationPass);
      this.depthVisualizationPass = null;
    }
    if (this.normalVisualizationPass) {
      this.composer.removePass(this.normalVisualizationPass);
      this.normalVisualizationPass = null;
    }
    this.scene.scene.overrideMaterial = null;
    if (mode === "depth") {
      this.depthVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          varying vec2 vUv;

          float readDepth(sampler2D depthSampler, vec2 coord) {
            float fragCoordZ = texture2D(depthSampler, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          void main() {
            float depth = readDepth(tDepth, vUv);
            // White = close, Black = far (standard depth map convention for AI video)
            gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.depthVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.depthVisualizationPass);
      }
    } else if (mode === "normal") {
      const scaledWidth = Math.floor(this.width * this.pixelRatio);
      const scaledHeight = Math.floor(this.height * this.pixelRatio);
      this.normalVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far },
          resolution: { value: new Vector2(scaledWidth, scaledHeight) },
          cameraProjectionMatrix: { value: this.camera.camera.projectionMatrix },
          cameraProjectionMatrixInverse: { value: this.camera.camera.projectionMatrixInverse }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          uniform vec2 resolution;
          uniform mat4 cameraProjectionMatrix;
          uniform mat4 cameraProjectionMatrixInverse;
          varying vec2 vUv;

          // Convert depth buffer value to linear depth
          float getLinearDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          // Reconstruct view-space position from depth
          vec3 getViewPosition(vec2 coord, float depth) {
            vec4 clipPos = vec4(coord * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
            vec4 viewPos = cameraProjectionMatrixInverse * clipPos;
            return viewPos.xyz / viewPos.w;
          }

          void main() {
            // Sample depth at current pixel and neighbors
            vec2 texelSize = 1.0 / resolution;

            float depthC = getLinearDepth(vUv);
            float depthL = getLinearDepth(vUv - vec2(texelSize.x, 0.0));
            float depthR = getLinearDepth(vUv + vec2(texelSize.x, 0.0));
            float depthU = getLinearDepth(vUv + vec2(0.0, texelSize.y));
            float depthD = getLinearDepth(vUv - vec2(0.0, texelSize.y));

            // Handle edges and background (depth = 1.0)
            if (depthC > 0.999) {
              gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0); // Default normal pointing at camera
              return;
            }

            // Reconstruct view-space positions
            vec3 posC = getViewPosition(vUv, depthC);
            vec3 posL = getViewPosition(vUv - vec2(texelSize.x, 0.0), depthL);
            vec3 posR = getViewPosition(vUv + vec2(texelSize.x, 0.0), depthR);
            vec3 posU = getViewPosition(vUv + vec2(0.0, texelSize.y), depthU);
            vec3 posD = getViewPosition(vUv - vec2(0.0, texelSize.y), depthD);

            // Calculate screen-space derivatives
            // Use the neighbor with smaller depth difference to reduce artifacts at edges
            vec3 ddx = abs(depthR - depthC) < abs(depthC - depthL) ? posR - posC : posC - posL;
            vec3 ddy = abs(depthU - depthC) < abs(depthC - depthD) ? posU - posC : posC - posD;

            // Calculate normal from cross product
            vec3 normal = normalize(cross(ddx, ddy));

            // Flip normal to face camera if needed
            if (normal.z < 0.0) normal = -normal;

            // Convert from view-space normal (-1 to 1) to color (0 to 1)
            // Standard normal map convention: RGB = (normal + 1) / 2
            gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.normalVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.normalVisualizationPass);
      }
    }
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    const buffer = new Uint8Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const flipped = new Uint8ClampedArray(buffer.length);
    const rowSize = width * 4;
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * rowSize;
      const dstRow = y * rowSize;
      flipped.set(buffer.subarray(srcRow, srcRow + rowSize), dstRow);
    }
    return new ImageData(flipped, width, height);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const buffer = new Float32Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const depth = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      depth[i] = buffer[i * 4];
    }
    const flipped = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width;
      const dstRow = y * width;
      flipped.set(depth.subarray(srcRow, srcRow + width), dstRow);
    }
    return flipped;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(width, height) {
    this.width = width;
    this.height = height;
    const scaledWidth = Math.floor(width * this.pixelRatio);
    const scaledHeight = Math.floor(height * this.pixelRatio);
    this.renderer.setSize(width, height);
    this.composer.setSize(scaledWidth, scaledHeight);
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer.renderTarget1.dispose();
    this.composer.renderTarget2.dispose();
    this.composer.renderTarget1 = this.colorTarget.clone();
    this.composer.renderTarget2 = this.colorTarget.clone();
    this.captureCanvas.width = scaledWidth;
    this.captureCanvas.height = scaledHeight;
    if (this.bokehPass && this.dofConfig.enabled) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
      this.createBokehPass();
    }
    if (this.ssaoPass && this.ssaoConfig.enabled) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
      this.createSSAOPass();
      this.updateSSAOPass();
    }
    if (this.bloomPass && this.bloomConfig.enabled) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
      this.createBloomPass();
      this.updateBloomPass();
    }
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // NESTED COMPOSITION RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of render targets for nested compositions (keyed by compositionId) */
  nestedCompTargets = /* @__PURE__ */ new Map();
  /**
   * Create or get a render target for a nested composition
   */
  getNestedCompRenderTarget(compositionId, width, height) {
    const key = `${compositionId}_${width}_${height}`;
    let target = this.nestedCompTargets.get(key);
    if (!target) {
      target = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        type: UnsignedByteType,
        colorSpace: SRGBColorSpace,
        depthBuffer: true,
        stencilBuffer: false
      });
      this.nestedCompTargets.set(key, target);
    }
    return target;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for nested composition rendering
   */
  renderSceneToTexture(scene, camera, target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.clear();
    this.renderer.render(scene, camera);
    this.renderer.setRenderTarget(prevTarget);
    return target.texture;
  }
  /**
   * Dispose a nested composition render target
   */
  disposeNestedCompTarget(compositionId) {
    for (const [key, target] of this.nestedCompTargets.entries()) {
      if (key.startsWith(compositionId + "_")) {
        target.dispose();
        this.nestedCompTargets.delete(key);
      }
    }
  }
  /**
   * Dispose all nested composition render targets
   */
  disposeAllNestedCompTargets() {
    for (const target of this.nestedCompTargets.values()) {
      target.dispose();
    }
    this.nestedCompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    if (this.bokehPass) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
    }
    if (this.ssaoPass) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
    }
    if (this.bloomPass) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
    }
    this.disposeAllNestedCompTargets();
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.depthMaterial.dispose();
    this.normalMaterial.dispose();
    this.composer.dispose();
    this.renderer.dispose();
  }
}

class ImageLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  texture = null;
  /** Resource manager for texture loading */
  resources;
  /** Image dimensions */
  imageWidth = 100;
  imageHeight = 100;
  /** Source URL or asset ID */
  sourceUrl = null;
  /** Original (unprocessed) texture for effects source */
  originalTexture = null;
  /** Canvas for rendering texture to 2D for effect processing */
  textureCanvas = null;
  textureCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `image_${this.id}`;
    this.group.add(this.mesh);
    const imageData = this.extractImageData(layerData);
    if (imageData.source) {
      this.loadImage(imageData.source);
    }
    this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(layerData) {
    const data = layerData.data;
    return {
      source: data?.source ?? data?.url ?? data?.assetId ?? null,
      width: data?.width ?? 100,
      height: data?.height ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(url) {
    this.sourceUrl = url;
    try {
      const texture = await this.resources.loadTexture(url, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      });
      this.setTexture(texture);
    } catch (error) {
      layerLogger.error(`ImageLayer: Failed to load image: ${url}`, error);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(texture) {
    this.texture = texture;
    this.originalTexture = texture;
    this.material.map = texture;
    this.material.needsUpdate = true;
    if (texture.image) {
      this.imageWidth = texture.image.width || texture.image.videoWidth || 100;
      this.imageHeight = texture.image.height || texture.image.videoHeight || 100;
      this.updateMeshSize();
      this.textureCanvas = null;
      this.textureCanvasCtx = null;
      this.effectsDirty = true;
    }
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(imageData) {
    const texture = this.resources.createTextureFromImageData(
      imageData,
      `layer_${this.id}_imagedata`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(canvas) {
    const texture = this.resources.createTextureFromCanvas(
      canvas,
      `layer_${this.id}_canvas`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(this.imageWidth, this.imageHeight);
    this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(width, height) {
    this.imageWidth = width;
    this.imageHeight = height;
    this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(color) {
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215);
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.originalTexture?.image) {
      return null;
    }
    const image = this.originalTexture.image;
    if (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.width = this.imageWidth;
      this.textureCanvas.height = this.imageHeight;
      this.textureCanvasCtx = this.textureCanvas.getContext("2d");
    }
    if (!this.textureCanvasCtx) {
      return null;
    }
    this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight);
    this.textureCanvasCtx.drawImage(image, 0, 0, this.imageWidth, this.imageHeight);
    return this.textureCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.texture = processedTexture;
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    this.evaluateEffects(frame);
  }
  onApplyEvaluatedState(state) {
    if (state.properties["tint"] !== void 0) {
      this.setTint(state.properties["tint"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.source || data?.url || data?.assetId) {
      const newSource = data.source ?? data.url ?? data.assetId;
      if (newSource !== this.sourceUrl) {
        this.loadImage(newSource);
      }
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data.width ?? this.imageWidth,
        data.height ?? this.imageHeight
      );
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class SolidLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  /** Solid color */
  color;
  /** Solid dimensions */
  width;
  height;
  /** Animated color property */
  animatedColor;
  constructor(layerData) {
    super(layerData);
    const solidData = this.extractSolidData(layerData);
    this.color = solidData.color;
    this.width = solidData.width;
    this.height = solidData.height;
    this.animatedColor = solidData.animatedColor;
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new MeshBasicMaterial({
      color: this.color,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `solid_${this.id}`;
    this.group.add(this.mesh);
    this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(layerData) {
    const data = layerData.data;
    return {
      color: data?.color ?? "#808080",
      width: data?.width ?? 1920,
      height: data?.height ?? 1080,
      animatedColor: data?.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(color) {
    this.color = color;
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.animatedColor, frame);
      this.material.color.set(color);
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    if (state.properties["color"] !== void 0) {
      this.material.color.set(state.properties["color"]);
      this.material.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.color !== void 0) {
      this.setColor(data.color);
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data?.width ?? this.width,
        data?.height ?? this.height
      );
    }
    if (data?.animatedColor !== void 0) {
      this.animatedColor = data.animatedColor;
    }
    if (data === void 0 && properties.labelColor !== void 0) {
      this.setColor(properties.labelColor);
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ControlLayer extends BaseLayer {
  /** Visual indicator (crosshair) for editor visibility */
  indicator = null;
  /** Whether to show the control indicator */
  showIndicator;
  /** Indicator size */
  indicatorSize;
  constructor(layerData, showIndicator = true) {
    super(layerData);
    this.showIndicator = showIndicator;
    this.indicatorSize = 50;
    if (this.showIndicator) {
      this.createIndicator();
    }
  }
  /**
   * Create visual indicator (crosshair) for the control layer
   */
  createIndicator() {
    this.indicator = new Group();
    this.indicator.name = `control_indicator_${this.id}`;
    const size = this.indicatorSize;
    const color = 16737792;
    const material = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const hPoints = [
      new Vector3(-size / 2, 0, 0),
      new Vector3(size / 2, 0, 0)
    ];
    const hGeometry = new BufferGeometry().setFromPoints(hPoints);
    const hLine = new Line(hGeometry, material);
    this.indicator.add(hLine);
    const vPoints = [
      new Vector3(0, -size / 2, 0),
      new Vector3(0, size / 2, 0)
    ];
    const vGeometry = new BufferGeometry().setFromPoints(vPoints);
    const vLine = new Line(vGeometry, material);
    this.indicator.add(vLine);
    if (this.threeD) {
      const zPoints = [
        new Vector3(0, 0, -size / 2),
        new Vector3(0, 0, size / 2)
      ];
      const zGeometry = new BufferGeometry().setFromPoints(zPoints);
      const zLine = new Line(zGeometry, material);
      this.indicator.add(zLine);
    }
    const centerGeometry = new CircleGeometry(3, 16);
    const centerMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false,
      side: DoubleSide
    });
    const centerPoint = new Mesh(centerGeometry, centerMaterial);
    this.indicator.add(centerPoint);
    this.group.add(this.indicator);
    this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(visible) {
    if (this.indicator) {
      this.indicator.visible = visible;
    }
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(size) {
    if (size === this.indicatorSize) return;
    this.indicatorSize = size;
    if (this.indicator) {
      this.group.remove(this.indicator);
      this.disposeIndicator();
      this.createIndicator();
    }
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    if (!this.indicator) return;
    this.indicator.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
      if (child instanceof Mesh) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.indicator.clear();
    this.indicator = null;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(_frame) {
  }
  onApplyEvaluatedState(_state) {
  }
  onUpdate(properties) {
    if (properties.threeD !== void 0 && properties.threeD !== this.threeD) {
      this.threeD = properties.threeD;
      if (this.indicator && this.showIndicator) {
        this.group.remove(this.indicator);
        this.disposeIndicator();
        this.createIndicator();
      }
    }
  }
  onDispose() {
    this.disposeIndicator();
  }
}

class ArcLengthTable {
  constructor(curve, resolution = 500) {
    this.curve = curve;
    this.build(resolution);
  }
  entries = [];
  totalLength = 0;
  build(resolution) {
    this.entries = [];
    let accumulatedLength = 0;
    let prevPoint = this.curve.getPointAt(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.getPointAt(t);
      const tangent = this.curve.getTangentAt(t);
      if (i > 0) {
        accumulatedLength += point.distanceTo(prevPoint);
      }
      this.entries.push({
        t,
        distance: accumulatedLength,
        position: point.clone(),
        tangent: tangent.clone().normalize()
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.entries.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.entries[mid].distance < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.entries[low];
    const prevEntry = this.entries[Math.max(0, low - 1)];
    if (entry.distance === prevEntry.distance) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.distance) / (entry.distance - prevEntry.distance);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    const position = this.curve.getPointAt(t);
    const tangent = this.curve.getTangentAt(t).normalize();
    const normal = new Vector3(-tangent.y, tangent.x, 0).normalize();
    return {
      position,
      tangent,
      normal,
      t,
      distance
    };
  }
}
class TextOnPathService {
  arcLengthTable = null;
  curve = null;
  /**
   * Set the path from control points
   */
  setPath(controlPoints, closed = false) {
    if (controlPoints.length < 2) {
      this.curve = null;
      this.arcLengthTable = null;
      return;
    }
    this.curve = new CurvePath();
    for (let i = 0; i < controlPoints.length - 1; i++) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (closed && controlPoints.length > 2) {
      const lastPoint = controlPoints[controlPoints.length - 1];
      const firstPoint = controlPoints[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    this.arcLengthTable = new ArcLengthTable(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(curve) {
    this.curve = curve;
    this.arcLengthTable = new ArcLengthTable(curve);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    return this.arcLengthTable?.totalLength ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(characterWidths, config, tracking = 0, fontSize = 72) {
    if (!this.arcLengthTable || characterWidths.length === 0) {
      return [];
    }
    const totalLength = this.arcLengthTable.totalLength;
    const placements = [];
    const trackingPx = tracking / 1e3 * fontSize;
    let totalTextWidth = 0;
    for (let i = 0; i < characterWidths.length; i++) {
      totalTextWidth += characterWidths[i];
      if (i < characterWidths.length - 1) {
        totalTextWidth += trackingPx;
      }
    }
    const availableLength = totalLength - config.firstMargin - config.lastMargin;
    let startDistance;
    switch (config.align) {
      case "center":
        startDistance = config.firstMargin + (availableLength - totalTextWidth) / 2;
        break;
      case "right":
        startDistance = config.firstMargin + availableLength - totalTextWidth;
        break;
      default:
        startDistance = config.firstMargin;
    }
    const offsetDistance = config.offset / 100 * availableLength;
    startDistance += offsetDistance;
    if (config.reversed) {
      startDistance = totalLength - startDistance - totalTextWidth;
    }
    let currentDistance = startDistance;
    for (let i = 0; i < characterWidths.length; i++) {
      const charWidth = characterWidths[i];
      const charCenterDistance = currentDistance + charWidth / 2;
      let actualDistance = charCenterDistance;
      let visible = true;
      if (actualDistance < 0 || actualDistance > totalLength) {
        if (config.forceAlignment) {
          actualDistance = (actualDistance % totalLength + totalLength) % totalLength;
        } else {
          visible = actualDistance >= -charWidth && actualDistance <= totalLength + charWidth;
          actualDistance = Math.max(0, Math.min(totalLength, actualDistance));
        }
      }
      const pathPoint = this.arcLengthTable.getPointAtDistance(actualDistance);
      let rotation;
      if (config.perpendicularToPath) {
        const angle = Math.atan2(pathPoint.tangent.y, pathPoint.tangent.x);
        rotation = new Euler(0, 0, config.reversed ? angle + Math.PI : angle);
      } else {
        rotation = new Euler(0, 0, 0);
      }
      placements.push({
        index: i,
        position: pathPoint.position.clone(),
        rotation,
        scale: 1,
        pathDistance: actualDistance,
        pathT: pathPoint.t,
        visible
      });
      currentDistance += charWidth + trackingPx;
    }
    return placements;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(percent) {
    if (!this.arcLengthTable) return null;
    const distance = percent / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(distance);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(count) {
    if (!this.arcLengthTable || count < 2) return [];
    const points = [];
    const spacing = this.arcLengthTable.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.arcLengthTable.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null;
    this.arcLengthTable = null;
  }
}
function createDefaultPathConfig() {
  return {
    pathLayerId: null,
    reversed: false,
    perpendicularToPath: true,
    forceAlignment: false,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}

class TextLayer extends BaseLayer {
  resources;
  // Text rendering
  textMesh;
  perCharacterGroup = null;
  characterMeshes = [];
  // Text data from layer
  textData;
  // Animatable text properties (from layer.properties)
  fontSizeProp;
  trackingProp;
  lineSpacingProp;
  fillColorProp;
  strokeColorProp;
  strokeWidthProp;
  pathOffsetProp;
  firstMarginProp;
  lastMarginProp;
  characterOffsetProp;
  // Per-character animation
  characterTransforms;
  // Path following service
  textOnPath;
  pathConfig;
  pathControlPoints = [];
  pathClosed = false;
  // Character width cache (recalculated when text/font changes)
  characterWidths = [];
  characterWidthsDirty = true;
  // Additional evaluator for text-specific properties
  textEvaluator;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.textEvaluator = new KeyframeEvaluator();
    this.textOnPath = new TextOnPathService();
    this.pathConfig = createDefaultPathConfig();
    this.textData = this.extractTextData(layerData);
    this.extractAnimatableProperties(layerData);
    this.textMesh = this.createTextMesh();
    this.group.add(this.textMesh);
    if (this.textData.perCharacter3D || this.textData.pathLayerId) {
      this.enablePerCharacter3D();
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(layerData) {
    const data = layerData.data;
    return {
      text: data?.text ?? "Text",
      fontFamily: data?.fontFamily ?? "Impact",
      fontSize: data?.fontSize ?? 72,
      fontWeight: data?.fontWeight ?? "400",
      fontStyle: data?.fontStyle ?? "normal",
      fill: data?.fill ?? "#ffffff",
      stroke: data?.stroke ?? "",
      strokeWidth: data?.strokeWidth ?? 0,
      // Character properties
      tracking: data?.tracking ?? 0,
      lineSpacing: data?.lineSpacing ?? 0,
      lineAnchor: data?.lineAnchor ?? 50,
      characterOffset: data?.characterOffset ?? 0,
      characterValue: data?.characterValue ?? 0,
      blur: data?.blur ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: data?.letterSpacing ?? data?.tracking ?? 0,
      lineHeight: data?.lineHeight ?? data?.lineSpacing ?? 1.2,
      textAlign: data?.textAlign ?? "left",
      // Path options (full AE parity)
      pathLayerId: data?.pathLayerId ?? null,
      pathReversed: data?.pathReversed ?? false,
      pathPerpendicularToPath: data?.pathPerpendicularToPath ?? true,
      pathForceAlignment: data?.pathForceAlignment ?? false,
      pathFirstMargin: data?.pathFirstMargin ?? 0,
      pathLastMargin: data?.pathLastMargin ?? 0,
      pathOffset: data?.pathOffset ?? 0,
      pathAlign: data?.pathAlign ?? "left",
      // More Options
      anchorPointGrouping: data?.anchorPointGrouping ?? "character",
      groupingAlignment: data?.groupingAlignment ?? { x: 0, y: 0 },
      fillAndStroke: data?.fillAndStroke ?? "fill-over-stroke",
      interCharacterBlending: data?.interCharacterBlending ?? "normal",
      // 3D
      perCharacter3D: data?.perCharacter3D ?? false
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(layerData) {
    if (!layerData.properties) return;
    for (const prop of layerData.properties) {
      switch (prop.name) {
        case "Font Size":
          this.fontSizeProp = prop;
          break;
        case "Tracking":
          this.trackingProp = prop;
          break;
        case "Line Spacing":
          this.lineSpacingProp = prop;
          break;
        case "Fill Color":
          this.fillColorProp = prop;
          break;
        case "Stroke Color":
          this.strokeColorProp = prop;
          break;
        case "Stroke Width":
          this.strokeWidthProp = prop;
          break;
        case "Path Offset":
          this.pathOffsetProp = prop;
          break;
        case "First Margin":
          this.firstMarginProp = prop;
          break;
        case "Last Margin":
          this.lastMarginProp = prop;
          break;
        case "Character Offset":
          this.characterOffsetProp = prop;
          break;
      }
    }
    this.syncPathConfig();
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId;
    this.pathConfig.reversed = this.textData.pathReversed;
    this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath;
    this.pathConfig.forceAlignment = this.textData.pathForceAlignment;
    this.pathConfig.firstMargin = this.textData.pathFirstMargin;
    this.pathConfig.lastMargin = this.textData.pathLastMargin;
    this.pathConfig.offset = this.textData.pathOffset;
    this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const text = new Text();
    text.text = this.textData.text;
    text.font = this.getFontUrl(this.textData.fontFamily) ?? null;
    text.fontSize = this.textData.fontSize;
    text.fontWeight = this.textData.fontWeight || "400";
    text.fontStyle = this.textData.fontStyle || "normal";
    text.color = this.textData.fill;
    if (this.textData.stroke && this.textData.strokeWidth > 0) {
      text.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
      text.outlineColor = this.textData.stroke;
    }
    text.letterSpacing = (this.textData.tracking || 0) / 1e3;
    text.lineHeight = this.textData.lineHeight || 1.2;
    text.textAlign = this.textData.textAlign;
    text.anchorX = this.getAnchorX();
    text.anchorY = "middle";
    text.depthOffset = 0;
    text.renderOrder = 0;
    text.sdfGlyphSize = 256;
    text.gpuAccelerateSDF = true;
    if (this.textData.strokeWidth > 0) {
      text.outlineBlur = 3e-3;
    }
    text.sync();
    return text;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(fontFamily) {
    const systemFonts = [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ];
    if (systemFonts.includes(fontFamily)) {
      return void 0;
    }
    const googleFonts = {
      "Roboto": "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      "Lato": "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      "Montserrat": "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      "Oswald": "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      "Poppins": "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    };
    return googleFonts[fontFamily];
  }
  /**
   * Get anchor X based on text alignment
   * Note: Swapped to match intuitive arrow button behavior:
   * -  (left) button makes text appear on LEFT (anchor right edge)
   * -  (right) button makes text appear on RIGHT (anchor left edge)
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "right";
      case "right":
        return "left";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(controlPoints, closed = false) {
    this.pathControlPoints = controlPoints;
    this.pathClosed = closed;
    if (controlPoints.length >= 2) {
      this.textOnPath.setPath(controlPoints, closed);
      if (!this.perCharacterGroup) {
        this.enablePerCharacter3D();
      }
      this.updatePathLayout();
    } else {
      this.textOnPath.dispose();
      this.resetPathLayout();
    }
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(curve) {
    this.textOnPath.setCurve(curve);
    if (!this.perCharacterGroup) {
      this.enablePerCharacter3D();
    }
    this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null;
    this.pathConfig.pathLayerId = null;
    this.textOnPath.dispose();
    this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup) {
      return;
    }
    this.ensureCharacterWidths();
    const placements = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(placements);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(placements) {
    for (let i = 0; i < this.characterMeshes.length && i < placements.length; i++) {
      const mesh = this.characterMeshes[i];
      const placement = placements[i];
      mesh.position.copy(placement.position);
      mesh.rotation.copy(placement.rotation);
      mesh.scale.setScalar(placement.scale);
      mesh.visible = placement.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    if (this.textData.perCharacter3D) {
      this.createCharacterMeshes();
    } else {
      this.disablePerCharacter3D();
    }
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const text = this.textData.text;
    const avgCharWidth = this.textData.fontSize * 0.6;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (`iIl1|!.,;:'"`.includes(char)) {
        this.characterWidths.push(avgCharWidth * 0.4);
      } else if ("mwMW".includes(char)) {
        this.characterWidths.push(avgCharWidth * 1.3);
      } else if (char === " ") {
        this.characterWidths.push(avgCharWidth * 0.5);
      } else {
        this.characterWidths.push(avgCharWidth);
      }
    }
    this.characterWidthsDirty = false;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    if (this.perCharacterGroup) return;
    this.textMesh.visible = false;
    this.perCharacterGroup = new Group();
    this.perCharacterGroup.name = `text_chars_${this.id}`;
    this.group.add(this.perCharacterGroup);
    this.createCharacterMeshes();
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    if (!this.perCharacterGroup) return;
    this.textMesh.visible = true;
    this.disposeCharacterMeshes();
    this.group.remove(this.perCharacterGroup);
    this.perCharacterGroup = null;
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes();
    this.characterWidthsDirty = true;
    const text = this.textData.text;
    let xOffset = 0;
    this.ensureCharacterWidths();
    const totalWidth = this.characterWidths.reduce((a, b) => a + b, 0) + (text.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let startX = 0;
    switch (this.textData.textAlign) {
      case "center":
        startX = -totalWidth / 2;
        break;
      case "right":
        startX = -totalWidth;
        break;
      default:
        startX = 0;
    }
    xOffset = startX;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charMesh = new Text();
      charMesh.text = char;
      charMesh.font = this.getFontUrl(this.textData.fontFamily) ?? null;
      charMesh.fontSize = this.textData.fontSize;
      charMesh.fontWeight = this.textData.fontWeight || "400";
      charMesh.fontStyle = this.textData.fontStyle || "normal";
      charMesh.color = this.textData.fill;
      charMesh.anchorX = "center";
      charMesh.anchorY = "middle";
      if (this.textData.stroke && this.textData.strokeWidth > 0) {
        charMesh.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
        charMesh.outlineColor = this.textData.stroke;
        charMesh.outlineBlur = 5e-3;
      }
      charMesh.sdfGlyphSize = 128;
      const charWidth = this.characterWidths[i];
      charMesh.position.x = xOffset + charWidth / 2;
      charMesh.position.y = 0;
      charMesh.position.z = 0;
      xOffset += charWidth + this.textData.tracking / 1e3 * this.textData.fontSize;
      charMesh.sync();
      this.characterMeshes.push(charMesh);
      this.perCharacterGroup.add(charMesh);
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    for (const mesh of this.characterMeshes) {
      mesh.dispose();
      this.perCharacterGroup?.remove(mesh);
    }
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(text) {
    this.textData.text = text;
    this.textMesh.text = text;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    if (this.perCharacterGroup) {
      this.createCharacterMeshes();
    }
  }
  setFontFamily(family) {
    this.textData.fontFamily = family;
    const fontUrl = this.getFontUrl(family) ?? null;
    this.textMesh.font = fontUrl;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.font = fontUrl;
      charMesh.sync();
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setFontSize(size) {
    this.textData.fontSize = size;
    this.textMesh.fontSize = size;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.fontSize = size;
      charMesh.sync();
    }
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setFontWeight(weight) {
    this.textData.fontWeight = weight;
    this.textMesh.fontWeight = weight;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontWeight = weight;
      charMesh.sync();
    }
  }
  setFontStyle(style) {
    this.textData.fontStyle = style;
    this.textMesh.fontStyle = style;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontStyle = style;
      charMesh.sync();
    }
  }
  setFillColor(color) {
    this.textData.fill = color;
    this.textMesh.color = color;
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.color = color;
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setStroke(color, width) {
    this.textData.stroke = color;
    this.textData.strokeWidth = width;
    const outlineWidth = width > 0 ? width / this.textData.fontSize : 0;
    this.textMesh.outlineWidth = outlineWidth;
    this.textMesh.outlineColor = width > 0 ? color : "";
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.outlineWidth = outlineWidth;
      charMesh.outlineColor = width > 0 ? color : "";
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setTracking(tracking) {
    this.textData.tracking = tracking;
    this.textMesh.letterSpacing = tracking / 1e3;
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setTextAlign(align) {
    this.textData.textAlign = align;
    this.textMesh.textAlign = align;
    this.textMesh.anchorX = this.getAnchorX();
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.pathConfig.align = align;
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(offset) {
    this.textData.pathOffset = offset;
    this.pathConfig.offset = offset;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(margin) {
    this.textData.pathFirstMargin = margin;
    this.pathConfig.firstMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(margin) {
    this.textData.pathLastMargin = margin;
    this.pathConfig.lastMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set path reversed
   */
  setPathReversed(reversed) {
    this.textData.pathReversed = reversed;
    this.pathConfig.reversed = reversed;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(perpendicular) {
    this.textData.pathPerpendicularToPath = perpendicular;
    this.pathConfig.perpendicularToPath = perpendicular;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set force alignment
   */
  setForceAlignment(force) {
    this.textData.pathForceAlignment = force;
    this.pathConfig.forceAlignment = force;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setAnchorPointGrouping(grouping) {
    this.textData.anchorPointGrouping = grouping;
  }
  setFillAndStroke(order) {
    this.textData.fillAndStroke = order;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.fontSizeProp?.animated) {
      const size = this.textEvaluator.evaluate(this.fontSizeProp, frame);
      this.setFontSize(size);
    }
    if (this.trackingProp?.animated) {
      const tracking = this.textEvaluator.evaluate(this.trackingProp, frame);
      this.setTracking(tracking);
    }
    if (this.fillColorProp?.animated) {
      const color = this.textEvaluator.evaluate(this.fillColorProp, frame);
      this.setFillColor(color);
    }
    if (this.strokeColorProp?.animated && this.strokeWidthProp) {
      const color = this.textEvaluator.evaluate(this.strokeColorProp, frame);
      const width = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, frame) : this.textData.strokeWidth;
      this.setStroke(color, width);
    }
    if (this.pathOffsetProp) {
      const offset = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, frame) : this.textData.pathOffset;
      this.setPathOffset(offset);
    }
    if (this.firstMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.firstMarginProp, frame);
      this.setFirstMargin(margin);
    }
    if (this.lastMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.lastMarginProp, frame);
      this.setLastMargin(margin);
    }
    if (this.characterTransforms?.animated && this.perCharacterGroup) {
      this.applyCharacterTransforms(frame);
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["fontSize"] !== void 0) {
      this.setFontSize(props["fontSize"]);
    }
    if (props["tracking"] !== void 0) {
      this.setTracking(props["tracking"]);
    }
    if (props["fillColor"] !== void 0) {
      this.setFillColor(props["fillColor"]);
    }
    if (props["strokeColor"] !== void 0 || props["strokeWidth"] !== void 0) {
      this.setStroke(
        props["strokeColor"] ?? this.textData.stroke,
        props["strokeWidth"] ?? this.textData.strokeWidth
      );
    }
    if (props["pathOffset"] !== void 0) {
      this.setPathOffset(props["pathOffset"]);
    }
    if (props["firstMargin"] !== void 0) {
      this.setFirstMargin(props["firstMargin"]);
    }
    if (props["lastMargin"] !== void 0) {
      this.setLastMargin(props["lastMargin"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(frame) {
    if (!this.characterTransforms) return;
    const transforms = this.textEvaluator.evaluate(this.characterTransforms, frame);
    for (let i = 0; i < this.characterMeshes.length && i < transforms.length; i++) {
      const charMesh = this.characterMeshes[i];
      const t = transforms[i];
      charMesh.position.x += t.position.x;
      charMesh.position.y += t.position.y;
      charMesh.position.z += t.position.z;
      charMesh.rotation.x += MathUtils.degToRad(t.rotation.x);
      charMesh.rotation.y += MathUtils.degToRad(t.rotation.y);
      charMesh.rotation.z += MathUtils.degToRad(t.rotation.z);
      charMesh.scale.x *= t.scale.x;
      charMesh.scale.y *= t.scale.y;
      if (charMesh.material) {
        charMesh.material.opacity *= t.opacity;
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.text !== void 0) {
        this.setText(data.text);
      }
      if (data.fontFamily !== void 0) {
        this.setFontFamily(data.fontFamily);
      }
      if (data.fontSize !== void 0) {
        this.setFontSize(data.fontSize);
      }
      if (data.fontWeight !== void 0) {
        this.setFontWeight(data.fontWeight);
      }
      if (data.fontStyle !== void 0) {
        this.setFontStyle(data.fontStyle);
      }
      if (data.fill !== void 0) {
        this.setFillColor(data.fill);
      }
      if (data.stroke !== void 0 || data.strokeWidth !== void 0) {
        this.setStroke(
          data.stroke ?? this.textData.stroke,
          data.strokeWidth ?? this.textData.strokeWidth
        );
      }
      if (data.tracking !== void 0) {
        this.setTracking(data.tracking);
      }
      if (data.textAlign !== void 0) {
        this.setTextAlign(data.textAlign);
      }
      if (data.pathLayerId !== void 0) {
        this.textData.pathLayerId = data.pathLayerId;
        this.pathConfig.pathLayerId = data.pathLayerId;
      }
      if (data.pathOffset !== void 0) {
        this.setPathOffset(data.pathOffset);
      }
      if (data.pathFirstMargin !== void 0) {
        this.setFirstMargin(data.pathFirstMargin);
      }
      if (data.pathLastMargin !== void 0) {
        this.setLastMargin(data.pathLastMargin);
      }
      if (data.pathReversed !== void 0) {
        this.setPathReversed(data.pathReversed);
      }
      if (data.pathPerpendicularToPath !== void 0) {
        this.setPerpendicularToPath(data.pathPerpendicularToPath);
      }
      if (data.pathForceAlignment !== void 0) {
        this.setForceAlignment(data.pathForceAlignment);
      }
      if (data.perCharacter3D !== void 0) {
        if (data.perCharacter3D && !this.perCharacterGroup) {
          this.enablePerCharacter3D();
        } else if (!data.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup) {
          this.disablePerCharacter3D();
        }
      }
      if (data.anchorPointGrouping !== void 0) {
        this.setAnchorPointGrouping(data.anchorPointGrouping);
      }
      if (data.fillAndStroke !== void 0) {
        this.setFillAndStroke(data.fillAndStroke);
      }
    }
    if (properties.properties) {
      this.extractAnimatableProperties(properties);
    }
  }
  // ============================================================================
  // OPACITY OVERRIDE FOR TROIKA TEXT
  // ============================================================================
  /**
   * Override base class opacity to use Troika's fillOpacity
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.textMesh.fillOpacity = normalizedOpacity;
    this.textMesh.outlineOpacity = normalizedOpacity;
    for (const charMesh of this.characterMeshes) {
      charMesh.fillOpacity = normalizedOpacity;
      charMesh.outlineOpacity = normalizedOpacity;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    const bounds = this.textMesh.textRenderInfo?.blockBounds;
    if (bounds) {
      return {
        width: bounds[2] - bounds[0],
        height: bounds[3] - bounds[1]
      };
    }
    return { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose();
    this.disposeCharacterMeshes();
    this.textOnPath.dispose();
    if (this.perCharacterGroup) {
      this.group.remove(this.perCharacterGroup);
    }
  }
}

/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var Node = /** @class */ (function () {
    function Node(key, data) {
        this.next = null;
        this.key = key;
        this.data = data;
        this.left = null;
        this.right = null;
    }
    return Node;
}());

/* follows "An implementation of top-down splaying"
 * by D. Sleator <sleator@cs.cmu.edu> March 1992
 */
function DEFAULT_COMPARE(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Simple top down splay, not requiring i to be in the tree t.
 */
function splay(i, t, comparator) {
    var N = new Node(null, null);
    var l = N;
    var r = N;
    while (true) {
        var cmp = comparator(i, t.key);
        //if (i < t.key) {
        if (cmp < 0) {
            if (t.left === null)
                break;
            //if (i < t.left.key) {
            if (comparator(i, t.left.key) < 0) {
                var y = t.left; /* rotate right */
                t.left = y.right;
                y.right = t;
                t = y;
                if (t.left === null)
                    break;
            }
            r.left = t; /* link right */
            r = t;
            t = t.left;
            //} else if (i > t.key) {
        }
        else if (cmp > 0) {
            if (t.right === null)
                break;
            //if (i > t.right.key) {
            if (comparator(i, t.right.key) > 0) {
                var y = t.right; /* rotate left */
                t.right = y.left;
                y.left = t;
                t = y;
                if (t.right === null)
                    break;
            }
            l.right = t; /* link left */
            l = t;
            t = t.right;
        }
        else
            break;
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
}
function insert(i, data, t, comparator) {
    var node = new Node(i, data);
    if (t === null) {
        node.left = node.right = null;
        return node;
    }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
    }
    else if (cmp >= 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
    }
    return node;
}
function split(key, v, comparator) {
    var left = null;
    var right = null;
    if (v) {
        v = splay(key, v, comparator);
        var cmp = comparator(v.key, key);
        if (cmp === 0) {
            left = v.left;
            right = v.right;
        }
        else if (cmp < 0) {
            right = v.right;
            v.right = null;
            left = v;
        }
        else {
            left = v.left;
            v.left = null;
            right = v;
        }
    }
    return { left: left, right: right };
}
function merge(left, right, comparator) {
    if (right === null)
        return left;
    if (left === null)
        return right;
    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
}
/**
 * Prints level of the tree
 */
function printRow(root, prefix, isTail, out, printNode) {
    if (root) {
        out("" + prefix + (isTail ? ' ' : ' ') + printNode(root) + "\n");
        var indent = prefix + (isTail ? '    ' : '   ');
        if (root.left)
            printRow(root.left, indent, false, out, printNode);
        if (root.right)
            printRow(root.right, indent, true, out, printNode);
    }
}
var Tree = /** @class */ (function () {
    function Tree(comparator) {
        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }
        this._root = null;
        this._size = 0;
        this._comparator = comparator;
    }
    /**
     * Inserts a key, allows duplicates
     */
    Tree.prototype.insert = function (key, data) {
        this._size++;
        return this._root = insert(key, data, this._root, this._comparator);
    };
    /**
     * Adds a key, if it is not present in the tree
     */
    Tree.prototype.add = function (key, data) {
        var node = new Node(key, data);
        if (this._root === null) {
            node.left = node.right = null;
            this._size++;
            this._root = node;
        }
        var comparator = this._comparator;
        var t = splay(key, this._root, comparator);
        var cmp = comparator(key, t.key);
        if (cmp === 0)
            this._root = t;
        else {
            if (cmp < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
            }
            else if (cmp > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
            }
            this._size++;
            this._root = node;
        }
        return this._root;
    };
    /**
     * @param  {Key} key
     * @return {Node|null}
     */
    Tree.prototype.remove = function (key) {
        this._root = this._remove(key, this._root, this._comparator);
    };
    /**
     * Deletes i from the tree if it's there
     */
    Tree.prototype._remove = function (i, t, comparator) {
        var x;
        if (t === null)
            return null;
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp === 0) { /* found it */
            if (t.left === null) {
                x = t.right;
            }
            else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
            }
            this._size--;
            return x;
        }
        return t; /* It wasn't there */
    };
    /**
     * Removes and returns the node with smallest key
     */
    Tree.prototype.pop = function () {
        var node = this._root;
        if (node) {
            while (node.left)
                node = node.left;
            this._root = splay(node.key, this._root, this._comparator);
            this._root = this._remove(node.key, this._root, this._comparator);
            return { key: node.key, data: node.data };
        }
        return null;
    };
    /**
     * Find without splaying
     */
    Tree.prototype.findStatic = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0)
                return current;
            else if (cmp < 0)
                current = current.left;
            else
                current = current.right;
        }
        return null;
    };
    Tree.prototype.find = function (key) {
        if (this._root) {
            this._root = splay(key, this._root, this._comparator);
            if (this._comparator(key, this._root.key) !== 0)
                return null;
        }
        return this._root;
    };
    Tree.prototype.contains = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0)
                return true;
            else if (cmp < 0)
                current = current.left;
            else
                current = current.right;
        }
        return false;
    };
    Tree.prototype.forEach = function (visitor, ctx) {
        var current = this._root;
        var Q = []; /* Initialize stack s */
        var done = false;
        while (!done) {
            if (current !== null) {
                Q.push(current);
                current = current.left;
            }
            else {
                if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                }
                else
                    done = true;
            }
        }
        return this;
    };
    /**
     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
     */
    Tree.prototype.range = function (low, high, fn, ctx) {
        var Q = [];
        var compare = this._comparator;
        var node = this._root;
        var cmp;
        while (Q.length !== 0 || node) {
            if (node) {
                Q.push(node);
                node = node.left;
            }
            else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp > 0) {
                    break;
                }
                else if (compare(node.key, low) >= 0) {
                    if (fn.call(ctx, node))
                        return this; // stop if smth is returned
                }
                node = node.right;
            }
        }
        return this;
    };
    /**
     * Returns array of keys
     */
    Tree.prototype.keys = function () {
        var keys = [];
        this.forEach(function (_a) {
            var key = _a.key;
            return keys.push(key);
        });
        return keys;
    };
    /**
     * Returns array of all the data in the nodes
     */
    Tree.prototype.values = function () {
        var values = [];
        this.forEach(function (_a) {
            var data = _a.data;
            return values.push(data);
        });
        return values;
    };
    Tree.prototype.min = function () {
        if (this._root)
            return this.minNode(this._root).key;
        return null;
    };
    Tree.prototype.max = function () {
        if (this._root)
            return this.maxNode(this._root).key;
        return null;
    };
    Tree.prototype.minNode = function (t) {
        if (t === void 0) { t = this._root; }
        if (t)
            while (t.left)
                t = t.left;
        return t;
    };
    Tree.prototype.maxNode = function (t) {
        if (t === void 0) { t = this._root; }
        if (t)
            while (t.right)
                t = t.right;
        return t;
    };
    /**
     * Returns node at given index
     */
    Tree.prototype.at = function (index) {
        var current = this._root;
        var done = false;
        var i = 0;
        var Q = [];
        while (!done) {
            if (current) {
                Q.push(current);
                current = current.left;
            }
            else {
                if (Q.length > 0) {
                    current = Q.pop();
                    if (i === index)
                        return current;
                    i++;
                    current = current.right;
                }
                else
                    done = true;
            }
        }
        return null;
    };
    Tree.prototype.next = function (d) {
        var root = this._root;
        var successor = null;
        if (d.right) {
            successor = d.right;
            while (successor.left)
                successor = successor.left;
            return successor;
        }
        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0)
                break;
            else if (cmp < 0) {
                successor = root;
                root = root.left;
            }
            else
                root = root.right;
        }
        return successor;
    };
    Tree.prototype.prev = function (d) {
        var root = this._root;
        var predecessor = null;
        if (d.left !== null) {
            predecessor = d.left;
            while (predecessor.right)
                predecessor = predecessor.right;
            return predecessor;
        }
        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0)
                break;
            else if (cmp < 0)
                root = root.left;
            else {
                predecessor = root;
                root = root.right;
            }
        }
        return predecessor;
    };
    Tree.prototype.clear = function () {
        this._root = null;
        this._size = 0;
        return this;
    };
    Tree.prototype.toList = function () {
        return toList(this._root);
    };
    /**
     * Bulk-load items. Both array have to be same size
     */
    Tree.prototype.load = function (keys, values, presort) {
        if (values === void 0) { values = []; }
        if (presort === void 0) { presort = false; }
        var size = keys.length;
        var comparator = this._comparator;
        // sort if needed
        if (presort)
            sort(keys, values, 0, size - 1, comparator);
        if (this._root === null) { // empty tree
            this._root = loadRecursive(keys, values, 0, size);
            this._size = size;
        }
        else { // that re-builds the whole tree from two in-order traversals
            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
            size = this._size + size;
            this._root = sortedListToBST({ head: mergedList }, 0, size);
        }
        return this;
    };
    Tree.prototype.isEmpty = function () { return this._root === null; };
    Object.defineProperty(Tree.prototype, "size", {
        get: function () { return this._size; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tree.prototype, "root", {
        get: function () { return this._root; },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.toString = function (printNode) {
        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }
        var out = [];
        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
        return out.join('');
    };
    Tree.prototype.update = function (key, newKey, newData) {
        var comparator = this._comparator;
        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
        if (comparator(key, newKey) < 0) {
            right = insert(newKey, newData, right, comparator);
        }
        else {
            left = insert(newKey, newData, left, comparator);
        }
        this._root = merge(left, right, comparator);
    };
    Tree.prototype.split = function (key) {
        return split(key, this._root, this._comparator);
    };
    Tree.prototype[Symbol.iterator] = function () {
        var current, Q, done;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this._root;
                    Q = [];
                    done = false;
                    _a.label = 1;
                case 1:
                    if (!!done) return [3 /*break*/, 6];
                    if (!(current !== null)) return [3 /*break*/, 2];
                    Q.push(current);
                    current = current.left;
                    return [3 /*break*/, 5];
                case 2:
                    if (!(Q.length !== 0)) return [3 /*break*/, 4];
                    current = Q.pop();
                    return [4 /*yield*/, current];
                case 3:
                    _a.sent();
                    current = current.right;
                    return [3 /*break*/, 5];
                case 4:
                    done = true;
                    _a.label = 5;
                case 5: return [3 /*break*/, 1];
                case 6: return [2 /*return*/];
            }
        });
    };
    return Tree;
}());
function loadRecursive(keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var key = keys[middle];
        var data = values[middle];
        var node = new Node(key, data);
        node.left = loadRecursive(keys, values, start, middle);
        node.right = loadRecursive(keys, values, middle + 1, end);
        return node;
    }
    return null;
}
function createList(keys, values) {
    var head = new Node(null, null);
    var p = head;
    for (var i = 0; i < keys.length; i++) {
        p = p.next = new Node(keys[i], values[i]);
    }
    p.next = null;
    return head.next;
}
function toList(root) {
    var current = root;
    var Q = [];
    var done = false;
    var head = new Node(null, null);
    var p = head;
    while (!done) {
        if (current) {
            Q.push(current);
            current = current.left;
        }
        else {
            if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
            }
            else
                done = true;
        }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
}
function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var left = sortedListToBST(list, start, middle);
        var root = list.head;
        root.left = left;
        list.head = list.head.next;
        root.right = sortedListToBST(list, middle + 1, end);
        return root;
    }
    return null;
}
function mergeLists(l1, l2, compare) {
    var head = new Node(null, null); // dummy
    var p = head;
    var p1 = l1;
    var p2 = l2;
    while (p1 !== null && p2 !== null) {
        if (compare(p1.key, p2.key) < 0) {
            p.next = p1;
            p1 = p1.next;
        }
        else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next;
    }
    if (p1 !== null) {
        p.next = p1;
    }
    else if (p2 !== null) {
        p.next = p2;
    }
    return head.next;
}
function sort(keys, values, left, right, compare) {
    if (left >= right)
        return;
    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;
    while (true) {
        do
            i++;
        while (compare(keys[i], pivot) < 0);
        do
            j--;
        while (compare(keys[j], pivot) > 0);
        if (i >= j)
            break;
        var tmp = keys[i];
        keys[i] = keys[j];
        keys[j] = tmp;
        tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }
    sort(keys, values, left, j, compare);
    sort(keys, values, j + 1, right, compare);
}

const epsilon$1 = 1.1102230246251565e-16;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;

// fast_expansion_sum_zeroelim routine from oritinal code
function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if ((fnow > enow) === (fnow > -enow)) {
        Q = enow;
        enow = e[++eindex];
    } else {
        Q = fnow;
        fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
        if ((fnow > enow) === (fnow > -enow)) {
            Qnew = enow + Q;
            hh = Q - (Qnew - enow);
            enow = e[++eindex];
        } else {
            Qnew = fnow + Q;
            hh = Q - (Qnew - fnow);
            fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
        while (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
            } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
    }
    while (eindex < elen) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    while (findex < flen) {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    if (Q !== 0 || hindex === 0) {
        h[hindex++] = Q;
    }
    return hindex;
}

function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++) Q += e[i];
    return Q;
}

function vec(n) {
    return new Float64Array(n);
}

const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;

const B = vec(4);
const C1 = vec(8);
const C2 = vec(12);
const D = vec(16);
const u = vec(4);

function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;

    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;

    let det = estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
        return det;
    }

    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);

    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
        return det;
    }

    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;

    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = sum(4, B, 4, u, C1);

    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = sum(C1len, C1, 4, u, C2);

    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = sum(C2len, C2, 4, u, D);

    return D[Dlen - 1];
}

function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;

    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;

    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

var define_process_default = { };
var define_process_env_default = {};
const isInBbox = (bbox, point) => {
  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
};
const getBboxOverlap = (b1, b2) => {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;
  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
let epsilon = Number.EPSILON;
if (epsilon === void 0) epsilon = Math.pow(2, -52);
const EPSILON_SQ = epsilon * epsilon;
const cmp = (a, b) => {
  if (-epsilon < a && a < epsilon) {
    if (-epsilon < b && b < epsilon) {
      return 0;
    }
  }
  const ab = a - b;
  if (ab * ab < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
class PtRounder {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new CoordRounder();
    this.yRounder = new CoordRounder();
  }
  round(x, y) {
    return {
      x: this.xRounder.round(x),
      y: this.yRounder.round(y)
    };
  }
}
class CoordRounder {
  constructor() {
    this.tree = new Tree();
    this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(coord) {
    const node = this.tree.add(coord);
    const prevNode = this.tree.prev(node);
    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
      this.tree.remove(coord);
      return prevNode.key;
    }
    const nextNode = this.tree.next(node);
    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
      this.tree.remove(coord);
      return nextNode.key;
    }
    return coord;
  }
}
const rounder = new PtRounder();
const crossProduct = (a, b) => a.x * b.y - a.y * b.x;
const dotProduct = (a, b) => a.x * b.x + a.y * b.y;
const compareVectorAngles = (basePt, endPt1, endPt2) => {
  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
  if (res > 0) return -1;
  if (res < 0) return 1;
  return 0;
};
const length = (v) => Math.sqrt(dotProduct(v, v));
const sineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
const cosineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
const horizontalIntersection = (pt, v, y) => {
  if (v.y === 0) return null;
  return {
    x: pt.x + v.x / v.y * (y - pt.y),
    y
  };
};
const verticalIntersection = (pt, v, x) => {
  if (v.x === 0) return null;
  return {
    x,
    y: pt.y + v.y / v.x * (x - pt.x)
  };
};
const intersection$1 = (pt1, v1, pt2, v2) => {
  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);
  const kross = crossProduct(v1, v2);
  if (kross == 0) return null;
  const ve = {
    x: pt2.x - pt1.x,
    y: pt2.y - pt1.y
  };
  const d1 = crossProduct(ve, v1) / kross;
  const d2 = crossProduct(ve, v2) / kross;
  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
  const x = (x1 + x2) / 2;
  const y = (y1 + y2) / 2;
  return {
    x,
    y
  };
};
class SweepEvent {
  // for ordering sweep events in the sweep event queue
  static compare(a, b) {
    const ptCmp = SweepEvent.comparePoints(a.point, b.point);
    if (ptCmp !== 0) return ptCmp;
    if (a.point !== b.point) a.link(b);
    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
    return Segment.compare(a.segment, b.segment);
  }
  // for ordering points in sweep line order
  static comparePoints(aPt, bPt) {
    if (aPt.x < bPt.x) return -1;
    if (aPt.x > bPt.x) return 1;
    if (aPt.y < bPt.y) return -1;
    if (aPt.y > bPt.y) return 1;
    return 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(point, isLeft) {
    if (point.events === void 0) point.events = [this];
    else point.events.push(this);
    this.point = point;
    this.isLeft = isLeft;
  }
  link(other) {
    if (other.point === this.point) {
      throw new Error("Tried to link already linked events");
    }
    const otherEvents = other.point.events;
    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
      const evt = otherEvents[i];
      this.point.events.push(evt);
      evt.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const numEvents = this.point.events.length;
    for (let i = 0; i < numEvents; i++) {
      const evt1 = this.point.events[i];
      if (evt1.segment.consumedBy !== void 0) continue;
      for (let j = i + 1; j < numEvents; j++) {
        const evt2 = this.point.events[j];
        if (evt2.consumedBy !== void 0) continue;
        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
        evt1.segment.consume(evt2.segment);
      }
    }
  }
  getAvailableLinkedEvents() {
    const events = [];
    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
      const evt = this.point.events[i];
      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
        events.push(evt);
      }
    }
    return events;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(baseEvent) {
    const cache = /* @__PURE__ */ new Map();
    const fillCache = (linkedEvent) => {
      const nextEvent = linkedEvent.otherSE;
      cache.set(linkedEvent, {
        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
      });
    };
    return (a, b) => {
      if (!cache.has(a)) fillCache(a);
      if (!cache.has(b)) fillCache(b);
      const {
        sine: asine,
        cosine: acosine
      } = cache.get(a);
      const {
        sine: bsine,
        cosine: bcosine
      } = cache.get(b);
      if (asine >= 0 && bsine >= 0) {
        if (acosine < bcosine) return 1;
        if (acosine > bcosine) return -1;
        return 0;
      }
      if (asine < 0 && bsine < 0) {
        if (acosine < bcosine) return -1;
        if (acosine > bcosine) return 1;
        return 0;
      }
      if (bsine < asine) return -1;
      if (bsine > asine) return 1;
      return 0;
    };
  }
}
let segmentId = 0;
class Segment {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(a, b) {
    const alx = a.leftSE.point.x;
    const blx = b.leftSE.point.x;
    const arx = a.rightSE.point.x;
    const brx = b.rightSE.point.x;
    if (brx < alx) return 1;
    if (arx < blx) return -1;
    const aly = a.leftSE.point.y;
    const bly = b.leftSE.point.y;
    const ary = a.rightSE.point.y;
    const bry = b.rightSE.point.y;
    if (alx < blx) {
      if (bly < aly && bly < ary) return 1;
      if (bly > aly && bly > ary) return -1;
      const aCmpBLeft = a.comparePoint(b.leftSE.point);
      if (aCmpBLeft < 0) return 1;
      if (aCmpBLeft > 0) return -1;
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
      return -1;
    }
    if (alx > blx) {
      if (aly < bly && aly < bry) return -1;
      if (aly > bly && aly > bry) return 1;
      const bCmpALeft = b.comparePoint(a.leftSE.point);
      if (bCmpALeft !== 0) return bCmpALeft;
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
      return 1;
    }
    if (aly < bly) return -1;
    if (aly > bly) return 1;
    if (arx < brx) {
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
    }
    if (arx > brx) {
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
    }
    if (arx !== brx) {
      const ay = ary - aly;
      const ax = arx - alx;
      const by = bry - bly;
      const bx = brx - blx;
      if (ay > ax && by < bx) return 1;
      if (ay < ax && by > bx) return -1;
    }
    if (arx > brx) return 1;
    if (arx < brx) return -1;
    if (ary < bry) return -1;
    if (ary > bry) return 1;
    if (a.id < b.id) return -1;
    if (a.id > b.id) return 1;
    return 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(leftSE, rightSE, rings, windings) {
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  static fromRing(pt1, pt2, ring) {
    let leftPt, rightPt, winding;
    const cmpPts = SweepEvent.comparePoints(pt1, pt2);
    if (cmpPts < 0) {
      leftPt = pt1;
      rightPt = pt2;
      winding = 1;
    } else if (cmpPts > 0) {
      leftPt = pt2;
      rightPt = pt1;
      winding = -1;
    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
    const leftSE = new SweepEvent(leftPt, true);
    const rightSE = new SweepEvent(rightPt, false);
    return new Segment(leftSE, rightSE, [ring], [winding]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(newRightSE) {
    this.rightSE = newRightSE;
    this.rightSE.segment = this;
    this.rightSE.otherSE = this.leftSE;
    this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const y1 = this.leftSE.point.y;
    const y2 = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: y1 < y2 ? y1 : y2
      },
      ur: {
        x: this.rightSE.point.x,
        y: y1 > y2 ? y1 : y2
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(pt) {
    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(point) {
    if (this.isAnEndpoint(point)) return 0;
    const lPt = this.leftSE.point;
    const rPt = this.rightSE.point;
    const v = this.vector();
    if (lPt.x === rPt.x) {
      if (point.x === lPt.x) return 0;
      return point.x < lPt.x ? 1 : -1;
    }
    const yDist = (point.y - lPt.y) / v.y;
    const xFromYDist = lPt.x + yDist * v.x;
    if (point.x === xFromYDist) return 0;
    const xDist = (point.x - lPt.x) / v.x;
    const yFromXDist = lPt.y + xDist * v.y;
    if (point.y === yFromXDist) return 0;
    return point.y < yFromXDist ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(other) {
    const tBbox = this.bbox();
    const oBbox = other.bbox();
    const bboxOverlap = getBboxOverlap(tBbox, oBbox);
    if (bboxOverlap === null) return null;
    const tlp = this.leftSE.point;
    const trp = this.rightSE.point;
    const olp = other.leftSE.point;
    const orp = other.rightSE.point;
    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
    if (touchesThisLSE && touchesOtherLSE) {
      if (touchesThisRSE && !touchesOtherRSE) return trp;
      if (!touchesThisRSE && touchesOtherRSE) return orp;
      return null;
    }
    if (touchesThisLSE) {
      if (touchesOtherRSE) {
        if (tlp.x === orp.x && tlp.y === orp.y) return null;
      }
      return tlp;
    }
    if (touchesOtherLSE) {
      if (touchesThisRSE) {
        if (trp.x === olp.x && trp.y === olp.y) return null;
      }
      return olp;
    }
    if (touchesThisRSE && touchesOtherRSE) return null;
    if (touchesThisRSE) return trp;
    if (touchesOtherRSE) return orp;
    const pt = intersection$1(tlp, this.vector(), olp, other.vector());
    if (pt === null) return null;
    if (!isInBbox(bboxOverlap, pt)) return null;
    return rounder.round(pt.x, pt.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(point) {
    const newEvents = [];
    const alreadyLinked = point.events !== void 0;
    const newLeftSE = new SweepEvent(point, true);
    const newRightSE = new SweepEvent(point, false);
    const oldRightSE = this.rightSE;
    this.replaceRightSE(newRightSE);
    newEvents.push(newRightSE);
    newEvents.push(newLeftSE);
    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
      newSeg.swapEvents();
    }
    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
      this.swapEvents();
    }
    if (alreadyLinked) {
      newLeftSE.checkForConsuming();
      newRightSE.checkForConsuming();
    }
    return newEvents;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const tmpEvt = this.rightSE;
    this.rightSE = this.leftSE;
    this.leftSE = tmpEvt;
    this.leftSE.isLeft = true;
    this.rightSE.isLeft = false;
    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
      this.windings[i] *= -1;
    }
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(other) {
    let consumer = this;
    let consumee = other;
    while (consumer.consumedBy) consumer = consumer.consumedBy;
    while (consumee.consumedBy) consumee = consumee.consumedBy;
    const cmp2 = Segment.compare(consumer, consumee);
    if (cmp2 === 0) return;
    if (cmp2 > 0) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    if (consumer.prev === consumee) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
      const ring = consumee.rings[i];
      const winding = consumee.windings[i];
      const index2 = consumer.rings.indexOf(ring);
      if (index2 === -1) {
        consumer.rings.push(ring);
        consumer.windings.push(winding);
      } else consumer.windings[index2] += winding;
    }
    consumee.rings = null;
    consumee.windings = null;
    consumee.consumedBy = consumer;
    consumee.leftSE.consumedBy = consumer.leftSE;
    consumee.rightSE.consumedBy = consumer.rightSE;
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    if (this._prevInResult !== void 0) return this._prevInResult;
    if (!this.prev) this._prevInResult = null;
    else if (this.prev.isInResult()) this._prevInResult = this.prev;
    else this._prevInResult = this.prev.prevInResult();
    return this._prevInResult;
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const seg = this.prev.consumedBy || this.prev;
      this._beforeState = seg.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const beforeState = this.beforeState();
    this._afterState = {
      rings: beforeState.rings.slice(0),
      windings: beforeState.windings.slice(0),
      multiPolys: []
    };
    const ringsAfter = this._afterState.rings;
    const windingsAfter = this._afterState.windings;
    const mpsAfter = this._afterState.multiPolys;
    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
      const ring = this.rings[i];
      const winding = this.windings[i];
      const index2 = ringsAfter.indexOf(ring);
      if (index2 === -1) {
        ringsAfter.push(ring);
        windingsAfter.push(winding);
      } else windingsAfter[index2] += winding;
    }
    const polysAfter = [];
    const polysExclude = [];
    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
      if (windingsAfter[i] === 0) continue;
      const ring = ringsAfter[i];
      const poly = ring.poly;
      if (polysExclude.indexOf(poly) !== -1) continue;
      if (ring.isExterior) polysAfter.push(poly);
      else {
        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
        const index2 = polysAfter.indexOf(ring.poly);
        if (index2 !== -1) polysAfter.splice(index2, 1);
      }
    }
    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
      const mp = polysAfter[i].multiPoly;
      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return false;
    if (this._isInResult !== void 0) return this._isInResult;
    const mpsBefore = this.beforeState().multiPolys;
    const mpsAfter = this.afterState().multiPolys;
    switch (operation.type) {
      case "union": {
        const noBefores = mpsBefore.length === 0;
        const noAfters = mpsAfter.length === 0;
        this._isInResult = noBefores !== noAfters;
        break;
      }
      case "intersection": {
        let least;
        let most;
        if (mpsBefore.length < mpsAfter.length) {
          least = mpsBefore.length;
          most = mpsAfter.length;
        } else {
          least = mpsAfter.length;
          most = mpsBefore.length;
        }
        this._isInResult = most === operation.numMultiPolys && least < most;
        break;
      }
      case "xor": {
        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
        this._isInResult = diff % 2 === 1;
        break;
      }
      case "difference": {
        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${operation.type}`);
    }
    return this._isInResult;
  }
}
class RingIn {
  constructor(geomRing, poly, isExterior) {
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    let prevPoint = firstPoint;
    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      let point = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
      this.segments.push(Segment.fromRing(prevPoint, point, this));
      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
      prevPoint = point;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
    }
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
      const segment = this.segments[i];
      sweepEvents.push(segment.leftSE);
      sweepEvents.push(segment.rightSE);
    }
    return sweepEvents;
  }
}
class PolyIn {
  constructor(geomPoly, multiPoly) {
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
      const ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  getSweepEvents() {
    const sweepEvents = this.exteriorRing.getSweepEvents();
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringSweepEvents = this.interiorRings[i].getSweepEvents();
      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
        sweepEvents.push(ringSweepEvents[j]);
      }
    }
    return sweepEvents;
  }
}
class MultiPolyIn {
  constructor(geom, isSubject) {
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number") geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let i = 0, iMax = geom.length; i < iMax; i++) {
      const poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polySweepEvents = this.polys[i].getSweepEvents();
      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
        sweepEvents.push(polySweepEvents[j]);
      }
    }
    return sweepEvents;
  }
}
class RingOut {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(allSegments) {
    const ringsOut = [];
    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
      const segment = allSegments[i];
      if (!segment.isInResult() || segment.ringOut) continue;
      let prevEvent = null;
      let event = segment.leftSE;
      let nextEvent = segment.rightSE;
      const events = [event];
      const startingPoint = event.point;
      const intersectionLEs = [];
      while (true) {
        prevEvent = event;
        event = nextEvent;
        events.push(event);
        if (event.point === startingPoint) break;
        while (true) {
          const availableLEs = event.getAvailableLinkedEvents();
          if (availableLEs.length === 0) {
            const firstPt = events[0].point;
            const lastPt = events[events.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
          }
          if (availableLEs.length === 1) {
            nextEvent = availableLEs[0].otherSE;
            break;
          }
          let indexLE = null;
          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
            if (intersectionLEs[j].point === event.point) {
              indexLE = j;
              break;
            }
          }
          if (indexLE !== null) {
            const intersectionLE = intersectionLEs.splice(indexLE)[0];
            const ringEvents = events.splice(intersectionLE.index);
            ringEvents.unshift(ringEvents[0].otherSE);
            ringsOut.push(new RingOut(ringEvents.reverse()));
            continue;
          }
          intersectionLEs.push({
            index: events.length,
            point: event.point
          });
          const comparator = event.getLeftmostComparator(prevEvent);
          nextEvent = availableLEs.sort(comparator)[0].otherSE;
          break;
        }
      }
      ringsOut.push(new RingOut(events));
    }
    return ringsOut;
  }
  constructor(events) {
    this.events = events;
    for (let i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  getGeom() {
    let prevPt = this.events[0].point;
    const points = [prevPt];
    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
      const pt2 = this.events[i].point;
      const nextPt2 = this.events[i + 1].point;
      if (compareVectorAngles(pt2, prevPt, nextPt2) === 0) continue;
      points.push(pt2);
      prevPt = pt2;
    }
    if (points.length === 1) return null;
    const pt = points[0];
    const nextPt = points[1];
    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
    points.push(points[0]);
    const step = this.isExteriorRing() ? 1 : -1;
    const iStart = this.isExteriorRing() ? 0 : points.length - 1;
    const iEnd = this.isExteriorRing() ? points.length : -1;
    const orderedPoints = [];
    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);
    return orderedPoints;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const enclosing = this.enclosingRing();
      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    if (this._enclosingRing === void 0) {
      this._enclosingRing = this._calcEnclosingRing();
    }
    return this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let leftMostEvt = this.events[0];
    for (let i = 1, iMax = this.events.length; i < iMax; i++) {
      const evt = this.events[i];
      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
    }
    let prevSeg = leftMostEvt.segment.prevInResult();
    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    while (true) {
      if (!prevSeg) return null;
      if (!prevPrevSeg) return prevSeg.ringOut;
      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
          return prevSeg.ringOut;
        } else return prevSeg.ringOut.enclosingRing();
      }
      prevSeg = prevPrevSeg.prevInResult();
      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    }
  }
}
class PolyOut {
  constructor(exteriorRing) {
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  addInterior(ring) {
    this.interiorRings.push(ring);
    ring.poly = this;
  }
  getGeom() {
    const geom = [this.exteriorRing.getGeom()];
    if (geom[0] === null) return null;
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringGeom = this.interiorRings[i].getGeom();
      if (ringGeom === null) continue;
      geom.push(ringGeom);
    }
    return geom;
  }
}
class MultiPolyOut {
  constructor(rings) {
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  getGeom() {
    const geom = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polyGeom = this.polys[i].getGeom();
      if (polyGeom === null) continue;
      geom.push(polyGeom);
    }
    return geom;
  }
  _composePolys(rings) {
    const polys = [];
    for (let i = 0, iMax = rings.length; i < iMax; i++) {
      const ring = rings[i];
      if (ring.poly) continue;
      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
      else {
        const enclosingRing = ring.enclosingRing();
        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
        enclosingRing.poly.addInterior(ring);
      }
    }
    return polys;
  }
}
class SweepLine {
  constructor(queue) {
    let comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
    this.queue = queue;
    this.tree = new Tree(comparator);
    this.segments = [];
  }
  process(event) {
    const segment = event.segment;
    const newEvents = [];
    if (event.consumedBy) {
      if (event.isLeft) this.queue.remove(event.otherSE);
      else this.tree.remove(segment);
      return newEvents;
    }
    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
    if (!node) throw new Error(`Unable to find segment #${segment.id} [${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> [${segment.rightSE.point.x}, ${segment.rightSE.point.y}] in SweepLine tree.`);
    let prevNode = node;
    let nextNode = node;
    let prevSeg = void 0;
    let nextSeg = void 0;
    while (prevSeg === void 0) {
      prevNode = this.tree.prev(prevNode);
      if (prevNode === null) prevSeg = null;
      else if (prevNode.key.consumedBy === void 0) prevSeg = prevNode.key;
    }
    while (nextSeg === void 0) {
      nextNode = this.tree.next(nextNode);
      if (nextNode === null) nextSeg = null;
      else if (nextNode.key.consumedBy === void 0) nextSeg = nextNode.key;
    }
    if (event.isLeft) {
      let prevMySplitter = null;
      if (prevSeg) {
        const prevInter = prevSeg.getIntersection(segment);
        if (prevInter !== null) {
          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
          if (!prevSeg.isAnEndpoint(prevInter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      let nextMySplitter = null;
      if (nextSeg) {
        const nextInter = nextSeg.getIntersection(segment);
        if (nextInter !== null) {
          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
          if (!nextSeg.isAnEndpoint(nextInter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      if (prevMySplitter !== null || nextMySplitter !== null) {
        let mySplitter = null;
        if (prevMySplitter === null) mySplitter = nextMySplitter;
        else if (nextMySplitter === null) mySplitter = prevMySplitter;
        else {
          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
        }
        this.queue.remove(segment.rightSE);
        newEvents.push(segment.rightSE);
        const newEventsFromSplit = segment.split(mySplitter);
        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
          newEvents.push(newEventsFromSplit[i]);
        }
      }
      if (newEvents.length > 0) {
        this.tree.remove(segment);
        newEvents.push(event);
      } else {
        this.segments.push(segment);
        segment.prev = prevSeg;
      }
    } else {
      if (prevSeg && nextSeg) {
        const inter = prevSeg.getIntersection(nextSeg);
        if (inter !== null) {
          if (!prevSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (!nextSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      this.tree.remove(segment);
    }
    return newEvents;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(seg, pt) {
    this.tree.remove(seg);
    const rightSE = seg.rightSE;
    this.queue.remove(rightSE);
    const newEvents = seg.split(pt);
    newEvents.push(rightSE);
    if (seg.consumedBy === void 0) this.tree.add(seg);
    return newEvents;
  }
}
const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof define_process_default !== "undefined" && define_process_env_default.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof define_process_default !== "undefined" && define_process_env_default.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class Operation {
  run(type, geom, moreGeoms) {
    operation.type = type;
    rounder.reset();
    const multipolys = [new MultiPolyIn(geom, true)];
    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
      multipolys.push(new MultiPolyIn(moreGeoms[i], false));
    }
    operation.numMultiPolys = multipolys.length;
    if (operation.type === "difference") {
      const subject = multipolys[0];
      let i = 1;
      while (i < multipolys.length) {
        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
        else multipolys.splice(i, 1);
      }
    }
    if (operation.type === "intersection") {
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const mpA = multipolys[i];
        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
        }
      }
    }
    const queue = new Tree(SweepEvent.compare);
    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
      const sweepEvents = multipolys[i].getSweepEvents();
      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
        queue.insert(sweepEvents[j]);
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
        }
      }
    }
    const sweepLine = new SweepLine(queue);
    let prevQueueSize = queue.size;
    let node = queue.pop();
    while (node) {
      const evt = node.key;
      if (queue.size === prevQueueSize) {
        const seg = evt.segment;
        throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent [${evt.point.x}, ${evt.point.y}] from segment #${seg.id} [${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> [${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
      }
      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      }
      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      }
      const newEvents = sweepLine.process(evt);
      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
        const evt2 = newEvents[i];
        if (evt2.consumedBy === void 0) queue.insert(evt2);
      }
      prevQueueSize = queue.size;
      node = queue.pop();
    }
    rounder.reset();
    const ringsOut = RingOut.factory(sweepLine.segments);
    const result = new MultiPolyOut(ringsOut);
    return result.getGeom();
  }
}
const operation = new Operation();
const union = function(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
const intersection = function(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
const xor = function(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
const difference = function(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index = {
  union,
  intersection,
  xor,
  difference
};

function distance$1(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerpPoint(a, b, t) {
  return {
    x: a.x + (b.x - a.x) * t,
    y: a.y + (b.y - a.y) * t
  };
}
function addPoints(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint$1(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function normalize(p) {
  const len = Math.sqrt(p.x * p.x + p.y * p.y);
  if (len < 1e-4) return { x: 0, y: 0 };
  return { x: p.x / len, y: p.y / len };
}
function perpendicular(p) {
  return { x: -p.y, y: p.x };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function rotatePoint$1(p, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: p.x * cos - p.y * sin,
    y: p.x * sin + p.y * cos
  };
}
function rotateAround(p, center, angle) {
  const translated = subtractPoints(p, center);
  const rotated = rotatePoint$1(translated, angle);
  return addPoints(rotated, center);
}
function clonePoint(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex(v) {
  return {
    point: clonePoint(v.point),
    inHandle: clonePoint(v.inHandle),
    outHandle: clonePoint(v.outHandle)
  };
}
function clonePath(path) {
  return {
    vertices: path.vertices.map(cloneVertex),
    closed: path.closed
  };
}
function cubicBezierPoint(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function cubicBezierDerivative(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const t2 = t * t;
  return {
    x: 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x),
    y: 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y)
  };
}
function splitCubicBezier(p0, p1, p2, p3, t) {
  const q0 = lerpPoint(p0, p1, t);
  const q1 = lerpPoint(p1, p2, t);
  const q2 = lerpPoint(p2, p3, t);
  const r0 = lerpPoint(q0, q1, t);
  const r1 = lerpPoint(q1, q2, t);
  const s = lerpPoint(r0, r1, t);
  return [
    [p0, q0, r0, s],
    [s, r1, q2, p3]
  ];
}
function cubicBezierLength(p0, p1, p2, p3, subdivisions = 32) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= subdivisions; i++) {
    const t = i / subdivisions;
    const curr = cubicBezierPoint(p0, p1, p2, p3, t);
    length += distance$1(prev, curr);
    prev = curr;
  }
  return length;
}
function getPathLength(path) {
  if (path.vertices.length < 2) return 0;
  let totalLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    totalLength += cubicBezierLength(p0, p1, p2, p3);
  }
  return totalLength;
}
function getPointAtDistance(path, targetDistance, totalLength) {
  if (path.vertices.length < 2) return null;
  const pathLength = totalLength ?? getPathLength(path);
  if (pathLength < 1e-4) return null;
  targetDistance = Math.max(0, Math.min(pathLength, targetDistance));
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    if (accumulatedLength + segmentLength >= targetDistance) {
      const remainingDistance = targetDistance - accumulatedLength;
      const localT = remainingDistance / segmentLength;
      const point = cubicBezierPoint(p0, p1, p2, p3, localT);
      const tangent = normalize(cubicBezierDerivative(p0, p1, p2, p3, localT));
      const globalT = (i + localT) / numSegments;
      return { point, tangent, t: globalT };
    }
    accumulatedLength += segmentLength;
  }
  const lastVertex = path.vertices[path.closed ? 0 : path.vertices.length - 1];
  return {
    point: clonePoint(lastVertex.point),
    tangent: { x: 1, y: 0 },
    t: 1
  };
}
function trimPath(path, startPercent, endPercent, offsetDegrees = 0) {
  if (path.vertices.length < 2) return clonePath(path);
  const totalLength = getPathLength(path);
  if (totalLength < 1e-4) return clonePath(path);
  const offsetPercent = offsetDegrees / 360 * 100;
  let start = ((startPercent + offsetPercent) % 100 + 100) % 100;
  let end = ((endPercent + offsetPercent) % 100 + 100) % 100;
  if (start > end && path.closed) {
    const part1 = trimPathSimple(path, start, 100, totalLength);
    const part2 = trimPathSimple(path, 0, end, totalLength);
    return joinPaths(part1, part2);
  }
  if (start > end) {
    [start, end] = [end, start];
  }
  return trimPathSimple(path, start, end, totalLength);
}
function trimPathSimple(path, startPercent, endPercent, totalLength) {
  const startDist = startPercent / 100 * totalLength;
  const endDist = endPercent / 100 * totalLength;
  if (endDist - startDist < 1e-3) {
    return { vertices: [], closed: false };
  }
  const result = [];
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  let inTrimRegion = false;
  let lastPoint = null;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    const segmentStart = accumulatedLength;
    const segmentEnd = accumulatedLength + segmentLength;
    if (segmentEnd > startDist && segmentStart < endDist) {
      const tStart = Math.max(0, (startDist - segmentStart) / segmentLength);
      const tEnd = Math.min(1, (endDist - segmentStart) / segmentLength);
      let trimmedPoints;
      if (tStart > 0 && tEnd < 1) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        const newTEnd = (tEnd - tStart) / (1 - tStart);
        const [left] = splitCubicBezier(right[0], right[1], right[2], right[3], newTEnd);
        trimmedPoints = left;
      } else if (tStart > 0) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        trimmedPoints = right;
      } else if (tEnd < 1) {
        const [left] = splitCubicBezier(p0, p1, p2, p3, tEnd);
        trimmedPoints = left;
      } else {
        trimmedPoints = [p0, p1, p2, p3];
      }
      if (!inTrimRegion || result.length === 0) {
        result.push({
          point: trimmedPoints[0],
          inHandle: { x: 0, y: 0 },
          outHandle: subtractPoints(trimmedPoints[1], trimmedPoints[0])
        });
        inTrimRegion = true;
      } else if (lastPoint && distance$1(lastPoint, trimmedPoints[0]) > 0.01) {
        if (result.length > 0) {
          result[result.length - 1].outHandle = subtractPoints(trimmedPoints[1], result[result.length - 1].point);
        }
      }
      result.push({
        point: trimmedPoints[3],
        inHandle: subtractPoints(trimmedPoints[2], trimmedPoints[3]),
        outHandle: { x: 0, y: 0 }
      });
      lastPoint = trimmedPoints[3];
    }
    accumulatedLength += segmentLength;
  }
  return { vertices: result, closed: false };
}
function joinPaths(path1, path2) {
  if (path1.vertices.length === 0) return clonePath(path2);
  if (path2.vertices.length === 0) return clonePath(path1);
  const result = clonePath(path1);
  const p2Verts = path2.vertices.map(cloneVertex);
  const lastP1 = result.vertices[result.vertices.length - 1];
  const firstP2 = p2Verts[0];
  if (distance$1(lastP1.point, firstP2.point) < 0.01) {
    lastP1.outHandle = firstP2.outHandle;
    result.vertices.push(...p2Verts.slice(1));
  } else {
    result.vertices.push(...p2Verts);
  }
  return result;
}
function mergePaths(paths, mode) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const polygons = paths.map(pathToPolygon);
  let result = [polygons[0]];
  for (let i = 1; i < polygons.length; i++) {
    const newPolygons = [];
    for (const existing of result) {
      switch (mode) {
        case "add":
          newPolygons.push(...polygonUnion(existing, polygons[i]));
          break;
        case "subtract":
        case "minusFront":
          newPolygons.push(...polygonDifference(existing, polygons[i]));
          break;
        case "minusBack":
          newPolygons.push(...polygonDifference(polygons[i], existing));
          break;
        case "intersect":
          newPolygons.push(...polygonIntersection(existing, polygons[i]));
          break;
        case "exclude":
          newPolygons.push(...polygonXor(existing, polygons[i]));
          break;
      }
    }
    result = newPolygons;
  }
  return result.map(polygonToPath);
}
function booleanOperation(paths, operation, segmentsPerCurve = 32) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const multiPolygons = paths.map((path) => {
    const polygon = pathToPolygon(path, segmentsPerCurve);
    return [point2DArrayToPolygon(polygon)];
  });
  let result;
  try {
    if (multiPolygons.length === 0) {
      return [];
    }
    if (multiPolygons.length === 1) {
      return [clonePath(paths[0])];
    }
    switch (operation) {
      case "union":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.union(result, multiPolygons[i]);
        }
        break;
      case "subtract":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.difference(result, multiPolygons[i]);
        }
        break;
      case "intersect":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.intersection(result, multiPolygons[i]);
        }
        break;
      case "exclude":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.xor(result, multiPolygons[i]);
        }
        break;
      default:
        return paths.map(clonePath);
    }
  } catch {
    return paths.map(clonePath);
  }
  const outputPaths = [];
  for (const polygon of result) {
    if (polygon.length > 0) {
      const points = ringToPoint2DArray(polygon[0]);
      if (points.length >= 3) {
        const bezierPath = fitBezierToPolygon(points, true);
        outputPaths.push(bezierPath);
      }
    }
  }
  return outputPaths;
}
function fitBezierToPolygon(points, closed) {
  if (points.length < 2) {
    return { vertices: [], closed };
  }
  const simplified = simplifyPolygon(points, 0.5);
  if (simplified.length < 2) {
    return polygonToPath(points);
  }
  const vertices = [];
  for (let i = 0; i < simplified.length; i++) {
    const curr = simplified[i];
    const prev = simplified[(i - 1 + simplified.length) % simplified.length];
    const next = simplified[(i + 1) % simplified.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const distPrev = distance$1(curr, prev);
    const distNext = distance$1(curr, next);
    const handleScale = 0.25;
    let inHandle;
    let outHandle;
    {
      const tangent = normalize(subtractPoints(toNext, toPrev));
      inHandle = scalePoint$1(tangent, -distPrev * handleScale);
      outHandle = scalePoint$1(tangent, distNext * handleScale);
    }
    vertices.push({
      point: clonePoint(curr),
      inHandle,
      outHandle
    });
  }
  return { vertices, closed };
}
function simplifyPolygon(points, tolerance) {
  if (points.length <= 2) return points;
  let maxDist = 0;
  let maxIndex = 0;
  const first = points[0];
  const last = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const d = perpendicularDistance(points[i], first, last);
    if (d > maxDist) {
      maxDist = d;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = simplifyPolygon(points.slice(0, maxIndex + 1), tolerance);
    const right = simplifyPolygon(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  }
  return [first, last];
}
function perpendicularDistance(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const lineLengthSq = dx * dx + dy * dy;
  if (lineLengthSq === 0) {
    return distance$1(point, lineStart);
  }
  const t = Math.max(0, Math.min(
    1,
    ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq
  ));
  const projection = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return distance$1(point, projection);
}
function pathToPolygon(path, segments = 16) {
  const points = [];
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    for (let j = 0; j < segments; j++) {
      const t = j / segments;
      points.push(cubicBezierPoint(p0, p1, p2, p3, t));
    }
  }
  return points;
}
function polygonToPath(polygon) {
  const vertices = polygon.map((p) => ({
    point: clonePoint(p),
    inHandle: { x: 0, y: 0 },
    outHandle: { x: 0, y: 0 }
  }));
  return { vertices, closed: true };
}
function point2DArrayToRing(points) {
  return points.map((p) => [p.x, p.y]);
}
function ringToPoint2DArray(ring) {
  return ring.map(([x, y]) => ({ x, y }));
}
function point2DArrayToPolygon(points) {
  return [point2DArrayToRing(points)];
}
function multiPolygonToPoint2DArrays(multiPoly) {
  const result = [];
  for (const polygon of multiPoly) {
    if (polygon.length > 0) {
      result.push(ringToPoint2DArray(polygon[0]));
    }
  }
  return result;
}
function polygonUnion(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.union([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a, b];
  }
}
function polygonDifference(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.difference([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a];
  }
}
function polygonIntersection(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.intersection([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [];
  }
}
function polygonXor(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.xor([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a, b];
  }
}
function offsetPath(path, amount, join = "miter", miterLimit = 4) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  const isClosed = path.closed;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    let inDir;
    let outDir;
    if (i === 0 && !isClosed) {
      inDir = { x: 0, y: 0 };
      outDir = normalize(subtractPoints(
        addPoints(next.point, next.inHandle),
        addPoints(curr.point, curr.outHandle)
      ));
    } else if (i === numVertices - 1 && !isClosed) {
      inDir = normalize(subtractPoints(
        addPoints(curr.point, curr.inHandle),
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = { x: 0, y: 0 };
    } else {
      inDir = normalize(subtractPoints(
        curr.point,
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = normalize(subtractPoints(
        addPoints(curr.point, curr.outHandle),
        curr.point
      ));
    }
    let offsetDir;
    if (Math.abs(inDir.x) < 1e-3 && Math.abs(inDir.y) < 1e-3) {
      offsetDir = perpendicular(outDir);
    } else if (Math.abs(outDir.x) < 1e-3 && Math.abs(outDir.y) < 1e-3) {
      offsetDir = perpendicular(inDir);
    } else {
      const perpIn = perpendicular(inDir);
      const perpOut = perpendicular(outDir);
      offsetDir = normalize(addPoints(perpIn, perpOut));
      const angle = Math.acos(Math.max(-1, Math.min(1, dot(inDir, outDir))));
      if (angle > 0.01) {
        const miterFactor = 1 / Math.cos(angle / 2);
        if (join === "miter" && miterFactor <= miterLimit) {
          offsetDir = scalePoint$1(offsetDir, miterFactor);
        }
      }
    }
    const newPoint = addPoints(curr.point, scalePoint$1(offsetDir, amount));
    const handleScale = 1;
    result.push({
      point: newPoint,
      inHandle: scalePoint$1(curr.inHandle, handleScale),
      outHandle: scalePoint$1(curr.outHandle, handleScale)
    });
  }
  return { vertices: result, closed: isClosed };
}
function offsetPathMultiple(path, baseAmount, copies, copyOffset, join = "miter", miterLimit = 4) {
  const results = [clonePath(path)];
  for (let i = 1; i < copies; i++) {
    const amount = baseAmount + copyOffset * i;
    results.push(offsetPath(path, amount, join, miterLimit));
  }
  return results;
}
function puckerBloat(path, amount) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const centroid = { x: 0, y: 0 };
  for (const v of path.vertices) {
    centroid.x += v.point.x;
    centroid.y += v.point.y;
  }
  centroid.x /= path.vertices.length;
  centroid.y /= path.vertices.length;
  const factor = amount / 100;
  const result = path.vertices.map((v) => {
    const dir = subtractPoints(v.point, centroid);
    const dist = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
    if (dist < 1e-3) return cloneVertex(v);
    const moveAmount = dist * factor;
    const newPoint = addPoints(v.point, scalePoint$1(normalize(dir), moveAmount));
    const handleFactor = 1 + factor * 0.5;
    return {
      point: newPoint,
      inHandle: scalePoint$1(v.inHandle, handleFactor),
      outHandle: scalePoint$1(v.outHandle, handleFactor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function wigglePath(path, size, detail, pointType, correlation, temporalPhase, spatialPhase, seed) {
  if (path.vertices.length < 2 || size < 1e-3) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  for (let i = 0; i < Math.floor(temporalPhase * 100); i++) {
    rng.next();
  }
  const correlationFactor = correlation / 100;
  const result = [];
  const subdividedPath = subdividePath(path, Math.max(1, Math.floor(detail)));
  let prevOffset = { x: 0, y: 0 };
  for (let i = 0; i < subdividedPath.vertices.length; i++) {
    const v = subdividedPath.vertices[i];
    const angle = rng.next() * Math.PI * 2 + spatialPhase;
    const magnitude = rng.next() * size;
    const newOffset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const offset = {
      x: prevOffset.x * correlationFactor + newOffset.x * (1 - correlationFactor),
      y: prevOffset.y * correlationFactor + newOffset.y * (1 - correlationFactor)
    };
    prevOffset = offset;
    const newVertex = {
      point: addPoints(v.point, offset),
      inHandle: pointType === "smooth" ? clonePoint(v.inHandle) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? clonePoint(v.outHandle) : { x: 0, y: 0 }
    };
    result.push(newVertex);
  }
  return { vertices: result, closed: path.closed };
}
function subdividePath(path, levels = 1) {
  if (levels <= 0) return clonePath(path);
  let current = clonePath(path);
  for (let level = 0; level < levels; level++) {
    const result = [];
    const numSegments = current.closed ? current.vertices.length : current.vertices.length - 1;
    for (let i = 0; i < numSegments; i++) {
      const v0 = current.vertices[i];
      const v1 = current.vertices[(i + 1) % current.vertices.length];
      const p0 = v0.point;
      const p1 = addPoints(v0.point, v0.outHandle);
      const p2 = addPoints(v1.point, v1.inHandle);
      const p3 = v1.point;
      const [left, right] = splitCubicBezier(p0, p1, p2, p3, 0.5);
      result.push({
        point: left[0],
        inHandle: i === 0 ? v0.inHandle : subtractPoints(left[1], left[0]),
        outHandle: subtractPoints(left[1], left[0])
      });
      result.push({
        point: left[3],
        inHandle: subtractPoints(left[2], left[3]),
        outHandle: subtractPoints(right[1], right[0])
      });
    }
    if (!current.closed) {
      const lastV = current.vertices[current.vertices.length - 1];
      result.push(cloneVertex(lastV));
    }
    current = { vertices: result, closed: current.closed };
  }
  return current;
}
function zigZagPath(path, size, ridgesPerSegment, pointType) {
  if (path.vertices.length < 2 || size < 1e-3 || ridgesPerSegment < 1) {
    return clonePath(path);
  }
  const result = [];
  const totalLength = getPathLength(path);
  const ridgeLength = totalLength / (ridgesPerSegment * (path.vertices.length - (path.closed ? 0 : 1)));
  let currentDistance = 0;
  let zigDirection = 1;
  while (currentDistance < totalLength) {
    const pointData = getPointAtDistance(path, currentDistance, totalLength);
    if (!pointData) break;
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint$1(perp, size * zigDirection);
    const vertex = {
      point: addPoints(pointData.point, offset),
      inHandle: pointType === "smooth" ? scalePoint$1(pointData.tangent, -ridgeLength * 0.3) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? scalePoint$1(pointData.tangent, ridgeLength * 0.3) : { x: 0, y: 0 }
    };
    result.push(vertex);
    currentDistance += ridgeLength;
    zigDirection *= -1;
  }
  if (result.length > 0 && !path.closed) {
    const lastVertex = path.vertices[path.vertices.length - 1];
    result.push({
      point: clonePoint(lastVertex.point),
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function roughenPath(path, size, detail, seed, relative = false) {
  if (path.vertices.length < 2 || size < 1e-3 || detail < 1) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  const result = [];
  let actualSize = size;
  if (relative) {
    const bounds = getPathBounds(path);
    const diagonal = Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height);
    actualSize = size / 100 * diagonal;
  }
  const subdivided = subdividePath(path, Math.max(1, Math.floor(detail)));
  for (const v of subdivided.vertices) {
    const angle = rng.next() * Math.PI * 2;
    const magnitude = rng.next() * actualSize;
    const offset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const newPoint = addPoints(v.point, offset);
    const handleRoughness = actualSize * 0.5;
    const handleAngle1 = rng.next() * Math.PI * 2;
    const handleMag1 = rng.next() * handleRoughness;
    const handleAngle2 = rng.next() * Math.PI * 2;
    const handleMag2 = rng.next() * handleRoughness;
    result.push({
      point: newPoint,
      inHandle: addPoints(v.inHandle, {
        x: Math.cos(handleAngle1) * handleMag1,
        y: Math.sin(handleAngle1) * handleMag1
      }),
      outHandle: addPoints(v.outHandle, {
        x: Math.cos(handleAngle2) * handleMag2,
        y: Math.sin(handleAngle2) * handleMag2
      })
    });
  }
  return { vertices: result, closed: path.closed };
}
function wavePath(path, amplitude, frequency, phase = 0, waveType = "sine") {
  if (path.vertices.length < 2 || amplitude < 1e-3 || frequency < 0.1) {
    return clonePath(path);
  }
  const totalLength = getPathLength(path);
  if (totalLength < 1e-3) return clonePath(path);
  const samplesPerWave = 16;
  const totalSamples = Math.max(4, Math.ceil(frequency * samplesPerWave));
  const sampleDistance = totalLength / totalSamples;
  const result = [];
  for (let i = 0; i <= totalSamples; i++) {
    const distance2 = Math.min(i * sampleDistance, totalLength - 1e-3);
    const pointData = getPointAtDistance(path, distance2, totalLength);
    if (!pointData) continue;
    const t = distance2 / totalLength;
    const waveInput = t * frequency * Math.PI * 2 + phase;
    let waveValue;
    switch (waveType) {
      case "triangle":
        waveValue = Math.abs(waveInput / Math.PI % 2 - 1) * 2 - 1;
        break;
      case "square":
        waveValue = Math.sin(waveInput) >= 0 ? 1 : -1;
        break;
      case "sine":
      default:
        waveValue = Math.sin(waveInput);
    }
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint$1(perp, waveValue * amplitude);
    const newPoint = addPoints(pointData.point, offset);
    const handleLength = sampleDistance * 0.3;
    const inHandle = scalePoint$1(pointData.tangent, -handleLength);
    const outHandle = scalePoint$1(pointData.tangent, handleLength);
    result.push({
      point: newPoint,
      inHandle,
      outHandle
    });
  }
  return { vertices: result, closed: path.closed };
}
function getPathBounds(path) {
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minX = Math.min(minX, v.point.x);
    minY = Math.min(minY, v.point.y);
    maxX = Math.max(maxX, v.point.x);
    maxY = Math.max(maxY, v.point.y);
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function twistPath(path, angle, center) {
  if (path.vertices.length < 2 || Math.abs(angle) < 1e-3) {
    return clonePath(path);
  }
  let minY = Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minY = Math.min(minY, v.point.y);
    maxY = Math.max(maxY, v.point.y);
  }
  const height = maxY - minY;
  if (height < 1e-3) return clonePath(path);
  const angleRad = angle * Math.PI / 180;
  const result = path.vertices.map((v) => {
    const yNorm = (v.point.y - minY) / height;
    const localAngle = angleRad * yNorm;
    const rotatedPoint = rotateAround(v.point, center, localAngle);
    const absInHandle = addPoints(v.point, v.inHandle);
    const absOutHandle = addPoints(v.point, v.outHandle);
    const rotatedIn = rotateAround(absInHandle, center, localAngle);
    const rotatedOut = rotateAround(absOutHandle, center, localAngle);
    return {
      point: rotatedPoint,
      inHandle: subtractPoints(rotatedIn, rotatedPoint),
      outHandle: subtractPoints(rotatedOut, rotatedPoint)
    };
  });
  return { vertices: result, closed: path.closed };
}
function roundCorners(path, radius) {
  if (path.vertices.length < 2 || radius < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    if (!path.closed && (i === 0 || i === numVertices - 1)) {
      result.push(cloneVertex(curr));
      continue;
    }
    const toPrev = normalize(subtractPoints(prev.point, curr.point));
    const toNext = normalize(subtractPoints(next.point, curr.point));
    const dotProduct = dot(toPrev, toNext);
    if (dotProduct > 0.99) {
      result.push(cloneVertex(curr));
      continue;
    }
    const distPrev = distance$1(curr.point, prev.point);
    const distNext = distance$1(curr.point, next.point);
    const maxRadius = Math.min(radius, distPrev / 2, distNext / 2);
    const startPoint = addPoints(curr.point, scalePoint$1(toPrev, maxRadius));
    const endPoint = addPoints(curr.point, scalePoint$1(toNext, maxRadius));
    const kappa = 0.5522847498;
    const handleLength = maxRadius * kappa;
    result.push({
      point: startPoint,
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint$1(toPrev, -handleLength)
    });
    result.push({
      point: endPoint,
      inHandle: scalePoint$1(toNext, -handleLength),
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function generateRectangle(position, size, roundness = 0, direction = 1) {
  const hw = size.x / 2;
  const hh = size.y / 2;
  const r = Math.min(roundness, hw, hh);
  const corners = [
    { x: position.x - hw, y: position.y - hh },
    // TL
    { x: position.x + hw, y: position.y - hh },
    // TR
    { x: position.x + hw, y: position.y + hh },
    // BR
    { x: position.x - hw, y: position.y + hh }
    // BL
  ];
  if (direction === -1) {
    corners.reverse();
  }
  if (r < 0.01) {
    return {
      vertices: corners.map((p) => ({
        point: p,
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      })),
      closed: true
    };
  }
  const kappa = 0.5522847498 * r;
  const vertices = [];
  for (let i = 0; i < 4; i++) {
    const curr = corners[i];
    const next = corners[(i + 1) % 4];
    const dir = normalize(subtractPoints(next, curr));
    vertices.push({
      point: addPoints(curr, scalePoint$1(dir, r)),
      inHandle: scalePoint$1(dir, -kappa),
      outHandle: { x: 0, y: 0 }
    });
    vertices.push({
      point: subtractPoints(next, scalePoint$1(dir, r)),
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint$1(dir, kappa)
    });
  }
  return { vertices, closed: true };
}
function generateEllipse(position, size, direction = 1) {
  const rx = size.x / 2;
  const ry = size.y / 2;
  const kappa = 0.5522847498;
  let vertices = [
    {
      // Top
      point: { x: position.x, y: position.y - ry },
      inHandle: { x: -rx * kappa, y: 0 },
      outHandle: { x: rx * kappa, y: 0 }
    },
    {
      // Right
      point: { x: position.x + rx, y: position.y },
      inHandle: { x: 0, y: -ry * kappa },
      outHandle: { x: 0, y: ry * kappa }
    },
    {
      // Bottom
      point: { x: position.x, y: position.y + ry },
      inHandle: { x: rx * kappa, y: 0 },
      outHandle: { x: -rx * kappa, y: 0 }
    },
    {
      // Left
      point: { x: position.x - rx, y: position.y },
      inHandle: { x: 0, y: ry * kappa },
      outHandle: { x: 0, y: -ry * kappa }
    }
  ];
  if (direction === -1) {
    vertices = vertices.reverse().map((v) => ({
      point: v.point,
      inHandle: v.outHandle,
      outHandle: v.inHandle
    }));
  }
  return { vertices, closed: true };
}
function generatePolygon(position, points, radius, roundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI * 2 / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints; i++) {
    const idx = direction === 1 ? i : numPoints - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.5;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function generateStar(position, points, outerRadius, innerRadius, outerRoundness = 0, innerRoundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints * 2; i++) {
    const idx = direction === 1 ? i : numPoints * 2 - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const isOuter = idx % 2 === 0;
    const radius = isOuter ? outerRadius : innerRadius;
    const roundness = isOuter ? outerRoundness : innerRoundness;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.3;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function simplifyPath(path, tolerance, straightLines = false) {
  if (path.vertices.length <= 2) return clonePath(path);
  const points = pathToPolygon(path, 32);
  const simplified = douglasPeucker(points, tolerance);
  if (straightLines) {
    return polygonToPath(simplified);
  } else {
    return fitBezierToPoints(simplified, path.closed);
  }
}
function douglasPeucker(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDistance(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeucker(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function fitBezierToPoints(points, closed) {
  const vertices = [];
  for (let i = 0; i < points.length; i++) {
    const prev = points[(i - 1 + points.length) % points.length];
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const handleLength = Math.min(
      distance$1(curr, prev) * 0.3,
      distance$1(curr, next) * 0.3
    );
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    vertices.push({
      point: clonePoint(curr),
      inHandle: scalePoint$1(avgDir, -handleLength),
      outHandle: scalePoint$1(avgDir, handleLength)
    });
  }
  return { vertices, closed };
}
function smoothPath(path, amount) {
  if (path.vertices.length < 2) return clonePath(path);
  const factor = amount / 100;
  const result = path.vertices.map((v, i) => {
    const prev = path.vertices[(i - 1 + path.vertices.length) % path.vertices.length];
    const next = path.vertices[(i + 1) % path.vertices.length];
    const toPrev = subtractPoints(prev.point, v.point);
    const toNext = subtractPoints(next.point, v.point);
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    const idealHandleLength = (distance$1(v.point, prev.point) + distance$1(v.point, next.point)) / 6;
    const idealIn = scalePoint$1(avgDir, -idealHandleLength);
    const idealOut = scalePoint$1(avgDir, idealHandleLength);
    return {
      point: clonePoint(v.point),
      inHandle: lerpPoint(v.inHandle, idealIn, factor),
      outHandle: lerpPoint(v.outHandle, idealOut, factor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function applyRepeater(paths, copies, offset, anchorPoint, position, scale, rotation, startOpacity, endOpacity) {
  const results = [];
  for (let i = 0; i < copies; i++) {
    const t = copies > 1 ? i / (copies - 1) : 0;
    const copyRotation = rotation * i;
    const copyScale = {
      x: 100 + (scale.x - 100) * i,
      y: 100 + (scale.y - 100) * i
    };
    const copyPosition = {
      x: position.x * i,
      y: position.y * i
    };
    const copyOpacity = startOpacity + (endOpacity - startOpacity) * t;
    const transformedPaths = paths.map((path) => {
      return transformPath(path, anchorPoint, copyPosition, copyScale, copyRotation);
    });
    results.push({
      paths: transformedPaths,
      opacities: paths.map(() => copyOpacity / 100)
    });
  }
  return results;
}
function transformPath(path, anchorPoint, position, scale, rotation) {
  const rotRad = rotation * Math.PI / 180;
  const cos = Math.cos(rotRad);
  const sin = Math.sin(rotRad);
  const transformPoint = (p) => {
    let x = p.x - anchorPoint.x;
    let y = p.y - anchorPoint.y;
    x *= scale.x / 100;
    y *= scale.y / 100;
    const rx = x * cos - y * sin;
    const ry = x * sin + y * cos;
    return {
      x: rx + anchorPoint.x + position.x,
      y: ry + anchorPoint.y + position.y
    };
  };
  const vertices = path.vertices.map((v) => {
    const newPoint = transformPoint(v.point);
    const absIn = addPoints(v.point, v.inHandle);
    const absOut = addPoints(v.point, v.outHandle);
    const newIn = transformPoint(absIn);
    const newOut = transformPoint(absOut);
    return {
      point: newPoint,
      inHandle: subtractPoints(newIn, newPoint),
      outHandle: subtractPoints(newOut, newPoint)
    };
  });
  return { vertices, closed: path.closed };
}
const ShapeOperations = {
  // Utilities
  distance: distance$1,
  lerpPoint,
  addPoints,
  subtractPoints,
  scalePoint: scalePoint$1,
  normalize,
  perpendicular,
  clonePath,
  // Bezier
  cubicBezierPoint,
  cubicBezierLength,
  getPathLength,
  getPointAtDistance,
  splitCubicBezier,
  // Path operators
  trimPath,
  mergePaths,
  offsetPath,
  offsetPathMultiple,
  puckerBloat,
  wigglePath,
  zigZagPath,
  roughenPath,
  wavePath,
  twistPath,
  roundCorners,
  booleanOperation,
  // Generators
  generateRectangle,
  generateEllipse,
  generatePolygon,
  generateStar,
  // Illustrator features
  simplifyPath,
  smoothPath,
  // Repeater
  applyRepeater,
  transformPath
};

const logger$3 = createLogger("VectorLOD");
const DEFAULT_LOD_CONFIG = {
  enabled: true,
  mode: "both",
  levels: [],
  maxPointsForPreview: 100,
  simplificationTolerance: 2,
  cullingEnabled: true,
  cullMargin: 50
};
class VectorLODService {
  // Cache for generated LOD levels by layer ID
  lodCache = /* @__PURE__ */ new Map();
  /**
   * Generate LOD levels for a set of control points
   *
   * @param layerId Layer ID for caching (optional - pass empty string to skip caching)
   * @param controlPoints Original high-quality points
   * @param levelCount Number of LOD levels to generate
   * @param baseTolerance Base tolerance for simplification
   * @returns Array of LOD levels from highest to lowest quality
   */
  generateLODLevels(layerId, controlPoints, levelCount = 4, baseTolerance = 2) {
    if (layerId && this.lodCache.has(layerId)) {
      return this.lodCache.get(layerId);
    }
    const levels = [];
    const originalCount = controlPoints.length;
    levels.push({
      tolerance: 0,
      controlPoints: [...controlPoints],
      pointCount: originalCount,
      complexity: 1
    });
    const toleranceMultipliers = [0.5, 1, 2, 5, 10];
    for (let i = 0; i < Math.min(levelCount - 1, toleranceMultipliers.length); i++) {
      const tolerance = baseTolerance * toleranceMultipliers[i];
      const simplified = this.simplifyPath(controlPoints, tolerance);
      const prevCount = levels[levels.length - 1].pointCount;
      if (simplified.length < prevCount * 0.9) {
        levels.push({
          tolerance,
          controlPoints: simplified,
          pointCount: simplified.length,
          complexity: simplified.length / originalCount
        });
      }
    }
    if (layerId) {
      this.lodCache.set(layerId, levels);
    }
    logger$3.debug("Generated LOD levels:", levels.map((l) => l.pointCount));
    return levels;
  }
  /**
   * Clear LOD cache for a specific layer or all layers
   */
  clearCache(layerId) {
    if (layerId) {
      this.lodCache.delete(layerId);
    } else {
      this.lodCache.clear();
    }
  }
  /**
   * Select appropriate LOD level based on context
   */
  selectLODLevel(levels, context) {
    if (levels.length === 0) {
      throw new Error("No LOD levels available");
    }
    if (levels.length === 1) {
      return levels[0];
    }
    let targetQuality = 1;
    if (context.zoom < 1) {
      targetQuality *= Math.max(0.2, context.zoom);
    }
    if (context.isPlaying) {
      targetQuality *= 0.7;
    }
    if (context.targetFPS && context.currentFPS) {
      const fpsRatio = context.currentFPS / context.targetFPS;
      if (fpsRatio < 0.8) {
        targetQuality *= fpsRatio;
      }
    }
    let bestLevel = levels[0];
    let bestDiff = Math.abs((levels[0].complexity ?? 0) - targetQuality);
    for (const level of levels) {
      const diff = Math.abs((level.complexity ?? 0) - targetQuality);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestLevel = level;
      }
    }
    return bestLevel;
  }
  /**
   * Cull points outside viewport
   * Returns indices of visible points
   */
  cullOffScreenPoints(points, viewport, margin = 50) {
    const minX = viewport.x - margin;
    const minY = viewport.y - margin;
    const maxX = viewport.x + viewport.width + margin;
    const maxY = viewport.y + viewport.height + margin;
    const visible = /* @__PURE__ */ new Set();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      if (p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY) {
        visible.add(Math.max(0, i - 1));
        visible.add(i);
        visible.add(Math.min(points.length - 1, i + 1));
      }
    }
    if (visible.size === 0) {
      return [];
    }
    const culled = [];
    for (let i = 0; i < points.length; i++) {
      if (visible.has(i)) {
        culled.push(points[i]);
      }
    }
    return culled;
  }
  /**
   * Simplify path using Ramer-Douglas-Peucker algorithm
   */
  simplifyPath(points, tolerance) {
    if (points.length <= 2) return [...points];
    const simplePoints = points.map((p) => ({ x: p.x, y: p.y }));
    const simplified = this.rdpSimplify(simplePoints, tolerance);
    const result = [];
    let simplifiedIndex = 0;
    for (let i = 0; i < points.length && simplifiedIndex < simplified.length; i++) {
      const p = points[i];
      const s = simplified[simplifiedIndex];
      if (Math.abs(p.x - s.x) < 0.01 && Math.abs(p.y - s.y) < 0.01) {
        result.push({ ...p });
        simplifiedIndex++;
      }
    }
    if (result.length < 2 && points.length >= 2) {
      return [points[0], points[points.length - 1]];
    }
    return result;
  }
  /**
   * Ramer-Douglas-Peucker line simplification
   */
  rdpSimplify(points, tolerance) {
    if (points.length <= 2) return points;
    let maxDist = 0;
    let maxIndex = 0;
    const first = points[0];
    const last = points[points.length - 1];
    for (let i = 1; i < points.length - 1; i++) {
      const d = this.perpendicularDistance(points[i], first, last);
      if (d > maxDist) {
        maxDist = d;
        maxIndex = i;
      }
    }
    if (maxDist > tolerance) {
      const left = this.rdpSimplify(points.slice(0, maxIndex + 1), tolerance);
      const right = this.rdpSimplify(points.slice(maxIndex), tolerance);
      return [...left.slice(0, -1), ...right];
    }
    return [first, last];
  }
  /**
   * Calculate perpendicular distance from point to line
   */
  perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lineLengthSq = dx * dx + dy * dy;
    if (lineLengthSq === 0) {
      return Math.sqrt(
        (point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2
      );
    }
    const t = Math.max(0, Math.min(
      1,
      ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq
    ));
    const projX = lineStart.x + t * dx;
    const projY = lineStart.y + t * dy;
    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
  }
  /**
   * Estimate rendering complexity of a path
   */
  estimateComplexity(points) {
    let complexity = points.length;
    for (const p of points) {
      if (p.handleIn || p.handleOut) {
        complexity += 0.5;
      }
    }
    return complexity;
  }
  /**
   * Check if LOD should be used for a spline
   */
  shouldUseLOD(splineData, context) {
    if (!splineData.lod?.enabled) return false;
    const pointCount = splineData.controlPoints.length;
    if (pointCount < 50) return false;
    if (context.isPlaying && splineData.lod.mode !== "zoom") return true;
    if (context.zoom < 0.5 && splineData.lod.mode !== "playback") return true;
    return false;
  }
  /**
   * Auto-generate LOD config for a spline if point count exceeds threshold
   */
  autoGenerateLOD(splineData, threshold = 200) {
    if (splineData.controlPoints.length < threshold) {
      return null;
    }
    const levels = this.generateLODLevels("", splineData.controlPoints, 4, 2);
    return {
      ...DEFAULT_LOD_CONFIG,
      enabled: true,
      levels
    };
  }
}
const vectorLODService = new VectorLODService();
const vectorLOD = vectorLODService;

const DEFAULT_WARP_WEIGHT_OPTIONS = {
  method: "inverse-distance",
  falloffPower: 2,
  normalize: true,
  minWeight: 1e-3
};

const logger$2 = createLogger("MeshWarpDeformation");
function distance(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function rotatePoint(point, origin, angleDegrees) {
  const angleRadians = angleDegrees * Math.PI / 180;
  const cos = Math.cos(angleRadians);
  const sin = Math.sin(angleRadians);
  const dx = point.x - origin.x;
  const dy = point.y - origin.y;
  return {
    x: origin.x + dx * cos - dy * sin,
    y: origin.y + dx * sin + dy * cos
  };
}
function scalePoint(point, origin, scale) {
  return {
    x: origin.x + (point.x - origin.x) * scale,
    y: origin.y + (point.y - origin.y) * scale
  };
}
function delaunayTriangulate(points) {
  if (points.length < 3) {
    return [];
  }
  const minX = Math.min(...points.map((p) => p.x));
  const maxX = Math.max(...points.map((p) => p.x));
  const minY = Math.min(...points.map((p) => p.y));
  const maxY = Math.max(...points.map((p) => p.y));
  const dx = maxX - minX;
  const dy = maxY - minY;
  const deltaMax = Math.max(dx, dy) * 2;
  const superA = { x: minX - deltaMax, y: minY - deltaMax };
  const superB = { x: minX + deltaMax * 2, y: minY - deltaMax };
  const superC = { x: minX + deltaMax / 2, y: maxY + deltaMax * 2 };
  const allPoints = [...points, superA, superB, superC];
  const superIndices = [points.length, points.length + 1, points.length + 2];
  let triangles = [{ a: superIndices[0], b: superIndices[1], c: superIndices[2] }];
  for (let i = 0; i < points.length; i++) {
    const point = points[i];
    const badTriangles = [];
    const polygon = [];
    for (const tri of triangles) {
      if (isPointInCircumcircle(point, allPoints[tri.a], allPoints[tri.b], allPoints[tri.c])) {
        badTriangles.push(tri);
      }
    }
    for (const tri of badTriangles) {
      const edges = [
        { a: tri.a, b: tri.b },
        { a: tri.b, b: tri.c },
        { a: tri.c, b: tri.a }
      ];
      for (const edge of edges) {
        let isShared = false;
        for (const other of badTriangles) {
          if (other === tri) continue;
          const otherEdges = [
            { a: other.a, b: other.b },
            { a: other.b, b: other.c },
            { a: other.c, b: other.a }
          ];
          for (const otherEdge of otherEdges) {
            if (edge.a === otherEdge.a && edge.b === otherEdge.b || edge.a === otherEdge.b && edge.b === otherEdge.a) {
              isShared = true;
              break;
            }
          }
          if (isShared) break;
        }
        if (!isShared) {
          polygon.push(edge);
        }
      }
    }
    triangles = triangles.filter((t) => !badTriangles.includes(t));
    for (const edge of polygon) {
      triangles.push({ a: edge.a, b: edge.b, c: i });
    }
  }
  return triangles.filter(
    (t) => !superIndices.includes(t.a) && !superIndices.includes(t.b) && !superIndices.includes(t.c)
  );
}
function isPointInCircumcircle(point, a, b, c) {
  const ax = a.x - point.x;
  const ay = a.y - point.y;
  const bx = b.x - point.x;
  const by = b.y - point.y;
  const cx = c.x - point.x;
  const cy = c.y - point.y;
  const det = (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay);
  const orientation = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
  return orientation > 0 ? det > 0 : det < 0;
}
function calculateWeights(vertices, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
  const vertexCount = vertices.length / 2;
  const pinCount = pins.length;
  if (pinCount === 0) {
    return new Float32Array(0);
  }
  const weights = new Float32Array(vertexCount * pinCount);
  for (let v = 0; v < vertexCount; v++) {
    const vx = vertices[v * 2];
    const vy = vertices[v * 2 + 1];
    let totalWeight = 0;
    const vertexWeights = [];
    for (let p = 0; p < pinCount; p++) {
      const pin = pins[p];
      const pinPos = pin.position.value;
      const dist = distance({ x: vx, y: vy }, pinPos);
      let weight;
      switch (options.method) {
        case "bounded":
        case "radial-basis":
        case "heat-diffusion":
        case "inverse-distance":
        default: {
          if (dist < 1e-3) {
            weight = 1e3;
          } else if (dist > pin.radius * 3) {
            weight = 0;
          } else {
            const normalizedDist = dist / pin.radius;
            weight = Math.pow(1 / (1 + normalizedDist), options.falloffPower);
            if (pin.stiffness > 0) {
              weight *= 1 - pin.stiffness * 0.5;
            }
          }
          break;
        }
      }
      if (weight < options.minWeight) {
        weight = 0;
      }
      vertexWeights.push(weight);
      totalWeight += weight;
    }
    for (let p = 0; p < pinCount; p++) {
      let finalWeight = vertexWeights[p];
      if (options.normalize && totalWeight > 0) {
        finalWeight = finalWeight / totalWeight;
      }
      weights[v * pinCount + p] = finalWeight;
    }
  }
  return weights;
}
function evaluatePinAtFrame(pin, restState, frame) {
  const position = {
    x: interpolateProperty(pin.position, frame).x,
    y: interpolateProperty(pin.position, frame).y
  };
  const rotation = interpolateProperty(pin.rotation, frame);
  const scale = interpolateProperty(pin.scale, frame);
  const delta = {
    x: position.x - restState.position.x,
    y: position.y - restState.position.y
  };
  return { position, rotation, scale, delta };
}
function deformMesh(mesh, frame) {
  const { originalVertices, pins, weights, pinRestStates, vertexCount } = mesh;
  const pinCount = pins.length;
  if (pinCount === 0 || vertexCount === 0) {
    return new Float32Array(originalVertices);
  }
  const pinStates = pins.map(
    (pin, i) => evaluatePinAtFrame(pin, pinRestStates[i], frame)
  );
  const deformedVertices = new Float32Array(vertexCount * 2);
  for (let v = 0; v < vertexCount; v++) {
    const origX = originalVertices[v * 2];
    const origY = originalVertices[v * 2 + 1];
    let deformedX = 0;
    let deformedY = 0;
    let totalWeight = 0;
    for (let p = 0; p < pinCount; p++) {
      const weight = weights[v * pinCount + p];
      if (weight <= 0) continue;
      const pin = pins[p];
      const pinState = pinStates[p];
      const restState = pinRestStates[p];
      let pinDeformed = { x: origX, y: origY };
      pinDeformed = {
        x: pinDeformed.x + pinState.delta.x,
        y: pinDeformed.y + pinState.delta.y
      };
      if (pin.type === "rotation" || Math.abs(pinState.rotation - restState.rotation) > 1e-3) {
        const rotationDelta = pinState.rotation - restState.rotation;
        pinDeformed = rotatePoint(
          pinDeformed,
          pinState.position,
          rotationDelta
        );
      }
      if (Math.abs(pinState.scale - restState.scale) > 1e-3) {
        const scaleDelta = pinState.scale / restState.scale;
        pinDeformed = scalePoint(
          pinDeformed,
          pinState.position,
          scaleDelta
        );
      }
      deformedX += pinDeformed.x * weight;
      deformedY += pinDeformed.y * weight;
      totalWeight += weight;
    }
    if (totalWeight > 0) {
      deformedVertices[v * 2] = deformedX / totalWeight;
      deformedVertices[v * 2 + 1] = deformedY / totalWeight;
    } else {
      deformedVertices[v * 2] = origX;
      deformedVertices[v * 2 + 1] = origY;
    }
  }
  return deformedVertices;
}
class MeshWarpDeformationService {
  meshCache = /* @__PURE__ */ new Map();
  /**
   * Build a warp mesh from control points and pins
   */
  buildMesh(layerId, controlPoints, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const vertices = new Float32Array(controlPoints.length * 2);
    for (let i = 0; i < controlPoints.length; i++) {
      vertices[i * 2] = controlPoints[i].x;
      vertices[i * 2 + 1] = controlPoints[i].y;
    }
    const pinRestStates = pins.map((pin) => ({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    }));
    const allPoints = [
      ...controlPoints.map((cp) => ({ x: cp.x, y: cp.y })),
      ...pins.map((pin) => pin.position.value)
    ];
    const triangles = delaunayTriangulate(allPoints);
    const triangulation = [];
    for (const tri of triangles) {
      triangulation.push(tri.a, tri.b, tri.c);
    }
    const weights = calculateWeights(vertices, pins, options);
    const mesh = {
      layerId,
      pins,
      triangulation,
      weights,
      originalVertices: vertices,
      pinRestStates,
      vertexCount: controlPoints.length,
      dirty: false
    };
    this.meshCache.set(layerId, mesh);
    logger$2.debug(`Built warp mesh: ${controlPoints.length} vertices, ${pins.length} pins`);
    return mesh;
  }
  /**
   * Get or build a mesh for a layer
   */
  getMesh(layerId) {
    return this.meshCache.get(layerId);
  }
  /**
   * Clear cached mesh for a layer
   */
  clearMesh(layerId) {
    this.meshCache.delete(layerId);
  }
  /**
   * Update mesh when pins change
   */
  updateMeshPins(layerId, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    mesh.pins = pins;
    mesh.pinRestStates = pins.map((pin) => ({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    }));
    mesh.weights = calculateWeights(mesh.originalVertices, pins, options);
    mesh.dirty = false;
  }
  /**
   * Add a pin to an existing mesh
   */
  addPin(layerId, pin, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    mesh.pins.push(pin);
    mesh.pinRestStates.push({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    });
    mesh.weights = calculateWeights(mesh.originalVertices, mesh.pins, options);
  }
  /**
   * Remove a pin from an existing mesh
   */
  removePin(layerId, pinId, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    const pinIndex = mesh.pins.findIndex((p) => p.id === pinId);
    if (pinIndex === -1) return;
    mesh.pins.splice(pinIndex, 1);
    mesh.pinRestStates.splice(pinIndex, 1);
    mesh.weights = calculateWeights(mesh.originalVertices, mesh.pins, options);
  }
  /**
   * Get deformed control points at a specific frame
   */
  getDeformedControlPoints(layerId, frame, originalControlPoints) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh || mesh.pins.length === 0) {
      return originalControlPoints;
    }
    const deformedVertices = deformMesh(mesh, frame);
    const deformedPoints = originalControlPoints.map((cp, i) => {
      const newX = deformedVertices[i * 2];
      const newY = deformedVertices[i * 2 + 1];
      const dx = newX - cp.x;
      const dy = newY - cp.y;
      return {
        ...cp,
        x: newX,
        y: newY,
        // Also offset handles to maintain shape
        handleIn: cp.handleIn ? { x: cp.handleIn.x + dx, y: cp.handleIn.y + dy } : null,
        handleOut: cp.handleOut ? { x: cp.handleOut.x + dx, y: cp.handleOut.y + dy } : null
      };
    });
    return deformedPoints;
  }
  /**
   * Deform a mesh and return result
   */
  deform(layerId, frame) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return null;
    const vertices = deformMesh(mesh, frame);
    const controlPoints = [];
    for (let i = 0; i < mesh.vertexCount; i++) {
      controlPoints.push({
        x: vertices[i * 2],
        y: vertices[i * 2 + 1],
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      });
    }
    return { vertices, controlPoints };
  }
  /**
   * Get all pins for a layer
   */
  getPins(layerId) {
    return this.meshCache.get(layerId)?.pins ?? [];
  }
  /**
   * Update a pin's position (for UI dragging)
   */
  updatePinPosition(layerId, pinId, x, y) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    const pin = mesh.pins.find((p) => p.id === pinId);
    if (pin) {
      pin.position.value = { x, y };
    }
  }
  /**
   * Clear all cached meshes
   */
  clearAllMeshes() {
    this.meshCache.clear();
  }
}
const meshWarpDeformation = new MeshWarpDeformationService();

class SplineLayer extends BaseLayer {
  /** The line mesh for the spline (using Line2 for proper width support) */
  lineMesh = null;
  /** The fill mesh (if closed path with fill) */
  fillMesh = null;
  /** Canvas resolution for LineMaterial (needed for proper width rendering) */
  resolution = new Vector2(1920, 1080);
  /** Spline data */
  splineData;
  /** Cached curve for path calculations */
  curve = null;
  /** Animated control points (if spline is animated) */
  animatedPoints = null;
  /** Last evaluated frame for cache invalidation */
  lastEvaluatedFrame = -1;
  /** Cached evaluated points for the current frame */
  cachedEvaluatedPoints = null;
  /** Hash of last evaluated points for change detection */
  lastPointsHash = "";
  /** Trim start property (static or animated) */
  trimStartProp;
  /** Trim end property (static or animated) */
  trimEndProp;
  /** Trim offset property (static or animated) */
  trimOffsetProp;
  /** Path effects to apply */
  pathEffects;
  /** LOD levels for this spline */
  lodLevels = [];
  /** Whether LOD is enabled for this spline */
  lodEnabled = false;
  /** Current LOD context (updated during playback) */
  lodContext = {
    zoom: 1,
    isPlaying: false,
    isScrubbing: false,
    targetFPS: 60,
    currentFPS: 60,
    viewport: { x: 0, y: 0, width: 1920, height: 1080 }
  };
  /** Whether warp (mesh warp) deformation is enabled for this spline */
  warpEnabled = false;
  /** Warp pins for this spline (stored on layer, mesh managed by service) */
  warpPins = [];
  // Backwards compatibility getters
  /** @deprecated Use warpEnabled instead */
  get puppetEnabled() {
    return this.warpEnabled;
  }
  set puppetEnabled(val) {
    this.warpEnabled = val;
  }
  /** @deprecated Use warpPins instead */
  get puppetPins() {
    return this.warpPins;
  }
  set puppetPins(val) {
    this.warpPins = val;
  }
  constructor(layerData) {
    super(layerData);
    this.splineData = this.extractSplineData(layerData);
    if (this.splineData.animated && this.splineData.animatedControlPoints) {
      this.animatedPoints = this.splineData.animatedControlPoints;
    }
    const data = layerData.data;
    this.trimStartProp = data?.trimStart;
    this.trimEndProp = data?.trimEnd;
    this.trimOffsetProp = data?.trimOffset;
    this.pathEffects = data?.pathEffects;
    this.initializeLOD(data);
    this.initializeWarp(data);
    this.buildSpline();
    this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(layerData) {
    const data = layerData.data;
    return {
      controlPoints: data?.controlPoints ?? [],
      closed: data?.closed ?? false,
      stroke: data?.stroke ?? "#00ff00",
      strokeWidth: data?.strokeWidth ?? 2,
      fill: data?.fill ?? "",
      pathData: data?.pathData ?? ""
    };
  }
  /**
   * Initialize LOD levels for complex paths
   */
  initializeLOD(data) {
    if (!data) return;
    const lodSettings = data.lod;
    const points = data.controlPoints;
    const shouldAutoEnable = points.length > 100;
    if (lodSettings?.enabled || shouldAutoEnable) {
      this.lodEnabled = true;
      if (lodSettings?.levels && lodSettings.levels.length > 0) {
        this.lodLevels = lodSettings.levels.map((level) => ({
          tolerance: level.tolerance,
          controlPoints: level.controlPoints,
          pointCount: level.controlPoints.length,
          quality: 0
          // Will be set by index
        }));
        this.lodLevels.forEach((level, i) => {
          level.quality = i;
        });
      } else {
        const tolerance = lodSettings?.simplificationTolerance ?? 2;
        this.lodLevels = vectorLOD.generateLODLevels(
          this.layerData.id,
          points,
          4,
          // 4 levels
          tolerance
        );
      }
    }
  }
  /**
   * Update LOD context (call this when playback state changes)
   */
  updateLODContext(context) {
    this.lodContext = { ...this.lodContext, ...context };
  }
  /**
   * Get control points at appropriate LOD level
   */
  getPointsAtLOD(points) {
    if (!this.lodEnabled || this.lodLevels.length === 0) {
      return points;
    }
    const level = vectorLOD.selectLODLevel(this.lodLevels, this.lodContext);
    if (level) {
      return level.controlPoints;
    }
    return points;
  }
  /**
   * Initialize mesh warp deformation from layer data
   */
  initializeWarp(data) {
    const pins = data?.warpPins ?? data?.puppetPins;
    if (!data || !pins || pins.length === 0) {
      return;
    }
    this.warpPins = pins;
    this.warpEnabled = true;
    meshWarpDeformation.buildMesh(
      this.layerData.id,
      data.controlPoints,
      pins
    );
  }
  /** @deprecated Use initializeWarp instead */
  initializePuppet(data) {
    return this.initializeWarp(data);
  }
  /**
   * Enable mesh warp deformation mode
   * Creates a deformation mesh from current control points
   */
  enableWarpMode() {
    if (this.warpEnabled) return;
    this.warpEnabled = true;
    meshWarpDeformation.buildMesh(
      this.layerData.id,
      this.splineData.controlPoints,
      this.warpPins
    );
    this.lastPointsHash = "";
  }
  /** @deprecated Use enableWarpMode instead */
  enablePuppetMode() {
    return this.enableWarpMode();
  }
  /**
   * Disable mesh warp deformation mode
   */
  disableWarpMode() {
    if (!this.warpEnabled) return;
    this.warpEnabled = false;
    this.warpPins = [];
    meshWarpDeformation.clearMesh(this.layerData.id);
    this.lastPointsHash = "";
  }
  /** @deprecated Use disableWarpMode instead */
  disablePuppetMode() {
    return this.disableWarpMode();
  }
  /**
   * Check if mesh warp deformation is enabled
   */
  isWarpEnabled() {
    return this.warpEnabled;
  }
  /** @deprecated Use isWarpEnabled instead */
  isPuppetEnabled() {
    return this.isWarpEnabled();
  }
  /**
   * Add a warp pin at the specified position
   * @param x - X position of the pin
   * @param y - Y position of the pin
   * @param type - Pin type (position, rotation, or starch)
   * @returns The created pin
   */
  addWarpPin(x, y, type = "position") {
    const { createDefaultWarpPin } = require("@/types/meshWarp");
    const id = `pin_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    const pin = createDefaultWarpPin(id, x, y, type);
    this.warpPins.push(pin);
    if (!this.warpEnabled) {
      this.enableWarpMode();
    }
    meshWarpDeformation.addPin(this.layerData.id, pin);
    this.lastPointsHash = "";
    return pin;
  }
  /** @deprecated Use addWarpPin instead */
  addPuppetPin(x, y, type = "position") {
    return this.addWarpPin(x, y, type);
  }
  /**
   * Remove a warp pin by ID
   * @param pinId - The ID of the pin to remove
   */
  removeWarpPin(pinId) {
    const index = this.warpPins.findIndex((p) => p.id === pinId);
    if (index === -1) return;
    this.warpPins.splice(index, 1);
    meshWarpDeformation.removePin(this.layerData.id, pinId);
    if (this.warpPins.length === 0) {
      this.disableWarpMode();
    }
    this.lastPointsHash = "";
  }
  /** @deprecated Use removeWarpPin instead */
  removePuppetPin(pinId) {
    return this.removeWarpPin(pinId);
  }
  /**
   * Get all warp pins
   */
  getWarpPins() {
    return this.warpPins;
  }
  /** @deprecated Use getWarpPins instead */
  getPuppetPins() {
    return this.getWarpPins();
  }
  /**
   * Update a warp pin's position
   * @param pinId - The ID of the pin to update
   * @param x - New X position
   * @param y - New Y position
   */
  updateWarpPinPosition(pinId, x, y) {
    const pin = this.warpPins.find((p) => p.id === pinId);
    if (!pin) return;
    pin.position.value = { x, y };
    meshWarpDeformation.updatePinPosition(this.layerData.id, pinId, x, y);
    this.lastPointsHash = "";
  }
  /** @deprecated Use updateWarpPinPosition instead */
  updatePuppetPinPosition(pinId, x, y) {
    return this.updateWarpPinPosition(pinId, x, y);
  }
  /**
   * Set warp pins (replacing all existing pins)
   * @param pins - Array of warp pins
   */
  setWarpPins(pins) {
    this.warpPins = pins;
    if (pins.length > 0) {
      if (!this.warpEnabled) {
        this.enableWarpMode();
      }
      meshWarpDeformation.updateMeshPins(this.layerData.id, pins);
    } else {
      this.disableWarpMode();
    }
    this.lastPointsHash = "";
  }
  /** @deprecated Use setWarpPins instead */
  setPuppetPins(pins) {
    return this.setWarpPins(pins);
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    this.clearMeshes();
    const points = this.splineData.controlPoints;
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          zLast
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const positions = [];
    for (const pt of curvePoints) {
      positions.push(pt.x, pt.y, pt.z);
    }
    const lineGeometry = new LineGeometry();
    lineGeometry.setPositions(positions);
    const color = new Color(this.splineData.stroke);
    const lineMaterial = new LineMaterial({
      color: color.getHex(),
      linewidth: this.splineData.strokeWidth,
      transparent: true,
      resolution: this.resolution,
      // Use world units so linewidth is in pixels
      worldUnits: false
    });
    this.lineMesh = new Line2(lineGeometry, lineMaterial);
    this.lineMesh.computeLineDistances();
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(curvePoints) {
    if (curvePoints.length < 3) return;
    const shape = new Shape();
    shape.moveTo(curvePoints[0].x, curvePoints[0].y);
    for (let i = 1; i < curvePoints.length; i++) {
      shape.lineTo(curvePoints[i].x, curvePoints[i].y);
    }
    shape.closePath();
    const fillGeometry = new ShapeGeometry(shape);
    const fillMaterial = new MeshBasicMaterial({
      color: this.splineData.fill,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.fillMesh = new Mesh(fillGeometry, fillMaterial);
    this.fillMesh.name = `spline_fill_${this.id}`;
    this.fillMesh.position.z = -0.1;
    this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    if (this.lineMesh) {
      this.group.remove(this.lineMesh);
      this.lineMesh.geometry.dispose();
      this.lineMesh.material.dispose();
      this.lineMesh = null;
    }
    if (this.fillMesh) {
      this.group.remove(this.fillMesh);
      this.fillMesh.geometry.dispose();
      this.fillMesh.material.dispose();
      this.fillMesh = null;
    }
    this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(t) {
    if (!this.curve) return null;
    return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(t) {
    if (!this.curve) return null;
    return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    if (!this.curve) return 0;
    return this.curve.getLength();
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(t) {
    const point = this.getPointAt(t);
    const tangent = this.getTangentAt(t);
    if (!point || !tangent) return null;
    const rotation = Math.atan2(tangent.y, tangent.x) * (180 / Math.PI);
    return { position: point, rotation };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(color) {
    this.splineData.stroke = color;
    if (this.lineMesh) {
      this.lineMesh.material.color.set(color);
    }
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(width) {
    this.splineData.strokeWidth = width;
    if (this.lineMesh) {
      this.lineMesh.material.linewidth = width;
      this.lineMesh.material.needsUpdate = true;
    }
  }
  /**
   * Set fill color
   */
  setFill(color) {
    this.splineData.fill = color;
    if (this.fillMesh) {
      this.fillMesh.material.color.set(color);
    } else if (color && this.splineData.closed && this.curve) {
      const curvePoints = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(curvePoints);
    }
  }
  /**
   * Set resolution for line material (call when canvas resizes)
   */
  setResolution(width, height) {
    this.resolution.set(width, height);
    if (this.lineMesh) {
      this.lineMesh.material.resolution.set(width, height);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(points) {
    this.splineData.controlPoints = points;
    this.animatedPoints = null;
    this.splineData.animated = false;
    this.buildSpline();
  }
  /**
   * Set animated control points
   * Enables animation mode for this spline
   */
  setAnimatedControlPoints(points) {
    this.animatedPoints = points;
    this.splineData.animatedControlPoints = points;
    this.splineData.animated = true;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
  }
  /**
   * Enable animation on this spline by converting static control points
   * to AnimatableControlPoint format
   */
  enableAnimation() {
    if (this.animatedPoints) {
      return this.animatedPoints;
    }
    const { controlPointToAnimatable } = require("@/types/project");
    const animatedPoints = this.splineData.controlPoints.map(
      (cp) => controlPointToAnimatable(cp)
    );
    this.setAnimatedControlPoints(animatedPoints);
    return animatedPoints;
  }
  /**
   * Disable animation and convert back to static control points
   */
  disableAnimation() {
    if (!this.animatedPoints) return;
    const { animatableToControlPoint } = require("@/types/project");
    this.splineData.controlPoints = this.animatedPoints.map(
      (acp) => animatableToControlPoint(acp)
    );
    this.animatedPoints = null;
    this.splineData.animatedControlPoints = void 0;
    this.splineData.animated = false;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
    this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(closed) {
    if (this.splineData.closed === closed) return;
    this.splineData.closed = closed;
    this.buildSpline();
  }
  /**
   * Check if the spline path is closed
   */
  isClosed() {
    return this.splineData.closed;
  }
  // ============================================================================
  // TRIM PATH SETTERS/GETTERS
  // ============================================================================
  /**
   * Set trim start (static value)
   * @param value - Trim start percentage (0-100)
   */
  setTrimStart(value) {
    this.trimStartProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set trim end (static value)
   * @param value - Trim end percentage (0-100)
   */
  setTrimEnd(value) {
    this.trimEndProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set trim offset (static value)
   * @param value - Trim offset in degrees
   */
  setTrimOffset(value) {
    this.trimOffsetProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim start property
   * @param prop - AnimatableProperty for trim start
   */
  setAnimatedTrimStart(prop) {
    this.trimStartProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim end property
   * @param prop - AnimatableProperty for trim end
   */
  setAnimatedTrimEnd(prop) {
    this.trimEndProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim offset property
   * @param prop - AnimatableProperty for trim offset
   */
  setAnimatedTrimOffset(prop) {
    this.trimOffsetProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Get current trim values at a specific frame
   * Useful for UI display and debugging
   */
  getTrimValues(frame) {
    return {
      start: this.evaluateStaticOrAnimated(this.trimStartProp, frame, 0),
      end: this.evaluateStaticOrAnimated(this.trimEndProp, frame, 100),
      offset: this.evaluateStaticOrAnimated(this.trimOffsetProp, frame, 0)
    };
  }
  /**
   * Check if trim path is enabled (has non-default values or animated)
   */
  hasTrimPath() {
    return this.trimStartProp !== void 0 || this.trimEndProp !== void 0 || this.trimOffsetProp !== void 0;
  }
  /**
   * Set path effects
   * @param effects - Array of path effects to apply
   */
  setPathEffects(effects) {
    this.pathEffects = effects;
    this.lastPointsHash = "";
  }
  /**
   * Get current path effects
   */
  getPathEffects() {
    return this.pathEffects;
  }
  // ============================================================================
  // ANIMATED SPLINE EVALUATION
  // ============================================================================
  /**
   * Check if this spline has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   * Uses interpolateProperty from interpolation.ts
   * Driven values override interpolated values
   */
  evaluateControlPointAtFrame(acp, frame, index) {
    const interpolatedX = interpolateProperty(acp.x, frame);
    const interpolatedY = interpolateProperty(acp.y, frame);
    const interpolatedDepth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    return {
      id: acp.id,
      x: this.getDrivenControlPointValue(index, "x", interpolatedX),
      y: this.getDrivenControlPointValue(index, "y", interpolatedY),
      depth: this.getDrivenControlPointValue(index, "depth", interpolatedDepth),
      handleIn: acp.handleIn ? {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      } : null,
      handleOut: acp.handleOut ? {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      } : null,
      type: acp.type,
      group: acp.group
    };
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer and other consumers
   *
   * For static splines, returns the static control points converted to EvaluatedControlPoint
   * For animated splines, interpolates all control points at the given frame
   * Driven values (from PropertyDriverSystem) override interpolated values
   *
   * DETERMINISM: Same frame + same drivers = same output (pure function)
   */
  getEvaluatedControlPoints(frame) {
    const hasDrivenValues = this.hasSplineDrivers();
    if (frame === this.lastEvaluatedFrame && this.cachedEvaluatedPoints && !hasDrivenValues) {
      return this.cachedEvaluatedPoints;
    }
    let points;
    if (this.animatedPoints && this.animatedPoints.length > 0) {
      points = this.animatedPoints.map(
        (acp, index) => this.evaluateControlPointAtFrame(acp, frame, index)
      );
    } else {
      points = this.splineData.controlPoints.map((cp, index) => ({
        id: cp.id,
        x: this.getDrivenControlPointValue(index, "x", cp.x),
        y: this.getDrivenControlPointValue(index, "y", cp.y),
        depth: this.getDrivenControlPointValue(index, "depth", cp.depth ?? 0),
        handleIn: cp.handleIn,
        handleOut: cp.handleOut,
        type: cp.type,
        group: cp.group
      }));
    }
    this.lastEvaluatedFrame = frame;
    if (!hasDrivenValues) {
      this.cachedEvaluatedPoints = points;
    }
    return points;
  }
  /**
   * Check if any spline control point drivers are active
   */
  hasSplineDrivers() {
    for (const key of this.drivenValues.keys()) {
      if (isSplineControlPointPath(key)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get a driven control point value, falling back to base value
   */
  getDrivenControlPointValue(index, property, baseValue) {
    const path = createSplineControlPointPath(index, property);
    return this.getDrivenOrBase(path, baseValue);
  }
  /**
   * Compute a hash of control point positions for change detection
   * Used to avoid rebuilding geometry when positions haven't changed
   */
  computePointsHash(points) {
    return points.map(
      (p) => `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.depth.toFixed(2)}`
    ).join("|");
  }
  // ============================================================================
  // TRIM PATH & PATH EFFECTS HELPERS
  // ============================================================================
  /**
   * Evaluate a property that can be either a static value or AnimatableProperty
   * @param prop - Static value or AnimatableProperty
   * @param frame - Current frame number
   * @param defaultValue - Value to use if prop is undefined
   */
  evaluateStaticOrAnimated(prop, frame, defaultValue) {
    if (prop === void 0) {
      return defaultValue;
    }
    if (typeof prop === "number") {
      return prop;
    }
    return interpolateProperty(prop, frame);
  }
  /**
   * Check if trim is active (differs from default values)
   */
  isTrimActive(trimStart, trimEnd, trimOffset) {
    return trimStart !== 0 || trimEnd !== 100 || trimOffset !== 0;
  }
  /**
   * Check if any path effects are enabled
   */
  hasActivePathEffects() {
    return this.pathEffects?.some((e) => e.enabled) ?? false;
  }
  /**
   * Convert EvaluatedControlPoint[] to BezierPath format for shapeOperations
   * Note: EvaluatedControlPoint handles are ABSOLUTE, BezierVertex handles are RELATIVE
   */
  evaluatedPointsToBezierPath(points) {
    const vertices = points.map((p) => {
      const inHandle = p.handleIn ? { x: p.handleIn.x - p.x, y: p.handleIn.y - p.y } : { x: 0, y: 0 };
      const outHandle = p.handleOut ? { x: p.handleOut.x - p.x, y: p.handleOut.y - p.y } : { x: 0, y: 0 };
      return {
        point: { x: p.x, y: p.y },
        inHandle,
        outHandle
      };
    });
    return {
      vertices,
      closed: this.splineData.closed
    };
  }
  /**
   * Convert BezierPath back to EvaluatedControlPoint[] format
   * Note: Depth information is lost during trim - we interpolate from original points
   */
  bezierPathToEvaluatedPoints(bezierPath, originalPoints) {
    return bezierPath.vertices.map((v, i) => {
      const originalDepth = i < originalPoints.length ? originalPoints[i].depth : 0;
      const handleIn = v.inHandle.x !== 0 || v.inHandle.y !== 0 ? { x: v.point.x + v.inHandle.x, y: v.point.y + v.inHandle.y } : null;
      const handleOut = v.outHandle.x !== 0 || v.outHandle.y !== 0 ? { x: v.point.x + v.outHandle.x, y: v.point.y + v.outHandle.y } : null;
      return {
        id: `trimmed_${i}`,
        x: v.point.x,
        y: v.point.y,
        depth: originalDepth,
        handleIn,
        handleOut,
        type: "smooth"
      };
    });
  }
  /**
   * Apply path effects in order (before trim)
   * @param bezierPath - The input path
   * @param frame - Current frame for animated effect properties
   */
  applyPathEffects(bezierPath, frame) {
    if (!this.pathEffects || this.pathEffects.length === 0) {
      return bezierPath;
    }
    const sortedEffects = [...this.pathEffects].filter((e) => e.enabled).sort((a, b) => a.order - b.order);
    let result = bezierPath;
    for (const effect of sortedEffects) {
      switch (effect.type) {
        case "offsetPath": {
          const offsetEffect = effect;
          const amount = interpolateProperty(offsetEffect.amount, frame);
          const miterLimit = interpolateProperty(offsetEffect.miterLimit, frame);
          result = offsetPath(result, amount, offsetEffect.lineJoin, miterLimit);
          break;
        }
        case "wiggle": {
          const wiggleEffect = effect;
          const size = interpolateProperty(wiggleEffect.size, frame);
          const detail = interpolateProperty(wiggleEffect.detail, frame);
          const temporalPhase = interpolateProperty(wiggleEffect.temporalPhase, frame);
          const spatialPhase = interpolateProperty(wiggleEffect.spatialPhase, frame);
          const correlation = interpolateProperty(wiggleEffect.correlation, frame);
          result = wigglePath(
            result,
            size,
            detail,
            "smooth",
            // WigglePathEffect pointType mapping
            correlation,
            temporalPhase,
            spatialPhase,
            wiggleEffect.seed
          );
          break;
        }
        case "zigzag": {
          const zigzagEffect = effect;
          const size = interpolateProperty(zigzagEffect.size, frame);
          const ridges = interpolateProperty(zigzagEffect.ridgesPerSegment, frame);
          result = zigZagPath(result, size, ridges, zigzagEffect.pointType);
          break;
        }
        case "roughen": {
          const roughenEffect = effect;
          const size = interpolateProperty(roughenEffect.size, frame);
          const detail = interpolateProperty(roughenEffect.detail, frame);
          result = roughenPath(result, size, detail, roughenEffect.seed);
          break;
        }
        case "wave": {
          const waveEffect = effect;
          const amplitude = interpolateProperty(waveEffect.amplitude, frame);
          const frequency = interpolateProperty(waveEffect.frequency, frame);
          const phase = interpolateProperty(waveEffect.phase, frame);
          result = wavePath(result, amplitude, frequency, phase, waveEffect.waveType);
          break;
        }
      }
    }
    return result;
  }
  /**
   * Build spline geometry from evaluated control points
   * Called when control points change during animation
   */
  buildSplineFromEvaluatedPoints(points) {
    this.clearMeshes();
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth;
      const z1 = p1.depth;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth;
      const zFirst = firstPoint.depth;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          zLast
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const positions = [];
    for (const pt of curvePoints) {
      positions.push(pt.x, pt.y, pt.z);
    }
    const lineGeometry = new LineGeometry();
    lineGeometry.setPositions(positions);
    const color = new Color(this.splineData.stroke);
    const lineMaterial = new LineMaterial({
      color: color.getHex(),
      linewidth: this.splineData.strokeWidth,
      transparent: true,
      resolution: this.resolution,
      worldUnits: false
    });
    this.lineMesh = new Line2(lineGeometry, lineMaterial);
    this.lineMesh.computeLineDistances();
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const trimStart = this.evaluateStaticOrAnimated(this.trimStartProp, frame, 0);
    const trimEnd = this.evaluateStaticOrAnimated(this.trimEndProp, frame, 100);
    const trimOffset = this.evaluateStaticOrAnimated(this.trimOffsetProp, frame, 0);
    const needsTrim = this.isTrimActive(trimStart, trimEnd, trimOffset);
    const hasEffects = this.hasActivePathEffects();
    const useLOD = this.shouldUseLOD();
    const hasWarp = this.warpEnabled && this.warpPins.length > 0;
    if (!this.isAnimated() && !needsTrim && !hasEffects && !useLOD && !hasWarp) {
      return;
    }
    let evaluatedPoints = this.getEvaluatedControlPoints(frame);
    const lodHash = useLOD ? `|lod:${this.lodContext.isPlaying},${this.lodContext.zoom.toFixed(2)}` : "";
    const trimHash = needsTrim || hasEffects ? `|trim:${trimStart.toFixed(2)},${trimEnd.toFixed(2)},${trimOffset.toFixed(2)}|fx:${frame}` : "";
    const warpHash = hasWarp ? `|warp:${frame}` : "";
    const pointsHash = this.computePointsHash(evaluatedPoints) + trimHash + lodHash + warpHash;
    if (pointsHash !== this.lastPointsHash) {
      let finalPoints = evaluatedPoints;
      if (hasWarp) {
        const controlPoints = evaluatedPoints.map((ep) => ({
          id: ep.id,
          x: ep.x,
          y: ep.y,
          depth: ep.depth,
          handleIn: ep.handleIn,
          handleOut: ep.handleOut,
          type: ep.type,
          group: ep.group
        }));
        const deformedPoints = meshWarpDeformation.getDeformedControlPoints(
          this.layerData.id,
          frame,
          controlPoints
        );
        finalPoints = deformedPoints.map((cp) => ({
          id: cp.id,
          x: cp.x,
          y: cp.y,
          depth: cp.depth ?? 0,
          handleIn: cp.handleIn,
          handleOut: cp.handleOut,
          type: cp.type,
          group: cp.group
        }));
      }
      if (needsTrim || hasEffects) {
        let bezierPath = this.evaluatedPointsToBezierPath(finalPoints);
        if (hasEffects) {
          bezierPath = this.applyPathEffects(bezierPath, frame);
        }
        if (needsTrim) {
          bezierPath = trimPath(bezierPath, trimStart, trimEnd, trimOffset);
        }
        finalPoints = this.bezierPathToEvaluatedPoints(bezierPath, evaluatedPoints);
      }
      if (useLOD && finalPoints.length > 50) {
        const lodLevel = vectorLOD.selectLODLevel(this.lodLevels, this.lodContext);
        if (lodLevel && lodLevel.pointCount < finalPoints.length) {
          finalPoints = lodLevel.controlPoints.map((cp, i) => ({
            id: cp.id,
            x: cp.x,
            y: cp.y,
            handleIn: cp.handleIn ?? { x: cp.x, y: cp.y },
            handleOut: cp.handleOut ?? { x: cp.x, y: cp.y },
            depth: cp.depth ?? 0,
            type: cp.type,
            group: cp.group
          }));
        }
      }
      this.buildSplineFromEvaluatedPoints(finalPoints);
      this.lastPointsHash = pointsHash;
    }
  }
  /**
   * Check if LOD should be used based on current context
   */
  shouldUseLOD() {
    if (!this.lodEnabled || this.lodLevels.length === 0) {
      return false;
    }
    if (this.lodContext.isPlaying || this.lodContext.isScrubbing) {
      return true;
    }
    if (this.lodContext.zoom < 0.5) {
      return true;
    }
    if ((this.lodContext.currentFPS ?? 60) < (this.lodContext.targetFPS ?? 60) * 0.8) {
      return true;
    }
    return false;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["controlPoints"] !== void 0) {
      const points = props["controlPoints"];
      const pointsHash = this.computePointsHash(points);
      if (pointsHash !== this.lastPointsHash) {
        this.buildSplineFromEvaluatedPoints(points);
        this.lastPointsHash = pointsHash;
      }
    }
    if (props["strokeWidth"] !== void 0) {
      this.setStrokeWidth(props["strokeWidth"]);
    }
    if (props["strokeColor"] !== void 0) {
      this.setStroke(props["strokeColor"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      let needsRebuild = false;
      if (data.animatedControlPoints !== void 0) {
        this.setAnimatedControlPoints(data.animatedControlPoints);
        needsRebuild = false;
      } else if (data.controlPoints !== void 0) {
        this.splineData.controlPoints = data.controlPoints;
        if (!data.animated) {
          this.animatedPoints = null;
          this.splineData.animated = false;
        }
        needsRebuild = true;
      }
      if (data.animated !== void 0) {
        if (data.animated && !this.animatedPoints) {
          this.enableAnimation();
          needsRebuild = false;
        } else if (!data.animated && this.animatedPoints) {
          this.disableAnimation();
          needsRebuild = false;
        }
      }
      if (data.closed !== void 0 && data.closed !== this.splineData.closed) {
        this.splineData.closed = data.closed;
        needsRebuild = true;
      }
      if (data.stroke !== void 0) {
        this.setStroke(data.stroke);
      }
      if (data.strokeWidth !== void 0) {
        this.setStrokeWidth(data.strokeWidth);
      }
      if (data.fill !== void 0) {
        this.setFill(data.fill);
      }
      if (data.trimStart !== void 0) {
        this.trimStartProp = data.trimStart;
        this.lastPointsHash = "";
      }
      if (data.trimEnd !== void 0) {
        this.trimEndProp = data.trimEnd;
        this.lastPointsHash = "";
      }
      if (data.trimOffset !== void 0) {
        this.trimOffsetProp = data.trimOffset;
        this.lastPointsHash = "";
      }
      if (data.pathEffects !== void 0) {
        this.pathEffects = data.pathEffects;
        this.lastPointsHash = "";
      }
      const warpPinsData = data.warpPins ?? data.puppetPins;
      if (warpPinsData !== void 0) {
        this.setWarpPins(warpPinsData);
      }
      if (needsRebuild) {
        this.buildSpline();
      }
    }
  }
  onDispose() {
    this.clearMeshes();
    if (this.warpEnabled) {
      meshWarpDeformation.clearMesh(this.layerData.id);
    }
  }
}

class PathLayer extends BaseLayer {
  /** The dashed guide line mesh */
  guideLine = null;
  /** Canvas resolution for LineMaterial */
  resolution = new Vector2(1920, 1080);
  /** Path data */
  pathData;
  /** Cached curve for path calculations */
  curve = null;
  /** Animated control points (if path is animated) */
  animatedPoints = null;
  /** Last evaluated frame for cache invalidation */
  lastEvaluatedFrame = -1;
  /** Cached evaluated points for the current frame */
  cachedEvaluatedPoints = null;
  /** Hash of last evaluated points for change detection */
  lastPointsHash = "";
  constructor(layerData) {
    super(layerData);
    this.pathData = this.extractPathData(layerData);
    if (this.pathData.animated && this.pathData.animatedControlPoints) {
      this.animatedPoints = this.pathData.animatedControlPoints;
    }
    this.buildPath();
    this.initializeBlendMode();
  }
  /**
   * Extract path layer data from layer object
   */
  extractPathData(layerData) {
    const data = layerData.data;
    return {
      controlPoints: data?.controlPoints ?? [],
      closed: data?.closed ?? false,
      pathData: data?.pathData ?? "",
      showGuide: data?.showGuide ?? true,
      guideColor: data?.guideColor ?? "#00FFFF",
      guideDashPattern: data?.guideDashPattern ?? [10, 5],
      animatedControlPoints: data?.animatedControlPoints,
      animated: data?.animated
    };
  }
  /**
   * Build the Three.js path from control points
   */
  buildPath() {
    this.clearGuideLine();
    const points = this.pathData.controlPoints;
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.pathData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          zLast
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    if (this.pathData.showGuide) {
      this.createGuideLine();
    }
  }
  /**
   * Create the dashed guide line visualization
   */
  createGuideLine() {
    if (!this.curve) return;
    const points = this.pathData.controlPoints;
    const curvePoints = this.curve.getPoints(points.length * 20);
    const positions = [];
    for (const pt of curvePoints) {
      positions.push(pt.x, pt.y, pt.z);
    }
    const lineGeometry = new LineGeometry();
    lineGeometry.setPositions(positions);
    const color = new Color(this.pathData.guideColor);
    const lineMaterial = new LineMaterial({
      color: color.getHex(),
      linewidth: 2,
      transparent: true,
      opacity: 0.7,
      resolution: this.resolution,
      worldUnits: false,
      dashed: true,
      dashSize: this.pathData.guideDashPattern[0],
      gapSize: this.pathData.guideDashPattern[1]
    });
    this.guideLine = new Line2(lineGeometry, lineMaterial);
    this.guideLine.computeLineDistances();
    this.guideLine.name = `path_guide_${this.id}`;
    this.guideLine.userData.isGuide = true;
    this.guideLine.userData.layerId = this.id;
    this.group.add(this.guideLine);
  }
  /**
   * Clear existing guide line
   */
  clearGuideLine() {
    if (this.guideLine) {
      this.group.remove(this.guideLine);
      this.guideLine.geometry.dispose();
      this.guideLine.material.dispose();
      this.guideLine = null;
    }
    this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES (Used by TextLayer, CameraLayer, ParticleLayer)
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(t) {
    if (!this.curve) return null;
    return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(t) {
    if (!this.curve) return null;
    return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    if (!this.curve) return 0;
    return this.curve.getLength();
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(t) {
    const point = this.getPointAt(t);
    const tangent = this.getTangentAt(t);
    if (!point || !tangent) return null;
    const rotation = Math.atan2(tangent.y, tangent.x) * (180 / Math.PI);
    return { position: point, rotation };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  /**
   * Check if the path is closed
   */
  isClosed() {
    return this.pathData.closed;
  }
  // ============================================================================
  // EVALUATED CONTROL POINTS API
  // ============================================================================
  /**
   * Check if this path has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer, CameraLayer, and other consumers
   *
   * DETERMINISM: Same frame = same output (pure function)
   */
  getEvaluatedControlPoints(frame) {
    if (frame === this.lastEvaluatedFrame && this.cachedEvaluatedPoints) {
      return this.cachedEvaluatedPoints;
    }
    let points;
    if (this.animatedPoints && this.animatedPoints.length > 0) {
      points = this.animatedPoints.map(
        (acp) => this.evaluateControlPointAtFrame(acp, frame)
      );
    } else {
      points = this.pathData.controlPoints.map((cp) => ({
        id: cp.id,
        x: cp.x,
        y: cp.y,
        depth: cp.depth ?? 0,
        handleIn: cp.handleIn,
        handleOut: cp.handleOut,
        type: cp.type,
        group: cp.group
      }));
    }
    this.lastEvaluatedFrame = frame;
    this.cachedEvaluatedPoints = points;
    return points;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   */
  evaluateControlPointAtFrame(acp, frame) {
    return {
      id: acp.id,
      x: interpolateProperty(acp.x, frame),
      y: interpolateProperty(acp.y, frame),
      depth: acp.depth ? interpolateProperty(acp.depth, frame) : 0,
      handleIn: acp.handleIn ? {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      } : null,
      handleOut: acp.handleOut ? {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      } : null,
      type: acp.type,
      group: acp.group
    };
  }
  /**
   * Compute a hash of control point positions for change detection
   */
  computePointsHash(points) {
    return points.map((p) => `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.depth.toFixed(2)}`).join("|");
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set guide visibility
   */
  setShowGuide(show) {
    if (this.pathData.showGuide === show) return;
    this.pathData.showGuide = show;
    if (show && !this.guideLine && this.curve) {
      this.createGuideLine();
    } else if (!show && this.guideLine) {
      this.group.remove(this.guideLine);
      this.guideLine.geometry.dispose();
      this.guideLine.material.dispose();
      this.guideLine = null;
    }
  }
  /**
   * Set guide color
   */
  setGuideColor(color) {
    this.pathData.guideColor = color;
    if (this.guideLine) {
      this.guideLine.material.color.set(color);
    }
  }
  /**
   * Set guide dash pattern [dash, gap]
   */
  setGuideDashPattern(pattern) {
    this.pathData.guideDashPattern = pattern;
    if (this.guideLine) {
      const mat = this.guideLine.material;
      mat.dashSize = pattern[0];
      mat.gapSize = pattern[1];
      mat.needsUpdate = true;
      this.guideLine.computeLineDistances();
    }
  }
  /**
   * Set resolution for line material (call when canvas resizes)
   */
  setResolution(width, height) {
    this.resolution.set(width, height);
    if (this.guideLine) {
      this.guideLine.material.resolution.set(width, height);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(points) {
    this.pathData.controlPoints = points;
    this.animatedPoints = null;
    this.pathData.animated = false;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.buildPath();
  }
  /**
   * Set animated control points
   */
  setAnimatedControlPoints(points) {
    this.animatedPoints = points;
    this.pathData.animatedControlPoints = points;
    this.pathData.animated = true;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
  }
  /**
   * Set closed state
   */
  setClosed(closed) {
    if (this.pathData.closed === closed) return;
    this.pathData.closed = closed;
    this.buildPath();
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.isAnimated()) return;
    const evaluatedPoints = this.getEvaluatedControlPoints(frame);
    const pointsHash = this.computePointsHash(evaluatedPoints);
    if (pointsHash !== this.lastPointsHash) {
      this.buildPathFromEvaluatedPoints(evaluatedPoints);
      this.lastPointsHash = pointsHash;
    }
  }
  /**
   * Build path geometry from evaluated control points
   */
  buildPathFromEvaluatedPoints(points) {
    this.clearGuideLine();
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth;
      const z1 = p1.depth;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.pathData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, lastPoint.depth),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          lastPoint.depth
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          firstPoint.depth
        ),
        new Vector3(firstPoint.x, -firstPoint.y, firstPoint.depth)
      );
      this.curve.add(closingBezier);
    }
    if (this.pathData.showGuide) {
      this.createGuideLine();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["controlPoints"] !== void 0) {
      const points = props["controlPoints"];
      const pointsHash = this.computePointsHash(points);
      if (pointsHash !== this.lastPointsHash) {
        this.buildPathFromEvaluatedPoints(points);
        this.lastPointsHash = pointsHash;
      }
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      let needsRebuild = false;
      if (data.animatedControlPoints !== void 0) {
        this.setAnimatedControlPoints(data.animatedControlPoints);
      } else if (data.controlPoints !== void 0) {
        this.pathData.controlPoints = data.controlPoints;
        if (!data.animated) {
          this.animatedPoints = null;
          this.pathData.animated = false;
        }
        needsRebuild = true;
      }
      if (data.closed !== void 0 && data.closed !== this.pathData.closed) {
        this.pathData.closed = data.closed;
        needsRebuild = true;
      }
      if (data.showGuide !== void 0) {
        this.setShowGuide(data.showGuide);
      }
      if (data.guideColor !== void 0) {
        this.setGuideColor(data.guideColor);
      }
      if (data.guideDashPattern !== void 0) {
        this.setGuideDashPattern(data.guideDashPattern);
      }
      if (needsRebuild) {
        this.buildPath();
      }
    }
  }
  onDispose() {
    this.clearGuideLine();
  }
}

const GLSL_NOISE = `
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289(i);
  vec4 p = permute(permute(permute(
    i.z + vec4(0.0, i1.z, i2.z, 1.0))
    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0) * 2.0 + 1.0;
  vec4 s1 = floor(b1) * 2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}
`;
const GLSL_FORCE_CALC = `
vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
  vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
  vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
  vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
  vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);
  vec3 fieldPos = row0.xyz;
  int fieldType = int(row0.w);
  float strength = row1.x;
  float falloffStart = row1.y;
  float falloffEnd = row1.z;
  int falloffType = int(row1.w);
  vec3 toField = fieldPos - pos;
  float dist = length(toField);
  float falloff = 1.0;
  if (dist > falloffStart && falloffEnd > falloffStart) {
    float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
    if (falloffType == 1) falloff = 1.0 - t;
    else if (falloffType == 2) falloff = 1.0 - t * t;
    else if (falloffType == 3) falloff = exp(-t * 3.0);
    else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t);
  }
  vec3 force = vec3(0.0);
  float effectiveStrength = strength * falloff;
  if (fieldType == 0) { force = row2.xyz * effectiveStrength; }
  else if (fieldType == 1) {
    if (dist > 0.001) { force = normalize(toField) * effectiveStrength / max(mass, 0.1); }
  }
  else if (fieldType == 2) {
    if (dist > 0.001) {
      vec3 axis = normalize(row2.xyz);
      vec3 tangent = normalize(cross(axis, toField));
      force = tangent * effectiveStrength + normalize(toField) * row2.w;
    }
  }
  else if (fieldType == 3) {
    float noiseScale = row3.x;
    float noiseSpeed = row3.y;
    vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
    force.x = snoise(noisePos) * effectiveStrength;
    force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
    force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
  }
  else if (fieldType == 4) {
    float linearDrag = row3.x;
    float quadDrag = row3.y;
    float speed = length(vel);
    if (speed > 0.001) {
      float dragMag = linearDrag * speed + quadDrag * speed * speed;
      force = -normalize(vel) * dragMag * effectiveStrength;
    }
  }
  else if (fieldType == 5) {
    vec3 windDir = normalize(row2.xyz);
    float gustStrength = row3.x;
    float gustFreq = row3.y;
    float gust = sin(u_time * gustFreq) * gustStrength;
    force = windDir * (effectiveStrength + gust);
  }
  return force;
}
`;
const TRANSFORM_FEEDBACK_VERTEX_SHADER = `#version 300 es
precision highp float;
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec3 a_velocity;
layout(location = 2) in vec2 a_life;
layout(location = 3) in vec2 a_physical;
layout(location = 4) in vec2 a_rotation;
layout(location = 5) in vec4 a_color;
out vec3 tf_position;
out vec3 tf_velocity;
out vec2 tf_life;
out vec2 tf_physical;
out vec2 tf_rotation;
out vec4 tf_color;
uniform float u_deltaTime;
uniform float u_time;
uniform int u_forceFieldCount;
uniform sampler2D u_forceFields;
${GLSL_NOISE}
${GLSL_FORCE_CALC}
void main() {
  if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
    tf_position = a_position;
    tf_velocity = a_velocity;
    tf_life = a_life;
    tf_physical = a_physical;
    tf_rotation = a_rotation;
    tf_color = a_color;
    return;
  }
  vec3 pos = a_position;
  vec3 vel = a_velocity;
  float age = a_life.x;
  float lifetime = a_life.y;
  float mass = a_physical.x;
  float size = a_physical.y;
  float rotation = a_rotation.x;
  float angularVel = a_rotation.y;
  vec3 totalForce = vec3(0.0);
  for (int i = 0; i < u_forceFieldCount; i++) {
    totalForce += calculateForce(i, pos, vel, mass);
  }
  vec3 acceleration = totalForce / max(mass, 0.1);
  vel += acceleration * u_deltaTime;
  pos += vel * u_deltaTime;
  rotation += angularVel * u_deltaTime;
  age += u_deltaTime;
  float lifeRatio = age / lifetime;
  float sizeMod = 1.0 - lifeRatio * 0.5;
  size = a_physical.y * sizeMod;
  float opacityMod = 1.0 - lifeRatio;
  tf_position = pos;
  tf_velocity = vel;
  tf_life = vec2(age, lifetime);
  tf_physical = vec2(mass, size);
  tf_rotation = vec2(rotation, angularVel);
  tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
}
`;
const TRANSFORM_FEEDBACK_FRAGMENT_SHADER = `#version 300 es
precision highp float;
out vec4 fragColor;
void main() { fragColor = vec4(0.0); }
`;
const PARTICLE_VERTEX_SHADER = `
precision highp float;
attribute vec2 position;
attribute vec2 uv;
attribute vec3 i_position;
attribute vec3 i_velocity;
attribute vec2 i_life;
attribute vec2 i_physical;
attribute vec2 i_rotation;
attribute vec4 i_color;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPosition;
// Motion blur uniforms
uniform int motionBlurEnabled;
uniform float motionBlurStrength;
uniform float minStretch;
uniform float maxStretch;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;

void main() {
  if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
    gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
    return;
  }

  float size = i_physical.y;
  float rotation = i_rotation.x;
  float lifeRatio = i_life.x / i_life.y;

  // Camera basis vectors
  vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
  vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);
  vec3 cameraForward = vec3(modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2]);

  vec2 offsetPos = position;

  // Motion blur: stretch billboard along velocity direction
  if (motionBlurEnabled == 1) {
    float speed = length(i_velocity);
    if (speed > 0.01) {
      // Project velocity onto camera plane
      vec3 velNorm = normalize(i_velocity);
      float velRight = dot(velNorm, cameraRight);
      float velUp = dot(velNorm, cameraUp);
      vec2 velDir2D = normalize(vec2(velRight, velUp));

      // Calculate stretch factor based on speed
      float stretch = clamp(speed * motionBlurStrength, minStretch, maxStretch);

      // Rotate and stretch the quad along velocity direction
      float angle = atan(velDir2D.y, velDir2D.x);
      float cosA = cos(angle);
      float sinA = sin(angle);

      // Apply rotation to align with velocity, then stretch in X
      vec2 rotated = vec2(
        position.x * cosA - position.y * sinA,
        position.x * sinA + position.y * cosA
      );
      offsetPos = vec2(rotated.x * stretch, rotated.y);

      // Rotate back to world space
      offsetPos = vec2(
        offsetPos.x * cosA + offsetPos.y * sinA,
        -offsetPos.x * sinA + offsetPos.y * cosA
      );
    }
  }

  // Apply per-particle rotation (if no motion blur or in addition to)
  if (motionBlurEnabled == 0) {
    float cosR = cos(rotation);
    float sinR = sin(rotation);
    offsetPos = vec2(
      offsetPos.x * cosR - offsetPos.y * sinR,
      offsetPos.x * sinR + offsetPos.y * cosR
    );
  }

  vec3 vertexPos = i_position + cameraRight * offsetPos.x * size + cameraUp * offsetPos.y * size;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);
  vUv = uv;
  vColor = i_color;
  vLifeRatio = lifeRatio;
}
`;
const PARTICLE_FRAGMENT_SHADER = `
precision highp float;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;
uniform sampler2D diffuseMap;
uniform int hasDiffuseMap;
uniform int proceduralShape;
// Sprite sheet uniforms
uniform vec2 spriteSheetSize;  // columns, rows
uniform int spriteFrameCount;
uniform int animateSprite;
uniform float spriteFrameRate;
uniform float time;

// Procedural shape generation
// 0 = none, 1 = circle, 2 = ring, 3 = square, 4 = star
float proceduralAlpha(vec2 uv, int shape) {
  vec2 centered = uv * 2.0 - 1.0;
  float dist = length(centered);

  // Circle - soft edge
  if (shape == 1) {
    return 1.0 - smoothstep(0.8, 1.0, dist);
  }
  // Ring - hollow circle
  else if (shape == 2) {
    return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
  }
  // Square - rounded corners
  else if (shape == 3) {
    float maxCoord = max(abs(centered.x), abs(centered.y));
    return 1.0 - smoothstep(0.8, 0.95, maxCoord);
  }
  // Star - 5-pointed
  else if (shape == 4) {
    float angle = atan(centered.y, centered.x);
    float star = 0.5 + 0.5 * cos(angle * 5.0);
    float r = mix(0.4, 0.9, star);
    return 1.0 - smoothstep(r - 0.1, r, dist);
  }
  return 1.0;
}

// Get UV coordinates for sprite sheet frame
vec2 getSpriteUV(vec2 uv, int frame, vec2 sheetSize) {
  float col = mod(float(frame), sheetSize.x);
  float row = floor(float(frame) / sheetSize.x);
  vec2 frameSize = 1.0 / sheetSize;
  vec2 offset = vec2(col, sheetSize.y - 1.0 - row) * frameSize;
  return offset + uv * frameSize;
}

void main() {
  vec4 texColor = vec4(1.0);

  if (hasDiffuseMap == 1) {
    vec2 texUV = vUv;

    // Sprite sheet animation
    if (spriteFrameCount > 1) {
      int frame;
      if (animateSprite == 1) {
        // Time-based animation
        frame = int(mod(time * spriteFrameRate, float(spriteFrameCount)));
      } else {
        // Life-based animation (frame changes with particle age)
        frame = int(vLifeRatio * float(spriteFrameCount - 1));
      }
      texUV = getSpriteUV(vUv, frame, spriteSheetSize);
    }

    texColor = texture2D(diffuseMap, texUV);
  }
  else if (proceduralShape > 0) {
    float alpha = proceduralAlpha(vUv, proceduralShape);
    texColor = vec4(1.0, 1.0, 1.0, alpha);
  }

  vec4 finalColor = texColor * vColor;
  if (finalColor.a < 0.01) discard;
  gl_FragColor = finalColor;
}
`;
const PARTICLE_GLOW_FRAGMENT_SHADER = `
precision highp float;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;
uniform float glowRadius;
uniform float glowIntensity;

void main() {
  vec2 centered = vUv * 2.0 - 1.0;
  float dist = length(centered);

  // Soft falloff for glow
  float glow = 1.0 - smoothstep(0.0, 1.0, dist);
  glow = pow(glow, 2.0) * glowIntensity;

  // Fade with particle life
  glow *= (1.0 - vLifeRatio * 0.5);

  vec4 glowColor = vec4(vColor.rgb, glow * vColor.a);
  if (glowColor.a < 0.001) discard;
  gl_FragColor = glowColor;
}
`;
const PARTICLE_GLOW_VERTEX_SHADER = `
precision highp float;
attribute vec2 position;
attribute vec2 uv;
attribute vec3 i_position;
attribute vec3 i_velocity;
attribute vec2 i_life;
attribute vec2 i_physical;
attribute vec2 i_rotation;
attribute vec4 i_color;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float glowRadius;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;

void main() {
  if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
    gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
    return;
  }

  // Expand size by glow radius
  float size = i_physical.y * (1.0 + glowRadius);
  float lifeRatio = i_life.x / i_life.y;

  vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
  vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

  vec3 vertexPos = i_position + cameraRight * position.x * size + cameraUp * position.y * size;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);
  vUv = uv;
  vColor = i_color;
  vLifeRatio = lifeRatio;
}
`;

let _webgpuAvailable = null;
let _gpuDevice = null;
async function isWebGPUAvailable() {
  if (_webgpuAvailable !== null) {
    return _webgpuAvailable;
  }
  try {
    if (!navigator.gpu) {
      _webgpuAvailable = false;
      return false;
    }
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      _webgpuAvailable = false;
      return false;
    }
    _gpuDevice = await adapter.requestDevice();
    _webgpuAvailable = true;
    return true;
  } catch {
    _webgpuAvailable = false;
    return false;
  }
}
function getGPUDevice() {
  return _gpuDevice;
}
const PARTICLE_STRUCT = (
  /* wgsl */
  `
struct Particle {
  position: vec3f,
  life: f32,
  velocity: vec3f,
  lifetime: f32,
  size: f32,
  mass: f32,
  rotation: f32,
  rotationSpeed: f32,
  color: vec4f,
}
`
);
const FORCE_FIELD_STRUCT = (
  /* wgsl */
  `
struct ForceField {
  fieldType: u32,      // 0=gravity, 1=point, 2=vortex, 3=turbulence, 4=wind, 5=drag
  position: vec3f,
  strength: f32,
  radius: f32,
  falloff: f32,
  direction: vec3f,
  _padding: f32,
}
`
);
const SIMULATION_PARAMS = (
  /* wgsl */
  `
struct SimParams {
  deltaTime: f32,
  time: f32,
  particleCount: u32,
  forceFieldCount: u32,
  boundsMin: vec3f,
  boundsMax: vec3f,
  damping: f32,
  noiseScale: f32,
  noiseSpeed: f32,
}
`
);
const PARTICLE_PHYSICS_SHADER = (
  /* wgsl */
  `
${PARTICLE_STRUCT}
${FORCE_FIELD_STRUCT}
${SIMULATION_PARAMS}

@group(0) @binding(0) var<storage, read> particlesIn: array<Particle>;
@group(0) @binding(1) var<storage, read_write> particlesOut: array<Particle>;
@group(0) @binding(2) var<uniform> params: SimParams;
@group(0) @binding(3) var<storage, read> forceFields: array<ForceField>;

// Simplex noise for turbulence
fn mod289_3(x: vec3f) -> vec3f {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

fn mod289_4(x: vec4f) -> vec4f {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

fn permute(x: vec4f) -> vec4f {
  return mod289_4(((x * 34.0) + 1.0) * x);
}

fn taylorInvSqrt(r: vec4f) -> vec4f {
  return 1.79284291400159 - 0.85373472095314 * r;
}

fn snoise(v: vec3f) -> f32 {
  let C = vec2f(1.0 / 6.0, 1.0 / 3.0);
  let D = vec4f(0.0, 0.5, 1.0, 2.0);

  var i = floor(v + dot(v, C.yyy));
  let x0 = v - i + dot(i, C.xxx);

  let g = step(x0.yzx, x0.xyz);
  let l = 1.0 - g;
  let i1 = min(g.xyz, l.zxy);
  let i2 = max(g.xyz, l.zxy);

  let x1 = x0 - i1 + C.xxx;
  let x2 = x0 - i2 + C.yyy;
  let x3 = x0 - D.yyy;

  i = mod289_3(i);
  let p = permute(permute(permute(
    i.z + vec4f(0.0, i1.z, i2.z, 1.0))
    + i.y + vec4f(0.0, i1.y, i2.y, 1.0))
    + i.x + vec4f(0.0, i1.x, i2.x, 1.0));

  let n_ = 0.142857142857;
  let ns = n_ * D.wyz - D.xzx;

  let j = p - 49.0 * floor(p * ns.z * ns.z);
  let x_ = floor(j * ns.z);
  let y_ = floor(j - 7.0 * x_);

  let x = x_ * ns.x + ns.yyyy;
  let y = y_ * ns.x + ns.yyyy;
  let h = 1.0 - abs(x) - abs(y);

  let b0 = vec4f(x.xy, y.xy);
  let b1 = vec4f(x.zw, y.zw);

  let s0 = floor(b0) * 2.0 + 1.0;
  let s1 = floor(b1) * 2.0 + 1.0;
  let sh = -step(h, vec4f(0.0));

  let a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  let a1 = b1.xzyw + s1.xzyw * sh.zzww;

  var p0 = vec3f(a0.xy, h.x);
  var p1 = vec3f(a0.zw, h.y);
  var p2 = vec3f(a1.xy, h.z);
  var p3 = vec3f(a1.zw, h.w);

  let norm = taylorInvSqrt(vec4f(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  var m = max(0.6 - vec4f(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec4f(0.0));
  m = m * m;
  return 42.0 * dot(m * m, vec4f(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}

// Curl noise for turbulence force
fn curlNoise(p: vec3f, scale: f32) -> vec3f {
  let e = 0.0001;
  let dx = vec3f(e, 0.0, 0.0);
  let dy = vec3f(0.0, e, 0.0);
  let dz = vec3f(0.0, 0.0, e);
  let ps = p * scale;

  let p_x0 = snoise(ps - dx);
  let p_x1 = snoise(ps + dx);
  let p_y0 = snoise(ps - dy);
  let p_y1 = snoise(ps + dy);
  let p_z0 = snoise(ps - dz);
  let p_z1 = snoise(ps + dz);

  let x = (p_y1 - p_y0) - (p_z1 - p_z0);
  let y = (p_z1 - p_z0) - (p_x1 - p_x0);
  let z = (p_x1 - p_x0) - (p_y1 - p_y0);

  return normalize(vec3f(x, y, z)) * 0.5;
}

// Calculate force from a single force field
fn calculateForce(particle: Particle, field: ForceField) -> vec3f {
  var force = vec3f(0.0);

  switch field.fieldType {
    case 0u: { // Gravity (directional)
      force = field.direction * field.strength;
    }
    case 1u: { // Point attractor/repeller
      let toField = field.position - particle.position;
      let dist = length(toField);
      if dist > 0.001 && dist < field.radius {
        let falloff = 1.0 - pow(dist / field.radius, field.falloff);
        force = normalize(toField) * field.strength * falloff;
      }
    }
    case 2u: { // Vortex
      let toField = field.position - particle.position;
      let dist = length(toField.xy);
      if dist > 0.001 && dist < field.radius {
        let falloff = 1.0 - pow(dist / field.radius, field.falloff);
        let tangent = vec3f(-toField.y, toField.x, 0.0);
        force = normalize(tangent) * field.strength * falloff;
      }
    }
    case 3u: { // Turbulence (curl noise)
      let noisePos = particle.position * params.noiseScale + vec3f(params.time * params.noiseSpeed);
      force = curlNoise(noisePos, 1.0) * field.strength;
    }
    case 4u: { // Wind (directional with noise)
      let noise = snoise(particle.position * 0.01 + vec3f(params.time * 0.5)) * 0.5 + 0.5;
      force = field.direction * field.strength * (0.5 + noise * 0.5);
    }
    case 5u: { // Drag
      force = -particle.velocity * field.strength;
    }
    default: {}
  }

  return force;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3u) {
  let idx = global_id.x;
  if idx >= params.particleCount {
    return;
  }

  var p = particlesIn[idx];

  // Skip dead particles
  if p.life <= 0.0 {
    particlesOut[idx] = p;
    return;
  }

  // Accumulate forces from all force fields
  var totalForce = vec3f(0.0);
  for (var i = 0u; i < params.forceFieldCount; i++) {
    totalForce += calculateForce(p, forceFields[i]);
  }

  // Apply force (F = ma, a = F/m)
  let acceleration = totalForce / max(p.mass, 0.001);

  // Integrate velocity and position (Verlet)
  p.velocity += acceleration * params.deltaTime;
  p.velocity *= params.damping;
  p.position += p.velocity * params.deltaTime;

  // Update rotation
  p.rotation += p.rotationSpeed * params.deltaTime;

  // Update life
  p.life -= params.deltaTime / p.lifetime;

  // Boundary handling (wrap/bounce/kill based on config)
  if p.position.x < params.boundsMin.x || p.position.x > params.boundsMax.x ||
     p.position.y < params.boundsMin.y || p.position.y > params.boundsMax.y ||
     p.position.z < params.boundsMin.z || p.position.z > params.boundsMax.z {
    // Bounce (simple reflection)
    if p.position.x < params.boundsMin.x { p.velocity.x = abs(p.velocity.x); }
    if p.position.x > params.boundsMax.x { p.velocity.x = -abs(p.velocity.x); }
    if p.position.y < params.boundsMin.y { p.velocity.y = abs(p.velocity.y); }
    if p.position.y > params.boundsMax.y { p.velocity.y = -abs(p.velocity.y); }
    if p.position.z < params.boundsMin.z { p.velocity.z = abs(p.velocity.z); }
    if p.position.z > params.boundsMax.z { p.velocity.z = -abs(p.velocity.z); }
  }

  particlesOut[idx] = p;
}
`
);
class WebGPUParticleCompute {
  device;
  pipeline = null;
  bindGroup = null;
  // Buffers
  particleBufferA = null;
  particleBufferB = null;
  paramsBuffer = null;
  forceFieldBuffer = null;
  // State
  pingPong = 0;
  config;
  initialized = false;
  constructor(config) {
    const device = getGPUDevice();
    if (!device) {
      throw new Error("WebGPU device not available");
    }
    this.device = device;
    this.config = config;
  }
  /**
   * Initialize compute pipeline and buffers
   */
  async initialize() {
    if (this.initialized) return;
    const shaderModule = this.device.createShaderModule({
      code: PARTICLE_PHYSICS_SHADER
    });
    this.pipeline = this.device.createComputePipeline({
      layout: "auto",
      compute: {
        module: shaderModule,
        entryPoint: "main"
      }
    });
    const particleByteSize = this.config.maxParticles * 64;
    this.particleBufferA = this.device.createBuffer({
      size: particleByteSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.particleBufferB = this.device.createBuffer({
      size: particleByteSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.paramsBuffer = this.device.createBuffer({
      size: 64,
      // SimParams struct size
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.forceFieldBuffer = this.device.createBuffer({
      size: 16 * 48,
      // 16 force fields * 48 bytes each
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.initialized = true;
  }
  /**
   * Update simulation parameters
   */
  updateParams(deltaTime, time, particleCount, forceFieldCount) {
    if (!this.paramsBuffer) return;
    const paramsBuffer = new ArrayBuffer(64);
    const paramsF32 = new Float32Array(paramsBuffer);
    const paramsU32 = new Uint32Array(paramsBuffer);
    paramsF32[0] = deltaTime;
    paramsF32[1] = time;
    paramsU32[2] = particleCount;
    paramsU32[3] = forceFieldCount;
    paramsF32[4] = this.config.bounds.min[0];
    paramsF32[5] = this.config.bounds.min[1];
    paramsF32[6] = this.config.bounds.min[2];
    paramsF32[7] = 0;
    paramsF32[8] = this.config.bounds.max[0];
    paramsF32[9] = this.config.bounds.max[1];
    paramsF32[10] = this.config.bounds.max[2];
    paramsF32[11] = this.config.damping;
    paramsF32[12] = this.config.noiseScale;
    paramsF32[13] = this.config.noiseSpeed;
    this.device.queue.writeBuffer(this.paramsBuffer, 0, paramsBuffer);
  }
  /**
   * Upload particle data to GPU
   */
  uploadParticles(data) {
    const gpuBuffer = this.pingPong === 0 ? this.particleBufferA : this.particleBufferB;
    if (gpuBuffer) {
      this.device.queue.writeBuffer(gpuBuffer, 0, data.buffer, data.byteOffset, data.byteLength);
    }
  }
  /**
   * Upload force field data
   */
  uploadForceFields(forceFields) {
    if (!this.forceFieldBuffer) return;
    const buffer = new ArrayBuffer(16 * 12 * 4);
    const data = new Float32Array(buffer);
    for (let i = 0; i < Math.min(forceFields.length, 16); i++) {
      const f = forceFields[i];
      const offset = i * 12;
      data[offset + 0] = f.type;
      data[offset + 1] = f.position[0];
      data[offset + 2] = f.position[1];
      data[offset + 3] = f.position[2];
      data[offset + 4] = f.strength;
      data[offset + 5] = f.radius;
      data[offset + 6] = f.falloff;
      data[offset + 7] = f.direction[0];
      data[offset + 8] = f.direction[1];
      data[offset + 9] = f.direction[2];
      data[offset + 10] = 0;
      data[offset + 11] = 0;
    }
    this.device.queue.writeBuffer(this.forceFieldBuffer, 0, buffer);
  }
  /**
   * Execute physics simulation step
   */
  step(particleCount) {
    if (!this.pipeline || !this.particleBufferA || !this.particleBufferB || !this.paramsBuffer || !this.forceFieldBuffer) {
      return;
    }
    const inputBuffer = this.pingPong === 0 ? this.particleBufferA : this.particleBufferB;
    const outputBuffer = this.pingPong === 0 ? this.particleBufferB : this.particleBufferA;
    const bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: inputBuffer } },
        { binding: 1, resource: { buffer: outputBuffer } },
        { binding: 2, resource: { buffer: this.paramsBuffer } },
        { binding: 3, resource: { buffer: this.forceFieldBuffer } }
      ]
    });
    const commandEncoder = this.device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    const workgroupCount = Math.ceil(particleCount / 256);
    passEncoder.dispatchWorkgroups(workgroupCount);
    passEncoder.end();
    this.device.queue.submit([commandEncoder.finish()]);
    this.pingPong = 1 - this.pingPong;
  }
  /**
   * Read particle data back from GPU
   */
  async readParticles(particleCount) {
    const buffer = this.pingPong === 0 ? this.particleBufferA : this.particleBufferB;
    if (!buffer) {
      return new Float32Array(0);
    }
    const byteSize = particleCount * 64;
    const stagingBuffer = this.device.createBuffer({
      size: byteSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, byteSize);
    this.device.queue.submit([commandEncoder.finish()]);
    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const data = new Float32Array(stagingBuffer.getMappedRange().slice(0));
    stagingBuffer.unmap();
    stagingBuffer.destroy();
    return data;
  }
  /**
   * Dispose of GPU resources
   */
  dispose() {
    this.particleBufferA?.destroy();
    this.particleBufferB?.destroy();
    this.paramsBuffer?.destroy();
    this.forceFieldBuffer?.destroy();
    this.particleBufferA = null;
    this.particleBufferB = null;
    this.paramsBuffer = null;
    this.forceFieldBuffer = null;
    this.pipeline = null;
    this.initialized = false;
  }
}

const PARTICLE_STRIDE = 16;
const MAX_FORCE_FIELDS = 16;
const SPATIAL_CELL_SIZE = 50;
const TF_VARYINGS = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function createDefaultEmitter(id) {
  return {
    id: id || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: true,
    // Default to center of standard 832x480 composition
    position: { x: 416, y: 240, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: false,
    beatEmissionMultiplier: 5
  };
}
function createDefaultForceField(type, id) {
  const base = {
    id: id || `force_${Date.now()}`,
    name: type.charAt(0).toUpperCase() + type.slice(1),
    type,
    enabled: true,
    strength: 100,
    // Default to center of standard 832x480 composition
    position: { x: 416, y: 240, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (type) {
    case "gravity":
      base.direction = { x: 0, y: 1, z: 0 };
      base.strength = 98;
      break;
    case "vortex":
      base.vortexAxis = { x: 0, y: 0, z: 1 };
      base.inwardForce = 20;
      break;
    case "turbulence":
      base.noiseScale = 5e-3;
      base.noiseSpeed = 0.5;
      base.noiseOctaves = 3;
      base.noiseLacunarity = 2;
      base.noiseGain = 0.5;
      break;
    case "drag":
      base.linearDrag = 0.1;
      base.quadraticDrag = 0.01;
      break;
    case "wind":
      base.windDirection = { x: 1, y: 0, z: 0 };
      base.gustStrength = 50;
      base.gustFrequency = 0.1;
      break;
    case "lorenz":
      base.lorenzSigma = 10;
      base.lorenzRho = 28;
      base.lorenzBeta = 2.667;
      break;
  }
  return base;
}
function createDefaultConfig() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: true,
      depthWrite: false,
      depthTest: true,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: false,
        receiveShadows: false,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: false,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: false,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: false,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: false,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: false,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: SPATIAL_CELL_SIZE,
    updateFrequency: 1,
    cullOffscreen: true
  };
}
class GPUParticleSystem {
  config;
  gl = null;
  renderer = null;
  // Double-buffered particle data
  particleBufferA;
  particleBufferB;
  currentBuffer = "A";
  // WebGL resources
  transformFeedbackProgram = null;
  renderProgram = null;
  vaoA = null;
  vaoB = null;
  particleVboA = null;
  particleVboB = null;
  transformFeedbackA = null;
  transformFeedbackB = null;
  // Three.js integration
  particleMesh = null;
  instancedGeometry = null;
  material = null;
  // Textures for modulation curves
  sizeOverLifetimeTexture = null;
  opacityOverLifetimeTexture = null;
  colorOverLifetimeTexture = null;
  // Emitter state
  emitters = /* @__PURE__ */ new Map();
  forceFields = /* @__PURE__ */ new Map();
  subEmitters = /* @__PURE__ */ new Map();
  // Runtime state
  state = {
    particleCount: 0,
    activeEmitters: 0,
    simulationTime: 0,
    frameCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0,
    gpuMemoryBytes: 0,
    currentAudioFeatures: /* @__PURE__ */ new Map()
  };
  // Audio reactivity
  audioFeatures = /* @__PURE__ */ new Map();
  // Spatial hash for neighbor queries (flocking)
  spatialHash = /* @__PURE__ */ new Map();
  // Event system
  eventHandlers = /* @__PURE__ */ new Map();
  // Pool of free particle indices
  freeIndices = [];
  nextParticleIndex = 0;
  // Trail system - stores position history for each particle
  trailBuffer = null;
  trailMesh = null;
  trailGeometry = null;
  trailMaterial = null;
  TRAIL_POSITIONS_PER_PARTICLE = 16;
  // Max trail segments
  // Connection system - lines between nearby particles
  connectionMesh = null;
  connectionGeometry = null;
  connectionMaterial = null;
  connectionConfig = null;
  // Texture/sprite system
  particleTexture = null;
  spriteSheetConfig = null;
  // Glow system - renders expanded soft glow behind particles
  glowMesh = null;
  glowMaterial = null;
  glowConfig = null;
  // Random number generator with seed
  rng;
  initialRngSeed;
  currentRngState;
  // Tracks RNG state for save/restore
  // ============================================================================
  // FRAME CACHING SYSTEM
  // Caches particle state every N frames for fast scrubbing
  // ============================================================================
  frameCache = /* @__PURE__ */ new Map();
  cacheInterval = 5;
  // Cache every 5 frames
  maxCacheSize = 200;
  // Max cached frames (1000 frames / 5 = 200)
  cacheVersion = 0;
  // Incremented on parameter changes to invalidate cache
  currentSimulatedFrame = -1;
  // Track which frame we're at
  constructor(config = {}) {
    this.config = { ...createDefaultConfig(), ...config };
    const bufferSize = this.config.maxParticles * PARTICLE_STRIDE;
    this.particleBufferA = new Float32Array(bufferSize);
    this.particleBufferB = new Float32Array(bufferSize);
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.initialRngSeed = this.config.randomSeed ?? Date.now();
    this.currentRngState = this.initialRngSeed;
    this.rng = this.createSeededRandom(this.initialRngSeed);
    this.config.emitters.forEach((e) => this.addEmitter(e));
    this.config.forceFields.forEach((f) => this.addForceField(f));
    this.config.subEmitters.forEach((s) => this.addSubEmitter(s));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  // GPU physics mode flag
  useGPUPhysics = false;
  gpuPhysicsInitialized = false;
  // WebGPU compute physics (preferred over Transform Feedback when available)
  useWebGPU = false;
  webgpuCompute = null;
  webgpuInitialized = false;
  webgpuReadbackPending = false;
  // Force field uniform buffer for GPU physics
  forceFieldBuffer = null;
  forceFieldTexture = null;
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(renderer) {
    this.renderer = renderer;
    this.gl = renderer.getContext();
    if (!this.gl) {
      throw new Error("WebGL2 context required for GPU particle system");
    }
    this.createModulationTextures();
    this.createParticleMesh();
    if (this.config.render.trailLength > 0) {
      this.initializeTrails();
    }
    this.initializeWebGPUPhysics().then((webgpuReady) => {
      if (!webgpuReady) {
        this.initializeGPUPhysics();
      }
    });
    this.state.gpuMemoryBytes = this.config.maxParticles * PARTICLE_STRIDE * 4 * 2;
  }
  /**
   * Initialize WebGPU compute shaders for particle physics
   * Provides best performance for large particle counts (10-100x faster than Transform Feedback)
   */
  async initializeWebGPUPhysics() {
    try {
      const available = await isWebGPUAvailable();
      if (!available) {
        console.log("WebGPU not available, will use Transform Feedback fallback");
        return false;
      }
      const webgpuConfig = {
        maxParticles: this.config.maxParticles,
        bounds: {
          min: [-1e4, -1e4, -1e4],
          max: [1e4, 1e4, 1e4]
        },
        damping: 0.99,
        noiseScale: 5e-3,
        noiseSpeed: 0.5
      };
      this.webgpuCompute = new WebGPUParticleCompute(webgpuConfig);
      await this.webgpuCompute.initialize();
      this.useWebGPU = true;
      this.webgpuInitialized = true;
      this.useGPUPhysics = false;
      console.log("WebGPU compute shaders initialized for particle physics");
      return true;
    } catch (error) {
      console.warn("WebGPU initialization failed:", error);
      this.useWebGPU = false;
      return false;
    }
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    const tfExtension = gl.getExtension("EXT_color_buffer_float");
    if (!tfExtension) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback");
      this.useGPUPhysics = false;
      return;
    }
    try {
      this.transformFeedbackProgram = this.createTransformFeedbackProgram(gl);
      if (!this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics");
        this.useGPUPhysics = false;
        return;
      }
      this.particleVboA = gl.createBuffer();
      this.particleVboB = gl.createBuffer();
      if (!this.particleVboA || !this.particleVboB) {
        throw new Error("Failed to create particle VBOs");
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboA);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferA, gl.DYNAMIC_COPY);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboB);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferB, gl.DYNAMIC_COPY);
      this.vaoA = gl.createVertexArray();
      this.vaoB = gl.createVertexArray();
      if (!this.vaoA || !this.vaoB) {
        throw new Error("Failed to create VAOs");
      }
      this.setupParticleVAO(gl, this.vaoA, this.particleVboA);
      this.setupParticleVAO(gl, this.vaoB, this.particleVboB);
      this.transformFeedbackA = gl.createTransformFeedback();
      this.transformFeedbackB = gl.createTransformFeedback();
      if (!this.transformFeedbackA || !this.transformFeedbackB) {
        throw new Error("Failed to create transform feedback objects");
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackA);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackB);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      this.forceFieldBuffer = new Float32Array(MAX_FORCE_FIELDS * 16);
      this.forceFieldTexture = new DataTexture(
        this.forceFieldBuffer,
        MAX_FORCE_FIELDS,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        RGBAFormat,
        FloatType
      );
      this.useGPUPhysics = true;
      this.gpuPhysicsInitialized = true;
      console.log("GPU physics initialized with Transform Feedback");
    } catch (error) {
      console.warn("GPU physics initialization failed:", error);
      this.useGPUPhysics = false;
      this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(gl, vao, vbo) {
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const stride = PARTICLE_STRIDE * 4;
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 2, gl.FLOAT, false, stride, 32);
    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 2, gl.FLOAT, false, stride, 40);
    gl.enableVertexAttribArray(5);
    gl.vertexAttribPointer(5, 4, gl.FLOAT, false, stride, 48);
    gl.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(gl) {
    const vsSource = TRANSFORM_FEEDBACK_VERTEX_SHADER;
    const fsSource = TRANSFORM_FEEDBACK_FRAGMENT_SHADER;
    const vs = gl.createShader(gl.VERTEX_SHADER);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    if (!vs || !fs) return null;
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback vertex shader error:", gl.getShaderInfoLog(vs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback fragment shader error:", gl.getShaderInfoLog(fs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    const program = gl.createProgram();
    if (!program) {
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.transformFeedbackVaryings(program, TF_VARYINGS, gl.INTERLEAVED_ATTRIBS);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Transform feedback program link error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.deleteShader(vs);
    gl.deleteShader(fs);
    return program;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    if (this.transformFeedbackProgram) {
      gl.deleteProgram(this.transformFeedbackProgram);
      this.transformFeedbackProgram = null;
    }
    if (this.particleVboA) {
      gl.deleteBuffer(this.particleVboA);
      this.particleVboA = null;
    }
    if (this.particleVboB) {
      gl.deleteBuffer(this.particleVboB);
      this.particleVboB = null;
    }
    if (this.vaoA) {
      gl.deleteVertexArray(this.vaoA);
      this.vaoA = null;
    }
    if (this.vaoB) {
      gl.deleteVertexArray(this.vaoB);
      this.vaoB = null;
    }
    if (this.transformFeedbackA) {
      gl.deleteTransformFeedback(this.transformFeedbackA);
      this.transformFeedbackA = null;
    }
    if (this.transformFeedbackB) {
      gl.deleteTransformFeedback(this.transformFeedbackB);
      this.transformFeedbackB = null;
    }
    this.forceFieldTexture?.dispose();
    this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(enabled) {
    if (enabled && !this.gpuPhysicsInitialized) {
      this.initializeGPUPhysics();
    }
    this.useGPUPhysics = enabled && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const resolution = 256;
    const sizeData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, sizeData);
    this.sizeOverLifetimeTexture = new DataTexture(
      sizeData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.sizeOverLifetimeTexture.needsUpdate = true;
    const opacityData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, opacityData);
    this.opacityOverLifetimeTexture = new DataTexture(
      opacityData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.opacityOverLifetimeTexture.needsUpdate = true;
    const colorStops = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ];
    const colorData = new Float32Array(resolution * 4);
    for (let i = 0; i < resolution; i++) {
      const t = i / (resolution - 1);
      const color = this.sampleColorGradient(colorStops, t);
      colorData[i * 4] = color[0];
      colorData[i * 4 + 1] = color[1];
      colorData[i * 4 + 2] = color[2];
      colorData[i * 4 + 3] = color[3];
    }
    this.colorOverLifetimeTexture = new DataTexture(
      colorData,
      resolution,
      1,
      RGBAFormat,
      FloatType
    );
    this.colorOverLifetimeTexture.needsUpdate = true;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(curve, output) {
    const len = output.length;
    if (!curve) {
      output.fill(1);
      return;
    }
    for (let i = 0; i < len; i++) {
      const t = i / (len - 1);
      output[i] = this.evaluateModulationCurve(curve, t);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(curve, t) {
    switch (curve.type) {
      case "constant":
        return curve.value;
      case "linear":
        return curve.start + (curve.end - curve.start) * t;
      case "curve": {
        const points = curve.points;
        if (points.length === 0) return 1;
        if (points.length === 1) return points[0].value;
        let p0 = points[0];
        let p1 = points[points.length - 1];
        for (let i = 0; i < points.length - 1; i++) {
          if (t >= points[i].time && t <= points[i + 1].time) {
            p0 = points[i];
            p1 = points[i + 1];
            break;
          }
        }
        const localT = (t - p0.time) / (p1.time - p0.time);
        const t2 = localT * localT;
        const t3 = t2 * localT;
        const h1 = 2 * t3 - 3 * t2 + 1;
        const h2 = -2 * t3 + 3 * t2;
        const h3 = t3 - 2 * t2 + localT;
        const h4 = t3 - t2;
        return h1 * p0.value + h2 * p1.value + h3 * (p0.outTangent ?? 0) + h4 * (p1.inTangent ?? 0);
      }
      case "random":
        return curve.min + this.rng() * (curve.max - curve.min);
      case "randomCurve": {
        const min = this.evaluateModulationCurve(curve.minCurve, t);
        const max = this.evaluateModulationCurve(curve.maxCurve, t);
        return min + this.rng() * (max - min);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(stops, t) {
    if (stops.length === 0) return [1, 1, 1, 1];
    if (stops.length === 1) return stops[0].color;
    let s0 = stops[0];
    let s1 = stops[stops.length - 1];
    for (let i = 0; i < stops.length - 1; i++) {
      if (t >= stops[i].time && t <= stops[i + 1].time) {
        s0 = stops[i];
        s1 = stops[i + 1];
        break;
      }
    }
    const localT = (t - s0.time) / (s1.time - s0.time);
    return [
      s0.color[0] + (s1.color[0] - s0.color[0]) * localT,
      s0.color[1] + (s1.color[1] - s0.color[1]) * localT,
      s0.color[2] + (s1.color[2] - s0.color[2]) * localT,
      s0.color[3] + (s1.color[3] - s0.color[3]) * localT
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const quadVertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    const quadUVs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new InstancedBufferGeometry();
    this.instancedGeometry.setAttribute("position", new BufferAttribute(quadVertices, 2));
    this.instancedGeometry.setAttribute("uv", new BufferAttribute(quadUVs, 2));
    const positionAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const velocityAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const lifeAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const physicalAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const rotationAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const colorAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    positionAttr.setUsage(DynamicDrawUsage);
    velocityAttr.setUsage(DynamicDrawUsage);
    lifeAttr.setUsage(DynamicDrawUsage);
    physicalAttr.setUsage(DynamicDrawUsage);
    rotationAttr.setUsage(DynamicDrawUsage);
    colorAttr.setUsage(DynamicDrawUsage);
    this.instancedGeometry.setAttribute("i_position", positionAttr);
    this.instancedGeometry.setAttribute("i_velocity", velocityAttr);
    this.instancedGeometry.setAttribute("i_life", lifeAttr);
    this.instancedGeometry.setAttribute("i_physical", physicalAttr);
    this.instancedGeometry.setAttribute("i_rotation", rotationAttr);
    this.instancedGeometry.setAttribute("i_color", colorAttr);
    this.material = new ShaderMaterial({
      vertexShader: PARTICLE_VERTEX_SHADER,
      fragmentShader: PARTICLE_FRAGMENT_SHADER,
      uniforms: this.createUniforms(),
      transparent: true,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    });
    this.particleMesh = new Mesh(this.instancedGeometry, this.material);
    this.particleMesh.frustumCulled = false;
  }
  /**
   * Initialize trail rendering system
   */
  initializeTrails() {
    const trailLength = Math.min(this.config.render.trailLength, this.TRAIL_POSITIONS_PER_PARTICLE);
    const maxTrailVertices = this.config.maxParticles * trailLength * 2;
    this.trailBuffer = new Float32Array(this.config.maxParticles * this.TRAIL_POSITIONS_PER_PARTICLE * 4);
    this.trailGeometry = new BufferGeometry();
    const trailPositions = new Float32Array(maxTrailVertices * 3);
    const trailColors = new Float32Array(maxTrailVertices * 4);
    this.trailGeometry.setAttribute("position", new BufferAttribute(trailPositions, 3));
    this.trailGeometry.setAttribute("color", new BufferAttribute(trailColors, 4));
    this.trailGeometry.getAttribute("position").setUsage(DynamicDrawUsage);
    this.trailGeometry.getAttribute("color").setUsage(DynamicDrawUsage);
    this.trailMaterial = new LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      blending: this.getThreeBlending(),
      depthWrite: false
    });
    this.trailMesh = new LineSegments(this.trailGeometry, this.trailMaterial);
    this.trailMesh.frustumCulled = false;
  }
  /**
   * Update trail positions for all particles
   */
  updateTrails() {
    if (!this.trailBuffer || !this.trailGeometry) return;
    const trailLength = Math.min(this.config.render.trailLength, this.TRAIL_POSITIONS_PER_PARTICLE);
    if (trailLength <= 0) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.trailGeometry.getAttribute("position");
    const colorAttr = this.trailGeometry.getAttribute("color");
    let vertexIndex = 0;
    const fadeMode = this.config.render.trailFadeMode;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const particleOffset = i * PARTICLE_STRIDE;
      const lifetime = buffer[particleOffset + 7];
      const age = buffer[particleOffset + 6];
      if (lifetime <= 0 || age >= lifetime) continue;
      const currentX = buffer[particleOffset + 0];
      const currentY = buffer[particleOffset + 1];
      const currentZ = buffer[particleOffset + 2];
      const currentColor = [
        buffer[particleOffset + 12],
        buffer[particleOffset + 13],
        buffer[particleOffset + 14],
        buffer[particleOffset + 15]
      ];
      const trailOffset = i * this.TRAIL_POSITIONS_PER_PARTICLE * 4;
      for (let t = this.TRAIL_POSITIONS_PER_PARTICLE - 1; t > 0; t--) {
        const srcOffset = trailOffset + (t - 1) * 4;
        const dstOffset = trailOffset + t * 4;
        this.trailBuffer[dstOffset + 0] = this.trailBuffer[srcOffset + 0];
        this.trailBuffer[dstOffset + 1] = this.trailBuffer[srcOffset + 1];
        this.trailBuffer[dstOffset + 2] = this.trailBuffer[srcOffset + 2];
        this.trailBuffer[dstOffset + 3] = this.trailBuffer[srcOffset + 3] + 1;
      }
      this.trailBuffer[trailOffset + 0] = currentX;
      this.trailBuffer[trailOffset + 1] = currentY;
      this.trailBuffer[trailOffset + 2] = currentZ;
      this.trailBuffer[trailOffset + 3] = 0;
      for (let t = 0; t < trailLength - 1; t++) {
        const p1Offset = trailOffset + t * 4;
        const p2Offset = trailOffset + (t + 1) * 4;
        if (this.trailBuffer[p2Offset + 3] >= trailLength) break;
        const x1 = this.trailBuffer[p1Offset + 0];
        const y1 = this.trailBuffer[p1Offset + 1];
        const z1 = this.trailBuffer[p1Offset + 2];
        const x2 = this.trailBuffer[p2Offset + 0];
        const y2 = this.trailBuffer[p2Offset + 1];
        const z2 = this.trailBuffer[p2Offset + 2];
        if (x1 === 0 && y1 === 0 && z1 === 0) break;
        if (x2 === 0 && y2 === 0 && z2 === 0) break;
        const t1Ratio = t / (trailLength - 1);
        const t2Ratio = (t + 1) / (trailLength - 1);
        let alpha1 = currentColor[3];
        let alpha2 = currentColor[3];
        if (fadeMode === "alpha" || fadeMode === "both") {
          alpha1 *= 1 - t1Ratio;
          alpha2 *= 1 - t2Ratio;
        }
        posAttr.setXYZ(vertexIndex, x1, y1, z1);
        colorAttr.setXYZW(vertexIndex, currentColor[0], currentColor[1], currentColor[2], alpha1);
        vertexIndex++;
        posAttr.setXYZ(vertexIndex, x2, y2, z2);
        colorAttr.setXYZW(vertexIndex, currentColor[0], currentColor[1], currentColor[2], alpha2);
        vertexIndex++;
      }
    }
    this.trailGeometry.setDrawRange(0, vertexIndex);
    posAttr.needsUpdate = true;
    colorAttr.needsUpdate = true;
  }
  /**
   * Get the trail mesh for adding to scene
   */
  getTrailMesh() {
    return this.trailMesh;
  }
  /**
   * Initialize particle connection system
   */
  initializeConnections(config) {
    this.connectionConfig = config;
    const maxLines = this.config.maxParticles * config.maxConnections;
    const maxVertices = maxLines * 2;
    this.connectionGeometry = new BufferGeometry();
    const positions = new Float32Array(maxVertices * 3);
    const colors = new Float32Array(maxVertices * 4);
    this.connectionGeometry.setAttribute("position", new BufferAttribute(positions, 3));
    this.connectionGeometry.setAttribute("color", new BufferAttribute(colors, 4));
    this.connectionGeometry.getAttribute("position").setUsage(DynamicDrawUsage);
    this.connectionGeometry.getAttribute("color").setUsage(DynamicDrawUsage);
    this.connectionMaterial = new LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      blending: AdditiveBlending,
      depthWrite: false,
      linewidth: config.lineWidth
      // Note: linewidth only works in some WebGL contexts
    });
    this.connectionMesh = new LineSegments(this.connectionGeometry, this.connectionMaterial);
    this.connectionMesh.frustumCulled = false;
  }
  /**
   * Update particle connections
   * Uses spatial hash for efficient neighbor queries
   */
  updateConnections() {
    if (!this.connectionConfig?.enabled || !this.connectionGeometry) return;
    const config = this.connectionConfig;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.connectionGeometry.getAttribute("position");
    const colorAttr = this.connectionGeometry.getAttribute("color");
    const maxDistSq = config.maxDistance * config.maxDistance;
    let vertexIndex = 0;
    const activeParticles = [];
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      const age = buffer[offset + 6];
      if (lifetime > 0 && age < lifetime) {
        activeParticles.push({
          index: i,
          x: buffer[offset + 0],
          y: buffer[offset + 1],
          z: buffer[offset + 2],
          color: [
            buffer[offset + 12],
            buffer[offset + 13],
            buffer[offset + 14],
            buffer[offset + 15]
          ]
        });
      }
    }
    const connectionCount = /* @__PURE__ */ new Map();
    for (let i = 0; i < activeParticles.length; i++) {
      const p1 = activeParticles[i];
      const p1Connections = connectionCount.get(p1.index) ?? 0;
      if (p1Connections >= config.maxConnections) continue;
      for (let j = i + 1; j < activeParticles.length; j++) {
        const p2 = activeParticles[j];
        const p2Connections = connectionCount.get(p2.index) ?? 0;
        if (p2Connections >= config.maxConnections) continue;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dz = p2.z - p1.z;
        const distSq = dx * dx + dy * dy + dz * dz;
        if (distSq < maxDistSq) {
          let opacity = config.lineOpacity;
          if (config.fadeByDistance) {
            const dist = Math.sqrt(distSq);
            opacity *= 1 - dist / config.maxDistance;
          }
          const color = config.color ?? [
            (p1.color[0] + p2.color[0]) / 2,
            (p1.color[1] + p2.color[1]) / 2,
            (p1.color[2] + p2.color[2]) / 2
          ];
          posAttr.setXYZ(vertexIndex, p1.x, p1.y, p1.z);
          colorAttr.setXYZW(vertexIndex, color[0], color[1], color[2], opacity);
          vertexIndex++;
          posAttr.setXYZ(vertexIndex, p2.x, p2.y, p2.z);
          colorAttr.setXYZW(vertexIndex, color[0], color[1], color[2], opacity);
          vertexIndex++;
          connectionCount.set(p1.index, p1Connections + 1);
          connectionCount.set(p2.index, p2Connections + 1);
          if ((connectionCount.get(p1.index) ?? 0) >= config.maxConnections) break;
        }
      }
    }
    this.connectionGeometry.setDrawRange(0, vertexIndex);
    posAttr.needsUpdate = true;
    colorAttr.needsUpdate = true;
  }
  /**
   * Get the connection mesh for adding to scene
   */
  getConnectionMesh() {
    return this.connectionMesh;
  }
  /**
   * Enable or disable particle connections
   */
  setConnectionsEnabled(enabled) {
    if (this.connectionConfig) {
      this.connectionConfig.enabled = enabled;
    }
  }
  // ============================================================================
  // Collision System
  // ============================================================================
  collisionConfig = null;
  /**
   * Initialize collision system
   */
  initializeCollisions(config) {
    this.collisionConfig = {
      enabled: config.enabled ?? true,
      particleCollision: config.particleCollision ?? false,
      particleRadius: config.particleRadius ?? 5,
      bounciness: config.bounciness ?? 0.5,
      friction: config.friction ?? 0.1,
      bounds: config.bounds ? {
        min: new Vector3(config.bounds.min.x, config.bounds.min.y, config.bounds.min.z),
        max: new Vector3(config.bounds.max.x, config.bounds.max.y, config.bounds.max.z)
      } : void 0,
      boundsBehavior: config.boundsBehavior ?? "none"
    };
  }
  /**
   * Apply collision detection and response
   */
  applyCollisions() {
    if (!this.collisionConfig?.enabled) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const config = this.collisionConfig;
    if (config.bounds && config.boundsBehavior !== "none") {
      this.applyBoundaryCollisions(buffer, config);
    }
    if (config.particleCollision) {
      this.applyParticleCollisions(buffer, config);
    }
  }
  /**
   * Apply boundary collision response
   */
  applyBoundaryCollisions(buffer, config) {
    if (!config.bounds) return;
    const { min, max } = config.bounds;
    const bounciness = config.bounciness;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      const age = buffer[offset + 6];
      if (lifetime <= 0 || age >= lifetime) continue;
      let px = buffer[offset + 0];
      let py = buffer[offset + 1];
      let pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      let collided = false;
      if (px < min.x) {
        if (config.boundsBehavior === "bounce") {
          px = min.x + (min.x - px);
          vx = -vx * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          px = max.x - (min.x - px);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      } else if (px > max.x) {
        if (config.boundsBehavior === "bounce") {
          px = max.x - (px - max.x);
          vx = -vx * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          px = min.x + (px - max.x);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      }
      if (py < min.y) {
        if (config.boundsBehavior === "bounce") {
          py = min.y + (min.y - py);
          vy = -vy * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          py = max.y - (min.y - py);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      } else if (py > max.y) {
        if (config.boundsBehavior === "bounce") {
          py = max.y - (py - max.y);
          vy = -vy * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          py = min.y + (py - max.y);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      }
      if (pz < min.z) {
        if (config.boundsBehavior === "bounce") {
          pz = min.z + (min.z - pz);
          vz = -vz * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          pz = max.z - (min.z - pz);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      } else if (pz > max.z) {
        if (config.boundsBehavior === "bounce") {
          pz = max.z - (pz - max.z);
          vz = -vz * bounciness;
        } else if (config.boundsBehavior === "wrap") {
          pz = min.z + (pz - max.z);
        } else if (config.boundsBehavior === "kill") {
          buffer[offset + 6] = buffer[offset + 7];
          continue;
        }
        collided = true;
      }
      if (collided) {
        buffer[offset + 0] = px;
        buffer[offset + 1] = py;
        buffer[offset + 2] = pz;
        buffer[offset + 3] = vx;
        buffer[offset + 4] = vy;
        buffer[offset + 5] = vz;
      }
    }
  }
  /**
   * Apply particle-particle collision response
   * Uses spatial hash for efficiency
   */
  applyParticleCollisions(buffer, config) {
    const radius = config.particleRadius;
    const radiusSq = radius * radius * 4;
    const bounciness = config.bounciness;
    const cellSize = radius * 4;
    const collisionHash = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      const age = buffer[offset + 6];
      if (lifetime <= 0 || age >= lifetime) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const key = `${cellX},${cellY},${cellZ}`;
      if (!collisionHash.has(key)) {
        collisionHash.set(key, []);
      }
      collisionHash.get(key).push(i);
    }
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      const age = buffer[offset + 6];
      if (lifetime <= 0 || age >= lifetime) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      const mass1 = buffer[offset + 8];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      for (let cx = cellX - 1; cx <= cellX + 1; cx++) {
        for (let cy = cellY - 1; cy <= cellY + 1; cy++) {
          for (let cz = cellZ - 1; cz <= cellZ + 1; cz++) {
            const neighbors = collisionHash.get(`${cx},${cy},${cz}`);
            if (!neighbors) continue;
            for (const j of neighbors) {
              if (j <= i) continue;
              const jOffset = j * PARTICLE_STRIDE;
              const jx = buffer[jOffset + 0];
              const jy = buffer[jOffset + 1];
              const jz = buffer[jOffset + 2];
              const dx = jx - px;
              const dy = jy - py;
              const dz = jz - pz;
              const distSq = dx * dx + dy * dy + dz * dz;
              if (distSq < radiusSq && distSq > 1e-3) {
                const dist = Math.sqrt(distSq);
                const nx = dx / dist;
                const ny = dy / dist;
                const nz = dz / dist;
                let jvx = buffer[jOffset + 3];
                let jvy = buffer[jOffset + 4];
                let jvz = buffer[jOffset + 5];
                const mass2 = buffer[jOffset + 8];
                const dvx = vx - jvx;
                const dvy = vy - jvy;
                const dvz = vz - jvz;
                const dvn = dvx * nx + dvy * ny + dvz * nz;
                if (dvn > 0) continue;
                const totalMass = mass1 + mass2;
                const impulse = -(1 + bounciness) * dvn / totalMass;
                vx += impulse * mass2 * nx;
                vy += impulse * mass2 * ny;
                vz += impulse * mass2 * nz;
                jvx -= impulse * mass1 * nx;
                jvy -= impulse * mass1 * ny;
                jvz -= impulse * mass1 * nz;
                buffer[jOffset + 3] = jvx;
                buffer[jOffset + 4] = jvy;
                buffer[jOffset + 5] = jvz;
                const overlap = (radius * 2 - dist) / 2;
                buffer[offset + 0] -= nx * overlap;
                buffer[offset + 1] -= ny * overlap;
                buffer[offset + 2] -= nz * overlap;
                buffer[jOffset + 0] += nx * overlap;
                buffer[jOffset + 1] += ny * overlap;
                buffer[jOffset + 2] += nz * overlap;
              }
            }
          }
        }
      }
      buffer[offset + 3] = vx;
      buffer[offset + 4] = vy;
      buffer[offset + 5] = vz;
    }
  }
  // ============================================================================
  // Texture/Sprite System
  // ============================================================================
  /**
   * Load a particle texture from URL or data URI
   */
  loadTexture(url, spriteSheet) {
    return new Promise((resolve, reject) => {
      const loader = new TextureLoader();
      loader.load(
        url,
        (texture) => {
          this.particleTexture = texture;
          texture.minFilter = LinearMipMapLinearFilter;
          texture.magFilter = LinearFilter;
          texture.wrapS = ClampToEdgeWrapping;
          texture.wrapT = ClampToEdgeWrapping;
          if (this.material) {
            this.material.uniforms.diffuseMap.value = texture;
            this.material.uniforms.hasDiffuseMap.value = 1;
            this.material.uniforms.proceduralShape.value = 0;
            if (spriteSheet && (spriteSheet.columns || spriteSheet.rows)) {
              const cols = spriteSheet.columns ?? 1;
              const rows = spriteSheet.rows ?? 1;
              this.spriteSheetConfig = {
                columns: cols,
                rows,
                animate: spriteSheet.animate ?? false,
                frameRate: spriteSheet.frameRate ?? 10,
                randomStart: spriteSheet.randomStart ?? false
              };
              this.material.uniforms.spriteSheetSize.value.set(cols, rows);
              this.material.uniforms.spriteFrameCount.value = cols * rows;
              this.material.uniforms.animateSprite.value = spriteSheet.animate ? 1 : 0;
              this.material.uniforms.spriteFrameRate.value = spriteSheet.frameRate ?? 10;
            }
            this.material.needsUpdate = true;
          }
          resolve();
        },
        void 0,
        (error) => {
          console.error("Failed to load particle texture:", error);
          reject(error);
        }
      );
    });
  }
  /**
   * Set procedural shape (no texture)
   * @param shape 0 = none, 1 = circle, 2 = ring, 3 = square, 4 = star
   */
  setProceduralShape(shape) {
    const shapeMap = { none: 0, circle: 1, ring: 2, square: 3, star: 4 };
    if (this.material) {
      this.material.uniforms.hasDiffuseMap.value = 0;
      this.material.uniforms.proceduralShape.value = shapeMap[shape] ?? 1;
      this.material.needsUpdate = true;
    }
    this.particleTexture = null;
    this.spriteSheetConfig = null;
  }
  /**
   * Update time uniform for sprite animation
   */
  updateSpriteAnimation(time) {
    if (this.material && this.spriteSheetConfig?.animate) {
      this.material.uniforms.time.value = time;
    }
  }
  /**
   * Configure motion blur effect
   * Stretches particles along their velocity direction
   */
  setMotionBlur(config) {
    if (!this.material) return;
    this.material.uniforms.motionBlurEnabled.value = config.enabled ? 1 : 0;
    if (config.strength !== void 0) {
      this.material.uniforms.motionBlurStrength.value = config.strength;
    }
    if (config.minStretch !== void 0) {
      this.material.uniforms.minStretch.value = config.minStretch;
    }
    if (config.maxStretch !== void 0) {
      this.material.uniforms.maxStretch.value = config.maxStretch;
    }
    this.config.render.motionBlur = config.enabled;
    if (config.strength !== void 0) {
      this.config.render.motionBlurStrength = config.strength;
    }
    if (config.minStretch !== void 0) {
      this.config.render.minStretch = config.minStretch;
    }
    if (config.maxStretch !== void 0) {
      this.config.render.maxStretch = config.maxStretch;
    }
  }
  /**
   * Initialize glow effect rendering
   * Creates a separate mesh that renders an expanded soft glow behind particles
   */
  initializeGlow(config) {
    this.glowConfig = config;
    if (!config.enabled || !this.instancedGeometry) return;
    this.glowMaterial = new ShaderMaterial({
      vertexShader: PARTICLE_GLOW_VERTEX_SHADER,
      fragmentShader: PARTICLE_GLOW_FRAGMENT_SHADER,
      uniforms: {
        glowRadius: { value: config.radius / 10 },
        // Normalize to 0-1 range
        glowIntensity: { value: config.intensity }
      },
      transparent: true,
      depthWrite: false,
      depthTest: true,
      blending: AdditiveBlending
    });
    this.glowMesh = new Mesh(this.instancedGeometry, this.glowMaterial);
    this.glowMesh.frustumCulled = false;
    this.glowMesh.renderOrder = -1;
  }
  /**
   * Update glow configuration
   */
  setGlow(config) {
    if (!this.glowConfig) {
      this.glowConfig = { enabled: false, radius: 10, intensity: 0.5 };
    }
    if (config.enabled !== void 0) {
      this.glowConfig.enabled = config.enabled;
      if (this.glowMesh) {
        this.glowMesh.visible = config.enabled;
      }
    }
    if (this.glowMaterial) {
      if (config.radius !== void 0) {
        this.glowMaterial.uniforms.glowRadius.value = config.radius / 10;
        this.glowConfig.radius = config.radius;
      }
      if (config.intensity !== void 0) {
        this.glowMaterial.uniforms.glowIntensity.value = config.intensity;
        this.glowConfig.intensity = config.intensity;
      }
    }
  }
  /**
   * Get the glow mesh for adding to scene
   */
  getGlowMesh() {
    return this.glowMesh;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, {
      ...config,
      accumulator: 0,
      velocity: new Vector3()
    });
    this.state.activeEmitters = this.emitters.size;
    this.invalidateCache();
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
      this.invalidateCache();
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.state.activeEmitters = this.emitters.size;
    this.invalidateCache();
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(config) {
    this.forceFields.set(config.id, config);
    this.invalidateCache();
  }
  updateForceField(id, updates) {
    const field = this.forceFields.get(id);
    if (field) {
      Object.assign(field, updates);
      this.invalidateCache();
    }
  }
  removeForceField(id) {
    this.forceFields.delete(id);
    this.invalidateCache();
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(config) {
    this.subEmitters.set(config.id, config);
    this.invalidateCache();
  }
  removeSubEmitter(id) {
    this.subEmitters.delete(id);
    this.invalidateCache();
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(deltaTime) {
    const startTime = performance.now();
    const dt = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : deltaTime * this.config.timeScale;
    this.emitParticles(dt);
    if (this.useWebGPU && this.webgpuCompute) {
      this.updatePhysicsWebGPU(dt);
    } else if (this.useGPUPhysics && this.gl) {
      this.updatePhysicsGPU(dt);
    } else {
      this.updatePhysics(dt);
    }
    this.processSubEmitters();
    if (this.config.flocking?.enabled) {
      this.updateSpatialHash();
      this.applyFlocking(dt);
    }
    if (this.collisionConfig?.enabled) {
      this.applyCollisions();
    }
    this.applyAudioModulation();
    if (this.config.render.trailLength > 0) {
      this.updateTrails();
    }
    if (this.connectionConfig?.enabled) {
      this.updateConnections();
    }
    this.updateInstanceBuffers();
    this.updateSpriteAnimation(this.state.simulationTime);
    this.state.simulationTime += dt;
    this.state.frameCount++;
    this.state.updateTimeMs = performance.now() - startTime;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(dt) {
    for (const emitter of this.emitters.values()) {
      if (!emitter.enabled) continue;
      let emissionRate = emitter.emissionRate;
      const audioMod = this.getAudioModulation("emitter", emitter.id, "emissionRate");
      if (audioMod !== void 0) {
        emissionRate *= audioMod;
      }
      if (emitter.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const burstCount = Math.floor(emitter.burstCount * emitter.beatEmissionMultiplier);
        for (let i = 0; i < burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
      emitter.accumulator += emissionRate * dt;
      while (emitter.accumulator >= 1) {
        this.spawnParticle(emitter);
        emitter.accumulator -= 1;
      }
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(emitter) {
    if (this.freeIndices.length === 0) {
      let oldestIndex = 0;
      let oldestAge = 0;
      const buffer2 = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let i = 0; i < this.config.maxParticles; i++) {
        const age = buffer2[i * PARTICLE_STRIDE + 6];
        if (age > oldestAge) {
          oldestAge = age;
          oldestIndex = i;
        }
      }
      this.freeIndices.push(oldestIndex);
    }
    const index = this.freeIndices.pop();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const offset = index * PARTICLE_STRIDE;
    const pos = this.getEmitterPosition(emitter);
    const dir = this.getEmissionDirection(emitter);
    const speed = emitter.initialSpeed + (this.rng() - 0.5) * 2 * emitter.speedVariance;
    const inheritVel = emitter.velocity.clone().multiplyScalar(emitter.inheritEmitterVelocity);
    buffer[offset + 0] = pos.x;
    buffer[offset + 1] = pos.y;
    buffer[offset + 2] = pos.z;
    buffer[offset + 3] = dir.x * speed + inheritVel.x;
    buffer[offset + 4] = dir.y * speed + inheritVel.y;
    buffer[offset + 5] = dir.z * speed + inheritVel.z;
    buffer[offset + 6] = 0;
    buffer[offset + 7] = emitter.lifetime + (this.rng() - 0.5) * 2 * emitter.lifetimeVariance;
    buffer[offset + 8] = emitter.initialMass + (this.rng() - 0.5) * 2 * emitter.massVariance;
    buffer[offset + 9] = emitter.initialSize + (this.rng() - 0.5) * 2 * emitter.sizeVariance;
    buffer[offset + 10] = emitter.initialRotation + this.rng() * emitter.rotationVariance;
    buffer[offset + 11] = emitter.initialAngularVelocity + (this.rng() - 0.5) * 2 * emitter.angularVelocityVariance;
    const colorT = this.rng() * emitter.colorVariance;
    buffer[offset + 12] = emitter.colorStart[0] + (emitter.colorEnd[0] - emitter.colorStart[0]) * colorT;
    buffer[offset + 13] = emitter.colorStart[1] + (emitter.colorEnd[1] - emitter.colorStart[1]) * colorT;
    buffer[offset + 14] = emitter.colorStart[2] + (emitter.colorEnd[2] - emitter.colorStart[2]) * colorT;
    buffer[offset + 15] = emitter.colorStart[3];
    this.state.particleCount++;
    this.emit("particleBirth", { index, emitterId: emitter.id });
    return index;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(emitter) {
    const shape = emitter.shape;
    const base = new Vector3(emitter.position.x, -emitter.position.y, emitter.position.z);
    switch (shape.type) {
      case "point":
        return base;
      case "circle": {
        const angle = this.rng() * Math.PI * 2;
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.sqrt(this.rng());
        }
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          0
        ));
      }
      case "sphere": {
        const theta = this.rng() * Math.PI * 2;
        const phi = Math.acos(2 * this.rng() - 1);
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.cbrt(this.rng());
        }
        return base.add(new Vector3(
          Math.sin(phi) * Math.cos(theta) * radius,
          Math.sin(phi) * Math.sin(theta) * radius,
          Math.cos(phi) * radius
        ));
      }
      case "box": {
        const size = shape.boxSize ?? { x: 100, y: 100, z: 100 };
        return base.add(new Vector3(
          (this.rng() - 0.5) * size.x,
          (this.rng() - 0.5) * size.y,
          (this.rng() - 0.5) * size.z
        ));
      }
      case "line": {
        const start = shape.lineStart ?? { x: -50, y: 0, z: 0 };
        const end = shape.lineEnd ?? { x: 50, y: 0, z: 0 };
        const t = this.rng();
        return base.add(new Vector3(
          start.x + (end.x - start.x) * t,
          start.y + (end.y - start.y) * t,
          start.z + (end.z - start.z) * t
        ));
      }
      case "cone": {
        const angle = this.rng() * Math.PI * 2;
        const t = this.rng();
        const radius = t * (shape.coneRadius ?? 50);
        const height = t * (shape.coneLength ?? 100);
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        ));
      }
      case "image": {
        if (!shape.imageData) return base;
        const { width, height, data } = shape.imageData;
        const threshold = shape.emissionThreshold ?? 0.1;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * width);
          const py = Math.floor(this.rng() * height);
          const idx = (py * width + px) * 4;
          const alpha = data[idx + 3] / 255;
          if (alpha > threshold) {
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              0
            ));
          }
        }
        return base;
      }
      case "depthEdge": {
        if (!shape.depthData || !shape.imageData) return base;
        const { width, height } = shape.imageData;
        const depthData = shape.depthData;
        const threshold = shape.emissionThreshold ?? 0.05;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * (width - 2)) + 1;
          const py = Math.floor(this.rng() * (height - 2)) + 1;
          const idx = py * width + px;
          const d = depthData[idx];
          const dLeft = depthData[idx - 1];
          const dRight = depthData[idx + 1];
          const dUp = depthData[idx - width];
          const dDown = depthData[idx + width];
          const gradX = Math.abs(dRight - dLeft);
          const gradY = Math.abs(dDown - dUp);
          const gradient = Math.sqrt(gradX * gradX + gradY * gradY);
          if (gradient > threshold) {
            const z = d * 500;
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              z
            ));
          }
        }
        return base;
      }
      case "spline": {
        if (!shape.splineId || !this.splineProvider) return base;
        let t = shape.splineOffset ?? this.rng();
        if (shape.splineOffset === void 0) {
          t = this.rng();
        }
        const point = this.splineProvider(shape.splineId, t);
        if (point) {
          return new Vector3(point.x, -point.y, point.z ?? 0);
        }
        return base;
      }
      case "mesh": {
        if (!shape.meshVertices) return base;
        const vertexCount = shape.meshVertices.length / 3;
        if (vertexCount === 0) return base;
        const vertexIndex = Math.floor(this.rng() * vertexCount);
        const vx = shape.meshVertices[vertexIndex * 3];
        const vy = shape.meshVertices[vertexIndex * 3 + 1];
        const vz = shape.meshVertices[vertexIndex * 3 + 2];
        return base.add(new Vector3(vx, vy, vz));
      }
      default:
        return base;
    }
  }
  // Spline lookup provider - set by external code
  splineProvider = null;
  /**
   * Set the spline provider function for spline-based emission
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(emitter) {
    const baseDir = new Vector3(
      emitter.emissionDirection.x,
      emitter.emissionDirection.y,
      emitter.emissionDirection.z
    ).normalize();
    if (emitter.emissionSpread <= 0) {
      return baseDir;
    }
    const spreadRad = emitter.emissionSpread * Math.PI / 180;
    const theta = this.rng() * Math.PI * 2;
    const phi = Math.acos(1 - this.rng() * (1 - Math.cos(spreadRad)));
    const up = Math.abs(baseDir.y) < 0.99 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0);
    const right = new Vector3().crossVectors(up, baseDir).normalize();
    const realUp = new Vector3().crossVectors(baseDir, right);
    return new Vector3().addScaledVector(baseDir, Math.cos(phi)).addScaledVector(right, Math.sin(phi) * Math.cos(theta)).addScaledVector(realUp, Math.sin(phi) * Math.sin(theta)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(dt) {
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = buffer[offset + 6];
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0 || age >= lifetime) continue;
      let px = buffer[offset + 0];
      let py = buffer[offset + 1];
      let pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      const mass = buffer[offset + 8];
      let fx = 0, fy = 0, fz = 0;
      for (const field of this.forceFields.values()) {
        if (!field.enabled) continue;
        const force = this.calculateForceField(field, px, py, pz, vx, vy, vz, mass);
        fx += force.x;
        fy += force.y;
        fz += force.z;
      }
      const ax = fx / Math.max(mass, 0.1);
      const ay = fy / Math.max(mass, 0.1);
      const az = fz / Math.max(mass, 0.1);
      vx += ax * dt;
      vy += ay * dt;
      vz += az * dt;
      px += vx * dt;
      py += vy * dt;
      pz += vz * dt;
      const lifeRatio = age / lifetime;
      const sizeMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const opacityMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const rotation = buffer[offset + 10] + buffer[offset + 11] * dt;
      buffer[offset + 0] = px;
      buffer[offset + 1] = py;
      buffer[offset + 2] = pz;
      buffer[offset + 3] = vx;
      buffer[offset + 4] = vy;
      buffer[offset + 5] = vz;
      buffer[offset + 6] = age + dt;
      buffer[offset + 9] *= sizeMod;
      buffer[offset + 10] = rotation;
      buffer[offset + 15] *= opacityMod;
      if (age + dt >= lifetime) {
        this.pendingDeathEvents.push({ index: i });
        this.freeIndices.push(i);
        this.state.particleCount--;
        this.emit("particleDeath", { index: i });
      }
    }
  }
  /**
   * Update particle physics using WebGPU compute shaders
   * This is the fastest physics backend, providing 10-100x speedup over Transform Feedback
   */
  updatePhysicsWebGPU(dt) {
    if (!this.webgpuCompute) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const forceFieldData = [];
    for (const field of this.forceFields.values()) {
      if (!field.enabled) continue;
      forceFieldData.push({
        type: this.getForceFieldTypeIndex(field.type),
        position: [field.position.x, field.position.y, field.position.z],
        strength: field.strength,
        radius: field.falloffEnd,
        falloff: field.falloffType === "linear" ? 1 : field.falloffType === "quadratic" ? 2 : 0,
        direction: [
          field.direction?.x ?? field.vortexAxis?.x ?? field.windDirection?.x ?? 0,
          field.direction?.y ?? field.vortexAxis?.y ?? field.windDirection?.y ?? 0,
          field.direction?.z ?? field.vortexAxis?.z ?? field.windDirection?.z ?? 0
        ]
      });
    }
    this.webgpuCompute.uploadParticles(buffer);
    this.webgpuCompute.uploadForceFields(forceFieldData);
    this.webgpuCompute.updateParams(
      dt,
      this.state.simulationTime,
      this.config.maxParticles,
      forceFieldData.length
    );
    this.webgpuCompute.step(this.config.maxParticles);
    if (this.state.frameCount % 10 === 0 && !this.webgpuReadbackPending) {
      this.webgpuReadbackPending = true;
      this.webgpuCompute.readParticles(this.config.maxParticles).then((data) => {
        const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
        targetBuffer.set(data);
        let activeCount = 0;
        for (let i = 0; i < this.config.maxParticles; i++) {
          const offset = i * PARTICLE_STRIDE;
          const age = targetBuffer[offset + 6];
          const lifetime = targetBuffer[offset + 7];
          if (lifetime > 0 && age < lifetime) {
            activeCount++;
          } else if (lifetime > 0 && age >= lifetime) {
            if (!this.freeIndices.includes(i)) {
              this.freeIndices.push(i);
              this.emit("particleDeath", { index: i });
            }
          }
        }
        this.state.particleCount = activeCount;
        this.webgpuReadbackPending = false;
      });
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(dt) {
    if (!this.gl || !this.transformFeedbackProgram) return;
    const gl = this.gl;
    this.updateForceFieldTexture();
    gl.useProgram(this.transformFeedbackProgram);
    const dtLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime");
    const timeLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_time");
    const ffCountLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount");
    const ffTexLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    gl.uniform1f(dtLoc, dt);
    gl.uniform1f(timeLoc, this.state.simulationTime);
    gl.uniform1i(ffCountLoc, Math.min(this.forceFields.size, MAX_FORCE_FIELDS));
    if (this.forceFieldTexture) {
      gl.activeTexture(gl.TEXTURE0);
      const textureProps = this.renderer?.properties.get(this.forceFieldTexture);
      const tex = textureProps?.__webglTexture;
      if (tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(ffTexLoc, 0);
      }
    }
    const readVAO = this.currentBuffer === "A" ? this.vaoA : this.vaoB;
    const writeTF = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB;
    const writeVBO = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    gl.bindVertexArray(readVAO);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, writeTF);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, this.config.maxParticles);
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    this.currentBuffer = this.currentBuffer === "A" ? "B" : "A";
    if (this.state.frameCount % 10 === 0) {
      this.readBackParticleData(writeVBO);
    }
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let fieldIndex = 0;
    for (const field of this.forceFields.values()) {
      if (fieldIndex >= MAX_FORCE_FIELDS) break;
      if (!field.enabled) continue;
      const baseOffset = fieldIndex * 16;
      this.forceFieldBuffer[baseOffset + 0] = field.position.x;
      this.forceFieldBuffer[baseOffset + 1] = field.position.y;
      this.forceFieldBuffer[baseOffset + 2] = field.position.z;
      this.forceFieldBuffer[baseOffset + 3] = this.getForceFieldTypeIndex(field.type);
      this.forceFieldBuffer[baseOffset + 4] = field.strength;
      this.forceFieldBuffer[baseOffset + 5] = field.falloffStart;
      this.forceFieldBuffer[baseOffset + 6] = field.falloffEnd;
      this.forceFieldBuffer[baseOffset + 7] = this.getFalloffTypeIndex(field.falloffType);
      this.forceFieldBuffer[baseOffset + 8] = field.direction?.x ?? field.vortexAxis?.x ?? field.windDirection?.x ?? 0;
      this.forceFieldBuffer[baseOffset + 9] = field.direction?.y ?? field.vortexAxis?.y ?? field.windDirection?.y ?? 0;
      this.forceFieldBuffer[baseOffset + 10] = field.direction?.z ?? field.vortexAxis?.z ?? field.windDirection?.z ?? 0;
      this.forceFieldBuffer[baseOffset + 11] = field.inwardForce ?? 0;
      this.forceFieldBuffer[baseOffset + 12] = field.noiseScale ?? field.linearDrag ?? field.gustStrength ?? 0;
      this.forceFieldBuffer[baseOffset + 13] = field.noiseSpeed ?? field.quadraticDrag ?? field.gustFrequency ?? 0;
      this.forceFieldBuffer[baseOffset + 14] = 0;
      this.forceFieldBuffer[baseOffset + 15] = 0;
      fieldIndex++;
    }
    this.forceFieldTexture.needsUpdate = true;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(type) {
    switch (type) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(type) {
    switch (type) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(vbo) {
    if (!this.gl || !vbo) return;
    const gl = this.gl;
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, targetBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    let activeCount = 0;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = targetBuffer[offset + 6];
      const lifetime = targetBuffer[offset + 7];
      if (lifetime > 0 && age < lifetime) {
        activeCount++;
      } else if (lifetime > 0 && age >= lifetime) {
        if (!this.freeIndices.includes(i)) {
          this.freeIndices.push(i);
          this.emit("particleDeath", { index: i });
        }
      }
    }
    this.state.particleCount = activeCount;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(field, px, py, pz, vx, vy, vz, mass) {
    const force = new Vector3();
    const dx = px - field.position.x;
    const dy = py - field.position.y;
    const dz = pz - field.position.z;
    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let falloff = 1;
    if (dist > field.falloffStart) {
      const t = Math.min((dist - field.falloffStart) / (field.falloffEnd - field.falloffStart), 1);
      switch (field.falloffType) {
        case "linear":
          falloff = 1 - t;
          break;
        case "quadratic":
          falloff = 1 - t * t;
          break;
        case "exponential":
          falloff = Math.exp(-t * 3);
          break;
        case "smoothstep":
          falloff = 1 - (3 * t * t - 2 * t * t * t);
          break;
      }
    }
    const strength = field.strength * falloff;
    switch (field.type) {
      case "gravity":
        force.set(
          (field.direction?.x ?? 0) * strength,
          (field.direction?.y ?? 1) * strength,
          (field.direction?.z ?? 0) * strength
        );
        break;
      case "point":
        if (dist > 1e-3) {
          const dir = new Vector3(-dx, -dy, -dz).normalize();
          force.copy(dir).multiplyScalar(strength / mass);
        }
        break;
      case "vortex":
        if (dist > 1e-3) {
          const axis = new Vector3(
            field.vortexAxis?.x ?? 0,
            field.vortexAxis?.y ?? 0,
            field.vortexAxis?.z ?? 1
          ).normalize();
          const toParticle = new Vector3(dx, dy, dz);
          const tangent = new Vector3().crossVectors(axis, toParticle).normalize();
          const inward = toParticle.normalize().multiplyScalar(-(field.inwardForce ?? 0));
          force.copy(tangent).multiplyScalar(strength).add(inward);
        }
        break;
      case "turbulence": {
        const scale = field.noiseScale ?? 0.01;
        const speed = field.noiseSpeed ?? 0.5;
        const time = this.state.simulationTime * speed;
        const nx = Math.sin(px * scale + time) * Math.cos(py * scale * 1.3) * strength;
        const ny = Math.sin(py * scale + time * 1.1) * Math.cos(pz * scale * 1.2) * strength;
        const nz = Math.sin(pz * scale + time * 0.9) * Math.cos(px * scale * 1.1) * strength;
        force.set(nx, ny, nz);
        break;
      }
      case "drag": {
        const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
        if (speed > 1e-3) {
          const dragMag = (field.linearDrag ?? 0.1) * speed + (field.quadraticDrag ?? 0.01) * speed * speed;
          force.set(-vx, -vy, -vz).normalize().multiplyScalar(-dragMag * strength);
        }
        break;
      }
      case "wind": {
        const windDir = new Vector3(
          field.windDirection?.x ?? 1,
          field.windDirection?.y ?? 0,
          field.windDirection?.z ?? 0
        ).normalize();
        const gust = Math.sin(this.state.simulationTime * (field.gustFrequency ?? 0.5)) * (field.gustStrength ?? 0);
        force.copy(windDir).multiplyScalar(strength + gust);
        break;
      }
      case "lorenz": {
        const sigma = field.lorenzSigma ?? 10;
        const rho = field.lorenzRho ?? 28;
        const beta = field.lorenzBeta ?? 2.667;
        force.set(
          sigma * (dy - dx),
          dx * (rho - dz) - dy,
          dx * dy - beta * dz
        ).multiplyScalar(strength * 0.01);
        break;
      }
    }
    return force;
  }
  /**
   * Process sub-emitter triggers
   * Spawns particles from sub-emitters when parent particles die, collide, etc.
   */
  processSubEmitters() {
    if (this.subEmitters.size === 0) return;
    const deathQueue = this.pendingDeathEvents;
    this.pendingDeathEvents = [];
    for (const death of deathQueue) {
      for (const subEmitter of this.subEmitters.values()) {
        if (subEmitter.trigger !== "death") continue;
        if (!subEmitter.parentEmitterId) continue;
        if (this.rng() > subEmitter.triggerProbability) continue;
        const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
        const offset = death.index * PARTICLE_STRIDE;
        const parentPos = {
          x: buffer[offset + 0],
          y: buffer[offset + 1],
          z: buffer[offset + 2]
        };
        const parentVel = {
          x: buffer[offset + 3],
          y: buffer[offset + 4],
          z: buffer[offset + 5]
        };
        const parentSize = buffer[offset + 9];
        const parentColor = [
          buffer[offset + 12],
          buffer[offset + 13],
          buffer[offset + 14],
          buffer[offset + 15]
        ];
        const parentRotation = buffer[offset + 10];
        const count = subEmitter.emitCount + Math.floor((this.rng() - 0.5) * 2 * subEmitter.emitCountVariance);
        for (let i = 0; i < count; i++) {
          if (this.freeIndices.length === 0) break;
          const index = this.freeIndices.pop();
          const subOffset = index * PARTICLE_STRIDE;
          if (subEmitter.inheritPosition) {
            buffer[subOffset + 0] = parentPos.x;
            buffer[subOffset + 1] = parentPos.y;
            buffer[subOffset + 2] = parentPos.z;
          } else {
            buffer[subOffset + 0] = parentPos.x;
            buffer[subOffset + 1] = parentPos.y;
            buffer[subOffset + 2] = parentPos.z;
          }
          const overrides = subEmitter.overrides;
          const speed = overrides.initialSpeed ?? 100;
          const spread = overrides.emissionSpread ?? 180;
          const theta = this.rng() * Math.PI * 2;
          const phi = Math.acos(1 - this.rng() * (1 - Math.cos(spread * Math.PI / 180)));
          const newVelX = Math.sin(phi) * Math.cos(theta) * speed;
          const newVelY = Math.sin(phi) * Math.sin(theta) * speed;
          const newVelZ = Math.cos(phi) * speed;
          const inheritVel = subEmitter.inheritVelocity;
          buffer[subOffset + 3] = newVelX + parentVel.x * inheritVel;
          buffer[subOffset + 4] = newVelY + parentVel.y * inheritVel;
          buffer[subOffset + 5] = newVelZ + parentVel.z * inheritVel;
          buffer[subOffset + 6] = 0;
          buffer[subOffset + 7] = overrides.lifetime ?? 30;
          buffer[subOffset + 8] = overrides.initialMass ?? 1;
          buffer[subOffset + 9] = (overrides.initialSize ?? 5) * (subEmitter.inheritSize > 0 ? parentSize * subEmitter.inheritSize : 1);
          buffer[subOffset + 10] = subEmitter.inheritRotation > 0 ? parentRotation * subEmitter.inheritRotation : this.rng() * Math.PI * 2;
          buffer[subOffset + 11] = overrides.initialAngularVelocity ?? 0;
          const colorStart = overrides.colorStart ?? [1, 1, 1, 1];
          if (subEmitter.inheritColor > 0) {
            buffer[subOffset + 12] = parentColor[0] * subEmitter.inheritColor + colorStart[0] * (1 - subEmitter.inheritColor);
            buffer[subOffset + 13] = parentColor[1] * subEmitter.inheritColor + colorStart[1] * (1 - subEmitter.inheritColor);
            buffer[subOffset + 14] = parentColor[2] * subEmitter.inheritColor + colorStart[2] * (1 - subEmitter.inheritColor);
            buffer[subOffset + 15] = parentColor[3] * subEmitter.inheritColor + colorStart[3] * (1 - subEmitter.inheritColor);
          } else {
            buffer[subOffset + 12] = colorStart[0];
            buffer[subOffset + 13] = colorStart[1];
            buffer[subOffset + 14] = colorStart[2];
            buffer[subOffset + 15] = colorStart[3];
          }
          this.state.particleCount++;
          this.emit("particleBirth", { index, emitterId: subEmitter.id, isSubEmitter: true });
        }
      }
    }
  }
  // Queue for sub-emitter death triggers
  pendingDeathEvents = [];
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const key = `${cellX},${cellY},${cellZ}`;
      if (!this.spatialHash.has(key)) {
        this.spatialHash.set(key, []);
      }
      this.spatialHash.get(key).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(dt) {
    const config = this.config.flocking;
    if (!config?.enabled) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const separation = new Vector3();
      const alignment = new Vector3();
      const cohesion = new Vector3();
      let separationCount = 0;
      let alignmentCount = 0;
      let cohesionCount = 0;
      for (let cx = cellX - 1; cx <= cellX + 1; cx++) {
        for (let cy = cellY - 1; cy <= cellY + 1; cy++) {
          for (let cz = cellZ - 1; cz <= cellZ + 1; cz++) {
            const neighbors = this.spatialHash.get(`${cx},${cy},${cz}`);
            if (!neighbors) continue;
            for (const j of neighbors) {
              if (j === i) continue;
              const jOffset = j * PARTICLE_STRIDE;
              const jx = buffer[jOffset + 0];
              const jy = buffer[jOffset + 1];
              const jz = buffer[jOffset + 2];
              const dx = px - jx;
              const dy = py - jy;
              const dz = pz - jz;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (dist < config.separationRadius && dist > 0) {
                separation.add(new Vector3(dx, dy, dz).divideScalar(dist));
                separationCount++;
              }
              if (dist < config.alignmentRadius) {
                alignment.add(new Vector3(
                  buffer[jOffset + 3],
                  buffer[jOffset + 4],
                  buffer[jOffset + 5]
                ));
                alignmentCount++;
              }
              if (dist < config.cohesionRadius) {
                cohesion.add(new Vector3(jx, jy, jz));
                cohesionCount++;
              }
            }
          }
        }
      }
      if (separationCount > 0) {
        separation.divideScalar(separationCount).normalize().multiplyScalar(config.separationWeight);
      }
      if (alignmentCount > 0) {
        alignment.divideScalar(alignmentCount).normalize().multiplyScalar(config.alignmentWeight);
      }
      if (cohesionCount > 0) {
        cohesion.divideScalar(cohesionCount);
        cohesion.sub(new Vector3(px, py, pz)).normalize().multiplyScalar(config.cohesionWeight);
      }
      const steering = separation.add(alignment).add(cohesion);
      if (steering.length() > config.maxForce) {
        steering.normalize().multiplyScalar(config.maxForce);
      }
      buffer[offset + 3] += steering.x * dt;
      buffer[offset + 4] += steering.y * dt;
      buffer[offset + 5] += steering.z * dt;
      const speed = Math.sqrt(
        buffer[offset + 3] ** 2 + buffer[offset + 4] ** 2 + buffer[offset + 5] ** 2
      );
      if (speed > config.maxSpeed) {
        const scale = config.maxSpeed / speed;
        buffer[offset + 3] *= scale;
        buffer[offset + 4] *= scale;
        buffer[offset + 5] *= scale;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const binding of this.config.audioBindings) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      const smoothed = featureValue;
      const t = (smoothed - binding.min) / (binding.max - binding.min);
      let output = binding.outputMin + t * (binding.outputMax - binding.outputMin);
      if (binding.curve === "exponential") {
        output = binding.outputMin + Math.pow(t, 2) * (binding.outputMax - binding.outputMin);
      } else if (binding.curve === "logarithmic") {
        output = binding.outputMin + Math.sqrt(t) * (binding.outputMax - binding.outputMin);
      }
      if (binding.target === "emitter") {
        const emitter = this.emitters.get(binding.targetId);
        if (emitter) {
          emitter[binding.parameter] = output;
        }
      } else if (binding.target === "forceField") {
        const field = this.forceFields.get(binding.targetId);
        if (field) {
          field[binding.parameter] = output;
        }
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(target, targetId, parameter) {
    for (const binding of this.config.audioBindings) {
      if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
        const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
        const t = (featureValue - binding.min) / (binding.max - binding.min);
        return binding.outputMin + t * (binding.outputMax - binding.outputMin);
      }
    }
    return void 0;
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.instancedGeometry.getAttribute("i_position");
    const velAttr = this.instancedGeometry.getAttribute("i_velocity");
    const lifeAttr = this.instancedGeometry.getAttribute("i_life");
    const physAttr = this.instancedGeometry.getAttribute("i_physical");
    const rotAttr = this.instancedGeometry.getAttribute("i_rotation");
    const colAttr = this.instancedGeometry.getAttribute("i_color");
    for (let i = 0; i < this.config.maxParticles; i++) {
      const src = i * PARTICLE_STRIDE;
      posAttr.setXYZ(i, buffer[src + 0], buffer[src + 1], buffer[src + 2]);
      velAttr.setXYZ(i, buffer[src + 3], buffer[src + 4], buffer[src + 5]);
      lifeAttr.setXY(i, buffer[src + 6], buffer[src + 7]);
      physAttr.setXY(i, buffer[src + 8], buffer[src + 9]);
      rotAttr.setXY(i, buffer[src + 10], buffer[src + 11]);
      colAttr.setXYZW(i, buffer[src + 12], buffer[src + 13], buffer[src + 14], buffer[src + 15]);
    }
    posAttr.needsUpdate = true;
    velAttr.needsUpdate = true;
    lifeAttr.needsUpdate = true;
    physAttr.needsUpdate = true;
    rotAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(feature, value) {
    this.audioFeatures.set(feature, value);
    this.state.currentAudioFeatures.set(feature, value);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1);
    requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(emitterId) {
    if (emitterId) {
      const emitter = this.emitters.get(emitterId);
      if (emitter) {
        for (let i = 0; i < emitter.burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
    } else {
      for (const emitter of this.emitters.values()) {
        if (emitter.burstOnBeat && emitter.enabled) {
          for (let i = 0; i < emitter.burstCount; i++) {
            this.spawnParticle(emitter);
          }
        }
      }
    }
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 },
      // Circle by default
      // Sprite sheet uniforms
      spriteSheetSize: { value: new Vector2(1, 1) },
      // columns, rows
      spriteFrameCount: { value: 1 },
      animateSprite: { value: 0 },
      spriteFrameRate: { value: 10 },
      time: { value: 0 },
      // Motion blur uniforms
      motionBlurEnabled: { value: this.config.render.motionBlur ? 1 : 0 },
      motionBlurStrength: { value: this.config.render.motionBlurStrength ?? 0.1 },
      minStretch: { value: this.config.render.minStretch ?? 1 },
      maxStretch: { value: this.config.render.maxStretch ?? 4 }
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return AdditiveBlending;
      case "multiply":
        return MultiplyBlending;
      case "screen":
        return CustomBlending;
      default:
        return NormalBlending;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(event, handler) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(event).add(handler);
  }
  off(event, handler) {
    this.eventHandlers.get(event)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => handler(event));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   * State is tracked externally via currentRngState for save/restore
   */
  createSeededRandom(seed) {
    this.currentRngState = seed;
    return () => {
      this.currentRngState = this.currentRngState * 1103515245 + 12345 & 2147483647;
      return this.currentRngState / 2147483647;
    };
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    const emitters = Array.from(this.emitters.values()).map((e) => {
      const { accumulator, velocity, ...config } = e;
      return config;
    });
    return {
      emitters,
      forceFields: Array.from(this.forceFields.values())
    };
  }
  // ============================================================================
  // FRAME CACHING METHODS
  // ============================================================================
  /**
   * Cache the current particle state for a specific frame
   * Called automatically every cacheInterval frames during step()
   */
  cacheCurrentState(frame) {
    if (this.frameCache.size >= this.maxCacheSize) {
      const oldestFrame = Math.min(...this.frameCache.keys());
      this.frameCache.delete(oldestFrame);
    }
    const emitterAccumulators = /* @__PURE__ */ new Map();
    for (const [id, emitter] of this.emitters) {
      emitterAccumulators.set(id, emitter.accumulator);
    }
    const currentBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    this.frameCache.set(frame, {
      frame,
      version: this.cacheVersion,
      particleBuffer: new Float32Array(currentBuffer),
      // Deep copy
      freeIndices: [...this.freeIndices],
      // Copy array
      particleCount: this.state.particleCount,
      simulationTime: this.state.simulationTime,
      rngState: this.currentRngState,
      emitterAccumulators
    });
  }
  /**
   * Restore particle state from a cached frame
   * @returns true if restore succeeded, false if cache miss or version mismatch
   */
  restoreFromCache(frame) {
    const cached = this.frameCache.get(frame);
    if (!cached || cached.version !== this.cacheVersion) {
      return false;
    }
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    targetBuffer.set(cached.particleBuffer);
    this.freeIndices = [...cached.freeIndices];
    this.state.particleCount = cached.particleCount;
    this.state.simulationTime = cached.simulationTime;
    this.state.frameCount = frame;
    this.currentSimulatedFrame = frame;
    this.currentRngState = cached.rngState;
    for (const [id, accumulator] of cached.emitterAccumulators) {
      const emitter = this.emitters.get(id);
      if (emitter) {
        emitter.accumulator = accumulator;
      }
    }
    this.updateInstanceBuffers();
    return true;
  }
  /**
   * Find the nearest cached frame at or before the target frame
   * @returns The nearest cached frame number, or -1 if no cache exists
   */
  findNearestCache(targetFrame) {
    let nearestFrame = -1;
    for (const frame of this.frameCache.keys()) {
      const cached = this.frameCache.get(frame);
      if (cached && cached.version === this.cacheVersion && frame <= targetFrame && frame > nearestFrame) {
        nearestFrame = frame;
      }
    }
    return nearestFrame;
  }
  /**
   * Clear all cached frames
   */
  clearCache() {
    this.frameCache.clear();
    this.currentSimulatedFrame = -1;
  }
  /**
   * Invalidate the cache by incrementing version
   * Called when particle parameters change (emitter config, force fields, etc.)
   */
  invalidateCache() {
    this.cacheVersion++;
    this.currentSimulatedFrame = -1;
  }
  /**
   * Simulate particles to a specific frame, using cache when available
   * This is the main entry point for timeline scrubbing
   *
   * @param targetFrame The frame number to simulate to
   * @param fps Frames per second for deltaTime calculation
   * @returns The number of simulation steps performed
   */
  simulateToFrame(targetFrame, fps = 30) {
    const deltaTime = 1 / fps;
    if (this.currentSimulatedFrame === targetFrame) {
      return 0;
    }
    if (this.currentSimulatedFrame >= 0 && this.currentSimulatedFrame < targetFrame && targetFrame - this.currentSimulatedFrame <= this.cacheInterval * 2) {
      let steps2 = 0;
      for (let f = this.currentSimulatedFrame + 1; f <= targetFrame; f++) {
        this.step(deltaTime);
        this.currentSimulatedFrame = f;
        if (f % this.cacheInterval === 0) {
          this.cacheCurrentState(f);
        }
        steps2++;
      }
      return steps2;
    }
    const nearestCache = this.findNearestCache(targetFrame);
    let startFrame = 0;
    if (nearestCache >= 0) {
      if (this.restoreFromCache(nearestCache)) {
        startFrame = nearestCache;
      }
    }
    if (startFrame === 0) {
      this.reset();
      this.currentSimulatedFrame = 0;
      this.cacheCurrentState(0);
    }
    let steps = 0;
    for (let f = startFrame + 1; f <= targetFrame; f++) {
      this.step(deltaTime);
      this.currentSimulatedFrame = f;
      if (f % this.cacheInterval === 0) {
        this.cacheCurrentState(f);
      }
      steps++;
    }
    return steps;
  }
  /**
   * Get cache statistics for debugging/UI
   */
  getCacheStats() {
    let validCount = 0;
    for (const cached of this.frameCache.values()) {
      if (cached.version === this.cacheVersion) {
        validCount++;
      }
    }
    return {
      cachedFrames: validCount,
      version: this.cacheVersion,
      currentFrame: this.currentSimulatedFrame,
      cacheInterval: this.cacheInterval,
      maxCacheSize: this.maxCacheSize
    };
  }
  /**
   * Set the cache interval (how often to cache frames)
   */
  setCacheInterval(interval) {
    this.cacheInterval = Math.max(1, interval);
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets RNG to initial seed for reproducible simulation
   */
  reset() {
    this.particleBufferA.fill(0);
    this.particleBufferB.fill(0);
    this.freeIndices = [];
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.state.particleCount = 0;
    this.state.simulationTime = 0;
    this.state.frameCount = 0;
    this.spatialHash.clear();
    for (const emitter of this.emitters.values()) {
      emitter.accumulator = 0;
    }
    this.currentSimulatedFrame = -1;
    this.rng = this.createSeededRandom(this.config.randomSeed ?? 12345);
  }
  /**
   * Get the current seed
   */
  getSeed() {
    return this.config.randomSeed ?? 12345;
  }
  /**
   * Set a new seed and reset the system
   * DETERMINISM: Used to ensure layer-specific reproducible seeds
   */
  setSeed(seed) {
    this.config.randomSeed = seed;
    this.initialRngSeed = seed;
    this.clearCache();
    this.reset();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.instancedGeometry?.dispose();
    this.material?.dispose();
    this.sizeOverLifetimeTexture?.dispose();
    this.opacityOverLifetimeTexture?.dispose();
    this.colorOverLifetimeTexture?.dispose();
    if (this.webgpuCompute) {
      this.webgpuCompute.dispose();
      this.webgpuCompute = null;
      this.useWebGPU = false;
      this.webgpuInitialized = false;
    }
    this.cleanupGPUPhysics();
    this.emitters.clear();
    this.forceFields.clear();
    this.subEmitters.clear();
    this.eventHandlers.clear();
  }
}

class ParticleLayer extends BaseLayer {
  /** The GPU particle system instance */
  particleSystem;
  /** Particle system configuration */
  systemConfig;
  /** Whether the system has been initialized with a renderer */
  initialized = false;
  /** Stored renderer reference for reinitialization */
  rendererRef = null;
  /** Composition FPS for time calculation */
  fps = 60;
  /** Deterministic seed derived from layer ID */
  layerSeed;
  /** Last evaluated frame (for scrub detection) */
  lastEvaluatedFrame = -1;
  /** Performance stats */
  stats = {
    particleCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0
  };
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /** Emitter visualization icons */
  emitterGizmos = /* @__PURE__ */ new Map();
  /** Force field visualization icons */
  forceFieldGizmos = /* @__PURE__ */ new Map();
  /** Whether emitter gizmos are visible */
  showEmitterGizmos = true;
  /** Whether force field gizmos are visible */
  showForceFieldGizmos = true;
  constructor(layerData) {
    super(layerData);
    this.layerSeed = this.generateSeedFromId(layerData.id);
    this.systemConfig = this.buildSystemConfig(layerData);
    this.systemConfig.randomSeed = this.layerSeed;
    this.particleSystem = new GPUParticleSystem(this.systemConfig);
    this.initializeBlendMode();
  }
  /**
   * Generate deterministic seed from layer ID
   * DETERMINISM: Same layer ID always produces identical seed
   */
  generateSeedFromId(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash) || 12345;
  }
  /**
   * Convert emitter shape from project format to GPU format
   * Supports: point, circle, sphere, box, line, ring, cone, spline
   */
  convertEmitterShape(emitter) {
    const shape = emitter.shape ?? "point";
    switch (shape) {
      case "point":
        return { type: "point" };
      case "circle":
        return {
          type: "circle",
          radius: emitter.shapeRadius ?? 50,
          emitFromEdge: emitter.emitFromEdge ?? false
        };
      case "sphere":
        return {
          type: "sphere",
          radius: emitter.shapeRadius ?? 50,
          emitFromEdge: emitter.emitFromEdge ?? false
        };
      case "box":
        return {
          type: "box",
          boxSize: {
            x: emitter.shapeWidth ?? 100,
            y: emitter.shapeHeight ?? 100,
            z: emitter.shapeDepth ?? 0
          }
        };
      case "line":
        const halfWidth = (emitter.shapeWidth ?? 100) / 2;
        return {
          type: "line",
          lineStart: { x: -halfWidth, y: 0, z: 0 },
          lineEnd: { x: halfWidth, y: 0, z: 0 }
        };
      case "ring":
        return {
          type: "circle",
          radius: emitter.shapeRadius ?? 50,
          radiusVariance: emitter.shapeInnerRadius ?? 0,
          emitFromEdge: true
          // Ring always emits from edge
        };
      case "spline":
        if (emitter.splinePath) {
          return {
            type: "spline",
            splineId: emitter.splinePath.layerId,
            splineOffset: emitter.splinePath.parameter ?? 0
          };
        }
        return { type: "point" };
      case "depth-map":
      case "mask":
        return { type: "point" };
      default:
        return { type: "point" };
    }
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(layerData) {
    const data = layerData.data;
    const config = createDefaultConfig();
    if (!data) {
      config.emitters = [createDefaultEmitter("default")];
      return config;
    }
    if (data.systemConfig) {
      config.maxParticles = data.systemConfig.maxParticles ?? 1e5;
      config.timeScale = 1;
      if (data.systemConfig.gravity !== 0) {
        config.forceFields.push({
          id: "global_gravity",
          name: "Gravity",
          type: "gravity",
          enabled: true,
          strength: data.systemConfig.gravity * 10,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          direction: { x: 0, y: 1, z: 0 }
        });
      }
      if (data.systemConfig.windStrength !== 0) {
        const windAngle = (data.systemConfig.windDirection ?? 0) * Math.PI / 180;
        config.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: true,
          strength: data.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(windAngle),
            y: Math.sin(windAngle),
            z: 0
          },
          gustStrength: data.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (data.systemConfig.friction > 0) {
        config.forceFields.push({
          id: "global_drag",
          name: "Friction",
          type: "drag",
          enabled: true,
          strength: 1,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          linearDrag: data.systemConfig.friction,
          quadraticDrag: data.systemConfig.friction * 0.1
        });
      }
      if (data.systemConfig.turbulenceFields) {
        for (const turbField of data.systemConfig.turbulenceFields) {
          if (turbField.enabled) {
            config.forceFields.push({
              id: turbField.id,
              name: "Turbulence",
              type: "turbulence",
              enabled: true,
              strength: turbField.strength,
              position: { x: 0, y: 0, z: 0 },
              falloffStart: 0,
              falloffEnd: 1e4,
              falloffType: "none",
              noiseScale: turbField.scale,
              noiseSpeed: turbField.evolutionSpeed,
              noiseOctaves: 3,
              noiseLacunarity: 2,
              noiseGain: 0.5
            });
          }
        }
      }
    }
    if (data.emitters) {
      for (const emitter of data.emitters) {
        if (!emitter.enabled) continue;
        const dirRad = (emitter.direction ?? 0) * Math.PI / 180;
        const shapeConfig = this.convertEmitterShape(emitter);
        const gpuEmitter = {
          id: emitter.id,
          name: emitter.name,
          enabled: true,
          position: { x: emitter.x, y: emitter.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: shapeConfig,
          emissionRate: emitter.emissionRate,
          emissionRateVariance: 0,
          burstCount: emitter.burstCount,
          burstInterval: 0,
          initialSpeed: emitter.speed,
          speedVariance: emitter.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: emitter.size,
          sizeVariance: emitter.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: emitter.particleLifetime,
          lifetimeVariance: emitter.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            1
          ],
          colorEnd: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(dirRad),
            y: Math.sin(dirRad),
            z: 0
          },
          emissionSpread: emitter.spread,
          burstOnBeat: emitter.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        config.emitters.push(gpuEmitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        if (!well.enabled) continue;
        config.forceFields.push({
          id: well.id,
          name: well.name,
          type: "point",
          enabled: true,
          strength: well.strength,
          position: { x: well.x, y: well.y, z: 0 },
          falloffStart: 0,
          falloffEnd: well.radius,
          falloffType: well.falloff === "linear" ? "linear" : well.falloff === "quadratic" ? "quadratic" : "none"
        });
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        if (!vortex.enabled) continue;
        config.forceFields.push({
          id: vortex.id,
          name: vortex.name,
          type: "vortex",
          enabled: true,
          strength: vortex.strength * vortex.rotationSpeed,
          position: { x: vortex.x, y: vortex.y, z: 0 },
          falloffStart: 0,
          falloffEnd: vortex.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: vortex.inwardPull
        });
      }
    }
    if (data.modulations) {
      const sizeModulations = data.modulations.filter((m) => m.property === "size");
      if (sizeModulations.length > 0) {
        const mod = sizeModulations[0];
        config.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
      const opacityModulations = data.modulations.filter((m) => m.property === "opacity");
      if (opacityModulations.length > 0) {
        const mod = opacityModulations[0];
        config.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
    }
    if (data.subEmitters) {
      for (const sub of data.subEmitters) {
        if (!sub.enabled) continue;
        const gpuSubEmitter = {
          id: sub.id,
          parentEmitterId: sub.parentEmitterId,
          trigger: sub.trigger,
          triggerProbability: 1,
          emitCount: sub.spawnCount,
          emitCountVariance: 0,
          inheritPosition: true,
          inheritVelocity: sub.inheritVelocity,
          inheritSize: 0,
          inheritColor: 0,
          inheritRotation: 0,
          overrides: {
            initialSpeed: sub.speed,
            emissionSpread: sub.spread,
            initialSize: sub.size,
            initialMass: 1,
            lifetime: sub.lifetime,
            lifetimeVariance: sub.sizeVariance,
            // Use size variance for lifetime variance
            colorStart: [
              sub.color[0] / 255,
              sub.color[1] / 255,
              sub.color[2] / 255,
              1
            ],
            colorEnd: [
              sub.color[0] / 255,
              sub.color[1] / 255,
              sub.color[2] / 255,
              0
            ]
          }
        };
        config.subEmitters.push(gpuSubEmitter);
      }
    }
    if (data.flocking?.enabled) {
      config.flocking = {
        enabled: true,
        separationWeight: (data.flocking.separationWeight ?? 50) / 100,
        separationRadius: data.flocking.separationRadius ?? 25,
        alignmentWeight: (data.flocking.alignmentWeight ?? 50) / 100,
        alignmentRadius: data.flocking.alignmentRadius ?? 50,
        cohesionWeight: (data.flocking.cohesionWeight ?? 50) / 100,
        cohesionRadius: data.flocking.cohesionRadius ?? 50,
        maxSpeed: data.flocking.maxSpeed ?? 200,
        maxForce: data.flocking.maxForce ?? 10,
        perceptionAngle: data.flocking.perceptionAngle ?? 270
      };
    }
    if (data.collision?.enabled) {
      this.pendingCollisionConfig = {
        enabled: true,
        particleCollision: data.collision.particleCollision ?? false,
        particleRadius: data.collision.particleRadius ?? 5,
        bounciness: data.collision.bounciness ?? 0.5,
        friction: data.collision.friction ?? 0.1,
        bounds: data.collision.boundaryEnabled ? {
          min: { x: data.collision.boundaryPadding, y: data.collision.boundaryPadding, z: -1e3 },
          max: { x: 1920 - data.collision.boundaryPadding, y: 1080 - data.collision.boundaryPadding, z: 1e3 }
        } : void 0,
        boundsBehavior: data.collision.boundaryBehavior ?? "none"
      };
    }
    if (data.renderOptions) {
      config.render.blendMode = data.renderOptions.blendMode ?? "normal";
      config.render.motionBlur = data.renderOptions.motionBlur ?? false;
      config.render.motionBlurStrength = data.renderOptions.motionBlurStrength ?? 0.5;
      config.render.motionBlurSamples = data.renderOptions.motionBlurSamples ?? 4;
      if (data.renderOptions.renderTrails) {
        config.render.mode = "trail";
        config.render.trailLength = data.renderOptions.trailLength;
        config.render.trailWidthEnd = 1 - (data.renderOptions.trailOpacityFalloff ?? 0.8);
      }
      config.render.texture.proceduralType = data.renderOptions.particleShape === "star" ? "star" : data.renderOptions.particleShape === "square" ? "square" : "circle";
      if (data.renderOptions.connections?.enabled) {
        this.pendingConnectionConfig = {
          enabled: true,
          maxDistance: data.renderOptions.connections.maxDistance ?? 100,
          maxConnections: data.renderOptions.connections.maxConnections ?? 5,
          lineWidth: data.renderOptions.connections.lineWidth ?? 1,
          lineOpacity: data.renderOptions.connections.lineOpacity ?? 0.5,
          fadeByDistance: data.renderOptions.connections.fadeByDistance ?? true,
          color: data.renderOptions.connections.color ? [
            data.renderOptions.connections.color[0] / 255,
            data.renderOptions.connections.color[1] / 255,
            data.renderOptions.connections.color[2] / 255
          ] : void 0
        };
      }
      if (data.renderOptions.glowEnabled) {
        this.pendingGlowConfig = {
          enabled: true,
          radius: data.renderOptions.glowRadius ?? 10,
          intensity: data.renderOptions.glowIntensity ?? 0.5
        };
      }
      if (data.renderOptions.spriteEnabled && data.renderOptions.spriteImageUrl) {
        this.pendingSpriteConfig = {
          url: data.renderOptions.spriteImageUrl,
          columns: data.renderOptions.spriteColumns ?? 1,
          rows: data.renderOptions.spriteRows ?? 1,
          animate: data.renderOptions.spriteAnimate ?? false,
          frameRate: data.renderOptions.spriteFrameRate ?? 10,
          randomStart: data.renderOptions.spriteRandomStart ?? false
        };
      }
    }
    return config;
  }
  // Pending configs to apply after initialization
  pendingConnectionConfig = null;
  pendingGlowConfig = null;
  pendingSpriteConfig = null;
  pendingCollisionConfig = null;
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(renderer) {
    if (this.initialized) return;
    this.rendererRef = renderer;
    this.particleSystem.initialize(renderer);
    this.initialized = true;
    const mesh = this.particleSystem.getMesh();
    if (mesh) {
      this.group.add(mesh);
    }
    if (this.pendingConnectionConfig) {
      this.particleSystem.initializeConnections(this.pendingConnectionConfig);
      const connectionMesh = this.particleSystem.getConnectionMesh();
      if (connectionMesh) {
        this.group.add(connectionMesh);
      }
      this.pendingConnectionConfig = null;
    }
    const trailMesh = this.particleSystem.getTrailMesh();
    if (trailMesh) {
      this.group.add(trailMesh);
    }
    if (this.pendingSpriteConfig) {
      this.particleSystem.loadTexture(this.pendingSpriteConfig.url, {
        columns: this.pendingSpriteConfig.columns,
        rows: this.pendingSpriteConfig.rows,
        animate: this.pendingSpriteConfig.animate,
        frameRate: this.pendingSpriteConfig.frameRate,
        randomStart: this.pendingSpriteConfig.randomStart
      }).catch((err) => {
        console.warn("Failed to load particle sprite:", err);
      });
      this.pendingSpriteConfig = null;
    }
    if (this.pendingGlowConfig && this.pendingGlowConfig.enabled) {
      this.particleSystem.initializeGlow(this.pendingGlowConfig);
      const glowMesh = this.particleSystem.getGlowMesh();
      if (glowMesh) {
        this.group.add(glowMesh);
      }
      this.glowConfig = this.pendingGlowConfig;
      this.pendingGlowConfig = null;
    }
    if (this.pendingCollisionConfig && this.pendingCollisionConfig.enabled) {
      this.particleSystem.initializeCollisions(this.pendingCollisionConfig);
      this.pendingCollisionConfig = null;
    }
    this.createGizmos();
  }
  // Glow configuration
  glowConfig = null;
  /**
   * Get glow configuration
   */
  getGlowConfig() {
    return this.glowConfig;
  }
  /**
   * Update glow settings at runtime
   */
  setGlow(config) {
    this.particleSystem.setGlow(config);
    if (this.glowConfig) {
      Object.assign(this.glowConfig, config);
    }
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    if (!this.initialized) {
      this.initializeWithRenderer(renderer);
    }
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(config) {
    const emitter = createDefaultEmitter();
    if (config) {
      Object.assign(emitter, config);
    }
    this.particleSystem.addEmitter(emitter);
    return emitter.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(id, updates) {
    this.particleSystem.updateEmitter(id, updates);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(id) {
    this.particleSystem.removeEmitter(id);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(type, config) {
    const field = createDefaultForceField(type);
    if (config) {
      Object.assign(field, config);
    }
    this.particleSystem.addForceField(field);
    return field.id;
  }
  /**
   * Update a force field
   */
  updateForceField(id, updates) {
    this.particleSystem.updateForceField(id, updates);
  }
  /**
   * Remove a force field
   */
  removeForceField(id) {
    this.particleSystem.removeForceField(id);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(feature, value) {
    this.particleSystem.setAudioFeature(feature, value);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(emitterId) {
    this.particleSystem.triggerBurst(emitterId);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(deltaTime) {
    if (!this.initialized) return;
    this.particleSystem.step(deltaTime);
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets to initial state with original seed
   */
  reset() {
    this.particleSystem.reset();
    this.lastEvaluatedFrame = -1;
  }
  /**
   * Clear the particle cache (used when user wants to free memory)
   */
  clearCache() {
    this.particleSystem.clearCache();
  }
  /**
   * Get cache statistics for UI display
   */
  getCacheStats() {
    return this.particleSystem.getCacheStats();
  }
  /**
   * Pre-cache frames from startFrame to endFrame
   * Used by Preview panel to build cache before playback
   * @returns Progress callback will be called with (current, total)
   */
  async preCacheFrames(startFrame, endFrame, onProgress) {
    const totalFrames = endFrame - startFrame + 1;
    for (let frame = startFrame; frame <= endFrame; frame++) {
      this.particleSystem.simulateToFrame(frame, this.fps);
      if (onProgress) {
        onProgress(frame - startFrame + 1, totalFrames);
      }
      if ((frame - startFrame) % 10 === 0) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
  }
  /**
   * Set the cache interval (frames between cached snapshots)
   */
  setCacheInterval(interval) {
    this.particleSystem.setCacheInterval(interval);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const stepsPerformed = this.particleSystem.simulateToFrame(frame, this.fps);
    this.lastEvaluatedFrame = frame;
    this.applyAudioReactivity();
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
    if (stepsPerformed > 10) {
      const cacheStats = this.particleSystem.getCacheStats();
      console.debug(
        `ParticleLayer: Simulated ${stepsPerformed} frames to reach frame ${frame}. Cache: ${cacheStats.cachedFrames} frames cached`
      );
    }
  }
  onApplyEvaluatedState(state) {
    const frame = state.frame ?? 0;
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate particles at a specific frame (scrub-safe)
   * DETERMINISM: Returns identical results regardless of evaluation order
   * Uses frame caching for performance
   */
  evaluateAtFrame(frame) {
    this.particleSystem.simulateToFrame(frame, this.fps);
    this.lastEvaluatedFrame = frame;
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const emissionRate = this.getAudioReactiveValue("particle.emissionRate");
    const speed = this.getAudioReactiveValue("particle.speed");
    const size = this.getAudioReactiveValue("particle.size");
    const gravity = this.getAudioReactiveValue("particle.gravity");
    const windStrength = this.getAudioReactiveValue("particle.windStrength");
    if (emissionRate !== 0) {
      this.particleSystem.setAudioFeature("amplitude", emissionRate);
    }
    if (speed !== 0 || size !== 0 || emissionRate !== 0) {
      const emitters = this.particleSystem.getConfig().emitters;
      for (const emitter of emitters) {
        if (speed !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSpeed: emitter.initialSpeed * (0.5 + speed)
          });
        }
        if (size !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSize: emitter.initialSize * (0.5 + size)
          });
        }
      }
    }
    if (gravity !== 0 || windStrength !== 0) {
      const forceFields = this.particleSystem.getConfig().forceFields;
      for (const field of forceFields) {
        if (field.type === "gravity" && gravity !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + gravity)
          });
        }
        if (field.type === "wind" && windStrength !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + windStrength)
          });
        }
      }
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      const oldMesh = this.particleSystem.getMesh();
      if (oldMesh) {
        this.group.remove(oldMesh);
      }
      this.systemConfig = this.buildSystemConfig({
        ...properties,
        id: this.id,
        type: "particles"
      });
      this.systemConfig.randomSeed = this.layerSeed;
      this.particleSystem.dispose();
      this.particleSystem = new GPUParticleSystem(this.systemConfig);
      this.lastEvaluatedFrame = -1;
      if (this.rendererRef) {
        this.initialized = false;
        this.initializeWithRenderer(this.rendererRef);
      }
    }
  }
  onDispose() {
    this.particleSystem.dispose();
    this.disposeGizmos();
  }
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /**
   * Create visual gizmos for all emitters and force fields
   */
  createGizmos() {
    this.disposeGizmos();
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      this.createEmitterGizmo(emitter);
    }
    for (const field of config.forceFields) {
      this.createForceFieldGizmo(field);
    }
  }
  /**
   * Create a visual gizmo for an emitter
   */
  createEmitterGizmo(emitter) {
    const gizmo = new Group();
    gizmo.name = `emitter_gizmo_${emitter.id}`;
    const size = 30;
    switch (emitter.shape.type) {
      case "point": {
        const coneGeom = new ConeGeometry(8, 20, 8);
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.7,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        cone.rotation.x = Math.PI;
        gizmo.add(cone);
        const sphereGeom = new SphereGeometry(5, 8, 8);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.9,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "circle": {
        const ringGeom = new RingGeometry(
          (emitter.shape.radius ?? 50) * 0.8,
          emitter.shape.radius ?? 50,
          32
        );
        const ringMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.5,
          side: DoubleSide,
          depthTest: false
        });
        const ring = new Mesh(ringGeom, ringMat);
        gizmo.add(ring);
        break;
      }
      case "sphere": {
        const sphereGeom = new SphereGeometry(emitter.shape.radius ?? 50, 16, 16);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "box": {
        const boxGeom = new BoxGeometry(
          emitter.shape.boxSize?.x ?? 100,
          emitter.shape.boxSize?.y ?? 100,
          emitter.shape.boxSize?.z ?? 100
        );
        const boxMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const box = new Mesh(boxGeom, boxMat);
        gizmo.add(box);
        break;
      }
      case "cone": {
        const coneGeom = new ConeGeometry(
          emitter.shape.coneRadius ?? 30,
          emitter.shape.coneLength ?? 100,
          16,
          1,
          true
        );
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        gizmo.add(cone);
        break;
      }
      default: {
        const lineMat = new LineBasicMaterial({
          color: 65416,
          depthTest: false
        });
        const hPoints = [new Vector3(-size, 0, 0), new Vector3(size, 0, 0)];
        const vPoints = [new Vector3(0, -size, 0), new Vector3(0, size, 0)];
        const hLine = new Line(
          new BufferGeometry().setFromPoints(hPoints),
          lineMat
        );
        const vLine = new Line(
          new BufferGeometry().setFromPoints(vPoints),
          lineMat.clone()
        );
        gizmo.add(hLine, vLine);
      }
    }
    const dir = emitter.emissionDirection;
    if (dir) {
      const arrowLength = 40;
      const arrowGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
      ]);
      const arrowMat = new LineBasicMaterial({
        color: 16776960,
        depthTest: false
      });
      const arrow = new Line(arrowGeom, arrowMat);
      gizmo.add(arrow);
    }
    const pos = emitter.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showEmitterGizmos;
    gizmo.renderOrder = 997;
    this.emitterGizmos.set(emitter.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Create a visual gizmo for a force field
   */
  createForceFieldGizmo(field) {
    const gizmo = new Group();
    gizmo.name = `forcefield_gizmo_${field.id}`;
    const radius = field.falloffEnd || 100;
    switch (field.type) {
      case "gravity":
      case "wind": {
        const dir = field.type === "wind" && field.windDirection ? field.windDirection : field.direction ?? { x: 0, y: 1, z: 0 };
        const arrowLength = 60;
        const arrowPoints = [
          new Vector3(0, 0, 0),
          new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
        ];
        const arrowGeom = new BufferGeometry().setFromPoints(arrowPoints);
        const arrowMat = new LineBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          linewidth: 2,
          depthTest: false
        });
        const arrow = new Line(arrowGeom, arrowMat);
        gizmo.add(arrow);
        const headGeom = new ConeGeometry(5, 15, 6);
        const headMat = new MeshBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          depthTest: false
        });
        const head = new Mesh(headGeom, headMat);
        head.position.set(
          dir.x * arrowLength,
          -dir.y * arrowLength,
          dir.z * arrowLength
        );
        head.lookAt(0, 0, 0);
        gizmo.add(head);
        break;
      }
      case "vortex": {
        const spiralPoints = [];
        for (let t = 0; t < Math.PI * 4; t += 0.2) {
          const r = t / (Math.PI * 4) * radius * 0.5;
          spiralPoints.push(new Vector3(
            Math.cos(t) * r,
            Math.sin(t) * r,
            t * 2
          ));
        }
        const spiralGeom = new BufferGeometry().setFromPoints(spiralPoints);
        const spiralMat = new LineBasicMaterial({
          color: 16711935,
          depthTest: false
        });
        const spiral = new Line(spiralGeom, spiralMat);
        gizmo.add(spiral);
        break;
      }
      case "turbulence": {
        const waveMat = new LineBasicMaterial({
          color: 16755200,
          depthTest: false
        });
        for (let i = 0; i < 3; i++) {
          const wavePoints = [];
          for (let t = 0; t < Math.PI * 2; t += 0.3) {
            wavePoints.push(new Vector3(
              t * 10,
              Math.sin(t * 3 + i) * 10,
              (i - 1) * 15
            ));
          }
          const waveGeom = new BufferGeometry().setFromPoints(wavePoints);
          const wave = new Line(waveGeom, waveMat.clone());
          wave.position.x = -30;
          gizmo.add(wave);
        }
        break;
      }
      case "point": {
        const sphereGeom = new SphereGeometry(15, 12, 12);
        const sphereMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.5,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        const rangeGeom = new RingGeometry(radius * 0.9, radius, 32);
        const rangeMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.2,
          side: DoubleSide,
          depthTest: false
        });
        const range = new Mesh(rangeGeom, rangeMat);
        gizmo.add(range);
        break;
      }
      case "drag": {
        const lineMat = new LineBasicMaterial({
          color: 8947848,
          depthTest: false
        });
        for (let i = -2; i <= 2; i++) {
          const linePoints = [
            new Vector3(-20, i * 8, 0),
            new Vector3(20, i * 8, 0)
          ];
          const lineGeom = new BufferGeometry().setFromPoints(linePoints);
          const line = new Line(lineGeom, lineMat.clone());
          gizmo.add(line);
        }
        break;
      }
    }
    const pos = field.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showForceFieldGizmos;
    gizmo.renderOrder = 996;
    this.forceFieldGizmos.set(field.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Update gizmo positions from current config
   */
  updateGizmoPositions() {
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      const gizmo = this.emitterGizmos.get(emitter.id);
      if (gizmo) {
        gizmo.position.set(emitter.position.x, -emitter.position.y, emitter.position.z);
      }
    }
    for (const field of config.forceFields) {
      const gizmo = this.forceFieldGizmos.get(field.id);
      if (gizmo) {
        gizmo.position.set(field.position.x, -field.position.y, field.position.z);
      }
    }
  }
  /**
   * Set emitter gizmo visibility
   */
  setEmitterGizmosVisible(visible) {
    this.showEmitterGizmos = visible;
    for (const gizmo of this.emitterGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Set force field gizmo visibility
   */
  setForceFieldGizmosVisible(visible) {
    this.showForceFieldGizmos = visible;
    for (const gizmo of this.forceFieldGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Dispose all gizmos
   */
  disposeGizmos() {
    for (const gizmo of this.emitterGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.emitterGizmos.clear();
    for (const gizmo of this.forceFieldGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.forceFieldGizmos.clear();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}

class NestedCompLayer extends BaseLayer {
  // Nested comp data
  nestedCompData;
  // Render context (provided by LayerManager)
  renderContext = null;
  // Display mesh
  mesh = null;
  material = null;
  // Cached render texture
  renderTexture = null;
  // Animation evaluator for time remap
  nestedCompEvaluator;
  // Cached composition reference
  cachedComposition = null;
  // Parent composition FPS for frame rate conversion
  parentFPS = 30;
  // Flatten transform state
  isCollapsed = false;
  collapsedLayerIds = [];
  constructor(layerData) {
    super(layerData);
    this.nestedCompEvaluator = new KeyframeEvaluator();
    this.nestedCompData = this.extractNestedCompData(layerData);
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract nested comp data with defaults
   */
  extractNestedCompData(layerData) {
    const data = layerData.data;
    return {
      compositionId: data?.compositionId ?? "",
      // Speed map (new naming)
      speedMapEnabled: data?.speedMapEnabled ?? data?.timeRemapEnabled ?? false,
      speedMap: data?.speedMap ?? data?.timeRemap,
      // Backwards compatibility aliases
      timeRemapEnabled: data?.timeRemapEnabled ?? data?.speedMapEnabled ?? false,
      timeRemap: data?.timeRemap ?? data?.speedMap,
      flattenTransform: data?.flattenTransform ?? false,
      overrideFrameRate: data?.overrideFrameRate ?? false,
      frameRate: data?.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 4473924,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `nestedComp_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for nested comp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(context) {
    this.renderContext = context;
    this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(fps) {
    this.parentFPS = fps;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    if (!this.renderContext || !this.nestedCompData.compositionId) {
      return;
    }
    this.cachedComposition = this.renderContext.getComposition(
      this.nestedCompData.compositionId
    );
    if (this.cachedComposition) {
      this.resizeMesh(
        this.cachedComposition.settings.width,
        this.cachedComposition.settings.height
      );
    }
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and speed map (time remapping)
   */
  calculateNestedFrame(parentFrame) {
    if (!this.cachedComposition) return 0;
    const speedMapEnabled = this.nestedCompData.speedMapEnabled ?? this.nestedCompData.timeRemapEnabled;
    const speedMapProp = this.nestedCompData.speedMap ?? this.nestedCompData.timeRemap;
    if (speedMapEnabled && speedMapProp) {
      const remappedTime = speedMapProp.animated ? this.nestedCompEvaluator.evaluate(speedMapProp, parentFrame) : speedMapProp.value;
      const fps = this.nestedCompData.overrideFrameRate && this.nestedCompData.frameRate ? this.nestedCompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(remappedTime * fps);
    }
    if (this.nestedCompData.overrideFrameRate && this.nestedCompData.frameRate) {
      const parentFps = this.parentFPS;
      const childFps = this.nestedCompData.frameRate;
      return Math.floor(parentFrame * (childFps / parentFps));
    }
    return parentFrame;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.renderContext || !this.cachedComposition) {
      return;
    }
    const nestedFrame = this.calculateNestedFrame(frame);
    const clampedFrame = Math.max(
      0,
      Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.nestedCompData.compositionId,
      clampedFrame
    );
    if (this.material) {
      if (this.renderTexture) {
        this.material.map = this.renderTexture;
        this.material.color.setHex(16777215);
      } else {
        this.material.map = null;
        this.material.color.setHex(4473924);
      }
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    const speedMapValue = props["speedMap"] ?? props["timeRemap"];
    const speedMapEnabled = this.nestedCompData.speedMapEnabled ?? this.nestedCompData.timeRemapEnabled;
    const speedMapProp = this.nestedCompData.speedMap ?? this.nestedCompData.timeRemap;
    if (speedMapValue !== void 0 && speedMapEnabled && speedMapProp) {
      speedMapProp.value = speedMapValue;
    }
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(compositionId) {
    this.nestedCompData.compositionId = compositionId;
    this.loadComposition();
  }
  /**
   * Enable/disable speed map (time remapping)
   */
  setSpeedMapEnabled(enabled) {
    this.nestedCompData.speedMapEnabled = enabled;
    this.nestedCompData.timeRemapEnabled = enabled;
  }
  /** @deprecated Use setSpeedMapEnabled instead */
  setTimeRemapEnabled(enabled) {
    this.setSpeedMapEnabled(enabled);
  }
  /**
   * Set speed map property
   */
  setSpeedMap(speedMap) {
    this.nestedCompData.speedMap = speedMap;
    this.nestedCompData.timeRemap = speedMap;
  }
  /** @deprecated Use setSpeedMap instead */
  setTimeRemap(timeRemap) {
    this.setSpeedMap(timeRemap);
  }
  /**
   * Enable/disable flatten transform
   */
  setFlattenTransform(flatten) {
    this.nestedCompData.flattenTransform = flatten;
    this.isCollapsed = flatten;
    if (this.mesh) {
      this.mesh.visible = !flatten;
    }
  }
  /** @deprecated Use setFlattenTransform instead */
  setCollapseTransformations(collapse) {
    this.setFlattenTransform(collapse);
  }
  /**
   * Check if flatten transform is enabled
   */
  isFlattenEnabled() {
    return this.nestedCompData.flattenTransform;
  }
  /** @deprecated Use isFlattenEnabled instead */
  isCollapseEnabled() {
    return this.isFlattenEnabled();
  }
  /**
   * Get the current transform values of this nested comp layer
   * Used when combining transforms for collapsed nested layers
   */
  getParentTransform() {
    return {
      position: {
        x: this.group.position.x,
        y: -this.group.position.y,
        // Convert back to screen coords
        z: this.group.position.z
      },
      rotation: {
        x: MathUtils.radToDeg(this.group.rotation.x),
        y: MathUtils.radToDeg(this.group.rotation.y),
        z: MathUtils.radToDeg(-this.group.rotation.z)
        // Convert back
      },
      scale: {
        x: this.group.scale.x * 100,
        y: this.group.scale.y * 100,
        z: this.group.scale.z * 100
      },
      opacity: this.getOpacity()
    };
  }
  /**
   * Get opacity value (for collapsed layer opacity combination)
   */
  getOpacity() {
    if (this.material) {
      return this.material.opacity * 100;
    }
    return 100;
  }
  /**
   * Combine parent (this nested comp) and nested layer transforms
   * Used when flatten transform is enabled
   *
   * @param nestedTransform - The transform of a nested layer
   * @returns Combined transform for rendering in parent scene
   */
  combineTransforms(nestedTransform) {
    const parent = this.getParentTransform();
    const combinedPosition = {
      x: parent.position.x + nestedTransform.position.x * parent.scale.x / 100,
      y: parent.position.y + nestedTransform.position.y * parent.scale.y / 100,
      z: parent.position.z + nestedTransform.position.z * parent.scale.z / 100
    };
    const combinedRotation = {
      x: parent.rotation.x + nestedTransform.rotation.x,
      y: parent.rotation.y + nestedTransform.rotation.y,
      z: parent.rotation.z + nestedTransform.rotation.z
    };
    const combinedScale = {
      x: parent.scale.x * nestedTransform.scale.x / 100,
      y: parent.scale.y * nestedTransform.scale.y / 100,
      z: parent.scale.z * nestedTransform.scale.z / 100
    };
    const combinedOpacity = parent.opacity / 100 * (nestedTransform.opacity / 100) * 100;
    return {
      position: combinedPosition,
      rotation: combinedRotation,
      scale: combinedScale,
      opacity: combinedOpacity
    };
  }
  /**
   * Get the IDs of layers in the nested composition
   * Used for managing collapsed layers in the parent scene
   */
  getNestedLayerIds() {
    if (!this.cachedComposition) {
      return [];
    }
    return this.cachedComposition.layers.map((l) => l.id);
  }
  /**
   * Check if this nested comp contains 3D layers
   * Flatten transform is most useful when nested comp has 3D layers
   */
  hasNested3DLayers() {
    if (!this.cachedComposition) {
      return false;
    }
    return this.cachedComposition.layers.some((l) => l.threeD);
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(override, fps) {
    this.nestedCompData.overrideFrameRate = override;
    this.nestedCompData.frameRate = fps;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.compositionId !== void 0) {
        this.setComposition(data.compositionId);
      }
      if (data.speedMapEnabled !== void 0 || data.timeRemapEnabled !== void 0) {
        this.setSpeedMapEnabled(data.speedMapEnabled ?? data.timeRemapEnabled ?? false);
      }
      if (data.speedMap !== void 0 || data.timeRemap !== void 0) {
        this.setSpeedMap(data.speedMap ?? data.timeRemap);
      }
      if (data.flattenTransform !== void 0) {
        this.setFlattenTransform(data.flattenTransform);
      }
      if (data.overrideFrameRate !== void 0 || data.frameRate !== void 0) {
        this.setFrameRateOverride(
          data.overrideFrameRate ?? this.nestedCompData.overrideFrameRate,
          data.frameRate ?? this.nestedCompData.frameRate
        );
      }
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get nested comp data
   */
  getNestedCompData() {
    return { ...this.nestedCompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.nestedCompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
    this.renderTexture = null;
    this.cachedComposition = null;
  }
}

class CameraLayer extends BaseLayer {
  // Camera data reference
  cameraData;
  // Callbacks to store
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Track current frame for interpolation
  currentFrame = 0;
  // Visual wireframe (shown in editor)
  wireframe = null;
  wireframeVisible = true;
  // Frustum visualization
  frustumHelper = null;
  showFrustum = true;
  // Track last camera state for frustum updates
  lastFrustumState = null;
  // Spline provider for path following
  splineProvider = null;
  // Auto-advance parameter (for autoAdvance mode)
  autoAdvanceT = 0;
  constructor(layerData) {
    super(layerData);
    this.threeD = true;
    this.cameraData = this.extractCameraData(layerData);
    this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(layerData) {
    const data = layerData.data;
    return {
      cameraId: data?.cameraId ?? "",
      isActiveCamera: data?.isActiveCamera ?? false,
      pathFollowing: data?.pathFollowing
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
  }
  /**
   * Set the spline provider for path following
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get path following configuration
   */
  getPathFollowing() {
    return this.cameraData.pathFollowing;
  }
  /**
   * Check if path following is active
   */
  isFollowingPath() {
    return this.cameraData.pathFollowing?.enabled ?? false;
  }
  /**
   * Reset auto-advance parameter (for deterministic scrubbing)
   */
  resetAutoAdvance() {
    this.autoAdvanceT = 0;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Group();
    this.wireframe.name = `camera_wireframe_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const bodySize = 40;
    const bodyGeometry = new BoxGeometry(bodySize, bodySize * 0.6, bodySize * 0.8);
    const bodyMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    this.wireframe.add(body);
    const coneGeometry = new ConeGeometry(bodySize * 0.3, bodySize * 0.6, 8);
    const coneMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.6,
      depthTest: false
    });
    const cone = new Mesh(coneGeometry, coneMaterial);
    cone.rotation.x = Math.PI / 2;
    cone.position.z = bodySize * 0.7;
    this.wireframe.add(cone);
    const planeGeometry = new PlaneGeometry(bodySize * 0.8, bodySize * 0.5);
    const planeMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.2,
      side: DoubleSide,
      depthTest: false
    });
    const plane = new Mesh(planeGeometry, planeMaterial);
    plane.position.z = -bodySize * 0.4;
    this.wireframe.add(plane);
    const upPoints = [
      new Vector3(0, bodySize * 0.4, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(-bodySize * 0.1, bodySize * 0.55, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(bodySize * 0.1, bodySize * 0.55, 0)
    ];
    const upGeometry = new BufferGeometry().setFromPoints(upPoints);
    const upMaterial = new LineBasicMaterial({
      color: 65280,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const upLine = new Line(upGeometry, upMaterial);
    this.wireframe.add(upLine);
    this.group.add(this.wireframe);
    this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const camera = this.getCamera();
    if (!camera) return;
    this.frustumHelper = new Group();
    this.frustumHelper.name = `camera_frustum_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const near = camera.nearClip;
    const far = Math.min(camera.farClip, 2e3);
    const fov = camera.angleOfView * (Math.PI / 180);
    const aspect = 16 / 9;
    const nearHeight = 2 * Math.tan(fov / 2) * near;
    const nearWidth = nearHeight * aspect;
    const farHeight = 2 * Math.tan(fov / 2) * far;
    const farWidth = farHeight * aspect;
    const frustumMaterial = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.3,
      depthTest: false
    });
    const nearTL = new Vector3(-nearWidth / 2, nearHeight / 2, near);
    const nearTR = new Vector3(nearWidth / 2, nearHeight / 2, near);
    const nearBL = new Vector3(-nearWidth / 2, -nearHeight / 2, near);
    const nearBR = new Vector3(nearWidth / 2, -nearHeight / 2, near);
    const farTL = new Vector3(-farWidth / 2, farHeight / 2, far);
    const farTR = new Vector3(farWidth / 2, farHeight / 2, far);
    const farBL = new Vector3(-farWidth / 2, -farHeight / 2, far);
    const farBR = new Vector3(farWidth / 2, -farHeight / 2, far);
    const nearPlane = new BufferGeometry().setFromPoints([
      nearTL,
      nearTR,
      nearBR,
      nearBL,
      nearTL
    ]);
    this.frustumHelper.add(new Line(nearPlane, frustumMaterial));
    const farPlane = new BufferGeometry().setFromPoints([
      farTL,
      farTR,
      farBR,
      farBL,
      farTL
    ]);
    this.frustumHelper.add(new Line(farPlane, frustumMaterial));
    const edges = [
      [nearTL, farTL],
      [nearTR, farTR],
      [nearBL, farBL],
      [nearBR, farBR]
    ];
    for (const [start, end] of edges) {
      const edgeGeom = new BufferGeometry().setFromPoints([start, end]);
      this.frustumHelper.add(new Line(edgeGeom, frustumMaterial));
    }
    this.group.add(this.frustumHelper);
    this.frustumHelper.renderOrder = 997;
    this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        const material = child.material;
        if (material.color.getHex() === 65280) return;
        material.color.setHex(color);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    if (!this.cameraGetter || !this.cameraData.cameraId) return null;
    return this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    if (!this.cameraData.cameraId) return null;
    if (this.cameraAtFrameGetter) {
      return this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame);
    }
    return this.getCamera();
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(active) {
    this.cameraData.isActiveCamera = active;
    this.updateWireframeColor();
    if (this.frustumHelper) {
      this.group.remove(this.frustumHelper);
      this.disposeFrustum();
      this.createFrustum();
    }
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(visible) {
    this.wireframeVisible = visible;
    if (this.wireframe) {
      this.wireframe.visible = visible;
    }
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(visible) {
    this.showFrustum = visible;
    if (this.frustumHelper) {
      this.frustumHelper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return;
    const degToRad = Math.PI / 180;
    const pathFollowing = this.cameraData.pathFollowing;
    const usePathFollowing = pathFollowing?.enabled && pathFollowing.pathLayerId && this.splineProvider;
    if (usePathFollowing && pathFollowing) {
      this.applyPathFollowing(frame, pathFollowing, camera);
    } else {
      this.group.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
      );
      if (camera.type === "two-node" && camera.pointOfInterest) {
        const poi = new Vector3(
          camera.pointOfInterest.x,
          camera.pointOfInterest.y,
          camera.pointOfInterest.z
        );
        this.group.lookAt(poi);
        this.group.rotation.z += camera.zRotation * degToRad;
      } else {
        this.group.rotation.set(
          (camera.orientation.x + camera.xRotation) * degToRad,
          (camera.orientation.y + camera.yRotation) * degToRad,
          (camera.orientation.z + camera.zRotation) * degToRad,
          "YXZ"
          // Standard 3D rotation order (heading-pitch-roll)
        );
      }
    }
    const currentState = {
      fov: camera.angleOfView,
      near: camera.nearClip,
      far: camera.farClip
    };
    const needsFrustumUpdate = !this.lastFrustumState || this.lastFrustumState.fov !== currentState.fov || this.lastFrustumState.near !== currentState.near || this.lastFrustumState.far !== currentState.far;
    if (needsFrustumUpdate) {
      if (this.frustumHelper) {
        this.group.remove(this.frustumHelper);
        this.disposeFrustum();
      }
      this.createFrustum();
      this.lastFrustumState = currentState;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pathParameter"] !== void 0 && this.cameraData.pathFollowing?.enabled) {
      this.cameraData.pathFollowing.parameter.value = props["pathParameter"];
    }
  }
  /**
   * Apply path following to camera position and orientation
   * DETERMINISM: Uses interpolateProperty for animated parameter
   */
  applyPathFollowing(frame, pathFollowing, camera) {
    if (!this.splineProvider) return;
    let t;
    if (pathFollowing.autoAdvance) {
      t = frame * pathFollowing.autoAdvanceSpeed % 1;
    } else {
      t = interpolateProperty(pathFollowing.parameter, frame);
    }
    t = Math.max(0, Math.min(1, t));
    const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);
    if (!pathResult) {
      this.group.position.set(camera.position.x, camera.position.y, camera.position.z);
      return;
    }
    let lookTarget = null;
    if (pathFollowing.alignToPath && pathFollowing.lookAhead > 0) {
      const lookAheadT = Math.min(1, t + pathFollowing.lookAhead);
      lookTarget = this.splineProvider(pathFollowing.pathLayerId, lookAheadT, frame);
    }
    const position = new Vector3(
      pathResult.point.x,
      pathResult.point.y + pathFollowing.offsetY,
      pathResult.point.z
    );
    this.group.position.copy(position);
    if (pathFollowing.alignToPath) {
      if (lookTarget) {
        const target = new Vector3(
          lookTarget.point.x,
          lookTarget.point.y + pathFollowing.offsetY,
          lookTarget.point.z
        );
        this.group.lookAt(target);
      } else {
        const tangent = new Vector3(
          pathResult.tangent.x,
          pathResult.tangent.y,
          0
        ).normalize();
        const forward = new Vector3(0, 0, 1);
        const quaternion = new Quaternion();
        quaternion.setFromUnitVectors(forward, tangent);
        this.group.quaternion.copy(quaternion);
      }
      if (pathFollowing.bankingStrength > 0) {
        const epsilon = 0.01;
        const tBefore = Math.max(0, t - epsilon);
        const tAfter = Math.min(1, t + epsilon);
        const before = this.splineProvider(pathFollowing.pathLayerId, tBefore, frame);
        const after = this.splineProvider(pathFollowing.pathLayerId, tAfter, frame);
        if (before && after) {
          const tangent1 = new Vector2(before.tangent.x, before.tangent.y).normalize();
          const tangent2 = new Vector2(after.tangent.x, after.tangent.y).normalize();
          const cross = tangent1.x * tangent2.y - tangent1.y * tangent2.x;
          const bankAngle = cross * pathFollowing.bankingStrength * Math.PI / 4;
          this.group.rotateZ(bankAngle);
        }
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.cameraId !== void 0) {
        this.cameraData.cameraId = data.cameraId;
        if (this.frustumHelper) {
          this.group.remove(this.frustumHelper);
          this.disposeFrustum();
        }
        this.createFrustum();
      }
      if (data.isActiveCamera !== void 0) {
        this.setActiveCamera(data.isActiveCamera);
      }
      if (data.pathFollowing !== void 0) {
        this.cameraData.pathFollowing = data.pathFollowing;
        if (data.pathFollowing?.autoAdvance) {
          this.autoAdvanceT = 0;
        }
      }
    }
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return null;
    return {
      position: { ...camera.position },
      rotation: {
        x: camera.orientation.x + camera.xRotation,
        y: camera.orientation.y + camera.yRotation,
        z: camera.orientation.z + camera.zRotation
      },
      fov: camera.angleOfView,
      focalLength: camera.focalLength,
      nearClip: camera.nearClip,
      farClip: camera.farClip
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    if (!this.wireframe) return;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.wireframe.clear();
    this.wireframe = null;
  }
  disposeFrustum() {
    if (!this.frustumHelper) return;
    this.frustumHelper.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.frustumHelper.clear();
    this.frustumHelper = null;
  }
  onDispose() {
    this.disposeWireframe();
    this.disposeFrustum();
  }
}

let rectAreaLightInitialized = false;
function initRectAreaLight() {
  if (!rectAreaLightInitialized) {
    RectAreaLightUniformsLib.init();
    rectAreaLightInitialized = true;
  }
}
function kelvinToRGB(kelvin) {
  const temp = kelvin / 100;
  let r, g, b;
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  return { r: r / 255, g: g / 255, b: b / 255 };
}
class LightLayer extends BaseLayer {
  light;
  helper = null;
  lightData;
  // Point of Interest
  poiTarget = new Vector3();
  smoothedPOI = new Vector3();
  // Path following callback (set by LayerManager)
  pathProvider = null;
  // Layer position getter for POI layer tracking
  layerPositionGetter = null;
  constructor(layerData) {
    super(layerData);
    this.lightData = this.extractLightData(layerData);
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(0);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // DATA EXTRACTION
  // ============================================================================
  extractLightData(layerData) {
    const data = layerData.data;
    return {
      lightType: data?.lightType ?? "point",
      color: data?.color ?? "#ffffff",
      colorTemperature: data?.colorTemperature,
      useColorTemperature: data?.useColorTemperature ?? false,
      intensity: data?.intensity ?? 100,
      physicalIntensity: data?.physicalIntensity,
      usePhysicalIntensity: data?.usePhysicalIntensity ?? false,
      radius: data?.radius ?? 500,
      falloff: data?.falloff ?? "none",
      falloffDistance: data?.falloffDistance ?? 500,
      coneAngle: data?.coneAngle ?? 90,
      coneFeather: data?.coneFeather ?? 50,
      areaWidth: data?.areaWidth ?? 100,
      areaHeight: data?.areaHeight ?? 100,
      pointOfInterest: {
        enabled: data?.pointOfInterest?.enabled ?? false,
        targetType: data?.pointOfInterest?.targetType ?? "position",
        position: data?.pointOfInterest?.position ?? {
          id: "poi_pos",
          name: "POI Position",
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: []
        },
        targetLayerId: data?.pointOfInterest?.targetLayerId,
        offset: data?.pointOfInterest?.offset ?? { x: 0, y: 0, z: 0 },
        smoothing: data?.pointOfInterest?.smoothing ?? 0
      },
      pathFollowing: {
        enabled: data?.pathFollowing?.enabled ?? false,
        splineLayerId: data?.pathFollowing?.splineLayerId,
        progress: data?.pathFollowing?.progress ?? {
          id: "path_progress",
          name: "Path Progress",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        autoOrient: data?.pathFollowing?.autoOrient ?? true,
        bankAngle: data?.pathFollowing?.bankAngle ?? {
          id: "bank_angle",
          name: "Bank Angle",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        }
      },
      shadow: {
        enabled: data?.shadow?.enabled ?? data?.castShadows ?? false,
        type: data?.shadow?.type ?? "pcf",
        mapSize: data?.shadow?.mapSize ?? 1024,
        darkness: data?.shadow?.darkness ?? data?.shadowDarkness ?? 100,
        radius: data?.shadow?.radius ?? data?.shadowDiffusion ?? 1,
        bias: data?.shadow?.bias ?? -1e-4,
        normalBias: data?.shadow?.normalBias ?? 0,
        cameraNear: data?.shadow?.cameraNear ?? 1,
        cameraFar: data?.shadow?.cameraFar ?? 1e3,
        cameraSize: data?.shadow?.cameraSize ?? 500
      },
      lightLinking: {
        mode: data?.lightLinking?.mode ?? "include",
        layers: data?.lightLinking?.layers ?? []
      },
      animatedIntensity: data?.animatedIntensity,
      animatedConeAngle: data?.animatedConeAngle,
      animatedColor: data?.animatedColor,
      animatedColorTemperature: data?.animatedColorTemperature
    };
  }
  // ============================================================================
  // LIGHT CREATION
  // ============================================================================
  createLight() {
    const color = this.getEffectiveColor();
    const intensity = this.getEffectiveIntensity();
    switch (this.lightData.lightType) {
      case "point": {
        const light = new PointLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        this.configureShadows(light);
        return light;
      }
      case "spot": {
        const light = new SpotLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        light.angle = MathUtils.degToRad((this.lightData.coneAngle ?? 90) / 2);
        light.penumbra = (this.lightData.coneFeather ?? 50) / 100;
        this.configureShadows(light);
        return light;
      }
      case "parallel": {
        const light = new DirectionalLight(color, intensity);
        this.configureShadows(light);
        return light;
      }
      case "ambient": {
        return new AmbientLight(color, intensity);
      }
      case "area": {
        initRectAreaLight();
        const light = new RectAreaLight(
          color,
          intensity,
          this.lightData.areaWidth ?? 100,
          this.lightData.areaHeight ?? 100
        );
        return light;
      }
      default:
        layerLogger.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`);
        return new PointLight(color, intensity);
    }
  }
  getEffectiveColor() {
    if (this.lightData.useColorTemperature && this.lightData.colorTemperature) {
      const rgb = kelvinToRGB(this.lightData.colorTemperature);
      return new Color(rgb.r, rgb.g, rgb.b);
    }
    return new Color(this.lightData.color);
  }
  getEffectiveIntensity() {
    if (this.lightData.usePhysicalIntensity && this.lightData.physicalIntensity) {
      return this.lightData.physicalIntensity / 100;
    }
    return this.lightData.intensity / 100;
  }
  // ============================================================================
  // SHADOW CONFIGURATION
  // ============================================================================
  configureShadows(light) {
    const shadowConfig = this.lightData.shadow;
    light.castShadow = shadowConfig.enabled;
    if (!light.castShadow) return;
    light.shadow.mapSize.width = shadowConfig.mapSize;
    light.shadow.mapSize.height = shadowConfig.mapSize;
    switch (shadowConfig.type) {
      case "basic":
        break;
      case "pcf":
        light.shadow.radius = 1;
        break;
      case "pcfSoft":
        light.shadow.radius = shadowConfig.radius;
        break;
      case "vsm":
        light.shadow.radius = shadowConfig.radius;
        break;
    }
    light.shadow.bias = shadowConfig.bias;
    light.shadow.normalBias = shadowConfig.normalBias;
    if (light instanceof DirectionalLight) {
      const camera = light.shadow.camera;
      camera.near = shadowConfig.cameraNear;
      camera.far = shadowConfig.cameraFar;
      camera.left = -shadowConfig.cameraSize / 2;
      camera.right = shadowConfig.cameraSize / 2;
      camera.top = shadowConfig.cameraSize / 2;
      camera.bottom = -shadowConfig.cameraSize / 2;
      camera.updateProjectionMatrix();
    } else if (light instanceof SpotLight) {
      light.shadow.camera.near = shadowConfig.cameraNear;
      light.shadow.camera.far = shadowConfig.cameraFar;
      light.shadow.camera.updateProjectionMatrix();
    }
  }
  // ============================================================================
  // HELPER VISUALIZATION
  // ============================================================================
  createHelper() {
    if (this.helper) {
      this.group.remove(this.helper);
      if (this.helper.dispose) {
        this.helper.dispose();
      }
    }
    switch (this.lightData.lightType) {
      case "point": {
        const helper = new PointLightHelper(this.light, this.lightData.radius / 10);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "spot": {
        const helper = new SpotLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "parallel": {
        const helper = new DirectionalLightHelper(this.light, 50);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "area": {
        const helper = new RectAreaLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
    }
  }
  // ============================================================================
  // POINT OF INTEREST
  // ============================================================================
  /**
   * Set callback for getting layer positions (for POI layer tracking)
   */
  setLayerPositionGetter(getter) {
    this.layerPositionGetter = getter;
  }
  /**
   * Update point of interest target
   */
  updatePointOfInterest(frame) {
    const poi = this.lightData.pointOfInterest;
    if (!poi.enabled) return;
    if (this.lightData.lightType !== "spot" && this.lightData.lightType !== "parallel") {
      return;
    }
    if (poi.targetType === "layer" && poi.targetLayerId && this.layerPositionGetter) {
      const layerPos = this.layerPositionGetter(poi.targetLayerId);
      if (layerPos) {
        this.poiTarget.copy(layerPos);
        this.poiTarget.x += poi.offset.x;
        this.poiTarget.y += poi.offset.y;
        this.poiTarget.z += poi.offset.z;
      }
    } else {
      const pos = this.evaluator.evaluate(poi.position, frame);
      this.poiTarget.set(pos.x, pos.y, pos.z);
    }
    if (poi.smoothing > 0) {
      this.smoothedPOI.lerp(this.poiTarget, 1 - poi.smoothing);
    } else {
      this.smoothedPOI.copy(this.poiTarget);
    }
    if (this.light instanceof SpotLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    } else if (this.light instanceof DirectionalLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    }
  }
  // ============================================================================
  // PATH FOLLOWING
  // ============================================================================
  /**
   * Set path provider callback (from LayerManager's spline provider)
   */
  setPathProvider(provider) {
    this.pathProvider = provider;
  }
  /**
   * Update position and orientation from path
   */
  updatePathFollowing(frame) {
    const path = this.lightData.pathFollowing;
    if (!path.enabled || !path.splineLayerId || !this.pathProvider) return;
    const progress = this.evaluator.evaluate(path.progress, frame);
    const result = this.pathProvider(path.splineLayerId, progress, frame);
    if (!result) return;
    this.group.position.set(result.point.x, -result.point.y, result.point.z);
    if (path.autoOrient) {
      const angle = Math.atan2(result.tangent.y, result.tangent.x);
      this.group.rotation.z = -angle;
      const bankAngle = this.evaluator.evaluate(path.bankAngle, frame);
      this.group.rotation.x = MathUtils.degToRad(bankAngle);
    }
  }
  // ============================================================================
  // PUBLIC SETTERS
  // ============================================================================
  setLightType(type) {
    if (type === this.lightData.lightType) return;
    this.lightData.lightType = type;
    this.group.remove(this.light);
    if (this.light.dispose) {
      this.light.dispose();
    }
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
  }
  setColor(color) {
    this.lightData.color = color;
    this.lightData.useColorTemperature = false;
    this.light.color.set(color);
  }
  setColorTemperature(kelvin) {
    this.lightData.colorTemperature = kelvin;
    this.lightData.useColorTemperature = true;
    const rgb = kelvinToRGB(kelvin);
    this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
  }
  setIntensity(intensity) {
    this.lightData.intensity = intensity;
    this.lightData.usePhysicalIntensity = false;
    this.light.intensity = intensity / 100;
  }
  setFalloffDistance(distance) {
    this.lightData.falloffDistance = distance;
    if (this.light instanceof PointLight || this.light instanceof SpotLight) {
      this.light.distance = this.lightData.falloff === "none" ? 0 : distance;
    }
  }
  setConeAngle(angle) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneAngle = angle;
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
  }
  setConeFeather(feather) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneFeather = feather;
      this.light.penumbra = feather / 100;
    }
  }
  setAreaSize(width, height) {
    if (this.light instanceof RectAreaLight) {
      this.lightData.areaWidth = width;
      this.lightData.areaHeight = height;
      this.light.width = width;
      this.light.height = height;
    }
  }
  setShadowEnabled(enabled) {
    this.lightData.shadow.enabled = enabled;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.light.castShadow = enabled;
    }
  }
  setShadowType(type) {
    this.lightData.shadow.type = type;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.configureShadows(this.light);
    }
  }
  setPointOfInterestEnabled(enabled) {
    this.lightData.pointOfInterest.enabled = enabled;
  }
  setPointOfInterestTarget(layerId) {
    if (layerId) {
      this.lightData.pointOfInterest.targetType = "layer";
      this.lightData.pointOfInterest.targetLayerId = layerId;
    } else {
      this.lightData.pointOfInterest.targetType = "position";
      this.lightData.pointOfInterest.targetLayerId = void 0;
    }
  }
  setPathFollowingEnabled(enabled) {
    this.lightData.pathFollowing.enabled = enabled;
  }
  setPathSpline(splineLayerId) {
    this.lightData.pathFollowing.splineLayerId = splineLayerId ?? void 0;
  }
  // ============================================================================
  // DRIVER PROPERTY ACCESS
  // ============================================================================
  /**
   * Get a light property value by driver property path
   * Used by PropertyDriverSystem for property-to-property linking
   */
  getDriverPropertyValue(path) {
    switch (path) {
      case "light.intensity":
        return this.lightData.intensity;
      case "light.color.r":
        return this.light.color.r * 255;
      case "light.color.g":
        return this.light.color.g * 255;
      case "light.color.b":
        return this.light.color.b * 255;
      case "light.colorTemperature":
        return this.lightData.colorTemperature ?? 6500;
      case "light.coneAngle":
        return this.lightData.coneAngle ?? 90;
      case "light.penumbra":
        return this.lightData.coneFeather ?? 50;
      case "light.falloff":
        return this.lightData.falloffDistance;
      case "light.shadow.intensity":
        return this.lightData.shadow.darkness;
      case "light.shadow.softness":
        return this.lightData.shadow.radius;
      case "light.shadow.bias":
        return this.lightData.shadow.bias * 1e4;
      case "light.poi.x":
        return this.poiTarget.x;
      case "light.poi.y":
        return this.poiTarget.y;
      case "light.poi.z":
        return this.poiTarget.z;
      case "light.areaSize.width":
        return this.lightData.areaWidth ?? 100;
      case "light.areaSize.height":
        return this.lightData.areaHeight ?? 100;
      case "light.physicalIntensity":
        return this.lightData.physicalIntensity ?? this.lightData.intensity * 100;
      default:
        return null;
    }
  }
  /**
   * Set a light property value by driver property path
   * Used by PropertyDriverSystem for driven values
   */
  setDriverPropertyValue(path, value) {
    switch (path) {
      case "light.intensity":
        this.light.intensity = value / 100;
        this.lightData.intensity = value;
        break;
      case "light.color.r":
        this.light.color.r = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.g":
        this.light.color.g = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.b":
        this.light.color.b = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.colorTemperature":
        this.setColorTemperature(value);
        break;
      case "light.coneAngle":
        this.setConeAngle(value);
        break;
      case "light.penumbra":
        this.setConeFeather(value);
        break;
      case "light.falloff":
        this.setFalloffDistance(value);
        break;
      case "light.shadow.intensity":
        this.lightData.shadow.darkness = value;
        break;
      case "light.shadow.softness":
        this.lightData.shadow.radius = value;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.radius = value;
        }
        break;
      case "light.shadow.bias":
        this.lightData.shadow.bias = value / 1e4;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.bias = value / 1e4;
        }
        break;
      case "light.poi.x":
        this.poiTarget.x = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.y":
        this.poiTarget.y = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.z":
        this.poiTarget.z = value;
        this.updatePointOfInterest(0);
        break;
      case "light.areaSize.width":
        this.setAreaSize(value, this.lightData.areaHeight ?? 100);
        break;
      case "light.areaSize.height":
        this.setAreaSize(this.lightData.areaWidth ?? 100, value);
        break;
      case "light.physicalIntensity":
        this.lightData.physicalIntensity = value;
        if (this.lightData.usePhysicalIntensity) {
          this.light.intensity = value / 100;
        }
        break;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getLight() {
    return this.light;
  }
  getLightData() {
    return { ...this.lightData };
  }
  getLightLinking() {
    return { ...this.lightData.lightLinking };
  }
  /**
   * Check if this light should affect a given layer
   */
  shouldAffectLayer(layerId) {
    const linking = this.lightData.lightLinking;
    if (linking.layers.length === 0) {
      return true;
    }
    const isInList = linking.layers.includes(layerId);
    if (linking.mode === "include") {
      return isInList;
    } else {
      return !isInList;
    }
  }
  setHelperVisible(visible) {
    if (this.helper) {
      this.helper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.lightData.pathFollowing.enabled) {
      this.updatePathFollowing(frame);
    }
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(frame);
    }
    if (this.lightData.animatedIntensity?.animated) {
      const intensity = this.evaluator.evaluate(this.lightData.animatedIntensity, frame);
      this.light.intensity = intensity / 100;
    }
    if (this.lightData.animatedConeAngle?.animated && this.light instanceof SpotLight) {
      const angle = this.evaluator.evaluate(this.lightData.animatedConeAngle, frame);
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (this.lightData.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.lightData.animatedColor, frame);
      this.light.color.set(color);
    }
    if (this.lightData.animatedColorTemperature?.animated && this.lightData.useColorTemperature) {
      const kelvin = this.evaluator.evaluate(this.lightData.animatedColorTemperature, frame);
      const rgb = kelvinToRGB(kelvin);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (this.helper) {
      if (this.helper instanceof PointLightHelper || this.helper instanceof SpotLightHelper || this.helper instanceof DirectionalLightHelper) {
        this.helper.update();
      }
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["intensity"] !== void 0) {
      this.light.intensity = props["intensity"] / 100;
    }
    if (props["coneAngle"] !== void 0 && this.light instanceof SpotLight) {
      this.light.angle = MathUtils.degToRad(props["coneAngle"] / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (props["color"] !== void 0) {
      this.light.color.set(props["color"]);
    }
    if (props["colorTemperature"] !== void 0 && this.lightData.useColorTemperature) {
      const rgb = kelvinToRGB(props["colorTemperature"]);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (props["falloffDistance"] !== void 0) {
      if (this.light instanceof PointLight || this.light instanceof SpotLight) {
        this.light.distance = this.lightData.falloff === "none" ? 0 : props["falloffDistance"];
      }
    }
    if (props["poi.x"] !== void 0 || props["poi.y"] !== void 0 || props["poi.z"] !== void 0) {
      this.poiTarget.set(
        props["poi.x"] ?? this.poiTarget.x,
        props["poi.y"] ?? this.poiTarget.y,
        props["poi.z"] ?? this.poiTarget.z
      );
      this.updatePointOfInterest(0);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.lightType !== void 0 && data.lightType !== this.lightData.lightType) {
      this.setLightType(data.lightType);
    }
    if (data.color !== void 0) {
      this.setColor(data.color);
    }
    if (data.colorTemperature !== void 0) {
      this.setColorTemperature(data.colorTemperature);
    }
    if (data.intensity !== void 0) {
      this.setIntensity(data.intensity);
    }
    if (data.falloffDistance !== void 0) {
      this.setFalloffDistance(data.falloffDistance);
    }
    if (data.falloff !== void 0) {
      this.lightData.falloff = data.falloff;
      this.setFalloffDistance(this.lightData.falloffDistance);
    }
    if (data.coneAngle !== void 0) {
      this.setConeAngle(data.coneAngle);
    }
    if (data.coneFeather !== void 0) {
      this.setConeFeather(data.coneFeather);
    }
    if (data.areaWidth !== void 0 || data.areaHeight !== void 0) {
      this.setAreaSize(
        data.areaWidth ?? this.lightData.areaWidth ?? 100,
        data.areaHeight ?? this.lightData.areaHeight ?? 100
      );
    }
    if (data.shadow !== void 0) {
      Object.assign(this.lightData.shadow, data.shadow);
      if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
        this.configureShadows(this.light);
      }
    }
    if (data.pointOfInterest !== void 0) {
      Object.assign(this.lightData.pointOfInterest, data.pointOfInterest);
    }
    if (data.pathFollowing !== void 0) {
      Object.assign(this.lightData.pathFollowing, data.pathFollowing);
    }
    if (data.lightLinking !== void 0) {
      Object.assign(this.lightData.lightLinking, data.lightLinking);
    }
    if (data.animatedIntensity !== void 0) {
      this.lightData.animatedIntensity = data.animatedIntensity;
    }
    if (data.animatedConeAngle !== void 0) {
      this.lightData.animatedConeAngle = data.animatedConeAngle;
    }
    if (data.animatedColor !== void 0) {
      this.lightData.animatedColor = data.animatedColor;
    }
    if (data.animatedColorTemperature !== void 0) {
      this.lightData.animatedColorTemperature = data.animatedColorTemperature;
    }
  }
  onDispose() {
    if (this.light.dispose) {
      this.light.dispose();
    }
    if (this.helper && this.helper.dispose) {
      this.helper.dispose();
    }
  }
}

const depthflowVertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const depthflowFragmentShader = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class DepthflowLayer extends BaseLayer {
  resources;
  // Textures
  sourceTexture = null;
  depthTexture = null;
  // Mesh and material
  mesh;
  geometry;
  material;
  // Layer data
  depthflowData;
  // Dimensions
  width = 1920;
  height = 1080;
  // Animation state
  animationTime = 0;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.depthflowData = this.extractDepthflowData(layerData);
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new ShaderMaterial({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new Vector2(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: depthflowVertexShader,
      fragmentShader: depthflowFragmentShader,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `depthflow_${this.id}`;
    this.group.add(this.mesh);
    this.loadTextures();
    this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(layerData) {
    const data = layerData.data;
    return {
      sourceLayerId: data?.sourceLayerId ?? "",
      depthLayerId: data?.depthLayerId ?? "",
      config: {
        preset: data?.config?.preset ?? "static",
        zoom: data?.config?.zoom ?? 1,
        offsetX: data?.config?.offsetX ?? 0,
        offsetY: data?.config?.offsetY ?? 0,
        rotation: data?.config?.rotation ?? 0,
        depthScale: data?.config?.depthScale ?? 0.1,
        focusDepth: data?.config?.focusDepth ?? 0.5,
        dollyZoom: data?.config?.dollyZoom ?? 0,
        orbitRadius: data?.config?.orbitRadius ?? 0.1,
        orbitSpeed: data?.config?.orbitSpeed ?? 1,
        swingAmplitude: data?.config?.swingAmplitude ?? 0.05,
        swingFrequency: data?.config?.swingFrequency ?? 1,
        edgeDilation: data?.config?.edgeDilation ?? 0,
        inpaintEdges: data?.config?.inpaintEdges ?? false
      },
      animatedZoom: data?.animatedZoom,
      animatedOffsetX: data?.animatedOffsetX,
      animatedOffsetY: data?.animatedOffsetY,
      animatedRotation: data?.animatedRotation,
      animatedDepthScale: data?.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const sourceTexture = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      if (sourceTexture) {
        this.sourceTexture = sourceTexture;
        this.material.uniforms.sourceTexture.value = sourceTexture;
        if (sourceTexture.image) {
          this.setDimensions(sourceTexture.image.width, sourceTexture.image.height);
        }
      }
    }
    if (this.depthflowData.depthLayerId) {
      const depthTexture = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      if (depthTexture) {
        this.depthTexture = depthTexture;
        this.material.uniforms.depthTexture.value = depthTexture;
      }
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(layerId) {
    const texture = this.resources.getLayerTexture(layerId);
    if (texture) return texture;
    layerLogger.warn(`DepthflowLayer: Could not load texture for layer ${layerId}`);
    return null;
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) return;
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Set source layer
   */
  async setSourceLayer(layerId) {
    this.depthflowData.sourceLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.sourceTexture?.dispose();
      this.sourceTexture = texture;
      this.material.uniforms.sourceTexture.value = texture;
    }
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(layerId) {
    this.depthflowData.depthLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.depthTexture?.dispose();
      this.depthTexture = texture;
      this.material.uniforms.depthTexture.value = texture;
    }
  }
  /**
   * Update config values
   */
  updateConfig(config) {
    Object.assign(this.depthflowData.config, config);
    if (config.depthScale !== void 0) {
      this.material.uniforms.depthScale.value = config.depthScale;
    }
    if (config.focusDepth !== void 0) {
      this.material.uniforms.focusDepth.value = config.focusDepth;
    }
    if (config.zoom !== void 0) {
      this.material.uniforms.zoom.value = config.zoom;
    }
    if (config.rotation !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(config.rotation);
    }
    if (config.edgeDilation !== void 0) {
      this.material.uniforms.edgeDilation.value = config.edgeDilation;
    }
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(frame, fps = 30) {
    const config = this.depthflowData.config;
    const duration = this.outPoint - this.inPoint;
    const progress = duration > 0 ? (frame - this.inPoint) / duration : 0;
    const time = frame / fps;
    let zoom = config.zoom;
    let offsetX = config.offsetX;
    let offsetY = config.offsetY;
    let rotation = config.rotation;
    switch (config.preset) {
      case "static":
        break;
      case "zoom_in":
        zoom = 1 + progress * 0.5;
        break;
      case "zoom_out":
        zoom = 1.5 - progress * 0.5;
        break;
      case "dolly_zoom_in":
        zoom = 1 + progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * progress);
        break;
      case "dolly_zoom_out":
        zoom = 1.5 - progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * (1 - progress));
        break;
      case "pan_left":
        offsetX = progress * 0.2;
        break;
      case "pan_right":
        offsetX = -progress * 0.2;
        break;
      case "pan_up":
        offsetY = progress * 0.2;
        break;
      case "pan_down":
        offsetY = -progress * 0.2;
        break;
      case "circle_cw":
        offsetX = Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "circle_ccw":
        offsetX = -Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "horizontal_swing":
        offsetX = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
      case "vertical_swing":
        offsetY = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
    }
    return { zoom, offsetX, offsetY, rotation };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const presetValues = this.calculatePresetValues(frame);
    let zoom = presetValues.zoom;
    let offsetX = presetValues.offsetX;
    let offsetY = presetValues.offsetY;
    let rotation = presetValues.rotation;
    if (this.depthflowData.animatedZoom) {
      zoom = this.evaluator.evaluate(this.depthflowData.animatedZoom, frame);
    }
    if (this.depthflowData.animatedOffsetX) {
      offsetX = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, frame);
    }
    if (this.depthflowData.animatedOffsetY) {
      offsetY = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, frame);
    }
    if (this.depthflowData.animatedRotation) {
      rotation = this.evaluator.evaluate(this.depthflowData.animatedRotation, frame);
    }
    if (this.depthflowData.animatedDepthScale) {
      this.material.uniforms.depthScale.value = this.evaluator.evaluate(
        this.depthflowData.animatedDepthScale,
        frame
      );
    }
    zoom = this.getDrivenOrBase("depthflow.zoom", zoom);
    offsetX = this.getDrivenOrBase("depthflow.offsetX", offsetX);
    offsetY = this.getDrivenOrBase("depthflow.offsetY", offsetY);
    rotation = this.getDrivenOrBase("depthflow.rotation", rotation);
    this.material.uniforms.zoom.value = zoom;
    this.material.uniforms.offset.value.set(offsetX, offsetY);
    this.material.uniforms.rotation.value = MathUtils.degToRad(rotation);
    this.material.uniforms.time.value = frame / 30;
    this.material.needsUpdate = true;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["zoom"] !== void 0) {
      this.material.uniforms.zoom.value = props["zoom"];
    }
    if (props["offsetX"] !== void 0 || props["offsetY"] !== void 0) {
      const offsetX = props["offsetX"] ?? this.material.uniforms.offset.value.x;
      const offsetY = props["offsetY"] ?? this.material.uniforms.offset.value.y;
      this.material.uniforms.offset.value.set(offsetX, offsetY);
    }
    if (props["rotation"] !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(props["rotation"]);
    }
    if (props["depthScale"] !== void 0) {
      this.material.uniforms.depthScale.value = props["depthScale"];
    }
    this.material.needsUpdate = true;
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.sourceLayerId !== void 0 && data.sourceLayerId !== this.depthflowData.sourceLayerId) {
      this.setSourceLayer(data.sourceLayerId);
    }
    if (data.depthLayerId !== void 0 && data.depthLayerId !== this.depthflowData.depthLayerId) {
      this.setDepthLayer(data.depthLayerId);
    }
    if (data.config) {
      this.updateConfig(data.config);
    }
    if (data.animatedZoom !== void 0) {
      this.depthflowData.animatedZoom = data.animatedZoom;
    }
    if (data.animatedOffsetX !== void 0) {
      this.depthflowData.animatedOffsetX = data.animatedOffsetX;
    }
    if (data.animatedOffsetY !== void 0) {
      this.depthflowData.animatedOffsetY = data.animatedOffsetY;
    }
    if (data.animatedRotation !== void 0) {
      this.depthflowData.animatedRotation = data.animatedRotation;
    }
    if (data.animatedDepthScale !== void 0) {
      this.depthflowData.animatedDepthScale = data.animatedDepthScale;
    }
  }
  onDispose() {
    this.sourceTexture?.dispose();
    this.depthTexture?.dispose();
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ProceduralMatteLayer extends BaseLayer {
  // Matte data
  matteData;
  // Display mesh
  mesh = null;
  material = null;
  texture = null;
  // Rendering canvas (grayscale output)
  renderCanvas;
  renderCtx;
  // Animation evaluator
  matteEvaluator;
  // Dimensions
  width = 512;
  height = 512;
  // Noise seed for deterministic noise
  noiseSeed;
  constructor(layerData) {
    super(layerData);
    this.matteEvaluator = new KeyframeEvaluator();
    this.matteData = this.extractMatteData(layerData);
    this.noiseSeed = this.matteData.parameters.seed ?? Math.random() * 65536;
    this.renderCanvas = document.createElement("canvas");
    this.renderCanvas.width = this.width;
    this.renderCanvas.height = this.height;
    this.renderCtx = this.renderCanvas.getContext("2d");
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract matte data with defaults
   */
  extractMatteData(layerData) {
    const data = layerData.data;
    if (!data) {
      return {
        patternType: "linear_gradient",
        parameters: {},
        animation: {
          enabled: false,
          speed: { id: "speed", name: "Speed", type: "number", value: 1, animated: false, keyframes: [] },
          phase: { id: "phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
          direction: { id: "dir", name: "Direction", type: "number", value: 0, animated: false, keyframes: [] }
        },
        inverted: false,
        levels: {
          inputBlack: { id: "ib", name: "Input Black", type: "number", value: 0, animated: false, keyframes: [] },
          inputWhite: { id: "iw", name: "Input White", type: "number", value: 255, animated: false, keyframes: [] },
          gamma: { id: "g", name: "Gamma", type: "number", value: 1, animated: false, keyframes: [] },
          outputBlack: { id: "ob", name: "Output Black", type: "number", value: 0, animated: false, keyframes: [] },
          outputWhite: { id: "ow", name: "Output White", type: "number", value: 255, animated: false, keyframes: [] }
        }
      };
    }
    return data;
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(this.width, this.height);
    this.texture = new CanvasTexture(this.renderCanvas);
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    this.material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `matte_${this.id}`;
    this.group.add(this.mesh);
  }
  /**
   * Set dimensions
   */
  setDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.renderCanvas.width = width;
    this.renderCanvas.height = height;
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh.geometry = new PlaneGeometry(width, height);
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.renderPattern(frame);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    if (properties.data) {
      this.matteData = this.extractMatteData({ ...properties, data: properties.data });
    }
  }
  // ============================================================================
  // PATTERN RENDERING
  // ============================================================================
  /**
   * Render the pattern to the canvas
   */
  renderPattern(frame) {
    const ctx = this.renderCtx;
    const w = this.width;
    const h = this.height;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);
    const speed = this.matteEvaluator.evaluate(this.matteData.animation.speed, frame);
    const phase = this.matteEvaluator.evaluate(this.matteData.animation.phase, frame);
    const time = this.matteData.animation.enabled ? frame * speed / 60 + phase : 0;
    switch (this.matteData.patternType) {
      case "linear_gradient":
        this.renderLinearGradient(ctx, w, h, frame, time);
        break;
      case "radial_gradient":
        this.renderRadialGradient(ctx, w, h, frame, time);
        break;
      case "angular_gradient":
        this.renderAngularGradient(ctx, w, h, frame, time);
        break;
      case "ramp":
        this.renderRamp(ctx, w, h, frame, time);
        break;
      case "noise":
        this.renderNoise(ctx, w, h, frame, time);
        break;
      case "checkerboard":
        this.renderCheckerboard(ctx, w, h, frame, time);
        break;
      case "circle":
        this.renderCircle(ctx, w, h, frame, time);
        break;
      case "rectangle":
        this.renderRectangle(ctx, w, h, frame, time);
        break;
      case "iris":
        this.renderIris(ctx, w, h, frame, time);
        break;
      case "radial_wipe":
        this.renderRadialWipe(ctx, w, h, frame, time);
        break;
      case "venetian_blinds":
        this.renderVenetianBlinds(ctx, w, h, frame, time);
        break;
      case "dissolve":
        this.renderDissolve(ctx, w, h, frame, time);
        break;
      case "wave":
        this.renderWave(ctx, w, h, frame, time);
        break;
      default:
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);
    }
    this.applyLevels(frame);
    if (this.matteData.inverted) {
      this.invertCanvas();
    }
  }
  // ============================================================================
  // PATTERN IMPLEMENTATIONS
  // ============================================================================
  renderLinearGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const angle = this.matteEvaluator.evaluate(params.angle, frame) + time * 360;
    const blend = this.matteEvaluator.evaluate(params.blend, frame);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const blendHalf = Math.max(1e-3, blend / 2);
    gradient.addColorStop(Math.max(0, 0.5 - blendHalf), "black");
    gradient.addColorStop(Math.min(1, 0.5 + blendHalf), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = this.matteEvaluator.evaluate(params.centerX, frame);
    const centerY = this.matteEvaluator.evaluate(params.centerY, frame);
    const radius = this.matteEvaluator.evaluate(params.radius, frame) + time * 0.5;
    const blend = params.blend ? this.matteEvaluator.evaluate(params.blend, frame) : 0.3;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = radius * Math.max(w, h) / 2;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    gradient.addColorStop(Math.max(0, 1 - blend), "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderAngularGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rotation = (params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0) + time * 360;
    const cx = centerX * w;
    const cy = centerY * h;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI + rotation;
        angle = (angle % 360 + 360) % 360;
        const value = Math.round(angle / 360 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderRamp(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = this.matteEvaluator.evaluate(params.progress, frame);
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.1;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const soft = Math.max(1e-3, softness / 2);
    gradient.addColorStop(Math.max(0, animProgress - soft), "black");
    gradient.addColorStop(Math.min(1, animProgress + soft), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderNoise(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const scale = params.scale ? this.matteEvaluator.evaluate(params.scale, frame) : 50;
    const octaves = params.octaves ?? 4;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const timeOffset = time * 10;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let noise = 0;
        let amp = 1;
        let freq = 1 / scale;
        for (let o = 0; o < octaves; o++) {
          noise += this.perlinNoise(x * freq + timeOffset, y * freq) * amp;
          amp *= 0.5;
          freq *= 2;
        }
        const value = Math.round((noise + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderCheckerboard(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const tilesX = params.tilesX ? this.matteEvaluator.evaluate(params.tilesX, frame) : 8;
    const tilesY = params.tilesY ? this.matteEvaluator.evaluate(params.tilesY, frame) : 8;
    const rotation = params.rotation ? this.matteEvaluator.evaluate(params.rotation, frame) : 0;
    const tileW = w / tilesX;
    const tileH = h / tilesY;
    const offset = time * tileW;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.translate(-w / 2 - offset, -h / 2);
    for (let y = -1; y <= tilesY + 1; y++) {
      for (let x = -1; x <= tilesX + 1; x++) {
        const isWhite = (x + y) % 2 === 0;
        ctx.fillStyle = isWhite ? "white" : "black";
        ctx.fillRect(x * tileW, y * tileH, tileW, tileH);
      }
    }
    ctx.restore();
  }
  renderCircle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const radius = params.radius ? this.matteEvaluator.evaluate(params.radius, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = (radius + time * 0.5) * Math.min(w, h) / 2;
    if (feather > 0) {
      const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 50), cx, cy, r);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, "black");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  renderRectangle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rectWidth = params.width ? this.matteEvaluator.evaluate(params.width, frame) : 0.5;
    const rectHeight = params.height ? this.matteEvaluator.evaluate(params.height, frame) : 0.5;
    const cornerRadius = params.cornerRadius ? this.matteEvaluator.evaluate(params.cornerRadius, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const rw = (rectWidth + time * 0.2) * w;
    const rh = (rectHeight + time * 0.2) * h;
    const cr = cornerRadius * Math.min(rw, rh) / 2;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.roundRect(cx - rw / 2, cy - rh / 2, rw, rh, cr);
    ctx.fill();
  }
  renderIris(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0.1;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const maxRadius = Math.sqrt(w * w + h * h) / 2;
    const r = animProgress * maxRadius;
    const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 100), cx, cy, r);
    gradient.addColorStop(0, "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialWipe(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.05;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const angle = animProgress * Math.PI * 2;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let pixelAngle = Math.atan2(dy, dx) + Math.PI;
        const diff = pixelAngle - angle;
        const dist = Math.abs((diff + Math.PI * 3) % (Math.PI * 2) - Math.PI) / Math.PI;
        let value = dist < 0.5 ? 255 : 0;
        if (softness > 0) {
          const soft = softness * Math.PI;
          if (Math.abs(dist - 0.5) < soft) {
            value = Math.round(255 * (1 - (dist - 0.5 + soft) / (soft * 2)));
          }
        }
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderVenetianBlinds(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const slats = params.slats ? this.matteEvaluator.evaluate(params.slats, frame) : 10;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const slatHeight = h / slats;
    const openAmount = animProgress * slatHeight;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle * Math.PI / 180);
    ctx.translate(-w / 2, -h / 2);
    for (let i = 0; i < slats; i++) {
      ctx.fillStyle = "white";
      ctx.fillRect(0, i * slatHeight, w, openAmount);
    }
    ctx.restore();
  }
  renderDissolve(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const blockSize = params.blockSize ? this.matteEvaluator.evaluate(params.blockSize, frame) : 4;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const blocksX = Math.ceil(w / blockSize);
    const blocksY = Math.ceil(h / blockSize);
    for (let by = 0; by < blocksY; by++) {
      for (let bx = 0; bx < blocksX; bx++) {
        const random = this.hash(bx + by * blocksX + this.noiseSeed);
        const isVisible = random < animProgress;
        const value = isVisible ? 255 : 0;
        for (let dy = 0; dy < blockSize && by * blockSize + dy < h; dy++) {
          for (let dx = 0; dx < blockSize && bx * blockSize + dx < w; dx++) {
            const x = bx * blockSize + dx;
            const y = by * blockSize + dy;
            const idx = (y * w + x) * 4;
            data[idx] = data[idx + 1] = data[idx + 2] = value;
            data[idx + 3] = 255;
          }
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderWave(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const frequency = params.frequency ? this.matteEvaluator.evaluate(params.frequency, frame) : 4;
    const amplitude = params.amplitude ? this.matteEvaluator.evaluate(params.amplitude, frame) : 0.5;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const waveType = params.waveType ?? "sine";
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const rad = angle * Math.PI / 180;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const rx = (x - w / 2) * Math.cos(rad) - (y - h / 2) * Math.sin(rad);
        const phase = (rx / w * frequency + time) * Math.PI * 2;
        let wave;
        switch (waveType) {
          case "triangle":
            wave = Math.abs(phase / Math.PI % 2 - 1) * 2 - 1;
            break;
          case "square":
            wave = Math.sin(phase) >= 0 ? 1 : -1;
            break;
          case "sawtooth":
            wave = phase / Math.PI % 2 - 1;
            break;
          default:
            wave = Math.sin(phase);
        }
        const value = Math.round((wave * amplitude + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  /**
   * Apply levels adjustment
   */
  applyLevels(frame) {
    const levels = this.matteData.levels;
    const inputBlack = this.matteEvaluator.evaluate(levels.inputBlack, frame);
    const inputWhite = this.matteEvaluator.evaluate(levels.inputWhite, frame);
    const gamma = this.matteEvaluator.evaluate(levels.gamma, frame);
    const outputBlack = this.matteEvaluator.evaluate(levels.outputBlack, frame);
    const outputWhite = this.matteEvaluator.evaluate(levels.outputWhite, frame);
    if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
      return;
    }
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    const inputRange = inputWhite - inputBlack;
    const outputRange = outputWhite - outputBlack;
    for (let i = 0; i < data.length; i += 4) {
      let value = data[i];
      value = Math.max(0, Math.min(255, (value - inputBlack) / inputRange * 255));
      value = Math.pow(value / 255, 1 / gamma) * 255;
      value = outputBlack + value / 255 * outputRange;
      data[i] = data[i + 1] = data[i + 2] = Math.round(value);
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  /**
   * Invert the canvas
   */
  invertCanvas() {
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];
      data[i + 1] = 255 - data[i + 1];
      data[i + 2] = 255 - data[i + 2];
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  /**
   * Simple deterministic hash function
   */
  hash(n) {
    const x = Math.sin(n) * 43758.5453123;
    return x - Math.floor(x);
  }
  /**
   * Simple 2D Perlin noise approximation
   */
  perlinNoise(x, y) {
    const xi = Math.floor(x);
    const yi = Math.floor(y);
    const xf = x - xi;
    const yf = y - yi;
    const tl = this.hash(xi + yi * 57 + this.noiseSeed);
    const tr = this.hash(xi + 1 + yi * 57 + this.noiseSeed);
    const bl = this.hash(xi + (yi + 1) * 57 + this.noiseSeed);
    const br = this.hash(xi + 1 + (yi + 1) * 57 + this.noiseSeed);
    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);
    return (tl + u * (tr - tl) + v * (bl - tl) + u * v * (tl - tr - bl + br)) * 2 - 1;
  }
  // ============================================================================
  // SOURCE CANVAS (for effects and track mattes)
  // ============================================================================
  getSourceCanvas() {
    return this.renderCanvas;
  }
  applyProcessedEffects(processedCanvas) {
    this.renderCtx.clearRect(0, 0, this.width, this.height);
    this.renderCtx.drawImage(processedCanvas, 0, 0);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
  }
}

class ShapeLayer extends BaseLayer {
  type = "shape";
  // Shape data
  shapeData;
  // Rendering
  canvas;
  ctx;
  texture;
  mesh;
  // Canvas size (matches composition)
  canvasWidth = 1920;
  canvasHeight = 1080;
  // 3D extrusion (if any)
  extrudedMeshes = [];
  extrudeGroup;
  // Current frame for animation
  currentFrame = 0;
  constructor(layerData) {
    super(layerData);
    this.shapeData = layerData.data || {
      contents: [],
      blendMode: "normal",
      quality: "normal",
      gpuAccelerated: true
    };
    this.canvas = new OffscreenCanvas(this.canvasWidth, this.canvasHeight);
    this.ctx = this.canvas.getContext("2d");
    this.texture = new CanvasTexture(this.canvas);
    this.texture.colorSpace = SRGBColorSpace;
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    const geometry = new PlaneGeometry(this.canvasWidth, this.canvasHeight);
    const material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, material);
    this.mesh.position.set(this.canvasWidth / 2, this.canvasHeight / 2, 0);
    this.group.add(this.mesh);
    this.extrudeGroup = new Group();
    this.group.add(this.extrudeGroup);
    this.renderShape();
  }
  // ============================================================================
  // SIZE MANAGEMENT
  // ============================================================================
  /**
   * Set canvas size (should match composition)
   */
  setSize(width, height) {
    if (width === this.canvasWidth && height === this.canvasHeight) return;
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.canvas = new OffscreenCanvas(width, height);
    this.ctx = this.canvas.getContext("2d");
    this.texture.image = this.canvas;
    this.texture.needsUpdate = true;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
    this.mesh.position.set(width / 2, height / 2, 0);
    this.renderShape();
  }
  // ============================================================================
  // SHAPE DATA ACCESS
  // ============================================================================
  getShapeData() {
    return this.shapeData;
  }
  setShapeData(data) {
    this.shapeData = data;
    this.renderShape();
  }
  addContent(content) {
    this.shapeData.contents.push(content);
    this.renderShape();
  }
  removeContent(index) {
    this.shapeData.contents.splice(index, 1);
    this.renderShape();
  }
  updateContent(index, content) {
    if (index >= 0 && index < this.shapeData.contents.length) {
      this.shapeData.contents[index] = content;
      this.renderShape();
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  evaluateFrame(frame) {
    this.currentFrame = frame;
    super.evaluateFrame(frame);
    this.renderShape();
  }
  /**
   * Called during frame evaluation to update shape-specific properties
   */
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
  }
  /**
   * Called when layer properties are updated
   */
  onUpdate(properties) {
    if (properties.data) {
      this.shapeData = properties.data;
      this.renderShape();
    }
  }
  onApplyEvaluatedState(state) {
    if (state.shapeData) {
      this.shapeData = state.shapeData;
    }
    this.renderShape();
  }
  // ============================================================================
  // SHAPE RENDERING
  // ============================================================================
  /**
   * Main render function
   */
  renderShape() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    const evaluatedPaths = this.evaluateContents(this.shapeData.contents);
    for (const evalPath of evaluatedPaths) {
      this.renderPath(evalPath);
    }
    this.texture.needsUpdate = true;
  }
  /**
   * Evaluate all shape contents into renderable paths
   */
  evaluateContents(contents) {
    const generators = [];
    const operators = [];
    const modifiers = [];
    const repeaters = [];
    const transforms = [];
    const groups = [];
    const illustratorOps = [];
    for (const content of contents) {
      switch (content.type) {
        case "rectangle":
        case "ellipse":
        case "polygon":
        case "star":
        case "path":
          generators.push(content);
          break;
        case "fill":
        case "stroke":
        case "gradientFill":
        case "gradientStroke":
          modifiers.push(content);
          break;
        case "trimPaths":
        case "mergePaths":
        case "offsetPaths":
        case "puckerBloat":
        case "wigglePaths":
        case "zigZag":
        case "twist":
        case "roundedCorners":
          operators.push(content);
          break;
        case "repeater":
          repeaters.push(content);
          break;
        case "transform":
          transforms.push(content);
          break;
        case "group":
          groups.push(content);
          break;
        case "simplifyPath":
        case "smoothPath":
        case "extrude":
        case "trace":
          illustratorOps.push(content);
          break;
      }
    }
    let paths = generators.map((gen) => this.generatePath(gen));
    for (const op of operators) {
      paths = this.applyOperator(paths, op);
    }
    for (const op of illustratorOps) {
      paths = this.applyIllustratorOperator(paths, op);
    }
    for (const transform of transforms) {
      paths = paths.map((p) => this.applyShapeTransform(p, transform));
    }
    for (const repeater of repeaters) {
      paths = this.applyRepeater(paths, repeater);
    }
    const result = [];
    for (const path of paths) {
      const evalPath = { path };
      for (const mod of modifiers) {
        this.applyModifier(evalPath, mod);
      }
      result.push(evalPath);
    }
    for (const group of groups) {
      const groupPaths = this.evaluateContents(group.contents);
      result.push(...groupPaths);
    }
    return result;
  }
  /**
   * Generate a path from a shape generator
   */
  generatePath(generator) {
    switch (generator.type) {
      case "rectangle": {
        const rect = generator;
        const pos = this.getAnimatedValue(rect.position);
        const size = this.getAnimatedValue(rect.size);
        const roundness = this.getAnimatedValue(rect.roundness);
        return generateRectangle(pos, size, roundness, rect.direction);
      }
      case "ellipse": {
        const ellipse = generator;
        const pos = this.getAnimatedValue(ellipse.position);
        const size = this.getAnimatedValue(ellipse.size);
        return generateEllipse(pos, size, ellipse.direction);
      }
      case "polygon": {
        const poly = generator;
        const pos = this.getAnimatedValue(poly.position);
        const points = this.getAnimatedValue(poly.points);
        const radius = this.getAnimatedValue(poly.outerRadius);
        const roundness = this.getAnimatedValue(poly.outerRoundness);
        const rotation = this.getAnimatedValue(poly.rotation);
        return generatePolygon(pos, points, radius, roundness, rotation, poly.direction);
      }
      case "star": {
        const star = generator;
        const pos = this.getAnimatedValue(star.position);
        const points = this.getAnimatedValue(star.points);
        const outerR = this.getAnimatedValue(star.outerRadius);
        const innerR = this.getAnimatedValue(star.innerRadius);
        const outerRound = this.getAnimatedValue(star.outerRoundness);
        const innerRound = this.getAnimatedValue(star.innerRoundness);
        const rotation = this.getAnimatedValue(star.rotation);
        return generateStar(pos, points, outerR, innerR, outerRound, innerRound, rotation, star.direction);
      }
      case "path": {
        const pathShape = generator;
        return clonePath(this.getAnimatedValue(pathShape.path));
      }
      default:
        return { vertices: [], closed: false };
    }
  }
  /**
   * Apply a path operator to paths
   */
  applyOperator(paths, operator) {
    switch (operator.type) {
      case "trimPaths": {
        const trim = operator;
        const start = this.getAnimatedValue(trim.start);
        const end = this.getAnimatedValue(trim.end);
        const offset = this.getAnimatedValue(trim.offset);
        if (trim.mode === "simultaneously") {
          return paths.map((p) => trimPath(p, start, end, offset));
        } else {
          return paths.map((p, i) => {
            const pathStart = (start + 100 / paths.length * i) % 100;
            const pathEnd = (end + 100 / paths.length * i) % 100;
            return trimPath(p, pathStart, pathEnd, offset);
          });
        }
      }
      case "mergePaths": {
        const merge = operator;
        return mergePaths(paths, merge.mode);
      }
      case "offsetPaths": {
        const offset = operator;
        const amount = this.getAnimatedValue(offset.amount);
        const copies = this.getAnimatedValue(offset.copies);
        const copyOff = this.getAnimatedValue(offset.copyOffset);
        const miter = this.getAnimatedValue(offset.miterLimit);
        if (copies <= 1) {
          return paths.map((p) => offsetPath(p, amount, offset.lineJoin, miter));
        } else {
          return paths.flatMap(
            (p) => ShapeOperations.offsetPathMultiple(p, amount, copies, copyOff, offset.lineJoin, miter)
          );
        }
      }
      case "puckerBloat": {
        const pb = operator;
        const amount = this.getAnimatedValue(pb.amount);
        return paths.map((p) => puckerBloat(p, amount));
      }
      case "wigglePaths": {
        const wiggle = operator;
        const size = this.getAnimatedValue(wiggle.size);
        const detail = this.getAnimatedValue(wiggle.detail);
        const correlation = this.getAnimatedValue(wiggle.correlation);
        const temporal = this.getAnimatedValue(wiggle.temporalPhase) + this.currentFrame * 0.1;
        const spatial = this.getAnimatedValue(wiggle.spatialPhase);
        return paths.map(
          (p, i) => wigglePath(p, size, detail, wiggle.points, correlation, temporal, spatial, wiggle.randomSeed + i)
        );
      }
      case "zigZag": {
        const zz = operator;
        const size = this.getAnimatedValue(zz.size);
        const ridges = this.getAnimatedValue(zz.ridgesPerSegment);
        return paths.map((p) => zigZagPath(p, size, ridges, zz.points));
      }
      case "twist": {
        const twist = operator;
        const angle = this.getAnimatedValue(twist.angle);
        const center = this.getAnimatedValue(twist.center);
        return paths.map((p) => twistPath(p, angle, center));
      }
      case "roundedCorners": {
        const rc = operator;
        const radius = this.getAnimatedValue(rc.radius);
        return paths.map((p) => roundCorners(p, radius));
      }
      default:
        return paths;
    }
  }
  /**
   * Apply Illustrator-specific operators
   */
  applyIllustratorOperator(paths, operator) {
    switch (operator.type) {
      case "simplifyPath": {
        const simp = operator;
        const tolerance = this.getAnimatedValue(simp.tolerance);
        return paths.map((p) => simplifyPath(p, tolerance, simp.straightLines));
      }
      case "smoothPath": {
        const smooth = operator;
        const amount = this.getAnimatedValue(smooth.amount);
        return paths.map((p) => smoothPath(p, amount));
      }
      case "extrude": {
        this.createExtrudedGeometry(paths, operator);
        return paths;
      }
      case "trace": {
        return paths;
      }
      default:
        return paths;
    }
  }
  /**
   * Apply a shape transform
   */
  applyShapeTransform(path, transform) {
    const anchor = this.getAnimatedValue(transform.anchorPoint);
    const position = this.getAnimatedValue(transform.position);
    const scale = this.getAnimatedValue(transform.scale);
    const rotation = this.getAnimatedValue(transform.rotation);
    return transformPath(path, anchor, position, scale, rotation);
  }
  /**
   * Apply repeater operator
   */
  applyRepeater(paths, repeater) {
    const copies = Math.floor(this.getAnimatedValue(repeater.copies));
    if (copies <= 1) return paths;
    const offset = this.getAnimatedValue(repeater.offset);
    const anchor = this.getAnimatedValue(repeater.transform.anchorPoint);
    const position = this.getAnimatedValue(repeater.transform.position);
    const scale = this.getAnimatedValue(repeater.transform.scale);
    const rotation = this.getAnimatedValue(repeater.transform.rotation);
    const startOp = this.getAnimatedValue(repeater.transform.startOpacity);
    const endOp = this.getAnimatedValue(repeater.transform.endOpacity);
    const repeated = applyRepeater(
      paths,
      copies,
      offset,
      anchor,
      position,
      scale,
      rotation,
      startOp,
      endOp
    );
    const result = [];
    if (repeater.composite === "below") {
      result.push(...paths);
      for (const rep of repeated.slice(1)) {
        result.push(...rep.paths);
      }
    } else {
      for (let i = repeated.length - 1; i >= 1; i--) {
        result.push(...repeated[i].paths);
      }
      result.push(...paths);
    }
    return result;
  }
  /**
   * Apply a modifier (fill/stroke) to an evaluated path
   */
  applyModifier(evalPath, modifier) {
    switch (modifier.type) {
      case "fill": {
        const fill = modifier;
        evalPath.fill = {
          color: this.getAnimatedValue(fill.color),
          opacity: this.getAnimatedValue(fill.opacity),
          rule: fill.fillRule
        };
        break;
      }
      case "stroke": {
        const stroke = modifier;
        evalPath.stroke = {
          color: this.getAnimatedValue(stroke.color),
          opacity: this.getAnimatedValue(stroke.opacity),
          width: this.getAnimatedValue(stroke.width),
          lineCap: stroke.lineCap,
          lineJoin: stroke.lineJoin,
          dashPattern: this.getAnimatedValue(stroke.dashPattern),
          dashOffset: this.getAnimatedValue(stroke.dashOffset)
        };
        break;
      }
      case "gradientFill": {
        const grad = modifier;
        const gradDef = this.getAnimatedValue(grad.gradient);
        evalPath.gradientFill = {
          type: gradDef.type,
          stops: gradDef.stops,
          startPoint: gradDef.startPoint,
          endPoint: gradDef.endPoint,
          opacity: this.getAnimatedValue(grad.opacity)
        };
        break;
      }
    }
  }
  /**
   * Get animated value at current frame
   */
  getAnimatedValue(prop) {
    return prop.value;
  }
  /**
   * Render a single evaluated path to canvas
   */
  renderPath(evalPath) {
    const { path, fill, stroke, gradientFill } = evalPath;
    if (path.vertices.length < 2) return;
    this.ctx.save();
    const path2d = this.buildPath2D(path);
    if (gradientFill) {
      const gradient = this.createGradient(gradientFill);
      this.ctx.globalAlpha = gradientFill.opacity / 100;
      this.ctx.fillStyle = gradient;
      this.ctx.fill(path2d, "nonzero");
    } else if (fill) {
      this.ctx.globalAlpha = fill.opacity / 100;
      this.ctx.fillStyle = this.colorToCSS(fill.color);
      this.ctx.fill(path2d, fill.rule);
    }
    if (stroke && stroke.width > 0) {
      this.ctx.globalAlpha = stroke.opacity / 100;
      this.ctx.strokeStyle = this.colorToCSS(stroke.color);
      this.ctx.lineWidth = stroke.width;
      this.ctx.lineCap = stroke.lineCap;
      this.ctx.lineJoin = stroke.lineJoin;
      if (stroke.dashPattern.length > 0) {
        this.ctx.setLineDash(stroke.dashPattern);
        this.ctx.lineDashOffset = stroke.dashOffset;
      }
      this.ctx.stroke(path2d);
    }
    this.ctx.restore();
  }
  /**
   * Build a Path2D from a BezierPath
   */
  buildPath2D(path) {
    const p = new Path2D();
    if (path.vertices.length === 0) return p;
    const v0 = path.vertices[0];
    p.moveTo(v0.point.x, v0.point.y);
    for (let i = 0; i < path.vertices.length; i++) {
      const curr = path.vertices[i];
      const next = path.vertices[(i + 1) % path.vertices.length];
      if (!path.closed && i === path.vertices.length - 1) break;
      const cp1x = curr.point.x + curr.outHandle.x;
      const cp1y = curr.point.y + curr.outHandle.y;
      const cp2x = next.point.x + next.inHandle.x;
      const cp2y = next.point.y + next.inHandle.y;
      p.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
    }
    if (path.closed) {
      p.closePath();
    }
    return p;
  }
  /**
   * Convert ShapeColor to CSS color string
   */
  colorToCSS(color) {
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
  }
  /**
   * Create canvas gradient
   */
  createGradient(gradDef) {
    if (!gradDef) {
      return this.ctx.createLinearGradient(0, 0, 0, 0);
    }
    const startX = gradDef.startPoint.x * this.canvasWidth;
    const startY = gradDef.startPoint.y * this.canvasHeight;
    const endX = gradDef.endPoint.x * this.canvasWidth;
    const endY = gradDef.endPoint.y * this.canvasHeight;
    let gradient;
    if (gradDef.type === "linear") {
      gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
    } else {
      const radius = Math.sqrt(
        Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
      );
      gradient = this.ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
    }
    for (const stop of gradDef.stops) {
      gradient.addColorStop(stop.position, this.colorToCSS(stop.color));
    }
    return gradient;
  }
  /**
   * Create extruded 3D geometry from paths
   */
  createExtrudedGeometry(paths, extrude) {
    for (const mesh of this.extrudedMeshes) {
      this.extrudeGroup.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    this.extrudedMeshes = [];
    const depth = this.getAnimatedValue(extrude.depth);
    const bevelDepth = this.getAnimatedValue(extrude.bevelDepth);
    const frontColor = this.getAnimatedValue(extrude.material.frontColor);
    this.getAnimatedValue(extrude.material.sideColor);
    for (const path of paths) {
      if (path.vertices.length < 3 || !path.closed) continue;
      const shape = new Shape();
      const v0 = path.vertices[0];
      shape.moveTo(v0.point.x, v0.point.y);
      for (let i = 0; i < path.vertices.length; i++) {
        const curr = path.vertices[i];
        const next = path.vertices[(i + 1) % path.vertices.length];
        const cp1x = curr.point.x + curr.outHandle.x;
        const cp1y = curr.point.y + curr.outHandle.y;
        const cp2x = next.point.x + next.inHandle.x;
        const cp2y = next.point.y + next.inHandle.y;
        shape.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
      }
      const geometry = new ExtrudeGeometry(shape, {
        depth,
        bevelEnabled: bevelDepth > 0,
        bevelThickness: bevelDepth,
        bevelSize: bevelDepth,
        bevelSegments: extrude.bevelSegments
      });
      const material = new MeshStandardMaterial({
        color: new Color(frontColor.r / 255, frontColor.g / 255, frontColor.b / 255),
        metalness: 0.1,
        roughness: 0.8
      });
      const mesh = new Mesh(geometry, material);
      this.extrudeGroup.add(mesh);
      this.extrudedMeshes.push(mesh);
    }
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  dispose() {
    this.texture.dispose();
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    for (const mesh of this.extrudedMeshes) {
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    super.dispose();
  }
}

class ModelLayer extends BaseLayer {
  /** The loaded 3D model */
  model = null;
  /** Original materials (for restoring after override) */
  originalMaterials = /* @__PURE__ */ new Map();
  /** Animation mixer for animated models */
  mixer = null;
  /** Available animation clips */
  animationClips = [];
  /** Currently playing animation action */
  currentAction = null;
  /** Skeleton helper for bone visualization */
  skeletonHelper = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  modelData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders (static for efficiency) */
  static gltfLoader = null;
  static objLoader = null;
  static fbxLoader = null;
  static colladaLoader = null;
  static dracoLoader = null;
  /** Composition FPS for animation sync */
  fps = 30;
  constructor(layerData) {
    super(layerData);
    this.modelData = this.extractModelData(layerData);
    this.initializeLoaders();
    this.loadModel();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!ModelLayer.gltfLoader) {
      ModelLayer.gltfLoader = new GLTFLoader();
      ModelLayer.dracoLoader = new DRACOLoader();
      ModelLayer.dracoLoader.setDecoderPath("/draco/");
      ModelLayer.gltfLoader.setDRACOLoader(ModelLayer.dracoLoader);
      ModelLayer.gltfLoader.setMeshoptDecoder(MeshoptDecoder);
    }
    if (!ModelLayer.objLoader) {
      ModelLayer.objLoader = new OBJLoader();
    }
    if (!ModelLayer.fbxLoader) {
      ModelLayer.fbxLoader = new FBXLoader();
    }
    if (!ModelLayer.colladaLoader) {
      ModelLayer.colladaLoader = new ColladaLoader();
    }
  }
  /**
   * Extract model data from layer
   */
  extractModelData(layerData) {
    const data = layerData.data;
    const defaultScale = {
      id: `${layerData.id}_scale`,
      name: "Scale",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "gltf",
      scale: data?.scale ?? defaultScale,
      uniformScale: data?.uniformScale ?? true,
      materialOverride: data?.materialOverride,
      animation: data?.animation,
      boundingBox: data?.boundingBox,
      castShadow: data?.castShadow ?? true,
      receiveShadow: data?.receiveShadow ?? true,
      frustumCulled: data?.frustumCulled ?? true,
      renderOrder: data?.renderOrder ?? 0,
      showBoundingBox: data?.showBoundingBox ?? false,
      showSkeleton: data?.showSkeleton ?? false,
      envMapIntensity: data?.envMapIntensity ?? 1,
      lod: data?.lod
    };
  }
  /**
   * Load the 3D model from asset
   */
  async loadModel() {
    if (!this.modelData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.modelData.assetId);
      let loadedObject;
      switch (this.modelData.format) {
        case "gltf":
        case "glb":
          loadedObject = await this.loadGLTF(url);
          break;
        case "obj":
          loadedObject = await this.loadOBJ(url);
          break;
        case "fbx":
          loadedObject = await this.loadFBX(url);
          break;
        case "dae":
          loadedObject = await this.loadCollada(url);
          break;
        case "usd":
        case "usda":
        case "usdc":
        case "usdz":
          loadedObject = await this.loadUSD(url);
          break;
        default:
          throw new Error(`Unsupported model format: ${this.modelData.format}`);
      }
      this.setModel(loadedObject);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[ModelLayer] Failed to load model: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load GLTF/GLB model
   */
  loadGLTF(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.gltfLoader.load(
        url,
        (gltf) => {
          if (gltf.animations && gltf.animations.length > 0) {
            this.animationClips = gltf.animations;
            this.setupAnimations(gltf.scene);
          }
          resolve(gltf.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load OBJ model
   */
  loadOBJ(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.objLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load FBX model
   */
  loadFBX(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.fbxLoader.load(
        url,
        (object) => {
          if (object.animations && object.animations.length > 0) {
            this.animationClips = object.animations;
            this.setupAnimations(object);
          }
          resolve(object);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load Collada (DAE) model
   */
  loadCollada(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.colladaLoader.load(
        url,
        (collada) => {
          if (collada.scene.animations && collada.scene.animations.length > 0) {
            this.animationClips = collada.scene.animations;
            this.setupAnimations(collada.scene);
          }
          resolve(collada.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load USD/USDZ model
   * Note: USD support in Three.js is limited. This is a placeholder for future implementation.
   */
  async loadUSD(url) {
    try {
      const { USDZLoader } = await import('./weyl-three-vendor.js').then(n => n.bp);
      const loader = new USDZLoader();
      return new Promise((resolve, reject) => {
        loader.load(url, resolve, void 0, reject);
      });
    } catch {
      console.warn("[ModelLayer] USD/USDZ loader not available. Creating placeholder.");
      return this.createUSDPlaceholder();
    }
  }
  /**
   * Create placeholder for USD when loader unavailable
   */
  createUSDPlaceholder() {
    const group = new Group();
    group.name = "usd_placeholder";
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshStandardMaterial({
      color: 4886745,
      wireframe: true
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    return group;
  }
  /**
   * Create placeholder model when loading fails or no asset
   */
  createPlaceholder() {
    const group = new Group();
    group.name = `model_placeholder_${this.id}`;
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshBasicMaterial({
      color: 16737792,
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    const axisHelper = new AxesHelper(75);
    group.add(axisHelper);
    this.setModel(group);
  }
  /**
   * Set the loaded model
   */
  setModel(object) {
    if (this.model) {
      this.group.remove(this.model);
      this.disposeModel();
    }
    this.model = object;
    this.model.name = `model_${this.id}`;
    this.storeOriginalMaterials();
    this.applyShadowSettings();
    if (this.modelData.materialOverride) {
      this.applyMaterialOverride(this.modelData.materialOverride);
    }
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.updateSkeletonHelper();
    this.group.add(this.model);
  }
  /**
   * Store original materials for later restoration
   */
  storeOriginalMaterials() {
    this.originalMaterials.clear();
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        this.originalMaterials.set(child, child.material);
      }
    });
  }
  /**
   * Apply shadow settings to model
   */
  applyShadowSettings() {
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.castShadow = this.modelData.castShadow;
        child.receiveShadow = this.modelData.receiveShadow;
        child.frustumCulled = this.modelData.frustumCulled;
        child.renderOrder = this.modelData.renderOrder;
      }
    });
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.model) return;
    const box = new Box3().setFromObject(this.model);
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.modelData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Setup animation mixer and actions
   */
  setupAnimations(object) {
    this.mixer = new AnimationMixer(object);
    if (!this.modelData.animation) {
      this.modelData.animation = {
        clips: [],
        time: {
          id: `${this.id}_anim_time`,
          name: "Animation Time",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        speed: 1,
        loop: true,
        autoPlay: false
      };
    }
    this.modelData.animation.clips = this.animationClips.map((clip) => ({
      name: clip.name,
      duration: clip.duration,
      frameCount: Math.round(clip.duration * this.fps)
    }));
    if (this.modelData.animation.autoPlay && this.animationClips.length > 0) {
      this.playAnimation(this.animationClips[0].name);
    }
  }
  /**
   * Play an animation clip by name
   */
  playAnimation(clipName) {
    if (!this.mixer) return;
    const clip = this.animationClips.find((c) => c.name === clipName);
    if (!clip) return;
    if (this.currentAction) {
      this.currentAction.stop();
    }
    this.currentAction = this.mixer.clipAction(clip);
    this.currentAction.setLoop(
      this.modelData.animation?.loop ? LoopRepeat : LoopOnce,
      Infinity
    );
    this.currentAction.play();
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = clipName;
    }
  }
  /**
   * Stop current animation
   */
  stopAnimation() {
    if (this.currentAction) {
      this.currentAction.stop();
      this.currentAction = null;
    }
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = void 0;
    }
  }
  /**
   * Set animation time directly (for scrubbing)
   */
  setAnimationTime(time) {
    if (!this.mixer || !this.currentAction) return;
    this.currentAction.time = time;
    this.mixer.update(0);
  }
  /**
   * Update animation mixer
   */
  updateAnimation(deltaTime) {
    if (!this.mixer) return;
    const speed = this.modelData.animation?.speed ?? 1;
    this.mixer.update(deltaTime * speed);
  }
  // ============================================================================
  // MATERIAL OVERRIDES
  // ============================================================================
  /**
   * Apply material override to all meshes
   */
  applyMaterialOverride(override) {
    if (!this.model) return;
    this.model.traverse((child) => {
      if (child instanceof Mesh) {
        this.applyMaterialOverrideToMesh(child, override);
      }
    });
  }
  /**
   * Apply material override to a single mesh
   */
  applyMaterialOverrideToMesh(mesh, override) {
    if (override.useDepthMaterial) {
      mesh.material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
      });
      return;
    }
    if (override.useNormalMaterial) {
      mesh.material = new MeshNormalMaterial();
      return;
    }
    let material = Array.isArray(mesh.material) ? mesh.material[0].clone() : mesh.material.clone();
    if (override.wireframe !== void 0) {
      material.wireframe = override.wireframe;
    }
    if (override.wireframeColor && override.wireframe) {
      material = new MeshBasicMaterial({
        color: override.wireframeColor,
        wireframe: true
      });
    } else if (override.colorOverride) {
      material.color = new Color(override.colorOverride);
    }
    if (override.opacityOverride !== void 0) {
      material.transparent = override.opacityOverride < 1;
      material.opacity = override.opacityOverride;
    }
    if (override.flatShading !== void 0 && "flatShading" in material) {
      material.flatShading = override.flatShading;
      material.needsUpdate = true;
    }
    if (material instanceof MeshStandardMaterial) {
      if (override.metalness !== void 0) {
        material.metalness = override.metalness;
      }
      if (override.roughness !== void 0) {
        material.roughness = override.roughness;
      }
      if (override.emissive) {
        material.emissive = new Color(override.emissive);
      }
      if (override.emissiveIntensity !== void 0) {
        material.emissiveIntensity = override.emissiveIntensity;
      }
    }
    mesh.material = material;
  }
  /**
   * Restore original materials
   */
  restoreOriginalMaterials() {
    this.originalMaterials.forEach((material, mesh) => {
      mesh.material = material;
    });
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper visibility
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.modelData.showBoundingBox && this.model) {
      this.boundingBoxHelper = new BoxHelper(this.model, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  /**
   * Update skeleton helper visibility
   */
  updateSkeletonHelper() {
    if (this.skeletonHelper) {
      this.group.remove(this.skeletonHelper);
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    if (this.modelData.showSkeleton && this.model) {
      let skeleton = null;
      this.model.traverse((child) => {
        if (child instanceof SkinnedMesh && child.skeleton) {
          skeleton = child.skeleton;
        }
      });
      if (skeleton) {
        this.skeletonHelper = new SkeletonHelper(this.model);
        this.skeletonHelper.name = `skeleton_helper_${this.id}`;
        this.skeletonHelper.material.linewidth = 2;
        this.group.add(this.skeletonHelper);
      }
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set model scale
   */
  setScale(scale) {
    if (!this.model) return;
    if (typeof scale === "number") {
      this.model.scale.setScalar(scale);
    } else {
      this.model.scale.set(scale.x, scale.y, scale.z);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.modelData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  /**
   * Set skeleton visibility
   */
  setShowSkeleton(show) {
    this.modelData.showSkeleton = show;
    this.updateSkeletonHelper();
  }
  /**
   * Set FPS for animation sync
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the loaded model object
   */
  getModel() {
    return this.model;
  }
  /**
   * Get available animation clips
   */
  getAnimationClips() {
    return this.modelData.animation?.clips ?? [];
  }
  /**
   * Get model-specific bounding box data
   */
  getModelBoundingBox() {
    return this.modelData.boundingBox;
  }
  /**
   * Check if model is loading
   */
  isModelLoading() {
    return this.isLoading;
  }
  /**
   * Get load error if any
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    let scale;
    if (typeof this.modelData.scale === "object" && "value" in this.modelData.scale) {
      scale = interpolateProperty(this.modelData.scale, frame);
      this.setScale(scale);
    }
    if (this.modelData.animation?.time) {
      const time = interpolateProperty(this.modelData.animation.time, frame);
      this.setAnimationTime(time);
    }
    if (this.mixer && this.modelData.animation?.autoPlay) {
      const deltaTime = 1 / this.fps;
      this.updateAnimation(deltaTime);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["scale"] !== void 0) {
      this.setScale(props["scale"]);
    }
    if (props["animationTime"] !== void 0) {
      this.setAnimationTime(props["animationTime"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.modelData.assetId) {
        this.modelData.assetId = data.assetId;
        if (data.format) {
          this.modelData.format = data.format;
        }
        this.loadModel();
      }
      if (data.materialOverride !== void 0) {
        this.modelData.materialOverride = data.materialOverride;
        if (data.materialOverride) {
          this.applyMaterialOverride(data.materialOverride);
        } else {
          this.restoreOriginalMaterials();
        }
      }
      if (data.castShadow !== void 0 || data.receiveShadow !== void 0) {
        if (data.castShadow !== void 0) {
          this.modelData.castShadow = data.castShadow;
        }
        if (data.receiveShadow !== void 0) {
          this.modelData.receiveShadow = data.receiveShadow;
        }
        this.applyShadowSettings();
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.showSkeleton !== void 0) {
        this.setShowSkeleton(data.showSkeleton);
      }
      if (data.animation !== void 0) {
        Object.assign(this.modelData.animation ?? {}, data.animation);
        if (data.animation.activeClip) {
          this.playAnimation(data.animation.activeClip);
        }
      }
    }
  }
  onDispose() {
    this.disposeModel();
  }
  /**
   * Dispose model resources
   */
  disposeModel() {
    if (this.mixer) {
      this.mixer.stopAllAction();
      this.mixer = null;
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.skeletonHelper) {
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else {
          child.material.dispose();
        }
      }
    });
    this.originalMaterials.clear();
    this.animationClips = [];
    this.currentAction = null;
    this.model = null;
  }
}

class PointCloudLayer extends BaseLayer {
  /** The point cloud mesh */
  pointCloud = null;
  /** Point cloud geometry */
  geometry = null;
  /** Point cloud material */
  material = null;
  /** Original point data (for color mode switching) */
  originalAttributes = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  cloudData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders */
  static plyLoader = null;
  static pcdLoader = null;
  constructor(layerData) {
    super(layerData);
    this.cloudData = this.extractCloudData(layerData);
    this.initializeLoaders();
    this.loadPointCloud();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!PointCloudLayer.plyLoader) {
      PointCloudLayer.plyLoader = new PLYLoader();
    }
    if (!PointCloudLayer.pcdLoader) {
      PointCloudLayer.pcdLoader = new PCDLoader();
    }
  }
  /**
   * Extract point cloud data from layer
   */
  extractCloudData(layerData) {
    const data = layerData.data;
    const defaultPointSize = {
      id: `${layerData.id}_pointSize`,
      name: "Point Size",
      type: "number",
      value: 2,
      animated: false,
      keyframes: []
    };
    const defaultOpacity = {
      id: `${layerData.id}_opacity`,
      name: "Opacity",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "ply",
      pointCount: data?.pointCount ?? 0,
      pointSize: data?.pointSize ?? defaultPointSize,
      sizeAttenuation: data?.sizeAttenuation ?? true,
      minPointSize: data?.minPointSize ?? 1,
      maxPointSize: data?.maxPointSize ?? 64,
      colorMode: data?.colorMode ?? "rgb",
      uniformColor: data?.uniformColor ?? "#ffffff",
      colorGradient: data?.colorGradient,
      renderMode: data?.renderMode ?? "circles",
      opacity: data?.opacity ?? defaultOpacity,
      depthTest: data?.depthTest ?? true,
      depthWrite: data?.depthWrite ?? true,
      boundingBox: data?.boundingBox,
      showBoundingBox: data?.showBoundingBox ?? false,
      lod: data?.lod,
      octree: data?.octree,
      pointBudget: data?.pointBudget ?? 1e6,
      edl: data?.edl,
      clipPlanes: data?.clipPlanes,
      classificationFilter: data?.classificationFilter,
      intensityRange: data?.intensityRange
    };
  }
  /**
   * Load the point cloud from asset
   */
  async loadPointCloud() {
    if (!this.cloudData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.cloudData.assetId);
      let geometry;
      switch (this.cloudData.format) {
        case "ply":
          geometry = await this.loadPLY(url);
          break;
        case "pcd":
          geometry = await this.loadPCD(url);
          break;
        case "xyz":
        case "pts":
          geometry = await this.loadXYZ(url);
          break;
        case "las":
        case "laz":
          geometry = await this.loadLAS(url);
          break;
        default:
          throw new Error(`Unsupported point cloud format: ${this.cloudData.format}`);
      }
      this.setGeometry(geometry);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[PointCloudLayer] Failed to load point cloud: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load PLY point cloud
   */
  loadPLY(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.plyLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load PCD point cloud
   */
  loadPCD(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.pcdLoader.load(
        url,
        (points) => {
          resolve(points.geometry);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load XYZ/PTS point cloud (ASCII format)
   */
  async loadXYZ(url) {
    const response = await fetch(url);
    const text = await response.text();
    const lines = text.trim().split("\n");
    const positions = [];
    const colors = [];
    for (const line of lines) {
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        positions.push(
          parseFloat(parts[0]),
          parseFloat(parts[1]),
          parseFloat(parts[2])
        );
        if (parts.length >= 6) {
          colors.push(
            parseFloat(parts[3]) / 255,
            parseFloat(parts[4]) / 255,
            parseFloat(parts[5]) / 255
          );
        } else {
          colors.push(1, 1, 1);
        }
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Load LAS/LAZ point cloud
   * Implements basic LAS 1.2-1.4 format parsing
   */
  async loadLAS(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    const view = new DataView(buffer);
    const signature = String.fromCharCode(
      view.getUint8(0),
      view.getUint8(1),
      view.getUint8(2),
      view.getUint8(3)
    );
    if (signature !== "LASF") {
      throw new Error("Invalid LAS file: missing LASF signature");
    }
    const versionMajor = view.getUint8(24);
    const versionMinor = view.getUint8(25);
    view.getUint16(94, true);
    const offsetToPointData = view.getUint32(96, true);
    const pointDataFormat = view.getUint8(104);
    const pointDataLength = view.getUint16(105, true);
    let pointCount;
    if (versionMajor === 1 && versionMinor >= 4) {
      pointCount = Number(view.getBigUint64(247, true));
    } else {
      pointCount = view.getUint32(107, true);
    }
    const scaleX = view.getFloat64(131, true);
    const scaleY = view.getFloat64(139, true);
    const scaleZ = view.getFloat64(147, true);
    const offsetX = view.getFloat64(155, true);
    const offsetY = view.getFloat64(163, true);
    const offsetZ = view.getFloat64(171, true);
    const maxPoints = Math.min(pointCount, this.cloudData.pointBudget);
    const skipRate = Math.max(1, Math.floor(pointCount / maxPoints));
    const positions = [];
    const colors = [];
    const intensities = [];
    const classifications = [];
    const hasRGB = pointDataFormat === 2 || pointDataFormat === 3 || pointDataFormat === 7 || pointDataFormat === 8;
    let offset = offsetToPointData;
    let loadedPoints = 0;
    for (let i = 0; i < pointCount && loadedPoints < maxPoints; i++) {
      if (i % skipRate !== 0) {
        offset += pointDataLength;
        continue;
      }
      const x = view.getInt32(offset, true) * scaleX + offsetX;
      const y = view.getInt32(offset + 4, true) * scaleY + offsetY;
      const z = view.getInt32(offset + 8, true) * scaleZ + offsetZ;
      const intensity = view.getUint16(offset + 12, true);
      const classification = view.getUint8(offset + 15);
      positions.push(x, z, -y);
      intensities.push(intensity / 65535);
      classifications.push(classification);
      if (hasRGB) {
        const rgbOffset = pointDataFormat === 2 ? 20 : pointDataFormat === 3 ? 28 : pointDataFormat === 7 ? 30 : pointDataFormat === 8 ? 30 : 20;
        if (offset + rgbOffset + 6 <= buffer.byteLength) {
          const r = view.getUint16(offset + rgbOffset, true) / 65535;
          const g = view.getUint16(offset + rgbOffset + 2, true) / 65535;
          const b = view.getUint16(offset + rgbOffset + 4, true) / 65535;
          colors.push(r, g, b);
        } else {
          colors.push(1, 1, 1);
        }
      } else {
        const gray = intensity / 65535;
        colors.push(gray, gray, gray);
      }
      offset += pointDataLength;
      loadedPoints++;
    }
    console.log(`[PointCloudLayer] Loaded ${loadedPoints} points from LAS v${versionMajor}.${versionMinor} (format ${pointDataFormat})`);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.originalAttributes = {
      positions: new Float32Array(positions),
      colors: new Float32Array(colors),
      intensities: new Float32Array(intensities),
      classifications: new Uint8Array(classifications)
    };
    return geometry;
  }
  /**
   * Create placeholder geometry
   */
  createPlaceholderGeometry() {
    const positions = [];
    const colors = [];
    const size = 100;
    const count = 1e3;
    for (let i = 0; i < count; i++) {
      positions.push(
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size
      );
      colors.push(Math.random(), Math.random(), Math.random());
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Create placeholder point cloud
   */
  createPlaceholder() {
    const geometry = this.createPlaceholderGeometry();
    this.setGeometry(geometry);
  }
  /**
   * Set the point cloud geometry
   */
  setGeometry(geometry) {
    if (this.pointCloud) {
      this.group.remove(this.pointCloud);
      this.disposePointCloud();
    }
    this.geometry = geometry;
    this.storeOriginalAttributes();
    const positionAttr = geometry.getAttribute("position");
    this.cloudData.pointCount = positionAttr ? positionAttr.count : 0;
    this.createMaterial();
    this.pointCloud = new Points(this.geometry, this.material);
    this.pointCloud.name = `pointcloud_${this.id}`;
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.applyColorMode(this.cloudData.colorMode);
    this.group.add(this.pointCloud);
  }
  /**
   * Store original point attributes
   */
  storeOriginalAttributes() {
    if (!this.geometry) return;
    const position = this.geometry.getAttribute("position");
    const color = this.geometry.getAttribute("color");
    const normal = this.geometry.getAttribute("normal");
    this.originalAttributes = {
      positions: position ? new Float32Array(position.array) : new Float32Array(),
      colors: color ? new Float32Array(color.array) : void 0,
      normals: normal ? new Float32Array(normal.array) : void 0
    };
  }
  /**
   * Create point cloud material
   */
  createMaterial() {
    this.material = new ShaderMaterial({
      uniforms: {
        pointSize: { value: 2 },
        minPointSize: { value: this.cloudData.minPointSize },
        maxPointSize: { value: this.cloudData.maxPointSize },
        opacity: { value: 1 },
        sizeAttenuation: { value: this.cloudData.sizeAttenuation ? 1 : 0 },
        uniformColor: { value: new Color(this.cloudData.uniformColor) },
        useUniformColor: { value: 0 },
        heightMin: { value: 0 },
        heightMax: { value: 100 },
        gradientColors: { value: this.getGradientTexture() },
        renderMode: { value: this.getRenderModeValue() }
      },
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      transparent: true,
      depthTest: this.cloudData.depthTest,
      depthWrite: this.cloudData.depthWrite,
      vertexColors: true
    });
  }
  /**
   * Get vertex shader for point cloud rendering
   */
  getVertexShader() {
    return `
      uniform float pointSize;
      uniform float minPointSize;
      uniform float maxPointSize;
      uniform float sizeAttenuation;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vColor = color;
        vPosition = position;
        vNormal = normal;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // Size attenuation
        float size = pointSize;
        if (sizeAttenuation > 0.5) {
          size = pointSize * (300.0 / -mvPosition.z);
        }

        // Clamp size
        gl_PointSize = clamp(size, minPointSize, maxPointSize);
      }
    `;
  }
  /**
   * Get fragment shader for point cloud rendering
   */
  getFragmentShader() {
    return `
      uniform float opacity;
      uniform vec3 uniformColor;
      uniform float useUniformColor;
      uniform float renderMode;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);

        // Render mode: 0 = points, 1 = circles, 2 = squares, 3 = splats
        if (renderMode > 0.5 && renderMode < 1.5) {
          // Circle
          float dist = length(coord);
          if (dist > 0.5) discard;
        } else if (renderMode > 2.5) {
          // Gaussian splat
          float dist = length(coord);
          float alpha = exp(-dist * dist * 8.0);
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(mix(vColor, uniformColor, useUniformColor), alpha * opacity);
          return;
        }
        // Squares (mode 2) use full point

        vec3 color = mix(vColor, uniformColor, useUniformColor);
        gl_FragColor = vec4(color, opacity);
      }
    `;
  }
  /**
   * Get render mode value for shader
   */
  getRenderModeValue() {
    switch (this.cloudData.renderMode) {
      case "points":
        return 0;
      case "circles":
        return 1;
      case "squares":
        return 2;
      case "splats":
        return 3;
      default:
        return 1;
    }
  }
  /**
   * Create gradient texture for color mapping
   */
  getGradientTexture() {
    const size = 256;
    const data = new Uint8Array(size * 4);
    const stops = this.cloudData.colorGradient?.stops ?? [
      { position: 0, color: "#0000ff" },
      { position: 0.5, color: "#00ff00" },
      { position: 1, color: "#ff0000" }
    ];
    for (let i = 0; i < size; i++) {
      const t = i / (size - 1);
      let stop1 = stops[0];
      let stop2 = stops[stops.length - 1];
      for (let j = 0; j < stops.length - 1; j++) {
        if (t >= stops[j].position && t <= stops[j + 1].position) {
          stop1 = stops[j];
          stop2 = stops[j + 1];
          break;
        }
      }
      const localT = (t - stop1.position) / (stop2.position - stop1.position);
      const color1 = new Color(stop1.color);
      const color2 = new Color(stop2.color);
      const color = color1.lerp(color2, localT);
      data[i * 4] = Math.floor(color.r * 255);
      data[i * 4 + 1] = Math.floor(color.g * 255);
      data[i * 4 + 2] = Math.floor(color.b * 255);
      data[i * 4 + 3] = 255;
    }
    const texture = new DataTexture(data, size, 1, RGBAFormat);
    texture.needsUpdate = true;
    return texture;
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.geometry) return;
    this.geometry.computeBoundingBox();
    const box = this.geometry.boundingBox;
    if (!box) return;
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.cloudData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
    if (this.material) {
      this.material.uniforms.heightMin.value = box.min.y;
      this.material.uniforms.heightMax.value = box.max.y;
    }
  }
  // ============================================================================
  // COLOR MODES
  // ============================================================================
  /**
   * Apply color mode to point cloud
   */
  applyColorMode(mode) {
    if (!this.geometry || !this.material || !this.originalAttributes) return;
    this.cloudData.colorMode = mode;
    switch (mode) {
      case "rgb":
        if (this.originalAttributes.colors) {
          this.geometry.setAttribute(
            "color",
            new Float32BufferAttribute(this.originalAttributes.colors, 3)
          );
        }
        this.material.uniforms.useUniformColor.value = 0;
        break;
      case "uniform":
        this.material.uniforms.useUniformColor.value = 1;
        this.material.uniforms.uniformColor.value.set(this.cloudData.uniformColor);
        break;
      case "height":
        this.applyHeightColoring();
        break;
      case "depth":
        this.applyDepthColoring();
        break;
      case "normal":
        this.applyNormalColoring();
        break;
      case "intensity":
        this.applyIntensityColoring();
        break;
      case "classification":
        this.applyClassificationColoring();
        break;
    }
    this.geometry.attributes.color.needsUpdate = true;
  }
  /**
   * Apply height-based coloring
   */
  applyHeightColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minY = this.cloudData.boundingBox.min.y;
    const maxY = this.cloudData.boundingBox.max.y;
    const range = maxY - minY || 1;
    for (let i = 0; i < count; i++) {
      const y = positions[i * 3 + 1];
      const t = (y - minY) / range;
      const color = new Color();
      color.setHSL((1 - t) * 0.7, 1, 0.5);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply depth-based coloring (distance from camera)
   */
  applyDepthColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minZ = this.cloudData.boundingBox.min.z;
    const maxZ = this.cloudData.boundingBox.max.z;
    const range = maxZ - minZ || 1;
    for (let i = 0; i < count; i++) {
      const z = positions[i * 3 + 2];
      const t = (z - minZ) / range;
      const value = 1 - t;
      colors[i * 3] = value;
      colors[i * 3 + 1] = value;
      colors[i * 3 + 2] = value;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply normal-based coloring
   */
  applyNormalColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.normals) {
      const normals = this.originalAttributes.normals;
      const count = normals.length / 3;
      const colors = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        colors[i * 3] = normals[i * 3] * 0.5 + 0.5;
        colors[i * 3 + 1] = normals[i * 3 + 1] * 0.5 + 0.5;
        colors[i * 3 + 2] = normals[i * 3 + 2] * 0.5 + 0.5;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    } else {
      console.warn("[PointCloudLayer] No normals available for normal coloring");
      this.material.uniforms.useUniformColor.value = 1;
      this.material.uniforms.uniformColor.value.set("#8080ff");
    }
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply intensity-based coloring
   */
  applyIntensityColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.intensities) {
      const intensities = this.originalAttributes.intensities;
      const count = intensities.length;
      const colors = new Float32Array(count * 3);
      let min = Infinity, max = -Infinity;
      for (let i = 0; i < count; i++) {
        min = Math.min(min, intensities[i]);
        max = Math.max(max, intensities[i]);
      }
      if (this.cloudData.intensityRange) {
        min = Math.max(min, this.cloudData.intensityRange.min);
        max = Math.min(max, this.cloudData.intensityRange.max);
      }
      const range = max - min || 1;
      for (let i = 0; i < count; i++) {
        const t = (intensities[i] - min) / range;
        colors[i * 3] = t;
        colors[i * 3 + 1] = t;
        colors[i * 3 + 2] = t;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No intensity data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  /**
   * Apply classification-based coloring (for LAS files)
   */
  applyClassificationColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.classifications) {
      const classifications = this.originalAttributes.classifications;
      const count = classifications.length;
      const colors = new Float32Array(count * 3);
      const classColors = {
        0: [0.5, 0.5, 0.5],
        // Never classified
        1: [0.5, 0.5, 0.5],
        // Unclassified
        2: [0.6, 0.4, 0.2],
        // Ground
        3: [0.2, 0.8, 0.2],
        // Low vegetation
        4: [0.1, 0.6, 0.1],
        // Medium vegetation
        5: [0, 0.4, 0],
        // High vegetation
        6: [0.9, 0.2, 0.2],
        // Building
        7: [0.5, 0.5, 0.5],
        // Low point (noise)
        8: [0.5, 0.5, 0.5],
        // Reserved
        9: [0.2, 0.4, 0.8],
        // Water
        10: [0.8, 0.6, 0.4],
        // Rail
        11: [0.3, 0.3, 0.3],
        // Road surface
        12: [0.5, 0.5, 0.5],
        // Reserved
        13: [0.8, 0.8, 0.2],
        // Wire - Guard
        14: [0.8, 0.6, 0.2],
        // Wire - Conductor
        15: [0.9, 0.9, 0.9],
        // Transmission Tower
        16: [0.6, 0.6, 0.8],
        // Wire - Connector
        17: [0.4, 0.4, 0.6],
        // Bridge Deck
        18: [0.9, 0.1, 0.1]
        // High Noise
      };
      for (let i = 0; i < count; i++) {
        const classId = classifications[i];
        const color = classColors[classId] ?? [0.5, 0.5, 0.5];
        colors[i * 3] = color[0];
        colors[i * 3 + 1] = color[1];
        colors[i * 3 + 2] = color[2];
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No classification data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.cloudData.showBoundingBox && this.pointCloud) {
      this.boundingBoxHelper = new BoxHelper(this.pointCloud, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set point size
   */
  setPointSize(size) {
    if (this.material) {
      this.material.uniforms.pointSize.value = size;
    }
  }
  /**
   * Set opacity
   */
  setOpacity(opacity) {
    if (this.material) {
      this.material.uniforms.opacity.value = opacity;
    }
  }
  /**
   * Set uniform color
   */
  setUniformColor(color) {
    this.cloudData.uniformColor = color;
    if (this.material) {
      this.material.uniforms.uniformColor.value.set(color);
    }
  }
  /**
   * Set render mode
   */
  setRenderMode(mode) {
    this.cloudData.renderMode = mode;
    if (this.material) {
      this.material.uniforms.renderMode.value = this.getRenderModeValue();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.cloudData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get point count
   */
  getPointCount() {
    return this.cloudData.pointCount;
  }
  /**
   * Get point cloud-specific bounding box data
   */
  getPointCloudBoundingBox() {
    return this.cloudData.boundingBox;
  }
  /**
   * Check if loading
   */
  isPointCloudLoading() {
    return this.isLoading;
  }
  /**
   * Get load error
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const size = interpolateProperty(this.cloudData.pointSize, frame);
    this.setPointSize(size);
    const opacity = interpolateProperty(this.cloudData.opacity, frame);
    this.setOpacity(opacity);
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pointSize"] !== void 0) {
      this.setPointSize(props["pointSize"]);
    }
    if (props["opacity"] !== void 0) {
      this.setOpacity(props["opacity"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.cloudData.assetId) {
        this.cloudData.assetId = data.assetId;
        if (data.format) {
          this.cloudData.format = data.format;
        }
        this.loadPointCloud();
      }
      if (data.colorMode !== void 0) {
        this.applyColorMode(data.colorMode);
      }
      if (data.uniformColor !== void 0) {
        this.setUniformColor(data.uniformColor);
      }
      if (data.renderMode !== void 0) {
        this.setRenderMode(data.renderMode);
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.depthTest !== void 0 || data.depthWrite !== void 0) {
        if (this.material) {
          if (data.depthTest !== void 0) {
            this.material.depthTest = data.depthTest;
            this.cloudData.depthTest = data.depthTest;
          }
          if (data.depthWrite !== void 0) {
            this.material.depthWrite = data.depthWrite;
            this.cloudData.depthWrite = data.depthWrite;
          }
        }
      }
    }
  }
  onDispose() {
    this.disposePointCloud();
  }
  /**
   * Dispose point cloud resources
   */
  disposePointCloud() {
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.geometry) {
      this.geometry.dispose();
      this.geometry = null;
    }
    this.originalAttributes = null;
    this.pointCloud = null;
  }
}

const COLORMAPS = {
  turbo: generateTurboColormap(),
  viridis: generateViridisColormap(),
  plasma: generatePlasmaColormap(),
  inferno: generateInfernoColormap(),
  magma: generateMagmaColormap(),
  grayscale: generateGrayscaleColormap()
};
class DepthLayer extends BaseLayer {
  mesh = null;
  material = null;
  texture = null;
  depthData;
  colormapTexture = null;
  constructor(layerData) {
    super(layerData);
    this.depthData = this.extractDepthData(layerData);
    this.createMesh();
  }
  /**
   * Extract depth layer data from layer object
   */
  extractDepthData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      visualizationMode: data?.visualizationMode ?? "colormap",
      colorMap: data?.colorMap ?? "turbo",
      invert: data?.invert ?? false,
      minDepth: data?.minDepth ?? 0,
      maxDepth: data?.maxDepth ?? 1,
      autoNormalize: data?.autoNormalize ?? true,
      contourLevels: data?.contourLevels ?? 10,
      contourColor: data?.contourColor ?? "#ffffff",
      contourWidth: data?.contourWidth ?? 1,
      meshDisplacement: data?.meshDisplacement ?? createAnimatableProperty("Mesh Displacement", 50, "number"),
      meshResolution: data?.meshResolution ?? 64,
      wireframe: data?.wireframe ?? false
    };
  }
  createMesh() {
    const geometry = new PlaneGeometry(1, 1, 1, 1);
    this.material = new ShaderMaterial({
      uniforms: {
        depthMap: { value: null },
        colormap: { value: null },
        invert: { value: this.depthData.invert ? 1 : 0 },
        minDepth: { value: this.depthData.minDepth },
        maxDepth: { value: this.depthData.maxDepth },
        opacity: { value: 1 },
        contourLevels: { value: this.depthData.contourLevels || 10 },
        contourColor: { value: new Color(this.depthData.contourColor || "#ffffff") },
        contourWidth: { value: this.depthData.contourWidth || 1 },
        visualizationMode: { value: this.getVisualizationModeIndex() }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D depthMap;
        uniform sampler2D colormap;
        uniform float invert;
        uniform float minDepth;
        uniform float maxDepth;
        uniform float opacity;
        uniform float contourLevels;
        uniform vec3 contourColor;
        uniform float contourWidth;
        uniform int visualizationMode;

        varying vec2 vUv;

        void main() {
          float depth = texture2D(depthMap, vUv).r;

          // Normalize depth to 0-1 range
          float normalizedDepth = (depth - minDepth) / (maxDepth - minDepth);
          normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);

          // Invert if needed
          if (invert > 0.5) {
            normalizedDepth = 1.0 - normalizedDepth;
          }

          vec3 color;

          if (visualizationMode == 0) {
            // Grayscale
            color = vec3(normalizedDepth);
          } else if (visualizationMode == 1) {
            // Colormap
            color = texture2D(colormap, vec2(normalizedDepth, 0.5)).rgb;
          } else if (visualizationMode == 2) {
            // Contour
            float contourValue = fract(normalizedDepth * contourLevels);
            float contourLine = smoothstep(0.0, contourWidth * 0.1, contourValue) *
                               smoothstep(contourWidth * 0.1, 0.0, contourValue - (1.0 - contourWidth * 0.1));
            color = mix(texture2D(colormap, vec2(normalizedDepth, 0.5)).rgb, contourColor, contourLine);
          } else {
            // Default to grayscale
            color = vec3(normalizedDepth);
          }

          gl_FragColor = vec4(color, opacity);
        }
      `,
      transparent: true
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `depth_${this.id}`;
    this.group.add(this.mesh);
    this.updateColormapTexture();
  }
  getVisualizationModeIndex() {
    switch (this.depthData.visualizationMode) {
      case "grayscale":
        return 0;
      case "colormap":
        return 1;
      case "contour":
        return 2;
      case "3d-mesh":
        return 3;
      default:
        return 0;
    }
  }
  updateColormapTexture() {
    const colors = COLORMAPS[this.depthData.colorMap] || COLORMAPS.grayscale;
    const data = new Uint8Array(256 * 4);
    for (let i = 0; i < 256; i++) {
      const color = colors[i];
      data[i * 4] = Math.floor(color.r * 255);
      data[i * 4 + 1] = Math.floor(color.g * 255);
      data[i * 4 + 2] = Math.floor(color.b * 255);
      data[i * 4 + 3] = 255;
    }
    if (this.colormapTexture) {
      this.colormapTexture.dispose();
    }
    this.colormapTexture = new DataTexture(data, 256, 1, RGBAFormat);
    this.colormapTexture.needsUpdate = true;
    if (this.material) {
      this.material.uniforms.colormap.value = this.colormapTexture;
    }
  }
  setTexture(texture) {
    this.texture = texture;
    if (this.material) {
      this.material.uniforms.depthMap.value = texture;
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.material) return;
    if (this.depthData.meshDisplacement && this.depthData.visualizationMode === "3d-mesh") {
      interpolateProperty(this.depthData.meshDisplacement, frame);
    }
    this.material.uniforms.invert.value = this.depthData.invert ? 1 : 0;
    this.material.uniforms.minDepth.value = this.depthData.minDepth;
    this.material.uniforms.maxDepth.value = this.depthData.maxDepth;
    this.material.uniforms.visualizationMode.value = this.getVisualizationModeIndex();
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      Object.assign(this.depthData, data);
      if (data.colorMap) {
        this.updateColormapTexture();
      }
      if (this.material) {
        if (data.contourColor) {
          this.material.uniforms.contourColor.value = new Color(data.contourColor);
        }
        if (data.contourLevels !== void 0) {
          this.material.uniforms.contourLevels.value = data.contourLevels;
        }
        if (data.contourWidth !== void 0) {
          this.material.uniforms.contourWidth.value = data.contourWidth;
        }
      }
    }
  }
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
    }
    if (this.colormapTexture) {
      this.colormapTexture.dispose();
    }
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
    }
  }
}
function generateTurboColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    const r = Math.sin(t * Math.PI * 1.5) * 0.5 + 0.5;
    const g = Math.sin(t * Math.PI * 2 - 0.5) * 0.5 + 0.5;
    const b = Math.cos(t * Math.PI * 1.5) * 0.5 + 0.5;
    colors.push(new Color(r, g, b));
  }
  return colors;
}
function generateViridisColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    const r = 0.267004 + t * (0.993248 - 0.267004);
    const g = 4874e-6 + t * (0.906157 - 4874e-6);
    const b = 0.329415 + t * (0.143936 - 0.329415);
    colors.push(new Color(
      Math.max(0, Math.min(1, r)),
      Math.max(0, Math.min(1, g)),
      Math.max(0, Math.min(1, b))
    ));
  }
  return colors;
}
function generatePlasmaColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    const r = 0.050383 + t * (0.940015 - 0.050383);
    const g = 0.029803 + t * (0.975158 - 0.029803);
    const b = 0.527975 + t * (0.131326 - 0.527975);
    colors.push(new Color(
      Math.max(0, Math.min(1, r)),
      Math.max(0, Math.min(1, g)),
      Math.max(0, Math.min(1, b))
    ));
  }
  return colors;
}
function generateInfernoColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    const r = t < 0.5 ? t * 2 : 1;
    const g = t < 0.5 ? t * 0.5 : (t - 0.5) * 2;
    const b = t < 0.25 ? t * 2 : t < 0.75 ? 0.5 - (t - 0.25) : 0;
    colors.push(new Color(r, g, b));
  }
  return colors;
}
function generateMagmaColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    const r = t;
    const g = t * t;
    const b = t < 0.5 ? t * 1.5 : 0.75 - (t - 0.5) * 0.5;
    colors.push(new Color(r, g, Math.max(0, b)));
  }
  return colors;
}
function generateGrayscaleColormap() {
  const colors = [];
  for (let i = 0; i < 256; i++) {
    const t = i / 255;
    colors.push(new Color(t, t, t));
  }
  return colors;
}

class NormalLayer extends BaseLayer {
  mesh = null;
  material = null;
  texture = null;
  normalData;
  constructor(layerData) {
    super(layerData);
    this.normalData = this.extractNormalData(layerData);
    this.createMesh();
  }
  /**
   * Extract normal layer data from layer object
   */
  extractNormalData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      visualizationMode: data?.visualizationMode ?? "rgb",
      format: data?.format ?? "opengl",
      flipX: data?.flipX ?? false,
      flipY: data?.flipY ?? false,
      flipZ: data?.flipZ ?? false,
      arrowDensity: data?.arrowDensity ?? 16,
      arrowScale: data?.arrowScale ?? 1,
      arrowColor: data?.arrowColor ?? "#00ff00",
      lightDirection: data?.lightDirection ?? { x: 0.5, y: 0.5, z: 1 },
      lightIntensity: data?.lightIntensity ?? 1,
      ambientIntensity: data?.ambientIntensity ?? 0.2
    };
  }
  createMesh() {
    const geometry = new PlaneGeometry(1, 1, 1, 1);
    this.material = new ShaderMaterial({
      uniforms: {
        normalMap: { value: null },
        flipX: { value: this.normalData.flipX ? -1 : 1 },
        flipY: { value: this.normalData.flipY ? -1 : 1 },
        flipZ: { value: this.normalData.flipZ ? -1 : 1 },
        lightDirection: { value: new Vector3(
          this.normalData.lightDirection?.x || 0.5,
          this.normalData.lightDirection?.y || 0.5,
          this.normalData.lightDirection?.z || 1
        ).normalize() },
        lightIntensity: { value: this.normalData.lightIntensity || 1 },
        ambientIntensity: { value: this.normalData.ambientIntensity || 0.2 },
        opacity: { value: 1 },
        visualizationMode: { value: this.getVisualizationModeIndex() },
        isDirectX: { value: this.normalData.format === "directx" ? 1 : 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D normalMap;
        uniform float flipX;
        uniform float flipY;
        uniform float flipZ;
        uniform vec3 lightDirection;
        uniform float lightIntensity;
        uniform float ambientIntensity;
        uniform float opacity;
        uniform int visualizationMode;
        uniform float isDirectX;

        varying vec2 vUv;

        void main() {
          vec3 normal = texture2D(normalMap, vUv).rgb * 2.0 - 1.0;

          // Apply flips
          normal.x *= flipX;
          normal.y *= flipY;
          normal.z *= flipZ;

          // Convert DirectX normals to OpenGL if needed
          if (isDirectX > 0.5) {
            normal.y = -normal.y;
          }

          normal = normalize(normal);

          vec3 color;

          if (visualizationMode == 0) {
            // RGB - direct normal visualization
            color = normal * 0.5 + 0.5;
          } else if (visualizationMode == 1) {
            // Hemisphere - hemisphere colorization
            color = vec3(
              normal.x * 0.5 + 0.5,
              normal.y * 0.5 + 0.5,
              max(0.0, normal.z)
            );
          } else if (visualizationMode == 3) {
            // Lit - fake lighting preview
            float diffuse = max(0.0, dot(normal, lightDirection));
            color = vec3(ambientIntensity + diffuse * lightIntensity);
          } else {
            // Default to RGB
            color = normal * 0.5 + 0.5;
          }

          gl_FragColor = vec4(color, opacity);
        }
      `,
      transparent: true
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `normal_${this.id}`;
    this.group.add(this.mesh);
  }
  getVisualizationModeIndex() {
    switch (this.normalData.visualizationMode) {
      case "rgb":
        return 0;
      case "hemisphere":
        return 1;
      case "arrows":
        return 2;
      case "lit":
        return 3;
      default:
        return 0;
    }
  }
  setTexture(texture) {
    this.texture = texture;
    if (this.material) {
      this.material.uniforms.normalMap.value = texture;
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.material) return;
    this.material.uniforms.flipX.value = this.normalData.flipX ? -1 : 1;
    this.material.uniforms.flipY.value = this.normalData.flipY ? -1 : 1;
    this.material.uniforms.flipZ.value = this.normalData.flipZ ? -1 : 1;
    this.material.uniforms.visualizationMode.value = this.getVisualizationModeIndex();
    this.material.uniforms.isDirectX.value = this.normalData.format === "directx" ? 1 : 0;
    if (this.normalData.lightDirection) {
      this.material.uniforms.lightDirection.value.set(
        this.normalData.lightDirection.x,
        this.normalData.lightDirection.y,
        this.normalData.lightDirection.z
      ).normalize();
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      Object.assign(this.normalData, data);
    }
  }
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
    }
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
    }
  }
}

class AudioLayer extends BaseLayer {
  audioData;
  iconGroup = null;
  constructor(layerData) {
    super(layerData);
    this.audioData = this.extractAudioData(layerData);
    this.createIconMesh();
  }
  /**
   * Extract audio layer data from layer object
   */
  extractAudioData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      level: data?.level ?? createAnimatableProperty("Level", 0, "number"),
      muted: data?.muted ?? false,
      solo: data?.solo ?? false,
      pan: data?.pan ?? createAnimatableProperty("Pan", 0, "number"),
      loop: data?.loop ?? false,
      startTime: data?.startTime ?? 0,
      speed: data?.speed ?? 1,
      showWaveform: data?.showWaveform ?? true,
      waveformColor: data?.waveformColor ?? "#4a90d9",
      exposeFeatures: data?.exposeFeatures ?? false
    };
  }
  /**
   * Create a visual indicator for the audio layer in the viewport
   * (speaker icon or waveform representation)
   */
  createIconMesh() {
    this.iconGroup = new Group();
    const bodyGeometry = new BoxGeometry(20, 30, 5);
    const bodyMaterial = new MeshBasicMaterial({
      color: 4886745,
      transparent: true,
      opacity: 0.8
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    this.iconGroup.add(body);
    const waveMaterial = new LineBasicMaterial({ color: 4886745, transparent: true, opacity: 0.6 });
    for (let i = 0; i < 3; i++) {
      const curve = new EllipseCurve(
        15,
        0,
        10 + i * 8,
        15 + i * 5,
        -Math.PI / 3,
        Math.PI / 3,
        false,
        0
      );
      const points = curve.getPoints(20);
      const geometry = new BufferGeometry().setFromPoints(
        points.map((p) => new Vector3(p.x, p.y, 0))
      );
      const wave = new Line(geometry, waveMaterial);
      this.iconGroup.add(wave);
    }
    this.iconGroup.name = `audio_icon_${this.id}`;
    this.group.add(this.iconGroup);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.audioData.level) {
      interpolateProperty(this.audioData.level, frame);
    }
    if (this.audioData.pan) {
      interpolateProperty(this.audioData.pan, frame);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      Object.assign(this.audioData, data);
    }
  }
  onDispose() {
    if (this.iconGroup) {
      this.iconGroup.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          if (child.material instanceof Material) {
            child.material.dispose();
          }
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          if (child.material instanceof Material) {
            child.material.dispose();
          }
        }
      });
    }
  }
  // ============================================================================
  // AUDIO-SPECIFIC METHODS
  // ============================================================================
  /**
   * Get the audio position for a given frame
   * Used for deterministic audio sync
   */
  getAudioTimeForFrame(frame, fps) {
    const layerTime = frame / fps;
    const audioTime = (layerTime - this.audioData.startTime) * this.audioData.speed;
    return Math.max(0, audioTime);
  }
  /**
   * Check if audio should be playing at given frame
   */
  isPlayingAtFrame(frame, fps) {
    if (this.audioData.muted) return false;
    const audioTime = this.getAudioTimeForFrame(frame, fps);
    if (audioTime < 0) return false;
    if (this.audioData.loop) return true;
    return true;
  }
}

class GeneratedLayer extends BaseLayer {
  mesh = null;
  material = null;
  texture = null;
  generatedData;
  statusIndicator = null;
  constructor(layerData) {
    super(layerData);
    this.generatedData = this.extractGeneratedData(layerData);
    this.createMesh();
  }
  /**
   * Extract generated layer data from layer object
   */
  extractGeneratedData(layerData) {
    const data = layerData.data;
    return {
      generationType: data?.generationType ?? "depth",
      sourceLayerId: data?.sourceLayerId ?? null,
      model: data?.model ?? "depth-anything-v2",
      parameters: data?.parameters ?? {},
      generatedAssetId: data?.generatedAssetId ?? null,
      status: data?.status ?? "pending",
      autoRegenerate: data?.autoRegenerate ?? false,
      lastGenerated: data?.lastGenerated,
      errorMessage: data?.errorMessage
    };
  }
  createMesh() {
    const geometry = new PlaneGeometry(1, 1, 1, 1);
    this.material = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      opacity: 1,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `generated_${this.id}`;
    this.group.add(this.mesh);
    this.createStatusIndicator();
  }
  createStatusIndicator() {
    const geometry = new CircleGeometry(10, 16);
    const material = new MeshBasicMaterial({
      color: this.getStatusColor(),
      transparent: true,
      opacity: 0.8
    });
    this.statusIndicator = new Mesh(geometry, material);
    this.statusIndicator.position.set(-50, 50, 1);
    this.statusIndicator.name = `status_${this.id}`;
    this.group.add(this.statusIndicator);
  }
  getStatusColor() {
    switch (this.generatedData.status) {
      case "pending":
        return 16755200;
      case "generating":
        return 43775;
      case "complete":
        return 65280;
      case "error":
        return 16711680;
      default:
        return 8947848;
    }
  }
  setTexture(texture) {
    this.texture = texture;
    if (this.material) {
      this.material.map = texture;
      this.material.needsUpdate = true;
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.statusIndicator) {
      this.statusIndicator.material.color.setHex(this.getStatusColor());
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      const oldSourceId = this.generatedData.sourceLayerId;
      Object.assign(this.generatedData, data);
      if (this.generatedData.autoRegenerate && data.sourceLayerId !== void 0 && data.sourceLayerId !== oldSourceId) {
        this.regenerate();
      }
    }
  }
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
    }
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
    }
    if (this.statusIndicator) {
      this.statusIndicator.material.dispose();
      this.statusIndicator.geometry.dispose();
    }
  }
  // ============================================================================
  // GENERATION-SPECIFIC METHODS
  // ============================================================================
  /**
   * Trigger regeneration of the content
   */
  async regenerate() {
    this.generatedData.status = "generating";
    try {
      this.generatedData.status = "complete";
      this.generatedData.lastGenerated = (/* @__PURE__ */ new Date()).toISOString();
    } catch (error) {
      this.generatedData.status = "error";
      this.generatedData.errorMessage = error instanceof Error ? error.message : "Unknown error";
    }
  }
}

class GroupLayer extends BaseLayer {
  groupData;
  boundingBox = null;
  labelMesh = null;
  constructor(layerData) {
    super(layerData);
    this.groupData = this.extractGroupData(layerData);
    this.createVisuals();
  }
  /**
   * Extract group layer data from layer object
   */
  extractGroupData(layerData) {
    const data = layerData.data;
    return {
      collapsed: data?.collapsed ?? false,
      color: data?.color ?? "#888888",
      passThrough: data?.passThrough ?? true,
      isolate: data?.isolate ?? false
    };
  }
  createVisuals() {
    this.createBoundingBox();
    this.createLabel();
  }
  createBoundingBox() {
    const geometry = new BufferGeometry();
    const positions = new Float32Array([
      -50,
      -50,
      0,
      50,
      -50,
      0,
      50,
      -50,
      0,
      50,
      50,
      0,
      50,
      50,
      0,
      -50,
      50,
      0,
      -50,
      50,
      0,
      -50,
      -50,
      0
    ]);
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const material = new LineDashedMaterial({
      color: this.getGroupColor(),
      dashSize: 5,
      gapSize: 3,
      transparent: true,
      opacity: 0.5
    });
    this.boundingBox = new LineSegments(geometry, material);
    this.boundingBox.computeLineDistances();
    this.boundingBox.name = `group_bounds_${this.id}`;
    this.group.add(this.boundingBox);
  }
  createLabel() {
    const geometry = new PlaneGeometry(20, 20);
    const material = new MeshBasicMaterial({
      color: this.getGroupColor(),
      transparent: true,
      opacity: 0.7
    });
    this.labelMesh = new Mesh(geometry, material);
    this.labelMesh.position.set(-40, 40, 0);
    this.labelMesh.name = `group_label_${this.id}`;
    this.group.add(this.labelMesh);
  }
  getGroupColor() {
    if (this.groupData.color) {
      return parseInt(this.groupData.color.replace("#", ""), 16);
    }
    return 8947848;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.boundingBox) {
      const material = this.boundingBox.material;
      material.color.setHex(this.getGroupColor());
    }
    if (this.labelMesh) {
      const material = this.labelMesh.material;
      material.color.setHex(this.getGroupColor());
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      Object.assign(this.groupData, data);
    }
  }
  onDispose() {
    if (this.boundingBox) {
      this.boundingBox.geometry.dispose();
      this.boundingBox.material.dispose();
    }
    if (this.labelMesh) {
      this.labelMesh.geometry.dispose();
      this.labelMesh.material.dispose();
    }
  }
  // ============================================================================
  // GROUP-SPECIFIC METHODS
  // ============================================================================
  /**
   * Update the group's bounding box based on child layer bounds
   */
  updateBoundsFromChildren(childBounds) {
    if (!this.boundingBox) return;
    const size = childBounds.getSize(new Vector3());
    const center = childBounds.getCenter(new Vector3());
    const halfX = size.x / 2;
    const halfY = size.y / 2;
    const positions = new Float32Array([
      -halfX,
      -halfY,
      0,
      halfX,
      -halfY,
      0,
      halfX,
      -halfY,
      0,
      halfX,
      halfY,
      0,
      halfX,
      halfY,
      0,
      -halfX,
      halfY,
      0,
      -halfX,
      halfY,
      0,
      -halfX,
      -halfY,
      0
    ]);
    this.boundingBox.geometry.setAttribute("position", new BufferAttribute(positions, 3));
    this.boundingBox.geometry.attributes.position.needsUpdate = true;
    this.boundingBox.computeLineDistances();
    this.boundingBox.position.copy(center);
  }
  /**
   * Check if group is in pass-through mode
   * In pass-through, group doesn't create intermediate composite
   */
  isPassThrough() {
    return this.groupData.passThrough;
  }
  /**
   * Check if group is isolated (only show group contents)
   */
  isIsolated() {
    return this.groupData.isolate;
  }
  /**
   * Check if group is collapsed in timeline
   */
  isCollapsed() {
    return this.groupData.collapsed;
  }
  /**
   * Toggle collapsed state
   */
  toggleCollapsed() {
    this.groupData.collapsed = !this.groupData.collapsed;
  }
}

class LayerManager {
  scene;
  resources;
  layers;
  // Callbacks
  onVideoMetadataLoaded;
  nestedCompRenderContext = null;
  effectLayerRenderContext = null;
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Renderer reference for particle systems
  rendererRef = null;
  // Composition FPS for particle timing
  compositionFPS = 60;
  // Camera reference for particles
  cameraRef = null;
  // Audio reactive callback
  audioReactiveGetter = null;
  // Matte canvas cache - stores rendered canvases for layers used as matte sources
  matteCanvases = /* @__PURE__ */ new Map();
  // Ordered layer list for render order (respects track matte dependencies)
  renderOrder = [];
  // Callback to get cross-composition matte canvas
  crossCompMatteGetter = null;
  constructor(scene, resources) {
    this.scene = scene;
    this.resources = resources;
    this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(callback) {
    this.onVideoMetadataLoaded = callback;
  }
  /**
   * Set the nested comp render context
   * This allows nested comp layers to render nested compositions
   */
  setNestedCompRenderContext(context) {
    this.nestedCompRenderContext = context;
    for (const layer of this.layers.values()) {
      if (layer.type === "nestedComp") {
        layer.setRenderContext(context);
      }
    }
  }
  /**
   * Set the effect layer render context
   * This allows effect layers to render layers below them
   */
  setEffectLayerRenderContext(context) {
    this.effectLayerRenderContext = context;
    for (const layer of this.layers.values()) {
      const layerData = layer.layerData;
      if (layer.type === "solid" && (layerData?.effectLayer || layerData?.adjustmentLayer)) {
        layer.setRenderContext(context);
      }
    }
  }
  /** @deprecated Use setEffectLayerRenderContext instead */
  setAdjustmentRenderContext(context) {
    this.setEffectLayerRenderContext(context);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
    for (const layer of this.layers.values()) {
      if (layer.type === "camera") {
        layer.setCameraCallbacks(getter, updater, atFrameGetter);
      }
    }
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setRenderer(renderer);
      }
    }
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(fps) {
    this.compositionFPS = fps;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setFPS(fps);
      }
      if (layer.type === "video") {
        layer.setFPS(fps);
      }
      if (layer.type === "nestedComp") {
        layer.setFPS(fps);
      }
    }
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(camera) {
    this.cameraRef = camera;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(layerData) {
    if (this.layers.has(layerData.id)) {
      layerLogger.warn(`LayerManager: Layer ${layerData.id} already exists, updating instead`);
      this.update(layerData.id, layerData);
      return this.layers.get(layerData.id);
    }
    const layer = this.createLayerInstance(layerData);
    this.layers.set(layerData.id, layer);
    this.setupLayerCallbacks(layer, layerData);
    if (layerData.parentId) {
      const parentLayer = this.layers.get(layerData.parentId);
      if (parentLayer) {
        layer.setParent(parentLayer);
      }
    }
    if (!layer.hasParent()) {
      this.scene.addToComposition(layer.getObject());
    }
    return layer;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(layer, layerData) {
    if (layer.type === "video" && this.onVideoMetadataLoaded) {
      const videoLayer = layer;
      videoLayer.setMetadataCallback((metadata) => {
        this.onVideoMetadataLoaded(layerData.id, metadata);
      });
    }
    if (layer.type === "nestedComp" && this.nestedCompRenderContext) {
      const nestedCompLayer = layer;
      nestedCompLayer.setRenderContext(this.nestedCompRenderContext);
    }
    if (layer.type === "camera" && this.cameraGetter && this.cameraUpdater) {
      const cameraLayer = layer;
      cameraLayer.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter);
      cameraLayer.setSplineProvider(this.createSplineProvider());
    }
    if (layer.type === "particles") {
      const particleLayer = layer;
      if (this.rendererRef) {
        particleLayer.setRenderer(this.rendererRef);
      }
      particleLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "video") {
      const videoLayer = layer;
      videoLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "nestedComp") {
      const nestedCompLayer = layer;
      nestedCompLayer.setFPS(this.compositionFPS);
    }
    if ((layerData.effectLayer || layerData.adjustmentLayer) && this.effectLayerRenderContext) {
      if ("setRenderContext" in layer) {
        layer.setRenderContext(this.effectLayerRenderContext);
      }
    }
    if (layer.type === "light") {
      const lightLayer = layer;
      lightLayer.setLayerPositionGetter((layerId) => {
        const targetLayer = this.layers.get(layerId);
        if (targetLayer) {
          const obj = targetLayer.getObject();
          return new Vector3(obj.position.x, obj.position.y, obj.position.z);
        }
        return null;
      });
      lightLayer.setPathProvider(this.createSplineProvider());
    }
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(layerData) {
    switch (layerData.type) {
      case "image":
        return new ImageLayer(layerData, this.resources);
      case "solid":
        return new SolidLayer(layerData);
      case "control":
      case "null":
        return new ControlLayer(layerData);
      case "text":
        return new TextLayer(layerData, this.resources);
      case "spline":
        return new SplineLayer(layerData);
      case "path":
        return new PathLayer(layerData);
      case "particles":
        return new ParticleLayer(layerData);
      case "video":
        return new VideoLayer(layerData, this.resources);
      case "nestedComp":
        return new NestedCompLayer(layerData);
      case "camera":
        return new CameraLayer(layerData);
      case "light":
        return new LightLayer(layerData);
      case "depthflow":
        return new DepthflowLayer(layerData, this.resources);
      case "matte":
        return new ProceduralMatteLayer(layerData);
      case "shape":
        return new ShapeLayer(layerData);
      case "model":
        return new ModelLayer(layerData);
      case "pointcloud":
        return new PointCloudLayer(layerData);
      case "depth":
        return new DepthLayer(layerData);
      case "normal":
        return new NormalLayer(layerData);
      case "audio":
        return new AudioLayer(layerData);
      case "generated":
        return new GeneratedLayer(layerData);
      case "group":
        return new GroupLayer(layerData);
      case "particle":
        layerLogger.info("LayerManager: Legacy particle type, using ParticleLayer");
        return new ParticleLayer(layerData);
      default:
        layerLogger.warn(`LayerManager: Unknown layer type: ${layerData.type}, creating ControlLayer`);
        return new ControlLayer(layerData);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(layerId, properties) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for update`);
      return;
    }
    layer.update(properties);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(updates) {
    for (const { id, properties } of updates) {
      this.update(id, properties);
    }
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(layerId) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(layer.getObject());
    layer.dispose();
    this.layers.delete(layerId);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(layerIds) {
    for (const id of layerIds) {
      this.remove(id);
    }
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [id, layer] of this.layers) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer state.
   * Layers receive already-computed values and only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * Rendering order:
   * 1. Spline layers (for text-on-path dependencies)
   * 2. Text-on-path connections
   * 3. Track matte source layers (render to canvas)
   * 4. All other layers (with track mattes applied)
   *
   * @param evaluatedLayers - Pre-evaluated layer states from MotionEngine
   * @param frame - Optional frame number for animated spline/mask evaluation
   */
  applyEvaluatedState(evaluatedLayers, frame) {
    const currentFrame = frame ?? 0;
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && (layer.type === "spline" || layer.type === "path")) {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.updateTextPathConnections(frame);
    this.processTrackMattes(currentFrame);
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type !== "spline" && layer.type !== "path") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.scene.sortByZ();
  }
  /**
   * Evaluate all layers at a given frame
   *
   * @deprecated Use applyEvaluatedState() with pre-evaluated state from MotionEngine.
   * This method causes layers to internally call interpolateProperty(), violating
   * the single-source-of-truth principle.
   *
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(frame, audioReactiveGetter) {
    this.updateTextPathConnections(frame);
    this.processTrackMattes(frame);
    const getter = audioReactiveGetter ?? this.audioReactiveGetter;
    for (const layer of this.layers.values()) {
      if (getter) {
        const audioValues = getter(layer.id, frame);
        if (audioValues.size > 0) {
          layer.setAudioReactiveValues(audioValues);
        }
      }
      layer.evaluateFrame(frame);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setDrivenValues(values);
    }
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const layer of this.layers.values()) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Update text layer connections to spline/path layers
   * Called before frame evaluation to ensure paths are current
   *
   * For animated splines/paths, this must be called with the current frame
   * to get properly evaluated control points.
   *
   * Supports both 'spline' and 'path' layer types.
   *
   * @param frame - Optional frame number for animated spline/path evaluation
   */
  updateTextPathConnections(frame) {
    for (const layer of this.layers.values()) {
      if (layer.type === "text") {
        const textLayer = layer;
        const textData = textLayer.getTextData();
        if (textData.pathLayerId) {
          const pathSourceLayer = this.layers.get(textData.pathLayerId);
          if (pathSourceLayer && (pathSourceLayer.type === "spline" || pathSourceLayer.type === "path")) {
            const pathLayer = pathSourceLayer;
            if (pathLayer.isAnimated() && frame !== void 0) {
              const evaluatedPoints = pathLayer.getEvaluatedControlPoints(frame);
              const controlPoints = evaluatedPoints.map((ep) => ({
                id: ep.id,
                x: ep.x,
                y: ep.y,
                depth: ep.depth,
                handleIn: ep.handleIn,
                handleOut: ep.handleOut,
                type: ep.type
              }));
              textLayer.setPathFromControlPoints(controlPoints, pathLayer.isClosed());
            } else {
              const curve = pathLayer.getCurve();
              if (curve) {
                textLayer.setPathFromCurve(curve);
              }
            }
          }
        }
      }
    }
  }
  // ============================================================================
  // SPLINE PATH PROVIDER (for Particle Systems)
  // ============================================================================
  /**
   * Create a SplinePathProvider that can be used by particle systems
   * to query spline positions for path-based emission
   *
   * USAGE:
   * ```typescript
   * const provider = layerManager.createSplineProvider();
   * particleSystem.setSplineProvider(provider);
   * ```
   */
  createSplineProvider() {
    return (layerId, t, frame) => {
      return this.querySplinePath(layerId, t, frame);
    };
  }
  /**
   * Query a spline/path layer for position and tangent at parameter t
   *
   * Supports both 'spline' and 'path' layer types.
   *
   * @param layerId - ID of the spline or path layer
   * @param t - Parameter along the path (0-1)
   * @param frame - Current frame for animated paths
   * @returns Position, tangent, and length or null if layer not found
   */
  querySplinePath(layerId, t, frame) {
    const layer = this.layers.get(layerId);
    if (!layer || layer.type !== "spline" && layer.type !== "path") {
      return null;
    }
    const pathLayer = layer;
    if (pathLayer.isAnimated()) {
      pathLayer.getEvaluatedControlPoints(frame);
    }
    const point = pathLayer.getPointAt(t);
    const tangent = pathLayer.getTangentAt(t);
    const length = pathLayer.getLength();
    if (!point || !tangent) {
      return null;
    }
    return {
      point: {
        x: point.x,
        y: -point.y,
        // Negate back from Three.js coordinate system
        z: point.z
      },
      tangent: {
        x: tangent.x,
        y: -tangent.y
        // Negate back
      },
      length
    };
  }
  /**
   * Get all spline and path layer IDs (useful for UI to list available paths)
   * Returns both 'spline' and 'path' layer types since both can be used as paths.
   */
  getSplineLayerIds() {
    const ids = [];
    for (const [id, layer] of this.layers) {
      if (layer.type === "spline" || layer.type === "path") {
        ids.push(id);
      }
    }
    return ids;
  }
  /**
   * Get all path layer IDs only (invisible motion paths)
   */
  getPathLayerIds() {
    const ids = [];
    for (const [id, layer] of this.layers) {
      if (layer.type === "path") {
        ids.push(id);
      }
    }
    return ids;
  }
  /**
   * Connect a text layer to a spline or path layer
   * Supports both 'spline' and 'path' layer types.
   */
  connectTextToPath(textLayerId, pathLayerId) {
    const textLayer = this.layers.get(textLayerId);
    if (!textLayer || textLayer.type !== "text") {
      layerLogger.warn(`LayerManager: Text layer ${textLayerId} not found`);
      return;
    }
    if (!pathLayerId) {
      textLayer.clearPath();
      return;
    }
    const pathSourceLayer = this.layers.get(pathLayerId);
    if (!pathSourceLayer || pathSourceLayer.type !== "spline" && pathSourceLayer.type !== "path") {
      layerLogger.warn(`LayerManager: Spline/path layer ${pathLayerId} not found`);
      return;
    }
    const pathLayer = pathSourceLayer;
    const curve = pathLayer.getCurve();
    if (curve) {
      textLayer.setPathFromCurve(curve);
    }
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(layerId) {
    return this.layers.get(layerId)?.getObject() ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(layerId) {
    return this.layers.get(layerId) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(type) {
    return Array.from(this.layers.values()).filter(
      (layer) => layer.type === type
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(layerId) {
    return this.layers.has(layerId);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  /**
   * Get all layers as an array
   */
  getAllLayers() {
    return Array.from(this.layers.values());
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const layer of this.layers.values()) {
      if (layer.hasParent()) {
        const parent = layer.getParent();
        if (parent) {
          parent.getObject().remove(layer.getObject());
        }
      }
    }
    for (const layer of this.layers.values()) {
      const parentId = layer.getParentId();
      if (parentId) {
        const parentLayer = this.layers.get(parentId);
        if (parentLayer) {
          layer.setParent(parentLayer);
        } else {
          layer.setParent(null);
          this.scene.addToComposition(layer.getObject());
        }
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(layerId, parentId) {
    const layer = this.layers.get(layerId);
    if (!layer) return;
    if (layer.hasParent()) {
      const oldParent = layer.getParent();
      if (oldParent) {
        oldParent.getObject().remove(layer.getObject());
      }
    } else {
      this.scene.removeFromComposition(layer.getObject());
    }
    if (parentId) {
      const newParent = this.layers.get(parentId);
      if (newParent) {
        layer.setParent(newParent);
      } else {
        layer.setParent(null);
        this.scene.addToComposition(layer.getObject());
      }
    } else {
      layer.setParent(null);
      this.scene.addToComposition(layer.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(layerId, z) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.getObject().position.z = z;
      this.scene.sortByZ();
    }
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(layerId, visible) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setVisible(visible);
    }
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      const newVisible = !layer.getObject().visible;
      layer.setVisible(newVisible);
      return newVisible;
    }
    return false;
  }
  /**
   * Isolate a layer (hide all others)
   */
  isolateLayer(layerId) {
    for (const [id, layer] of this.layers) {
      layer.setVisible(id === layerId);
    }
  }
  /** @deprecated Use isolateLayer instead */
  soloLayer(layerId) {
    this.isolateLayer(layerId);
  }
  /**
   * Unisolate all layers (show all)
   */
  unisolateAll() {
    for (const layer of this.layers.values()) {
      layer.setVisible(true);
    }
  }
  /** @deprecated Use unisolateAll instead */
  unsoloAll() {
    this.unisolateAll();
  }
  // ============================================================================
  // TRACK MATTE PROCESSING
  // ============================================================================
  /**
   * Set callback for retrieving cross-composition matte canvases
   *
   * This enables track mattes from other compositions (nested comps)
   * to be used as matte sources.
   */
  setCrossCompMatteGetter(getter) {
    this.crossCompMatteGetter = getter;
  }
  /**
   * Process track mattes for all layers
   *
   * Track mattes use one layer's rendered output to control
   * another layer's visibility (alpha or luma).
   *
   * This method:
   * 1. Identifies layers that are used as track mattes
   * 2. Collects their rendered canvases (from same comp or cross-comp)
   * 3. Passes the canvas to layers that use them as mattes
   *
   * @param frame - Current frame number for animated evaluation
   */
  processTrackMattes(frame) {
    this.matteCanvases.clear();
    for (const layer of this.layers.values()) {
      const matteLayerId = layer.getTrackMatteLayerId();
      const matteType = layer.getTrackMatteType();
      if (!matteLayerId || matteType === "none") {
        continue;
      }
      let matteCanvas = null;
      if (layer.hasCrossCompMatte() && this.crossCompMatteGetter) {
        const compositionId = layer.getTrackMatteCompositionId();
        matteCanvas = this.crossCompMatteGetter(compositionId, matteLayerId, frame);
        if (!matteCanvas) {
          layerLogger.warn(
            `Cross-comp track matte not found: composition=${compositionId}, layer=${matteLayerId}`
          );
        }
      } else {
        const matteLayer = this.layers.get(matteLayerId);
        if (matteLayer) {
          if (this.matteCanvases.has(matteLayerId)) {
            matteCanvas = this.matteCanvases.get(matteLayerId);
          } else {
            matteCanvas = this.getLayerRenderedCanvas(matteLayer, frame);
            if (matteCanvas) {
              this.matteCanvases.set(matteLayerId, matteCanvas);
            }
          }
        } else {
          layerLogger.warn(`Matte source layer ${matteLayerId} not found`);
        }
      }
      layer.setTrackMatteCanvas(matteCanvas);
    }
  }
  /**
   * Get the rendered canvas from a layer (for use as track matte)
   *
   * This gets the layer's visual output as a canvas that can be used
   * for track matte operations.
   *
   * @param layer - The layer to get canvas from
   * @param frame - Current frame for animated content
   * @returns Canvas with layer's rendered content, or null if unavailable
   */
  getLayerRenderedCanvas(layer, frame) {
    const sourceCanvas = layer.getSourceCanvas?.();
    if (sourceCanvas) {
      const canvas = document.createElement("canvas");
      canvas.width = sourceCanvas.width;
      canvas.height = sourceCanvas.height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        return canvas;
      }
    }
    return null;
  }
  /**
   * Update masks for a specific layer
   */
  setLayerMasks(layerId, masks) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setMasks(masks);
    }
  }
  /**
   * Clear track matte assignment for a layer
   */
  clearTrackMatte(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setTrackMatteCanvas(null);
    }
  }
  /**
   * Compute render order respecting track matte dependencies
   *
   * Matte layers must be rendered before the layers that use them.
   * This returns a topologically sorted list of layer IDs.
   */
  computeRenderOrder() {
    const order = [];
    const visited = /* @__PURE__ */ new Set();
    const visiting = /* @__PURE__ */ new Set();
    const visit = (layerId) => {
      if (visited.has(layerId)) return;
      if (visiting.has(layerId)) {
        layerLogger.warn(`Circular track matte dependency detected involving layer ${layerId}`);
        return;
      }
      visiting.add(layerId);
      const layer = this.layers.get(layerId);
      if (layer) {
        const matteLayerId = layer.getTrackMatteLayerId();
        if (matteLayerId && this.layers.has(matteLayerId)) {
          visit(matteLayerId);
        }
        const parentId = layer.getParentId();
        if (parentId && this.layers.has(parentId)) {
          visit(parentId);
        }
      }
      visiting.delete(layerId);
      visited.add(layerId);
      order.push(layerId);
    };
    for (const layerId of this.layers.keys()) {
      visit(layerId);
    }
    this.renderOrder = order;
    return order;
  }
  /**
   * Get the computed render order
   */
  getRenderOrder() {
    return this.renderOrder;
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(x, y, camera) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, camera);
    const intersects = this.scene.raycastComposition(raycaster);
    const layerIds = /* @__PURE__ */ new Set();
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          layerIds.add(obj.userData.layerId);
          break;
        }
        obj = obj.parent;
      }
    }
    return Array.from(layerIds).map((id) => this.layers.get(id)).filter((layer) => layer !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const layer of this.layers.values()) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
}

/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
const ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
const DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI / 2;
const EPSILON = 1e-5;
const DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
  return approxZero(a - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;
  let output = target + (change + temp) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
class EventDispatcher {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
}
var _a;
const VERSION = "2.10.1";
const TOUCH_DOLLY_FACTOR = 1 / 8;
const isMac = /Mac/.test((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform);
let THREE;
let _ORIGIN;
let _AXIS_Y;
let _AXIS_Z;
let _v2;
let _v3A;
let _v3B;
let _v3C;
let _cameraDirection;
let _xColumn;
let _yColumn;
let _zColumn;
let _deltaTarget;
let _deltaOffset;
let _sphericalA;
let _sphericalB;
let _box3A;
let _box3B;
let _sphere;
let _quaternionA;
let _quaternionB;
let _rotationMatrix;
let _raycaster;
class CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(_) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = this.truckSpeed * deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = this.truckSpeed * deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (screenSpacePanning) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onPointerUp = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 || event.ctrlKey ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.SCREEN_PAN: {
          this._truckInternal(event.deltaX, event.deltaY, false, true);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true, false);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2);
      lastDragPosition.copy(_v2);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2);
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;
      lastDragPosition.copy(_v2);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
        this._truckInternal(deltaX, deltaY, false, true);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true, false);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2);
      lastDragPosition.copy(_v2);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      startDragging();
    };
    this.unlockPointer = () => {
      var _a2, _b, _c;
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      (_a2 = this._domElement) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument.exitPointerLock();
      (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
      this.cancel();
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown);
      this._domElement.addEventListener("pointercancel", onPointerUp);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isObject3D = "isObject3D" in sphereOrMesh;
    const boundingSphere = isObject3D ? CameraControls.createBoundingSphere(sphereOrMesh, _sphere) : _sphere.copy(sphereOrMesh);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = out || new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd);
    this._target.copy(this._targetEnd);
    this._spherical.copy(this._sphericalEnd);
    this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
      this._camera.updateMatrixWorld();
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin, rayDirection);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      if (!mesh.geometry)
        return;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l = position.count; i < l; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
}

CameraControls.install({ THREE: THREE$1 });
class CameraController {
  /** The main camera */
  camera;
  /** Camera controls for 3D navigation (camera-controls library) */
  cameraControls = null;
  /** Clock for camera-controls delta time */
  clock = new Clock();
  /** Keyframe evaluator for animations */
  evaluator;
  /** Composition dimensions */
  width;
  height;
  /** Default camera state for reset */
  defaultPosition;
  defaultTarget;
  defaultFov = 50;
  /** Animation properties */
  positionProp;
  targetProp;
  fovProp;
  /** Current target position (for lookAt) */
  target;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.evaluator = new KeyframeEvaluator();
    console.log(`[CameraController] constructor: comp=${width}x${height}`);
    this.camera = new PerspectiveCamera(
      this.defaultFov,
      // Field of view
      width / height,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = height / 2 / Math.tan(fovRad / 2);
    this.defaultPosition = new Vector3(width / 2, -height / 2, distance);
    this.defaultTarget = new Vector3(width / 2, -height / 2, 0);
    this.camera.position.copy(this.defaultPosition);
    this.target = this.defaultTarget.clone();
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // CAMERA CONTROLS (3D Navigation)
  // ============================================================================
  /**
   * Enable camera controls for 3D navigation
   * Uses camera-controls library for smooth transitions
   * @param domElement The canvas element to attach controls to
   */
  enableOrbitControls(domElement) {
    if (this.cameraControls) {
      this.cameraControls.dispose();
    }
    this.cameraControls = new CameraControls(this.camera, domElement);
    this.cameraControls.mouseButtons.left = CameraControls.ACTION.NONE;
    this.cameraControls.mouseButtons.middle = CameraControls.ACTION.TRUCK;
    this.cameraControls.mouseButtons.right = CameraControls.ACTION.ROTATE;
    this.cameraControls.mouseButtons.wheel = CameraControls.ACTION.NONE;
    this.cameraControls.setTarget(this.target.x, this.target.y, this.target.z, false);
    this.cameraControls.smoothTime = 0.15;
    this.cameraControls.draggingSmoothTime = 0.1;
    this.cameraControls.minDistance = 10;
    this.cameraControls.maxDistance = 5e4;
    this.cameraControls.minPolarAngle = 0.01;
    this.cameraControls.maxPolarAngle = Math.PI - 0.01;
    this.cameraControls.azimuthRotateSpeed = 0.5;
    this.cameraControls.polarRotateSpeed = 0.5;
    this.cameraControls.truckSpeed = 2;
    this.resetToDefault();
    console.log("[CameraController] Camera controls enabled (camera-controls library, smooth transitions)");
  }
  /**
   * Disable camera controls
   */
  disableOrbitControls() {
    if (this.cameraControls) {
      this.cameraControls.dispose();
      this.cameraControls = null;
    }
  }
  /**
   * Update camera controls (call in animation loop)
   * Returns true if camera is still moving (for render optimization)
   */
  updateOrbitControls() {
    if (this.cameraControls) {
      const delta = this.clock.getDelta();
      const hasUpdated = this.cameraControls.update(delta);
      const target = this.cameraControls.getTarget(new Vector3());
      this.target.copy(target);
      return hasUpdated;
    }
    return false;
  }
  /**
   * Reset camera to default viewing position - PERFECT 2D FRONT VIEW
   * Camera looks straight at composition center, no rotation/tilt
   * This is the "Sync to Home" state - as if there's no 3D at all
   */
  resetToDefault() {
    const fovRad = MathUtils.degToRad(this.defaultFov);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    const centerX = this.width / 2;
    const centerY = -this.height / 2;
    this.camera.position.set(centerX, centerY, distance);
    this.target.set(centerX, centerY, 0);
    this.camera.fov = this.defaultFov;
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
    if (this.cameraControls) {
      this.cameraControls.setLookAt(
        this.camera.position.x,
        this.camera.position.y,
        this.camera.position.z,
        this.target.x,
        this.target.y,
        this.target.z,
        false
        // No animation
      );
    }
    this.zoomLevel = 1;
    this.panOffset.set(0, 0);
    console.log(`[CameraController] resetToDefault: comp=${this.width}x${this.height}, center=(${centerX}, ${centerY}), cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${distance.toFixed(1)}), fov=${this.defaultFov}, aspect=${this.camera.aspect.toFixed(3)}`);
  }
  /**
   * Check if camera controls are enabled
   */
  hasOrbitControls() {
    return this.cameraControls !== null;
  }
  /**
   * Set the camera controls target point (the point camera orbits around)
   * This updates the orbit pivot without moving the camera
   * @param x - X position (screen coordinates)
   * @param y - Y position (screen coordinates - will be negated)
   * @param z - Z position
   * @param animate - Whether to animate the transition (default: false)
   */
  setOrbitTarget(x, y, z, animate = false) {
    this.target.set(x, -y, z);
    if (this.cameraControls) {
      this.cameraControls.setTarget(this.target.x, this.target.y, this.target.z, animate);
    }
  }
  /**
   * Reset orbit target to composition center
   */
  resetOrbitTargetToCenter() {
    const centerX = this.width / 2;
    const centerY = this.height / 2;
    this.setOrbitTarget(centerX, centerY, 0);
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera position directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setPositionDirect(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera target directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setTargetDirect(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(x, y, z) {
    this.camera.rotation.set(
      MathUtils.degToRad(x),
      MathUtils.degToRad(y),
      MathUtils.degToRad(z)
    );
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(fov) {
    this.camera.fov = MathUtils.clamp(fov, 1, 179);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(near, far) {
    this.camera.near = Math.max(1e-3, near);
    this.camera.far = Math.max(this.camera.near + 1, far);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEWPORT ZOOM/PAN
  // ============================================================================
  /** Pan offset for viewport navigation */
  panOffset = new Vector2(0, 0);
  zoomLevel = 1;
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(zoom) {
    this.zoomLevel = Math.max(0.1, Math.min(10, zoom));
    this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation (in WORLD units, not screen pixels)
   * Positive X pans right (camera moves left), positive Y pans down (camera moves up)
   */
  setPan(x, y) {
    this.panOffset.set(x, y);
    this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   * When camera controls are active and user has rotated, preserve the rotation.
   * Otherwise, use straight-on 2D view.
   */
  updateCameraForViewport() {
    if (this.cameraControls && this.orbitEnabled) {
      const fovRad2 = MathUtils.degToRad(this.camera.fov);
      const baseDistance2 = this.height / 2 / Math.tan(fovRad2 / 2);
      this.spherical.radius = baseDistance2 / this.zoomLevel;
      this.updateCameraFromSpherical();
      return;
    }
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const baseDistance = this.height / 2 / Math.tan(fovRad / 2);
    const distance = baseDistance / this.zoomLevel;
    const compositionCenterX = this.width / 2;
    const compositionCenterY = -this.height / 2;
    const cameraPosX = compositionCenterX + this.panOffset.x;
    const cameraPosY = compositionCenterY - this.panOffset.y;
    this.camera.position.set(cameraPosX, cameraPosY, distance);
    this.target.set(cameraPosX, cameraPosY, 0);
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.rotation.z = 0;
    this.camera.updateProjectionMatrix();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the primary method for centering - calculates the right zoom to fit
   * @param viewportWidth - The viewport width in pixels
   * @param viewportHeight - The viewport height in pixels
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitToViewport(viewportWidth, viewportHeight, padding = 40) {
    const availableWidth = viewportWidth - padding * 2;
    const availableHeight = viewportHeight - padding * 2;
    const scaleX = availableWidth / this.width;
    const scaleY = availableHeight / this.height;
    const fitZoom = Math.min(scaleX, scaleY, 1);
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
    this.zoomLevel = fitZoom;
    this.panOffset.set(0, 0);
    this.updateCameraForViewport();
    console.log(`[CameraController] fitToViewport: viewport=${viewportWidth}x${viewportHeight}, comp=${this.width}x${this.height}, zoom=${fitZoom.toFixed(3)}, cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)})`);
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(props) {
    this.positionProp = props.position;
    this.targetProp = props.target;
    this.fovProp = props.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0;
    this.targetProp = void 0;
    this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(frame) {
    if (this.positionProp) {
      const pos = this.evaluator.evaluate(this.positionProp, frame);
      this.setPosition(pos.x, pos.y, pos.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const target = this.evaluator.evaluate(this.targetProp, frame);
      this.setTarget(target.x, target.y, target.z ?? 0);
    }
    if (this.fovProp) {
      const fov = this.evaluator.evaluate(this.fovProp, frame);
      this.setFOV(fov);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new COMPOSITION dimensions
   * Note: The aspect ratio should be set separately using setViewportAspect()
   */
  resize(width, height) {
    console.log(`[CameraController] resize: NEW comp=${width}x${height} (was ${this.width}x${this.height})`);
    this.width = width;
    this.height = height;
    this.resetToDefault();
  }
  /**
   * Set camera aspect ratio to match viewport dimensions
   * This should be called with VIEWPORT dimensions, not composition
   */
  setViewportAspect(viewportWidth, viewportHeight) {
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(screenX, screenY, z = 0) {
    const ndcX = screenX / this.width * 2 - 1;
    const ndcY = -(screenY / this.height) * 2 + 1;
    const vector = new Vector3(ndcX, ndcY, 0.5);
    vector.unproject(this.camera);
    const dir = vector.sub(this.camera.position).normalize();
    const distance = (z - this.camera.position.z) / dir.z;
    return this.camera.position.clone().add(dir.multiplyScalar(distance));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(worldX, worldY, worldZ = 0) {
    const vector = new Vector3(worldX, -worldY, worldZ);
    vector.project(this.camera);
    return {
      x: (vector.x + 1) / 2 * this.width,
      y: (-vector.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(state) {
    if (state.position) {
      this.setPosition(state.position.x, state.position.y, state.position.z);
    }
    if (state.target) {
      this.setTarget(state.target.x, state.target.y, state.target.z);
    }
    if (state.fov !== void 0) {
      this.setFOV(state.fov);
    }
    if (state.near !== void 0 || state.far !== void 0) {
      this.setClipPlanes(
        state.near ?? this.camera.near,
        state.far ?? this.camera.far
      );
    }
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const fovRad = MathUtils.degToRad(50);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    this.camera.fov = 50;
    this.camera.position.set(this.width / 2, -this.height / 2, distance);
    this.target.set(this.width / 2, -this.height / 2, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const ortho = new OrthographicCamera(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    ortho.position.set(0, 0, 1e3);
    ortho.lookAt(0, 0, 0);
    return ortho;
  }
  // ============================================================================
  // 3D ORBIT CONTROLS
  // ============================================================================
  /** Current spherical coordinates for orbit mode */
  spherical = { radius: 1e3, theta: 0, phi: Math.PI / 2 };
  /** Whether orbit mode is enabled */
  orbitEnabled = false;
  /**
   * Enable orbit mode for 3D navigation
   * In orbit mode, the camera orbits around the target point
   */
  enableOrbitMode() {
    this.orbitEnabled = true;
    const offset = new Vector3().subVectors(this.camera.position, this.target);
    this.spherical.radius = offset.length();
    this.spherical.theta = Math.atan2(offset.x - this.target.x, offset.z);
    this.spherical.phi = Math.acos(MathUtils.clamp(offset.y / this.spherical.radius, -1, 1));
  }
  /**
   * Disable orbit mode (return to pan/zoom mode)
   */
  disableOrbitMode() {
    this.orbitEnabled = false;
  }
  /**
   * Check if orbit mode is active
   */
  isOrbitMode() {
    return this.orbitEnabled;
  }
  /**
   * Orbit camera around target point
   * @param deltaTheta - Horizontal rotation in radians (around Y axis)
   * @param deltaPhi - Vertical rotation in radians (around X axis)
   */
  orbit(deltaTheta, deltaPhi) {
    if (!this.orbitEnabled) return;
    this.spherical.theta -= deltaTheta;
    this.spherical.phi = MathUtils.clamp(
      this.spherical.phi - deltaPhi,
      0.01,
      // Prevent flipping at poles
      Math.PI - 0.01
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Dolly (zoom in/out) in orbit mode
   * @param delta - Positive to zoom in, negative to zoom out
   */
  dolly(delta) {
    if (!this.orbitEnabled) {
      this.setZoom(this.zoomLevel * (1 + delta * 0.1));
      return;
    }
    this.spherical.radius = MathUtils.clamp(
      this.spherical.radius * (1 - delta * 0.1),
      10,
      // Minimum distance
      5e4
      // Maximum distance
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Pan camera in orbit mode (move target point)
   * @param deltaX - Horizontal pan in screen pixels
   * @param deltaY - Vertical pan in screen pixels
   */
  orbitPan(deltaX, deltaY) {
    if (!this.orbitEnabled) {
      this.setPan(this.panOffset.x + deltaX, this.panOffset.y + deltaY);
      return;
    }
    const panSpeed = this.spherical.radius * 1e-3;
    const right = new Vector3();
    const up = new Vector3();
    right.setFromMatrixColumn(this.camera.matrix, 0);
    up.setFromMatrixColumn(this.camera.matrix, 1);
    const panOffset = new Vector3();
    panOffset.addScaledVector(right, -deltaX * panSpeed);
    panOffset.addScaledVector(up, deltaY * panSpeed);
    this.target.add(panOffset);
    this.updateCameraFromSpherical();
  }
  /**
   * Update camera position from spherical coordinates
   */
  updateCameraFromSpherical() {
    const x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
    const y = this.spherical.radius * Math.cos(this.spherical.phi);
    const z = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
    this.camera.position.set(
      this.target.x + x,
      this.target.y + y,
      this.target.z + z
    );
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEW PRESETS
  // ============================================================================
  /**
   * Available orthographic view presets
   */
  static VIEW_PRESETS = {
    front: { theta: 0, phi: Math.PI / 2, name: "Front" },
    back: { theta: Math.PI, phi: Math.PI / 2, name: "Back" },
    left: { theta: -Math.PI / 2, phi: Math.PI / 2, name: "Left" },
    right: { theta: Math.PI / 2, phi: Math.PI / 2, name: "Right" },
    top: { theta: 0, phi: 0.01, name: "Top" },
    bottom: { theta: 0, phi: Math.PI - 0.01, name: "Bottom" },
    perspective: { theta: Math.PI / 4, phi: Math.PI / 3, name: "Perspective" }
  };
  /**
   * Switch to a predefined view preset
   * @param preset - Name of the view preset
   * @param animate - Whether to animate the transition (default: false)
   */
  setViewPreset(preset, animate = false) {
    const view = CameraController.VIEW_PRESETS[preset];
    if (!view) return;
    if (!this.orbitEnabled) {
      this.enableOrbitMode();
    }
    if (animate) {
      const startTheta = this.spherical.theta;
      const startPhi = this.spherical.phi;
      const targetTheta = view.theta;
      const targetPhi = view.phi;
      const duration = 300;
      const startTime = performance.now();
      const animateView = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.spherical.theta = startTheta + (targetTheta - startTheta) * eased;
        this.spherical.phi = startPhi + (targetPhi - startPhi) * eased;
        this.updateCameraFromSpherical();
        if (t < 1) {
          requestAnimationFrame(animateView);
        }
      };
      requestAnimationFrame(animateView);
    } else {
      this.spherical.theta = view.theta;
      this.spherical.phi = view.phi;
      this.updateCameraFromSpherical();
    }
  }
  /**
   * Reset camera to default 2D view (centered on composition)
   */
  resetTo2DView() {
    this.disableOrbitMode();
    this.panOffset.set(0, 0);
    this.zoomLevel = 1;
    this.reset();
  }
  /**
   * Reset orbit to center on composition
   */
  resetOrbit() {
    this.target.set(this.width / 2, -this.height / 2, 0);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    this.spherical.radius = this.height / 2 / Math.tan(fovRad / 2);
    this.spherical.theta = 0;
    this.spherical.phi = Math.PI / 2;
    if (this.orbitEnabled) {
      this.updateCameraFromSpherical();
    } else {
      this.reset();
    }
  }
  // ============================================================================
  // FOCUS & FRAMING
  // ============================================================================
  /**
   * Focus camera on a bounding box, framing it in view
   * @param bounds - { min: {x, y, z}, max: {x, y, z} }
   */
  focusOnBounds(bounds) {
    const center = new Vector3(
      (bounds.min.x + bounds.max.x) / 2,
      -(bounds.min.y + bounds.max.y) / 2,
      // Negate for screen coords
      (bounds.min.z + bounds.max.z) / 2
    );
    const size = new Vector3(
      bounds.max.x - bounds.min.x,
      bounds.max.y - bounds.min.y,
      bounds.max.z - bounds.min.z
    );
    const maxDim = Math.max(size.x, size.y, size.z);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = maxDim / 2 / Math.tan(fovRad / 2) * 1.5;
    this.target.copy(center);
    if (this.orbitEnabled) {
      this.spherical.radius = distance;
      this.updateCameraFromSpherical();
    } else {
      this.camera.position.set(center.x, center.y, center.z + distance);
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
  }
  /**
   * Focus on a layer by its bounding rect
   * @param x - Layer X position
   * @param y - Layer Y position
   * @param width - Layer width
   * @param height - Layer height
   * @param z - Layer Z position (default 0)
   */
  focusOnLayer(x, y, width, height, z = 0) {
    this.focusOnBounds({
      min: { x, y, z: z - 10 },
      max: { x: x + width, y: y + height, z: z + 10 }
    });
  }
  // ============================================================================
  // CAMERA BOOKMARKS
  // ============================================================================
  /** Stored camera bookmarks */
  bookmarks = /* @__PURE__ */ new Map();
  /**
   * Save current camera state as a bookmark
   * @param name - Name for the bookmark
   */
  saveBookmark(name) {
    this.bookmarks.set(name, {
      position: this.camera.position.clone(),
      target: this.target.clone(),
      spherical: { ...this.spherical },
      fov: this.camera.fov,
      orbitEnabled: this.orbitEnabled
    });
  }
  /**
   * Load a saved camera bookmark
   * @param name - Name of the bookmark
   * @param animate - Whether to animate transition
   */
  loadBookmark(name, animate = false) {
    const bookmark = this.bookmarks.get(name);
    if (!bookmark) return false;
    if (animate) {
      const startPos = this.camera.position.clone();
      const startTarget = this.target.clone();
      const startFov = this.camera.fov;
      const duration = 500;
      const startTime = performance.now();
      const animateBookmark = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.camera.position.lerpVectors(startPos, bookmark.position, eased);
        this.target.lerpVectors(startTarget, bookmark.target, eased);
        this.camera.fov = startFov + (bookmark.fov - startFov) * eased;
        this.camera.lookAt(this.target);
        this.camera.updateProjectionMatrix();
        if (t < 1) {
          requestAnimationFrame(animateBookmark);
        } else {
          this.spherical = { ...bookmark.spherical };
          this.orbitEnabled = bookmark.orbitEnabled;
        }
      };
      requestAnimationFrame(animateBookmark);
    } else {
      this.camera.position.copy(bookmark.position);
      this.target.copy(bookmark.target);
      this.camera.fov = bookmark.fov;
      this.spherical = { ...bookmark.spherical };
      this.orbitEnabled = bookmark.orbitEnabled;
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
    return true;
  }
  /**
   * Delete a bookmark
   * @param name - Name of the bookmark
   */
  deleteBookmark(name) {
    return this.bookmarks.delete(name);
  }
  /**
   * Get list of bookmark names
   */
  getBookmarkNames() {
    return Array.from(this.bookmarks.keys());
  }
  /**
   * Export all bookmarks as JSON-serializable data
   */
  exportBookmarks() {
    const result = {};
    this.bookmarks.forEach((value, key) => {
      result[key] = {
        position: { x: value.position.x, y: value.position.y, z: value.position.z },
        target: { x: value.target.x, y: value.target.y, z: value.target.z },
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      };
    });
    return result;
  }
  /**
   * Import bookmarks from JSON data
   */
  importBookmarks(data) {
    Object.entries(data).forEach(([name, value]) => {
      this.bookmarks.set(name, {
        position: new Vector3(value.position.x, value.position.y, value.position.z),
        target: new Vector3(value.target.x, value.target.y, value.target.z),
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      });
    });
  }
}

class ResourceManager {
  // Texture cache (keyed by URL or ID)
  textures;
  // Geometry cache (keyed by type and parameters)
  geometries;
  // Material cache (keyed by configuration hash)
  materials;
  // Texture loader
  textureLoader;
  // Asset getter callback (set by WeylEngine)
  assetGetter;
  // Statistics
  stats = {
    texturesLoaded: 0,
    texturesFromCache: 0,
    geometriesCreated: 0,
    geometriesFromCache: 0
  };
  constructor() {
    this.textures = /* @__PURE__ */ new Map();
    this.geometries = /* @__PURE__ */ new Map();
    this.materials = /* @__PURE__ */ new Map();
    this.textureLoader = new TextureLoader();
    this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(assetId) {
    return this.assetGetter?.(assetId);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const plane = new PlaneGeometry(1, 1, 1, 1);
    this.geometries.set("plane:1:1", plane);
    const quad = new PlaneGeometry(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", quad);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(url, options) {
    const cacheKey = this.getTextureCacheKey(url, options);
    const cached = this.textures.get(cacheKey);
    if (cached) {
      this.stats.texturesFromCache++;
      return cached;
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.applyTextureOptions(texture, options);
          this.textures.set(cacheKey, texture);
          this.stats.texturesLoaded++;
          resolve(texture);
        },
        void 0,
        // Progress callback
        (error) => {
          renderLogger.error("ResourceManager: Failed to load texture:", url, error);
          reject(error);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(imageData, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof DataTexture) {
      cached.image = imageData;
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new DataTexture(
      imageData.data,
      imageData.width,
      imageData.height,
      RGBAFormat,
      UnsignedByteType
    );
    this.applyTextureOptions(texture, options);
    texture.needsUpdate = true;
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(canvas, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof CanvasTexture) {
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new CanvasTexture(canvas);
    this.applyTextureOptions(texture, options);
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Get a cached texture
   */
  getTexture(key) {
    return this.textures.get(key);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(texture, options) {
    if (!options) {
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.colorSpace = SRGBColorSpace;
      return;
    }
    if (options.wrapS !== void 0) texture.wrapS = options.wrapS;
    if (options.wrapT !== void 0) texture.wrapT = options.wrapT;
    if (options.minFilter !== void 0) texture.minFilter = options.minFilter;
    if (options.magFilter !== void 0) texture.magFilter = options.magFilter;
    if (options.generateMipmaps !== void 0) texture.generateMipmaps = options.generateMipmaps;
    if (options.flipY !== void 0) texture.flipY = options.flipY;
    if (options.colorSpace !== void 0) texture.colorSpace = options.colorSpace;
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(url, options) {
    if (!options) return url;
    return `${url}:${JSON.stringify(options)}`;
  }
  /**
   * Release a texture
   */
  releaseTexture(key) {
    const texture = this.textures.get(key);
    if (texture) {
      texture.dispose();
      this.textures.delete(key);
    }
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(layerId) {
    const layerKey = `layer:${layerId}`;
    const layerTexture = this.textures.get(layerKey);
    if (layerTexture) {
      return layerTexture;
    }
    return null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(layerId, texture) {
    const key = `layer:${layerId}`;
    this.textures.set(key, texture);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(width = 1, height = 1) {
    const key = `plane:${width}:${height}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new PlaneGeometry(width, height, 1, 1);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(radius = 1, segments = 32) {
    const key = `circle:${radius}:${segments}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new CircleGeometry(radius, segments);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(width = 1, height = 1, depth = 1) {
    const key = `box:${width}:${height}:${depth}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new BoxGeometry(width, height, depth);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(options) {
    const key = `basic:${JSON.stringify(options)}`;
    let material = this.materials.get(key);
    if (material) {
      return material;
    }
    material = new MeshBasicMaterial({
      color: options.color ?? 16777215,
      transparent: options.transparent ?? true,
      opacity: options.opacity ?? 1,
      map: options.map,
      side: options.side ?? DoubleSide
    });
    this.materials.set(key, material);
    return material;
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(type) {
    switch (type) {
      case "basic":
        return new MeshBasicMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "standard":
        return new MeshStandardMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "shader":
        return new ShaderMaterial();
      default:
        return new MeshBasicMaterial();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const texture of this.textures.values()) {
      texture.dispose();
    }
    this.textures.clear();
    for (const geometry of this.geometries.values()) {
      geometry.dispose();
    }
    this.geometries.clear();
    for (const material of this.materials.values()) {
      material.dispose();
    }
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    renderLogger.debug("ResourceManager: Resource stats:", this.getStats());
  }
}

class PerformanceMonitor {
  // Frame timing
  frameCount = 0;
  lastTime = 0;
  frameTimes = [];
  maxFrameTimes = 60;
  // FPS calculation
  fps = 0;
  fpsUpdateInterval = 500;
  // ms
  lastFpsUpdate = 0;
  framesInInterval = 0;
  // Frame start time (for measuring frame duration)
  frameStartTime = 0;
  // Last captured stats
  lastStats = {
    fps: 0,
    frameTime: 0,
    drawCalls: 0,
    triangles: 0,
    textures: 0,
    geometries: 0,
    memoryUsed: 0
  };
  constructor() {
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(renderer) {
    const now = performance.now();
    const frameTime = now - this.frameStartTime;
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxFrameTimes) {
      this.frameTimes.shift();
    }
    this.frameCount++;
    this.framesInInterval++;
    const timeSinceUpdate = now - this.lastFpsUpdate;
    if (timeSinceUpdate >= this.fpsUpdateInterval) {
      this.fps = Math.round(this.framesInInterval * 1e3 / timeSinceUpdate);
      this.framesInInterval = 0;
      this.lastFpsUpdate = now;
    }
    const info = renderer.info;
    const memory = performance.memory;
    const memoryUsed = memory?.usedJSHeapSize ?? 0;
    const avgFrameTime = this.frameTimes.length > 0 ? this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length : 0;
    this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(avgFrameTime * 100) / 100,
      drawCalls: info.render.calls,
      triangles: info.render.triangles,
      textures: info.memory.textures,
      geometries: info.memory.geometries,
      memoryUsed
    };
    this.lastTime = now;
    return this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    if (this.frameTimes.length === 0) return 0;
    return this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    if (this.frameTimes.length === 0) {
      return { min: 0, max: 0 };
    }
    return {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0;
    this.frameTimes = [];
    this.fps = 0;
    this.framesInInterval = 0;
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
    this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(targetFps = 30) {
    return this.fps > 0 && this.fps < targetFps;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const stats = this.lastStats;
    const range = this.getFrameTimeRange();
    return [
      `FPS: ${stats.fps}`,
      `Frame Time: ${stats.frameTime.toFixed(2)}ms (min: ${range.min.toFixed(2)}, max: ${range.max.toFixed(2)})`,
      `Draw Calls: ${stats.drawCalls}`,
      `Triangles: ${stats.triangles.toLocaleString()}`,
      `Textures: ${stats.textures}`,
      `Geometries: ${stats.geometries}`,
      `Memory: ${(stats.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join("\n");
  }
}

class WeylEngine {
  // Core subsystems
  scene;
  renderer;
  layers;
  camera;
  resources;
  performance;
  // State
  state;
  animationFrameId = null;
  // Background and overlay images
  backgroundImage = null;
  depthMapMesh = null;
  depthMapSettings = { colormap: "viridis", opacity: 0.5, visible: false };
  // Viewport transform for pan/zoom
  viewportTransform = [1, 0, 0, 1, 0, 0];
  // Render mode
  renderMode = "color";
  // Audio reactivity
  audioReactiveGetter = null;
  // Transform controls for layer manipulation
  transformControls = null;
  selectedLayerId = null;
  transformMode = "translate";
  // Transform change callback
  onTransformChange = null;
  // Event system
  eventHandlers;
  // WebGL context event handlers (stored for cleanup)
  contextLostHandler = null;
  contextRestoredHandler = null;
  // Configuration
  config;
  constructor(config) {
    this.validateConfig(config);
    this.config = {
      canvas: config.canvas,
      width: config.width,
      height: config.height,
      compositionWidth: config.compositionWidth ?? config.width,
      compositionHeight: config.compositionHeight ?? config.height,
      pixelRatio: config.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      backgroundColor: config.backgroundColor ?? null,
      debug: config.debug ?? false,
      powerPreference: config.powerPreference ?? "high-performance"
    };
    this.state = {
      currentFrame: 0,
      // DEPRECATED: Use MotionEngine as time authority
      isRendering: false,
      isDisposed: false,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    };
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.resources = new ResourceManager();
    this.scene = new SceneManager(this.config.backgroundColor);
    this.camera = new CameraController(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.camera.setViewportAspect(this.config.width, this.config.height);
    this.renderer = new RenderPipeline({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera);
    this.layers = new LayerManager(this.scene, this.resources);
    this.performance = new PerformanceMonitor();
    this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.setupContextLossHandling();
    if (this.config.debug) {
      engineLogger.debug("Initialized", this.config);
    }
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(config) {
    if (!(config.canvas instanceof HTMLCanvasElement)) {
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    }
    if (config.width <= 0 || config.height <= 0) {
      throw new Error("WeylEngine requires positive width and height");
    }
    if (config.width > 8192 || config.height > 8192) {
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
    }
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(layerData) {
    this.assertNotDisposed();
    this.layers.create(layerData);
    this.emit("layerAdded", { layerId: layerData.id });
    if (this.config.debug) {
      engineLogger.debug("Layer added:", layerData.id, layerData.type);
    }
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(layerId, properties) {
    this.assertNotDisposed();
    this.layers.update(layerId, properties);
    this.emit("layerUpdated", { layerId, properties });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(layerId) {
    this.assertNotDisposed();
    this.layers.remove(layerId);
    this.emit("layerRemoved", { layerId });
    if (this.config.debug) {
      engineLogger.debug("Layer removed:", layerId);
    }
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(layerId) {
    return this.layers.getObject(layerId);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(layers) {
    this.assertNotDisposed();
    const existingIds = new Set(this.layers.getLayerIds());
    const newIds = new Set(layers.map((l) => l.id));
    for (const id of existingIds) {
      if (!newIds.has(id)) {
        this.layers.remove(id);
      }
    }
    for (const layer of layers) {
      if (existingIds.has(layer.id)) {
        this.layers.update(layer.id, layer);
      } else {
        this.layers.create(layer);
      }
    }
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(getter) {
    this.resources.setAssetGetter(getter);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(callback) {
    this.layers.setVideoMetadataCallback(callback);
  }
  /**
   * Set the nested comp render context for LayerManager
   * Allows nested comp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setNestedCompRenderContext(context) {
    this.layers.setNestedCompRenderContext(context);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.layers.setCameraCallbacks(getter, updater, atFrameGetter);
    this.activeCameraGetter = getter;
  }
  // Active camera tracking
  activeCameraGetter;
  activeCameraId = null;
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(cameraLayerId) {
    this.activeCameraId = cameraLayerId;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter) {
      return;
    }
    const cameraLayer = this.layers.getLayer(this.activeCameraId);
    if (!cameraLayer || cameraLayer.type !== "camera") {
      return;
    }
    const typedLayer = cameraLayer;
    const exportData = typedLayer.getExportData();
    if (!exportData) {
      return;
    }
    this.camera.setPosition(exportData.position.x, exportData.position.y, exportData.position.z);
    this.camera.setRotation(exportData.rotation.x, exportData.rotation.y, exportData.rotation.z);
    this.camera.setFOV(exportData.fov);
    this.camera.setClipPlanes(exportData.nearClip, exportData.farClip);
    const camera3d = typedLayer.getCameraAtCurrentFrame();
    if (camera3d && camera3d.depthOfField) {
      this.setDOFFromCamera(camera3d.depthOfField);
    }
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(fps) {
    this.layers.setCompositionFPS(fps);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer());
    this.layers.setCamera(this.camera.camera);
  }
  /**
   * Initialize all 3D services with WebGL renderer
   * This enables:
   * - Material system PMREM for environment map prefiltering
   * - Environment map support in SceneManager
   * Call this after engine construction for full 3D pipeline support
   */
  initialize3DServices() {
    const renderer = this.renderer.getWebGLRenderer();
    materialSystem.initialize(renderer);
    this.scene.initializeEnvironmentSupport(renderer);
    if (this.config.debug) {
      engineLogger.debug("3D services initialized");
    }
  }
  // ============================================================================
  // 3D SERVICE ACCESS
  // ============================================================================
  /**
   * Get the material system for PBR material management
   */
  getMaterialSystem() {
    return materialSystem;
  }
  /**
   * Get the SVG extrusion service for logo workflows
   */
  getSVGExtrusionService() {
    return svgExtrusionService;
  }
  /**
   * Get the mesh particle manager for custom particle shapes
   */
  getMeshParticleManager() {
    return meshParticleManager;
  }
  /**
   * Get the sprite sheet service for particle animations
   */
  getSpriteSheetService() {
    return spriteSheetService;
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const cam = this.camera.camera;
    return {
      projectionMatrix: cam.projectionMatrix.clone(),
      viewMatrix: cam.matrixWorldInverse.clone(),
      projectionMatrixInverse: cam.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    this.layers.setLayerDrivenValues(layerId, values);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    this.layers.clearLayerDrivenValues(layerId);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Apply a pre-evaluated FrameState from MotionEngine
   *
   * This is the CANONICAL way to update the rendering state.
   * FrameState is computed by MotionEngine.evaluate() which is PURE.
   *
   * ARCHITECTURAL RULE:
   * - Layers receive already-evaluated values via applyEvaluatedState()
   * - NO interpolation or time sampling happens here
   * - Single source of truth: MotionEngine
   *
   * @param frameState - Pre-evaluated state from MotionEngine.evaluate()
   */
  applyFrameState(frameState) {
    this.assertNotDisposed();
    this.state.currentFrame = frameState.frame;
    this.layers.applyEvaluatedState(frameState.layers, frameState.frame);
    if (frameState.camera) {
      this.applyCameraState(frameState.camera);
    } else {
      this.syncActiveCamera();
      if (!this.activeCameraId) {
        this.camera.evaluateFrame(frameState.frame);
      }
    }
  }
  /**
   * Apply evaluated camera state directly
   */
  applyCameraState(cameraState) {
    if (!cameraState) return;
    this.camera.setPositionDirect(
      cameraState.position.x,
      cameraState.position.y,
      cameraState.position.z
    );
    this.camera.setTargetDirect(
      cameraState.target.x,
      cameraState.target.y,
      cameraState.target.z
    );
    this.camera.setFOV(cameraState.fov);
  }
  /**
   * Set the current frame for animation evaluation
   *
   * @deprecated Use applyFrameState() with MotionEngine.evaluate() instead.
   * This method evaluates frames directly, bypassing the single time authority.
   * It is kept for backwards compatibility but should be phased out.
   *
   * @param frame - The frame number (0-indexed)
   */
  setFrame(frame) {
    this.assertNotDisposed();
    this.state.currentFrame = frame;
    this.layers.evaluateFrame(frame, this.audioReactiveGetter);
    this.syncActiveCamera();
    if (!this.activeCameraId) {
      this.camera.evaluateFrame(frame);
    }
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
    this.layers.setAudioReactiveCallback(getter);
  }
  /**
   * Get the current frame
   * @deprecated Frame authority is now MotionEngine. This returns cached value.
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed();
    this.performance.beginFrame();
    this.emit("frameStart", { frame: this.state.currentFrame });
    this.camera.updateOrbitControls();
    this.renderer.render();
    this.emit("frameEnd", { frame: this.state.currentFrame });
    this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    this.assertNotDisposed();
    if (this.animationFrameId !== null) {
      return;
    }
    this.state.isRendering = true;
    const loop = () => {
      if (!this.state.isRendering || this.state.isDisposed) {
        this.animationFrameId = null;
        return;
      }
      this.render();
      this.animationFrameId = requestAnimationFrame(loop);
    };
    this.animationFrameId = requestAnimationFrame(loop);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = false;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(width, height, compositionWidth, compositionHeight) {
    this.assertNotDisposed();
    if (width <= 0 || height <= 0) {
      engineLogger.warn("Invalid resize dimensions:", width, height);
      return;
    }
    console.log(`[WeylEngine] resize: viewport=${width}x${height}, comp=${compositionWidth ?? "undefined"}x${compositionHeight ?? "undefined"}`);
    this.state.viewport = { width, height };
    this.renderer.resize(width, height);
    if (compositionWidth !== void 0 && compositionHeight !== void 0) {
      this.camera.resize(compositionWidth, compositionHeight);
    }
    this.camera.setViewportAspect(width, height);
    this.updateSplineResolutions(width, height);
    this.emit("resize", { width, height, compositionWidth, compositionHeight });
  }
  /**
   * Update all SplineLayer resolutions for Line2 materials
   */
  updateSplineResolutions(width, height) {
    const layers = this.layers.getAllLayers();
    for (const layer of layers) {
      if ("setResolution" in layer && typeof layer.setResolution === "function") {
        layer.setResolution(width, height);
      }
    }
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Enable 3D orbit controls for camera navigation
   * Right-click = orbit, middle-click = pan, scroll = dolly
   */
  enableOrbitControls() {
    const domElement = this.renderer.getDomElement();
    this.camera.enableOrbitControls(domElement);
  }
  /**
   * Disable 3D orbit controls
   */
  disableOrbitControls() {
    this.camera.disableOrbitControls();
  }
  /**
   * Reset camera to default viewing position
   */
  resetCameraToDefault() {
    this.camera.resetToDefault();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the canonical method for centering the view on initial load
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitCompositionToViewport(padding = 40) {
    const { width, height } = this.state.viewport;
    this.camera.fitToViewport(width, height, padding);
  }
  /**
   * Check if orbit controls are enabled
   */
  hasOrbitControls() {
    return this.camera.hasOrbitControls();
  }
  /**
   * Set camera position
   */
  setCameraPosition(x, y, z) {
    this.camera.setPosition(x, y, z);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(x, y, z) {
    this.camera.setTarget(x, y, z);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(fov) {
    this.camera.setFOV(fov);
  }
  /**
   * Set the orbit pivot point (the point the camera orbits around)
   * @param x - X position in screen coordinates
   * @param y - Y position in screen coordinates
   * @param z - Z position
   */
  setOrbitTarget(x, y, z) {
    this.camera.setOrbitTarget(x, y, z);
  }
  /**
   * Reset orbit target to composition center
   */
  resetOrbitTargetToCenter() {
    this.camera.resetOrbitTargetToCenter();
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(dof) {
    this.renderer.setDOF({
      enabled: dof.enabled,
      focusDistance: dof.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: dof.aperture * 1e-4,
      maxBlur: dof.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(enabled) {
    this.renderer.setDOFEnabled(enabled);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(distance) {
    this.renderer.setFocusDistance(distance);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(aperture) {
    this.renderer.setAperture(aperture * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   * @param config - SSAO configuration options
   */
  setSSAO(config) {
    this.renderer.setSSAO(config);
  }
  /**
   * Enable or disable SSAO
   */
  setSSAOEnabled(enabled) {
    this.renderer.setSSAOEnabled(enabled);
  }
  /**
   * Set SSAO intensity
   * @param intensity - Occlusion intensity multiplier
   */
  setSSAOIntensity(intensity) {
    this.renderer.setSSAOIntensity(intensity);
  }
  /**
   * Set SSAO sampling radius
   * @param radius - Kernel radius for occlusion sampling
   */
  setSSAORadius(radius) {
    this.renderer.setSSAORadius(radius);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return this.renderer.getSSAO();
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, bright particles) glow
   * @param config - Bloom configuration options
   */
  setBloom(config) {
    this.renderer.setBloom(config);
  }
  /**
   * Enable or disable bloom
   */
  setBloomEnabled(enabled) {
    this.renderer.setBloomEnabled(enabled);
  }
  /**
   * Set bloom intensity
   * @param strength - Bloom strength multiplier
   */
  setBloomStrength(strength) {
    this.renderer.setBloomStrength(strength);
  }
  /**
   * Set bloom threshold
   * @param threshold - Brightness threshold for bloom (0-1)
   */
  setBloomThreshold(threshold) {
    this.renderer.setBloomThreshold(threshold);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return this.renderer.getBloom();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(transform) {
    this.viewportTransform = [...transform];
    const scale = transform[0];
    const tx = transform[4];
    const ty = transform[5];
    this.camera.setZoom(scale);
    this.camera.setPan(tx, ty);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set the scene background color
   * @param color - Hex color string (e.g., '#050505') or null for transparent
   */
  setBackground(color) {
    this.assertNotDisposed();
    this.scene.setBackground(color);
  }
  /**
   * Get the current background color
   */
  getBackground() {
    return this.scene.getBackground();
  }
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(image) {
    this.assertNotDisposed();
    if (this.backgroundImage) {
      this.scene.removeFromComposition(this.backgroundImage);
      this.backgroundImage.geometry.dispose();
      this.backgroundImage.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    texture.colorSpace = SRGBColorSpace;
    const geometry = new PlaneGeometry(image.width, image.height);
    const material = new MeshBasicMaterial({
      map: texture,
      transparent: true,
      depthWrite: false
    });
    this.backgroundImage = new Mesh(geometry, material);
    this.backgroundImage.position.set(image.width / 2, image.height / 2, -1e3);
    this.backgroundImage.userData.isBackground = true;
    this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(image, options) {
    this.assertNotDisposed();
    this.depthMapSettings = {
      colormap: options.colormap ?? this.depthMapSettings.colormap,
      opacity: options.opacity ?? this.depthMapSettings.opacity,
      visible: options.visible ?? this.depthMapSettings.visible
    };
    if (this.depthMapMesh) {
      this.scene.removeFromComposition(this.depthMapMesh);
      this.depthMapMesh.geometry.dispose();
      this.depthMapMesh.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    const material = this.createColormapMaterial(texture, this.depthMapSettings);
    const geometry = new PlaneGeometry(image.width, image.height);
    this.depthMapMesh = new Mesh(geometry, material);
    this.depthMapMesh.position.set(image.width / 2, image.height / 2, -999);
    this.depthMapMesh.visible = this.depthMapSettings.visible;
    this.depthMapMesh.userData.isDepthOverlay = true;
    this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(texture, settings) {
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `;
    const colormapIndex = settings.colormap === "viridis" ? 0 : settings.colormap === "plasma" ? 1 : 2;
    return new ShaderMaterial({
      uniforms: {
        depthMap: { value: texture },
        opacity: { value: settings.opacity },
        colormap: { value: colormapIndex }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(visible) {
    this.depthMapSettings.visible = visible;
    if (this.depthMapMesh) {
      this.depthMapMesh.visible = visible;
    }
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(colormap) {
    this.depthMapSettings.colormap = colormap;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      const colormapIndex = colormap === "viridis" ? 0 : colormap === "plasma" ? 1 : 2;
      material.uniforms.colormap.value = colormapIndex;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(opacity) {
    this.depthMapSettings.opacity = opacity;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      material.uniforms.opacity.value = opacity;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    this.renderer.setRenderMode(mode);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize environment map support
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport() {
    this.scene.initializeEnvironmentSupport(this.renderer.getWebGLRenderer());
  }
  /**
   * Load and set an environment map from URL
   * Supports HDR, EXR, and standard image formats
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    this.initializeEnvironmentSupport();
    return this.scene.loadEnvironmentMap(url, config);
  }
  /**
   * Set environment map configuration
   * @param config - Partial configuration to update
   */
  setEnvironmentConfig(config) {
    this.scene.setEnvironmentConfig(config);
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return this.scene.getEnvironmentConfig();
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.scene.setEnvironmentEnabled(enabled);
  }
  /**
   * Set environment map intensity
   * @param intensity - Intensity multiplier (0-2 typical range)
   */
  setEnvironmentIntensity(intensity) {
    this.scene.setEnvironmentIntensity(intensity);
  }
  /**
   * Set environment map rotation
   * @param degrees - Y-axis rotation in degrees
   */
  setEnvironmentRotation(degrees) {
    this.scene.setEnvironmentRotation(degrees);
  }
  /**
   * Set background blur amount for HDRI background
   * @param blur - Blur amount (0-1)
   */
  setEnvironmentBackgroundBlur(blur) {
    this.scene.setBackgroundBlur(blur);
  }
  /**
   * Toggle whether to use HDRI as scene background
   */
  setEnvironmentAsBackground(use) {
    this.scene.setUseAsBackground(use);
  }
  /**
   * Get the current environment map texture
   */
  getEnvironmentMap() {
    return this.scene.getEnvironmentMap();
  }
  // ============================================================================
  // COMPOSITION GUIDES
  // ============================================================================
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    this.scene.setCompositionGridVisible(visible);
  }
  /**
   * Show/hide dark overlay outside composition
   */
  setOutsideOverlayVisible(visible) {
    this.scene.setOutsideOverlayVisible(visible);
  }
  /**
   * Show/hide composition bounds frame
   */
  setCompositionBoundsVisible(visible) {
    this.scene.setCompositionBoundsVisible(visible);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(x, y) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, this.camera.getCamera());
    const intersects = this.scene.raycastComposition(raycaster);
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          return obj.userData.layerId;
        }
        if (obj.userData.isBackground || obj.userData.isDepthOverlay) {
          break;
        }
        obj = obj.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    this.assertNotDisposed();
    if (this.transformControls) {
      return;
    }
    const camera = this.camera.getCamera();
    const domElement = this.renderer.getDomElement();
    this.transformControls = new TransformControls(camera, domElement);
    this.transformControls.setMode(this.transformMode);
    this.transformControls.setSpace("world");
    this.transformControls.setSize(1);
    this.scene.addUIElement(this.transformControls);
    let isDragging = false;
    this.transformControls.addEventListener("dragging-changed", (event) => {
      isDragging = event.value;
      this.emit("transform-dragging", { dragging: event.value });
    });
    this.transformControls.addEventListener("change", () => {
      if (!isDragging) return;
      if (!this.transformControls || !this.selectedLayerId) return;
      const object = this.transformControls.object;
      if (!object) return;
      const layer = this.layers.getLayer(this.selectedLayerId);
      const layerData = layer?.getLayerData?.();
      const anchorX = layerData?.transform?.anchorPoint?.value?.x ?? 0;
      const anchorY = layerData?.transform?.anchorPoint?.value?.y ?? 0;
      const anchorZ = layerData?.transform?.anchorPoint?.value?.z ?? 0;
      const transform = {
        position: {
          x: object.position.x + anchorX,
          y: -object.position.y + anchorY,
          // Y is negated in 3D space
          z: object.position.z + anchorZ
        },
        rotationX: MathUtils.radToDeg(object.rotation.x),
        rotationY: MathUtils.radToDeg(object.rotation.y),
        rotationZ: MathUtils.radToDeg(object.rotation.z),
        scale: {
          x: object.scale.x * 100,
          // Convert back to percentage
          y: object.scale.y * 100,
          z: object.scale.z * 100
        }
      };
      transform.rotation = transform.rotationZ;
      if (this.onTransformChange) {
        this.onTransformChange(this.selectedLayerId, transform);
      }
    });
    this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(callback) {
    this.onTransformChange = callback;
  }
  /**
   * Select a layer and attach transform controls
   * Also updates orbit target to the selected layer's position for right-click orbiting
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(layerId) {
    this.assertNotDisposed();
    if (!this.transformControls) {
      this.initializeTransformControls();
    }
    if (this.selectedLayerId && this.transformControls) {
      this.transformControls.detach();
    }
    this.selectedLayerId = layerId;
    if (!layerId || !this.transformControls) {
      this.resetOrbitTargetToCenter();
      return;
    }
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      this.transformControls.attach(layerObject);
    }
  }
  /**
   * Focus the camera on the selected layer's position
   * This moves the orbit target to the layer without changing camera rotation
   */
  focusOnLayer(layerId) {
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      const worldPos = new Vector3();
      layerObject.getWorldPosition(worldPos);
      this.setOrbitTarget(worldPos.x, -worldPos.y, worldPos.z);
    }
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(mode) {
    this.transformMode = mode;
    if (this.transformControls) {
      this.transformControls.setMode(mode);
    }
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(visible) {
    if (this.transformControls) {
      this.transformControls.visible = visible;
      this.transformControls.enabled = visible;
    }
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    return this.transformControls?.dragging ?? false;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const imageData = this.renderer.captureFrame();
    return {
      imageData,
      width: imageData.width,
      height: imageData.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(format = "png", quality = 0.95) {
    this.assertNotDisposed();
    const { imageData, width, height } = this.captureFrame();
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: `image/${format}`,
      quality
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const depthBuffer = this.renderer.captureDepth();
    const cameraState = this.camera.getState();
    return {
      depthBuffer,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: cameraState.near,
      far: cameraState.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(type, handler) {
    if (!this.eventHandlers.has(type)) {
      this.eventHandlers.set(type, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(type).add(handler);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(type, handler) {
    this.eventHandlers.get(type)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => {
      try {
        handler(event);
      } catch (error) {
        engineLogger.error(`Event handler error for ${type}:`, error);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const canvas = this.config.canvas;
    this.contextLostHandler = (event) => {
      event.preventDefault();
      this.stopRenderLoop();
      this.emit("contextLost", null);
      engineLogger.warn("WebGL context lost");
    };
    this.contextRestoredHandler = () => {
      this.emit("contextRestored", null);
      engineLogger.info("WebGL context restored");
    };
    canvas.addEventListener("webglcontextlost", this.contextLostHandler);
    canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler);
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed) {
      throw new Error("WeylEngine has been disposed");
    }
  }
  // ============================================================================
  // NESTED COMP RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of layer managers for nested compositions */
  nestedCompLayerManagers = /* @__PURE__ */ new Map();
  /** Cache of scenes for nested compositions */
  nestedCompScenes = /* @__PURE__ */ new Map();
  /** Cache of last rendered frame per composition (for texture caching) */
  nestedCompLastFrame = /* @__PURE__ */ new Map();
  /**
   * Render a composition to a texture
   * Used by NestedCompLayer to render nested compositions
   *
   * @param compositionId - The composition ID to render
   * @param layers - The layers in that composition
   * @param settings - Composition settings (width, height, fps)
   * @param frame - The frame to render
   * @returns The rendered texture, or null if rendering fails
   */
  renderCompositionToTexture(compositionId, layers, settings, frame) {
    this.assertNotDisposed();
    try {
      const lastFrame = this.nestedCompLastFrame.get(compositionId);
      const target = this.renderer.getNestedCompRenderTarget(
        compositionId,
        settings.width,
        settings.height
      );
      if (lastFrame === frame) {
        return target.texture;
      }
      let nestedCompScene = this.nestedCompScenes.get(compositionId);
      if (!nestedCompScene) {
        nestedCompScene = new SceneManager(null);
        nestedCompScene.setCompositionSize(settings.width, settings.height);
        this.nestedCompScenes.set(compositionId, nestedCompScene);
      }
      let nestedCompLayers = this.nestedCompLayerManagers.get(compositionId);
      if (!nestedCompLayers) {
        nestedCompLayers = new LayerManager(nestedCompScene, this.resources);
        nestedCompLayers.setRenderer(this.renderer.getWebGLRenderer());
        nestedCompLayers.setCompositionFPS(settings.fps);
        nestedCompLayers.setCamera(this.camera.camera);
        this.nestedCompLayerManagers.set(compositionId, nestedCompLayers);
      }
      const currentLayerIds = new Set(nestedCompLayers.getLayerIds());
      const targetLayerIds = new Set(layers.map((l) => l.id));
      for (const id of currentLayerIds) {
        if (!targetLayerIds.has(id)) {
          nestedCompLayers.remove(id);
        }
      }
      for (const layerData of layers) {
        if (currentLayerIds.has(layerData.id)) {
          nestedCompLayers.update(layerData.id, layerData);
        } else {
          nestedCompLayers.create(layerData);
        }
      }
      nestedCompLayers.evaluateFrame(frame, this.audioReactiveGetter);
      const nestedCompCamera = new OrthographicCamera(
        -settings.width / 2,
        settings.width / 2,
        settings.height / 2,
        -settings.height / 2,
        0.1,
        1e4
      );
      nestedCompCamera.position.set(0, 0, 1e3);
      nestedCompCamera.lookAt(0, 0, 0);
      const texture = this.renderer.renderSceneToTexture(
        nestedCompScene.scene,
        nestedCompCamera,
        target
      );
      this.nestedCompLastFrame.set(compositionId, frame);
      return texture;
    } catch (error) {
      engineLogger.error("Failed to render composition to texture:", compositionId, error);
      return null;
    }
  }
  /**
   * Clear nested composition cache for a specific composition
   * Call when a composition is deleted or significantly changed
   */
  clearNestedCompCache(compositionId) {
    const nestedCompLayers = this.nestedCompLayerManagers.get(compositionId);
    if (nestedCompLayers) {
      nestedCompLayers.dispose();
      this.nestedCompLayerManagers.delete(compositionId);
    }
    const nestedCompScene = this.nestedCompScenes.get(compositionId);
    if (nestedCompScene) {
      nestedCompScene.dispose();
      this.nestedCompScenes.delete(compositionId);
    }
    this.nestedCompLastFrame.delete(compositionId);
    this.renderer.disposeNestedCompTarget(compositionId);
  }
  /**
   * Clear all nested composition caches
   */
  clearAllNestedCompCaches() {
    for (const [id] of this.nestedCompLayerManagers) {
      this.clearNestedCompCache(id);
    }
    this.renderer.disposeAllNestedCompTargets();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    if (this.state.isDisposed) {
      return;
    }
    this.stopRenderLoop();
    this.clearAllNestedCompCaches();
    const canvas = this.config.canvas;
    if (this.contextLostHandler) {
      canvas.removeEventListener("webglcontextlost", this.contextLostHandler);
      this.contextLostHandler = null;
    }
    if (this.contextRestoredHandler) {
      canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler);
      this.contextRestoredHandler = null;
    }
    if (this.transformControls) {
      this.transformControls.dispose();
      this.transformControls = null;
    }
    this.layers.dispose();
    this.renderer.dispose();
    this.scene.dispose();
    this.resources.dispose();
    this.eventHandlers.clear();
    this.state.isDisposed = true;
    this.emit("dispose", null);
    if (this.config.debug) {
      engineLogger.debug("Disposed");
    }
  }
}

const _hoisted_1$i = { class: "spline-editor" };
const _hoisted_2$i = {
  key: 0,
  class: "tool-tip-popup"
};
const _hoisted_3$i = {
  key: 2,
  class: "spline-toolbar"
};
const _hoisted_4$i = { class: "toolbar-group pen-tools" };
const _hoisted_5$i = {
  key: 0,
  class: "toolbar-group"
};
const _hoisted_6$i = ["title"];
const _hoisted_7$i = {
  key: 1,
  class: "toolbar-group"
};
const _hoisted_8$h = { class: "tolerance-label" };
const _hoisted_9$h = { class: "tolerance-value" };
const _hoisted_10$g = {
  key: 2,
  class: "toolbar-info"
};
const _hoisted_11$f = {
  key: 3,
  class: "toolbar-group z-depth-controls"
};
const _hoisted_12$e = { class: "z-depth-label" };
const _hoisted_13$e = ["value"];
const _hoisted_14$c = ["viewBox"];
const _hoisted_15$b = ["x1", "y1", "x2", "y2"];
const _hoisted_16$a = ["x1", "y1", "x2", "y2"];
const _hoisted_17$a = ["cx", "cy", "onMousedown"];
const _hoisted_18$a = ["cx", "cy", "onMousedown"];
const _hoisted_19$a = ["cx", "cy"];
const _hoisted_20$a = ["cx", "cy", "onMousedown", "onMouseenter"];
const _hoisted_21$a = {
  key: 1,
  class: "axis-handles"
};
const _hoisted_22$9 = ["cx", "cy"];
const _hoisted_23$9 = { class: "axis-x-group" };
const _hoisted_24$7 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$7 = ["points"];
const _hoisted_26$7 = ["x", "y", "onMousedown"];
const _hoisted_27$7 = { class: "axis-y-group" };
const _hoisted_28$6 = ["x1", "y1", "x2", "y2"];
const _hoisted_29$6 = ["points"];
const _hoisted_30$5 = ["x", "y", "onMousedown"];
const _hoisted_31$5 = {
  key: 2,
  class: "z-handle-group"
};
const _hoisted_32$5 = ["x1", "y1", "x2", "y2"];
const _hoisted_33$5 = ["points"];
const _hoisted_34$5 = ["points"];
const _hoisted_35$4 = ["points", "onMousedown"];
const _hoisted_36$3 = ["x", "y"];
const _hoisted_37$3 = ["d"];
const _hoisted_38$3 = ["cx", "cy"];
const _hoisted_39$3 = ["cx", "cy"];
const _hoisted_40$2 = ["cx", "cy"];
const CLOSE_THRESHOLD = 15;
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "SplineEditor",
  props: {
    layerId: {},
    currentFrame: {},
    canvasWidth: {},
    canvasHeight: {},
    containerWidth: {},
    containerHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated", "pathClosed", "togglePenMode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    function isSplineOrPathType(layerType) {
      return layerType === "spline" || layerType === "path";
    }
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const selectedPointId = ref(null);
    const selectedPointIds = ref([]);
    const hoveredPointId = ref(null);
    const hoverFeedback = ref(null);
    const hoverFeedbackPos = ref(null);
    const previewPoint = ref(null);
    const closePathPreview = ref(false);
    const previewCurve = ref(null);
    const insertPreviewPoint = ref(null);
    const penSubMode = ref("add");
    const dragTarget = ref(null);
    const activeToolTip = computed(() => {
      switch (penSubMode.value) {
        case "add":
          return "Click to add points. Drag after clicking to create curved handles. Right-click to finish drawing.";
        case "insert":
          return "Click on the path to insert a new point on that segment.";
        case "delete":
          return "Click on any point to delete it from the path.";
        case "convert":
          return "Click on a point to toggle between smooth (curved) and corner (sharp) type.";
        default:
          return "";
      }
    });
    const hoverFeedbackStyle = computed(() => {
      if (!hoverFeedbackPos.value) return { display: "none" };
      const svgStyle = overlayStyle.value;
      const svgWidth = parseFloat(svgStyle.width);
      const svgHeight = parseFloat(svgStyle.height);
      const left = parseFloat(svgStyle.left) + hoverFeedbackPos.value.x / props.canvasWidth * svgWidth;
      const top = parseFloat(svgStyle.top) + hoverFeedbackPos.value.y / props.canvasHeight * svgHeight - 25;
      return {
        position: "absolute",
        left: `${left}px`,
        top: `${top}px`,
        transform: "translateX(-50%)"
      };
    });
    const selectedPointDepth = computed(() => {
      if (!selectedPointId.value) return 0;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      return point?.depth ?? 0;
    });
    function updateSelectedPointDepth(event) {
      if (!selectedPointId.value || !props.layerId) return;
      const input = event.target;
      const newDepth = Math.max(0, parseFloat(input.value) || 0);
      store.updateSplineControlPoint(props.layerId, selectedPointId.value, { depth: newDepth });
      emit("pathUpdated");
    }
    function adjustSelectedPointDepth(delta) {
      if (!selectedPointId.value || !props.layerId) return;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      const currentDepth = point?.depth ?? 0;
      const newDepth = Math.max(0, currentDepth + delta);
      store.updateSplineControlPoint(props.layerId, selectedPointId.value, { depth: newDepth });
      emit("pathUpdated");
    }
    const is3DLayer = computed(() => {
      if (!props.layerId) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      return layer?.threeD ?? false;
    });
    const layerTransform = computed(() => {
      if (!props.layerId) {
        return { position: { x: 0, y: 0 }, rotation: 0, scale: { x: 100, y: 100 }, anchorPoint: { x: 0, y: 0 } };
      }
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer) {
        return { position: { x: 0, y: 0 }, rotation: 0, scale: { x: 100, y: 100 }, anchorPoint: { x: 0, y: 0 } };
      }
      const t = layer.transform;
      const getVal = (prop, defaultVal) => {
        if (!prop) return defaultVal;
        if (prop.animated && prop.keyframes?.length > 0) {
          return interpolateProperty(prop, props.currentFrame) ?? defaultVal;
        }
        return prop.value ?? defaultVal;
      };
      const position = getVal(t.position, { x: props.canvasWidth / 2, y: props.canvasHeight / 2 });
      const anchorPoint = getVal(t.anchorPoint, { x: 0, y: 0 });
      const scale = getVal(t.scale, { x: 100, y: 100 });
      let rotation = 0;
      if (layer.threeD && t.rotationZ) {
        rotation = getVal(t.rotationZ, 0);
      } else if (t.rotation) {
        rotation = getVal(t.rotation, 0);
      }
      return { position, rotation, scale, anchorPoint };
    });
    function transformPoint(p) {
      const { position, rotation, scale, anchorPoint } = layerTransform.value;
      let x = p.x - anchorPoint.x;
      let y = p.y - anchorPoint.y;
      x *= scale.x / 100;
      y *= scale.y / 100;
      const rad = rotation * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      return {
        x: rx + position.x,
        y: ry + position.y
      };
    }
    function inverseTransformPoint(p) {
      const { position, rotation, scale, anchorPoint } = layerTransform.value;
      let x = p.x - position.x;
      let y = p.y - position.y;
      const rad = -rotation * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      x = rx / (scale.x / 100);
      y = ry / (scale.y / 100);
      return {
        x: x + anchorPoint.x,
        y: y + anchorPoint.y
      };
    }
    const isClosed = computed(() => {
      if (!props.layerId) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type)) return false;
      return layer.data?.closed ?? false;
    });
    const smoothTolerance = ref(10);
    const hasControlPoints = computed(() => visibleControlPoints.value.length > 0);
    computed(() => {
      if (!selectedPointId.value) return null;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      return point?.type ?? null;
    });
    function setPenSubMode(mode) {
      if (props.isPenMode && penSubMode.value === mode) {
        emit("togglePenMode");
        return;
      }
      penSubMode.value = mode;
      if (!props.isPenMode) {
        emit("togglePenMode");
      }
    }
    function toggleClosePath() {
      if (!props.layerId) return;
      store.updateLayerData(props.layerId, { closed: !isClosed.value });
      emit("pathUpdated");
    }
    function smoothSelectedPoints() {
      if (!props.layerId) return;
      if (selectedPointIds.value.length > 0) {
        smoothSpecificPoints(selectedPointIds.value);
      } else if (selectedPointId.value) {
        smoothSpecificPoints([selectedPointId.value]);
      } else {
        store.smoothSplineHandles(props.layerId, smoothTolerance.value * 2);
      }
      emit("pathUpdated");
    }
    function smoothSpecificPoints(pointIds) {
      if (!props.layerId) return;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type) || !layer.data) return;
      const splineData = layer.data;
      const controlPoints = splineData.controlPoints;
      if (!controlPoints || controlPoints.length < 2) return;
      const factor = Math.max(0, Math.min(100, smoothTolerance.value * 2)) / 100;
      for (const pointId of pointIds) {
        const i = controlPoints.findIndex((cp2) => cp2.id === pointId);
        if (i < 0) continue;
        const cp = controlPoints[i];
        const prev = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
        const next = controlPoints[(i + 1) % controlPoints.length];
        if (!splineData.closed && (i === 0 || i === controlPoints.length - 1)) continue;
        const toPrev = { x: prev.x - cp.x, y: prev.y - cp.y };
        const toNext = { x: next.x - cp.x, y: next.y - cp.y };
        const avgDir = { x: toNext.x - toPrev.x, y: toNext.y - toPrev.y };
        const avgLength = Math.sqrt(avgDir.x * avgDir.x + avgDir.y * avgDir.y);
        if (avgLength < 0.01) continue;
        const normalized = { x: avgDir.x / avgLength, y: avgDir.y / avgLength };
        const distPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
        const distNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);
        const handleLength = (distPrev + distNext) / 6;
        const idealIn = { x: cp.x - normalized.x * handleLength, y: cp.y - normalized.y * handleLength };
        const idealOut = { x: cp.x + normalized.x * handleLength, y: cp.y + normalized.y * handleLength };
        store.updateSplineControlPoint(props.layerId, pointId, {
          type: "smooth",
          handleIn: {
            x: cp.handleIn ? cp.handleIn.x + (idealIn.x - cp.handleIn.x) * factor : idealIn.x * factor + cp.x * (1 - factor),
            y: cp.handleIn ? cp.handleIn.y + (idealIn.y - cp.handleIn.y) * factor : idealIn.y * factor + cp.y * (1 - factor)
          },
          handleOut: {
            x: cp.handleOut ? cp.handleOut.x + (idealOut.x - cp.handleOut.x) * factor : idealOut.x * factor + cp.x * (1 - factor),
            y: cp.handleOut ? cp.handleOut.y + (idealOut.y - cp.handleOut.y) * factor : idealOut.y * factor + cp.y * (1 - factor)
          }
        });
      }
    }
    function simplifySpline() {
      if (!props.layerId) return;
      store.simplifySpline(props.layerId, smoothTolerance.value);
      emit("pathUpdated");
    }
    const rawControlPoints = computed(() => {
      if (!props.layerId) return [];
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type) || !layer.data) return [];
      const layerData = layer.data;
      if (layerData.animated && layerData.animatedControlPoints) {
        return store.getEvaluatedSplinePoints(props.layerId, props.currentFrame);
      }
      return layerData.controlPoints || [];
    });
    const visibleControlPoints = computed(() => {
      return rawControlPoints.value.map((cp) => {
        const transformed = transformPoint({ x: cp.x, y: cp.y });
        const transformedHandleIn = cp.handleIn ? transformPoint(cp.handleIn) : null;
        const transformedHandleOut = cp.handleOut ? transformPoint(cp.handleOut) : null;
        return {
          id: cp.id,
          rawX: cp.x,
          rawY: cp.y,
          x: transformed.x,
          y: transformed.y,
          depth: cp.depth,
          handleIn: transformedHandleIn,
          handleOut: transformedHandleOut,
          rawHandleIn: cp.handleIn ? { ...cp.handleIn } : null,
          rawHandleOut: cp.handleOut ? { ...cp.handleOut } : null,
          type: cp.type
        };
      });
    });
    function pointHasKeyframes(pointId) {
      if (!props.layerId) return false;
      return store.hasSplinePointKeyframes(props.layerId, pointId);
    }
    function getPointDepth(point) {
      return point.depth ?? 0;
    }
    function getDepthOffset(point) {
      const depth = getPointDepth(point);
      return Math.max(-30, Math.min(30, -depth / 16.67));
    }
    function getZHandlePoints(point) {
      const x = point.x + 15;
      const y = point.y + getDepthOffset(point);
      const size = 5;
      return `${x},${y - size} ${x + size},${y} ${x},${y + size} ${x - size},${y}`;
    }
    function startDragDepth(pointId, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      const pos = getMousePos(event);
      dragTarget.value = {
        type: "depth",
        pointId,
        startX: pos.x,
        startY: pos.y,
        startDepth: getPointDepth(point),
        // Store screen coordinates for zoom-independent movement
        screenStartX: event.clientX,
        screenStartY: event.clientY
      };
      selectedPointId.value = pointId;
    }
    const canClosePath = computed(() => {
      if (!props.layerId || visibleControlPoints.value.length < 3) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type) || !layer.data) return false;
      const layerData = layer.data;
      return !layerData.closed;
    });
    const strokeColor = computed(() => {
      if (!props.layerId) return "#00ff66";
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type) || !layer.data) return "#00ff66";
      if (layer.type === "path") {
        const pathData = layer.data;
        return pathData.guideColor || "#00FFFF";
      }
      const splineData = layer.data;
      return splineData.stroke || splineData.strokeColor || "#00ff66";
    });
    const overlayStyle = computed(() => {
      const containerAspect = props.containerWidth / props.containerHeight;
      const compAspect = props.canvasWidth / props.canvasHeight;
      let fitWidth;
      let fitHeight;
      if (containerAspect > compAspect) {
        fitHeight = props.containerHeight;
        fitWidth = props.canvasWidth * (props.containerHeight / props.canvasHeight);
      } else {
        fitWidth = props.containerWidth;
        fitHeight = props.canvasHeight * (props.containerWidth / props.canvasWidth);
      }
      const zoomFactor = props.zoom || 1;
      const width = fitWidth * zoomFactor;
      const height = fitHeight * zoomFactor;
      const left = (props.containerWidth - width) / 2;
      const top = (props.containerHeight - height) / 2;
      return {
        position: "absolute",
        left: `${left}px`,
        top: `${top}px`,
        width: `${width}px`,
        height: `${height}px`,
        pointerEvents: "all"
      };
    });
    function screenToCanvas(screenX, screenY) {
      const svgRect = overlayStyle.value;
      const svgWidth = parseFloat(svgRect.width);
      const svgHeight = parseFloat(svgRect.height);
      const x = screenX / svgWidth * props.canvasWidth;
      const y = screenY / svgHeight * props.canvasHeight;
      return { x, y };
    }
    function getMousePos(event) {
      const svg = event.currentTarget;
      const rect = svg.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;
      return screenToCanvas(screenX, screenY);
    }
    function evaluateBezier(p0, h0, h1, p1, t) {
      const cp0 = p0;
      const cp1 = h0 || p0;
      const cp2 = h1 || p1;
      const cp3 = p1;
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;
      return {
        x: mt3 * cp0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * cp3.x,
        y: mt3 * cp0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * cp3.y
      };
    }
    function findClosestPointOnPath(pos) {
      const points = visibleControlPoints.value;
      if (points.length < 2) return null;
      let closest = null;
      const numSegments = isClosed.value ? points.length : points.length - 1;
      for (let i = 0; i < numSegments; i++) {
        const p0 = points[i];
        const p1 = points[(i + 1) % points.length];
        const h0 = p0.handleOut;
        const h1 = p1.handleIn;
        for (let t = 0; t <= 1; t += 0.02) {
          const pt = evaluateBezier(p0, h0, h1, p1, t);
          const dist = Math.sqrt((pos.x - pt.x) ** 2 + (pos.y - pt.y) ** 2);
          if (!closest || dist < closest.dist) {
            closest = { x: pt.x, y: pt.y, segmentIndex: i, t, dist };
          }
        }
      }
      if (closest && closest.dist < 20) {
        return { x: closest.x, y: closest.y, segmentIndex: closest.segmentIndex, t: closest.t };
      }
      return null;
    }
    function handleMouseDown(event) {
      if (!props.isPenMode) return;
      const pos = getMousePos(event);
      const layerPos = inverseTransformPoint(pos);
      if (!props.layerId) return;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || !isSplineOrPathType(layer.type)) return;
      if (penSubMode.value === "add") {
        const newPoint = {
          id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          x: layerPos.x,
          y: layerPos.y,
          handleIn: null,
          handleOut: null,
          type: "corner"
        };
        store.addSplineControlPoint(props.layerId, newPoint);
        selectedPointId.value = newPoint.id;
        dragTarget.value = {
          type: "newPoint",
          pointId: newPoint.id,
          startX: pos.x,
          startY: pos.y,
          newPointX: pos.x,
          newPointY: pos.y
        };
        emit("pointAdded", newPoint);
        emit("pathUpdated");
      } else if (penSubMode.value === "insert") {
        const closest = findClosestPointOnPath(pos);
        if (closest) {
          const closestLayerPos = inverseTransformPoint({ x: closest.x, y: closest.y });
          const newPoint = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: closestLayerPos.x,
            y: closestLayerPos.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          store.insertSplineControlPoint(props.layerId, newPoint, closest.segmentIndex + 1);
          selectedPointId.value = newPoint.id;
          emit("pointAdded", newPoint);
          emit("pathUpdated");
        }
      } else if (penSubMode.value === "delete") {
        const clickedPoint = findClickedPoint(pos);
        if (clickedPoint) {
          store.deleteSplineControlPoint(props.layerId, clickedPoint.id);
          emit("pointDeleted", clickedPoint.id);
          emit("pathUpdated");
          selectedPointId.value = null;
        }
      } else if (penSubMode.value === "convert") {
        const clickedPoint = findClickedPoint(pos);
        if (clickedPoint) {
          const newType = clickedPoint.type === "smooth" ? "corner" : "smooth";
          if (newType === "corner") {
            store.updateSplineControlPoint(props.layerId, clickedPoint.id, {
              type: "corner",
              handleIn: null,
              handleOut: null
            });
          } else {
            const handleOffset = 30;
            store.updateSplineControlPoint(props.layerId, clickedPoint.id, {
              type: "smooth",
              handleIn: { x: clickedPoint.x - handleOffset, y: clickedPoint.y },
              handleOut: { x: clickedPoint.x + handleOffset, y: clickedPoint.y }
            });
          }
          selectedPointId.value = clickedPoint.id;
          emit("pathUpdated");
        }
      }
    }
    function findClickedPoint(pos) {
      const threshold = 10;
      for (const point of visibleControlPoints.value) {
        const dist = Math.sqrt((pos.x - point.x) ** 2 + (pos.y - point.y) ** 2);
        if (dist < threshold) {
          return point;
        }
      }
      return null;
    }
    function generateCurvePreview(prevPoint, newPoint, dragPos) {
      const dx = dragPos.x - newPoint.x;
      const dy = dragPos.y - newPoint.y;
      let h1x, h1y;
      if (prevPoint.handleOut) {
        h1x = prevPoint.handleOut.x;
        h1y = prevPoint.handleOut.y;
      } else {
        const dirX = newPoint.x - prevPoint.x;
        const dirY = newPoint.y - prevPoint.y;
        h1x = prevPoint.x + dirX * 0.33;
        h1y = prevPoint.y + dirY * 0.33;
      }
      const h2x = newPoint.x - dx;
      const h2y = newPoint.y - dy;
      return `M ${prevPoint.x},${prevPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${newPoint.x},${newPoint.y}`;
    }
    function handleMouseMove(event) {
      const pos = getMousePos(event);
      if (props.isPenMode) {
        previewPoint.value = pos;
        if (penSubMode.value === "insert") {
          const closest = findClosestPointOnPath(pos);
          insertPreviewPoint.value = closest;
          if (closest) {
            hoverFeedbackPos.value = { x: closest.x, y: closest.y };
            hoverFeedback.value = "Click to add point to spline";
          } else if (!hoveredPointId.value) {
            hoverFeedback.value = null;
          }
        } else {
          insertPreviewPoint.value = null;
          if (!hoveredPointId.value) {
            hoverFeedback.value = null;
          }
        }
        if (penSubMode.value === "add" && !dragTarget.value) {
          const points = visibleControlPoints.value;
          if (points.length > 0) {
            const lastPoint = points[points.length - 1];
            if (lastPoint.handleOut) {
              const h1x = lastPoint.handleOut.x;
              const h1y = lastPoint.handleOut.y;
              const dx = pos.x - lastPoint.x;
              const dy = pos.y - lastPoint.y;
              const h2x = pos.x - dx * 0.3;
              const h2y = pos.y - dy * 0.3;
              previewCurve.value = `M ${lastPoint.x},${lastPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${pos.x},${pos.y}`;
            } else {
              const dx = pos.x - lastPoint.x;
              const dy = pos.y - lastPoint.y;
              const h1x = lastPoint.x + dx * 0.3;
              const h1y = lastPoint.y + dy * 0.3;
              const h2x = pos.x - dx * 0.3;
              const h2y = pos.y - dy * 0.3;
              previewCurve.value = `M ${lastPoint.x},${lastPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${pos.x},${pos.y}`;
            }
          }
        }
      }
      if (dragTarget.value?.type === "newPoint") {
        const points = visibleControlPoints.value;
        if (points.length >= 1) {
          const newPoint = points.find((p) => p.id === dragTarget.value.pointId);
          const newPointIndex = points.indexOf(newPoint);
          const prevPointIndex = newPointIndex - 1;
          const layerPos = inverseTransformPoint(pos);
          const rawNewPointX = newPoint?.rawX ?? newPoint?.x ?? 0;
          const rawNewPointY = newPoint?.rawY ?? newPoint?.y ?? 0;
          if (newPoint && prevPointIndex >= 0) {
            const prevPoint = points[prevPointIndex];
            previewCurve.value = generateCurvePreview(prevPoint, newPoint, pos);
            if (props.layerId) {
              const dx = layerPos.x - rawNewPointX;
              const dy = layerPos.y - rawNewPointY;
              if (Math.sqrt(dx * dx + dy * dy) > 5) {
                store.updateSplineControlPoint(props.layerId, newPoint.id, {
                  handleOut: { x: layerPos.x, y: layerPos.y },
                  handleIn: { x: rawNewPointX - dx, y: rawNewPointY - dy },
                  type: "smooth"
                });
              }
            }
          } else if (newPoint && prevPointIndex < 0) {
            if (props.layerId) {
              const dx = layerPos.x - rawNewPointX;
              const dy = layerPos.y - rawNewPointY;
              if (Math.sqrt(dx * dx + dy * dy) > 5) {
                store.updateSplineControlPoint(props.layerId, newPoint.id, {
                  handleOut: { x: layerPos.x, y: layerPos.y },
                  handleIn: { x: rawNewPointX - dx, y: rawNewPointY - dy },
                  type: "smooth"
                });
              }
            }
          }
        }
      } else if (!props.isPenMode || penSubMode.value !== "add") {
        previewCurve.value = null;
      }
      if (canClosePath.value && visibleControlPoints.value.length > 0) {
        const firstPoint = visibleControlPoints.value[0];
        const dx = pos.x - firstPoint.x;
        const dy = pos.y - firstPoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        closePathPreview.value = dist < CLOSE_THRESHOLD;
      } else {
        closePathPreview.value = false;
      }
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (!layer || !isSplineOrPathType(layer.type)) return;
        const layerData = layer.data;
        const point = layerData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
        if (!point) return;
        const layerPos = inverseTransformPoint(pos);
        if (dragTarget.value.type === "point") {
          const dx = layerPos.x - point.x;
          const dy = layerPos.y - point.y;
          const updates = { x: layerPos.x, y: layerPos.y };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + dx, y: point.handleIn.y + dy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + dx, y: point.handleOut.y + dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "handleIn") {
          const updates = { handleIn: { x: layerPos.x, y: layerPos.y } };
          if (point.type === "smooth") {
            const dx = layerPos.x - point.x;
            const dy = layerPos.y - point.y;
            updates.handleOut = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "in", layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "handleOut") {
          const updates = { handleOut: { x: layerPos.x, y: layerPos.y } };
          if (point.type === "smooth") {
            const dx = layerPos.x - point.x;
            const dy = layerPos.y - point.y;
            updates.handleIn = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "out", layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "depth") {
          const screenDy = event.clientY - (dragTarget.value.screenStartY ?? event.clientY);
          const depthScale = 2;
          const newDepth = Math.max(0, (dragTarget.value.startDepth ?? 0) - screenDy * depthScale);
          store.updateSplineControlPoint(props.layerId, point.id, { depth: newDepth });
        } else if (dragTarget.value.type === "axisX") {
          const screenDx = event.clientX - (dragTarget.value.screenStartX ?? event.clientX);
          const dx = screenDx;
          const newX = (dragTarget.value.originalX ?? point.x) + dx;
          const handleDx = newX - point.x;
          const updates = { x: newX };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + handleDx, y: point.handleIn.y };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + handleDx, y: point.handleOut.y };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, newX, point.y);
        } else if (dragTarget.value.type === "axisY") {
          const screenDy = event.clientY - (dragTarget.value.screenStartY ?? event.clientY);
          const dy = screenDy;
          const newY = (dragTarget.value.originalY ?? point.y) + dy;
          const handleDy = newY - point.y;
          const updates = { y: newY };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x, y: point.handleIn.y + handleDy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x, y: point.handleOut.y + handleDy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, point.x, newY);
        }
        emit("pathUpdated");
      }
    }
    function handleMouseUp() {
      previewCurve.value = null;
      if (dragTarget.value && props.layerId) {
        if (dragTarget.value.type === "newPoint") {
          dragTarget.value = null;
          emit("pathUpdated");
          return;
        }
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && isSplineOrPathType(layer.type)) {
          const layerData = layer.data;
          const point = layerData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
          if (point && point.handleOut && dragTarget.value.type === "handleOut") {
            const dx = point.handleOut.x - point.x;
            const dy = point.handleOut.y - point.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) {
              store.updateSplineControlPoint(props.layerId, point.id, {
                type: "smooth",
                handleIn: { x: point.x - dx, y: point.y - dy }
              });
            } else {
              store.updateSplineControlPoint(props.layerId, point.id, {
                handleOut: null
              });
            }
          }
        }
        dragTarget.value = null;
        emit("pathUpdated");
      }
    }
    function handleRightClick(event) {
      event.preventDefault();
      event.stopPropagation();
      if (!props.layerId) return;
      if (props.isPenMode) {
        emit("togglePenMode");
        previewCurve.value = null;
        previewPoint.value = null;
        insertPreviewPoint.value = null;
        closePathPreview.value = false;
        hoverFeedback.value = null;
        hoveredPointId.value = null;
      }
    }
    function handlePointClick(pointId, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      if (props.isPenMode) {
        if (penSubMode.value === "delete") {
          if (props.layerId) {
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
            hoveredPointId.value = null;
            hoverFeedback.value = null;
          }
          return;
        } else if (penSubMode.value === "convert") {
          if (props.layerId) {
            const newType = point.type === "smooth" ? "corner" : "smooth";
            if (newType === "corner") {
              store.updateSplineControlPoint(props.layerId, pointId, {
                type: "corner",
                handleIn: null,
                handleOut: null
              });
            } else {
              const handleOffset = 30;
              store.updateSplineControlPoint(props.layerId, pointId, {
                type: "smooth",
                handleIn: { x: point.x - handleOffset, y: point.y },
                handleOut: { x: point.x + handleOffset, y: point.y }
              });
            }
            selectedPointId.value = pointId;
            emit("pathUpdated");
          }
          return;
        }
      }
      if (event.shiftKey) {
        if (selectedPointIds.value.includes(pointId)) {
          selectedPointIds.value = selectedPointIds.value.filter((id) => id !== pointId);
        } else {
          selectedPointIds.value = [...selectedPointIds.value, pointId];
        }
        selectedPointId.value = pointId;
      } else {
        selectedPointId.value = pointId;
        selectedPointIds.value = [pointId];
      }
      if (!props.isPenMode) {
        const pos = getMousePos(event);
        dragTarget.value = {
          type: "point",
          pointId,
          startX: pos.x,
          startY: pos.y
        };
      }
    }
    function handlePointHover(pointId) {
      hoveredPointId.value = pointId;
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (props.isPenMode && point) {
        hoverFeedbackPos.value = { x: point.x, y: point.y };
        if (penSubMode.value === "delete") {
          hoverFeedback.value = "Click to delete point";
        } else if (penSubMode.value === "convert") {
          const currentType = point.type === "smooth" ? "smooth" : "corner";
          const newType = currentType === "smooth" ? "corner" : "smooth";
          hoverFeedback.value = `Click to convert to ${newType}`;
        } else {
          hoverFeedback.value = null;
        }
      } else {
        hoverFeedback.value = null;
      }
    }
    function handlePointLeave() {
      hoveredPointId.value = null;
      hoverFeedback.value = null;
      hoverFeedbackPos.value = null;
    }
    function startDragHandle(pointId, handleType, event) {
      const pos = getMousePos(event);
      dragTarget.value = {
        type: handleType === "in" ? "handleIn" : "handleOut",
        pointId,
        startX: pos.x,
        startY: pos.y
      };
    }
    function startDragAxis(pointId, axis, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      const pos = getMousePos(event);
      selectedPointId.value = pointId;
      dragTarget.value = {
        type: axis === "X" ? "axisX" : "axisY",
        pointId,
        startX: pos.x,
        startY: pos.y,
        originalX: point.x,
        originalY: point.y,
        // Store screen coordinates for zoom-independent movement
        screenStartX: event.clientX,
        screenStartY: event.clientY
      };
    }
    function handleKeyDown(event) {
      if (event.key === "Delete" || event.key === "Backspace") {
        if (selectedPointId.value && props.layerId) {
          const layer = store.layers.find((l) => l.id === props.layerId);
          if (layer && isSplineOrPathType(layer.type)) {
            const pointId = selectedPointId.value;
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
            selectedPointIds.value = [];
          }
        }
      }
      if (event.key === "ArrowUp" && selectedPointId.value) {
        event.preventDefault();
        const delta = event.shiftKey ? 100 : 10;
        adjustSelectedPointDepth(delta);
      }
      if (event.key === "ArrowDown" && selectedPointId.value) {
        event.preventDefault();
        const delta = event.shiftKey ? -100 : -10;
        adjustSelectedPointDepth(delta);
      }
      if (event.key === "Escape") {
        selectedPointId.value = null;
        selectedPointIds.value = [];
        hoverFeedback.value = null;
        if (props.isPenMode) {
          emit("togglePenMode");
        }
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    __expose({
      selectedPointId,
      selectedPointIds,
      clearSelection: () => {
        selectedPointId.value = null;
        selectedPointIds.value = [];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        __props.layerId && __props.isPenMode ? (openBlock(), createElementBlock("div", _hoisted_2$i, toDisplayString(activeToolTip.value), 1)) : createCommentVNode("", true),
        hoverFeedback.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "hover-feedback",
          style: normalizeStyle(hoverFeedbackStyle.value)
        }, toDisplayString(hoverFeedback.value), 5)) : createCommentVNode("", true),
        __props.layerId ? (openBlock(), createElementBlock("div", _hoisted_3$i, [
          createBaseVNode("div", _hoisted_4$i, [
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "add" }]),
              onClick: _cache[0] || (_cache[0] = ($event) => setPenSubMode("add")),
              title: "Pen Tool (P) - Add points at end of path"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("svg", {
                viewBox: "0 0 24 24",
                width: "14",
                height: "14"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"
                })
              ], -1),
              createBaseVNode("span", { class: "tool-label" }, "Pen", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "insert" }]),
              onClick: _cache[1] || (_cache[1] = ($event) => setPenSubMode("insert")),
              title: "Add Point (+) - Click on path to insert point"
            }, [..._cache[6] || (_cache[6] = [
              createStaticVNode('<svg viewBox="0 0 24 24" width="14" height="14" data-v-eef11fe4><path fill="currentColor" d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" data-v-eef11fe4></path><circle cx="18" cy="18" r="5" fill="#1e1e1e" data-v-eef11fe4></circle><path fill="currentColor" d="M18,15v6M15,18h6" stroke="currentColor" stroke-width="1.5" data-v-eef11fe4></path></svg><span class="tool-label" data-v-eef11fe4>Pen+</span>', 2)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "delete" }]),
              onClick: _cache[2] || (_cache[2] = ($event) => setPenSubMode("delete")),
              title: "Delete Point (-) - Click point to remove"
            }, [..._cache[7] || (_cache[7] = [
              createStaticVNode('<svg viewBox="0 0 24 24" width="14" height="14" data-v-eef11fe4><path fill="currentColor" d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" data-v-eef11fe4></path><circle cx="18" cy="18" r="5" fill="#1e1e1e" data-v-eef11fe4></circle><path fill="currentColor" d="M15,18h6" stroke="currentColor" stroke-width="1.5" data-v-eef11fe4></path></svg><span class="tool-label" data-v-eef11fe4>Pen-</span>', 2)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "convert" }]),
              onClick: _cache[3] || (_cache[3] = ($event) => setPenSubMode("convert")),
              title: "Convert Point (^) - Click to toggle smooth/corner"
            }, [..._cache[8] || (_cache[8] = [
              createBaseVNode("svg", {
                viewBox: "0 0 24 24",
                width: "14",
                height: "14"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M12,2L6,8H9V14H6L12,20L18,14H15V8H18L12,2Z",
                  transform: "rotate(180 12 11)"
                })
              ], -1),
              createBaseVNode("span", { class: "tool-label" }, "Convert", -1)
            ])], 2)
          ]),
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "toolbar-separator" }, null, -1)),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_5$i, [
            createBaseVNode("button", {
              class: "toolbar-btn",
              onClick: smoothSelectedPoints,
              title: selectedPointIds.value.length > 0 ? "Smooth selected points" : "Smooth all path handles"
            }, " Smooth" + toDisplayString(selectedPointIds.value.length > 0 ? ` (${selectedPointIds.value.length})` : ""), 9, _hoisted_6$i),
            createBaseVNode("button", {
              class: "toolbar-btn",
              onClick: simplifySpline,
              title: "Simplify path (reduce control points)"
            }, " Simplify "),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn", { active: isClosed.value }]),
              onClick: toggleClosePath,
              title: "Toggle closed path"
            }, toDisplayString(isClosed.value ? "Open" : "Close"), 3)
          ])) : createCommentVNode("", true),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_7$i, [
            createBaseVNode("label", _hoisted_8$h, [
              _cache[9] || (_cache[9] = createTextVNode(" Tolerance: ", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => smoothTolerance.value = $event),
                min: "1",
                max: "50",
                step: "1",
                class: "tolerance-slider"
              }, null, 512), [
                [
                  vModelText,
                  smoothTolerance.value,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$h, toDisplayString(smoothTolerance.value) + "px", 1)
            ])
          ])) : createCommentVNode("", true),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_10$g, toDisplayString(visibleControlPoints.value.length) + " points" + toDisplayString(selectedPointIds.value.length > 0 ? ` (${selectedPointIds.value.length} selected)` : ""), 1)) : createCommentVNode("", true),
          selectedPointId.value ? (openBlock(), createElementBlock("div", _hoisted_11$f, [
            createBaseVNode("label", _hoisted_12$e, [
              _cache[10] || (_cache[10] = createTextVNode(" Z: ", -1)),
              createBaseVNode("input", {
                type: "number",
                value: selectedPointDepth.value,
                onInput: updateSelectedPointDepth,
                class: "z-depth-input",
                step: "10"
              }, null, 40, _hoisted_13$e)
            ]),
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "z-depth-hint" }, "(/ keys)", -1))
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(), createElementBlock("svg", {
          class: "control-overlay",
          viewBox: `0 0 ${__props.canvasWidth} ${__props.canvasHeight}`,
          style: normalizeStyle(overlayStyle.value),
          onMousedown: handleMouseDown,
          onMousemove: handleMouseMove,
          onMouseup: handleMouseUp,
          onMouseleave: handleMouseUp,
          onContextmenu: handleRightClick
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handles-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 0,
                x1: point.x,
                y1: point.y,
                x2: point.handleIn.x,
                y2: point.handleIn.y,
                class: "handle-line",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_15$b)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 1,
                x1: point.x,
                y1: point.y,
                x2: point.handleOut.x,
                y2: point.handleOut.y,
                class: "handle-line",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_16$a)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handle-points-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.handleIn.x,
                cy: point.handleIn.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleIn" && dragTarget.value.pointId === point.id }]),
                style: normalizeStyle({ fill: strokeColor.value }),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "in", $event), ["stop"])
              }, null, 46, _hoisted_17$a)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 1,
                cx: point.handleOut.x,
                cy: point.handleOut.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleOut" && dragTarget.value.pointId === point.id }]),
                style: normalizeStyle({ fill: strokeColor.value }),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "out", $event), ["stop"])
              }, null, 46, _hoisted_18$a)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock("g", {
              key: `point-${point.id}`
            }, [
              pointHasKeyframes(point.id) ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.x,
                cy: point.y,
                r: "8",
                class: "keyframe-indicator",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_19$a)) : createCommentVNode("", true),
              createBaseVNode("circle", {
                cx: point.x,
                cy: point.y,
                r: "5",
                class: normalizeClass(["control-point", {
                  selected: selectedPointId.value === point.id || selectedPointIds.value.includes(point.id),
                  corner: point.type === "corner",
                  smooth: point.type === "smooth",
                  keyframed: pointHasKeyframes(point.id),
                  "will-delete": __props.isPenMode && penSubMode.value === "delete" && hoveredPointId.value === point.id,
                  "will-convert": __props.isPenMode && penSubMode.value === "convert" && hoveredPointId.value === point.id
                }]),
                style: normalizeStyle({ fill: strokeColor.value, stroke: "#ffffff" }),
                onMousedown: withModifiers(($event) => handlePointClick(point.id, $event), ["stop"]),
                onMouseenter: ($event) => handlePointHover(point.id),
                onMouseleave: handlePointLeave
              }, null, 46, _hoisted_20$a),
              selectedPointId.value === point.id && !props.isPenMode ? (openBlock(), createElementBlock("g", _hoisted_21$a, [
                createBaseVNode("circle", {
                  cx: point.x,
                  cy: point.y,
                  r: "10",
                  class: "selection-ring",
                  style: normalizeStyle({ stroke: strokeColor.value })
                }, null, 12, _hoisted_22$9),
                createBaseVNode("g", _hoisted_23$9, [
                  createBaseVNode("line", {
                    x1: point.x + 12,
                    y1: point.y,
                    x2: point.x + 35,
                    y2: point.y,
                    class: "axis-line axis-x"
                  }, null, 8, _hoisted_24$7),
                  createBaseVNode("polygon", {
                    points: `${point.x + 40},${point.y} ${point.x + 33},${point.y - 4} ${point.x + 33},${point.y + 4}`,
                    class: "axis-arrow axis-x"
                  }, null, 8, _hoisted_25$7),
                  createBaseVNode("rect", {
                    x: point.x + 12,
                    y: point.y - 8,
                    width: "30",
                    height: "16",
                    class: "axis-hit-area",
                    onMousedown: withModifiers(($event) => startDragAxis(point.id, "X", $event), ["stop"])
                  }, null, 40, _hoisted_26$7)
                ]),
                createBaseVNode("g", _hoisted_27$7, [
                  createBaseVNode("line", {
                    x1: point.x,
                    y1: point.y + 12,
                    x2: point.x,
                    y2: point.y + 35,
                    class: "axis-line axis-y"
                  }, null, 8, _hoisted_28$6),
                  createBaseVNode("polygon", {
                    points: `${point.x},${point.y + 40} ${point.x - 4},${point.y + 33} ${point.x + 4},${point.y + 33}`,
                    class: "axis-arrow axis-y"
                  }, null, 8, _hoisted_29$6),
                  createBaseVNode("rect", {
                    x: point.x - 8,
                    y: point.y + 12,
                    width: "16",
                    height: "30",
                    class: "axis-hit-area",
                    onMousedown: withModifiers(($event) => startDragAxis(point.id, "Y", $event), ["stop"])
                  }, null, 40, _hoisted_30$5)
                ])
              ])) : createCommentVNode("", true),
              selectedPointId.value === point.id && is3DLayer.value ? (openBlock(), createElementBlock("g", _hoisted_31$5, [
                createBaseVNode("line", {
                  x1: point.x + 15,
                  y1: point.y - 30,
                  x2: point.x + 15,
                  y2: point.y + 30,
                  class: "z-axis-line"
                }, null, 8, _hoisted_32$5),
                createBaseVNode("polygon", {
                  points: `${point.x + 15},${point.y - 35} ${point.x + 12},${point.y - 28} ${point.x + 18},${point.y - 28}`,
                  class: "z-arrow"
                }, null, 8, _hoisted_33$5),
                createBaseVNode("polygon", {
                  points: `${point.x + 15},${point.y + 35} ${point.x + 12},${point.y + 28} ${point.x + 18},${point.y + 28}`,
                  class: "z-arrow"
                }, null, 8, _hoisted_34$5),
                createBaseVNode("polygon", {
                  points: getZHandlePoints(point),
                  class: normalizeClass(["z-handle", { active: dragTarget.value?.type === "depth" && dragTarget.value.pointId === point.id }]),
                  onMousedown: withModifiers(($event) => startDragDepth(point.id, $event), ["stop"])
                }, null, 42, _hoisted_35$4),
                createBaseVNode("text", {
                  x: point.x + 25,
                  y: point.y + getDepthOffset(point),
                  class: "z-label"
                }, " Z: " + toDisplayString(getPointDepth(point).toFixed(0)), 9, _hoisted_36$3)
              ])) : createCommentVNode("", true)
            ]);
          }), 128)),
          previewCurve.value ? (openBlock(), createElementBlock("path", {
            key: 0,
            d: previewCurve.value,
            class: "preview-curve",
            fill: "none"
          }, null, 8, _hoisted_37$3)) : createCommentVNode("", true),
          previewPoint.value && __props.isPenMode ? (openBlock(), createElementBlock("circle", {
            key: 1,
            cx: previewPoint.value.x,
            cy: previewPoint.value.y,
            r: "4",
            class: "preview-point"
          }, null, 8, _hoisted_38$3)) : createCommentVNode("", true),
          insertPreviewPoint.value && penSubMode.value === "insert" ? (openBlock(), createElementBlock("circle", {
            key: 2,
            cx: insertPreviewPoint.value.x,
            cy: insertPreviewPoint.value.y,
            r: "5",
            class: "insert-preview-point"
          }, null, 8, _hoisted_39$3)) : createCommentVNode("", true),
          canClosePath.value && closePathPreview.value ? (openBlock(), createElementBlock("circle", {
            key: 3,
            cx: visibleControlPoints.value[0].x,
            cy: visibleControlPoints.value[0].y,
            r: "10",
            class: "close-indicator"
          }, null, 8, _hoisted_40$2)) : createCommentVNode("", true)
        ], 44, _hoisted_14$c))
      ]);
    };
  }
});

const SplineEditor = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-eef11fe4"]]);

const _hoisted_1$h = {
  key: 1,
  class: "overlay-controls"
};
const _hoisted_2$h = { class: "viewer-controls" };
const _hoisted_3$h = { class: "zoom-display" };
const _hoisted_4$h = {
  key: 2,
  class: "loading-overlay"
};
const _hoisted_5$h = ["src"];
const _hoisted_6$h = {
  key: 5,
  class: "segment-loading"
};
const _hoisted_7$h = { class: "render-mode-controls" };
const _hoisted_8$g = { class: "transform-mode-controls" };
const _hoisted_9$g = {
  key: 7,
  class: "safe-frame-container"
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "ThreeCanvas",
  setup(__props, { expose: __expose }) {
    const store = useCompositorStore();
    const containerRef = ref(null);
    const canvasRef = ref(null);
    const splineEditorRef = ref(null);
    const engine = shallowRef(null);
    const loading = ref(false);
    const zoom = ref(1);
    const canvasWidth = ref(800);
    const canvasHeight = ref(600);
    const compositionWidth = computed(() => store.width || 832);
    const compositionHeight = computed(() => store.height || 480);
    const showDepthOverlay = ref(false);
    const depthColormap = ref("viridis");
    const depthOpacity = ref(50);
    const renderMode = ref("color");
    const showPerformance = ref(false);
    const performanceStats = ref({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    const viewportTransform = ref([1, 0, 0, 1, 0, 0]);
    const cameraUpdateTrigger = ref(0);
    const zoomLevel = ref("fit");
    const resolution = ref("full");
    const zoomDisplayPercent = computed(() => Math.round(zoom.value * 100));
    const transformMode = ref("translate");
    const showGrid = ref(true);
    ref(false);
    const showSafeFrameGuides = ref(false);
    const isDrawingSegmentBox = ref(false);
    const segmentBoxEnd = ref(null);
    const maskOverlayStyle = computed(() => {
      const mask = store.segmentPendingMask;
      if (!mask) return {};
      const vpt = viewportTransform.value;
      const screenX = mask.bounds.x * vpt[0] + vpt[4];
      const screenY = mask.bounds.y * vpt[3] + vpt[5];
      const screenWidth = mask.bounds.width * vpt[0];
      const screenHeight = mask.bounds.height * vpt[3];
      return {
        left: `${screenX}px`,
        top: `${screenY}px`,
        width: `${screenWidth}px`,
        height: `${screenHeight}px`
      };
    });
    const segmentBoxStyle = computed(() => {
      const start = store.segmentBoxStart;
      const end = segmentBoxEnd.value;
      if (!start || !end) return {};
      const vpt = viewportTransform.value;
      const x1 = start.x * vpt[0] + vpt[4];
      const y1 = start.y * vpt[3] + vpt[5];
      const x2 = end.x * vpt[0] + vpt[4];
      const y2 = end.y * vpt[3] + vpt[5];
      return {
        left: `${Math.min(x1, x2)}px`,
        top: `${Math.min(y1, y2)}px`,
        width: `${Math.abs(x2 - x1)}px`,
        height: `${Math.abs(y2 - y1)}px`
      };
    });
    const safeFrameBounds = computed(() => {
      if (!containerRef.value || !engine.value) {
        console.log("[ThreeCanvas] safeFrameBounds: no container or engine");
        return { left: 0, top: 0, right: 0, bottom: 0 };
      }
      const viewportWidth = canvasWidth.value;
      const viewportHeight = canvasHeight.value;
      const compWidth = store.width || 1920;
      const compHeight = store.height || 1080;
      if (viewportWidth <= 0 || viewportHeight <= 0) {
        console.log("[ThreeCanvas] safeFrameBounds: invalid viewport dimensions", viewportWidth, viewportHeight);
        return { left: 0, top: 0, right: 0, bottom: 0 };
      }
      const camera = engine.value.getCameraController().camera;
      camera.updateMatrixWorld(true);
      camera.updateProjectionMatrix();
      const topLeft = new Vector3(0, 0, 0);
      const bottomRight = new Vector3(compWidth, -compHeight, 0);
      topLeft.project(camera);
      bottomRight.project(camera);
      const left = (topLeft.x + 1) / 2 * viewportWidth;
      const top = (-topLeft.y + 1) / 2 * viewportHeight;
      const right = (bottomRight.x + 1) / 2 * viewportWidth;
      const bottom = (-bottomRight.y + 1) / 2 * viewportHeight;
      console.log("[ThreeCanvas] safeFrameBounds:", { left, top, right, bottom, viewportWidth, viewportHeight, compWidth, compHeight });
      return { left, top, right, bottom };
    });
    const safeFrameLeftStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: "0",
        top: "0",
        width: `${Math.max(0, bounds.left)}px`,
        height: "100%"
      };
    });
    const safeFrameRightStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${bounds.right}px`,
        top: "0",
        width: `calc(100% - ${bounds.right}px)`,
        height: "100%"
      };
    });
    const safeFrameTopStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: "0",
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `${Math.max(0, bounds.top)}px`
      };
    });
    const safeFrameBottomStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: `${bounds.bottom}px`,
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `calc(100% - ${bounds.bottom}px)`
      };
    });
    const compositionBoundaryStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      if (width <= 0 || height <= 0) {
        return { display: "none" };
      }
      return {
        left: `${bounds.left}px`,
        top: `${bounds.top}px`,
        width: `${width}px`,
        height: `${height}px`
      };
    });
    const hasDepthMap = computed(() => store.depthMap !== null);
    const isPenMode = computed(() => store.currentTool === "pen");
    const activeSplineLayerId = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "spline") {
        return selectedLayer.id;
      }
      if (isPenMode.value) {
        const splines = store.layers.filter((l) => l.type === "spline");
        return splines.length > 0 ? splines[splines.length - 1].id : null;
      }
      return null;
    });
    const viewportTransformArray = computed(() => viewportTransform.value);
    onMounted(async () => {
      if (!canvasRef.value || !containerRef.value) return;
      const container = containerRef.value;
      const rect = container.getBoundingClientRect();
      canvasWidth.value = rect.width;
      canvasHeight.value = rect.height;
      const config = {
        canvas: canvasRef.value,
        width: rect.width,
        height: rect.height,
        compositionWidth: store.width || 1920,
        compositionHeight: store.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: true,
        alpha: true,
        backgroundColor: store.backgroundColor || "#050505",
        powerPreference: "high-performance"
      };
      try {
        loading.value = true;
        engine.value = new WeylEngine(config);
        engine.value.setAssetGetter((assetId) => store.assets[assetId]);
        engine.value.setVideoMetadataCallback((layerId, metadata) => {
          store.onVideoMetadataLoaded(layerId, metadata);
        });
        engine.value.setCameraCallbacks(
          (cameraId) => store.getCamera(cameraId),
          (cameraId, updates) => store.updateCamera(cameraId, updates),
          (cameraId, frame) => store.getCameraAtFrame(cameraId, frame)
        );
        engine.value.setNestedCompRenderContext({
          renderComposition: (compositionId, frame) => {
            const comp = store.getComposition(compositionId);
            if (!comp) {
              console.warn("[ThreeCanvas] Nested comp not found:", compositionId);
              return null;
            }
            if (!comp.layers || comp.layers.length === 0) {
              return null;
            }
            return engine.value.renderCompositionToTexture(
              compositionId,
              comp.layers,
              {
                width: comp.settings.width,
                height: comp.settings.height,
                fps: comp.settings.fps
              },
              frame
            );
          },
          getComposition: (compositionId) => store.getComposition(compositionId)
        });
        engine.value.setAudioReactiveCallback(
          (layerId, frame) => store.getAudioReactiveValuesForLayer(layerId, frame)
        );
        engine.value.initializeTransformControls();
        engine.value.setTransformChangeCallback((layerId, transform) => {
          handleTransformChange(layerId, transform);
        });
        engine.value.initializeParticleSystems();
        engine.value.setCompositionFPS(store.fps || 60);
        engine.value.initialize3DServices();
        engine.value.enableOrbitControls();
        engine.value.resetCameraToDefault();
        engine.value.start();
        await nextTick();
        syncLayersToEngine();
        store.initializePropertyDriverSystem();
        const initialFrameState = store.getFrameState(store.currentFrame);
        engine.value.applyFrameState(initialFrameState);
        setupInputHandlers();
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(container);
        centerOnComposition();
      } catch (err) {
        console.error("[ThreeCanvas] Failed to initialize engine:", err);
      } finally {
        loading.value = false;
      }
      setupWatchers();
    });
    onUnmounted(() => {
      if (engine.value) {
        engine.value.stop();
        engine.value.dispose();
        engine.value = null;
      }
    });
    function setupWatchers() {
      watch(
        () => store.layers,
        () => {
          syncLayersToEngine();
          if (engine.value) {
            const frameState = store.getFrameState(store.currentFrame);
            engine.value.applyFrameState(frameState);
          }
        },
        { deep: true }
      );
      watch(
        () => store.currentFrame,
        (frame) => {
          if (engine.value) {
            applyPropertyDrivers();
            const frameState = store.getFrameState(frame);
            engine.value.applyFrameState(frameState);
          }
        }
      );
      watch(
        () => [store.width, store.height],
        ([width, height]) => {
          if (engine.value) {
            engine.value.resize(canvasWidth.value, canvasHeight.value, width, height);
            centerOnComposition();
          }
        }
      );
      watch(
        () => store.sourceImage,
        async (imageData) => {
          if (engine.value && imageData) {
            await loadSourceImage(imageData);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.depthMap,
        async (depthData) => {
          if (engine.value && depthData) {
            await loadDepthMap(depthData);
          }
        },
        { immediate: true }
      );
      watch(
        () => engine.value?.getPerformanceStats(),
        (stats) => {
          if (stats) {
            performanceStats.value = stats;
          }
        }
      );
      watch(
        () => store.activeCameraId,
        (activeCameraId) => {
          if (!engine.value) return;
          if (!activeCameraId) {
            engine.value.setActiveCameraLayer(null);
            return;
          }
          const cameraLayer = store.layers.find(
            (l) => l.type === "camera" && l.data?.cameraId === activeCameraId
          );
          if (cameraLayer) {
            engine.value.setActiveCameraLayer(cameraLayer.id);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.selectedLayerIds,
        (selectedIds) => {
          if (!engine.value) return;
          const selectedId = selectedIds.length > 0 ? selectedIds[0] : null;
          engine.value.selectLayer(selectedId);
        },
        { deep: true }
      );
      watch(
        () => store.viewOptions.showGrid,
        (showGridVisible) => {
          if (!engine.value) return;
          showGrid.value = showGridVisible;
          engine.value.setCompositionGridVisible(showGridVisible);
        },
        { immediate: true }
      );
      watch(
        () => store.viewOptions.showCompositionBounds,
        (_showBounds) => {
          if (!engine.value) return;
          engine.value.setCompositionBoundsVisible(false);
        },
        { immediate: true }
      );
      watch(
        () => store.backgroundColor,
        (newColor) => {
          if (!engine.value) return;
          engine.value.setBackground(newColor);
        }
      );
    }
    function syncLayersToEngine() {
      if (!engine.value) return;
      const engineLayerIds = new Set(engine.value.getLayerIds());
      const storeLayerIds = new Set(store.layers.map((l) => l.id));
      for (const id of engineLayerIds) {
        if (!storeLayerIds.has(id)) {
          engine.value.removeLayer(id);
        }
      }
      for (const layer of store.layers) {
        if (engineLayerIds.has(layer.id)) {
          engine.value.updateLayer(layer.id, layer);
        } else {
          engine.value.addLayer(layer);
        }
      }
    }
    function applyPropertyDrivers() {
      if (!engine.value) return;
      engine.value.clearAllDrivenValues();
      for (const layer of store.layers) {
        const drivenValues = store.getDrivenValuesForLayer(layer.id);
        if (drivenValues.size > 0) {
          engine.value.setLayerDrivenValues(layer.id, drivenValues);
        }
      }
    }
    async function loadSourceImage(imageData) {
      if (!engine.value) return;
      try {
        loading.value = true;
        const img = await loadImage(imageData);
        engine.value.setBackgroundImage(img);
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load source image:", err);
      } finally {
        loading.value = false;
      }
    }
    async function loadDepthMap(depthData) {
      if (!engine.value) return;
      try {
        const img = await loadImage(depthData);
        engine.value.setDepthMap(img, {
          colormap: depthColormap.value,
          opacity: depthOpacity.value / 100,
          visible: showDepthOverlay.value
        });
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load depth map:", err);
      }
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
      });
    }
    function setupInputHandlers() {
      const container = containerRef.value;
      const canvas = canvasRef.value;
      if (!container || !canvas) return;
      let isPanning = false;
      let isZooming = false;
      let lastPosX = 0;
      let lastPosY = 0;
      let zoomStartY = 0;
      let zoomStartLevel = 1;
      container.addEventListener("mousedown", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("auxclick", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        let newZoom = zoom.value * (delta > 0 ? 0.9 : 1.1);
        newZoom = Math.min(Math.max(newZoom, 0.1), 10);
        zoom.value = newZoom;
        viewportTransform.value[0] = newZoom;
        viewportTransform.value[3] = newZoom;
        if (engine.value) {
          engine.value.getCameraController().setZoom(newZoom);
          cameraUpdateTrigger.value++;
        }
      }, { passive: false });
      canvas.addEventListener("mousedown", (e) => {
        const currentTool = store.currentTool;
        if (e.button === 1 || currentTool === "hand" || e.button === 0 && e.altKey) {
          isPanning = true;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          canvas.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }
        if (currentTool === "zoom") {
          if (e.shiftKey) {
            const newZoom = Math.max(zoom.value * 0.7, 0.1);
            zoom.value = newZoom;
            viewportTransform.value[0] = newZoom;
            viewportTransform.value[3] = newZoom;
            if (engine.value) {
              engine.value.setViewportTransform(viewportTransform.value);
            }
          } else {
            isZooming = true;
            zoomStartY = e.clientY;
            zoomStartLevel = zoom.value;
          }
          return;
        }
        if (currentTool === "text") {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          const newLayer = store.createLayer("text");
          if (newLayer.transform?.position) {
            newLayer.transform.position.value = { x: scenePos.x, y: scenePos.y, z: 0 };
          }
          store.updateLayer(newLayer.id, {
            transform: {
              ...newLayer.transform,
              position: {
                ...newLayer.transform.position,
                value: { x: scenePos.x, y: scenePos.y, z: 0 }
              }
            }
          });
          store.selectLayer(newLayer.id);
          store.setTool("select");
          return;
        }
        if (currentTool === "segment" && e.button === 0) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          if (store.segmentMode === "point") {
            handleSegmentPoint(scenePos.x, scenePos.y);
          } else {
            store.setSegmentBoxStart({ x: scenePos.x, y: scenePos.y });
            segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
            isDrawingSegmentBox.value = true;
          }
          return;
        }
        if (currentTool === "select" && e.button === 0) {
          if (engine.value?.isTransformDragging()) {
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          if (engine.value) {
            const hitLayer = engine.value.raycastLayers(x, y);
            if (hitLayer) {
              store.selectLayer(hitLayer);
              engine.value.selectLayer(hitLayer);
            } else {
              store.clearSelection();
              engine.value.selectLayer(null);
            }
          }
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isPanning && engine.value) {
          const dx = e.clientX - lastPosX;
          const dy = e.clientY - lastPosY;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          const camera = engine.value.getCameraController();
          const currentPan = camera.getPan();
          const compHeight = store.height || 1080;
          const fovRad = Math.PI * camera.getFOV() / 180;
          const distance = compHeight / 2 / Math.tan(fovRad / 2) / zoom.value;
          const viewHeight = 2 * distance * Math.tan(fovRad / 2);
          const container2 = containerRef.value;
          if (container2) {
            const rect = container2.getBoundingClientRect();
            const worldPerPixel = viewHeight / rect.height;
            camera.setPan(
              currentPan.x - dx * worldPerPixel,
              currentPan.y - dy * worldPerPixel
              // Positive dy should move camera up (view shifts down)
            );
            cameraUpdateTrigger.value++;
          }
          return;
        }
        if (isZooming && engine.value) {
          const dy = zoomStartY - e.clientY;
          const zoomFactor = 1 + dy * 0.01;
          const newZoom = Math.max(0.1, Math.min(10, zoomStartLevel * zoomFactor));
          zoom.value = newZoom;
          viewportTransform.value[0] = newZoom;
          viewportTransform.value[3] = newZoom;
          engine.value.getCameraController().setZoom(newZoom);
          cameraUpdateTrigger.value++;
          return;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
          return;
        }
        const currentTool = store.currentTool;
        if (currentTool === "hand") canvas.style.cursor = "grab";
        else if (currentTool === "zoom") canvas.style.cursor = "zoom-in";
        else if (currentTool === "text") canvas.style.cursor = "text";
        else if (currentTool === "pen") canvas.style.cursor = "crosshair";
        else if (currentTool === "segment") canvas.style.cursor = "crosshair";
        else canvas.style.cursor = "default";
      });
      canvas.addEventListener("mouseup", (e) => {
        if (isPanning) {
          isPanning = false;
          canvas.style.cursor = store.currentTool === "hand" ? "grab" : "default";
        }
        if (isZooming) {
          isZooming = false;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart && segmentBoxEnd.value) {
          isDrawingSegmentBox.value = false;
          handleSegmentBox(
            store.segmentBoxStart.x,
            store.segmentBoxStart.y,
            segmentBoxEnd.value.x,
            segmentBoxEnd.value.y
          );
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
        isZooming = false;
        if (isDrawingSegmentBox.value) {
          isDrawingSegmentBox.value = false;
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
    }
    function screenToScene(screenX, screenY) {
      const vpt = viewportTransform.value;
      return {
        x: (screenX - vpt[4]) / vpt[0],
        y: (screenY - vpt[5]) / vpt[3]
      };
    }
    async function handleSegmentPoint(x, y) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      store.setSegmentLoading(true);
      try {
        const result = await segmentByPoint(store.sourceImage, { x, y });
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    async function handleSegmentBox(x1, y1, x2, y2) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      const box = [
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.max(x1, x2),
        Math.max(y1, y2)
      ];
      store.setSegmentLoading(true);
      try {
        const result = await segmentByBox(store.sourceImage, box);
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Box segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Box segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Box segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    function handleTransformChange(layerId, transform) {
      const layer = store.layers.find((l) => l.id === layerId);
      if (!layer) return;
      const updates = {};
      if (transform.position && layer.transform) {
        updates.transform = {
          ...layer.transform,
          position: {
            ...layer.transform.position,
            value: {
              x: transform.position.x,
              y: transform.position.y,
              z: transform.position.z ?? layer.transform.position?.value?.z ?? 0
            }
          }
        };
      }
      if (layer.threeD) {
        if (transform.rotationX !== void 0 || transform.rotationY !== void 0 || transform.rotationZ !== void 0) {
          if (!updates.transform && layer.transform) {
            updates.transform = { ...layer.transform };
          }
          if (updates.transform) {
            if (transform.rotationX !== void 0) {
              updates.transform.rotationX = { ...layer.transform.rotationX, value: transform.rotationX };
            }
            if (transform.rotationY !== void 0) {
              updates.transform.rotationY = { ...layer.transform.rotationY, value: transform.rotationY };
            }
            if (transform.rotationZ !== void 0) {
              updates.transform.rotationZ = { ...layer.transform.rotationZ, value: transform.rotationZ };
            }
          }
        }
      } else {
        if (transform.rotation !== void 0 && layer.transform) {
          if (!updates.transform) {
            updates.transform = { ...layer.transform };
          }
          updates.transform.rotation = { ...layer.transform.rotation, value: transform.rotation };
        }
      }
      if (transform.scale && layer.transform) {
        if (!updates.transform) {
          updates.transform = { ...layer.transform };
        }
        updates.transform.scale = {
          ...layer.transform.scale,
          value: {
            x: transform.scale.x,
            y: transform.scale.y,
            z: transform.scale.z ?? layer.transform.scale?.value?.z ?? 100
          }
        };
      }
      if (Object.keys(updates).length > 0) {
        store.updateLayer(layerId, updates);
      }
    }
    function setTransformModeTo(mode) {
      transformMode.value = mode;
      if (engine.value) {
        engine.value.setTransformMode(mode);
      }
    }
    function handleResize(entries) {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          canvasWidth.value = width;
          canvasHeight.value = height;
          if (engine.value) {
            engine.value.resize(width, height);
            centerOnComposition();
          }
        }
      }
    }
    function centerOnComposition() {
      const container = containerRef.value;
      if (!container || !engine.value) return;
      const padding = 40;
      engine.value.fitCompositionToViewport(padding);
      const camera = engine.value.getCameraController();
      const calculatedZoom = camera.getZoom();
      zoom.value = calculatedZoom;
      viewportTransform.value = [calculatedZoom, 0, 0, calculatedZoom, 0, 0];
      requestAnimationFrame(() => {
        cameraUpdateTrigger.value++;
      });
    }
    function setRenderMode(mode) {
      renderMode.value = mode;
      if (engine.value) {
        engine.value.setRenderMode(mode);
      }
    }
    function onPointAdded(_point) {
      if (!activeSplineLayerId.value) {
        const newLayer = store.createLayer("spline");
        store.selectLayer(newLayer.id);
      }
    }
    function onPathUpdated() {
      syncLayersToEngine();
    }
    function togglePenMode() {
      if (store.currentTool === "pen") {
        store.setTool("select");
      } else {
        store.setTool("pen");
      }
    }
    function zoomIn() {
      const newZoom = Math.min(zoom.value * 1.2, 10);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function zoomOut() {
      const newZoom = Math.max(zoom.value * 0.8, 0.1);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function fitToView() {
      centerOnComposition();
    }
    function resetCamera() {
      if (engine.value) {
        engine.value.resetCameraToDefault();
        centerOnComposition();
      }
    }
    function setZoom(newZoom) {
      newZoom = Math.max(0.1, Math.min(10, newZoom));
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function onZoomSelect() {
      if (zoomLevel.value === "fit") {
        fitToView();
      } else {
        const newZoom = parseFloat(zoomLevel.value);
        if (!isNaN(newZoom)) {
          setZoom(newZoom);
          if (engine.value) {
            engine.value.getCameraController().setZoom(newZoom);
          }
        }
      }
    }
    function onResolutionChange() {
      if (!engine.value) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const fullWidth = comp.settings.width;
      const fullHeight = comp.settings.height;
      let factor = 1;
      switch (resolution.value) {
        case "half":
          factor = 0.5;
          break;
        case "third":
          factor = 1 / 3;
          break;
        case "quarter":
          factor = 0.25;
          break;
        default:
          factor = 1;
      }
      const newWidth = Math.round(fullWidth * factor);
      const newHeight = Math.round(fullHeight * factor);
      engine.value.setResolution(newWidth, newHeight);
      console.log(`[ThreeCanvas] Resolution changed to ${resolution.value}: ${newWidth}x${newHeight}`);
    }
    async function captureFrame() {
      if (!engine.value) return null;
      const result = engine.value.captureFrame();
      if (!result?.imageData) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      ctx.putImageData(result.imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    async function captureDepth() {
      if (!engine.value) return null;
      const result = engine.value.captureDepth();
      if (!result?.depthBuffer) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const imageData = ctx.createImageData(result.width, result.height);
      for (let i = 0; i < result.depthBuffer.length; i++) {
        const value = Math.floor(result.depthBuffer[i] * 255);
        const idx = i * 4;
        imageData.data[idx] = value;
        imageData.data[idx + 1] = value;
        imageData.data[idx + 2] = value;
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    watch(showDepthOverlay, (visible) => {
      if (engine.value) {
        engine.value.setDepthOverlayVisible(visible);
      }
    });
    watch(depthColormap, (colormap) => {
      if (engine.value) {
        engine.value.setDepthColormap(colormap);
      }
    });
    watch(depthOpacity, (opacity) => {
      if (engine.value) {
        engine.value.setDepthOpacity(opacity / 100);
      }
    });
    __expose({
      engine,
      fitToView,
      zoomIn,
      zoomOut,
      zoom,
      setZoom,
      captureFrame,
      captureDepth,
      showPerformance,
      performanceStats,
      renderMode,
      setRenderMode,
      transformMode,
      setTransformModeTo,
      resetCamera
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "three-canvas",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("canvas", {
          ref_key: "canvasRef",
          ref: canvasRef
        }, null, 512),
        activeSplineLayerId.value || isPenMode.value ? (openBlock(), createBlock(SplineEditor, {
          key: 0,
          layerId: activeSplineLayerId.value,
          currentFrame: unref(store).currentFrame,
          canvasWidth: compositionWidth.value,
          canvasHeight: compositionHeight.value,
          containerWidth: canvasWidth.value,
          containerHeight: canvasHeight.value,
          zoom: zoom.value,
          viewportTransform: viewportTransformArray.value,
          isPenMode: isPenMode.value,
          onPointAdded,
          onPathUpdated,
          onTogglePenMode: togglePenMode,
          ref_key: "splineEditorRef",
          ref: splineEditorRef
        }, null, 8, ["layerId", "currentFrame", "canvasWidth", "canvasHeight", "containerWidth", "containerHeight", "zoom", "viewportTransform", "isPenMode"])) : createCommentVNode("", true),
        hasDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_1$h, [
          createBaseVNode("label", null, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showDepthOverlay.value = $event)
            }, null, 512), [
              [vModelCheckbox, showDepthOverlay.value]
            ]),
            _cache[11] || (_cache[11] = createTextVNode(" Depth Overlay ", -1))
          ]),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => depthColormap.value = $event),
            class: "colormap-select"
          }, [..._cache[12] || (_cache[12] = [
            createBaseVNode("option", { value: "viridis" }, "Viridis", -1),
            createBaseVNode("option", { value: "plasma" }, "Plasma", -1),
            createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1)
          ])], 512), [
            [vModelSelect, depthColormap.value]
          ]),
          withDirectives(createBaseVNode("input", {
            type: "range",
            min: "0",
            max: "100",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => depthOpacity.value = $event),
            class: "opacity-slider"
          }, null, 512), [
            [
              vModelText,
              depthOpacity.value,
              void 0,
              { number: true }
            ]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$h, [
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => zoomLevel.value = $event),
            class: "zoom-dropdown",
            onChange: onZoomSelect
          }, [..._cache[13] || (_cache[13] = [
            createStaticVNode('<option value="fit" data-v-366049ef>Fit</option><option value="0.25" data-v-366049ef>25%</option><option value="0.33" data-v-366049ef>33%</option><option value="0.5" data-v-366049ef>50%</option><option value="0.75" data-v-366049ef>75%</option><option value="1" data-v-366049ef>100%</option><option value="2" data-v-366049ef>200%</option><option value="4" data-v-366049ef>400%</option>', 8)
          ])], 544), [
            [vModelSelect, zoomLevel.value]
          ]),
          createBaseVNode("span", _hoisted_3$h, toDisplayString(zoomDisplayPercent.value) + "%", 1),
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "viewer-divider" }, null, -1)),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => resolution.value = $event),
            class: "resolution-dropdown",
            onChange: onResolutionChange
          }, [..._cache[14] || (_cache[14] = [
            createStaticVNode('<option value="full" data-v-366049ef>Full</option><option value="half" data-v-366049ef>Half</option><option value="third" data-v-366049ef>Third</option><option value="quarter" data-v-366049ef>Quarter</option><option value="custom" data-v-366049ef>Custom</option>', 5)
          ])], 544), [
            [vModelSelect, resolution.value]
          ])
        ]),
        loading.value ? (openBlock(), createElementBlock("div", _hoisted_4$h, [..._cache[16] || (_cache[16] = [
          createBaseVNode("div", { class: "loading-spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(store).segmentPendingMask ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "segment-mask-overlay",
          style: normalizeStyle(maskOverlayStyle.value)
        }, [
          createBaseVNode("img", {
            src: "data:image/png;base64," + unref(store).segmentPendingMask.mask,
            class: "mask-preview",
            alt: "Segmentation mask"
          }, null, 8, _hoisted_5$h)
        ], 4)) : createCommentVNode("", true),
        isDrawingSegmentBox.value && unref(store).segmentBoxStart && segmentBoxEnd.value ? (openBlock(), createElementBlock("div", {
          key: 4,
          class: "segment-box-preview",
          style: normalizeStyle(segmentBoxStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        unref(store).segmentIsLoading ? (openBlock(), createElementBlock("div", _hoisted_6$h, [..._cache[17] || (_cache[17] = [
          createBaseVNode("div", { class: "segment-spinner" }, null, -1),
          createBaseVNode("span", null, "Segmenting...", -1)
        ])])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_7$h, [
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "color" }),
            onClick: _cache[5] || (_cache[5] = ($event) => setRenderMode("color")),
            title: "Color Mode"
          }, "", 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "depth" }),
            onClick: _cache[6] || (_cache[6] = ($event) => setRenderMode("depth")),
            title: "Depth Mode"
          }, "", 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "normal" }),
            onClick: _cache[7] || (_cache[7] = ($event) => setRenderMode("normal")),
            title: "Normal Mode"
          }, "", 2)
        ]),
        createBaseVNode("div", _hoisted_8$g, [
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "translate" }),
            onClick: _cache[8] || (_cache[8] = ($event) => setTransformModeTo("translate")),
            title: "Move Tool (W)"
          }, "", 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "rotate" }),
            onClick: _cache[9] || (_cache[9] = ($event) => setTransformModeTo("rotate")),
            title: "Rotate Tool (E)"
          }, "", 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "scale" }),
            onClick: _cache[10] || (_cache[10] = ($event) => setTransformModeTo("scale")),
            title: "Scale Tool (R)"
          }, "", 2)
        ]),
        unref(store).viewOptions.showCompositionBounds !== false ? (openBlock(), createElementBlock("div", {
          key: 6,
          class: "composition-boundary",
          style: normalizeStyle(compositionBoundaryStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        showSafeFrameGuides.value ? (openBlock(), createElementBlock("div", _hoisted_9$g, [
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-left",
            style: normalizeStyle(safeFrameLeftStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-right",
            style: normalizeStyle(safeFrameRightStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-top",
            style: normalizeStyle(safeFrameTopStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-bottom",
            style: normalizeStyle(safeFrameBottomStyle.value)
          }, null, 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const ThreeCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-366049ef"]]);

const useAudioStore = defineStore("audio", {
  state: () => ({
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    loadingState: "idle",
    loadingProgress: 0,
    loadingPhase: "",
    loadingError: null,
    audioContext: null,
    audioSource: null,
    isPlayingAudio: false,
    audioStartTime: 0,
    audioStartOffset: 0,
    peakData: null,
    legacyMappings: /* @__PURE__ */ new Map(),
    reactiveMappings: [],
    reactiveMapper: null
  }),
  getters: {
    isLoaded: (state) => state.audioAnalysis !== null,
    isLoading: (state) => state.loadingState === "decoding" || state.loadingState === "analyzing",
    hasError: (state) => state.loadingState === "error",
    duration: (state) => state.audioBuffer?.duration ?? 0,
    bpm: (state) => state.audioAnalysis?.bpm ?? 0,
    frameCount: (state) => state.audioAnalysis?.frameCount ?? 0
  },
  actions: {
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(file, fps) {
      this.audioFile = file;
      this.audioBuffer = null;
      this.audioAnalysis = null;
      this.loadingState = "decoding";
      this.loadingProgress = 0;
      this.loadingPhase = "Preparing...";
      this.loadingError = null;
      try {
        const result = await loadAndAnalyzeAudio(
          file,
          fps,
          {
            onProgress: (progress) => {
              if (progress.phase === "decoding") {
                this.loadingState = "decoding";
              } else {
                this.loadingState = "analyzing";
              }
              this.loadingProgress = progress.progress;
              this.loadingPhase = progress.message;
            }
          }
        );
        this.audioBuffer = result.buffer;
        this.audioAnalysis = result.analysis;
        this.loadingState = "complete";
        this.loadingProgress = 1;
        this.loadingPhase = "Complete";
        this.initializeReactiveMapper();
        storeLogger.debug("Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (error) {
        storeLogger.error("Failed to load audio:", error);
        this.audioFile = null;
        this.audioBuffer = null;
        this.audioAnalysis = null;
        this.reactiveMapper = null;
        this.loadingState = "error";
        this.loadingError = error.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelLoad() {
      cancelAnalysis();
      this.loadingState = "idle";
      this.loadingProgress = 0;
      this.loadingPhase = "";
      this.loadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clear() {
      this.cancelLoad();
      this.audioFile = null;
      this.audioBuffer = null;
      this.audioAnalysis = null;
      this.legacyMappings.clear();
      this.reactiveMappings = [];
      this.reactiveMapper = null;
      this.peakData = null;
    },
    /**
     * Initialize the audio reactive mapper
     */
    initializeReactiveMapper() {
      if (!this.audioAnalysis) return;
      this.reactiveMapper = new AudioReactiveMapper(this.audioAnalysis);
      for (const mapping of this.reactiveMappings) {
        this.reactiveMapper.addMapping(mapping);
      }
      if (this.peakData) {
        this.reactiveMapper.setPeakData(this.peakData);
      }
    },
    /**
     * Get audio feature value at frame
     */
    getFeatureAtFrame(feature, frame) {
      if (!this.audioAnalysis) return 0;
      return getFeatureAtFrame(this.audioAnalysis, feature, frame);
    },
    /**
     * Check if frame is on a beat
     */
    isBeatAtFrame(frame) {
      if (!this.audioAnalysis) return false;
      return isBeatAtFrame(this.audioAnalysis, frame);
    },
    // ============================================================
    // PEAK DETECTION
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(peakData) {
      this.peakData = peakData;
      if (this.reactiveMapper) {
        this.reactiveMapper.setPeakData(peakData);
      }
    },
    /**
     * Detect peaks with config
     */
    detectPeaks(config) {
      if (!this.audioAnalysis) return null;
      const weights = this.audioAnalysis.amplitudeEnvelope;
      const peakData = detectPeaks(weights, config);
      this.peakData = peakData;
      if (this.reactiveMapper) {
        this.reactiveMapper.setPeakData(peakData);
      }
      return peakData;
    },
    // ============================================================
    // LEGACY AUDIO MAPPINGS
    // ============================================================
    /**
     * Apply audio reactivity mapping to particle layer (legacy)
     */
    addLegacyMapping(layerId, mapping) {
      const existing = this.legacyMappings.get(layerId) || [];
      existing.push(mapping);
      this.legacyMappings.set(layerId, existing);
    },
    /**
     * Remove legacy audio mapping
     */
    removeLegacyMapping(layerId, index) {
      const mappings = this.legacyMappings.get(layerId);
      if (mappings) {
        mappings.splice(index, 1);
        if (mappings.length === 0) {
          this.legacyMappings.delete(layerId);
        }
      }
    },
    /**
     * Get legacy mappings for a layer
     */
    getLegacyMappings(layerId) {
      return this.legacyMappings.get(layerId) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Add new audio mapping
     */
    addMapping(mapping) {
      this.reactiveMappings.push(mapping);
      if (this.reactiveMapper) {
        this.reactiveMapper.addMapping(mapping);
      }
    },
    /**
     * Remove audio mapping by ID
     */
    removeMapping(mappingId) {
      const index = this.reactiveMappings.findIndex((m) => m.id === mappingId);
      if (index >= 0) {
        this.reactiveMappings.splice(index, 1);
      }
      if (this.reactiveMapper) {
        this.reactiveMapper.removeMapping(mappingId);
      }
    },
    /**
     * Update audio mapping
     */
    updateMapping(mappingId, updates) {
      const mapping = this.reactiveMappings.find((m) => m.id === mappingId);
      if (mapping) {
        Object.assign(mapping, updates);
      }
      if (this.reactiveMapper) {
        this.reactiveMapper.updateMapping(mappingId, updates);
      }
    },
    /**
     * Get all audio mappings
     */
    getMappings() {
      return this.reactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(mappingId, frame) {
      if (!this.reactiveMapper) return 0;
      return this.reactiveMapper.getValueAtFrame(mappingId, frame);
    },
    /**
     * Get all mapped values at frame
     */
    getAllMappedValuesAtFrame(frame) {
      if (!this.reactiveMapper) return /* @__PURE__ */ new Map();
      return this.reactiveMapper.getAllValuesAtFrame(frame);
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(layerId) {
      return this.reactiveMappings.filter(
        (m) => m.enabled && (m.targetLayerId === layerId || m.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getValuesForLayerAtFrame(layerId, frame) {
      if (!this.reactiveMapper) return /* @__PURE__ */ new Map();
      return this.reactiveMapper.getValuesForLayerAtFrame(layerId, frame);
    },
    // ============================================================
    // AUDIO PLAYBACK (Ctrl+. for audio-only preview)
    // ============================================================
    /**
     * Initialize audio context if needed
     */
    ensureAudioContext() {
      if (!this.audioContext) {
        this.audioContext = new AudioContext();
      }
      return this.audioContext;
    },
    /**
     * Play audio from a specific frame
     * @param frame - Current frame to start from
     * @param fps - Frames per second for time calculation
     */
    playAudioFromFrame(frame, fps) {
      if (!this.audioBuffer) {
        storeLogger.debug("No audio loaded");
        return;
      }
      this.stopAudio();
      const context = this.ensureAudioContext();
      if (context.state === "suspended") {
        context.resume();
      }
      const startTime = frame / fps;
      this.audioSource = context.createBufferSource();
      this.audioSource.buffer = this.audioBuffer;
      this.audioSource.connect(context.destination);
      this.audioStartTime = context.currentTime;
      this.audioStartOffset = startTime;
      this.isPlayingAudio = true;
      this.audioSource.start(0, startTime);
      this.audioSource.onended = () => {
        this.isPlayingAudio = false;
      };
      storeLogger.debug("Audio playback started at frame", frame, "time", startTime);
    },
    /**
     * Stop audio playback
     */
    stopAudio() {
      if (this.audioSource) {
        try {
          this.audioSource.stop();
        } catch {
        }
        this.audioSource.disconnect();
        this.audioSource = null;
      }
      this.isPlayingAudio = false;
      storeLogger.debug("Audio playback stopped");
    },
    /**
     * Toggle audio playback (Ctrl+.)
     * @param frame - Current frame
     * @param fps - Frames per second
     */
    toggleAudioPlayback(frame, fps) {
      if (this.isPlayingAudio) {
        this.stopAudio();
      } else {
        this.playAudioFromFrame(frame, fps);
      }
    },
    /**
     * Get current audio playback time in seconds
     */
    getCurrentAudioTime() {
      if (!this.isPlayingAudio || !this.audioContext) return 0;
      return this.audioStartOffset + (this.audioContext.currentTime - this.audioStartTime);
    },
    /**
     * Scrub audio at a specific position (for Ctrl+drag audio scrub)
     * This plays a short snippet of audio at the given frame
     * @param frame - Frame to scrub to
     * @param fps - Frames per second
     */
    scrubAudio(frame, fps) {
      if (!this.audioBuffer) return;
      const context = this.ensureAudioContext();
      if (context.state === "suspended") {
        context.resume();
      }
      if (this.audioSource) {
        try {
          this.audioSource.stop();
        } catch {
        }
        this.audioSource.disconnect();
      }
      const time = frame / fps;
      const scrubDuration = 0.1;
      this.audioSource = context.createBufferSource();
      this.audioSource.buffer = this.audioBuffer;
      this.audioSource.connect(context.destination);
      const endTime = Math.min(time + scrubDuration, this.audioBuffer.duration);
      this.audioSource.start(0, time, endTime - time);
    }
  }
});

const audioStore = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  useAudioStore
}, Symbol.toStringTag, { value: 'Module' }));

const KEYFRAME_SHAPES = {
  // ========================================
  // BAR SHAPES (for holds/markers)
  // ========================================
  /** Mini - Short vertical bar for subtle keyframes */
  mini: {
    path: "M1,8 L1,16",
    width: 2,
    height: 24,
    stroke: true
  },
  /** Extend - Taller bar for extended holds */
  extend: {
    path: "M2,4 L2,20",
    width: 4,
    height: 24,
    stroke: true
  },
  /** Long - Full height bar for long duration markers */
  long: {
    path: "M2,0 L2,24",
    width: 4,
    height: 24,
    stroke: true
  },
  // ========================================
  // ROUND HEAD SHAPES (for smooth starts)
  // ========================================
  /** Round Head - Circle top for smooth interpolation start */
  roundHead: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,20",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Extend - Circle with extended bar */
  rhExtend: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,16 L8,16 L8,20 L0,20 L0,16 L4,16",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Long - Circle with long bar */
  rhLong: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,24",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Outline - Outline circle variant */
  rhOutline: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,24",
    width: 8,
    height: 24,
    stroke: true,
    fill: "none"
  },
  // ========================================
  // WIDE SHAPES (for timing windows)
  // ========================================
  /** Wide - Horizontal bar for wide timing window */
  wide: {
    path: "M0,10 L12,10 L12,14 L0,14 Z",
    width: 12,
    height: 24
  },
  /** Wide Hammer - Bar with hard stop end */
  wideHammer: {
    path: "M0,10 L10,10 L10,6 L12,6 L12,18 L10,18 L10,14 L0,14 Z",
    width: 12,
    height: 24
  },
  // ========================================
  // EASE SHAPES (for interpolation types)
  // ========================================
  /** Pill - Rounded rectangle for eased transitions */
  pill: {
    path: "M3,8 L9,8 A3,3 0 0,1 9,16 L3,16 A3,3 0 0,1 3,8 Z",
    width: 12,
    height: 24
  },
  /** Watch - Hourglass shape for ease in-out */
  watch: {
    path: "M2,6 L10,6 L10,8 L7,12 L10,16 L10,18 L2,18 L2,16 L5,12 L2,8 Z",
    width: 12,
    height: 24
  },
  /** Triangle - Directional ramp (ease in or out) */
  triangle: {
    path: "M0,20 L6,4 L12,20 Z",
    width: 12,
    height: 24
  },
  /** Diamond - Standard keyframe (linear) */
  diamond: {
    path: "M6,2 L11,12 L6,22 L1,12 Z",
    width: 12,
    height: 24
  },
  /** Martini - Inverted triangle (ease out with hold) */
  martini: {
    path: "M1,4 L11,4 L6,18 L6,22 L6,18 Z",
    width: 12,
    height: 24
  },
  // ========================================
  // POINT SHAPES (for discrete keyframes)
  // ========================================
  /** Radio - Filled circle point */
  radio: {
    path: "M6,6 a6,6 0 1,1 0.01,0 Z",
    width: 12,
    height: 24
  },
  /** Radio Long - Circle with extension bar */
  radioLong: {
    path: "M6,6 a6,6 0 1,1 0.01,0 Z M6,12 L6,24",
    width: 12,
    height: 24
  }
};
function getShapeForEasing(easing) {
  const easingLower = easing.toLowerCase();
  if (easingLower === "hold" || easingLower === "step") {
    return "extend";
  }
  if (easingLower === "linear") {
    return "diamond";
  }
  if (easingLower.startsWith("easein") && !easingLower.includes("out")) {
    return "triangle";
  }
  if (easingLower.startsWith("easeout") || easingLower === "easeout") {
    return "martini";
  }
  if (easingLower.includes("inout") || easingLower === "easeinout") {
    return "pill";
  }
  if (easingLower === "bezier" || easingLower === "cubic-bezier") {
    return "watch";
  }
  if (easingLower.includes("elastic")) {
    return "radioLong";
  }
  if (easingLower.includes("bounce")) {
    return "radio";
  }
  if (easingLower.includes("spring")) {
    return "roundHead";
  }
  return "diamond";
}

const _hoisted_1$g = { class: "prop-wrapper" };
const _hoisted_2$g = {
  key: 0,
  class: "keyframe-nav"
};
const _hoisted_3$g = ["disabled"];
const _hoisted_4$g = ["disabled"];
const _hoisted_5$g = { class: "prop-content" };
const _hoisted_6$g = { class: "prop-name" };
const _hoisted_7$g = { class: "prop-inputs" };
const _hoisted_8$f = {
  key: 0,
  class: "vec-item"
};
const _hoisted_9$f = {
  key: 1,
  class: "checkbox-wrapper"
};
const _hoisted_10$f = ["checked"];
const _hoisted_11$e = ["value", "title"];
const _hoisted_12$d = ["value"];
const _hoisted_13$d = {
  key: 0,
  value: "off"
};
const _hoisted_14$b = {
  key: 1,
  value: "on"
};
const _hoisted_15$a = {
  key: 2,
  value: "only"
};
const _hoisted_16$9 = {
  key: 3,
  value: "Classic 3D"
};
const _hoisted_17$9 = {
  key: 4,
  value: "CINEMA 4D"
};
const _hoisted_18$9 = {
  key: 5,
  value: "Ray-traced 3D"
};
const _hoisted_19$9 = ["value", "placeholder", "title"];
const _hoisted_20$9 = {
  key: 5,
  class: "color-input-wrapper"
};
const _hoisted_21$9 = ["value"];
const _hoisted_22$8 = { class: "color-hex" };
const _hoisted_23$8 = { class: "vec-item" };
const _hoisted_24$6 = { class: "vec-item" };
const _hoisted_25$6 = ["onMousedown", "onDblclick", "onContextmenu"];
const _hoisted_26$6 = ["viewBox"];
const _hoisted_27$6 = ["d", "fill", "stroke"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(__props, { emit: __emit }) {
    function getKeyframeShapePath(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      return KEYFRAME_SHAPES[shapeKey]?.path || KEYFRAME_SHAPES.diamond.path;
    }
    function getKeyframeShapeViewBox(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      const shape = KEYFRAME_SHAPES[shapeKey] || KEYFRAME_SHAPES.diamond;
      return `0 0 ${shape.width} ${shape.height}`;
    }
    function isStrokeShape(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      return KEYFRAME_SHAPES[shapeKey]?.stroke || false;
    }
    const props = __props;
    const store = useCompositorStore();
    const selectedKeyframeIds = ref(/* @__PURE__ */ new Set());
    const trackRef = ref(null);
    const isBoxSelecting = ref(false);
    const boxStartX = ref(0);
    const boxCurrentX = ref(0);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      keyframe: null
    });
    const contextMenuStyle = computed(() => ({
      left: `${contextMenu.value.x}px`,
      top: `${contextMenu.value.y}px`
    }));
    const selectionBoxStyle = computed(() => {
      const left = Math.min(boxStartX.value, boxCurrentX.value);
      const width = Math.abs(boxCurrentX.value - boxStartX.value);
      return {
        left: `${left}px`,
        width: `${width}px`
      };
    });
    const hasKeyframeAtCurrent = computed(() => props.property.keyframes?.some((k) => k.frame === store.currentFrame));
    const isSelected = computed(() => store.selectedPropertyPath === props.propertyPath);
    const sortedKeyframes = computed(() => {
      const kfs = props.property.keyframes || [];
      return [...kfs].sort((a, b) => a.frame - b.frame);
    });
    const hasPrevKeyframe = computed(() => {
      return sortedKeyframes.value.some((kf) => kf.frame < store.currentFrame);
    });
    const hasNextKeyframe = computed(() => {
      return sortedKeyframes.value.some((kf) => kf.frame > store.currentFrame);
    });
    function goToPrevKeyframe() {
      const prevKfs = sortedKeyframes.value.filter((kf) => kf.frame < store.currentFrame);
      if (prevKfs.length > 0) {
        const prevKf = prevKfs[prevKfs.length - 1];
        store.setFrame(prevKf.frame);
      }
    }
    function goToNextKeyframe() {
      const nextKf = sortedKeyframes.value.find((kf) => kf.frame > store.currentFrame);
      if (nextKf) {
        store.setFrame(nextKf.frame);
      }
    }
    function toggleAnim() {
      store.setPropertyAnimated(props.layerId, props.propertyPath, !props.property.animated);
    }
    function addKeyframeAtCurrent() {
      store.addKeyframe(props.layerId, props.propertyPath, props.property.value);
    }
    function updateValDirect(v) {
      if (props.propertyPath.startsWith("data.")) {
        const dataKey = props.propertyPath.replace("data.", "");
        store.updateLayerData(props.layerId, { [dataKey]: v });
      } else {
        store.setPropertyValue(props.layerId, props.propertyPath, v);
      }
    }
    function updateValByIndex(axis, v) {
      const newVal = { ...props.property.value, [axis]: v };
      store.setPropertyValue(props.layerId, props.propertyPath, newVal);
    }
    function selectProp() {
      store.selectProperty(props.propertyPath);
    }
    function formatOptionLabel(opt) {
      return opt.charAt(0).toUpperCase() + opt.slice(1);
    }
    function getDropdownTitle() {
      switch (props.name) {
        case "Line Cap":
          return "Butt: flat end, Round: rounded end, Square: extends end";
        case "Line Join":
          return "Miter: sharp corner, Round: rounded corner, Bevel: flat corner";
        default:
          return "";
      }
    }
    function getStringTitle() {
      switch (props.name) {
        case "Dashes":
          return "Dash pattern: comma-separated values (e.g., 10, 5 for 10px dash, 5px gap)";
        default:
          return "";
      }
    }
    function handleTrackMouseDown(e) {
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      isBoxSelecting.value = true;
      boxStartX.value = x;
      boxCurrentX.value = x;
      if (!e.shiftKey) {
        selectedKeyframeIds.value.clear();
      }
      const onMove = (ev) => {
        const currentX = ev.clientX - rect.left;
        boxCurrentX.value = Math.max(0, currentX);
        const minFrame = Math.min(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        const maxFrame = Math.max(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        if (!ev.shiftKey) {
          selectedKeyframeIds.value.clear();
        }
        for (const kf of props.property.keyframes || []) {
          if (kf.frame >= minFrame && kf.frame <= maxFrame) {
            selectedKeyframeIds.value.add(kf.id);
          }
        }
      };
      const onUp = (ev) => {
        isBoxSelecting.value = false;
        const dragDistance = Math.abs(boxCurrentX.value - boxStartX.value);
        if (dragDistance < 5) {
          const frame = Math.round(boxStartX.value / props.pixelsPerFrame);
          store.setFrame(Math.max(0, Math.min(store.frameCount - 1, frame)));
        }
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function startKeyframeDrag(e, kf) {
      if (e.shiftKey) {
        if (selectedKeyframeIds.value.has(kf.id)) {
          selectedKeyframeIds.value.delete(kf.id);
        } else {
          selectedKeyframeIds.value.add(kf.id);
        }
      } else {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const startX = e.clientX;
      const startFrame = kf.frame;
      const onMove = (ev) => {
        const dx = ev.clientX - startX;
        const frameDelta = Math.round(dx / props.pixelsPerFrame);
        let newFrame = Math.max(0, Math.min(store.frameCount - 1, startFrame + frameDelta));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(newFrame, store.snapConfig, props.pixelsPerFrame, {
            layers: store.layers,
            selectedLayerId: props.layerId,
            currentFrame: store.currentFrame,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            newFrame = snap.frame;
          }
        }
        if (newFrame !== kf.frame) {
          store.moveKeyframe(props.layerId, props.propertyPath, kf.id, newFrame);
        }
      };
      const onUp = () => {
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function deleteKeyframe(kfId) {
      store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      selectedKeyframeIds.value.delete(kfId);
    }
    function showContextMenu(e, kf) {
      if (!selectedKeyframeIds.value.has(kf.id)) {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const trackRect = trackRef.value?.getBoundingClientRect();
      if (trackRect) {
        contextMenu.value = {
          visible: true,
          x: e.clientX - trackRect.left,
          y: e.clientY - trackRect.top,
          keyframe: kf
        };
      }
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.keyframe = null;
    }
    function setInterpolation(type) {
      for (const kfId of selectedKeyframeIds.value) {
        store.setKeyframeInterpolation(props.layerId, props.propertyPath, kfId, type);
      }
      hideContextMenu();
    }
    function goToKeyframe() {
      if (contextMenu.value.keyframe) {
        store.setFrame(contextMenu.value.keyframe.frame);
      }
      hideContextMenu();
    }
    function deleteSelectedKeyframes() {
      for (const kfId of selectedKeyframeIds.value) {
        store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      }
      selectedKeyframeIds.value.clear();
      hideContextMenu();
    }
    function handleGlobalClick(e) {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleGlobalClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleGlobalClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["prop-sidebar", { selected: isSelected.value }]),
          style: normalizeStyle(__props.gridStyle),
          onClick: selectProp
        }, [
          _cache[18] || (_cache[18] = createBaseVNode("div", { class: "indent-spacer" }, null, -1)),
          __props.property.animatable !== false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", {
              class: "icon-box",
              onClick: withModifiers(toggleAnim, ["stop"]),
              title: "Toggle Animation"
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["keyframe-toggle", { active: __props.property.animated }])
              }, "", 2)
            ]),
            __props.property.animated ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
              createBaseVNode("button", {
                class: "nav-btn",
                onClick: withModifiers(goToPrevKeyframe, ["stop"]),
                disabled: !hasPrevKeyframe.value,
                title: "Previous Keyframe (J)"
              }, [..._cache[10] || (_cache[10] = [
                createBaseVNode("span", null, "", -1)
              ])], 8, _hoisted_3$g),
              createBaseVNode("button", {
                class: normalizeClass(["nav-btn kf-indicator", { active: hasKeyframeAtCurrent.value }]),
                onClick: withModifiers(addKeyframeAtCurrent, ["stop"]),
                title: "Add/Remove Keyframe"
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("span", null, "", -1)
              ])], 2),
              createBaseVNode("button", {
                class: "nav-btn",
                onClick: withModifiers(goToNextKeyframe, ["stop"]),
                disabled: !hasNextKeyframe.value,
                title: "Next Keyframe (K)"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("span", null, "", -1)
              ])], 8, _hoisted_4$g)
            ])) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: "icon-box",
              onClick: withModifiers(addKeyframeAtCurrent, ["stop"])
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["kf-btn", { active: hasKeyframeAtCurrent.value }])
              }, "", 2)
            ]))
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _cache[13] || (_cache[13] = createBaseVNode("div", { class: "icon-box disabled" }, null, -1)),
            _cache[14] || (_cache[14] = createBaseVNode("div", { class: "icon-box disabled" }, null, -1))
          ], 64)),
          createBaseVNode("div", _hoisted_5$g, [
            createBaseVNode("span", _hoisted_6$g, toDisplayString(__props.name), 1),
            createBaseVNode("div", _hoisted_7$g, [
              __props.name === "Z Position" ? (openBlock(), createElementBlock("div", _hoisted_8$f, [
                _cache[15] || (_cache[15] = createBaseVNode("span", { class: "label z-label" }, "Z", -1)),
                createVNode(ScrubableNumber, {
                  modelValue: __props.property.value?.z ?? 0,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => updateValByIndex("z", v))
                }, null, 8, ["modelValue"])
              ])) : __props.property.type === "boolean" ? (openBlock(), createElementBlock("div", _hoisted_9$f, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: __props.property.value,
                  onChange: _cache[1] || (_cache[1] = (e) => updateValDirect(e.target.checked))
                }, null, 40, _hoisted_10$f)
              ])) : __props.property.type === "dropdown" ? (openBlock(), createElementBlock("select", {
                key: 2,
                class: "prop-dropdown",
                value: __props.property.value,
                onChange: _cache[2] || (_cache[2] = (e) => updateValDirect(e.target.value)),
                title: getDropdownTitle()
              }, [
                __props.property.options && Array.isArray(__props.property.options) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.property.options, (opt) => {
                  return openBlock(), createElementBlock("option", {
                    key: opt,
                    value: opt
                  }, toDisplayString(formatOptionLabel(opt)), 9, _hoisted_12$d);
                }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_13$d, "Off")) : createCommentVNode("", true),
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_14$b, "On")) : createCommentVNode("", true),
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_15$a, "Only")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_16$9, "Classic 3D")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_17$9, "CINEMA 4D")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_18$9, "Ray-traced 3D")) : createCommentVNode("", true)
                ], 64))
              ], 40, _hoisted_11$e)) : __props.property.type === "string" ? (openBlock(), createElementBlock("input", {
                key: 3,
                type: "text",
                class: "prop-string-input",
                value: __props.property.value,
                placeholder: __props.property.placeholder || "",
                title: getStringTitle(),
                onChange: _cache[3] || (_cache[3] = (e) => updateValDirect(e.target.value))
              }, null, 40, _hoisted_19$9)) : __props.property.type === "percent" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 4,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 0,
                min: 0,
                max: 100,
                suffix: "%"
              }, null, 8, ["modelValue"])) : __props.property.type === "color" ? (openBlock(), createElementBlock("div", _hoisted_20$9, [
                createBaseVNode("input", {
                  type: "color",
                  value: __props.property.value,
                  onInput: _cache[4] || (_cache[4] = (e) => updateValDirect(e.target.value))
                }, null, 40, _hoisted_21$9),
                createBaseVNode("span", _hoisted_22$8, toDisplayString(__props.property.value), 1)
              ])) : typeof __props.property.value === "object" ? (openBlock(), createElementBlock(Fragment, { key: 6 }, [
                createBaseVNode("div", _hoisted_23$8, [
                  _cache[16] || (_cache[16] = createBaseVNode("span", { class: "label x-label" }, "X", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateValByIndex("x", v))
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_24$6, [
                  _cache[17] || (_cache[17] = createBaseVNode("span", { class: "label y-label" }, "Y", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updateValByIndex("y", v))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof __props.property.value === "number" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 7,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 1
              }, null, 8, ["modelValue"])) : createCommentVNode("", true)
            ])
          ])
        ], 6)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "prop-track",
          onMousedown: handleTrackMouseDown,
          ref_key: "trackRef",
          ref: trackRef
        }, [
          isBoxSelecting.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "selection-box",
            style: normalizeStyle(selectionBoxStyle.value)
          }, null, 4)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.property.keyframes, (kf) => {
            return openBlock(), createElementBlock("div", {
              key: kf.id,
              class: normalizeClass(["keyframe", { selected: selectedKeyframeIds.value.has(kf.id), [kf.interpolation || "linear"]: true }]),
              style: normalizeStyle({ left: `${kf.frame * __props.pixelsPerFrame}px` }),
              onMousedown: withModifiers(($event) => startKeyframeDrag($event, kf), ["stop"]),
              onDblclick: withModifiers(($event) => deleteKeyframe(kf.id), ["stop"]),
              onContextmenu: withModifiers(($event) => showContextMenu($event, kf), ["prevent", "stop"])
            }, [
              (openBlock(), createElementBlock("svg", {
                class: "keyframe-shape",
                viewBox: getKeyframeShapeViewBox(kf.interpolation),
                preserveAspectRatio: "xMidYMid meet"
              }, [
                createBaseVNode("path", {
                  d: getKeyframeShapePath(kf.interpolation),
                  fill: isStrokeShape(kf.interpolation) ? "none" : "currentColor",
                  stroke: isStrokeShape(kf.interpolation) ? "currentColor" : "none",
                  "stroke-width": "1.5"
                }, null, 8, _hoisted_27$6)
              ], 8, _hoisted_26$6))
            ], 46, _hoisted_25$6);
          }), 128)),
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: normalizeStyle(contextMenuStyle.value)
          }, [
            _cache[24] || (_cache[24] = createBaseVNode("div", { class: "menu-header" }, "Interpolation", -1)),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "linear" }]),
              onClick: _cache[7] || (_cache[7] = ($event) => setInterpolation("linear"))
            }, [..._cache[19] || (_cache[19] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Linear ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "bezier" }]),
              onClick: _cache[8] || (_cache[8] = ($event) => setInterpolation("bezier"))
            }, [..._cache[20] || (_cache[20] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Bezier ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "hold" }]),
              onClick: _cache[9] || (_cache[9] = ($event) => setInterpolation("hold"))
            }, [..._cache[21] || (_cache[21] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Hold ", -1)
            ])], 2),
            _cache[25] || (_cache[25] = createBaseVNode("div", { class: "menu-divider" }, null, -1)),
            createBaseVNode("div", {
              class: "menu-item",
              onClick: goToKeyframe
            }, [..._cache[22] || (_cache[22] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Go to Frame ", -1)
            ])]),
            createBaseVNode("div", {
              class: "menu-item delete",
              onClick: deleteSelectedKeyframes
            }, [..._cache[23] || (_cache[23] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Delete ", -1)
            ])])
          ], 4)) : createCommentVNode("", true)
        ], 544))
      ]);
    };
  }
});

const PropertyTrack = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-c6f6e25a"]]);

const _hoisted_1$f = {
  key: 0,
  class: "track-wrapper"
};
const _hoisted_2$f = { class: "av-features" };
const _hoisted_3$f = ["title"];
const _hoisted_4$f = ["title"];
const _hoisted_5$f = {
  key: 1,
  class: "icon-col placeholder"
};
const _hoisted_6$f = ["title"];
const _hoisted_7$f = ["title"];
const _hoisted_8$e = { class: "layer-info" };
const _hoisted_9$e = { class: "layer-id" };
const _hoisted_10$e = { class: "arrow" };
const _hoisted_11$d = { class: "type-icon" };
const _hoisted_12$c = {
  key: 0,
  class: "name-text"
};
const _hoisted_13$c = { class: "layer-switches" };
const _hoisted_14$a = ["title"];
const _hoisted_15$9 = ["title"];
const _hoisted_16$8 = ["title"];
const _hoisted_17$8 = ["title"];
const _hoisted_18$8 = ["title"];
const _hoisted_19$8 = ["title"];
const _hoisted_20$8 = ["title"];
const _hoisted_21$8 = ["title"];
const _hoisted_22$7 = { class: "col-parent" };
const _hoisted_23$7 = ["value"];
const _hoisted_24$5 = ["value"];
const _hoisted_25$5 = {
  key: 0,
  class: "children-container"
};
const _hoisted_26$5 = ["onMousedown"];
const _hoisted_27$5 = { class: "arrow-col" };
const _hoisted_28$5 = { class: "arrow" };
const _hoisted_29$5 = { class: "group-label" };
const _hoisted_30$4 = { key: 0 };
const _hoisted_31$4 = {
  key: 0,
  class: "children-container"
};
const _hoisted_32$4 = { key: 0 };
const _hoisted_33$4 = { class: "color-grid" };
const _hoisted_34$4 = ["onClick"];
const SNAP_TOLERANCE = 5;
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const localExpanded = ref(false);
    const isExpanded = computed(() => props.isExpandedExternal ?? localExpanded.value);
    const isSelected = computed(() => store.selectedLayerIds.includes(props.layer.id));
    const isDragTarget = ref(false);
    function onDragStart(event) {
      event.dataTransfer?.setData("application/layer-reorder", props.layer.id);
      event.dataTransfer.effectAllowed = "move";
    }
    function onDragEnd() {
      isDragTarget.value = false;
    }
    function onDragOver(event) {
      const data = event.dataTransfer?.types.includes("application/layer-reorder");
      if (data) {
        isDragTarget.value = true;
      }
    }
    function onDragLeave() {
      isDragTarget.value = false;
    }
    function onDrop(event) {
      isDragTarget.value = false;
      if (event.altKey) {
        const projectItemData = event.dataTransfer?.getData("application/project-item");
        if (projectItemData) {
          try {
            const item = JSON.parse(projectItemData);
            if (item && (item.type === "asset" || item.type === "composition")) {
              store.replaceLayerSource(props.layer.id, item);
              console.log(`[Weyl] Replaced layer source: ${props.layer.name}  ${item.name}`);
              return;
            }
          } catch (e) {
            console.error("[Weyl] Failed to parse project item for replacement:", e);
          }
        }
      }
      const draggedLayerId = event.dataTransfer?.getData("application/layer-reorder");
      if (!draggedLayerId || draggedLayerId === props.layer.id) return;
      const layers = store.layers;
      const draggedIndex = layers.findIndex((l) => l.id === draggedLayerId);
      const targetIndex = layers.findIndex((l) => l.id === props.layer.id);
      if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
        store.moveLayer(draggedLayerId, targetIndex);
        console.log(`[Weyl] Moved layer from index ${draggedIndex} to ${targetIndex}`);
      }
    }
    const hasAudioCapability = computed(() => ["video", "audio", "nestedComp"].includes(props.layer.type));
    const isTextLayer = computed(() => props.layer.type === "text");
    const expandedGroups = ref(["Transform", "Text", "More Options", "Stroke", "Fill", "Trim Paths", "Path Options"]);
    const isRenaming = ref(false);
    const renameVal = ref("");
    const renameInput = ref(null);
    const contextMenuVisible = ref(false);
    const contextMenuX = ref(0);
    const contextMenuY = ref(0);
    const showColorPicker = ref(false);
    const colorPickerX = ref(0);
    const colorPickerY = ref(0);
    const labelColors = [
      "#999999",
      // None (gray)
      "#e24b4b",
      // Red
      "#f5c343",
      // Yellow
      "#c8e04d",
      // Lime
      "#4be08e",
      // Sea Green
      "#4bcde0",
      // Aqua
      "#5b8ef0",
      // Blue
      "#9d70e8",
      // Purple
      "#e070d0",
      // Pink
      "#e0a070",
      // Peach
      "#e07070",
      // Light Red
      "#70e0a0",
      // Mint
      "#7090e0",
      // Sky Blue
      "#a070e0",
      // Violet
      "#e07090",
      // Rose
      "#90c8e0"
      // Pale Blue
    ];
    const availableParents = computed(() => props.allLayers?.filter((l) => l.id !== props.layer.id) || []);
    const groupedProperties = computed(() => {
      const groups = {};
      const t = props.layer.transform;
      const transformProps = [];
      const add = (path, name, prop) => {
        if (prop) transformProps.push({ path, name, property: prop });
      };
      add("transform.anchorPoint", "Anchor Point", t.anchorPoint);
      add("transform.position", "Position", t.position);
      if (props.layer.threeD && t.position) {
        transformProps.push({
          path: "transform.position",
          name: "Z Position",
          property: t.position
          // Pass full position property, PropertyTrack handles .z
        });
      }
      add("transform.scale", "Scale", t.scale);
      if (props.layer.threeD) {
        if (t.orientation) transformProps.push({ path: "transform.orientation", name: "Orientation", property: t.orientation });
        if (t.rotationX) transformProps.push({ path: "transform.rotationX", name: "X Rotation", property: t.rotationX });
        if (t.rotationY) transformProps.push({ path: "transform.rotationY", name: "Y Rotation", property: t.rotationY });
        if (t.rotationZ) transformProps.push({ path: "transform.rotationZ", name: "Z Rotation", property: t.rotationZ });
      } else {
        if (t.rotation) transformProps.push({ path: "transform.rotation", name: "Rotation", property: t.rotation });
      }
      if (props.layer.opacity) transformProps.push({ path: "opacity", name: "Opacity", property: props.layer.opacity });
      groups["Transform"] = transformProps;
      if (props.layer.threeD) {
        groups["Geometry Options"] = [
          { path: "geometry.renderer", name: "Renderer", property: { value: "Classic 3D", type: "dropdown" } }
        ];
      }
      if (props.layer.threeD) {
        const mat = props.layer.materialOptions || {
          castsShadows: "off",
          lightTransmission: 0,
          acceptsShadows: true,
          acceptsLights: true,
          ambient: 100,
          diffuse: 50,
          specularIntensity: 50,
          specularShininess: 5,
          metal: 100
        };
        groups["Material Options"] = [
          { path: "materialOptions.castsShadows", name: "Casts Shadows", property: { value: mat.castsShadows, type: "dropdown" } },
          { path: "materialOptions.lightTransmission", name: "Light Transmission", property: { value: mat.lightTransmission, type: "percent" } },
          { path: "materialOptions.acceptsShadows", name: "Accepts Shadows", property: { value: mat.acceptsShadows, type: "boolean" } },
          { path: "materialOptions.acceptsLights", name: "Accepts Lights", property: { value: mat.acceptsLights, type: "boolean" } },
          { path: "materialOptions.ambient", name: "Ambient", property: { value: mat.ambient, type: "percent" } },
          { path: "materialOptions.diffuse", name: "Diffuse", property: { value: mat.diffuse, type: "percent" } },
          { path: "materialOptions.specularIntensity", name: "Specular Intensity", property: { value: mat.specularIntensity, type: "percent" } },
          { path: "materialOptions.specularShininess", name: "Specular Shininess", property: { value: mat.specularShininess, type: "percent" } },
          { path: "materialOptions.metal", name: "Metal", property: { value: mat.metal, type: "percent" } }
        ];
      }
      if (props.layer.type === "spline" && props.layer.data) {
        const splineData = props.layer.data;
        groups["Path Options"] = [
          { path: "data.closed", name: "Closed", property: { value: splineData.closed ?? false, type: "boolean", animatable: false } }
        ];
        groups["More Options"] = [
          { path: "data.lineCap", name: "Line Cap", property: { value: splineData.lineCap ?? "round", type: "dropdown", options: ["butt", "round", "square"], animatable: false } },
          { path: "data.lineJoin", name: "Line Join", property: { value: splineData.lineJoin ?? "round", type: "dropdown", options: ["miter", "round", "bevel"], animatable: false } },
          { path: "data.dashArray", name: "Dashes", property: { value: splineData.dashArray ?? "", type: "string", placeholder: "10, 5", animatable: false } },
          { path: "data.dashOffset", name: "Dash Offset", property: { value: splineData.dashOffset ?? 0, type: "number", animatable: false } }
        ];
      }
      if (props.layer.properties) {
        props.layer.properties.forEach((p) => {
          const g = p.group || "Properties";
          if (!groups[g]) groups[g] = [];
          groups[g].push({ path: p.name, name: p.name, property: p });
        });
      }
      return groups;
    });
    const barStyle = computed(() => {
      const frameCount = props.frameCount || 81;
      const inPoint = props.layer.inPoint ?? 0;
      const outPoint = props.layer.outPoint ?? frameCount - 1;
      const leftPct = Math.max(0, inPoint / frameCount * 100);
      const widthPct = Math.max(1, (outPoint - inPoint + 1) / frameCount * 100);
      return {
        left: `${leftPct}%`,
        width: `${widthPct}%`
      };
    });
    function selectLayer() {
      emit("select", props.layer.id);
    }
    function toggleExpand() {
      emit("toggleExpand", props.layer.id, !isExpanded.value);
    }
    function toggleGroup(g) {
      if (expandedGroups.value.includes(g)) expandedGroups.value = expandedGroups.value.filter((x) => x !== g);
      else expandedGroups.value.push(g);
    }
    function getLayerIcon(t) {
      return { text: "T", solid: "", camera: "", nestedComp: "", image: "", video: "" }[t] || "";
    }
    function handleDoubleClick() {
      if (props.layer.type === "nestedComp" && props.layer.data?.compositionId) {
        store.enterNestedComp(props.layer.data.compositionId);
      } else {
        startRename();
      }
    }
    function startRename() {
      isRenaming.value = true;
      renameVal.value = props.layer.name;
      nextTick(() => renameInput.value?.focus());
    }
    function saveRename() {
      emit("updateLayer", props.layer.id, { name: renameVal.value });
      isRenaming.value = false;
    }
    function setParent(e) {
      emit("updateLayer", props.layer.id, { parentId: e.target.value || null });
    }
    const isDragging = ref(false);
    const isResizingLeft = ref(false);
    const isResizingRight = ref(false);
    const dragStartX = ref(0);
    const dragStartInPoint = ref(0);
    const dragStartOutPoint = ref(0);
    function getSnapTargets() {
      const targets = [];
      targets.push(store.currentFrame);
      const layers = props.allLayers || store.layers;
      for (const layer of layers) {
        if (layer.id === props.layer.id) continue;
        if (layer.inPoint !== void 0) targets.push(layer.inPoint);
        if (layer.outPoint !== void 0) targets.push(layer.outPoint);
      }
      targets.push(0);
      targets.push(props.frameCount - 1);
      const composition = store.activeComposition;
      if (composition?.markers) {
        for (const marker of composition.markers) {
          targets.push(marker.frame);
        }
      }
      return [...new Set(targets)];
    }
    function snapToNearest(value, targets) {
      let nearest = value;
      let minDist = SNAP_TOLERANCE + 1;
      for (const target of targets) {
        const dist = Math.abs(value - target);
        if (dist < minDist) {
          minDist = dist;
          nearest = target;
        }
      }
      return minDist <= SNAP_TOLERANCE ? nearest : value;
    }
    function startDrag(e) {
      isDragging.value = true;
      dragStartX.value = e.clientX;
      dragStartInPoint.value = props.layer.inPoint ?? 0;
      dragStartOutPoint.value = props.layer.outPoint ?? props.frameCount - 1;
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
    }
    function startResizeLeft(e) {
      isResizingLeft.value = true;
      dragStartX.value = e.clientX;
      dragStartInPoint.value = props.layer.inPoint ?? 0;
      document.addEventListener("mousemove", onResizeLeft);
      document.addEventListener("mouseup", stopDrag);
    }
    function startResizeRight(e) {
      isResizingRight.value = true;
      dragStartX.value = e.clientX;
      dragStartOutPoint.value = props.layer.outPoint ?? props.frameCount - 1;
      document.addEventListener("mousemove", onResizeRight);
      document.addEventListener("mouseup", stopDrag);
    }
    function onDrag(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      const duration = dragStartOutPoint.value - dragStartInPoint.value;
      let newInPoint = dragStartInPoint.value + framesDelta;
      let newOutPoint = newInPoint + duration;
      if (e.shiftKey) {
        const targets = getSnapTargets();
        const snappedIn = snapToNearest(newInPoint, targets);
        const snappedOut = snapToNearest(newOutPoint, targets);
        const inDist = Math.abs(snappedIn - newInPoint);
        const outDist = Math.abs(snappedOut - newOutPoint);
        if (inDist <= outDist && inDist <= SNAP_TOLERANCE) {
          newInPoint = snappedIn;
          newOutPoint = snappedIn + duration;
        } else if (outDist <= SNAP_TOLERANCE) {
          newOutPoint = snappedOut;
          newInPoint = snappedOut - duration;
        }
      }
      if (newInPoint < 0) {
        newInPoint = 0;
        newOutPoint = duration;
      }
      if (newOutPoint >= props.frameCount) {
        newOutPoint = props.frameCount - 1;
        newInPoint = newOutPoint - duration;
      }
      emit("updateLayer", props.layer.id, { inPoint: newInPoint, outPoint: newOutPoint });
    }
    function onResizeLeft(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      let newInPoint = dragStartInPoint.value + framesDelta;
      if (e.shiftKey) {
        const targets = getSnapTargets();
        newInPoint = snapToNearest(newInPoint, targets);
      }
      const outPoint = props.layer.outPoint ?? props.frameCount - 1;
      newInPoint = Math.max(0, Math.min(newInPoint, outPoint - 1));
      emit("updateLayer", props.layer.id, { inPoint: newInPoint });
    }
    function onResizeRight(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      let newOutPoint = dragStartOutPoint.value + framesDelta;
      if (e.shiftKey) {
        const targets = getSnapTargets();
        newOutPoint = snapToNearest(newOutPoint, targets);
      }
      const inPoint = props.layer.inPoint ?? 0;
      newOutPoint = Math.max(inPoint + 1, Math.min(newOutPoint, props.frameCount - 1));
      emit("updateLayer", props.layer.id, { outPoint: newOutPoint });
    }
    function stopDrag() {
      isDragging.value = false;
      isResizingLeft.value = false;
      isResizingRight.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mousemove", onResizeLeft);
      document.removeEventListener("mousemove", onResizeRight);
      document.removeEventListener("mouseup", stopDrag);
    }
    function toggleVis() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
    }
    function toggleLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
    }
    function toggleAudio() {
      emit("updateLayer", props.layer.id, { audioEnabled: props.layer.audioEnabled === false ? true : false });
    }
    function toggleIsolate() {
      emit("updateLayer", props.layer.id, { isolate: !props.layer.isolate });
    }
    function toggleMinimized() {
      emit("updateLayer", props.layer.id, { minimized: !props.layer.minimized });
    }
    function toggleFlattenTransform() {
      emit("updateLayer", props.layer.id, { flattenTransform: !props.layer.flattenTransform });
    }
    function toggleQuality() {
      emit("updateLayer", props.layer.id, { quality: props.layer.quality === "best" ? "draft" : "best" });
    }
    function toggleEffects() {
      emit("updateLayer", props.layer.id, { effectsEnabled: props.layer.effectsEnabled === false ? true : false });
    }
    function toggleFrameBlend() {
      emit("updateLayer", props.layer.id, { frameBlending: !props.layer.frameBlending });
    }
    function toggleMotionBlur() {
      emit("updateLayer", props.layer.id, { motionBlur: !props.layer.motionBlur });
    }
    function toggleEffectLayer() {
      const currentState = props.layer.effectLayer || props.layer.adjustmentLayer;
      emit("updateLayer", props.layer.id, { effectLayer: !currentState, adjustmentLayer: !currentState });
    }
    function toggleColorPicker(e) {
      const rect = e.target.getBoundingClientRect();
      colorPickerX.value = rect.left;
      colorPickerY.value = rect.bottom + 4;
      showColorPicker.value = !showColorPicker.value;
    }
    function setLabelColor(color) {
      emit("updateLayer", props.layer.id, { labelColor: color });
      showColorPicker.value = false;
    }
    function closeColorPicker() {
      showColorPicker.value = false;
    }
    function resetTransform() {
      const comp = store.getActiveComp();
      if (!comp) return;
      const defaultTransform = {
        anchorPoint: { x: comp.settings.width / 2, y: comp.settings.height / 2 },
        position: { x: comp.settings.width / 2, y: comp.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100},
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      };
      const t = props.layer.transform;
      if (t.anchorPoint) t.anchorPoint.value = { ...defaultTransform.anchorPoint };
      if (t.position) t.position.value = props.layer.threeD ? { ...defaultTransform.position } : { x: defaultTransform.position.x, y: defaultTransform.position.y };
      if (t.scale) t.scale.value = { x: defaultTransform.scale.x, y: defaultTransform.scale.y };
      if (t.rotation) t.rotation.value = defaultTransform.rotation;
      if (t.rotationX) t.rotationX.value = defaultTransform.rotationX;
      if (t.rotationY) t.rotationY.value = defaultTransform.rotationY;
      if (t.rotationZ) t.rotationZ.value = defaultTransform.rotationZ;
      if (t.orientation) t.orientation.value = { ...defaultTransform.orientation };
      if (props.layer.opacity) props.layer.opacity.value = defaultTransform.opacity;
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      console.log("[EnhancedLayerTrack] Reset transform for layer:", props.layer.name);
    }
    function showContextMenu(e) {
      contextMenuX.value = e.clientX;
      contextMenuY.value = e.clientY;
      contextMenuVisible.value = true;
      if (!isSelected.value) {
        emit("select", props.layer.id);
      }
    }
    function hideContextMenu() {
      contextMenuVisible.value = false;
    }
    function duplicateLayer() {
      store.duplicateLayer(props.layer.id);
      hideContextMenu();
    }
    function renameFromMenu() {
      hideContextMenu();
      nextTick(() => {
        isRenaming.value = true;
        renameVal.value = props.layer.name;
        nextTick(() => renameInput.value?.focus());
      });
    }
    function toggleLayerVisibility() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
      hideContextMenu();
    }
    function toggleLayerLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
      hideContextMenu();
    }
    function toggleLayer3D() {
      store.toggleLayer3D(props.layer.id);
      hideContextMenu();
    }
    function nestLayer() {
      store.selectLayer(props.layer.id);
      store.nestSelectedLayers(props.layer.name + " Nested");
      hideContextMenu();
    }
    async function convertToSplines() {
      hideContextMenu();
      if (props.layer.type !== "text") return;
      try {
        const result = await convertTextLayerToSplines(store, props.layer.id, {
          perCharacter: true,
          groupCharacters: true});
        if (result) {
          console.log("[EnhancedLayerTrack] Text converted to splines:", result);
        }
      } catch (error) {
        console.error("[EnhancedLayerTrack] Failed to convert text to splines:", error);
      }
    }
    function deleteLayer() {
      store.deleteLayer(props.layer.id);
      hideContextMenu();
    }
    function handleOutsideClick(e) {
      if (contextMenuVisible.value) {
        hideContextMenu();
      }
      if (showColorPicker.value) {
        closeColorPicker();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return __props.layer ? (openBlock(), createElementBlock("div", _hoisted_1$f, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(["sidebar-row", { selected: isSelected.value, "drag-over": isDragTarget.value }]),
            onMousedown: selectLayer,
            onContextmenu: withModifiers(showContextMenu, ["prevent"]),
            draggable: "true",
            onDragstart: onDragStart,
            onDragend: onDragEnd,
            onDragover: withModifiers(onDragOver, ["prevent"]),
            onDragleave: onDragLeave,
            onDrop
          }, [
            createBaseVNode("div", _hoisted_2$f, [
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleVis, ["stop"]),
                title: __props.layer.visible ? "Hide" : "Show"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ inactive: !__props.layer.visible })
                }, "", 2)
              ], 40, _hoisted_3$f),
              hasAudioCapability.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "icon-col",
                onMousedown: withModifiers(toggleAudio, ["stop"]),
                title: __props.layer.audioEnabled !== false ? "Mute Audio" : "Enable Audio"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ inactive: __props.layer.audioEnabled === false })
                }, "", 2)
              ], 40, _hoisted_4$f)) : (openBlock(), createElementBlock("div", _hoisted_5$f)),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleIsolate, ["stop"]),
                title: __props.layer.isolate ? "Unisolate" : "Isolate"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.isolate })
                }, "", 2)
              ], 40, _hoisted_6$f),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleLock, ["stop"]),
                title: __props.layer.locked ? "Unlock" : "Lock"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.locked })
                }, "", 2)
              ], 40, _hoisted_7$f)
            ]),
            createBaseVNode("div", _hoisted_8$e, [
              createBaseVNode("div", {
                class: "label-box",
                onMousedown: withModifiers(toggleColorPicker, ["stop"]),
                style: normalizeStyle({ background: __props.layer.labelColor || "#999" })
              }, null, 36),
              createBaseVNode("div", _hoisted_9$e, toDisplayString(__props.index), 1),
              createBaseVNode("div", {
                class: "arrow-col",
                onMousedown: withModifiers(toggleExpand, ["stop"])
              }, [
                createBaseVNode("span", _hoisted_10$e, toDisplayString(isExpanded.value ? "" : ""), 1)
              ], 32),
              createBaseVNode("div", {
                class: "layer-name-col",
                onDblclick: withModifiers(handleDoubleClick, ["stop"])
              }, [
                createBaseVNode("span", _hoisted_11$d, toDisplayString(getLayerIcon(__props.layer.type)), 1),
                !isRenaming.value ? (openBlock(), createElementBlock("span", _hoisted_12$c, toDisplayString(__props.layer.name), 1)) : withDirectives((openBlock(), createElementBlock("input", {
                  key: 1,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => renameVal.value = $event),
                  onBlur: saveRename,
                  onKeydown: withKeys(saveRename, ["enter"]),
                  class: "rename-input",
                  ref_key: "renameInput",
                  ref: renameInput
                }, null, 544)), [
                  [vModelText, renameVal.value]
                ])
              ], 32)
            ]),
            createBaseVNode("div", _hoisted_13$c, [
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleMinimized, ["stop"]),
                title: __props.layer.minimized ? "Unminimize" : "Minimize (hide when filter enabled)"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.minimized })
                }, "", 2)
              ], 40, _hoisted_14$a),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleFlattenTransform, ["stop"]),
                title: __props.layer.flattenTransform ? "Disable Flatten Transform" : "Flatten Transform"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.flattenTransform })
                }, "", 2)
              ], 40, _hoisted_15$9),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleQuality, ["stop"]),
                title: __props.layer.quality === "best" ? "Draft Quality" : "Best Quality"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.quality === "best" })
                }, "", 2)
              ], 40, _hoisted_16$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleEffects, ["stop"]),
                title: __props.layer.effectsEnabled !== false ? "Disable Effects" : "Enable Effects"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.effectsEnabled !== false, inactive: __props.layer.effectsEnabled === false })
                }, "fx", 2)
              ], 40, _hoisted_17$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleFrameBlend, ["stop"]),
                title: __props.layer.frameBlending ? "Disable Frame Blending" : "Enable Frame Blending"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.frameBlending })
                }, "", 2)
              ], 40, _hoisted_18$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleMotionBlur, ["stop"]),
                title: __props.layer.motionBlur ? "Disable Motion Blur" : "Enable Motion Blur"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.motionBlur })
                }, "", 2)
              ], 40, _hoisted_19$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleEffectLayer, ["stop"]),
                title: __props.layer.effectLayer || __props.layer.adjustmentLayer ? "Disable Effect Layer" : "Make Effect Layer"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.effectLayer || __props.layer.adjustmentLayer })
                }, "", 2)
              ], 40, _hoisted_20$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => unref(store).toggleLayer3D(__props.layer.id), ["stop"])),
                title: __props.layer.threeD ? "Make 2D Layer" : "Make 3D Layer"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.threeD })
                }, "", 2)
              ], 40, _hoisted_21$8)
            ]),
            createBaseVNode("div", _hoisted_22$7, [
              createBaseVNode("select", {
                value: __props.layer.parentId || "",
                class: "mini-select",
                onChange: setParent,
                onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"]))
              }, [
                _cache[5] || (_cache[5] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (p) => {
                  return openBlock(), createElementBlock("option", {
                    key: p.id,
                    value: p.id
                  }, toDisplayString(p.index) + ". " + toDisplayString(p.name), 9, _hoisted_24$5);
                }), 128))
              ], 40, _hoisted_23$7)
            ])
          ], 34),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                createBaseVNode("div", {
                  class: "group-header sidebar-row",
                  style: normalizeStyle(__props.gridStyle),
                  onMousedown: withModifiers(($event) => toggleGroup(groupName), ["stop"])
                }, [
                  createBaseVNode("div", _hoisted_27$5, [
                    createBaseVNode("span", _hoisted_28$5, toDisplayString(expandedGroups.value.includes(groupName) ? "" : ""), 1)
                  ]),
                  createBaseVNode("div", _hoisted_29$5, [
                    createTextVNode(toDisplayString(groupName) + " ", 1),
                    groupName === "Transform" ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: "reset-link",
                      onClick: withModifiers(resetTransform, ["stop"])
                    }, "Reset")) : createCommentVNode("", true)
                  ])
                ], 44, _hoisted_26$5),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_30$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "sidebar",
                      gridStyle: __props.gridStyle,
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "layer-row track-bg",
            onMousedown: selectLayer
          }, [
            createBaseVNode("div", {
              class: "duration-bar",
              style: normalizeStyle(barStyle.value),
              onMousedown: withModifiers(startDrag, ["stop"])
            }, [
              createBaseVNode("div", {
                class: "bar-handle bar-handle-left",
                onMousedown: withModifiers(startResizeLeft, ["stop"])
              }, null, 32),
              createBaseVNode("div", {
                class: "bar-fill",
                style: normalizeStyle({ background: __props.layer.labelColor || "#777" })
              }, null, 4),
              createBaseVNode("div", {
                class: "bar-handle bar-handle-right",
                onMousedown: withModifiers(startResizeRight, ["stop"])
              }, null, 32)
            ], 36)
          ], 32),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_31$4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "group-header track-bg" }, null, -1)),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_32$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "track",
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenuVisible.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-context-menu",
            style: normalizeStyle({ left: contextMenuX.value + "px", top: contextMenuY.value + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: duplicateLayer }, "Duplicate Layer"),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            _cache[7] || (_cache[7] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: toggleLayerVisibility }, toDisplayString(__props.layer.visible ? "Hide" : "Show") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayerLock }, toDisplayString(__props.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayer3D }, toDisplayString(__props.layer.threeD ? "Make 2D" : "Make 3D"), 1),
            _cache[8] || (_cache[8] = createBaseVNode("hr", null, null, -1)),
            isTextLayer.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: convertToSplines
            }, "Convert to Splines")) : createCommentVNode("", true),
            createBaseVNode("button", { onClick: nestLayer }, "Nest Layers..."),
            _cache[9] || (_cache[9] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteLayer,
              class: "danger"
            }, "Delete Layer")
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showColorPicker.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-color-picker",
            style: normalizeStyle({ left: colorPickerX.value + "px", top: colorPickerY.value + "px" }),
            onClick: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("div", _hoisted_33$4, [
              (openBlock(), createElementBlock(Fragment, null, renderList(labelColors, (color) => {
                return createBaseVNode("button", {
                  key: color,
                  class: normalizeClass(["color-swatch", { active: __props.layer.labelColor === color }]),
                  style: normalizeStyle({ backgroundColor: color }),
                  onClick: ($event) => setLabelColor(color)
                }, null, 14, _hoisted_34$4);
              }), 64))
            ])
          ], 4)) : createCommentVNode("", true)
        ]))
      ])) : createCommentVNode("", true);
    };
  }
});

const EnhancedLayerTrack = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-9e65ac0d"]]);

const _hoisted_1$e = { class: "composition-tabs" };
const _hoisted_2$e = {
  key: 0,
  class: "breadcrumb-nav"
};
const _hoisted_3$e = ["onClick"];
const _hoisted_4$e = {
  key: 0,
  class: "breadcrumb-sep"
};
const _hoisted_5$e = { class: "tabs-container" };
const _hoisted_6$e = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_7$e = {
  key: 0,
  class: "nested-comp-icon",
  title: "Nested Composition"
};
const _hoisted_8$d = {
  key: 1,
  class: "tab-name"
};
const _hoisted_9$d = {
  key: 2,
  class: "tab-name"
};
const _hoisted_10$d = { class: "tab-info" };
const _hoisted_11$c = ["onClick"];
const _hoisted_12$b = ["disabled"];
const _hoisted_13$b = ["disabled"];
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "CompositionTabs",
  emits: ["newComposition", "openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const breadcrumbPath = computed(() => store.breadcrumbPath);
    const editingId = ref(null);
    const editingName = ref("");
    const renameInput = ref(null);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      comp: null
    });
    const openCompositions = computed(() => store.openCompositions);
    const activeCompositionId = computed(() => store.activeCompositionId);
    const mainCompositionId = computed(() => store.project.mainCompositionId);
    function switchToComposition(compId) {
      store.switchComposition(compId);
    }
    function closeTab(compId) {
      store.closeCompositionTab(compId);
    }
    function navigateToBreadcrumb(idx) {
      store.navigateToBreadcrumb(idx);
    }
    function navigateBack() {
      store.navigateBack();
    }
    function formatCompInfo(comp) {
      const s = comp.settings;
      return `${s.width}x${s.height} ${s.fps}fps`;
    }
    function startRename(comp) {
      editingId.value = comp.id;
      editingName.value = comp.name;
      nextTick(() => {
        renameInput.value?.focus();
        renameInput.value?.select();
      });
    }
    function finishRename() {
      if (editingId.value && editingName.value.trim()) {
        store.renameComposition(editingId.value, editingName.value.trim());
      }
      editingId.value = null;
      editingName.value = "";
    }
    function cancelRename() {
      editingId.value = null;
      editingName.value = "";
    }
    function showContextMenu(event, comp) {
      contextMenu.value = {
        visible: true,
        x: event.clientX,
        y: event.clientY,
        comp
      };
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.comp = null;
    }
    function openCompSettings() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== activeCompositionId.value) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      emit("openCompositionSettings");
      hideContextMenu();
    }
    function renameFromMenu() {
      if (contextMenu.value.comp) {
        startRename(contextMenu.value.comp);
      }
      hideContextMenu();
    }
    function duplicateComposition() {
      if (contextMenu.value.comp) {
        const original = contextMenu.value.comp;
        const newComp = store.createComposition(
          `${original.name} Copy`,
          original.settings,
          original.isNestedComp
        );
        for (const layer of original.layers) {
          const clonedLayer = structuredClone(layer);
          clonedLayer.id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          if (clonedLayer.properties) {
            for (const prop of clonedLayer.properties) {
              prop.id = `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
              if (prop.keyframes) {
                for (const kf of prop.keyframes) {
                  kf.id = `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                }
              }
            }
          }
          newComp.layers.push(clonedLayer);
        }
        console.log("[CompositionTabs] Duplicated:", newComp.name, "with", newComp.layers.length, "layers");
      }
      hideContextMenu();
    }
    function openInNewTab() {
      if (contextMenu.value.comp) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function setAsMainComp() {
      if (contextMenu.value.comp) {
        store.project.mainCompositionId = contextMenu.value.comp.id;
        console.log("[CompositionTabs] Set main composition:", contextMenu.value.comp.name);
      }
      hideContextMenu();
    }
    function deleteComposition() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== mainCompositionId.value) {
        store.deleteComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function handleOutsideClick() {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        breadcrumbPath.value.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_2$e, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(breadcrumbPath.value, (crumb, idx) => {
            return openBlock(), createElementBlock(Fragment, {
              key: crumb.id
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["breadcrumb-item", { current: idx === breadcrumbPath.value.length - 1 }]),
                onClick: ($event) => navigateToBreadcrumb(idx)
              }, toDisplayString(crumb.name), 11, _hoisted_3$e),
              idx < breadcrumbPath.value.length - 1 ? (openBlock(), createElementBlock("span", _hoisted_4$e, "")) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          createBaseVNode("button", {
            class: "back-btn",
            onClick: navigateBack,
            title: "Go back (Backspace)"
          }, "")
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_5$e, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(openCompositions.value, (comp) => {
            return openBlock(), createElementBlock("div", {
              key: comp.id,
              class: normalizeClass(["tab", {
                active: comp.id === activeCompositionId.value,
                nestedComp: comp.isNestedComp
              }]),
              onClick: ($event) => switchToComposition(comp.id),
              onDblclick: ($event) => startRename(comp),
              onContextmenu: withModifiers(($event) => showContextMenu($event, comp), ["prevent"])
            }, [
              comp.isNestedComp ? (openBlock(), createElementBlock("span", _hoisted_7$e, "")) : createCommentVNode("", true),
              editingId.value === comp.id ? (openBlock(), createElementBlock("span", _hoisted_8$d, [
                withDirectives(createBaseVNode("input", {
                  ref_for: true,
                  ref_key: "renameInput",
                  ref: renameInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editingName.value = $event),
                  type: "text",
                  class: "rename-input",
                  onBlur: finishRename,
                  onKeydown: [
                    withKeys(finishRename, ["enter"]),
                    withKeys(cancelRename, ["escape"])
                  ],
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 544), [
                  [vModelText, editingName.value]
                ])
              ])) : (openBlock(), createElementBlock("span", _hoisted_9$d, toDisplayString(comp.name), 1)),
              createBaseVNode("span", _hoisted_10$d, toDisplayString(formatCompInfo(comp)), 1),
              openCompositions.value.length > 1 ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "close-btn",
                onClick: withModifiers(($event) => closeTab(comp.id), ["stop"]),
                title: "Close tab"
              }, "  ", 8, _hoisted_11$c)) : createCommentVNode("", true)
            ], 42, _hoisted_6$e);
          }), 128)),
          createBaseVNode("button", {
            class: "new-comp-btn",
            onClick: _cache[2] || (_cache[2] = ($event) => emit("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "context-menu",
            style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: openCompSettings }, "Composition Settings..."),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            createBaseVNode("button", { onClick: duplicateComposition }, "Duplicate"),
            createBaseVNode("button", { onClick: openInNewTab }, "Open in New Tab"),
            _cache[4] || (_cache[4] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: setAsMainComp,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value
            }, " Set as Main Composition ", 8, _hoisted_12$b),
            _cache[5] || (_cache[5] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteComposition,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value,
              class: "danger"
            }, " Delete Composition ", 8, _hoisted_13$b)
          ], 4)) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const CompositionTabs = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-101554e9"]]);

const _hoisted_1$d = { class: "timeline-header" };
const _hoisted_2$d = { class: "header-left" };
const _hoisted_3$d = { class: "timecode" };
const _hoisted_4$d = { class: "frame-display" };
const _hoisted_5$d = ["value"];
const _hoisted_6$d = { class: "fps-label" };
const _hoisted_7$d = { class: "header-center" };
const _hoisted_8$c = ["aria-expanded"];
const _hoisted_9$c = { class: "tool-group" };
const _hoisted_10$c = ["disabled"];
const _hoisted_11$b = { class: "tool-group" };
const _hoisted_12$a = { class: "header-right" };
const _hoisted_13$a = { class: "timeline-content" };
const _hoisted_14$9 = { class: "sidebar-header-row" };
const _hoisted_15$8 = { class: "col-header col-switches" };
const MAX_PPF = 80;
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings", "openPathSuggestion"],
  setup(__props, { emit: __emit }) {
    const workAreaStart = inject("workAreaStart", ref(null));
    const workAreaEnd = inject("workAreaEnd", ref(null));
    const emit = __emit;
    const store = useCompositorStore();
    const audioStore = useAudioStore();
    const playbackStore = usePlaybackStore();
    const zoomPercent = ref(0);
    const sidebarWidth = ref(450);
    const expandedLayers = ref({});
    const showAddLayerMenu = ref(false);
    const addLayerContainer = ref(null);
    const trackViewportRef = ref(null);
    const rulerCanvas = ref(null);
    const sidebarScrollRef = ref(null);
    const trackScrollRef = ref(null);
    const rulerScrollRef = ref(null);
    let isScrollingSidebar = false;
    let isScrollingTrack = false;
    const viewportWidth = ref(1e3);
    const isDragOver = ref(false);
    const filteredLayers = computed(() => store.displayedLayers || []);
    const playheadPositionPct = computed(() => store.currentFrame / store.frameCount * 100);
    const effectivePpf = computed(() => {
      const minPpf = viewportWidth.value / store.frameCount;
      return minPpf + zoomPercent.value / 100 * (MAX_PPF - minPpf);
    });
    const timelineWidth = computed(() => {
      if (zoomPercent.value === 0) {
        return viewportWidth.value;
      }
      return store.frameCount * effectivePpf.value;
    });
    const computedWidthStyle = computed(() => timelineWidth.value + "px");
    const hasWorkArea = computed(() => workAreaStart.value !== null && workAreaEnd.value !== null);
    computed(() => {
      if (workAreaStart.value === null) return 0;
      return workAreaStart.value / store.frameCount * 100;
    });
    computed(() => {
      if (workAreaStart.value === null || workAreaEnd.value === null) return 100;
      const start = Math.min(workAreaStart.value, workAreaEnd.value);
      const end = Math.max(workAreaStart.value, workAreaEnd.value);
      return (end - start) / store.frameCount * 100;
    });
    const workAreaStyle = computed(() => {
      if (!hasWorkArea.value) return { display: "none" };
      const start = Math.min(workAreaStart.value, workAreaEnd.value);
      const end = Math.max(workAreaStart.value, workAreaEnd.value);
      return {
        left: start / store.frameCount * 100 + "%",
        width: (end - start) / store.frameCount * 100 + "%"
      };
    });
    const sidebarGridStyle = computed(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function toggleAddLayerMenu() {
      showAddLayerMenu.value = !showAddLayerMenu.value;
    }
    const addLayerMenuStyle = computed(() => {
      if (!showAddLayerMenu.value || !addLayerContainer.value) {
        return {};
      }
      const rect = addLayerContainer.value.getBoundingClientRect();
      return {
        position: "fixed",
        left: `${rect.left}px`,
        bottom: `${window.innerHeight - rect.top + 8}px`
      };
    });
    function addLayer(type) {
      let newLayer;
      if (type === "text") newLayer = store.createTextLayer();
      else if (type === "video") newLayer = store.createLayer("video");
      else if (type === "camera") newLayer = store.createCameraLayer();
      else if (type === "particles") newLayer = store.createParticleLayer();
      else newLayer = store.createLayer(type);
      showAddLayerMenu.value = false;
      if (newLayer) {
        store.selectLayer(newLayer.id);
        if (type === "spline" || type === "shape" || type === "path") {
          store.setTool("pen");
        } else if (type === "text") {
          store.setTool("text");
        } else {
          store.setTool("select");
        }
      }
    }
    function selectLayer(id) {
      store.selectLayer(id);
    }
    function updateLayer(id, u) {
      store.updateLayer(id, u);
    }
    function onDragOver(event) {
      if (event.dataTransfer?.types.includes("application/project-item")) {
        isDragOver.value = true;
      }
    }
    function onDragLeave() {
      isDragOver.value = false;
    }
    function onDrop(event) {
      isDragOver.value = false;
      const data = event.dataTransfer?.getData("application/project-item");
      if (!data) return;
      try {
        const item = JSON.parse(data);
        console.log("[TimelinePanel] Dropped item:", item);
        if (item.type === "composition") {
          const layer = store.createLayer("precomp", item.name);
          if (layer) {
            layer.data.compositionId = item.id;
            store.selectLayer(layer.id);
            console.log("[TimelinePanel] Created precomp layer for composition:", item.name);
          }
        } else if (item.type === "footage") {
          const asset = store.project.assets[item.id];
          if (asset) {
            if (asset.type === "video") {
              const layer = store.createLayer("video", item.name);
              if (layer) {
                layer.data.assetId = item.id;
                store.selectLayer(layer.id);
                console.log("[TimelinePanel] Created video layer from asset:", item.name);
              }
            } else if (asset.type === "image") {
              const layer = store.createLayer("image", item.name);
              if (layer) {
                layer.data.assetId = item.id;
                store.selectLayer(layer.id);
                console.log("[TimelinePanel] Created image layer from asset:", item.name);
              }
            }
          } else {
            const layer = store.createLayer("image", item.name);
            if (layer) {
              store.selectLayer(layer.id);
              console.log("[TimelinePanel] Created image layer:", item.name);
            }
          }
        } else if (item.type === "solid") {
          const layer = store.createLayer("solid", item.name);
          if (layer) {
            store.selectLayer(layer.id);
            console.log("[TimelinePanel] Created solid layer:", item.name);
          }
        } else if (item.type === "audio") {
          console.log("[TimelinePanel] Audio dropped - should be loaded via AudioPanel");
        }
      } catch (error) {
        console.error("[TimelinePanel] Failed to parse dropped item:", error);
      }
    }
    function deleteSelectedLayers() {
      store.selectedLayerIds.forEach((id) => store.deleteLayer(id));
    }
    function setFrame(e) {
      store.setFrame(parseInt(e.target.value) || 0);
    }
    function togglePlayback() {
      store.togglePlayback();
    }
    function handleToggleExpand(id, val) {
      expandedLayers.value[id] = val;
    }
    function formatTimecode(frame) {
      const fps = store.fps;
      const totalSeconds = Math.floor(frame / fps);
      const frames = Math.floor(frame % fps);
      const seconds = totalSeconds % 60;
      const minutes = Math.floor(totalSeconds / 60) % 60;
      const hours = Math.floor(totalSeconds / 3600);
      const pad = (n, len = 2) => String(n).padStart(len, "0");
      return `${pad(hours)};${pad(minutes)};${pad(seconds)};${pad(frames)}`;
    }
    function drawRuler() {
      const cvs = rulerCanvas.value;
      if (!cvs) return;
      const ctx = cvs.getContext("2d");
      if (!ctx) return;
      const width = timelineWidth.value;
      cvs.width = width;
      cvs.height = 30;
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, cvs.width, cvs.height);
      ctx.strokeStyle = "#666";
      ctx.fillStyle = "#aaa";
      ctx.font = "11px sans-serif";
      const labelMinWidth = 40;
      const maxLabels = Math.max(1, Math.floor(width / labelMinWidth));
      const idealStep = Math.ceil(store.frameCount / maxLabels);
      const niceSteps = [1, 2, 5, 10, 20, 25, 50, 100, 200];
      const majorStep = niceSteps.find((s) => s >= idealStep) || 200;
      const minorStep = majorStep > 1 ? Math.floor(majorStep / 2) : 0;
      const frameCount = store.frameCount;
      for (let f = 0; f <= frameCount; f++) {
        const x = f / frameCount * width;
        if (f % majorStep === 0) {
          ctx.strokeStyle = "#888";
          ctx.beginPath();
          ctx.moveTo(x, 12);
          ctx.lineTo(x, 30);
          ctx.stroke();
          ctx.fillStyle = "#ccc";
          ctx.fillText(String(f), x + 3, 10);
        } else if (minorStep > 0 && f % minorStep === 0) {
          ctx.strokeStyle = "#555";
          ctx.beginPath();
          ctx.moveTo(x, 22);
          ctx.lineTo(x, 30);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = "#444";
      ctx.beginPath();
      ctx.moveTo(0, 29.5);
      ctx.lineTo(cvs.width, 29.5);
      ctx.stroke();
    }
    function startRulerScrub(e) {
      const rect = rulerCanvas.value.getBoundingClientRect();
      const isAudioScrub = e.ctrlKey || e.metaKey;
      const update = (ev) => {
        const currentScrollX = rulerScrollRef.value?.scrollLeft || trackScrollRef.value?.scrollLeft || 0;
        const x = ev.clientX - rect.left + currentScrollX;
        let f = Math.max(0, Math.min(store.frameCount - 1, x / timelineWidth.value * store.frameCount));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(Math.round(f), store.snapConfig, effectivePpf.value, {
            layers: store.layers,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            f = snap.frame;
          }
        }
        const frame = Math.round(f);
        store.setFrame(frame);
        if (isAudioScrub || ev.ctrlKey || ev.metaKey) {
          audioStore.scrubAudio(frame, store.fps);
        }
      };
      update(e);
      window.addEventListener("mousemove", update);
      window.addEventListener("mouseup", () => {
        window.removeEventListener("mousemove", update);
        if (isAudioScrub) {
          audioStore.stopAudio();
        }
      }, { once: true });
    }
    function startResize(e) {
      const startX = e.clientX;
      const startW = sidebarWidth.value;
      const onMove = (ev) => {
        sidebarWidth.value = Math.max(450, startW + (ev.clientX - startX));
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", onMove), { once: true });
    }
    function clearWorkArea() {
      workAreaStart.value = null;
      workAreaEnd.value = null;
      playbackStore.clearWorkArea();
    }
    function startWorkAreaDrag(handle, e) {
      const rect = rulerCanvas.value.getBoundingClientRect();
      const update = (ev) => {
        const currentScrollX = rulerScrollRef.value?.scrollLeft || trackScrollRef.value?.scrollLeft || 0;
        const x = ev.clientX - rect.left + currentScrollX;
        let frame = Math.round(Math.max(0, Math.min(store.frameCount - 1, x / timelineWidth.value * store.frameCount)));
        if (handle === "start") {
          if (workAreaEnd.value !== null) {
            frame = Math.min(frame, workAreaEnd.value - 1);
          }
          workAreaStart.value = frame;
        } else {
          if (workAreaStart.value !== null) {
            frame = Math.max(frame, workAreaStart.value + 1);
          }
          workAreaEnd.value = frame;
        }
      };
      update(e);
      window.addEventListener("mousemove", update);
      window.addEventListener("mouseup", () => {
        window.removeEventListener("mousemove", update);
        playbackStore.setWorkArea(workAreaStart.value, workAreaEnd.value);
      }, { once: true });
    }
    function syncSidebarScroll(e) {
      if (isScrollingTrack) return;
      isScrollingSidebar = true;
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollTop = target.scrollTop;
      }
      requestAnimationFrame(() => {
        isScrollingSidebar = false;
      });
    }
    function handleTrackScroll(e) {
      const target = e.target;
      if (!isScrollingSidebar) {
        isScrollingTrack = true;
        if (sidebarScrollRef.value) {
          sidebarScrollRef.value.scrollTop = target.scrollTop;
        }
        requestAnimationFrame(() => {
          isScrollingTrack = false;
        });
      }
      if (rulerScrollRef.value) {
        rulerScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function syncRulerScroll(e) {
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function handleKeydown(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      if (e.code === "Space") {
        e.preventDefault();
        togglePlayback();
      }
      if (e.code === "Delete" || e.code === "Backspace") {
        e.preventDefault();
        deleteSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyC") {
        e.preventDefault();
        store.copySelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyX") {
        e.preventDefault();
        store.cutSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyV") {
        e.preventDefault();
        store.pasteLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyA") {
        e.preventDefault();
        store.selectedLayerIds = store.layers.map((l) => l.id);
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyD") {
        e.preventDefault();
        for (const id of store.selectedLayerIds) {
          store.duplicateLayer(id);
        }
      }
    }
    let resizeObserver = null;
    onMounted(() => {
      window.addEventListener("mousedown", (e) => {
        if (addLayerContainer.value && !addLayerContainer.value.contains(e.target)) {
          showAddLayerMenu.value = false;
        }
      });
      const elementToObserve = trackScrollRef.value || trackViewportRef.value;
      if (elementToObserve) {
        viewportWidth.value = elementToObserve.clientWidth || 1e3;
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            viewportWidth.value = entry.contentRect.width || elementToObserve.clientWidth || 1e3;
            drawRuler();
          }
        });
        resizeObserver.observe(elementToObserve);
      }
      setTimeout(() => {
        if (trackScrollRef.value) {
          viewportWidth.value = trackScrollRef.value.clientWidth || viewportWidth.value;
        }
        drawRuler();
      }, 50);
    });
    onUnmounted(() => {
      if (resizeObserver) resizeObserver.disconnect();
    });
    watch(() => [computedWidthStyle.value, zoomPercent.value, store.frameCount], () => nextTick(drawRuler));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "timeline-panel",
        tabindex: "0",
        onKeydown: handleKeydown,
        role: "region",
        "aria-label": "Timeline"
      }, [
        createVNode(CompositionTabs, {
          onNewComposition: _cache[0] || (_cache[0] = ($event) => emit("openCompositionSettings")),
          onOpenCompositionSettings: _cache[1] || (_cache[1] = ($event) => emit("openCompositionSettings"))
        }),
        createBaseVNode("div", _hoisted_1$d, [
          createBaseVNode("div", _hoisted_2$d, [
            createBaseVNode("span", _hoisted_3$d, toDisplayString(formatTimecode(unref(store).currentFrame)), 1),
            createBaseVNode("div", _hoisted_4$d, [
              createBaseVNode("input", {
                type: "number",
                value: unref(store).currentFrame,
                onChange: setFrame,
                class: "frame-input"
              }, null, 40, _hoisted_5$d),
              createBaseVNode("span", _hoisted_6$d, toDisplayString(unref(store).fps) + " fps", 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$d, [
            createBaseVNode("div", {
              class: "tool-group add-layer-wrapper",
              ref_key: "addLayerContainer",
              ref: addLayerContainer
            }, [
              createBaseVNode("button", {
                class: normalizeClass(["add-layer-btn", { active: showAddLayerMenu.value }]),
                onMousedown: withModifiers(toggleAddLayerMenu, ["stop", "prevent"]),
                "aria-label": "Add Layer",
                "aria-haspopup": "menu",
                "aria-expanded": showAddLayerMenu.value
              }, [..._cache[25] || (_cache[25] = [
                createBaseVNode("span", {
                  class: "icon",
                  "aria-hidden": "true"
                }, "+", -1),
                createTextVNode(" Layer ", -1)
              ])], 42, _hoisted_8$c),
              showAddLayerMenu.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "add-layer-menu",
                role: "menu",
                "aria-label": "Layer types",
                style: normalizeStyle(addLayerMenuStyle.value)
              }, [
                createBaseVNode("button", {
                  onMousedown: _cache[2] || (_cache[2] = ($event) => addLayer("solid")),
                  role: "menuitem"
                }, [..._cache[26] || (_cache[26] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Solid", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[3] || (_cache[3] = ($event) => addLayer("text")),
                  role: "menuitem"
                }, [..._cache[27] || (_cache[27] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "T", -1),
                  createTextVNode(" Text", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[4] || (_cache[4] = ($event) => addLayer("shape")),
                  role: "menuitem"
                }, [..._cache[28] || (_cache[28] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Shape", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[5] || (_cache[5] = ($event) => addLayer("spline")),
                  role: "menuitem"
                }, [..._cache[29] || (_cache[29] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Spline", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[6] || (_cache[6] = ($event) => addLayer("path")),
                  role: "menuitem"
                }, [..._cache[30] || (_cache[30] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Path", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[7] || (_cache[7] = ($event) => addLayer("particles")),
                  role: "menuitem"
                }, [..._cache[31] || (_cache[31] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Particles", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[8] || (_cache[8] = ($event) => addLayer("control")),
                  role: "menuitem"
                }, [..._cache[32] || (_cache[32] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Control", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[9] || (_cache[9] = ($event) => addLayer("camera")),
                  role: "menuitem"
                }, [..._cache[33] || (_cache[33] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Camera", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[10] || (_cache[10] = ($event) => addLayer("light")),
                  role: "menuitem"
                }, [..._cache[34] || (_cache[34] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Light", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[11] || (_cache[11] = ($event) => addLayer("video")),
                  role: "menuitem"
                }, [..._cache[35] || (_cache[35] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Video", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[12] || (_cache[12] = ($event) => addLayer("model")),
                  role: "menuitem"
                }, [..._cache[36] || (_cache[36] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" 3D Model", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[13] || (_cache[13] = ($event) => addLayer("pointcloud")),
                  role: "menuitem"
                }, [..._cache[37] || (_cache[37] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Point Cloud", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[14] || (_cache[14] = ($event) => addLayer("depth")),
                  role: "menuitem"
                }, [..._cache[38] || (_cache[38] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Depth Map", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[15] || (_cache[15] = ($event) => addLayer("normal")),
                  role: "menuitem"
                }, [..._cache[39] || (_cache[39] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Normal Map", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[16] || (_cache[16] = ($event) => addLayer("audio")),
                  role: "menuitem"
                }, [..._cache[40] || (_cache[40] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Audio", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[17] || (_cache[17] = ($event) => addLayer("generated")),
                  role: "menuitem"
                }, [..._cache[41] || (_cache[41] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" AI Generated", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[18] || (_cache[18] = ($event) => addLayer("group")),
                  role: "menuitem"
                }, [..._cache[42] || (_cache[42] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Group", -1)
                ])], 32)
              ], 4)) : createCommentVNode("", true)
            ], 512),
            createBaseVNode("div", _hoisted_9$c, [
              createBaseVNode("button", {
                class: "delete-btn",
                onClick: deleteSelectedLayers,
                disabled: unref(store).selectedLayerIds.length === 0,
                "aria-label": "Delete selected layers"
              }, "", 8, _hoisted_10$c)
            ]),
            createBaseVNode("div", _hoisted_11$b, [
              createBaseVNode("button", {
                class: "comp-settings-btn",
                onClick: _cache[19] || (_cache[19] = ($event) => emit("openCompositionSettings")),
                title: "Composition Settings (Ctrl+K)"
              }, "  Comp Settings "),
              createBaseVNode("button", {
                class: "ai-btn",
                onClick: _cache[20] || (_cache[20] = ($event) => emit("openPathSuggestion")),
                title: "AI Path Suggestion"
              }, "  AI ")
            ])
          ]),
          createBaseVNode("div", _hoisted_12$a, [
            withDirectives(createBaseVNode("input", {
              type: "range",
              min: "0",
              max: "100",
              step: "1",
              "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => zoomPercent.value = $event),
              class: "zoom-slider",
              title: "Zoom Timeline",
              "aria-label": "Timeline zoom level"
            }, null, 512), [
              [
                vModelText,
                zoomPercent.value,
                void 0,
                { number: true }
              ]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_13$a, [
          createBaseVNode("div", {
            class: "timeline-sidebar",
            style: normalizeStyle({ width: sidebarWidth.value + "px" })
          }, [
            createBaseVNode("div", _hoisted_14$9, [
              _cache[44] || (_cache[44] = createStaticVNode('<div class="col-header col-av-features" data-v-2e30f95f><span class="header-icon" title="Video" data-v-2e30f95f></span><span class="header-icon" title="Audio" data-v-2e30f95f></span><span class="header-icon" title="Isolate" data-v-2e30f95f></span><span class="header-icon" title="Lock" data-v-2e30f95f></span></div><div class="col-header col-number" data-v-2e30f95f>#</div><div class="col-header col-name" data-v-2e30f95f>Source Name</div>', 3)),
              createBaseVNode("div", _hoisted_15$8, [
                createBaseVNode("span", {
                  class: normalizeClass(["header-icon clickable", { active: unref(store).hideMinimizedLayers }]),
                  title: "Hide Minimized Layers",
                  onClick: _cache[22] || (_cache[22] = ($event) => unref(store).toggleHideMinimizedLayers())
                }, "", 2),
                _cache[43] || (_cache[43] = createStaticVNode('<span class="header-icon" title="Flatten Transform" data-v-2e30f95f></span><span class="header-icon" title="Quality" data-v-2e30f95f></span><span class="header-icon" title="Effects" data-v-2e30f95f>fx</span><span class="header-icon" title="Frame Blending" data-v-2e30f95f></span><span class="header-icon" title="Motion Blur" data-v-2e30f95f></span><span class="header-icon" title="Adjustment Layer" data-v-2e30f95f></span><span class="header-icon" title="3D Layer" data-v-2e30f95f></span>', 7))
              ]),
              _cache[45] || (_cache[45] = createBaseVNode("div", { class: "col-header col-parent" }, "Parent & Link", -1))
            ]),
            createBaseVNode("div", {
              class: "sidebar-scroll-area",
              ref_key: "sidebarScrollRef",
              ref: sidebarScrollRef,
              onScroll: syncSidebarScroll
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer, idx) => {
                return openBlock(), createBlock(EnhancedLayerTrack, {
                  key: layer.id,
                  layer,
                  index: idx + 1,
                  layoutMode: "sidebar",
                  isExpandedExternal: expandedLayers.value[layer.id],
                  allLayers: unref(store).layers,
                  gridStyle: sidebarGridStyle.value,
                  onToggleExpand: handleToggleExpand,
                  onSelect: selectLayer,
                  onUpdateLayer: updateLayer
                }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]);
              }), 128))
            ], 544)
          ], 4),
          createBaseVNode("div", {
            class: "sidebar-resizer",
            onMousedown: startResize
          }, null, 32),
          createBaseVNode("div", {
            class: "track-viewport",
            ref_key: "trackViewportRef",
            ref: trackViewportRef
          }, [
            createBaseVNode("div", {
              class: "ruler-scroll-wrapper",
              onScroll: syncRulerScroll,
              ref_key: "rulerScrollRef",
              ref: rulerScrollRef
            }, [
              createBaseVNode("div", {
                class: "time-ruler",
                style: normalizeStyle({ width: computedWidthStyle.value }),
                onMousedown: startRulerScrub
              }, [
                createBaseVNode("canvas", {
                  ref_key: "rulerCanvas",
                  ref: rulerCanvas,
                  height: "30"
                }, null, 512),
                hasWorkArea.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "work-area-bar",
                  style: normalizeStyle(workAreaStyle.value),
                  onDblclick: withModifiers(clearWorkArea, ["stop"]),
                  title: "Work Area (B/N to set, double-click to clear)"
                }, [
                  createBaseVNode("div", {
                    class: "work-area-handle work-area-handle-left",
                    onMousedown: _cache[23] || (_cache[23] = withModifiers(($event) => startWorkAreaDrag("start", $event), ["stop"]))
                  }, null, 32),
                  createBaseVNode("div", {
                    class: "work-area-handle work-area-handle-right",
                    onMousedown: _cache[24] || (_cache[24] = withModifiers(($event) => startWorkAreaDrag("end", $event), ["stop"]))
                  }, null, 32)
                ], 36)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "playhead-head",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4),
                createBaseVNode("div", {
                  class: "playhead-hit-area",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" }),
                  onMousedown: withModifiers(startRulerScrub, ["stop"])
                }, null, 36)
              ], 36)
            ], 544),
            createBaseVNode("div", {
              class: normalizeClass(["track-scroll-area", { "drag-over": isDragOver.value }]),
              ref_key: "trackScrollRef",
              ref: trackScrollRef,
              onScroll: handleTrackScroll,
              onDragover: withModifiers(onDragOver, ["prevent"]),
              onDragleave: onDragLeave,
              onDrop
            }, [
              createBaseVNode("div", {
                class: "layer-bars-container",
                style: normalizeStyle({ width: computedWidthStyle.value })
              }, [
                _cache[46] || (_cache[46] = createBaseVNode("div", { class: "grid-background" }, null, -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer) => {
                  return openBlock(), createBlock(EnhancedLayerTrack, {
                    key: layer.id,
                    layer,
                    layoutMode: "track",
                    frameCount: unref(store).frameCount,
                    pixelsPerFrame: effectivePpf.value,
                    isExpandedExternal: expandedLayers.value[layer.id],
                    onSelect: selectLayer,
                    onUpdateLayer: updateLayer
                  }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]);
                }), 128)),
                createBaseVNode("div", {
                  class: "playhead-line",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4)
              ], 4)
            ], 34)
          ], 512)
        ])
      ], 32);
    };
  }
});

const TimelinePanel = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-2e30f95f"]]);

const _hoisted_1$c = { class: "curve-editor" };
const _hoisted_2$c = { class: "curve-header" };
const _hoisted_3$c = { class: "mode-toggle" };
const _hoisted_4$c = { class: "preset-buttons" };
const _hoisted_5$c = ["onClick", "title"];
const _hoisted_6$c = { class: "toolbar" };
const _hoisted_7$c = { class: "curve-content" };
const _hoisted_8$b = { class: "property-list" };
const _hoisted_9$b = { class: "property-list-header" };
const _hoisted_10$b = ["title"];
const _hoisted_11$a = ["onClick"];
const _hoisted_12$9 = ["onClick"];
const _hoisted_13$9 = { class: "property-name" };
const _hoisted_14$8 = {
  key: 0,
  class: "keyframe-count"
};
const _hoisted_15$7 = {
  key: 0,
  class: "dimension-toggles"
};
const _hoisted_16$7 = ["onClick"];
const _hoisted_17$7 = {
  key: 0,
  class: "no-properties"
};
const _hoisted_18$7 = { class: "curve-main" };
const _hoisted_19$7 = ["viewBox"];
const _hoisted_20$7 = ["onMousedown"];
const _hoisted_21$7 = ["x", "y", "fill", "transform"];
const _hoisted_22$6 = {
  key: 1,
  class: "bezier-handles"
};
const _hoisted_23$6 = {
  key: 0,
  class: "handle out-handle"
};
const _hoisted_24$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$4 = ["cx", "cy", "onMousedown"];
const _hoisted_26$4 = {
  key: 1,
  class: "handle in-handle"
};
const _hoisted_27$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_28$4 = ["cx", "cy", "onMousedown"];
const _hoisted_29$4 = ["x1", "x2", "y2"];
const _hoisted_30$3 = {
  key: 0,
  class: "keyframe-info-panel"
};
const _hoisted_31$3 = { class: "info-row" };
const _hoisted_32$3 = ["value"];
const _hoisted_33$3 = { class: "info-row" };
const _hoisted_34$3 = ["value"];
const _hoisted_35$3 = { class: "info-row" };
const _hoisted_36$2 = ["value"];
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$2 = ["disabled"];
const _hoisted_39$2 = ["disabled"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "CurveEditor",
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const canvasRef = ref(null);
    const canvasContainerRef = ref(null);
    const timeRulerRef = ref(null);
    const timeRulerCanvas = ref(null);
    const valueAxisRef = ref(null);
    const valueAxisCanvas = ref(null);
    const canvasWidth = ref(400);
    const canvasHeight = ref(200);
    const mode = ref("value");
    const viewState = reactive({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    });
    const selectedPropertyIds = ref([]);
    const visiblePropertyIds = ref([]);
    const visibleDimensions = ref({});
    const selectedKeyframes = ref([]);
    const hoveredKeyframe = ref(null);
    const dragTarget = ref(null);
    const selectionBox = ref(null);
    const contextMenu = ref(null);
    const clipboard = ref(null);
    const snapEnabled = ref(false);
    const autoSelectNearby = ref(true);
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const propertyColors = {
      "Position": "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      "Scale": "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      "Rotation": "#bb8fce",
      "Opacity": "#f8b739",
      "default": "#7c9cff"
    };
    const presetList = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ];
    const animatableProperties = computed(() => {
      const layer = store.selectedLayer;
      if (!layer) return [];
      const props = [];
      props.push(layer.transform.position);
      props.push(layer.transform.scale);
      props.push(layer.transform.rotation);
      props.push(layer.opacity);
      props.push(...layer.properties);
      return props;
    });
    const visibleProperties = computed(() => {
      return animatableProperties.value.filter(
        (p) => visiblePropertyIds.value.includes(p.id) && p.animated
      );
    });
    const allPropertiesVisible = computed(() => {
      return animatableProperties.value.every((p) => visiblePropertyIds.value.includes(p.id));
    });
    const currentFrameScreenX = computed(() => {
      return frameToScreenX(store.currentFrame);
    });
    function frameToScreenX(frame) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (frame - viewState.frameStart) / (viewState.frameEnd - viewState.frameStart);
      return margin.left + t * graphWidth;
    }
    function screenXToFrame(screenX) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (screenX - margin.left) / graphWidth;
      return viewState.frameStart + t * (viewState.frameEnd - viewState.frameStart);
    }
    function valueToScreenY(value) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (value - viewState.valueMin) / (viewState.valueMax - viewState.valueMin);
      return canvasHeight.value - margin.bottom - t * graphHeight;
    }
    function screenYToValue(screenY) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (canvasHeight.value - margin.bottom - screenY) / graphHeight;
      return viewState.valueMin + t * (viewState.valueMax - viewState.valueMin);
    }
    function getKeyframeScreenX(kf) {
      return frameToScreenX(kf.frame);
    }
    function getKeyframeScreenY(prop, kf) {
      const value = typeof kf.value === "number" ? kf.value : typeof kf.value === "object" ? kf.value.x ?? kf.value : 0;
      return valueToScreenY(value);
    }
    function getKeyframeDisplayValue(selection) {
      if (!selection) return 0;
      const value = selection.keyframe.value;
      return typeof value === "number" ? value : typeof value === "object" ? value.x ?? 0 : 0;
    }
    function getOutHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.outHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getOutHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.outHandle.value;
      return valueToScreenY(handleValue);
    }
    function getInHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.inHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getInHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.inHandle.value;
      return valueToScreenY(handleValue);
    }
    function getNumericValue(value) {
      if (typeof value === "number") return value;
      if (typeof value === "object") return value.x ?? value.y ?? value.z ?? 0;
      return 0;
    }
    function getPropertyColor(propId) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return propertyColors.default;
      return propertyColors[prop.name] ?? propertyColors.default;
    }
    function isKeyframeInView(kf) {
      return kf.frame >= viewState.frameStart && kf.frame <= viewState.frameEnd;
    }
    function isKeyframeSelected(propId, index) {
      return selectedKeyframes.value.some((sk) => sk.propId === propId && sk.index === index);
    }
    function hasDimension(prop, dim) {
      if (!prop.animated || prop.keyframes.length === 0) return false;
      const value = prop.keyframes[0].value;
      return typeof value === "object" && dim in value;
    }
    function toggleProperty(propId) {
      const index = selectedPropertyIds.value.indexOf(propId);
      if (index === -1) {
        selectedPropertyIds.value.push(propId);
      } else {
        selectedPropertyIds.value.splice(index, 1);
      }
    }
    function togglePropertyVisibility(propId) {
      const index = visiblePropertyIds.value.indexOf(propId);
      if (index === -1) {
        visiblePropertyIds.value.push(propId);
      } else {
        visiblePropertyIds.value.splice(index, 1);
      }
      updateViewBounds();
    }
    function toggleAllProperties() {
      if (allPropertiesVisible.value) {
        visiblePropertyIds.value = [];
      } else {
        visiblePropertyIds.value = animatableProperties.value.map((p) => p.id);
      }
      updateViewBounds();
    }
    function toggleDimension(propId, dim) {
      if (!visibleDimensions.value[propId]) {
        visibleDimensions.value[propId] = [];
      }
      const dims = visibleDimensions.value[propId];
      const index = dims.indexOf(dim);
      if (index === -1) {
        dims.push(dim);
      } else {
        dims.splice(index, 1);
      }
    }
    function fitToView() {
      const visible = visibleProperties.value;
      if (visible.length === 0) return;
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const prop of visible) {
        for (const kf of prop.keyframes) {
          minFrame = Math.min(minFrame, kf.frame);
          maxFrame = Math.max(maxFrame, kf.frame);
          const value = getNumericValue(kf.value);
          minValue = Math.min(minValue, value);
          maxValue = Math.max(maxValue, value);
        }
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
    }
    function updateViewBounds() {
      fitToView();
    }
    function toggleAutoSelect() {
      autoSelectNearby.value = !autoSelectNearby.value;
    }
    function isPresetActive(presetKey) {
      if (selectedKeyframes.value.length === 0) return false;
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return false;
      if (presetKey === "linear") {
        return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "linear");
      }
      return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "bezier");
    }
    function applyPreset(presetKey) {
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const propertyPath = getPropertyPath(prop);
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? sk.keyframe.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - sk.keyframe.frame : 10;
        if (presetKey === "linear") {
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "linear");
          sk.keyframe.interpolation = "linear";
          sk.keyframe.outHandle = { frame: outDuration * 0.33, value: 0, enabled: false };
          sk.keyframe.inHandle = { frame: -inDuration * 0.33, value: 0, enabled: false };
        } else {
          const outHandle = {
            frame: preset.outHandle.x * outDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          const inHandle = {
            frame: -preset.inHandle.x * inDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "bezier");
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "out", outHandle);
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "in", inHandle);
          sk.keyframe.interpolation = "bezier";
          sk.keyframe.outHandle = outHandle;
          sk.keyframe.inHandle = inHandle;
        }
      }
      drawGraph();
    }
    function handleMouseDown(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 1 || event.button === 0 && event.altKey) {
        dragTarget.value = { type: "pan", startX: x, startY: y };
      } else if (event.button === 0) {
        if (!event.shiftKey) {
          selectedKeyframes.value = [];
        }
        selectionBox.value = { x, y, width: 0, height: 0 };
        dragTarget.value = { type: "select", startX: x, startY: y };
      }
    }
    function handleMouseMove(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      updateHoveredKeyframe(x, y);
      if (!dragTarget.value) return;
      if (dragTarget.value.type === "pan") {
        const dx = x - (dragTarget.value.startX ?? 0);
        const dy = y - (dragTarget.value.startY ?? 0);
        const graphWidth = canvasWidth.value - margin.left - margin.right;
        const graphHeight = canvasHeight.value - margin.top - margin.bottom;
        const frameShift = -dx / graphWidth * (viewState.frameEnd - viewState.frameStart);
        const valueShift = dy / graphHeight * (viewState.valueMax - viewState.valueMin);
        viewState.frameStart += frameShift;
        viewState.frameEnd += frameShift;
        viewState.valueMin += valueShift;
        viewState.valueMax += valueShift;
        dragTarget.value.startX = x;
        dragTarget.value.startY = y;
        drawGraph();
      } else if (dragTarget.value.type === "select" && selectionBox.value) {
        const startX = dragTarget.value.startX ?? 0;
        const startY = dragTarget.value.startY ?? 0;
        selectionBox.value = {
          x: Math.min(x, startX),
          y: Math.min(y, startY),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY)
        };
      } else if (dragTarget.value.type === "keyframe") {
        moveSelectedKeyframes(x, y);
      } else if (dragTarget.value.type === "outHandle" || dragTarget.value.type === "inHandle") {
        moveHandle(x, y);
      }
    }
    function handleMouseUp() {
      if (dragTarget.value?.type === "select" && selectionBox.value) {
        selectKeyframesInBox();
      }
      dragTarget.value = null;
      selectionBox.value = null;
    }
    function handleWheel(event) {
      event.preventDefault();
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
      const frameAtCursor = screenXToFrame(x);
      const newFrameStart = frameAtCursor - (frameAtCursor - viewState.frameStart) * zoomFactor;
      const newFrameEnd = frameAtCursor + (viewState.frameEnd - frameAtCursor) * zoomFactor;
      if (event.shiftKey) {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
      } else {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
        const y = event.clientY - rect.top;
        const valueAtCursor = screenYToValue(y);
        viewState.valueMin = valueAtCursor - (valueAtCursor - viewState.valueMin) * zoomFactor;
        viewState.valueMax = valueAtCursor + (viewState.valueMax - valueAtCursor) * zoomFactor;
      }
      drawGraph();
    }
    function updateHoveredKeyframe(x, y) {
      hoveredKeyframe.value = null;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const kfX = getKeyframeScreenX(kf);
          const kfY = getKeyframeScreenY(prop, kf);
          const dist = Math.sqrt((x - kfX) ** 2 + (y - kfY) ** 2);
          if (dist < 10) {
            hoveredKeyframe.value = { propId: prop.id, index: i };
            return;
          }
        }
      }
    }
    function onKeyframeMouseDown(propId, index, event) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return;
      const kf = prop.keyframes[index];
      if (!event.shiftKey) {
        selectedKeyframes.value = [];
      }
      if (!isKeyframeSelected(propId, index)) {
        selectedKeyframes.value.push({ propId, index, keyframe: kf });
      }
      dragTarget.value = { type: "keyframe", propId, index };
    }
    function selectKeyframesInBox() {
      if (!selectionBox.value) return;
      const box = selectionBox.value;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const x = getKeyframeScreenX(kf);
          const y = getKeyframeScreenY(prop, kf);
          if (x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height) {
            if (!isKeyframeSelected(prop.id, i)) {
              selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: kf });
            }
          }
        }
      }
    }
    function moveSelectedKeyframes(screenX, screenY) {
      const newFrame = Math.round(screenXToFrame(screenX));
      const newValue = screenYToValue(screenY);
      const layer = store.selectedLayer;
      if (!layer) return;
      if (selectedKeyframes.value.length > 0) {
        const sk = selectedKeyframes.value[0];
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) return;
        const frame = snapEnabled.value ? Math.round(newFrame / 5) * 5 : newFrame;
        const propertyPath = getPropertyPath(prop);
        store.updateKeyframe(layer.id, propertyPath, sk.keyframe.id, {
          frame,
          value: typeof sk.keyframe.value === "number" ? newValue : void 0
        });
        sk.keyframe.frame = frame;
        if (typeof sk.keyframe.value === "number") {
          sk.keyframe.value = newValue;
        }
      }
      drawGraph();
    }
    function getPropertyPath(prop) {
      const name = prop.name.toLowerCase();
      if (name === "position") return "transform.position";
      if (name === "scale") return "transform.scale";
      if (name === "rotation") return "transform.rotation";
      if (name === "opacity") return "opacity";
      if (name === "anchor point") return "transform.anchorPoint";
      return prop.id;
    }
    function startDragHandle(type, propId, index, event) {
      dragTarget.value = { type, propId, index };
      document.addEventListener("mousemove", onDragHandle);
      document.addEventListener("mouseup", stopDragHandle);
    }
    function onDragHandle(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect || !dragTarget.value) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      moveHandle(x, y);
    }
    function moveHandle(screenX, screenY) {
      if (!dragTarget.value || !dragTarget.value.propId) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = animatableProperties.value.find((p) => p.id === dragTarget.value.propId);
      if (!prop) return;
      const kfIndex = dragTarget.value.index;
      const kf = prop.keyframes[kfIndex];
      if (!kf) return;
      const handleFrame = screenXToFrame(screenX);
      const handleValue = screenYToValue(screenY);
      const propertyPath = getPropertyPath(prop);
      if (dragTarget.value.type === "outHandle") {
        const nextKf = prop.keyframes[kfIndex + 1];
        let frameOffset = handleFrame - kf.frame;
        if (nextKf) {
          frameOffset = Math.max(0, Math.min(nextKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.max(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", newHandle);
        kf.outHandle = newHandle;
        kf.interpolation = "bezier";
        applyControlModeConstraints(kf, "out", propertyPath);
      } else if (dragTarget.value.type === "inHandle") {
        const prevKf = prop.keyframes[kfIndex - 1];
        let frameOffset = handleFrame - kf.frame;
        if (prevKf) {
          frameOffset = Math.min(0, Math.max(prevKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.min(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", newHandle);
        kf.inHandle = newHandle;
        applyControlModeConstraints(kf, "in", propertyPath);
      }
      drawGraph();
    }
    function applyControlModeConstraints(kf, changedHandle, propertyPath) {
      if (!kf.controlMode || kf.controlMode === "corner") {
        return;
      }
      const layer = store.selectedLayer;
      if (!layer) return;
      if (kf.controlMode === "symmetric") {
        if (changedHandle === "in") {
          kf.outHandle.frame = -kf.inHandle.frame;
          kf.outHandle.value = -kf.inHandle.value;
          kf.outHandle.enabled = kf.inHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", { ...kf.outHandle });
        } else {
          kf.inHandle.frame = -kf.outHandle.frame;
          kf.inHandle.value = -kf.outHandle.value;
          kf.inHandle.enabled = kf.outHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", { ...kf.inHandle });
        }
      }
      if (kf.controlMode === "smooth") {
        const changed = changedHandle === "in" ? kf.inHandle : kf.outHandle;
        const other = changedHandle === "in" ? kf.outHandle : kf.inHandle;
        const otherType = changedHandle === "in" ? "out" : "in";
        if (changed.frame !== 0 || changed.value !== 0) {
          const angle = Math.atan2(changed.value, changed.frame);
          const oppositeAngle = angle + Math.PI;
          const otherLength = Math.hypot(other.frame, other.value);
          other.frame = Math.cos(oppositeAngle) * otherLength;
          other.value = Math.sin(oppositeAngle) * otherLength;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, otherType, { ...other });
        }
      }
    }
    function stopDragHandle() {
      dragTarget.value = null;
      document.removeEventListener("mousemove", onDragHandle);
      document.removeEventListener("mouseup", stopDragHandle);
    }
    function showContextMenu(event) {
      contextMenu.value = { x: event.offsetX, y: event.offsetY };
    }
    function addKeyframeAtPosition() {
      if (!contextMenu.value) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const frame = Math.round(screenXToFrame(contextMenu.value.x));
      const value = screenYToValue(contextMenu.value.y);
      if (visibleProperties.value.length > 0) {
        const prop = visibleProperties.value[0];
        const propertyPath = getPropertyPath(prop);
        const keyframeValue = typeof prop.value === "number" ? value : { x: value, y: value };
        store.addKeyframe(layer.id, propertyPath, keyframeValue, frame);
        drawGraph();
      }
      contextMenu.value = null;
    }
    function deleteSelectedKeyframes() {
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (prop) {
          const propertyPath = getPropertyPath(prop);
          store.removeKeyframe(layer.id, propertyPath, sk.keyframe.id);
        }
      }
      selectedKeyframes.value = [];
      drawGraph();
    }
    function copyKeyframes() {
      clipboard.value = selectedKeyframes.value.map((sk) => ({ ...sk.keyframe }));
    }
    function pasteKeyframes() {
      if (!clipboard.value || visibleProperties.value.length === 0) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = visibleProperties.value[0];
      const propertyPath = getPropertyPath(prop);
      const offset = store.currentFrame - clipboard.value[0].frame;
      for (const kf of clipboard.value) {
        const newFrame = kf.frame + offset;
        const newKeyframe = store.addKeyframe(layer.id, propertyPath, kf.value, newFrame);
        if (newKeyframe) {
          if (kf.interpolation !== "linear") {
            store.setKeyframeInterpolation(layer.id, propertyPath, newKeyframe.id, kf.interpolation);
          }
          if (kf.inHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "in", kf.inHandle);
          }
          if (kf.outHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "out", kf.outHandle);
          }
        }
      }
      drawGraph();
    }
    function selectAllKeyframes() {
      selectedKeyframes.value = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
        }
      }
    }
    function invertSelection() {
      const newSelection = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          if (!isKeyframeSelected(prop.id, i)) {
            newSelection.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
          }
        }
      }
      selectedKeyframes.value = newSelection;
    }
    function updateSelectedKeyframeFrame(event) {
      const value = parseInt(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        selectedKeyframes.value[0].keyframe.frame = value;
        drawGraph();
      }
    }
    function updateSelectedKeyframeValue(event) {
      const value = parseFloat(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        const kf = selectedKeyframes.value[0].keyframe;
        if (typeof kf.value === "number") {
          kf.value = value;
        } else if (typeof kf.value === "object") {
          kf.value.x = value;
        }
        drawGraph();
      }
    }
    function updateSelectedKeyframeInterpolation(event) {
      const value = event.target.value;
      if (selectedKeyframes.value.length > 0) {
        selectedKeyframes.value[0].keyframe.interpolation = value;
        drawGraph();
      }
    }
    function onTimeRulerClick(event) {
      const rect = timeRulerCanvas.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const frame = Math.round(screenXToFrame(x));
      store.setFrame(frame);
    }
    function drawGraph() {
      drawMainCanvas();
      drawTimeRuler();
      drawValueAxis();
    }
    function drawMainCanvas() {
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = canvasWidth.value;
      canvas.height = canvasHeight.value;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
      drawGrid(ctx);
      for (const prop of visibleProperties.value) {
        drawPropertyCurve(ctx, prop);
      }
    }
    function drawGrid(ctx) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, graphWidth, 50);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, graphHeight, 30);
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
      ctx.strokeStyle = "#3a3a3a";
      ctx.lineWidth = 1;
      if (viewState.frameStart <= 0 && viewState.frameEnd >= 0) {
        const x = frameToScreenX(0);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      if (viewState.valueMin <= 0 && viewState.valueMax >= 0) {
        const y = valueToScreenY(0);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
    }
    function calculateGridStep(range, pixelSize, targetSpacing) {
      const rawStep = range * targetSpacing / pixelSize;
      const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const normalized = rawStep / magnitude;
      if (normalized <= 1) return magnitude;
      if (normalized <= 2) return 2 * magnitude;
      if (normalized <= 5) return 5 * magnitude;
      return 10 * magnitude;
    }
    function drawPropertyCurve(ctx, prop) {
      if (prop.keyframes.length < 2) return;
      const color = getPropertyColor(prop.id);
      for (let pass = 0; pass < 2; pass++) {
        if (pass === 0) {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < prop.keyframes.length - 1; i++) {
          const kf1 = prop.keyframes[i];
          const kf2 = prop.keyframes[i + 1];
          if (kf2.frame < viewState.frameStart || kf1.frame > viewState.frameEnd) continue;
          const x1 = getKeyframeScreenX(kf1);
          const y1 = getKeyframeScreenY(prop, kf1);
          const x2 = getKeyframeScreenX(kf2);
          const y2 = getKeyframeScreenY(prop, kf2);
          if (!started) {
            ctx.moveTo(x1, y1);
            started = true;
          }
          if (kf1.interpolation === "hold") {
            ctx.lineTo(x2, y1);
            ctx.lineTo(x2, y2);
          } else if (kf1.interpolation === "linear" || !kf1.outHandle.enabled && !kf2.inHandle.enabled) {
            ctx.lineTo(x2, y2);
          } else {
            const cp1x = frameToScreenX(kf1.frame + kf1.outHandle.frame);
            const cp1y = valueToScreenY(getNumericValue(kf1.value) + kf1.outHandle.value);
            const cp2x = frameToScreenX(kf2.frame + kf2.inHandle.frame);
            const cp2y = valueToScreenY(getNumericValue(kf2.value) + kf2.inHandle.value);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
          }
        }
        ctx.stroke();
      }
    }
    function drawTimeRuler() {
      const canvas = timeRulerCanvas.value;
      if (!canvas) return;
      const rect = timeRulerRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = rect.width;
      canvas.height = 24;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, canvas.width, 60);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.fillText(frame.toString(), x, 16);
        ctx.strokeStyle = "#444";
        ctx.beginPath();
        ctx.moveTo(x, 20);
        ctx.lineTo(x, 24);
        ctx.stroke();
      }
      const ctfX = frameToScreenX(store.currentFrame);
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.moveTo(ctfX - 5, 0);
      ctx.lineTo(ctfX + 5, 0);
      ctx.lineTo(ctfX, 8);
      ctx.closePath();
      ctx.fill();
    }
    function drawValueAxis() {
      const canvas = valueAxisCanvas.value;
      if (!canvas) return;
      const rect = valueAxisRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = 40;
      canvas.height = rect.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, canvas.height, 30);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.fillText(value.toFixed(0), 36, y + 4);
      }
    }
    function applyEasyEase(direction = "both") {
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const kf = sk.keyframe;
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? kf.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - kf.frame : 10;
        const influence = 0.3333;
        if (direction === "both" || direction === "in") {
          kf.inHandle = {
            frame: -inDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        if (direction === "both" || direction === "out") {
          kf.outHandle = {
            frame: outDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        kf.interpolation = "bezier";
        kf.controlMode = "smooth";
      }
      drawGraph();
    }
    function goToPreviousKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const prev = [...allKeyframes].reverse().find((f) => f < currentFrame);
      if (prev !== void 0) {
        store.setFrame(prev);
      }
    }
    function goToNextKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const next = allKeyframes.find((f) => f > currentFrame);
      if (next !== void 0) {
        store.setFrame(next);
      }
    }
    function handleKeyDown(event) {
      if (event.key === "F9") {
        event.preventDefault();
        if (event.ctrlKey && event.shiftKey) {
          applyEasyEase("out");
        } else if (event.shiftKey) {
          applyEasyEase("in");
        } else {
          applyEasyEase("both");
        }
        return;
      }
      if (event.key.toLowerCase() === "j") {
        event.preventDefault();
        goToPreviousKeyframe();
        return;
      }
      if (event.key.toLowerCase() === "k") {
        event.preventDefault();
        goToNextKeyframe();
        return;
      }
      if (event.key === "Delete" || event.key === "Backspace") {
        event.preventDefault();
        deleteSelectedKeyframes();
        return;
      }
      if (event.key.toLowerCase() === "f" && !event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          fitToView();
        } else if (selectedKeyframes.value.length > 0) {
          fitSelectionToView();
        } else {
          fitToView();
        }
        return;
      }
      if (event.key === "=" || event.key === "+") {
        event.preventDefault();
        zoomIn();
        return;
      }
      if (event.key === "-" || event.key === "_") {
        event.preventDefault();
        zoomOut();
        return;
      }
    }
    function fitSelectionToView() {
      if (selectedKeyframes.value.length === 0) {
        fitToView();
        return;
      }
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const sk of selectedKeyframes.value) {
        minFrame = Math.min(minFrame, sk.keyframe.frame);
        maxFrame = Math.max(maxFrame, sk.keyframe.frame);
        const value = getNumericValue(sk.keyframe.value);
        minValue = Math.min(minValue, value);
        maxValue = Math.max(maxValue, value);
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
      drawGraph();
    }
    function zoomIn() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.4;
      viewState.frameEnd = centerFrame + frameRange * 0.4;
      drawGraph();
    }
    function zoomOut() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.6;
      viewState.frameEnd = centerFrame + frameRange * 0.6;
      drawGraph();
    }
    let resizeObserver = null;
    onMounted(() => {
      if (canvasContainerRef.value) {
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            canvasWidth.value = entry.contentRect.width;
            canvasHeight.value = entry.contentRect.height;
            drawGraph();
          }
        });
        resizeObserver.observe(canvasContainerRef.value);
      }
      visiblePropertyIds.value = animatableProperties.value.filter((p) => p.animated).map((p) => p.id);
      window.addEventListener("keydown", handleKeyDown);
      fitToView();
      drawGraph();
    });
    onUnmounted(() => {
      resizeObserver?.disconnect();
      window.removeEventListener("keydown", handleKeyDown);
    });
    watch([() => store.currentFrame, visiblePropertyIds, mode], () => {
      drawGraph();
    });
    watch(animatableProperties, () => {
      fitToView();
      drawGraph();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createBaseVNode("div", _hoisted_2$c, [
          _cache[9] || (_cache[9] = createBaseVNode("span", { class: "curve-title" }, "Curve Editor", -1)),
          createBaseVNode("div", _hoisted_3$c, [
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "value" }),
              onClick: _cache[0] || (_cache[0] = ($event) => mode.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "speed" }),
              onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          createBaseVNode("div", _hoisted_4$c, [
            (openBlock(), createElementBlock(Fragment, null, renderList(presetList, (preset) => {
              return createBaseVNode("button", {
                key: preset.key,
                class: normalizeClass(["preset-btn", { active: isPresetActive(preset.key) }]),
                onClick: ($event) => applyPreset(preset.key),
                title: preset.label
              }, toDisplayString(preset.shortLabel), 11, _hoisted_5$c);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_6$c, [
            createBaseVNode("button", {
              onClick: fitToView,
              title: "Fit to View"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("span", { class: "icon" }, "[ ]", -1)
            ])]),
            createBaseVNode("button", {
              onClick: toggleAutoSelect,
              class: normalizeClass({ active: autoSelectNearby.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("span", { class: "icon" }, "A", -1)
            ])], 2),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => snapEnabled.value = !snapEnabled.value),
              class: normalizeClass({ active: snapEnabled.value }),
              title: "Snap to Grid"
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          createBaseVNode("button", {
            class: "close-btn",
            onClick: _cache[3] || (_cache[3] = ($event) => emit("close"))
          }, [..._cache[8] || (_cache[8] = [
            createBaseVNode("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        createBaseVNode("div", _hoisted_7$c, [
          createBaseVNode("div", _hoisted_8$b, [
            createBaseVNode("div", _hoisted_9$b, [
              _cache[10] || (_cache[10] = createTextVNode(" Properties ", -1)),
              createBaseVNode("button", {
                class: "toggle-all-btn",
                onClick: toggleAllProperties,
                title: allPropertiesVisible.value ? "Hide All" : "Show All"
              }, toDisplayString(allPropertiesVisible.value ? "Hide" : "Show"), 9, _hoisted_10$b)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(animatableProperties.value, (prop) => {
              return openBlock(), createElementBlock("div", {
                key: prop.id,
                class: normalizeClass(["property-item", {
                  selected: selectedPropertyIds.value.includes(prop.id),
                  animated: prop.animated
                }])
              }, [
                createBaseVNode("div", {
                  class: "property-row",
                  onClick: ($event) => toggleProperty(prop.id)
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(["visibility-toggle", { visible: visiblePropertyIds.value.includes(prop.id) }]),
                    onClick: withModifiers(($event) => togglePropertyVisibility(prop.id), ["stop"])
                  }, null, 10, _hoisted_12$9),
                  createBaseVNode("span", {
                    class: "property-color",
                    style: normalizeStyle({ background: getPropertyColor(prop.id) })
                  }, null, 4),
                  createBaseVNode("span", _hoisted_13$9, toDisplayString(prop.name), 1),
                  prop.animated ? (openBlock(), createElementBlock("span", _hoisted_14$8, toDisplayString(prop.keyframes.length), 1)) : createCommentVNode("", true)
                ], 8, _hoisted_11$a),
                prop.name === "Position" || prop.name === "Scale" ? (openBlock(), createElementBlock("div", _hoisted_15$7, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(["x", "y", "z"], (dim) => {
                    return createBaseVNode("button", {
                      key: dim,
                      class: normalizeClass({
                        active: visibleDimensions.value[prop.id]?.includes(dim),
                        hasValue: hasDimension(prop, dim)
                      }),
                      onClick: ($event) => toggleDimension(prop.id, dim)
                    }, toDisplayString(dim.toUpperCase()), 11, _hoisted_16$7);
                  }), 64))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128)),
            animatableProperties.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_17$7, " No animated properties ")) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$7, [
            createBaseVNode("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: timeRulerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "timeRulerCanvas",
                ref: timeRulerCanvas,
                onClick: onTimeRulerClick
              }, null, 512)
            ], 512),
            createBaseVNode("div", {
              class: "curve-canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "canvasRef",
                ref: canvasRef,
                onMousedown: handleMouseDown,
                onMousemove: handleMouseMove,
                onMouseup: handleMouseUp,
                onMouseleave: handleMouseUp,
                onWheel: handleWheel,
                onContextmenu: withModifiers(showContextMenu, ["prevent"])
              }, null, 544),
              selectionBox.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "selection-box",
                style: normalizeStyle({
                  left: selectionBox.value.x + "px",
                  top: selectionBox.value.y + "px",
                  width: selectionBox.value.width + "px",
                  height: selectionBox.value.height + "px"
                })
              }, null, 4)) : createCommentVNode("", true),
              (openBlock(), createElementBlock("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleProperties.value, (prop) => {
                  return openBlock(), createElementBlock("g", {
                    key: prop.id,
                    class: "property-handles"
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(prop.keyframes, (kf, kfIndex) => {
                      return openBlock(), createElementBlock(Fragment, { key: kfIndex }, [
                        isKeyframeInView(kf) ? (openBlock(), createElementBlock("g", {
                          key: 0,
                          class: normalizeClass(["keyframe-marker", {
                            selected: isKeyframeSelected(prop.id, kfIndex),
                            hovered: hoveredKeyframe.value?.propId === prop.id && hoveredKeyframe.value?.index === kfIndex
                          }]),
                          onMousedown: withModifiers(($event) => onKeyframeMouseDown(prop.id, kfIndex, $event), ["stop"])
                        }, [
                          createBaseVNode("rect", {
                            x: getKeyframeScreenX(kf) - 5,
                            y: getKeyframeScreenY(prop, kf) - 5,
                            width: "10",
                            height: "10",
                            fill: getPropertyColor(prop.id),
                            "transform-origin": "center",
                            transform: `rotate(45, ${getKeyframeScreenX(kf)}, ${getKeyframeScreenY(prop, kf)})`
                          }, null, 8, _hoisted_21$7)
                        ], 42, _hoisted_20$7)) : createCommentVNode("", true),
                        isKeyframeSelected(prop.id, kfIndex) && kf.interpolation !== "hold" ? (openBlock(), createElementBlock("g", _hoisted_22$6, [
                          prop.keyframes[kfIndex + 1] && (kf.outHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_23$6, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getOutHandleX(prop, kfIndex),
                              y2: getOutHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_24$4),
                            createBaseVNode("circle", {
                              cx: getOutHandleX(prop, kfIndex),
                              cy: getOutHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "outHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("outHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_25$4)
                          ])) : createCommentVNode("", true),
                          kfIndex > 0 && (kf.inHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_26$4, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getInHandleX(prop, kfIndex),
                              y2: getInHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_27$4),
                            createBaseVNode("circle", {
                              cx: getInHandleX(prop, kfIndex),
                              cy: getInHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "inHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("inHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_28$4)
                          ])) : createCommentVNode("", true)
                        ])) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]);
                }), 128)),
                createBaseVNode("line", {
                  x1: currentFrameScreenX.value,
                  y1: 0,
                  x2: currentFrameScreenX.value,
                  y2: canvasHeight.value,
                  class: "current-time-line"
                }, null, 8, _hoisted_29$4)
              ], 8, _hoisted_19$7))
            ], 512),
            createBaseVNode("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: valueAxisRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "valueAxisCanvas",
                ref: valueAxisCanvas
              }, null, 512)
            ], 512)
          ])
        ]),
        selectedKeyframes.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$3, [
          createBaseVNode("div", _hoisted_31$3, [
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "info-label" }, "Frame:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: selectedKeyframes.value[0]?.keyframe.frame,
              onChange: updateSelectedKeyframeFrame,
              class: "info-input"
            }, null, 40, _hoisted_32$3)
          ]),
          createBaseVNode("div", _hoisted_33$3, [
            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "info-label" }, "Value:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: getKeyframeDisplayValue(selectedKeyframes.value[0]),
              onChange: updateSelectedKeyframeValue,
              class: "info-input",
              step: "0.1"
            }, null, 40, _hoisted_34$3)
          ]),
          createBaseVNode("div", _hoisted_35$3, [
            _cache[14] || (_cache[14] = createBaseVNode("span", { class: "info-label" }, "Interpolation:", -1)),
            createBaseVNode("select", {
              value: selectedKeyframes.value[0]?.keyframe.interpolation,
              onChange: updateSelectedKeyframeInterpolation,
              class: "info-select"
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "linear" }, "Linear", -1),
              createBaseVNode("option", { value: "bezier" }, "Bezier", -1),
              createBaseVNode("option", { value: "hold" }, "Hold", -1)
            ])], 40, _hoisted_36$2)
          ])
        ])) : createCommentVNode("", true),
        contextMenu.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "context-menu",
          style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
          onClick: _cache[4] || (_cache[4] = ($event) => contextMenu.value = null)
        }, [
          createBaseVNode("button", { onClick: addKeyframeAtPosition }, "Add Keyframe"),
          createBaseVNode("button", {
            onClick: deleteSelectedKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Delete Keyframe(s)", 8, _hoisted_37$2),
          _cache[15] || (_cache[15] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", {
            onClick: copyKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Copy", 8, _hoisted_38$2),
          createBaseVNode("button", {
            onClick: pasteKeyframes,
            disabled: !clipboard.value
          }, "Paste", 8, _hoisted_39$2),
          _cache[16] || (_cache[16] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", { onClick: selectAllKeyframes }, "Select All"),
          createBaseVNode("button", { onClick: invertSelection }, "Invert Selection")
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
});

const CurveEditor = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-eb640822"]]);

class ArcLengthParameterizer {
  curve;
  totalLength;
  /**
   * @param curve - Three.js curve instance (CubicBezierCurve, CubicBezierCurve3, etc.)
   * @param arcLengthDivisions - Number of divisions for arc-length calculation (higher = more accurate)
   */
  constructor(curve, arcLengthDivisions = 200) {
    this.curve = curve;
    this.curve.updateArcLengths();
    this.totalLength = this.curve.getLength();
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    const u = distance / this.totalLength;
    return this.curve.getUtoTmapping(u, distance);
  }
  /**
   * Get point and tangent at arc length distance (2D)
   */
  getPointAtDistance(distance) {
    const u = Math.max(0, Math.min(1, distance / this.totalLength));
    const point = this.curve.getPointAt(u);
    const tangent = this.curve.getTangentAt(u);
    return {
      point: { x: point.x, y: point.y },
      tangent: { x: tangent.x, y: tangent.y },
      t: this.distanceToT(distance)
    };
  }
  /**
   * Get point and tangent at arc length distance (3D)
   */
  getPointAtDistance3D(distance) {
    const u = Math.max(0, Math.min(1, distance / this.totalLength));
    const point = this.curve.getPointAt(u);
    const tangent = this.curve.getTangentAt(u);
    return {
      point: { x: point.x, y: point.y, z: point.z || 0 },
      tangent: { x: tangent.x, y: tangent.y, z: tangent.z || 0 },
      t: this.distanceToT(distance)
    };
  }
  /**
   * Get evenly spaced points along the curve (2D)
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(count) {
    const points = [];
    for (let i = 0; i < count; i++) {
      const u = i / (count - 1);
      const distance = u * this.totalLength;
      points.push(this.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Get evenly spaced points along the curve (3D)
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints3D(count) {
    const points = [];
    for (let i = 0; i < count; i++) {
      const u = i / (count - 1);
      const distance = u * this.totalLength;
      points.push(this.getPointAtDistance3D(distance));
    }
    return points;
  }
  /**
   * Get the underlying Three.js curve
   */
  getCurve() {
    return this.curve;
  }
}
function pathCommandsToBezier(pathCommands) {
  if (!pathCommands || pathCommands.length < 2) {
    return null;
  }
  let startPoint = null;
  for (const cmd of pathCommands) {
    const [command, ...coords] = cmd;
    if (command === "M") {
      startPoint = { x: coords[0], y: coords[1], z: coords[2] || 0 };
    } else if (command === "C" && startPoint) {
      return new CubicBezierCurve3(
        new Vector3(startPoint.x, startPoint.y, startPoint.z),
        new Vector3(coords[0], coords[1], coords[2] || 0),
        new Vector3(coords[3] || coords[2], coords[4] || coords[3], coords[5] || 0),
        new Vector3(coords[6] || coords[4], coords[7] || coords[5], coords[8] || 0)
      );
    } else if (command === "Q" && startPoint) {
      const qcp = { x: coords[0], y: coords[1], z: coords[2] || 0 };
      const end = { x: coords[3] || coords[2], y: coords[4] || coords[3], z: coords[5] || 0 };
      const cp1 = {
        x: (startPoint.x + 2 * qcp.x) / 3,
        y: (startPoint.y + 2 * qcp.y) / 3,
        z: (startPoint.z + 2 * qcp.z) / 3
      };
      const cp2 = {
        x: (2 * qcp.x + end.x) / 3,
        y: (2 * qcp.y + end.y) / 3,
        z: (2 * qcp.z + end.z) / 3
      };
      return new CubicBezierCurve3(
        new Vector3(startPoint.x, startPoint.y, startPoint.z),
        new Vector3(cp1.x, cp1.y, cp1.z),
        new Vector3(cp2.x, cp2.y, cp2.z),
        new Vector3(end.x, end.y, end.z)
      );
    }
  }
  return null;
}

class MatteExporter {
  offscreenCanvas = null;
  ctx = null;
  particleSystems = /* @__PURE__ */ new Map();
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(width, height) {
    const correctedWidth = Math.round(width / 8) * 8;
    const correctedHeight = Math.round(height / 8) * 8;
    const finalWidth = Math.max(256, correctedWidth);
    const finalHeight = Math.max(256, correctedHeight);
    const valid = width === finalWidth && height === finalHeight;
    return {
      valid,
      correctedWidth: finalWidth,
      correctedHeight: finalHeight,
      message: valid ? void 0 : `Adjusted to ${finalWidth}x${finalHeight} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(project, options, onProgress) {
    const { frameCount } = project.composition;
    const { width, height } = options;
    this.offscreenCanvas = new OffscreenCanvas(width, height);
    this.ctx = this.offscreenCanvas.getContext("2d");
    this.initializeParticleSystems(project);
    const frames = [];
    for (let frame = 0; frame < frameCount; frame++) {
      if (onProgress) {
        onProgress({
          frame,
          total: frameCount,
          percent: Math.round(frame / frameCount * 100)
        });
      }
      this.stepParticleSystemsToFrame(project, frame);
      const frameBlob = await this.generateFrame(project, frame, options);
      frames.push(frameBlob);
    }
    this.particleSystems.clear();
    if (onProgress) {
      onProgress({
        frame: frameCount,
        total: frameCount,
        percent: 100
      });
    }
    return frames;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(project, frame, options) {
    const ctx = this.ctx;
    const { width, height } = options;
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    if (options.matteMode === "include_all") {
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    }
    ctx.fillStyle = "#000000";
    const scaleX = width / project.composition.width;
    const scaleY = height / project.composition.height;
    const textLayers = project.layers.filter((layer) => {
      const start = layer.startFrame ?? layer.inPoint ?? 0;
      const end = layer.endFrame ?? layer.outPoint ?? 80;
      return layer.type === "text" && layer.visible && frame >= start && frame <= end;
    });
    for (const layer of textLayers) {
      await this.renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY);
    }
    const particleLayers = project.layers.filter((layer) => {
      const start = layer.startFrame ?? layer.inPoint ?? 0;
      const end = layer.endFrame ?? layer.outPoint ?? 80;
      return layer.type === "particles" && layer.visible && frame >= start && frame <= end;
    });
    for (const layer of particleLayers) {
      this.renderParticleLayerToMatte(ctx, layer, width, height);
    }
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(project, frame, options) {
    if (!this.offscreenCanvas || this.offscreenCanvas.width !== options.width || this.offscreenCanvas.height !== options.height) {
      this.offscreenCanvas = new OffscreenCanvas(options.width, options.height);
      this.ctx = this.offscreenCanvas.getContext("2d");
    }
    const blob = await this.generateFrame(project, frame, options);
    return URL.createObjectURL(blob);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY) {
    const textData = layer.data;
    if (!textData) return;
    const fontSizeProp = layer.properties.find((p) => p.name === "fontSize");
    const fontSize = fontSizeProp ? interpolateProperty(fontSizeProp, frame) : textData.fontSize;
    const scaledFontSize = fontSize * Math.min(scaleX, scaleY);
    ctx.font = `${textData.fontWeight} ${scaledFontSize}px "${textData.fontFamily}"`;
    if (textData.pathLayerId) {
      await this.renderTextOnPathToMatte(ctx, layer, textData, project, frame, scaledFontSize, scaleX, scaleY);
    } else {
      this.renderTextBlockToMatte(ctx, layer, textData, frame, scaledFontSize, scaleX, scaleY);
    }
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(ctx, layer, textData, project, frame, fontSize, scaleX, scaleY) {
    const pathLayer = project.layers.find((l) => l.id === textData.pathLayerId);
    if (!pathLayer || pathLayer.type !== "spline") return;
    const splineData = pathLayer.data;
    if (!splineData?.controlPoints || splineData.controlPoints.length < 2) return;
    const pathCommands = this.buildPathCommands(splineData);
    if (!pathCommands || pathCommands.length < 2) return;
    const bezierCurve = pathCommandsToBezier(pathCommands);
    if (!bezierCurve) return;
    const parameterizer = new ArcLengthParameterizer(bezierCurve);
    const offsetProp = layer.properties.find((p) => p.name === "pathOffset");
    const pathOffset = offsetProp ? interpolateProperty(offsetProp, frame) : textData.pathOffset;
    const totalLength = parameterizer.totalLength;
    let currentDistance = pathOffset * totalLength;
    const padding = 4 * Math.min(scaleX, scaleY);
    for (const char of textData.text) {
      if (char === " ") {
        const spaceWidth = ctx.measureText(" ").width;
        currentDistance += spaceWidth + textData.letterSpacing;
        continue;
      }
      const charWidth = ctx.measureText(char).width;
      const clampedDistance = Math.max(0, Math.min(currentDistance, totalLength));
      const { point, tangent } = parameterizer.getPointAtDistance(clampedDistance);
      const angle = Math.atan2(tangent.y, tangent.x);
      const scaledX = point.x * scaleX;
      const scaledY = point.y * scaleY;
      ctx.save();
      ctx.translate(scaledX, scaledY);
      ctx.rotate(angle);
      ctx.fillRect(
        -padding,
        -fontSize - padding,
        charWidth + padding * 2,
        fontSize + padding * 2
      );
      ctx.restore();
      currentDistance += charWidth + textData.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(splineData) {
    const cp = splineData.controlPoints;
    if (!cp || cp.length < 2) return null;
    const pathCommands = [];
    pathCommands.push(["M", cp[0].x, cp[0].y]);
    for (let i = 0; i < cp.length - 1; i++) {
      const p1 = cp[i];
      const p2 = cp[i + 1];
      const h1 = p1.handleOut || { x: p1.x, y: p1.y };
      const h2 = p2.handleIn || { x: p2.x, y: p2.y };
      pathCommands.push([
        "C",
        h1.x,
        h1.y,
        h2.x,
        h2.y,
        p2.x,
        p2.y
      ]);
    }
    return pathCommands;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(ctx, layer, textData, frame, fontSize, scaleX, scaleY) {
    const positionProp = layer.transform.position;
    const position = interpolateProperty(positionProp, frame);
    const rotationProp = layer.transform.rotation;
    const rotation = interpolateProperty(rotationProp, frame);
    const scaleProp = layer.transform.scale;
    const scale = interpolateProperty(scaleProp, frame);
    ctx.save();
    ctx.translate(position.x * scaleX, position.y * scaleY);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scale.x, scale.y);
    const metrics = ctx.measureText(textData.text);
    const textWidth = metrics.width;
    const textHeight = fontSize;
    const padding = 4;
    ctx.fillRect(
      -padding,
      -textHeight - padding,
      textWidth + padding * 2,
      textHeight + padding * 2
    );
    ctx.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(frames, filename = "matte_sequence", onProgress) {
    const JSZip = (await import('./weyl-export-vendor.js').then(n => n.j)).default;
    const zip = new JSZip();
    frames.forEach((blob, index) => {
      const frameName = `${filename}_${String(index).padStart(4, "0")}.png`;
      zip.file(frameName, blob);
    });
    const content = await zip.generateAsync(
      { type: "blob" },
      (metadata) => {
        if (onProgress) {
          onProgress(Math.round(metadata.percent));
        }
      }
    );
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${filename}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(project) {
    this.particleSystems.clear();
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles"
    );
    for (const layer of particleLayers) {
      const data = layer.data;
      if (!data) continue;
      const system = new ParticleSystem(data.systemConfig);
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
      const warmupFrames = data.systemConfig.warmupPeriod || 0;
      for (let i = 0; i < warmupFrames; i++) {
        system.step();
      }
      this.particleSystems.set(layer.id, system);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(project, frame) {
    if (frame === 0) return;
    for (const layer of project.layers) {
      if (layer.type !== "particles") continue;
      const system = this.particleSystems.get(layer.id);
      if (!system) continue;
      const start = layer.startFrame ?? layer.inPoint ?? 0;
      const end = layer.endFrame ?? layer.outPoint ?? 80;
      if (layer.visible && frame >= start && frame <= end) {
        system.step();
      }
    }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(ctx, layer, width, height) {
    const system = this.particleSystems.get(layer.id);
    if (!system) return;
    const maskData = system.renderToMask(width, height);
    const tempCanvas = new OffscreenCanvas(width, height);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.putImageData(maskData, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null;
    this.ctx = null;
    this.particleSystems.clear();
  }
}
const matteExporter = new MatteExporter();

const _hoisted_1$b = { class: "export-dialog" };
const _hoisted_2$b = { class: "dialog-header" };
const _hoisted_3$b = { class: "dialog-content" };
const _hoisted_4$b = { class: "form-group" };
const _hoisted_5$b = { class: "resolution-presets" };
const _hoisted_6$b = ["onClick"];
const _hoisted_7$b = { class: "custom-resolution" };
const _hoisted_8$a = { class: "dimension-input" };
const _hoisted_9$a = { class: "dimension-input" };
const _hoisted_10$a = {
  key: 0,
  class: "dimension-warning"
};
const _hoisted_11$9 = { class: "form-group" };
const _hoisted_12$8 = { class: "matte-mode-options" };
const _hoisted_13$8 = { class: "form-group" };
const _hoisted_14$7 = { class: "preview-container" };
const _hoisted_15$6 = ["src"];
const _hoisted_16$6 = {
  key: 1,
  class: "preview-placeholder"
};
const _hoisted_17$6 = {
  key: 0,
  class: "progress-section"
};
const _hoisted_18$6 = { class: "progress-bar" };
const _hoisted_19$6 = { class: "progress-text" };
const _hoisted_20$6 = { class: "dialog-footer" };
const _hoisted_21$6 = { class: "export-info" };
const _hoisted_22$5 = ["disabled"];
const _hoisted_23$5 = ["disabled"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const resolutionPresets = matteExporter.getResolutionPresets();
    const selectedPreset = ref("720p (1280x720)");
    const customWidth = ref(1280);
    const customHeight = ref(720);
    const dimensionWarning = ref();
    const matteMode = ref("exclude_text");
    const previewUrl = ref(null);
    const isExporting = ref(false);
    const exportProgress = ref(0);
    const progressMessage = ref("");
    const exportWidth = computed(() => customWidth.value);
    const exportHeight = computed(() => customHeight.value);
    function selectPreset(preset) {
      selectedPreset.value = preset.label;
      customWidth.value = preset.width;
      customHeight.value = preset.height;
      dimensionWarning.value = void 0;
    }
    function validateCustomDimensions() {
      const validation = matteExporter.validateDimensions(customWidth.value, customHeight.value);
      if (!validation.valid) {
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        dimensionWarning.value = validation.message;
        selectedPreset.value = "";
      } else {
        dimensionWarning.value = void 0;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
      }
    }
    async function generatePreview() {
      if (!store.hasProject) return;
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
        previewUrl.value = null;
      }
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      previewUrl.value = await matteExporter.generatePreviewFrame(
        store.project,
        0,
        options
      );
    }
    async function startExport() {
      if (isExporting.value || !store.hasProject) return;
      isExporting.value = true;
      exportProgress.value = 0;
      progressMessage.value = "Generating frames...";
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      try {
        const frames = await matteExporter.generateMatteSequence(
          store.project,
          options,
          (progress) => {
            exportProgress.value = progress.percent;
            progressMessage.value = `Generating frame ${progress.frame + 1} of ${progress.total}...`;
          }
        );
        progressMessage.value = "Creating ZIP archive...";
        await matteExporter.downloadAsZip(
          frames,
          `matte_${Date.now()}`,
          (percent) => {
            progressMessage.value = `Compressing... ${percent}%`;
          }
        );
        progressMessage.value = "Export complete!";
        emit("exported");
        setTimeout(() => {
          emit("close");
        }, 1e3);
      } catch (err) {
        console.error("[ExportDialog] Export failed:", err);
        progressMessage.value = `Export failed: ${err instanceof Error ? err.message : "Unknown error"}`;
      } finally {
        isExporting.value = false;
      }
    }
    watch(
      [exportWidth, exportHeight, matteMode],
      () => {
        generatePreview();
      },
      { immediate: false }
    );
    onMounted(() => {
      if (store.hasProject) {
        const validation = matteExporter.validateDimensions(store.width, store.height);
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
        if (!validation.valid) {
          dimensionWarning.value = validation.message;
        }
      }
      generatePreview();
    });
    onUnmounted(() => {
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
      }
      matteExporter.dispose();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$b, [
          createBaseVNode("div", _hoisted_2$b, [
            _cache[8] || (_cache[8] = createBaseVNode("h3", null, "Export Matte Sequence", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_3$b, [
            createBaseVNode("div", _hoisted_4$b, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Resolution", -1)),
              createBaseVNode("div", _hoisted_5$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(resolutionPresets), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.label,
                    class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.label }]),
                    onClick: ($event) => selectPreset(preset)
                  }, toDisplayString(preset.label), 11, _hoisted_6$b);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_7$b, [
                createBaseVNode("div", _hoisted_8$a, [
                  _cache[9] || (_cache[9] = createBaseVNode("label", null, "Width", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => customWidth.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customWidth.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                _cache[11] || (_cache[11] = createBaseVNode("span", { class: "dimension-x" }, "", -1)),
                createBaseVNode("div", _hoisted_9$a, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", null, "Height", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customHeight.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customHeight.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ])
              ]),
              dimensionWarning.value ? (openBlock(), createElementBlock("p", _hoisted_10$a, [
                _cache[12] || (_cache[12] = createBaseVNode("i", { class: "pi pi-info-circle" }, null, -1)),
                createTextVNode(" " + toDisplayString(dimensionWarning.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_11$9, [
              _cache[16] || (_cache[16] = createBaseVNode("label", null, "Matte Mode", -1)),
              createBaseVNode("div", _hoisted_12$8, [
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "exclude_text" }]),
                  onClick: _cache[3] || (_cache[3] = ($event) => matteMode.value = "exclude_text")
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("i", { class: "pi pi-ban" }, null, -1),
                  createBaseVNode("span", null, "Exclude Text", -1),
                  createBaseVNode("small", null, "Text regions are BLACK (excluded from generation)", -1)
                ])], 2),
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "include_all" }]),
                  onClick: _cache[4] || (_cache[4] = ($event) => matteMode.value = "include_all")
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("i", { class: "pi pi-check-circle" }, null, -1),
                  createBaseVNode("span", null, "Include All", -1),
                  createBaseVNode("small", null, "Entire frame is WHITE (generate everything)", -1)
                ])], 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$8, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Preview (Frame 0)", -1)),
              createBaseVNode("div", _hoisted_14$7, [
                previewUrl.value ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: previewUrl.value,
                  alt: "Matte preview",
                  class: "preview-image"
                }, null, 8, _hoisted_15$6)) : (openBlock(), createElementBlock("div", _hoisted_16$6, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-image" }, null, -1),
                  createBaseVNode("span", null, "Generating preview...", -1)
                ])]))
              ]),
              _cache[19] || (_cache[19] = createBaseVNode("p", { class: "preview-info" }, [
                createTextVNode(" White = Keep original / generate content"),
                createBaseVNode("br"),
                createTextVNode(" Black = Exclude from generation ")
              ], -1))
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_17$6, [
              createBaseVNode("div", _hoisted_18$6, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: `${exportProgress.value}%` })
                }, null, 4)
              ]),
              createBaseVNode("p", _hoisted_19$6, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_20$6, [
            createBaseVNode("div", _hoisted_21$6, [
              createBaseVNode("span", null, toDisplayString(unref(store).frameCount) + " frames @ " + toDisplayString(exportWidth.value) + "" + toDisplayString(exportHeight.value), 1)
            ]),
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[5] || (_cache[5] = ($event) => emit("close")),
              disabled: isExporting.value
            }, " Cancel ", 8, _hoisted_22$5),
            createBaseVNode("button", {
              class: "export-btn",
              onClick: startExport,
              disabled: isExporting.value || !unref(store).hasProject
            }, [
              _cache[20] || (_cache[20] = createBaseVNode("i", { class: "pi pi-download" }, null, -1)),
              createTextVNode(" " + toDisplayString(isExporting.value ? "Exporting..." : "Export ZIP"), 1)
            ], 8, _hoisted_23$5)
          ])
        ])
      ]);
    };
  }
});

const ExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-5e0349d2"]]);

const EXPORT_PRESETS = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: false,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "motionctrl": {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 3
  },
  "cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025) - All use 16fps with 4n+1 frame pattern
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ati": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ttm": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-wan": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 50,
    cfgScale: 6
  },
  "ttm-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    // 5 seconds at 16fps (4n+1 pattern)
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  }
};
const DEPTH_FORMAT_SPECS = {
  "midas": {
    format: "midas",
    bitDepth: 8,
    invert: true,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "zoe": {
    format: "zoe",
    bitDepth: 16,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: false,
    normalize: false,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  "normalized": {
    format: "normalized",
    bitDepth: 8,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
};
const RESOLUTION_PRESETS = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
];
const FRAME_COUNT_PRESETS = [
  // Legacy model presets (non-Wan)
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  // Wan/AI model presets - 16fps with 4n+1 pattern
  {
    name: "17 frames (1s)",
    frameCount: 17,
    // 116+1 = 17
    duration: "1.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati"]
  },
  {
    name: "33 frames (2s)",
    frameCount: 33,
    // 216+1 = 33
    duration: "2.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati", "ttm"]
  },
  {
    name: "49 frames (3s)",
    frameCount: 49,
    // 316+1 = 49
    duration: "3.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati", "ttm", "cogvideox"]
  },
  {
    name: "65 frames (4s)",
    frameCount: 65,
    // 416+1 = 65
    duration: "4.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati", "ttm"]
  },
  {
    name: "81 frames (5s)  Default",
    frameCount: 81,
    // 516+1 = 81
    duration: "5.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera", "uni3c-motion", "wan-move", "ati", "ttm", "ttm-wan", "light-x", "camera-comfyui"]
  },
  {
    name: "113 frames (7s)",
    frameCount: 113,
    // 716+1 = 113
    duration: "7.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati"]
  },
  {
    name: "161 frames (10s)",
    frameCount: 161,
    // 1016+1 = 161
    duration: "10.0s",
    fps: 16,
    recommended: ["wan22-i2v", "wan-move", "ati"]
  },
  {
    name: "241 frames (15s)",
    frameCount: 241,
    // 1516+1 = 241
    duration: "15.0s",
    fps: 16,
    recommended: ["wan22-i2v"]
  }
];
const WAN_DURATION_PRESETS = [
  { label: "1 second", seconds: 1, frameCount: 17, fps: 16 },
  { label: "2 seconds", seconds: 2, frameCount: 33, fps: 16 },
  { label: "3 seconds", seconds: 3, frameCount: 49, fps: 16 },
  { label: "4 seconds", seconds: 4, frameCount: 65, fps: 16 },
  { label: "5 seconds", seconds: 5, frameCount: 81, fps: 16, isDefault: true },
  { label: "7 seconds", seconds: 7, frameCount: 113, fps: 16 },
  { label: "10 seconds", seconds: 10, frameCount: 161, fps: 16 },
  { label: "15 seconds", seconds: 15, frameCount: 241, fps: 16 }
];
function isValidWanFrameCount(frameCount) {
  return (frameCount - 1) % 4 === 0;
}
const EXPORT_TARGET_INFO = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  "motionctrl": {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  "cogvideox": {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  "ati": {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  "ttm": {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "ttm-wan": {
    name: "TTM (Wan 2.1 Backend)",
    description: "Time-to-Move with Wan 2.1 model for high-quality generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControl", "TTM_TrajectoryFromPoints", "WanImageToVideo"]
  },
  "ttm-cogvideox": {
    name: "TTM (CogVideoX Backend)",
    description: "Time-to-Move with CogVideoX model for longer sequences",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlCogVideo", "TTM_TrajectoryFromPoints", "CogVideoImageToVideo"]
  },
  "ttm-svd": {
    name: "TTM (SVD Backend)",
    description: "Time-to-Move with Stable Video Diffusion for fast generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlSVD", "TTM_TrajectoryFromPoints", "SVDEncode"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};

function renderDepthFrame(options) {
  const { width, height, nearClip, farClip, camera, layers, frame } = options;
  const depthBuffer = new Float32Array(width * height);
  depthBuffer.fill(farClip);
  let minDepth = farClip;
  let maxDepth = nearClip;
  const sortedLayers = [...layers].filter((l) => l.visible).sort((a, b) => {
    const aZ = getLayerDepth(a, frame);
    const bZ = getLayerDepth(b, frame);
    return aZ - bZ;
  });
  for (const layer of sortedLayers) {
    const layerDepth = getLayerDepth(layer, frame);
    const layerOpacity = getLayerOpacity(layer, frame);
    if (layerOpacity < 0.01) continue;
    const bounds = getLayerScreenBounds(layer, frame, camera, width, height);
    if (!bounds) continue;
    const cameraZ = camera.position.z;
    const relativeDepth = Math.abs(layerDepth - cameraZ);
    const clampedDepth = Math.max(nearClip, Math.min(farClip, relativeDepth));
    minDepth = Math.min(minDepth, clampedDepth);
    maxDepth = Math.max(maxDepth, clampedDepth);
    if (layer.type === "depthflow" && hasDepthData(layer)) {
      fillDepthFromDepthflow(depthBuffer, layer, bounds, width, height, nearClip, farClip);
    } else {
      fillUniformDepth(depthBuffer, bounds, clampedDepth, layerOpacity, width, height);
    }
  }
  return {
    depthBuffer,
    width,
    height,
    minDepth,
    maxDepth
  };
}
function getLayerDepth(layer, frame) {
  const position = layer.transform?.position;
  if (!position) return 0;
  if (position.keyframes && position.keyframes.length > 0) {
    return interpolateValue(position.keyframes, frame, 2) || 0;
  }
  if (position.value) {
    const value = position.value;
    if (typeof value === "object" && "z" in value) {
      return value.z ?? 0;
    }
  }
  return 0;
}
function getLayerOpacity(layer, frame) {
  if (layer.opacity && "keyframes" in layer.opacity && layer.opacity.keyframes?.length > 0) {
    return (interpolateValue(layer.opacity.keyframes, frame) || 100) / 100;
  }
  if (layer.opacity && "value" in layer.opacity) {
    return (layer.opacity.value || 100) / 100;
  }
  return 1;
}
function getLayerScreenBounds(layer, frame, camera, screenWidth, screenHeight) {
  let x = 0, y = 0;
  const position = layer.transform?.position;
  if (position && "value" in position) {
    const value = position.value;
    if (Array.isArray(value)) {
      x = value[0] || 0;
      y = value[1] || 0;
    }
  }
  const layerWidth = layer.width || screenWidth;
  const layerHeight = layer.height || screenHeight;
  let scaleX = 1, scaleY = 1;
  const scale = layer.transform?.scale;
  if (scale && "value" in scale) {
    const value = scale.value;
    if (Array.isArray(value)) {
      scaleX = (value[0] || 100) / 100;
      scaleY = (value[1] || 100) / 100;
    }
  }
  const finalWidth = layerWidth * scaleX;
  const finalHeight = layerHeight * scaleY;
  let anchorX = 0.5, anchorY = 0.5;
  const anchorPoint = layer.transform?.anchorPoint;
  if (anchorPoint && "value" in anchorPoint) {
    const value = anchorPoint.value;
    if (Array.isArray(value)) {
      anchorX = (value[0] || 0) / layerWidth + 0.5;
      anchorY = (value[1] || 0) / layerHeight + 0.5;
    }
  }
  const screenX = x - finalWidth * anchorX + screenWidth / 2;
  const screenY = y - finalHeight * anchorY + screenHeight / 2;
  const clippedX = Math.max(0, Math.min(screenWidth, screenX));
  const clippedY = Math.max(0, Math.min(screenHeight, screenY));
  const clippedWidth = Math.max(0, Math.min(screenWidth - clippedX, finalWidth - (clippedX - screenX)));
  const clippedHeight = Math.max(0, Math.min(screenHeight - clippedY, finalHeight - (clippedY - screenY)));
  if (clippedWidth <= 0 || clippedHeight <= 0) return null;
  return {
    x: clippedX,
    y: clippedY,
    width: clippedWidth,
    height: clippedHeight
  };
}
function hasDepthData(layer) {
  return layer.type === "depthflow" && !!layer.depthMapData;
}
function fillDepthFromDepthflow(depthBuffer, layer, bounds, screenWidth, screenHeight, nearClip, farClip) {
  const depthData = layer.depthMapData;
  const depthWidth = layer.depthWidth || bounds.width;
  const depthHeight = layer.depthHeight || bounds.height;
  for (let y = 0; y < bounds.height; y++) {
    for (let x = 0; x < bounds.width; x++) {
      const screenX = Math.floor(bounds.x + x);
      const screenY = Math.floor(bounds.y + y);
      if (screenX < 0 || screenX >= screenWidth || screenY < 0 || screenY >= screenHeight) continue;
      const sampleX = Math.floor(x / bounds.width * depthWidth);
      const sampleY = Math.floor(y / bounds.height * depthHeight);
      const sampleIdx = sampleY * depthWidth + sampleX;
      let depthValue;
      if (depthData instanceof Float32Array) {
        depthValue = depthData[sampleIdx];
      } else {
        depthValue = depthData[sampleIdx] / 255;
      }
      const worldDepth = nearClip + depthValue * (farClip - nearClip);
      const bufferIdx = screenY * screenWidth + screenX;
      if (worldDepth < depthBuffer[bufferIdx]) {
        depthBuffer[bufferIdx] = worldDepth;
      }
    }
  }
}
function fillUniformDepth(depthBuffer, bounds, depth, opacity, screenWidth, screenHeight) {
  const startX = Math.floor(bounds.x);
  const startY = Math.floor(bounds.y);
  const endX = Math.min(screenWidth, Math.ceil(bounds.x + bounds.width));
  const endY = Math.min(screenHeight, Math.ceil(bounds.y + bounds.height));
  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      const idx = y * screenWidth + x;
      if (opacity > 0.5 && depth < depthBuffer[idx]) {
        depthBuffer[idx] = depth;
      }
    }
  }
}
function interpolateValue(keyframes, frame, index) {
  if (!keyframes || keyframes.length === 0) return null;
  let prev = keyframes[0];
  let next = keyframes[keyframes.length - 1];
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i].frame <= frame) {
      prev = keyframes[i];
    }
    if (keyframes[i].frame >= frame && i < keyframes.length) {
      next = keyframes[i];
      break;
    }
  }
  if (prev.frame === next.frame) {
    const value = prev.value;
    return index !== void 0 && Array.isArray(value) ? value[index] : value;
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevValue = index !== void 0 && Array.isArray(prev.value) ? prev.value[index] : prev.value;
  const nextValue = index !== void 0 && Array.isArray(next.value) ? next.value[index] : next.value;
  return prevValue + (nextValue - prevValue) * t;
}
function convertDepthToFormat(result, format) {
  const spec = DEPTH_FORMAT_SPECS[format];
  const { depthBuffer, width, height, minDepth, maxDepth } = result;
  const pixelCount = width * height;
  if (spec.bitDepth === 16) {
    const output = new Uint16Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized;
      if (spec.normalize) {
        normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      } else {
        normalized = depthBuffer[i] / spec.farClip;
      }
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(65535, Math.round(normalized * 65535)));
    }
    return output;
  } else {
    const output = new Uint8Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(255, Math.round(normalized * 255)));
    }
    return output;
  }
}
function depthToImageData(depthData, width, height) {
  const imageData = new ImageData(width, height);
  const is16bit = depthData instanceof Uint16Array;
  for (let i = 0; i < width * height; i++) {
    const value = is16bit ? Math.floor(depthData[i] / 256) : depthData[i];
    const pixelIdx = i * 4;
    imageData.data[pixelIdx] = value;
    imageData.data[pixelIdx + 1] = value;
    imageData.data[pixelIdx + 2] = value;
    imageData.data[pixelIdx + 3] = 255;
  }
  return imageData;
}

let nodeIdCounter = 1;
function resetNodeIds() {
  nodeIdCounter = 1;
}
function nextNodeId() {
  return String(nodeIdCounter++);
}
function createNode(classType, inputs, title) {
  const node = {
    class_type: classType,
    inputs
  };
  if (title) {
    node._meta = { title };
  }
  return node;
}
function conn(nodeId, outputIndex = 0) {
  return [nodeId, outputIndex];
}
function addCheckpointLoader(workflow, checkpoint) {
  const id = nextNodeId();
  workflow[id] = createNode("CheckpointLoaderSimple", {
    ckpt_name: checkpoint
  }, "Load Checkpoint");
  return id;
}
function addCLIPTextEncode(workflow, clipConnection, text, title) {
  const id = nextNodeId();
  workflow[id] = createNode("CLIPTextEncode", {
    clip: clipConnection,
    text
  }, title);
  return id;
}
function addLoadImage(workflow, imageName, title) {
  const id = nextNodeId();
  workflow[id] = createNode("LoadImage", {
    image: imageName
  }, title || "Load Image");
  return id;
}
function addImageResize(workflow, imageConnection, width, height) {
  const id = nextNodeId();
  workflow[id] = createNode("ImageResize", {
    image: imageConnection,
    width,
    height,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image");
  return id;
}
function addVAEEncode(workflow, imageConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEEncode", {
    pixels: imageConnection,
    vae: vaeConnection
  }, "VAE Encode");
  return id;
}
function addVAEDecode(workflow, samplesConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEDecode", {
    samples: samplesConnection,
    vae: vaeConnection
  }, "VAE Decode");
  return id;
}
function addKSampler(workflow, modelConnection, positiveConnection, negativeConnection, latentConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("KSampler", {
    model: modelConnection,
    positive: positiveConnection,
    negative: negativeConnection,
    latent_image: latentConnection,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    steps: params.steps ?? 20,
    cfg: params.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: params.denoise ?? 1
  }, "KSampler");
  return id;
}
function addVideoOutput(workflow, imagesConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("VHS_VideoCombine", {
    images: imagesConnection,
    frame_rate: params.fps,
    loop_count: 0,
    filename_prefix: params.filename || "weyl_output",
    format: params.format || "video/h264-mp4",
    pingpong: false,
    save_output: true,
    audio: null,
    meta_batch: null
  }, "Video Output");
  return id;
}
function generateWan22I2VWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const isHD = params.width > 640 || params.height > 640;
  const wanModel = params.wanModel || (isHD ? "i2v_720p" : "i2v_480p");
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${wanModel}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanImageToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: params.denoise || 1
  }, "I2V Generation");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_i2v"
  });
  return workflow;
}
function generateWan22FunCameraWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("WanFunCameraMotion", {
    motion_type: params.cameraMotion || "Static",
    length: params.frameCount
  }, "Camera Motion");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFunCameraI2V", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    camera_motion: conn(cameraCtrlId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_fun_camera"
  });
  return workflow;
}
function generateWan22FirstLastWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const firstImageId = addLoadImage(workflow, params.referenceImage || "first.png", "First Frame");
  const lastImageId = addLoadImage(workflow, params.lastFrameImage || "last.png", "Last Frame");
  const resizeFirstId = addImageResize(workflow, conn(firstImageId), params.width, params.height);
  const resizeLastId = addImageResize(workflow, conn(lastImageId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFirstLastFrameToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    first_frame: conn(resizeFirstId),
    last_frame: conn(resizeLastId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_flf"
  });
  return workflow;
}
function generateUni3CWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const uni3cLoaderId = nextNodeId();
  workflow[uni3cLoaderId] = createNode("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const trajId = nextNodeId();
  if (params.trajType === "custom" && params.cameraData?.trajectory) {
    workflow[trajId] = createNode("Uni3CCustomTrajectory", {
      trajectory_data: JSON.stringify(params.cameraData.trajectory),
      length: params.frameCount
    }, "Custom Trajectory");
  } else {
    workflow[trajId] = createNode("Uni3CPresetTrajectory", {
      traj_type: params.trajType || "orbit",
      length: params.frameCount
    }, "Preset Trajectory");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyUni3CCameraControl", {
    model: conn(baseModelId),
    uni3c: conn(uni3cLoaderId),
    trajectory: conn(trajId),
    image: conn(resizeId),
    control_strength: 1
  }, "Apply Camera Control");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "uni3c_output"
  });
  return workflow;
}
function generateMotionCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const motionCtrlId = nextNodeId();
  workflow[motionCtrlId] = createNode("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("MotionCtrlCameraPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("MotionCtrlPresetPoses", {
      preset: params.motionPreset || "static",
      length: params.frameCount
    }, "Preset Poses");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyMotionCtrl", {
    model: conn(baseModelId),
    motion_ctrl: conn(motionCtrlId),
    camera_poses: conn(posesId),
    control_strength: 1
  }, "Apply MotionCtrl");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "motionctrl_output"
  });
  return workflow;
}
function generateControlNetDepthWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "sd_xl_base_1.0.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const depthLoaderId = nextNodeId();
  workflow[depthLoaderId] = createNode("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const refImageId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeRefId = addImageResize(workflow, conn(refImageId), params.width, params.height);
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(depthLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const encodeRefId = addVAEEncode(workflow, conn(resizeRefId), conn(checkpointId, 2));
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(encodeRefId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7, denoise: params.denoise || 0.75 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "controlnet_depth"
  });
  return workflow;
}
function generateAnimateDiffCameraCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "dreamshaper_8.safetensors");
  const animateDiffId = nextNodeId();
  workflow[animateDiffId] = createNode("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("ADE_CameraCtrlPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("ADE_CameraCtrlPreset", {
      motion_type: params.cameraMotion || "Static",
      speed: 1,
      frame_length: params.frameCount
    }, "Camera Preset");
  }
  const applyADId = nextNodeId();
  workflow[applyADId] = createNode("ADE_ApplyAnimateDiffModel", {
    model: conn(checkpointId),
    motion_model: conn(animateDiffId)
  }, "Apply AnimateDiff");
  const applyCamId = nextNodeId();
  workflow[applyCamId] = createNode("ADE_ApplyCameraCtrl", {
    model: conn(applyADId),
    cameractrl: conn(cameraCtrlId),
    poses: conn(posesId)
  }, "Apply CameraCtrl");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(applyCamId),
    conn(positiveId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "animatediff_cameractrl"
  });
  return workflow;
}
function generateCogVideoXWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const cogVideoId = nextNodeId();
  workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const t5Id = nextNodeId();
  workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const vaeId = nextNodeId();
  workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const encodePromptId = nextNodeId();
  workflow[encodePromptId] = createNode("CogVideoTextEncode", {
    text_encoder: conn(t5Id),
    prompt: params.prompt,
    force_offload: true
  }, "Encode Prompt");
  const generateId = nextNodeId();
  workflow[generateId] = createNode("CogVideoImageToVideo", {
    model: conn(cogVideoId),
    positive: conn(encodePromptId),
    image: conn(resizeId),
    vae: conn(vaeId),
    width: params.width,
    height: params.height,
    num_frames: params.frameCount,
    steps: params.steps || 50,
    cfg: params.cfgScale || 6,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("CogVideoDecode", {
    vae: conn(vaeId),
    samples: conn(generateId),
    enable_vae_tiling: true
  }, "Decode Video");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "cogvideox_output"
  });
  return workflow;
}
function generateTTMWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const ttmModel = params.ttmModel || "wan";
  const layers = params.ttmLayers || [];
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const combinedMaskId = nextNodeId();
  workflow[combinedMaskId] = createNode("LoadImage", {
    image: params.ttmCombinedMask || "combined_motion_mask.png"
  }, "Combined Motion Mask");
  const layerMaskIds = [];
  const trajectoryIds = [];
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];
    const maskId = nextNodeId();
    workflow[maskId] = createNode("LoadImage", {
      image: layer.motionMask
    }, `Layer ${i + 1} Mask: ${layer.layerName}`);
    layerMaskIds.push(maskId);
    const trajId = nextNodeId();
    workflow[trajId] = createNode("TTM_TrajectoryFromPoints", {
      points: JSON.stringify(layer.trajectory.map((t) => [t.x, t.y])),
      frames: JSON.stringify(layer.trajectory.map((t) => t.frame)),
      total_frames: params.frameCount,
      interpolation: "linear"
    }, `Trajectory: ${layer.layerName}`);
    trajectoryIds.push(trajId);
  }
  let combinedLayerDataId = null;
  if (layers.length > 0) {
    combinedLayerDataId = nextNodeId();
    workflow[combinedLayerDataId] = createNode("TTM_CombineLayers", {
      masks: layerMaskIds.map((id) => conn(id)),
      trajectories: trajectoryIds.map((id) => conn(id)),
      blend_mode: "additive"
    }, "Combine Layer Data");
  }
  if (ttmModel === "wan") {
    const wanLoaderId = nextNodeId();
    workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
      model: "wan2.1_i2v_480p_bf16.safetensors",
      base_precision: "bf16",
      quantization: "disabled"
    }, "Load Wan Model");
    const vaeLoaderId = nextNodeId();
    workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
      vae: "wan_2.1_vae.safetensors",
      precision: "bf16"
    }, "Load Wan VAE");
    const clipLoaderId = nextNodeId();
    workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
      text_encoder: "umt5-xxl-enc-bf16.safetensors",
      precision: "bf16"
    }, "Load Text Encoder");
    const positiveId = nextNodeId();
    workflow[positiveId] = createNode("WanTextEncode", {
      text_encoder: conn(clipLoaderId),
      prompt: params.prompt,
      force_offload: true
    }, "Positive Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControl", {
      wan_model: conn(wanLoaderId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const latentId = nextNodeId();
    workflow[latentId] = createNode("WanImageToVideo", {
      wan_model: conn(ttmControlId),
      positive: conn(positiveId),
      image: conn(resizeId),
      vae: conn(vaeLoaderId),
      width: params.width,
      height: params.height,
      length: params.frameCount,
      steps: params.steps || 30,
      cfg: params.cfgScale || 5,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "DPM++ 2M SDE",
      denoise_strength: params.denoise || 1
    }, "TTM I2V Generation");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("WanVAEDecode", {
      vae: conn(vaeLoaderId),
      samples: conn(latentId),
      enable_vae_tiling: true,
      tile_sample_min_height: 240,
      tile_sample_min_width: 240,
      tile_overlap_factor_height: 0.2,
      tile_overlap_factor_width: 0.2
    }, "VAE Decode");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_output"
    });
  } else if (ttmModel === "cogvideox") {
    const cogVideoId = nextNodeId();
    workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
      model: "CogVideoX-5b-I2V",
      precision: "bf16"
    }, "Load CogVideoX");
    const t5Id = nextNodeId();
    workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
      model: "t5-v1_1-xxl-encoder-bf16",
      precision: "bf16"
    }, "Load T5 Encoder");
    const vaeId = nextNodeId();
    workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
      model: "cogvideox_vae",
      precision: "bf16"
    }, "Load CogVideo VAE");
    const encodePromptId = nextNodeId();
    workflow[encodePromptId] = createNode("CogVideoTextEncode", {
      text_encoder: conn(t5Id),
      prompt: params.prompt,
      force_offload: true
    }, "Encode Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlCogVideo", {
      model: conn(cogVideoId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const generateId = nextNodeId();
    workflow[generateId] = createNode("CogVideoImageToVideo", {
      model: conn(ttmControlId),
      positive: conn(encodePromptId),
      image: conn(resizeId),
      vae: conn(vaeId),
      width: params.width,
      height: params.height,
      num_frames: params.frameCount,
      steps: params.steps || 50,
      cfg: params.cfgScale || 6,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "CogVideoX DDIM"
    }, "CogVideoX I2V");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("CogVideoDecode", {
      vae: conn(vaeId),
      samples: conn(generateId),
      enable_vae_tiling: true
    }, "Decode Video");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_cogvideo_output"
    });
  } else {
    const baseModelId = nextNodeId();
    workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
      ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
    }, "Load SVD");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlSVD", {
      model: conn(baseModelId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const encodeId = nextNodeId();
    workflow[encodeId] = createNode("SVDEncode", {
      model: conn(ttmControlId),
      image: conn(resizeId),
      vae: conn(baseModelId, 2),
      width: params.width,
      height: params.height,
      video_frames: params.frameCount,
      motion_bucket_id: 127,
      fps: params.fps,
      augmentation_level: 0
    }, "SVD Encode");
    const sampleId = addKSampler(
      workflow,
      conn(ttmControlId),
      conn(encodeId, 1),
      conn(encodeId, 2),
      conn(encodeId),
      { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
    );
    const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_svd_output"
    });
  }
  return workflow;
}
function generateControlNetWorkflow(params, controlType) {
  resetNodeIds();
  const workflow = {};
  const controlnetModels = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  };
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "v1-5-pruned-emaonly.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || controlnetModels[controlType]
  }, `Load ControlNet ${controlType}`);
  const controlLoaderId = nextNodeId();
  workflow[controlLoaderId] = createNode("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(controlLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || `controlnet_${controlType}`
  });
  return workflow;
}
function generateWorkflowForTarget(target, params) {
  switch (target) {
    case "wan22-i2v":
      return generateWan22I2VWorkflow(params);
    case "wan22-t2v":
      return generateWan22I2VWorkflow({ ...params, referenceImage: void 0 });
    case "wan22-fun-camera":
      return generateWan22FunCameraWorkflow(params);
    case "wan22-first-last":
      return generateWan22FirstLastWorkflow(params);
    case "uni3c-camera":
    case "uni3c-motion":
      return generateUni3CWorkflow(params);
    case "motionctrl":
    case "motionctrl-svd":
      return generateMotionCtrlWorkflow(params);
    case "cogvideox":
      return generateCogVideoXWorkflow(params);
    case "controlnet-depth":
      return generateControlNetDepthWorkflow(params);
    case "controlnet-canny":
      return generateControlNetWorkflow(params, "canny");
    case "controlnet-lineart":
      return generateControlNetWorkflow(params, "lineart");
    case "animatediff-cameractrl":
      return generateAnimateDiffCameraCtrlWorkflow(params);
    case "ttm":
    case "ttm-wan":
    case "ttm-cogvideox":
    case "ttm-svd":
      return generateTTMWorkflow(params);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${target}`);
  }
}
function validateWorkflow(workflow) {
  const errors = [];
  const warnings = [];
  const nodeIds = Object.keys(workflow);
  for (const [nodeId, node] of Object.entries(workflow)) {
    if (!node.class_type) {
      errors.push(`Node ${nodeId}: missing class_type`);
    }
    for (const [inputName, inputValue] of Object.entries(node.inputs)) {
      if (Array.isArray(inputValue) && inputValue.length === 2) {
        const [refNodeId] = inputValue;
        if (typeof refNodeId === "string" && !nodeIds.includes(refNodeId)) {
          errors.push(`Node ${nodeId}.${inputName}: references non-existent node ${refNodeId}`);
        }
      }
    }
  }
  const hasOutput = Object.values(workflow).some(
    (node) => node.class_type.includes("Save") || node.class_type.includes("Output") || node.class_type.includes("Preview")
  );
  if (!hasOutput) {
    warnings.push("Workflow has no output/save nodes");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

class ExportPipeline {
  layers;
  cameraKeyframes;
  config;
  onProgress;
  abortSignal;
  aborted = false;
  constructor(options) {
    this.layers = options.layers;
    this.cameraKeyframes = options.cameraKeyframes;
    this.config = options.config;
    this.onProgress = options.onProgress || (() => {
    });
    this.abortSignal = options.abortSignal;
    if (this.abortSignal) {
      this.abortSignal.addEventListener("abort", () => {
        this.aborted = true;
      });
    }
  }
  checkAborted() {
    if (this.aborted) {
      throw new Error("Export aborted");
    }
  }
  updateProgress(progress) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...progress
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const startTime = Date.now();
    const result = {
      success: false,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const configErrors = this.validateConfig();
      if (configErrors.length > 0) {
        result.errors = configErrors;
        return result;
      }
      if (this.config.exportReferenceFrame) {
        this.checkAborted();
        await this.renderReferenceFrame(result);
      }
      if (this.config.exportLastFrame) {
        this.checkAborted();
        await this.renderLastFrame(result);
      }
      if (this.config.exportDepthMap) {
        this.checkAborted();
        await this.renderDepthSequence(result);
      }
      if (this.config.exportControlImages) {
        this.checkAborted();
        await this.renderControlSequence(result);
      }
      if (this.config.exportCameraData) {
        this.checkAborted();
        await this.exportCameraData(result);
      }
      this.checkAborted();
      await this.generateWorkflow(result);
      if (this.config.autoQueueWorkflow && this.config.comfyuiServer) {
        this.checkAborted();
        await this.queueWorkflow(result);
      }
      result.success = result.errors.length === 0;
    } catch (error) {
      if (error instanceof Error && error.message === "Export aborted") {
        result.errors.push("Export was cancelled");
      } else {
        result.errors.push(error instanceof Error ? error.message : "Unknown error");
      }
    }
    result.duration = Date.now() - startTime;
    return result;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const errors = [];
    if (this.config.width < 64 || this.config.width > 4096) {
      errors.push("Width must be between 64 and 4096");
    }
    if (this.config.height < 64 || this.config.height > 4096) {
      errors.push("Height must be between 64 and 4096");
    }
    if (this.config.frameCount < 1 || this.config.frameCount > 1e3) {
      errors.push("Frame count must be between 1 and 1000");
    }
    if (this.config.fps < 1 || this.config.fps > 120) {
      errors.push("FPS must be between 1 and 120");
    }
    if (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) {
      errors.push("Invalid start frame");
    }
    if (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) {
      errors.push("Invalid end frame");
    }
    if (!this.config.prompt && this.needsPrompt()) {
      errors.push("Prompt is required for this export target");
    }
    return errors;
  }
  needsPrompt() {
    const noPromptTargets = ["controlnet-depth", "controlnet-canny", "controlnet-lineart"];
    return !noPromptTargets.includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.startFrame);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.referenceImage = uploadResult.name;
    } else {
      result.outputFiles.referenceImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.endFrame - 1);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.lastImage = uploadResult.name;
    } else {
      result.outputFiles.lastImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(ctx, frameIndex) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    const sortedLayers = [...this.layers].filter((layer) => layer.visible).sort((a, b) => {
      const az = a.transform?.position?.value?.z ?? 0;
      const bz = b.transform?.position?.value?.z ?? 0;
      return az - bz;
    });
    for (const layer of sortedLayers) {
      await this.renderLayerToCanvas(ctx, layer, frameIndex);
    }
  }
  async renderLayerToCanvas(ctx, layer, _frameIndex) {
    const pos = layer.transform?.position?.value ?? { x: 0, y: 0 };
    const scaleVal = layer.transform?.scale?.value ?? { x: 100, y: 100 };
    const rotation = layer.transform?.rotation?.value ?? 0;
    const opacity = typeof layer.opacity?.value === "number" ? layer.opacity.value : 100;
    ctx.save();
    ctx.globalAlpha = opacity / 100;
    ctx.translate(pos.x, pos.y);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scaleVal.x / 100, scaleVal.y / 100);
    const layerData = layer.data;
    if (layer.type === "image" && layerData?.src) {
      const img = await this.loadImage(layerData.src);
      ctx.drawImage(img, -img.width / 2, -img.height / 2);
    } else if (layer.type === "solid" && layerData?.color) {
      ctx.fillStyle = layerData.color || "#000000";
      const width = layerData.width ?? 100;
      const height = layerData.height ?? 100;
      ctx.fillRect(-width / 2, -height / 2, width, height);
    }
    ctx.restore();
  }
  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const depthFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: progress,
        overallProgress: 15 + progress * 0.25,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering depth frame ${i + 1}/${frameCount}`
      });
      const defaultCamera = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: false,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      };
      const depthResult = renderDepthFrame({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: defaultCamera,
        layers: this.layers,
        frame: frameIndex
      });
      const convertedDepth = convertDepthToFormat(
        depthResult,
        this.config.depthFormat
      );
      const imageData = depthToImageData(
        convertedDepth,
        this.config.width,
        this.config.height
      );
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      const blob = await canvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_depth_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "depth_sequence");
        depthFiles.push(uploadResult.name);
      } else {
        depthFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.depthSequence = depthFiles;
    this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const controlFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: progress,
        overallProgress: 40 + progress * 0.2,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering control frame ${i + 1}/${frameCount}`
      });
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      await this.renderFrameToCanvas(ctx, frameIndex);
      const controlCanvas = await this.applyControlPreprocessing(canvas, this.config.controlType || "depth");
      const blob = await controlCanvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_control_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "control_sequence");
        controlFiles.push(uploadResult.name);
      } else {
        controlFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.controlSequence = controlFiles;
    this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(input, controlType) {
    const output = new OffscreenCanvas(input.width, input.height);
    const ctx = output.getContext("2d");
    const inputCtx = input.getContext("2d");
    const imageData = inputCtx.getImageData(0, 0, input.width, input.height);
    const data = imageData.data;
    switch (controlType) {
      case "canny":
        this.applyEdgeDetection(data, input.width, input.height);
        break;
      case "lineart":
        this.applyLineart(data);
        break;
      case "softedge":
        this.applySoftEdge(data, input.width, input.height);
        break;
    }
    ctx.putImageData(imageData, 0, 0);
    return output;
  }
  applyEdgeDetection(data, width, height) {
    const grayscale = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      grayscale[i] = (data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114) / 255;
    }
    const edges = new Float32Array(width * height);
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = y * width + x;
        const gx = -grayscale[idx - width - 1] + grayscale[idx - width + 1] + -2 * grayscale[idx - 1] + 2 * grayscale[idx + 1] + -grayscale[idx + width - 1] + grayscale[idx + width + 1];
        const gy = -grayscale[idx - width - 1] - 2 * grayscale[idx - width] - grayscale[idx - width + 1] + grayscale[idx + width - 1] + 2 * grayscale[idx + width] + grayscale[idx + width + 1];
        edges[idx] = Math.min(1, Math.sqrt(gx * gx + gy * gy) * 2);
      }
    }
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      const val = Math.floor(edges[i] * 255);
      data[idx] = val;
      data[idx + 1] = val;
      data[idx + 2] = val;
    }
  }
  applyLineart(data) {
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      const val = gray > 128 ? 255 : 0;
      data[i] = val;
      data[i + 1] = val;
      data[i + 2] = val;
    }
  }
  applySoftEdge(data, width, height) {
    this.applyEdgeDetection(data, width, height);
    const temp = new Uint8ClampedArray(data);
    const kernel = 2;
    for (let y = kernel; y < height - kernel; y++) {
      for (let x = kernel; x < width - kernel; x++) {
        let sum = 0;
        let count = 0;
        for (let ky = -kernel; ky <= kernel; ky++) {
          for (let kx = -kernel; kx <= kernel; kx++) {
            const idx2 = ((y + ky) * width + (x + kx)) * 4;
            sum += temp[idx2];
            count++;
          }
        }
        const idx = (y * width + x) * 4;
        const val = Math.floor(sum / count);
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
    }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(result) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const exportCamera = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: false,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: false
      }};
    const cameraData = exportCameraForTarget(
      this.config.target,
      exportCamera,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    );
    const filename = `${this.config.filenamePrefix}_camera.json`;
    const blob = new Blob([JSON.stringify(cameraData, null, 2)], { type: "application/json" });
    if (this.config.comfyuiServer) {
      result.outputFiles.cameraData = filename;
    } else {
      result.outputFiles.cameraData = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(result) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const params = {
      referenceImage: result.outputFiles.referenceImage,
      lastFrameImage: result.outputFiles.lastImage,
      depthSequence: result.outputFiles.depthSequence,
      controlImages: result.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    if (result.outputFiles.cameraData) {
      params.cameraData = result.outputFiles.cameraData;
    }
    const workflow = generateWorkflowForTarget(this.config.target, params);
    const validation = validateWorkflow(workflow);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
    }
    result.warnings.push(...validation.warnings);
    const filename = `${this.config.filenamePrefix}_workflow.json`;
    const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: "application/json" });
    result.outputFiles.workflowJson = await this.saveBlobLocally(blob, filename);
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(result) {
    if (!this.config.comfyuiServer || !result.outputFiles.workflowJson) {
      return;
    }
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const client = getComfyUIClient(this.config.comfyuiServer);
    const connected = await client.checkConnection();
    if (!connected) {
      result.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const response = await fetch(result.outputFiles.workflowJson);
    const workflow = await response.json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const promptResult = await client.queuePrompt(workflow);
    result.outputFiles.promptId = promptResult.prompt_id;
    if (promptResult.node_errors && Object.keys(promptResult.node_errors).length > 0) {
      result.errors.push("Workflow has node errors: " + JSON.stringify(promptResult.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await client.waitForPrompt(promptResult.prompt_id, (progress) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: progress.percentage,
          overallProgress: 80 + progress.percentage * 0.15,
          message: `Generating: ${progress.percentage.toFixed(0)}%`,
          preview: progress.preview
        });
      });
      this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return url;
  }
}
async function exportToComfyUI(layers, cameraKeyframes, config, onProgress) {
  const pipeline = new ExportPipeline({
    layers,
    cameraKeyframes,
    config,
    onProgress
  });
  return pipeline.execute();
}

const _hoisted_1$a = { class: "export-dialog" };
const _hoisted_2$a = { class: "dialog-tabs" };
const _hoisted_3$a = { class: "dialog-content" };
const _hoisted_4$a = {
  key: 0,
  class: "tab-content"
};
const _hoisted_5$a = { class: "target-grid" };
const _hoisted_6$a = { class: "target-buttons" };
const _hoisted_7$a = ["onClick"];
const _hoisted_8$9 = {
  key: 0,
  class: "target-info"
};
const _hoisted_9$9 = { class: "info-row" };
const _hoisted_10$9 = { class: "info-row" };
const _hoisted_11$8 = { class: "info-row" };
const _hoisted_12$7 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_13$7 = { class: "settings-section" };
const _hoisted_14$6 = { class: "preset-buttons" };
const _hoisted_15$5 = ["onClick"];
const _hoisted_16$5 = { class: "input-row" };
const _hoisted_17$5 = { class: "settings-section" };
const _hoisted_18$5 = { class: "preset-buttons" };
const _hoisted_19$5 = ["onClick"];
const _hoisted_20$5 = { class: "input-row" };
const _hoisted_21$5 = { class: "input-row" };
const _hoisted_22$4 = { class: "settings-section" };
const _hoisted_23$4 = { class: "checkbox-grid" };
const _hoisted_24$3 = {
  key: 0,
  class: "settings-section"
};
const _hoisted_25$3 = ["value"];
const _hoisted_26$3 = {
  key: 1,
  class: "settings-section"
};
const _hoisted_27$3 = ["value"];
const _hoisted_28$3 = {
  key: 2,
  class: "tab-content"
};
const _hoisted_29$3 = { class: "settings-section" };
const _hoisted_30$2 = { class: "settings-section" };
const _hoisted_31$2 = { class: "settings-section" };
const _hoisted_32$2 = { class: "input-row" };
const _hoisted_33$2 = { class: "input-row seed-row" };
const _hoisted_34$2 = {
  key: 3,
  class: "tab-content"
};
const _hoisted_35$2 = { class: "settings-section" };
const _hoisted_36$1 = { class: "server-row" };
const _hoisted_37$1 = { key: 0 };
const _hoisted_38$1 = { key: 1 };
const _hoisted_39$1 = { key: 2 };
const _hoisted_40$1 = { key: 3 };
const _hoisted_41$1 = { class: "settings-section" };
const _hoisted_42$1 = { class: "checkbox-large" };
const _hoisted_43$1 = {
  key: 0,
  class: "export-progress"
};
const _hoisted_44$1 = { class: "progress-header" };
const _hoisted_45$1 = { class: "progress-bar" };
const _hoisted_46$1 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_47$1 = {
  key: 1,
  class: "export-error"
};
const _hoisted_48$1 = { class: "dialog-footer" };
const _hoisted_49$1 = ["disabled"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const activeTab = ref("target");
    const selectedTarget = ref("wan22-i2v");
    const width = ref(832);
    const height = ref(480);
    const frameCount = ref(81);
    const fps = ref(24);
    const startFrame = ref(0);
    const endFrame = ref(81);
    const exportDepthMap = ref(true);
    const exportControlImages = ref(false);
    const exportCameraData = ref(true);
    const exportReferenceFrame = ref(true);
    const exportLastFrame = ref(false);
    const depthFormat = ref("midas");
    const controlType = ref("depth");
    const prompt = ref("");
    const negativePrompt = ref("blurry, low quality, distorted");
    const seed = ref(void 0);
    const steps = ref(30);
    const cfgScale = ref(5);
    const comfyuiServer = ref("127.0.0.1:8188");
    const autoQueueWorkflow = ref(false);
    const connectionStatus = ref("disconnected");
    const isExporting = ref(false);
    const exportProgress = ref(null);
    const exportError = ref(null);
    const abortController = ref(null);
    const targetInfo = computed(() => EXPORT_TARGET_INFO[selectedTarget.value]);
    const targetCategories = computed(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      "Uni3C": ["uni3c-camera", "uni3c-motion"],
      "MotionCtrl": ["motionctrl", "motionctrl-svd"],
      "Camera": ["animatediff-cameractrl", "camera-comfyui", "ati"],
      "Advanced": ["light-x", "ttm", "cogvideox"],
      "ControlNet": ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      "Custom": ["custom-workflow"]
    }));
    const targetDisplayName = computed(() => {
      const names = {
        "wan22-i2v": "Image to Video",
        "wan22-t2v": "Text to Video",
        "wan22-fun-camera": "Fun Camera",
        "wan22-first-last": "First + Last Frame",
        "wan-move": "Point Trajectories",
        "uni3c-camera": "Camera Control",
        "uni3c-motion": "Motion + Camera",
        "motionctrl": "MotionCtrl",
        "motionctrl-svd": "MotionCtrl SVD",
        "cogvideox": "CogVideoX I2V",
        "animatediff-cameractrl": "CameraCtrl",
        "camera-comfyui": "4x4 Matrices",
        "ati": "Any Trajectory",
        "light-x": "Relighting",
        "ttm": "Cut & Drag",
        "controlnet-depth": "Depth",
        "controlnet-canny": "Canny Edge",
        "controlnet-lineart": "Line Art",
        "custom-workflow": "Custom Workflow"
      };
      return names;
    });
    const depthFormats = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ];
    const controlTypes = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function selectTarget(target) {
      selectedTarget.value = target;
      const preset = EXPORT_PRESETS[target];
      if (preset) {
        width.value = preset.width ?? 832;
        height.value = preset.height ?? 480;
        frameCount.value = preset.frameCount ?? 81;
        fps.value = preset.fps ?? 24;
        endFrame.value = frameCount.value;
      }
      const info = EXPORT_TARGET_INFO[target];
      if (info) {
        exportDepthMap.value = info.requiredInputs.includes("depth_sequence") || info.requiredInputs.includes("depth_map");
        exportCameraData.value = info.requiredInputs.includes("camera_data") || info.requiredInputs.includes("camera_trajectory") || info.requiredInputs.includes("camera_poses");
        exportReferenceFrame.value = info.requiredInputs.includes("reference_image") || info.requiredInputs.includes("first_frame");
        exportLastFrame.value = info.requiredInputs.includes("last_frame");
        exportControlImages.value = target.startsWith("controlnet-");
      }
    }
    async function checkConnection() {
      connectionStatus.value = "connecting";
      try {
        const client = getComfyUIClient(comfyuiServer.value);
        const connected = await client.checkConnection();
        connectionStatus.value = connected ? "connected" : "error";
      } catch {
        connectionStatus.value = "error";
      }
    }
    function applyResolutionPreset(preset) {
      width.value = preset.width;
      height.value = preset.height;
    }
    function applyFrameCountPreset(count) {
      frameCount.value = count;
      endFrame.value = Math.min(endFrame.value, count);
    }
    function randomizeSeed() {
      seed.value = Math.floor(Math.random() * 2147483647);
    }
    async function startExport() {
      isExporting.value = true;
      exportError.value = null;
      abortController.value = new AbortController();
      const config = {
        target: selectedTarget.value,
        width: width.value,
        height: height.value,
        frameCount: frameCount.value,
        fps: fps.value,
        startFrame: startFrame.value,
        endFrame: endFrame.value,
        outputDir: "",
        filenamePrefix: `weyl_${selectedTarget.value}_${Date.now()}`,
        exportDepthMap: exportDepthMap.value,
        exportControlImages: exportControlImages.value,
        exportCameraData: exportCameraData.value,
        exportReferenceFrame: exportReferenceFrame.value,
        exportLastFrame: exportLastFrame.value,
        depthFormat: depthFormat.value,
        controlType: controlType.value,
        prompt: prompt.value,
        negativePrompt: negativePrompt.value,
        seed: seed.value,
        steps: steps.value,
        cfgScale: cfgScale.value,
        comfyuiServer: comfyuiServer.value,
        autoQueueWorkflow: autoQueueWorkflow.value
      };
      try {
        const result = await exportToComfyUI(
          props.layers,
          props.cameraKeyframes,
          config,
          (progress) => {
            exportProgress.value = progress;
          }
        );
        if (result.success) {
          emit("exported", result);
        } else {
          exportError.value = result.errors.join("\n");
        }
      } catch (error) {
        exportError.value = error instanceof Error ? error.message : "Export failed";
      } finally {
        isExporting.value = false;
        abortController.value = null;
      }
    }
    function cancelExport() {
      if (abortController.value) {
        abortController.value.abort();
      }
    }
    function close() {
      if (isExporting.value) {
        cancelExport();
      }
      emit("close");
    }
    onMounted(() => {
      endFrame.value = Math.min(frameCount.value, props.totalFrames);
      checkConnection();
    });
    watch(selectedTarget, () => {
      selectTarget(selectedTarget.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: withModifiers(close, ["self"])
      }, [
        createBaseVNode("div", _hoisted_1$a, [
          createBaseVNode("header", { class: "dialog-header" }, [
            _cache[24] || (_cache[24] = createBaseVNode("h2", null, "Export to ComfyUI", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: close
            }, "")
          ]),
          createBaseVNode("nav", _hoisted_2$a, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "target" }),
              onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "target")
            }, " Target ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "output" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "output")
            }, " Output ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "generation" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "generation")
            }, " Generation ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "comfyui" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          createBaseVNode("div", _hoisted_3$a, [
            activeTab.value === "target" ? (openBlock(), createElementBlock("div", _hoisted_4$a, [
              createBaseVNode("div", _hoisted_5$a, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(targetCategories.value, (targets, category) => {
                  return openBlock(), createElementBlock("div", {
                    key: category,
                    class: "target-category"
                  }, [
                    createBaseVNode("h3", null, toDisplayString(category), 1),
                    createBaseVNode("div", _hoisted_6$a, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                        return openBlock(), createElementBlock("button", {
                          key: target,
                          class: normalizeClass({ selected: selectedTarget.value === target }),
                          onClick: ($event) => selectTarget(target)
                        }, toDisplayString(targetDisplayName.value[target]), 11, _hoisted_7$a);
                      }), 128))
                    ])
                  ]);
                }), 128))
              ]),
              targetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_8$9, [
                createBaseVNode("h4", null, toDisplayString(targetDisplayName.value[selectedTarget.value]), 1),
                createBaseVNode("div", _hoisted_9$9, [
                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "label" }, "Required:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_10$9, [
                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "label" }, "Optional:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_11$8, [
                  _cache[27] || (_cache[27] = createBaseVNode("span", { class: "label" }, "Outputs:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.outputTypes.join(", ")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "output" ? (openBlock(), createElementBlock("div", _hoisted_12$7, [
              createBaseVNode("div", _hoisted_13$7, [
                _cache[28] || (_cache[28] = createBaseVNode("h3", null, "Resolution", -1)),
                createBaseVNode("div", _hoisted_14$6, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(RESOLUTION_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyResolutionPreset(preset)
                    }, toDisplayString(preset.name), 9, _hoisted_15$5);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_16$5, [
                  createVNode(ScrubableNumber, {
                    modelValue: width.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => width.value = $event),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: height.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => height.value = $event),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$5, [
                _cache[29] || (_cache[29] = createBaseVNode("h3", null, "Frames", -1)),
                createBaseVNode("div", _hoisted_18$5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(FRAME_COUNT_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyFrameCountPreset(preset.frameCount)
                    }, toDisplayString(preset.name), 9, _hoisted_19$5);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_20$5, [
                  createVNode(ScrubableNumber, {
                    modelValue: frameCount.value,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => frameCount.value = $event),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: fps.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => fps.value = $event),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$5, [
                  createVNode(ScrubableNumber, {
                    modelValue: startFrame.value,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => startFrame.value = $event),
                    label: "Start",
                    min: 0,
                    max: endFrame.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  createVNode(ScrubableNumber, {
                    modelValue: endFrame.value,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => endFrame.value = $event),
                    label: "End",
                    min: startFrame.value + 1,
                    max: frameCount.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              createBaseVNode("div", _hoisted_22$4, [
                _cache[35] || (_cache[35] = createBaseVNode("h3", null, "Export Options", -1)),
                createBaseVNode("div", _hoisted_23$4, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => exportReferenceFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportReferenceFrame.value]
                    ]),
                    _cache[30] || (_cache[30] = createTextVNode(" Reference Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => exportLastFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportLastFrame.value]
                    ]),
                    _cache[31] || (_cache[31] = createTextVNode(" Last Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => exportDepthMap.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportDepthMap.value]
                    ]),
                    _cache[32] || (_cache[32] = createTextVNode(" Depth Maps ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => exportControlImages.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportControlImages.value]
                    ]),
                    _cache[33] || (_cache[33] = createTextVNode(" Control Images ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => exportCameraData.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportCameraData.value]
                    ]),
                    _cache[34] || (_cache[34] = createTextVNode(" Camera Data ", -1))
                  ])
                ])
              ]),
              exportDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_24$3, [
                _cache[36] || (_cache[36] = createBaseVNode("h3", null, "Depth Format", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => depthFormat.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(depthFormats, (fmt) => {
                    return createBaseVNode("option", {
                      key: fmt.value,
                      value: fmt.value
                    }, toDisplayString(fmt.label), 9, _hoisted_25$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, depthFormat.value]
                ])
              ])) : createCommentVNode("", true),
              exportControlImages.value ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                _cache[37] || (_cache[37] = createBaseVNode("h3", null, "Control Type", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => controlType.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(controlTypes, (ct) => {
                    return createBaseVNode("option", {
                      key: ct.value,
                      value: ct.value
                    }, toDisplayString(ct.label), 9, _hoisted_27$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, controlType.value]
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "generation" ? (openBlock(), createElementBlock("div", _hoisted_28$3, [
              createBaseVNode("div", _hoisted_29$3, [
                _cache[38] || (_cache[38] = createBaseVNode("h3", null, "Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => prompt.value = $event),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_30$2, [
                _cache[39] || (_cache[39] = createBaseVNode("h3", null, "Negative Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => negativePrompt.value = $event),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [vModelText, negativePrompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_31$2, [
                _cache[40] || (_cache[40] = createBaseVNode("h3", null, "Parameters", -1)),
                createBaseVNode("div", _hoisted_32$2, [
                  createVNode(ScrubableNumber, {
                    modelValue: steps.value,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => steps.value = $event),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: cfgScale.value,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => cfgScale.value = $event),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_33$2, [
                  createVNode(ScrubableNumber, {
                    modelValue: seed.value ?? 0,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => seed.value = v),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("button", {
                    class: "randomize-btn",
                    onClick: randomizeSeed
                  }, "Random")
                ])
              ])
            ])) : createCommentVNode("", true),
            activeTab.value === "comfyui" ? (openBlock(), createElementBlock("div", _hoisted_34$2, [
              createBaseVNode("div", _hoisted_35$2, [
                _cache[41] || (_cache[41] = createBaseVNode("h3", null, "Server", -1)),
                createBaseVNode("div", _hoisted_36$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => comfyuiServer.value = $event),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [vModelText, comfyuiServer.value]
                  ]),
                  createBaseVNode("button", { onClick: checkConnection }, toDisplayString(connectionStatus.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["connection-status", connectionStatus.value])
                }, [
                  connectionStatus.value === "connected" ? (openBlock(), createElementBlock("span", _hoisted_37$1, "Connected")) : connectionStatus.value === "error" ? (openBlock(), createElementBlock("span", _hoisted_38$1, "Connection failed")) : connectionStatus.value === "connecting" ? (openBlock(), createElementBlock("span", _hoisted_39$1, "Connecting...")) : (openBlock(), createElementBlock("span", _hoisted_40$1, "Not connected"))
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_41$1, [
                _cache[43] || (_cache[43] = createBaseVNode("h3", null, "Workflow", -1)),
                createBaseVNode("label", _hoisted_42$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => autoQueueWorkflow.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, autoQueueWorkflow.value]
                  ]),
                  _cache[42] || (_cache[42] = createBaseVNode("span", null, [
                    createBaseVNode("strong", null, "Auto-queue workflow"),
                    createBaseVNode("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : createCommentVNode("", true)
          ]),
          isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_43$1, [
            createBaseVNode("div", _hoisted_44$1, [
              createBaseVNode("span", null, toDisplayString(exportProgress.value?.message || "Exporting..."), 1),
              createBaseVNode("button", { onClick: cancelExport }, "Cancel")
            ]),
            createBaseVNode("div", _hoisted_45$1, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value?.overallProgress || 0}%` })
              }, null, 4)
            ]),
            exportProgress.value?.currentFrame ? (openBlock(), createElementBlock("div", _hoisted_46$1, " Frame " + toDisplayString(exportProgress.value.currentFrame) + " / " + toDisplayString(exportProgress.value.totalFrames), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          exportError.value ? (openBlock(), createElementBlock("div", _hoisted_47$1, toDisplayString(exportError.value), 1)) : createCommentVNode("", true),
          createBaseVNode("footer", _hoisted_48$1, [
            createBaseVNode("button", {
              class: "secondary",
              onClick: close
            }, "Cancel"),
            createBaseVNode("button", {
              class: "primary",
              disabled: isExporting.value,
              onClick: startExport
            }, toDisplayString(isExporting.value ? "Exporting..." : "Export"), 9, _hoisted_49$1)
          ])
        ])
      ]);
    };
  }
});

const ComfyUIExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-a8c65cb8"]]);

const _hoisted_1$9 = { class: "dialog-container" };
const _hoisted_2$9 = { class: "dialog-content" };
const _hoisted_3$9 = { class: "form-row" };
const _hoisted_4$9 = { class: "tabs" };
const _hoisted_5$9 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_6$9 = { class: "form-row" };
const _hoisted_7$9 = { class: "form-row dimensions-row" };
const _hoisted_8$8 = { class: "dimension-group" };
const _hoisted_9$8 = { class: "dimension-group" };
const _hoisted_10$8 = { class: "form-row" };
const _hoisted_11$7 = { class: "aspect-info" };
const _hoisted_12$6 = { class: "form-row" };
const _hoisted_13$6 = { class: "form-row" };
const _hoisted_14$5 = { class: "resolution-info" };
const _hoisted_15$4 = { class: "form-row" };
const _hoisted_16$4 = { label: "Wan/AI Models (16fps, 4n+1)" };
const _hoisted_17$4 = ["value"];
const _hoisted_18$4 = { class: "form-row" };
const _hoisted_19$4 = { class: "duration-inputs" };
const _hoisted_20$4 = { class: "duration-helper" };
const _hoisted_21$4 = {
  key: 0,
  class: "form-row warning-row"
};
const _hoisted_22$3 = { class: "warning-text" };
const _hoisted_23$3 = { class: "form-row" };
const _hoisted_24$2 = { class: "color-picker-row" };
const _hoisted_25$2 = { class: "color-label" };
const _hoisted_26$2 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_27$2 = { class: "form-row" };
const _hoisted_28$2 = { class: "form-row" };
const _hoisted_29$2 = { class: "form-row" };
const _hoisted_30$1 = { class: "motion-blur-settings" };
const _hoisted_31$1 = {
  key: 0,
  class: "motion-blur-params"
};
const _hoisted_32$1 = { class: "param-row" };
const _hoisted_33$1 = { class: "param-row" };
const _hoisted_34$1 = { class: "dialog-footer" };
const _hoisted_35$1 = { class: "preview-toggle" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const activeTab = ref("basic");
    const selectedPreset = ref("custom");
    const selectedDurationPreset = ref("custom");
    const lockAspectRatio = ref(false);
    const aspectRatio = ref(16 / 9);
    const previewChanges = ref(false);
    const settings = ref({
      name: "Main Comp",
      width: 832,
      height: 480,
      pixelAspectRatio: 1,
      fps: 16,
      frameCount: 81,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: true,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: false,
      shutterAngle: 180,
      shutterPhase: -90
    });
    const frameAspectRatio = computed(() => {
      const ratio = settings.value.width / settings.value.height * settings.value.pixelAspectRatio;
      if (Math.abs(ratio - 16 / 9) < 0.01) return "16:9 (1.78)";
      if (Math.abs(ratio - 4 / 3) < 0.01) return "4:3 (1.33)";
      if (Math.abs(ratio - 1) < 0.01) return "1:1 (1.0)";
      if (Math.abs(ratio - 9 / 16) < 0.01) return "9:16 (0.56)";
      if (Math.abs(ratio - 21 / 9) < 0.01) return "21:9 (2.33)";
      return `${ratio.toFixed(2)}`;
    });
    const durationSeconds = computed(() => {
      return settings.value.frameCount / settings.value.fps;
    });
    const durationTimecode = ref("00:00:10:00");
    const isValidFrameCount = computed(() => {
      return isValidWanFrameCount(settings.value.frameCount);
    });
    const nearestValidFrameCount = computed(() => {
      const n = Math.round((settings.value.frameCount - 1) / 4);
      return n * 4 + 1;
    });
    const resolutionInfo = computed(() => {
      const divisors = { full: 1, half: 2, third: 3, quarter: 4 };
      const d = divisors[settings.value.resolution];
      const w = Math.floor(settings.value.width / d);
      const h = Math.floor(settings.value.height / d);
      const mb = (w * h * 4 / (1024 * 1024)).toFixed(1);
      return `${w} x ${h}, ${mb} MB per 8bpc frame`;
    });
    const presets = {
      "1080p30": { width: 1920, height: 1080, fps: 30, frameCount: 300 },
      "1080p60": { width: 1920, height: 1080, fps: 60, frameCount: 600 },
      "720p30": { width: 1280, height: 720, fps: 30, frameCount: 300 },
      "4k30": { width: 3840, height: 2160, fps: 30, frameCount: 300 },
      "instagram_square": { width: 1080, height: 1080, fps: 30, frameCount: 300 },
      "instagram_story": { width: 1080, height: 1920, fps: 30, frameCount: 300 },
      "tiktok": { width: 1080, height: 1920, fps: 30, frameCount: 300 },
      "youtube_short": { width: 1080, height: 1920, fps: 60, frameCount: 600 },
      "sd15_512": { width: 512, height: 512, fps: 8, frameCount: 16 },
      "sd15_768": { width: 768, height: 512, fps: 8, frameCount: 16 },
      "sdxl_1024": { width: 1024, height: 1024, fps: 8, frameCount: 16 },
      "wan_480p": { width: 832, height: 480, fps: 16, frameCount: 81 },
      "wan_720p": { width: 1280, height: 720, fps: 16, frameCount: 81 },
      "wan22_480p": { width: 832, height: 480, fps: 16, frameCount: 81 },
      "wan22_720p": { width: 1280, height: 720, fps: 16, frameCount: 81 },
      "hunyuan_720p": { width: 1280, height: 720, fps: 24, frameCount: 96 },
      "hunyuan_540p": { width: 960, height: 540, fps: 24, frameCount: 96 }
    };
    function applyPreset() {
      const preset = presets[selectedPreset.value];
      if (preset) {
        if (preset.width) settings.value.width = preset.width;
        if (preset.height) settings.value.height = preset.height;
        if (preset.fps) settings.value.fps = preset.fps;
        if (preset.frameCount) settings.value.frameCount = preset.frameCount;
        aspectRatio.value = settings.value.width / settings.value.height;
        updateDurationTimecode();
        updateDurationPresetSelection();
      }
    }
    function applyDurationPreset() {
      if (selectedDurationPreset.value === "custom") return;
      const frameCount = Number(selectedDurationPreset.value);
      const preset = WAN_DURATION_PRESETS.find((p) => p.frameCount === frameCount);
      if (preset) {
        settings.value.frameCount = preset.frameCount;
        settings.value.fps = 16;
        updateDurationTimecode();
      }
    }
    function updateDurationPresetSelection() {
      const matchingPreset = WAN_DURATION_PRESETS.find((p) => p.frameCount === settings.value.frameCount);
      if (matchingPreset && settings.value.fps === 16) {
        selectedDurationPreset.value = matchingPreset.frameCount;
      } else {
        selectedDurationPreset.value = "custom";
      }
    }
    function onDimensionChange(changed) {
      settings.value.width = Math.round(settings.value.width / 8) * 8;
      settings.value.height = Math.round(settings.value.height / 8) * 8;
      if (lockAspectRatio.value) {
        if (changed === "width") {
          settings.value.height = Math.round(settings.value.width / aspectRatio.value / 8) * 8;
        } else {
          settings.value.width = Math.round(settings.value.height * aspectRatio.value / 8) * 8;
        }
      } else {
        aspectRatio.value = settings.value.width / settings.value.height;
      }
      selectedPreset.value = "custom";
    }
    function parseDuration() {
      const parts = durationTimecode.value.split(":").map((p) => parseInt(p) || 0);
      if (parts.length === 4) {
        const [hours, minutes, seconds, frames] = parts;
        const totalSeconds = hours * 3600 + minutes * 60 + seconds;
        settings.value.frameCount = Math.round(totalSeconds * settings.value.fps) + frames;
      } else if (parts.length === 1) {
        settings.value.frameCount = parts[0];
      }
    }
    function updateDurationTimecode() {
      const totalFrames = settings.value.frameCount;
      const fps = settings.value.fps;
      const totalSeconds = Math.floor(totalFrames / fps);
      const frames = totalFrames % Math.round(fps);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor(totalSeconds % 3600 / 60);
      const seconds = totalSeconds % 60;
      durationTimecode.value = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}:${pad(frames)}`;
    }
    function pad(n) {
      return n.toString().padStart(2, "0");
    }
    function loadCurrentSettings() {
      const activeComp = store.activeComposition;
      settings.value = {
        name: activeComp?.name || "Main Comp",
        width: store.width,
        height: store.height,
        pixelAspectRatio: 1,
        fps: store.fps,
        frameCount: store.frameCount,
        resolution: "full",
        backgroundColor: activeComp?.backgroundColor || "#000000",
        autoResizeToContent: activeComp?.autoResizeToContent ?? true,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: false,
        shutterAngle: 180,
        shutterPhase: -90
      };
      aspectRatio.value = settings.value.width / settings.value.height;
      updateDurationTimecode();
      updateDurationPresetSelection();
    }
    function cancel() {
      emit("close");
    }
    function confirm() {
      emit("confirm", { ...settings.value });
      emit("close");
    }
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && !e.shiftKey) {
        confirm();
      }
    }
    watch(() => props.visible, (visible) => {
      if (visible) {
        loadCurrentSettings();
      }
    });
    watch(settings, () => {
      if (previewChanges.value && props.visible) {
        store.resizeComposition(settings.value.width, settings.value.height, settings.value.frameCount);
      }
    }, { deep: true });
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$9, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "dialog-title" }, "Composition Settings", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$9, [
              createBaseVNode("div", _hoisted_3$9, [
                _cache[21] || (_cache[21] = createBaseVNode("label", null, "Composition Name:", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => settings.value.name = $event),
                  class: "text-input full-width"
                }, null, 512), [
                  [vModelText, settings.value.name]
                ])
              ]),
              createBaseVNode("div", _hoisted_4$9, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "basic" }),
                  onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "basic")
                }, "Basic", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "advanced" }),
                  onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "advanced")
                }, "Advanced", 2)
              ]),
              activeTab.value === "basic" ? (openBlock(), createElementBlock("div", _hoisted_5$9, [
                createBaseVNode("div", _hoisted_6$9, [
                  _cache[23] || (_cache[23] = createBaseVNode("label", null, "Preset:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedPreset.value = $event),
                    onChange: applyPreset,
                    class: "select-input"
                  }, [..._cache[22] || (_cache[22] = [
                    createBaseVNode("option", { value: "custom" }, "Custom", -1),
                    createBaseVNode("optgroup", { label: "Video" }, [
                      createBaseVNode("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                      createBaseVNode("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                      createBaseVNode("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                      createBaseVNode("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Social Media" }, [
                      createBaseVNode("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                      createBaseVNode("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                      createBaseVNode("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                      createBaseVNode("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "AI Video (ComfyUI)" }, [
                      createBaseVNode("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                      createBaseVNode("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                      createBaseVNode("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                      createBaseVNode("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                      createBaseVNode("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)"),
                      createBaseVNode("option", { value: "wan22_480p" }, "Wan 2.2 480p (832x480)"),
                      createBaseVNode("option", { value: "wan22_720p" }, "Wan 2.2 720p (1280x720)"),
                      createBaseVNode("option", { value: "hunyuan_720p" }, "Hunyuan 720p (1280x720)"),
                      createBaseVNode("option", { value: "hunyuan_540p" }, "Hunyuan 540p (960x540)")
                    ], -1)
                  ])], 544), [
                    [vModelSelect, selectedPreset.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_7$9, [
                  createBaseVNode("div", _hoisted_8$8, [
                    _cache[24] || (_cache[24] = createBaseVNode("label", null, "Width:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => settings.value.width = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[5] || (_cache[5] = ($event) => onDimensionChange("width"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.width,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[25] || (_cache[25] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["lock-btn", { locked: lockAspectRatio.value }]),
                    onClick: _cache[6] || (_cache[6] = ($event) => lockAspectRatio.value = !lockAspectRatio.value),
                    title: "Lock Aspect Ratio"
                  }, toDisplayString(lockAspectRatio.value ? "" : ""), 3),
                  createBaseVNode("div", _hoisted_9$8, [
                    _cache[26] || (_cache[26] = createBaseVNode("label", null, "Height:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => settings.value.height = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[8] || (_cache[8] = ($event) => onDimensionChange("height"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.height,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[27] || (_cache[27] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_10$8, [
                  _cache[28] || (_cache[28] = createBaseVNode("label", null, "Pixel Aspect Ratio:", -1)),
                  _cache[29] || (_cache[29] = createBaseVNode("span", { class: "fixed-value" }, "Square Pixels (1:1)", -1)),
                  createBaseVNode("span", _hoisted_11$7, "Frame Aspect Ratio: " + toDisplayString(frameAspectRatio.value), 1)
                ]),
                createBaseVNode("div", _hoisted_12$6, [
                  _cache[31] || (_cache[31] = createBaseVNode("label", null, "Frame Rate:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => settings.value.fps = $event),
                    class: "select-input short"
                  }, [..._cache[30] || (_cache[30] = [
                    createBaseVNode("option", { value: 8 }, "8", -1),
                    createBaseVNode("option", { value: 12 }, "12", -1),
                    createBaseVNode("option", { value: 15 }, "15", -1),
                    createBaseVNode("option", { value: 16 }, "16", -1),
                    createBaseVNode("option", { value: 23.976 }, "23.976", -1),
                    createBaseVNode("option", { value: 24 }, "24", -1),
                    createBaseVNode("option", { value: 25 }, "25", -1),
                    createBaseVNode("option", { value: 29.97 }, "29.97", -1),
                    createBaseVNode("option", { value: 30 }, "30", -1),
                    createBaseVNode("option", { value: 50 }, "50", -1),
                    createBaseVNode("option", { value: 59.94 }, "59.94", -1),
                    createBaseVNode("option", { value: 60 }, "60", -1)
                  ])], 512), [
                    [
                      vModelSelect,
                      settings.value.fps,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("span", { class: "unit" }, "frames per second", -1))
                ]),
                createBaseVNode("div", _hoisted_13$6, [
                  _cache[34] || (_cache[34] = createBaseVNode("label", null, "Resolution:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => settings.value.resolution = $event),
                    class: "select-input short"
                  }, [..._cache[33] || (_cache[33] = [
                    createBaseVNode("option", { value: "full" }, "Full", -1),
                    createBaseVNode("option", { value: "half" }, "Half", -1),
                    createBaseVNode("option", { value: "third" }, "Third", -1),
                    createBaseVNode("option", { value: "quarter" }, "Quarter", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.resolution]
                  ]),
                  createBaseVNode("span", _hoisted_14$5, toDisplayString(resolutionInfo.value), 1)
                ]),
                createBaseVNode("div", _hoisted_15$4, [
                  _cache[36] || (_cache[36] = createBaseVNode("label", null, "Duration Preset:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => selectedDurationPreset.value = $event),
                    onChange: applyDurationPreset,
                    class: "select-input"
                  }, [
                    _cache[35] || (_cache[35] = createBaseVNode("option", { value: "custom" }, "Custom", -1)),
                    createBaseVNode("optgroup", _hoisted_16$4, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WAN_DURATION_PRESETS), (preset) => {
                        return openBlock(), createElementBlock("option", {
                          key: preset.frameCount,
                          value: preset.frameCount
                        }, toDisplayString(preset.label) + " (" + toDisplayString(preset.frameCount) + " frames)" + toDisplayString(preset.isDefault ? " " : ""), 9, _hoisted_17$4);
                      }), 128))
                    ])
                  ], 544), [
                    [vModelSelect, selectedDurationPreset.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$4, [
                  _cache[37] || (_cache[37] = createBaseVNode("label", null, "Duration:", -1)),
                  createBaseVNode("div", _hoisted_19$4, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => durationTimecode.value = $event),
                      class: "timecode-input",
                      placeholder: "00:00:00:00",
                      onBlur: parseDuration
                    }, null, 544), [
                      [vModelText, durationTimecode.value]
                    ]),
                    createBaseVNode("span", _hoisted_20$4, toDisplayString(settings.value.frameCount) + " frames = " + toDisplayString(durationSeconds.value.toFixed(2)) + "s ", 1)
                  ])
                ]),
                settings.value.fps === 16 && !isValidFrameCount.value ? (openBlock(), createElementBlock("div", _hoisted_21$4, [
                  _cache[38] || (_cache[38] = createBaseVNode("span", { class: "warning-icon" }, "", -1)),
                  createBaseVNode("span", _hoisted_22$3, " Frame count " + toDisplayString(settings.value.frameCount) + " doesn't follow 4n+1 pattern. Nearest valid: " + toDisplayString(nearestValidFrameCount.value) + " frames. ", 1)
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_23$3, [
                  _cache[39] || (_cache[39] = createBaseVNode("label", null, "Background Color:", -1)),
                  createBaseVNode("div", _hoisted_24$2, [
                    withDirectives(createBaseVNode("input", {
                      type: "color",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => settings.value.backgroundColor = $event),
                      class: "color-input"
                    }, null, 512), [
                      [vModelText, settings.value.backgroundColor]
                    ]),
                    createBaseVNode("span", _hoisted_25$2, toDisplayString(settings.value.backgroundColor), 1)
                  ])
                ])
              ])) : createCommentVNode("", true),
              activeTab.value === "advanced" ? (openBlock(), createElementBlock("div", _hoisted_26$2, [
                createBaseVNode("div", _hoisted_27$2, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => settings.value.autoResizeToContent = $event)
                    }, null, 512), [
                      [vModelCheckbox, settings.value.autoResizeToContent]
                    ]),
                    _cache[40] || (_cache[40] = createTextVNode(" Auto-resize composition when importing video ", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_28$2, [
                  _cache[41] || (_cache[41] = createBaseVNode("label", null, "Start Timecode:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => settings.value.startTimecode = $event),
                    class: "timecode-input",
                    placeholder: "00:00:00:00"
                  }, null, 512), [
                    [vModelText, settings.value.startTimecode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_29$2, [
                  _cache[47] || (_cache[47] = createBaseVNode("label", null, "Motion Blur:", -1)),
                  createBaseVNode("div", _hoisted_30$1, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => settings.value.motionBlurEnabled = $event)
                      }, null, 512), [
                        [vModelCheckbox, settings.value.motionBlurEnabled]
                      ]),
                      _cache[42] || (_cache[42] = createTextVNode(" Enable Motion Blur ", -1))
                    ]),
                    settings.value.motionBlurEnabled ? (openBlock(), createElementBlock("div", _hoisted_31$1, [
                      createBaseVNode("div", _hoisted_32$1, [
                        _cache[43] || (_cache[43] = createBaseVNode("label", null, "Shutter Angle:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => settings.value.shutterAngle = $event),
                          min: "0",
                          max: "720",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterAngle,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[44] || (_cache[44] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ]),
                      createBaseVNode("div", _hoisted_33$1, [
                        _cache[45] || (_cache[45] = createBaseVNode("label", null, "Shutter Phase:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => settings.value.shutterPhase = $event),
                          min: "-360",
                          max: "360",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterPhase,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[46] || (_cache[46] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_34$1, [
              createBaseVNode("div", _hoisted_35$1, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => previewChanges.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, previewChanges.value]
                  ]),
                  _cache[48] || (_cache[48] = createTextVNode(" Preview ", -1))
                ])
              ]),
              createBaseVNode("div", { class: "dialog-actions" }, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: confirm
                }, "OK")
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const CompositionSettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-69d05373"]]);

const _hoisted_1$8 = { class: "dialog-box" };
const _hoisted_2$8 = { class: "dialog-header" };
const _hoisted_3$8 = { class: "dialog-body" };
const _hoisted_4$8 = { class: "form-row" };
const _hoisted_5$8 = { class: "info-text" };
const _hoisted_6$8 = { class: "dialog-footer" };
const _hoisted_7$8 = ["disabled"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "PrecomposeDialog",
  props: {
    visible: { type: Boolean },
    layerCount: {},
    defaultName: {}
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const compName = ref(props.defaultName || "Pre-comp 1");
    const nameInput = ref(null);
    watch(() => props.visible, (visible) => {
      if (visible) {
        compName.value = props.defaultName || "Pre-comp 1";
        nextTick(() => {
          nameInput.value?.focus();
          nameInput.value?.select();
        });
      }
    });
    function confirm() {
      if (compName.value.trim()) {
        emit("confirm", compName.value.trim());
        emit("close");
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.$emit("close"), ["self"]))
        }, [
          createBaseVNode("div", _hoisted_1$8, [
            createBaseVNode("div", _hoisted_2$8, [
              _cache[5] || (_cache[5] = createBaseVNode("h3", null, "Pre-compose", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, "")
            ]),
            createBaseVNode("div", _hoisted_3$8, [
              createBaseVNode("div", _hoisted_4$8, [
                _cache[6] || (_cache[6] = createBaseVNode("label", { for: "precomp-name" }, "New composition name", -1)),
                withDirectives(createBaseVNode("input", {
                  id: "precomp-name",
                  ref_key: "nameInput",
                  ref: nameInput,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => compName.value = $event),
                  type: "text",
                  placeholder: "Enter name...",
                  onKeydown: [
                    withKeys(confirm, ["enter"]),
                    _cache[2] || (_cache[2] = withKeys(($event) => _ctx.$emit("close"), ["escape"]))
                  ]
                }, null, 544), [
                  [vModelText, compName.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_5$8, toDisplayString(__props.layerCount) + " layer" + toDisplayString(__props.layerCount !== 1 ? "s" : "") + " will be moved to the new composition. ", 1)
            ]),
            createBaseVNode("div", _hoisted_6$8, [
              createBaseVNode("button", {
                class: "btn-cancel",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
              }, "Cancel"),
              createBaseVNode("button", {
                class: "btn-confirm",
                onClick: confirm,
                disabled: !compName.value.trim()
              }, "OK", 8, _hoisted_7$8)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const PrecomposeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-882e37a9"]]);

const logger$1 = createLogger("MotionIntentResolver");
const SYSTEM_PROMPT = `You are a motion graphics expert analyzing images for camera movements and animation paths.

Given an image, suggest motion paths and camera trajectories that would create compelling visual effects.

ALWAYS respond in valid JSON format with this structure:
{
  "description": "Brief description of suggested motion",
  "confidence": 0.0-1.0,
  "cameraIntents": [...],
  "splineIntents": [...],
  "particleIntents": [...],
  "layerIntents": [...]
}

For spline/path suggestions, provide control points as:
{
  "suggestedPoints": [
    { "id": "p1", "x": 100, "y": 200, "depth": 0.5, "handleIn": null, "handleOut": null, "type": "smooth" }
  ]
}

Consider:
- Depth information if available (closer = lower depth values)
- Subject positions and focal points
- Natural motion paths that follow scene geometry
- Parallax opportunities based on depth layers
`;
const PATH_SUGGESTION_PROMPT = `Analyze this image and suggest camera/motion paths.

Consider:
1. Main subjects and their positions
2. Depth layers (foreground, midground, background)
3. Natural movement paths that would be visually interesting
4. Points of interest to orbit around or move between

Suggest 2-3 different trajectory options with varying complexity.`;
class MotionIntentResolver {
  config;
  lastResult = null;
  constructor(config) {
    this.config = {
      modelId: config?.modelId ?? "rule-based",
      apiEndpoint: config?.apiEndpoint,
      apiKey: config?.apiKey,
      maxTokens: config?.maxTokens ?? 2048,
      temperature: config?.temperature ?? 0.7
    };
  }
  /**
   * Resolve a user prompt into structured motion intents
   */
  async resolve(prompt, context, modelOverride) {
    const modelId = modelOverride ?? this.config.modelId;
    logger$1.info(`Resolving motion intent with ${modelId}:`, prompt);
    try {
      let result;
      switch (modelId) {
        case "rule-based":
          result = await this.resolveWithRules(prompt, context);
          break;
        case "gpt-4v":
        case "gpt-4o":
          result = await this.resolveWithOpenAI(prompt, context, modelId);
          break;
        case "claude-vision":
          result = await this.resolveWithClaude(prompt, context);
          break;
        case "qwen-vl":
        case "qwen2-vl":
        case "llava":
        case "local-vlm":
          result = await this.resolveWithLocalVLM(prompt, context, modelId);
          break;
        default:
          result = await this.resolveWithRules(prompt, context);
      }
      this.lastResult = result;
      return result;
    } catch (error) {
      logger$1.error("Motion intent resolution failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  /**
   * Suggest paths based on image analysis
   * This is the main entry point for "suggest trajectories across image"
   */
  async suggestPaths(context, modelOverride) {
    return this.resolve(PATH_SUGGESTION_PROMPT, context, modelOverride);
  }
  // ============================================================================
  // RULE-BASED FALLBACK
  // ============================================================================
  async resolveWithRules(prompt, context) {
    const lowerPrompt = prompt.toLowerCase();
    const intents = {
      description: "Rule-based motion suggestion",
      confidence: 0.6,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: []
    };
    const cameraIntents = [];
    if (lowerPrompt.includes("dolly") || lowerPrompt.includes("push in") || lowerPrompt.includes("pull out")) {
      cameraIntents.push({
        type: "dolly",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "z",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("pan") || lowerPrompt.includes("sweep")) {
      cameraIntents.push({
        type: "pan",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "y",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("orbit") || lowerPrompt.includes("around")) {
      cameraIntents.push({
        type: "orbit",
        intensity: this.extractIntensity(lowerPrompt),
        durationFrames: context.frameCount,
        orbitCenter: { x: context.width / 2, y: context.height / 2, z: 0 },
        suggestedEasing: "linear"
      });
    }
    if (lowerPrompt.includes("drift") || lowerPrompt.includes("float") || lowerPrompt.includes("subtle")) {
      cameraIntents.push({
        type: "drift",
        intensity: "very_subtle",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("handheld") || lowerPrompt.includes("shake")) {
      cameraIntents.push({
        type: "handheld",
        intensity: this.extractIntensity(lowerPrompt),
        noiseAmount: lowerPrompt.includes("light") ? 0.3 : 0.6,
        durationFrames: context.frameCount
      });
    }
    const splineIntents = [];
    if (context.depthMap || lowerPrompt.includes("path") || lowerPrompt.includes("trajectory")) {
      const defaultPath = this.generateDefaultPath(context);
      splineIntents.push({
        usage: "camera_path",
        smoothness: 0.8,
        complexity: defaultPath.length,
        worldSpace: true,
        suggestedPoints: defaultPath,
        closed: false
      });
      if (context.depthMap) {
        const depthPath = this.generateDepthBasedPath(context);
        splineIntents.push({
          usage: "camera_path",
          smoothness: 0.9,
          complexity: depthPath.length,
          worldSpace: true,
          suggestedPoints: depthPath,
          closed: false
        });
      }
    }
    const particleIntents = [];
    if (lowerPrompt.includes("particle") || lowerPrompt.includes("dust") || lowerPrompt.includes("snow")) {
      particleIntents.push({
        behavior: lowerPrompt.includes("snow") ? "snow" : lowerPrompt.includes("dust") ? "dust" : "drift",
        intensity: 0.5,
        spread: 45,
        lifetime: 120
      });
    }
    return {
      ...intents,
      cameraIntents,
      splineIntents,
      particleIntents
    };
  }
  extractIntensity(prompt) {
    if (prompt.includes("very subtle") || prompt.includes("barely")) return "very_subtle";
    if (prompt.includes("subtle") || prompt.includes("gentle") || prompt.includes("soft")) return "subtle";
    if (prompt.includes("dramatic") || prompt.includes("intense") || prompt.includes("strong")) return "dramatic";
    if (prompt.includes("bold") || prompt.includes("dynamic")) return "strong";
    return "medium";
  }
  generateDefaultPath(context) {
    const { width, height } = context;
    const padding = Math.min(width, height) * 0.1;
    return [
      this.createControlPoint("p1", padding, height / 2, 0),
      this.createControlPoint("p2", width * 0.33, height * 0.3, 0.3),
      this.createControlPoint("p3", width * 0.66, height * 0.7, 0.6),
      this.createControlPoint("p4", width - padding, height / 2, 1)
    ];
  }
  generateDepthBasedPath(context) {
    const { width, height, depthMap } = context;
    if (!depthMap) {
      return this.generateDefaultPath(context);
    }
    const points = [];
    const numPoints = 5;
    for (let i = 0; i < numPoints; i++) {
      const t = i / (numPoints - 1);
      const x = width * (0.2 + t * 0.6);
      const y = height * (0.3 + Math.sin(t * Math.PI) * 0.4);
      const pixelIndex = Math.floor(y) * width + Math.floor(x);
      const depth = depthMap[pixelIndex] ?? 0.5;
      points.push(this.createControlPoint(`dp${i}`, x, y, depth));
    }
    return points;
  }
  createControlPoint(id, x, y, depth) {
    return {
      id,
      x,
      y,
      depth,
      handleIn: null,
      handleOut: null,
      type: "smooth"
    };
  }
  // ============================================================================
  // OPENAI GPT-4V / GPT-4o
  // ============================================================================
  async resolveWithOpenAI(prompt, context, model) {
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: imageBase64 ? [
          { type: "text", text: prompt },
          { type: "image_url", image_url: { url: `data:image/png;base64,${imageBase64}` } }
        ] : prompt
      }
    ];
    try {
      const response = await fetch("/weyl/api/vision/openai", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: model === "gpt-4o" ? "gpt-4o" : "gpt-4-vision-preview",
          messages,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature
        })
      });
      const result = await response.json();
      if (result.status !== "success") {
        throw new Error(result.message || `OpenAI API error: ${response.status}`);
      }
      const content = result.data.choices[0]?.message?.content;
      return this.parseAIResponse(content, prompt);
    } catch (error) {
      logger$1.error("OpenAI API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // CLAUDE VISION
  // ============================================================================
  async resolveWithClaude(prompt, context) {
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const content = imageBase64 ? [
      { type: "image", source: { type: "base64", media_type: "image/png", data: imageBase64 } },
      { type: "text", text: prompt }
    ] : [{ type: "text", text: prompt }];
    try {
      const response = await fetch("/weyl/api/vision/anthropic", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: this.config.maxTokens,
          messages: [
            { role: "user", content: SYSTEM_PROMPT + "\n\nUser request: " + (typeof content === "string" ? content : JSON.stringify(content)) }
          ]
        })
      });
      const result = await response.json();
      if (result.status !== "success") {
        throw new Error(result.message || `Anthropic API error: ${response.status}`);
      }
      const responseContent = result.data.content[0]?.text;
      return this.parseAIResponse(responseContent, prompt);
    } catch (error) {
      logger$1.error("Anthropic API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // LOCAL VLM (via ComfyUI or local endpoint)
  // ============================================================================
  async resolveWithLocalVLM(prompt, context, model) {
    const endpoint = this.config.apiEndpoint ?? "/weyl/vlm";
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model,
          prompt: `${SYSTEM_PROMPT}

User request: ${prompt}`,
          image: imageBase64,
          max_tokens: this.config.maxTokens
        })
      });
      if (!response.ok) {
        throw new Error(`Local VLM API error: ${response.status}`);
      }
      const data = await response.json();
      return this.parseAIResponse(data.response ?? data.text ?? data.content, prompt);
    } catch (error) {
      logger$1.error("Local VLM API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // RESPONSE PARSING
  // ============================================================================
  parseAIResponse(content, originalPrompt) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          description: parsed.description ?? "AI-generated motion suggestion",
          confidence: parsed.confidence ?? 0.8,
          cameraIntents: parsed.cameraIntents ?? [],
          splineIntents: parsed.splineIntents ?? [],
          particleIntents: parsed.particleIntents ?? [],
          layerIntents: parsed.layerIntents ?? [],
          rawResponse: content
        };
      }
    } catch (error) {
      logger$1.warn("Failed to parse AI response as JSON:", error);
    }
    return {
      description: content.slice(0, 200),
      confidence: 0.5,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: [],
      rawResponse: content
    };
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  imageDataToBase64(imageData) {
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL("image/png").split(",")[1];
  }
  /**
   * Get last resolution result
   */
  getLastResult() {
    return this.lastResult;
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
const motionIntentResolver = new MotionIntentResolver();

const logger = createLogger("MotionIntentTranslator");
const INTENSITY_TO_DISTANCE = {
  very_subtle: 10,
  subtle: 30,
  medium: 80,
  strong: 200,
  dramatic: 500
};
const INTENSITY_TO_ROTATION = {
  very_subtle: 2,
  subtle: 5,
  medium: 15,
  strong: 45,
  dramatic: 90
};
function getEasingHandles(easing, duration) {
  const third = duration / 3;
  switch (easing) {
    case "linear":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeIn":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "easeOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeInOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "bounce":
      return {
        inHandle: { frame: -third * 0.5, value: 0, enabled: true },
        outHandle: { frame: third * 0.5, value: 0, enabled: true }
      };
    case "elastic":
      return {
        inHandle: { frame: -third * 0.3, value: 0, enabled: true },
        outHandle: { frame: third * 0.3, value: 0, enabled: true }
      };
    default:
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
  }
}
class MotionIntentTranslator {
  /**
   * Translate a camera motion intent to keyframes
   */
  translateCameraIntent(intent, cameraLayerId, currentPosition, compositionFrameCount) {
    const duration = intent.durationFrames ?? compositionFrameCount;
    const distance = INTENSITY_TO_DISTANCE[intent.intensity];
    const rotation = INTENSITY_TO_ROTATION[intent.intensity];
    const easing = intent.suggestedEasing ?? "easeInOut";
    const batches = [];
    switch (intent.type) {
      case "dolly":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.z",
            currentPosition.z,
            currentPosition.z + (intent.axis === "z" ? distance : 0),
            0,
            duration,
            easing
          )
        );
        break;
      case "truck":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.x",
            currentPosition.x,
            currentPosition.x + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pedestal":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.y",
            currentPosition.y,
            currentPosition.y + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pan":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.y",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "tilt":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.x",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "roll":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.z",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "zoom":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "camera.fov",
            60,
            60 - distance * 0.5,
            // Narrower FOV = zoom in
            0,
            duration,
            easing
          )
        );
        break;
      case "drift":
        batches.push(
          ...this.createDriftKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "handheld":
        batches.push(
          ...this.createHandheldKeyframes(
            cameraLayerId,
            currentPosition,
            duration,
            intent.noiseAmount ?? 0.5
          )
        );
        break;
      case "orbit":
        if (intent.orbitCenter) {
          batches.push(
            ...this.createOrbitKeyframes(
              cameraLayerId,
              currentPosition,
              intent.orbitCenter,
              duration,
              intent.intensity
            )
          );
        }
        break;
      case "crane":
        batches.push(
          ...this.createCraneKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "follow_path":
        if (intent.suggestedPath) {
          logger.info("Camera path following requires spline layer creation");
        }
        break;
    }
    return batches;
  }
  /**
   * Translate a spline intent to a spline layer configuration
   */
  translateSplineIntent(intent, compositionWidth, compositionHeight) {
    const controlPoints = intent.suggestedPoints.map((p, i) => ({
      id: p.id ?? `sp_${i}`,
      x: p.x,
      y: p.y,
      depth: p.depth ?? 0,
      handleIn: this.generateHandle(intent.suggestedPoints, i, -1, intent.smoothness),
      handleOut: this.generateHandle(intent.suggestedPoints, i, 1, intent.smoothness),
      type: p.type ?? "smooth"
    }));
    return {
      keyframeBatches: [],
      newSplines: [
        {
          name: `AI Path - ${intent.usage}`,
          points: controlPoints,
          closed: intent.closed
        }
      ]
    };
  }
  /**
   * Translate a particle intent to emitter configuration
   */
  translateParticleIntent(intent, compositionWidth, compositionHeight) {
    const baseConfig = {
      emissionRate: intent.intensity * 20,
      particleLifetime: intent.lifetime ?? 60,
      spread: intent.spread ?? 30
    };
    switch (intent.behavior) {
      case "snow":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 50,
          speedVariance: 20,
          gravity: 0.1
        });
        break;
      case "rain":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 200,
          speedVariance: 30,
          gravity: 0.5
        });
        break;
      case "dust":
        Object.assign(baseConfig, {
          direction: 0,
          speed: 20,
          speedVariance: 15,
          gravity: 0
        });
        break;
      case "fireflies":
        Object.assign(baseConfig, {
          direction: 90,
          speed: 30,
          speedVariance: 20,
          gravity: -0.05
        });
        break;
      case "explosion":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 300,
          speedVariance: 100,
          initialBurst: 50,
          emissionRate: 0
        });
        break;
      case "vortex":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 100
          // Would need vortex force field
        });
        break;
    }
    return {
      keyframeBatches: [],
      newLayers: [
        {
          type: "particles",
          name: `AI Particles - ${intent.behavior}`,
          config: baseConfig
        }
      ]
    };
  }
  /**
   * Translate a layer motion intent to keyframes
   */
  translateLayerIntent(intent, layer, compositionFrameCount) {
    const duration = compositionFrameCount;
    const amplitude = intent.amplitude;
    const frequency = intent.frequency ?? 1;
    const batches = [];
    switch (intent.motionType) {
      case "parallax":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 50,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "float":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.y",
            0,
            amplitude * 30,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "sway":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 40,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "breathe":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.x",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          ),
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.y",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "pulse":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "opacity",
            100,
            100 - amplitude * 30,
            duration,
            frequency * 2,
            intent.phase ?? 0
          )
        );
        break;
      case "rotate":
        batches.push(
          this.createPositionKeyframes(
            layer.id,
            "transform.rotation.z",
            0,
            360 * frequency,
            0,
            duration,
            "linear"
          )
        );
        break;
    }
    return batches;
  }
  // ============================================================================
  // KEYFRAME GENERATORS
  // ============================================================================
  createPositionKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    const handles = getEasingHandles(easing, endFrame - startFrame);
    return {
      layerId,
      propertyPath,
      keyframes: [
        {
          id: `kf_${layerId}_${propertyPath}_0`,
          frame: startFrame,
          value: startValue,
          interpolation: easing === "linear" ? "linear" : "bezier",
          ...handles,
          controlMode: "smooth"
        },
        {
          id: `kf_${layerId}_${propertyPath}_1`,
          frame: endFrame,
          value: endValue,
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: false },
          outHandle: { frame: 0, value: 0, enabled: false },
          controlMode: "smooth"
        }
      ]
    };
  }
  createRotationKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    return this.createPositionKeyframes(
      layerId,
      propertyPath,
      startValue,
      endValue,
      startFrame,
      endFrame,
      easing
    );
  }
  createOscillatingKeyframes(layerId, propertyPath, centerValue, amplitude, duration, cycles, phase) {
    const keyframes = [];
    const framesPerCycle = duration / cycles;
    const quarterCycle = framesPerCycle / 4;
    for (let i = 0; i <= cycles * 4; i++) {
      const frame = Math.round(i * quarterCycle);
      if (frame > duration) break;
      const sinePhase = (i + phase * 4) % 4;
      let value;
      switch (sinePhase) {
        case 0:
          value = centerValue;
          break;
        case 1:
          value = centerValue + amplitude;
          break;
        case 2:
          value = centerValue;
          break;
        case 3:
          value = centerValue - amplitude;
          break;
        default:
          value = centerValue;
      }
      keyframes.push({
        id: `kf_${layerId}_${propertyPath}_${i}`,
        frame,
        value,
        interpolation: "bezier",
        inHandle: { frame: -quarterCycle * 0.5, value: 0, enabled: true },
        outHandle: { frame: quarterCycle * 0.5, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return { layerId, propertyPath, keyframes };
  }
  createDriftKeyframes(layerId, startPosition, duration, intensity) {
    const distance = INTENSITY_TO_DISTANCE[intensity] * 0.3;
    return [
      this.createOscillatingKeyframes(layerId, "transform.position.x", startPosition.x, distance, duration, 0.5, 0),
      this.createOscillatingKeyframes(layerId, "transform.position.y", startPosition.y, distance * 0.7, duration, 0.3, 0.25),
      this.createOscillatingKeyframes(layerId, "transform.position.z", startPosition.z, distance * 0.5, duration, 0.4, 0.5)
    ];
  }
  createHandheldKeyframes(layerId, startPosition, duration, noiseAmount) {
    const seed = this.hashString(layerId);
    const amplitude = noiseAmount * 5;
    const keyframes = [];
    for (const axis of ["x", "y", "z"]) {
      const axisKeyframes = [];
      const baseValue = startPosition[axis];
      const numKeyframes = Math.floor(duration / 4);
      for (let i = 0; i <= numKeyframes; i++) {
        const frame = Math.min(i * 4, duration);
        const noise = this.deterministicNoise(seed, axis, frame) * amplitude;
        axisKeyframes.push({
          id: `kf_${layerId}_handheld_${axis}_${i}`,
          frame,
          value: baseValue + noise,
          interpolation: "bezier",
          inHandle: { frame: -1, value: 0, enabled: true },
          outHandle: { frame: 1, value: 0, enabled: true },
          controlMode: "smooth"
        });
      }
      keyframes.push({
        layerId,
        propertyPath: `transform.position.${axis}`,
        keyframes: axisKeyframes
      });
    }
    return keyframes;
  }
  createOrbitKeyframes(layerId, startPosition, center, duration, intensity) {
    const radius = Math.sqrt(
      Math.pow(startPosition.x - center.x, 2) + Math.pow(startPosition.z - center.z, 2)
    ) || INTENSITY_TO_DISTANCE[intensity];
    const numKeyframes = 8;
    const xKeyframes = [];
    const zKeyframes = [];
    for (let i = 0; i <= numKeyframes; i++) {
      const frame = Math.round(i / numKeyframes * duration);
      const angle = i / numKeyframes * Math.PI * 2;
      xKeyframes.push({
        id: `kf_${layerId}_orbit_x_${i}`,
        frame,
        value: center.x + Math.cos(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
      zKeyframes.push({
        id: `kf_${layerId}_orbit_z_${i}`,
        frame,
        value: center.z + Math.sin(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return [
      { layerId, propertyPath: "transform.position.x", keyframes: xKeyframes },
      { layerId, propertyPath: "transform.position.z", keyframes: zKeyframes }
    ];
  }
  createCraneKeyframes(layerId, startPosition, duration, intensity) {
    const height = INTENSITY_TO_DISTANCE[intensity];
    return [
      this.createPositionKeyframes(
        layerId,
        "transform.position.y",
        startPosition.y,
        startPosition.y + height,
        0,
        duration / 2,
        "easeOut"
      ),
      this.createPositionKeyframes(
        layerId,
        "transform.position.z",
        startPosition.z,
        startPosition.z + height * 0.5,
        0,
        duration,
        "easeInOut"
      )
    ];
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  generateHandle(points, index, direction, smoothness) {
    const prevPoint = points[index - 1];
    const nextPoint = points[index + 1];
    const currentPoint = points[index];
    if (!currentPoint) return null;
    let tangentX = 0;
    let tangentY = 0;
    if (prevPoint && nextPoint) {
      tangentX = (nextPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else if (nextPoint) {
      tangentX = (nextPoint.x - currentPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - currentPoint.y) * 0.25 * smoothness;
    } else if (prevPoint) {
      tangentX = (currentPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (currentPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else {
      return null;
    }
    return {
      x: tangentX * direction,
      y: tangentY * direction
    };
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  deterministicNoise(seed, axis, frame) {
    const axisOffset = axis === "x" ? 0 : axis === "y" ? 1e3 : 2e3;
    const combined = seed + axisOffset + frame * 13;
    const x = Math.sin(combined) * 1e4;
    return x - Math.floor(x) - 0.5;
  }
}
const motionIntentTranslator = new MotionIntentTranslator();

const _hoisted_1$7 = { class: "dialog-container" };
const _hoisted_2$7 = { class: "dialog-content" };
const _hoisted_3$7 = { class: "form-section" };
const _hoisted_4$7 = { class: "form-row" };
const _hoisted_5$7 = {
  key: 0,
  class: "form-row api-status-row"
};
const _hoisted_6$7 = {
  key: 1,
  class: "form-row"
};
const _hoisted_7$7 = { class: "form-section" };
const _hoisted_8$7 = { class: "prompt-presets" };
const _hoisted_9$7 = ["onClick"];
const _hoisted_10$7 = {
  key: 0,
  class: "form-section"
};
const _hoisted_11$6 = {
  key: 0,
  class: "spinner"
};
const _hoisted_12$5 = { class: "status-text" };
const _hoisted_13$5 = {
  key: 1,
  class: "form-section"
};
const _hoisted_14$4 = { class: "suggestions-list" };
const _hoisted_15$3 = ["onClick"];
const _hoisted_16$3 = { class: "suggestion-header" };
const _hoisted_17$3 = { class: "suggestion-type" };
const _hoisted_18$3 = { class: "suggestion-confidence" };
const _hoisted_19$3 = { class: "suggestion-description" };
const _hoisted_20$3 = { class: "suggestion-details" };
const _hoisted_21$3 = { key: 0 };
const _hoisted_22$2 = { key: 1 };
const _hoisted_23$2 = { class: "form-section preview-section" };
const _hoisted_24$1 = { class: "dialog-footer" };
const _hoisted_25$1 = { class: "footer-left" };
const _hoisted_26$1 = ["disabled"];
const _hoisted_27$1 = {
  key: 0,
  class: "spinner-small"
};
const _hoisted_28$1 = { class: "dialog-actions" };
const _hoisted_29$1 = ["disabled"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "PathSuggestionDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "accept", "preview"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectedModel = ref("rule-based");
    const localEndpoint = ref("http://localhost:8188/api/vlm");
    const apiKeyStatus = ref({ openai: false, anthropic: false });
    const prompt = ref("");
    const selectedPreset = ref(null);
    const status = ref("idle");
    const statusMessage = ref("");
    const suggestions = ref([]);
    const selectedSuggestion = ref(null);
    const showPreview = ref(true);
    const promptPresets = [
      { id: "dolly", label: "Dolly", prompt: "Gentle dolly in towards the subject" },
      { id: "orbit", label: "Orbit", prompt: "Slow orbit around the center point" },
      { id: "drift", label: "Drift", prompt: "Subtle floating drift movement" },
      { id: "handheld", label: "Handheld", prompt: "Organic handheld camera shake" },
      { id: "pan", label: "Pan", prompt: "Smooth horizontal pan across the scene" },
      { id: "crane", label: "Crane", prompt: "Vertical crane movement" }
    ];
    const isCloudModel = computed(() => {
      return ["gpt-4v", "gpt-4o", "claude-vision"].includes(selectedModel.value);
    });
    const isLocalModel = computed(() => {
      return ["qwen-vl", "qwen2-vl", "llava", "local-vlm"].includes(selectedModel.value);
    });
    const selectedProvider = computed(() => {
      if (selectedModel.value.startsWith("gpt-")) return "openai";
      if (selectedModel.value === "claude-vision") return "anthropic";
      return "openai";
    });
    async function checkApiStatus() {
      try {
        const response = await fetch("/weyl/api/status");
        const result = await response.json();
        if (result.status === "success") {
          apiKeyStatus.value = result.providers;
        }
      } catch (error) {
        console.warn("Failed to check API status:", error);
      }
    }
    onMounted(() => {
      checkApiStatus();
    });
    function selectPreset(preset) {
      selectedPreset.value = preset.id;
      prompt.value = preset.prompt;
    }
    async function loadDepthMapAsFloat32Array(depthMapUrl) {
      if (!depthMapUrl) return void 0;
      if (!isValidExternalURL(depthMapUrl, { allowData: true, allowBlob: true, allowHttp: true })) {
        console.warn("[Security] Blocked depth map URL:", depthMapUrl.substring(0, 50));
        return void 0;
      }
      try {
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = reject;
          img.src = depthMapUrl;
        });
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) return void 0;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const depthArray = new Float32Array(img.width * img.height);
        for (let i = 0; i < depthArray.length; i++) {
          const r = imageData.data[i * 4];
          const g = imageData.data[i * 4 + 1];
          const b = imageData.data[i * 4 + 2];
          depthArray[i] = (r + g + b) / (3 * 255);
        }
        return depthArray;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to load depth map:", error);
        return void 0;
      }
    }
    async function captureCurrentFrameImage() {
      try {
        const canvas = document.querySelector(".viewport-content canvas");
        if (!canvas) return void 0;
        const ctx = canvas.getContext("2d") || canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!ctx) return void 0;
        if (ctx instanceof WebGLRenderingContext || ctx instanceof WebGL2RenderingContext) {
          const width = canvas.width;
          const height = canvas.height;
          const pixels = new Uint8Array(width * height * 4);
          ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
          const imageData = new ImageData(width, height);
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const srcIdx = ((height - 1 - y) * width + x) * 4;
              const dstIdx = (y * width + x) * 4;
              imageData.data[dstIdx] = pixels[srcIdx];
              imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
              imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
              imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
          }
          return imageData;
        }
        if (ctx instanceof CanvasRenderingContext2D) {
          return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        return void 0;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to capture frame:", error);
        return void 0;
      }
    }
    async function suggestPaths() {
      if (!prompt.value.trim()) {
        status.value = "error";
        statusMessage.value = "Please enter a motion description";
        return;
      }
      status.value = "loading";
      statusMessage.value = "Analyzing scene and generating suggestions...";
      suggestions.value = [];
      selectedSuggestion.value = null;
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const depthMap = await loadDepthMapAsFloat32Array(store.depthMap);
        const frameImage = await captureCurrentFrameImage();
        const context = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: store.selectedLayerIds,
          currentFrame: store.currentFrame,
          depthMap,
          frameImage
        };
        const result = await motionIntentResolver.resolve(prompt.value, context, selectedModel.value);
        const items = [];
        if (result.cameraIntents) {
          for (const intent of result.cameraIntents) {
            items.push({
              type: "camera",
              description: `${intent.type} motion - ${intent.intensity}`,
              confidence: 0.8,
              duration: intent.durationFrames,
              intent
            });
          }
        }
        if (result.splineIntents) {
          for (const intent of result.splineIntents) {
            items.push({
              type: "spline",
              description: `${intent.usage} - ${intent.suggestedPoints.length} point path`,
              confidence: 0.9,
              points: intent.suggestedPoints.map((p) => ({ x: p.x, y: p.y, depth: p.depth })),
              intent
            });
          }
        }
        suggestions.value = items;
        status.value = "success";
        statusMessage.value = `Found ${items.length} suggestion${items.length !== 1 ? "s" : ""}`;
        if (items.length > 0) {
          selectedSuggestion.value = 0;
        }
        if (showPreview.value) {
          emit("preview", suggestions.value);
        }
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    function acceptSuggestion() {
      if (selectedSuggestion.value === null) return;
      const suggestion = suggestions.value[selectedSuggestion.value];
      const result = {
        keyframes: [],
        splines: []
      };
      if (suggestion.type === "camera") {
        const translation = motionIntentTranslator.translateCameraIntent(
          suggestion.intent,
          store.width,
          store.height,
          store.frameCount
        );
        result.keyframes = translation.keyframeBatches;
      } else if (suggestion.type === "spline") {
        const translation = motionIntentTranslator.translateSplineIntent(
          suggestion.intent,
          store.width,
          store.height
        );
        result.splines = translation.newSplines || [];
      }
      emit("accept", result);
      emit("close");
    }
    function cancel() {
      emit("close");
    }
    watch(showPreview, (show) => {
      if (show && suggestions.value.length > 0) {
        emit("preview", suggestions.value);
      } else {
        emit("preview", []);
      }
    });
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && e.ctrlKey) {
        suggestPaths();
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$7, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "dialog-title" }, "AI Path Suggestion", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$7, [
              createBaseVNode("div", _hoisted_3$7, [
                _cache[8] || (_cache[8] = createBaseVNode("label", { class: "section-label" }, "Vision Model", -1)),
                createBaseVNode("div", _hoisted_4$7, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
                    class: "select-input"
                  }, [..._cache[5] || (_cache[5] = [
                    createBaseVNode("option", { value: "rule-based" }, "Rule-Based (Offline)", -1),
                    createBaseVNode("optgroup", { label: "Cloud Models" }, [
                      createBaseVNode("option", { value: "gpt-4o" }, "OpenAI GPT-4o"),
                      createBaseVNode("option", { value: "gpt-4v" }, "OpenAI GPT-4V"),
                      createBaseVNode("option", { value: "claude-vision" }, "Claude Vision")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Local Models" }, [
                      createBaseVNode("option", { value: "qwen2-vl" }, "Qwen2-VL"),
                      createBaseVNode("option", { value: "qwen-vl" }, "Qwen-VL"),
                      createBaseVNode("option", { value: "llava" }, "LLaVA"),
                      createBaseVNode("option", { value: "local-vlm" }, "Custom Local VLM")
                    ], -1)
                  ])], 512), [
                    [vModelSelect, selectedModel.value]
                  ])
                ]),
                isCloudModel.value ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
                  createBaseVNode("span", {
                    class: normalizeClass(["api-status", { available: apiKeyStatus.value[selectedProvider.value], unavailable: !apiKeyStatus.value[selectedProvider.value] }])
                  }, [
                    _cache[6] || (_cache[6] = createBaseVNode("span", { class: "status-dot" }, null, -1)),
                    createTextVNode(" " + toDisplayString(apiKeyStatus.value[selectedProvider.value] ? "API key configured on server" : "API key not configured"), 1)
                  ], 2),
                  createBaseVNode("button", {
                    class: "btn btn-small",
                    onClick: checkApiStatus
                  }, "Refresh")
                ])) : createCommentVNode("", true),
                isLocalModel.value ? (openBlock(), createElementBlock("div", _hoisted_6$7, [
                  _cache[7] || (_cache[7] = createBaseVNode("label", null, "Endpoint:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localEndpoint.value = $event),
                    class: "text-input",
                    placeholder: "http://localhost:8188/api/vlm"
                  }, null, 512), [
                    [vModelText, localEndpoint.value]
                  ])
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_7$7, [
                _cache[9] || (_cache[9] = createBaseVNode("label", { class: "section-label" }, "Motion Description", -1)),
                createBaseVNode("div", _hoisted_8$7, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(promptPresets, (preset) => {
                    return createBaseVNode("button", {
                      key: preset.id,
                      class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                      onClick: ($event) => selectPreset(preset)
                    }, toDisplayString(preset.label), 11, _hoisted_9$7);
                  }), 64))
                ]),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => prompt.value = $event),
                  class: "prompt-input",
                  rows: "3",
                  placeholder: "Describe the motion you want, e.g., 'dolly in slowly' or 'orbit around the subject'"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              status.value !== "idle" ? (openBlock(), createElementBlock("div", _hoisted_10$7, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-bar", status.value])
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_11$6)) : createCommentVNode("", true),
                  createBaseVNode("span", _hoisted_12$5, toDisplayString(statusMessage.value), 1)
                ], 2)
              ])) : createCommentVNode("", true),
              suggestions.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$5, [
                _cache[10] || (_cache[10] = createBaseVNode("label", { class: "section-label" }, "Suggested Paths", -1)),
                createBaseVNode("div", _hoisted_14$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(suggestions.value, (suggestion, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["suggestion-item", { selected: selectedSuggestion.value === index }]),
                      onClick: ($event) => selectedSuggestion.value = index
                    }, [
                      createBaseVNode("div", _hoisted_16$3, [
                        createBaseVNode("span", _hoisted_17$3, toDisplayString(suggestion.type), 1),
                        createBaseVNode("span", _hoisted_18$3, toDisplayString(Math.round(suggestion.confidence * 100)) + "% ", 1)
                      ]),
                      createBaseVNode("div", _hoisted_19$3, toDisplayString(suggestion.description), 1),
                      createBaseVNode("div", _hoisted_20$3, [
                        suggestion.points ? (openBlock(), createElementBlock("span", _hoisted_21$3, toDisplayString(suggestion.points.length) + " points", 1)) : createCommentVNode("", true),
                        suggestion.duration ? (openBlock(), createElementBlock("span", _hoisted_22$2, toDisplayString(suggestion.duration) + " frames", 1)) : createCommentVNode("", true)
                      ])
                    ], 10, _hoisted_15$3);
                  }), 128))
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_23$2, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showPreview.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, showPreview.value]
                  ]),
                  _cache[11] || (_cache[11] = createTextVNode(" Show preview on canvas ", -1))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_24$1, [
              createBaseVNode("div", _hoisted_25$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: suggestPaths,
                  disabled: status.value === "loading"
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_27$1)) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(status.value === "loading" ? "Analyzing..." : "Suggest Paths"), 1)
                ], 8, _hoisted_26$1)
              ]),
              createBaseVNode("div", _hoisted_28$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: acceptSuggestion,
                  disabled: selectedSuggestion.value === null
                }, " Accept ", 8, _hoisted_29$1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const PathSuggestionDialog = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-2082f292"]]);

const _hoisted_1$6 = { class: "dialog-box" };
const _hoisted_2$6 = { class: "dialog-header" };
const _hoisted_3$6 = { class: "dialog-body" };
const _hoisted_4$6 = { class: "info-row" };
const _hoisted_5$6 = { class: "info-value" };
const _hoisted_6$6 = { class: "form-row" };
const _hoisted_7$6 = {
  key: 0,
  class: "form-row"
};
const _hoisted_8$6 = {
  key: 1,
  class: "form-row"
};
const _hoisted_9$6 = {
  key: 2,
  class: "curve-preview"
};
const _hoisted_10$6 = {
  viewBox: "0 0 100 100",
  class: "curve-svg"
};
const _hoisted_11$5 = ["d"];
const _hoisted_12$4 = { class: "dialog-footer" };
const _hoisted_13$4 = ["disabled"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "KeyframeInterpolationDialog",
  props: {
    visible: { type: Boolean },
    keyframeCount: {},
    initialInterpolation: {},
    initialControlMode: {}
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const interpolationType = ref("bezier");
    const easingPreset = ref("easeInOutCubic");
    const controlMode = ref("smooth");
    watch(() => props.visible, (visible) => {
      if (visible) {
        interpolationType.value = props.initialInterpolation || "bezier";
        controlMode.value = props.initialControlMode || "smooth";
        easingPreset.value = "easeInOutCubic";
      }
    });
    const curvePath = computed(() => {
      if (interpolationType.value !== "bezier") {
        return "M 0 100 L 100 0";
      }
      const easingFn = easings[easingPreset.value] || easings.linear;
      const points = [];
      for (let i = 0; i <= 100; i += 2) {
        const t = i / 100;
        const y = 100 - easingFn(t) * 100;
        points.push(`${i === 0 ? "M" : "L"} ${i} ${y}`);
      }
      return points.join(" ");
    });
    function confirm() {
      emit("confirm", {
        interpolation: interpolationType.value,
        easingPreset: easingPreset.value,
        controlMode: controlMode.value
      });
      emit("close");
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.$emit("close"), ["self"]))
        }, [
          createBaseVNode("div", _hoisted_1$6, [
            createBaseVNode("div", _hoisted_2$6, [
              _cache[6] || (_cache[6] = createBaseVNode("h3", null, "Keyframe Interpolation", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, "")
            ]),
            createBaseVNode("div", _hoisted_3$6, [
              createBaseVNode("div", _hoisted_4$6, [
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "info-label" }, "Selected Keyframes:", -1)),
                createBaseVNode("span", _hoisted_5$6, toDisplayString(__props.keyframeCount), 1)
              ]),
              createBaseVNode("div", _hoisted_6$6, [
                _cache[9] || (_cache[9] = createBaseVNode("label", null, "Temporal Interpolation", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => interpolationType.value = $event),
                  class: "select-input"
                }, [..._cache[8] || (_cache[8] = [
                  createBaseVNode("option", { value: "linear" }, "Linear", -1),
                  createBaseVNode("option", { value: "bezier" }, "Bezier (Ease)", -1),
                  createBaseVNode("option", { value: "hold" }, "Hold (Step)", -1)
                ])], 512), [
                  [vModelSelect, interpolationType.value]
                ])
              ]),
              interpolationType.value === "bezier" ? (openBlock(), createElementBlock("div", _hoisted_7$6, [
                _cache[11] || (_cache[11] = createBaseVNode("label", null, "Easing Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => easingPreset.value = $event),
                  class: "select-input"
                }, [..._cache[10] || (_cache[10] = [
                  createBaseVNode("option", { value: "" }, "Custom", -1),
                  createBaseVNode("optgroup", { label: "Ease In" }, [
                    createBaseVNode("option", { value: "easeInSine" }, "Ease In Sine"),
                    createBaseVNode("option", { value: "easeInQuad" }, "Ease In Quad"),
                    createBaseVNode("option", { value: "easeInCubic" }, "Ease In Cubic"),
                    createBaseVNode("option", { value: "easeInQuart" }, "Ease In Quart"),
                    createBaseVNode("option", { value: "easeInQuint" }, "Ease In Quint"),
                    createBaseVNode("option", { value: "easeInExpo" }, "Ease In Expo"),
                    createBaseVNode("option", { value: "easeInCirc" }, "Ease In Circ"),
                    createBaseVNode("option", { value: "easeInBack" }, "Ease In Back"),
                    createBaseVNode("option", { value: "easeInElastic" }, "Ease In Elastic")
                  ], -1),
                  createBaseVNode("optgroup", { label: "Ease Out" }, [
                    createBaseVNode("option", { value: "easeOutSine" }, "Ease Out Sine"),
                    createBaseVNode("option", { value: "easeOutQuad" }, "Ease Out Quad"),
                    createBaseVNode("option", { value: "easeOutCubic" }, "Ease Out Cubic"),
                    createBaseVNode("option", { value: "easeOutQuart" }, "Ease Out Quart"),
                    createBaseVNode("option", { value: "easeOutQuint" }, "Ease Out Quint"),
                    createBaseVNode("option", { value: "easeOutExpo" }, "Ease Out Expo"),
                    createBaseVNode("option", { value: "easeOutCirc" }, "Ease Out Circ"),
                    createBaseVNode("option", { value: "easeOutBack" }, "Ease Out Back"),
                    createBaseVNode("option", { value: "easeOutElastic" }, "Ease Out Elastic"),
                    createBaseVNode("option", { value: "easeOutBounce" }, "Ease Out Bounce")
                  ], -1),
                  createBaseVNode("optgroup", { label: "Ease In/Out" }, [
                    createBaseVNode("option", { value: "easeInOutSine" }, "Ease In/Out Sine"),
                    createBaseVNode("option", { value: "easeInOutQuad" }, "Ease In/Out Quad"),
                    createBaseVNode("option", { value: "easeInOutCubic" }, "Ease In/Out Cubic"),
                    createBaseVNode("option", { value: "easeInOutQuart" }, "Ease In/Out Quart"),
                    createBaseVNode("option", { value: "easeInOutQuint" }, "Ease In/Out Quint"),
                    createBaseVNode("option", { value: "easeInOutExpo" }, "Ease In/Out Expo"),
                    createBaseVNode("option", { value: "easeInOutCirc" }, "Ease In/Out Circ"),
                    createBaseVNode("option", { value: "easeInOutBack" }, "Ease In/Out Back"),
                    createBaseVNode("option", { value: "easeInOutElastic" }, "Ease In/Out Elastic")
                  ], -1)
                ])], 512), [
                  [vModelSelect, easingPreset.value]
                ])
              ])) : createCommentVNode("", true),
              interpolationType.value === "bezier" ? (openBlock(), createElementBlock("div", _hoisted_8$6, [
                _cache[13] || (_cache[13] = createBaseVNode("label", null, "Handle Mode", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => controlMode.value = $event),
                  class: "select-input"
                }, [..._cache[12] || (_cache[12] = [
                  createBaseVNode("option", { value: "symmetric" }, "Symmetric (mirrored)", -1),
                  createBaseVNode("option", { value: "smooth" }, "Smooth (continuous)", -1),
                  createBaseVNode("option", { value: "corner" }, "Corner (independent)", -1)
                ])], 512), [
                  [vModelSelect, controlMode.value]
                ])
              ])) : createCommentVNode("", true),
              interpolationType.value === "bezier" ? (openBlock(), createElementBlock("div", _hoisted_9$6, [
                (openBlock(), createElementBlock("svg", _hoisted_10$6, [
                  _cache[14] || (_cache[14] = createBaseVNode("line", {
                    x1: "0",
                    y1: "50",
                    x2: "100",
                    y2: "50",
                    stroke: "#333",
                    "stroke-width": "0.5"
                  }, null, -1)),
                  _cache[15] || (_cache[15] = createBaseVNode("line", {
                    x1: "50",
                    y1: "0",
                    x2: "50",
                    y2: "100",
                    stroke: "#333",
                    "stroke-width": "0.5"
                  }, null, -1)),
                  createBaseVNode("path", {
                    d: curvePath.value,
                    fill: "none",
                    stroke: "#8B5CF6",
                    "stroke-width": "2"
                  }, null, 8, _hoisted_11$5),
                  _cache[16] || (_cache[16] = createBaseVNode("circle", {
                    cx: "0",
                    cy: "100",
                    r: "3",
                    fill: "#8B5CF6"
                  }, null, -1)),
                  _cache[17] || (_cache[17] = createBaseVNode("circle", {
                    cx: "100",
                    cy: "0",
                    r: "3",
                    fill: "#8B5CF6"
                  }, null, -1))
                ]))
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_12$4, [
              createBaseVNode("button", {
                class: "btn-cancel",
                onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("close"))
              }, "Cancel"),
              createBaseVNode("button", {
                class: "btn-confirm",
                onClick: confirm,
                disabled: __props.keyframeCount === 0
              }, "Apply", 8, _hoisted_13$4)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const KeyframeInterpolationDialog = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-f9e8070c"]]);

const _hoisted_1$5 = { class: "dialog-container" };
const _hoisted_2$5 = { class: "dialog-body" };
const _hoisted_3$5 = { class: "info-section" };
const _hoisted_4$5 = { class: "info-row" };
const _hoisted_5$5 = { class: "info-value" };
const _hoisted_6$5 = { class: "info-row" };
const _hoisted_7$5 = { class: "info-value" };
const _hoisted_8$5 = { class: "control-section" };
const _hoisted_9$5 = { class: "control-row" };
const _hoisted_10$5 = { class: "input-group" };
const _hoisted_11$4 = { class: "presets" };
const _hoisted_12$3 = ["onClick"];
const _hoisted_13$3 = { class: "control-section" };
const _hoisted_14$3 = { class: "control-row" };
const _hoisted_15$2 = { class: "preview-section" };
const _hoisted_16$2 = { class: "info-row highlight" };
const _hoisted_17$2 = { class: "info-value" };
const _hoisted_18$2 = { class: "info-row highlight" };
const _hoisted_19$2 = { class: "info-value" };
const _hoisted_20$2 = { class: "control-section" };
const _hoisted_21$2 = { class: "checkbox-row" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "TimeStretchDialog",
  props: {
    visible: { type: Boolean },
    layerId: {}
  },
  emits: ["close", "applied"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const stretchFactor = ref(100);
    const holdInPlace = ref("in-point");
    const reversePlayback = ref(false);
    const originalDuration = ref(0);
    const currentStretchFactor = ref(100);
    const speedPresets = [
      { label: "25%", value: 400 },
      // Quarter speed
      { label: "50%", value: 200 },
      // Half speed
      { label: "100%", value: 100 },
      // Normal
      { label: "200%", value: 50 },
      // Double speed
      { label: "400%", value: 25 }
      // 4x speed
    ];
    const layer = computed(() => {
      return store.layers.find((l) => l.id === props.layerId);
    });
    const newDuration = computed(() => {
      return originalDuration.value * (stretchFactor.value / 100);
    });
    const effectiveSpeed = computed(() => {
      const speed = 100 / stretchFactor.value * 100;
      return reversePlayback.value ? -speed : speed;
    });
    watch(() => props.visible, (visible) => {
      if (visible && layer.value) {
        initializeFromLayer();
      }
    });
    function initializeFromLayer() {
      if (!layer.value) return;
      const data = layer.value.data;
      const startFrame = layer.value.startFrame ?? 0;
      const endFrame = layer.value.endFrame ?? store.frameCount;
      const fps = store.fps || 30;
      originalDuration.value = (endFrame - startFrame) / fps;
      if ("speed" in data && data.speed) {
        currentStretchFactor.value = 100 / data.speed;
        stretchFactor.value = currentStretchFactor.value;
        reversePlayback.value = data.speed < 0;
      } else {
        currentStretchFactor.value = 100;
        stretchFactor.value = 100;
        reversePlayback.value = false;
      }
    }
    function updatePreview() {
    }
    function reset() {
      stretchFactor.value = 100;
      reversePlayback.value = false;
      holdInPlace.value = "in-point";
    }
    function cancel() {
      emit("close");
    }
    function apply() {
      if (!layer.value) return;
      const speed = (reversePlayback.value ? -1 : 1) * (100 / stretchFactor.value);
      let newStartFrame = layer.value.startFrame ?? 0;
      let newEndFrame = layer.value.endFrame ?? store.frameCount;
      const currentDurationFrames = newEndFrame - newStartFrame;
      const newDurationFrames = Math.round(currentDurationFrames * (stretchFactor.value / currentStretchFactor.value));
      switch (holdInPlace.value) {
        case "in-point":
          newEndFrame = newStartFrame + newDurationFrames;
          break;
        case "current-frame":
          const currentFrame = store.currentFrame;
          const ratio = (currentFrame - newStartFrame) / currentDurationFrames;
          newStartFrame = Math.round(currentFrame - ratio * newDurationFrames);
          newEndFrame = newStartFrame + newDurationFrames;
          break;
        case "out-point":
          newStartFrame = newEndFrame - newDurationFrames;
          break;
      }
      store.timeStretchLayer(props.layerId, {
        stretchFactor: stretchFactor.value,
        holdInPlace: holdInPlace.value,
        reverse: reversePlayback.value,
        newStartFrame,
        newEndFrame,
        speed
      });
      emit("applied");
      emit("close");
    }
    function formatDuration(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = Math.floor(seconds % 1 * (store.fps || 30));
      return `${mins}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
    }
    function handleKeyDown(e) {
      if (!props.visible) return;
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && !e.shiftKey) {
        apply();
      }
    }
    onMounted(() => {
      document.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[3] || (_cache[3] = createBaseVNode("h2", null, "Time Stretch", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel,
                title: "Close"
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$5, [
              createBaseVNode("div", _hoisted_3$5, [
                createBaseVNode("div", _hoisted_4$5, [
                  _cache[4] || (_cache[4] = createBaseVNode("span", { class: "info-label" }, "Original Duration:", -1)),
                  createBaseVNode("span", _hoisted_5$5, toDisplayString(formatDuration(originalDuration.value)), 1)
                ]),
                createBaseVNode("div", _hoisted_6$5, [
                  _cache[5] || (_cache[5] = createBaseVNode("span", { class: "info-label" }, "Original Speed:", -1)),
                  createBaseVNode("span", _hoisted_7$5, toDisplayString((100 / currentStretchFactor.value).toFixed(1)) + "%", 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_8$5, [
                createBaseVNode("div", _hoisted_9$5, [
                  _cache[7] || (_cache[7] = createBaseVNode("label", { for: "stretch-factor" }, "Stretch Factor:", -1)),
                  createBaseVNode("div", _hoisted_10$5, [
                    withDirectives(createBaseVNode("input", {
                      id: "stretch-factor",
                      type: "number",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => stretchFactor.value = $event),
                      min: "10",
                      max: "1000",
                      step: "1",
                      class: "stretch-input",
                      onInput: updatePreview
                    }, null, 544), [
                      [
                        vModelText,
                        stretchFactor.value,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[6] || (_cache[6] = createBaseVNode("span", { class: "unit" }, "%", -1))
                  ])
                ]),
                _cache[8] || (_cache[8] = createBaseVNode("p", { class: "hint" }, " 100% = normal speed, 200% = half speed (2x duration), 50% = double speed (0.5x duration) ", -1)),
                createBaseVNode("div", _hoisted_11$4, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(speedPresets, (preset) => {
                    return createBaseVNode("button", {
                      key: preset.value,
                      class: normalizeClass(["preset-btn", { active: stretchFactor.value === preset.value }]),
                      onClick: ($event) => {
                        stretchFactor.value = preset.value;
                      }
                    }, toDisplayString(preset.label), 11, _hoisted_12$3);
                  }), 64))
                ])
              ]),
              createBaseVNode("div", _hoisted_13$3, [
                createBaseVNode("div", _hoisted_14$3, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", { for: "hold-in-place" }, "Hold In Place:", -1)),
                  withDirectives(createBaseVNode("select", {
                    id: "hold-in-place",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => holdInPlace.value = $event),
                    class: "select-input"
                  }, [..._cache[9] || (_cache[9] = [
                    createBaseVNode("option", { value: "in-point" }, "Layer In-point", -1),
                    createBaseVNode("option", { value: "current-frame" }, "Current Frame", -1),
                    createBaseVNode("option", { value: "out-point" }, "Layer Out-point", -1)
                  ])], 512), [
                    [vModelSelect, holdInPlace.value]
                  ])
                ]),
                _cache[11] || (_cache[11] = createBaseVNode("p", { class: "hint" }, " The layer will stretch from this anchor point. ", -1))
              ]),
              createBaseVNode("div", _hoisted_15$2, [
                createBaseVNode("div", _hoisted_16$2, [
                  _cache[12] || (_cache[12] = createBaseVNode("span", { class: "info-label" }, "New Duration:", -1)),
                  createBaseVNode("span", _hoisted_17$2, toDisplayString(formatDuration(newDuration.value)), 1)
                ]),
                createBaseVNode("div", _hoisted_18$2, [
                  _cache[13] || (_cache[13] = createBaseVNode("span", { class: "info-label" }, "Effective Speed:", -1)),
                  createBaseVNode("span", _hoisted_19$2, toDisplayString(effectiveSpeed.value.toFixed(1)) + "%", 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_20$2, [
                createBaseVNode("label", _hoisted_21$2, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => reversePlayback.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, reversePlayback.value]
                  ]),
                  _cache[14] || (_cache[14] = createBaseVNode("span", null, "Reverse Playback", -1))
                ])
              ])
            ]),
            createBaseVNode("div", { class: "dialog-footer" }, [
              createBaseVNode("button", {
                class: "btn btn-secondary",
                onClick: reset
              }, "Reset"),
              _cache[15] || (_cache[15] = createBaseVNode("div", { class: "spacer" }, null, -1)),
              createBaseVNode("button", {
                class: "btn btn-secondary",
                onClick: cancel
              }, "Cancel"),
              createBaseVNode("button", {
                class: "btn btn-primary",
                onClick: apply
              }, "Apply")
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const TimeStretchDialog = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-8826b616"]]);

const _hoisted_1$4 = { class: "expression-input" };
const _hoisted_2$4 = { class: "expression-header" };
const _hoisted_3$4 = { class: "expression-body" };
const _hoisted_4$4 = { class: "mode-toggle" };
const _hoisted_5$4 = {
  key: 0,
  class: "preset-section"
};
const _hoisted_6$4 = {
  key: 0,
  class: "preset-description"
};
const _hoisted_7$4 = {
  key: 1,
  class: "custom-section"
};
const _hoisted_8$4 = ["onKeydown"];
const _hoisted_9$4 = { class: "expression-footer" };
const _hoisted_10$4 = ["disabled"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ExpressionInput",
  props: {
    visible: { type: Boolean },
    currentExpression: {}
  },
  emits: ["close", "apply", "remove"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const mode = ref("preset");
    const selectedPreset = ref("");
    const customExpression = ref("");
    const hasExpression = computed(() => {
      return props.currentExpression?.enabled ?? false;
    });
    const presetDescriptions = {
      inertiaLight: "Adds subtle overshoot after keyframes end",
      inertiaHeavy: "Adds noticeable overshoot with slower settle",
      bounceGentle: "Soft bouncing at the end of motion",
      bounceFirm: "Quick bouncing with higher energy",
      elasticSnappy: "Snappy spring-like motion",
      elasticLoose: "Loose, wobbly spring motion",
      jitterSubtle: "Subtle random movement (noise)",
      jitterModerate: "Moderate random movement",
      jitterIntense: "Strong random movement",
      repeatCycle: "Loop keyframes from start",
      repeatPingpong: "Loop keyframes back and forth",
      repeatOffset: "Loop with continuous offset"
    };
    const presetDescription = computed(() => {
      return presetDescriptions[selectedPreset.value] || "";
    });
    const canApply = computed(() => {
      if (mode.value === "preset") {
        return selectedPreset.value !== "";
      }
      return customExpression.value.trim() !== "";
    });
    watch(() => props.visible, (visible) => {
      if (visible && props.currentExpression) {
        if (props.currentExpression.type === "preset") {
          mode.value = "preset";
          const presetKey = Object.keys(EXPRESSION_PRESETS).find((key) => {
            const preset = EXPRESSION_PRESETS[key];
            return preset.name === props.currentExpression?.name;
          });
          selectedPreset.value = presetKey || "";
        } else {
          mode.value = "custom";
          customExpression.value = props.currentExpression.name || "";
        }
      } else if (visible) {
        mode.value = "preset";
        selectedPreset.value = "";
        customExpression.value = "";
      }
    });
    function apply() {
      if (!canApply.value) return;
      let expression;
      if (mode.value === "preset") {
        const preset = EXPRESSION_PRESETS[selectedPreset.value];
        if (preset) {
          expression = {
            enabled: true,
            type: "preset",
            name: preset.name,
            params: { ...preset.params }
          };
        } else {
          return;
        }
      } else {
        expression = {
          enabled: true,
          type: "custom",
          name: customExpression.value.trim(),
          params: {}
        };
      }
      emit("apply", expression);
      emit("close");
    }
    function remove() {
      emit("remove");
      emit("close");
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "expression-overlay",
          onClick: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.$emit("close"), ["self"]))
        }, [
          createBaseVNode("div", _hoisted_1$4, [
            createBaseVNode("div", _hoisted_2$4, [
              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "expression-icon" }, "fx", -1)),
              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "expression-title" }, "Expression", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, "")
            ]),
            createBaseVNode("div", _hoisted_3$4, [
              createBaseVNode("div", _hoisted_4$4, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: mode.value === "preset" }),
                  onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "preset")
                }, "Preset", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: mode.value === "custom" }),
                  onClick: _cache[2] || (_cache[2] = ($event) => mode.value = "custom")
                }, "Custom", 2)
              ]),
              mode.value === "preset" ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
                _cache[10] || (_cache[10] = createBaseVNode("label", null, "Expression Type", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedPreset.value = $event),
                  class: "preset-select"
                }, [..._cache[9] || (_cache[9] = [
                  createBaseVNode("option", { value: "" }, "Select expression...", -1),
                  createBaseVNode("optgroup", { label: "Motion" }, [
                    createBaseVNode("option", { value: "inertiaLight" }, "Inertia (Light)"),
                    createBaseVNode("option", { value: "inertiaHeavy" }, "Inertia (Heavy)"),
                    createBaseVNode("option", { value: "bounceGentle" }, "Bounce (Gentle)"),
                    createBaseVNode("option", { value: "bounceFirm" }, "Bounce (Firm)"),
                    createBaseVNode("option", { value: "elasticSnappy" }, "Elastic (Snappy)"),
                    createBaseVNode("option", { value: "elasticLoose" }, "Elastic (Loose)")
                  ], -1),
                  createBaseVNode("optgroup", { label: "Jitter/Wiggle" }, [
                    createBaseVNode("option", { value: "jitterSubtle" }, "Jitter (Subtle)"),
                    createBaseVNode("option", { value: "jitterModerate" }, "Jitter (Moderate)"),
                    createBaseVNode("option", { value: "jitterIntense" }, "Jitter (Intense)")
                  ], -1),
                  createBaseVNode("optgroup", { label: "Loop" }, [
                    createBaseVNode("option", { value: "repeatCycle" }, "Loop (Cycle)"),
                    createBaseVNode("option", { value: "repeatPingpong" }, "Loop (Ping-Pong)"),
                    createBaseVNode("option", { value: "repeatOffset" }, "Loop (Offset)")
                  ], -1)
                ])], 512), [
                  [vModelSelect, selectedPreset.value]
                ]),
                presetDescription.value ? (openBlock(), createElementBlock("p", _hoisted_6$4, toDisplayString(presetDescription.value), 1)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true),
              mode.value === "custom" ? (openBlock(), createElementBlock("div", _hoisted_7$4, [
                _cache[11] || (_cache[11] = createBaseVNode("label", null, "Expression Code", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => customExpression.value = $event),
                  class: "expression-textarea",
                  placeholder: "wiggle(2, 10)",
                  rows: "3",
                  onKeydown: withKeys(withModifiers(apply, ["ctrl"]), ["enter"])
                }, null, 40, _hoisted_8$4), [
                  [vModelText, customExpression.value]
                ]),
                _cache[12] || (_cache[12] = createBaseVNode("p", { class: "hint" }, " Available: wiggle(freq, amp), loopOut('cycle'), time, value ", -1))
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_9$4, [
              hasExpression.value ? (openBlock(), createElementBlock("button", {
                key: 0,
                class: "btn-remove",
                onClick: remove
              }, " Remove ")) : createCommentVNode("", true),
              _cache[13] || (_cache[13] = createBaseVNode("div", { class: "spacer" }, null, -1)),
              createBaseVNode("button", {
                class: "btn-cancel",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
              }, "Cancel"),
              createBaseVNode("button", {
                class: "btn-apply",
                onClick: apply,
                disabled: !canApply.value
              }, "Apply", 8, _hoisted_10$4)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ExpressionInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-0f069dc1"]]);

const _hoisted_1$3 = ["viewBox"];
const _hoisted_2$3 = ["width", "height"];
const _hoisted_3$3 = ["d"];
const _hoisted_4$3 = {
  key: 0,
  width: "100%",
  height: "100%",
  fill: "url(#preview-grid)"
};
const _hoisted_5$3 = ["onClick"];
const _hoisted_6$3 = ["d", "stroke"];
const _hoisted_7$3 = ["d", "stroke", "stroke-dasharray"];
const _hoisted_8$3 = { key: 2 };
const _hoisted_9$3 = ["cx", "cy", "stroke"];
const _hoisted_10$3 = ["cx", "cy", "fill"];
const _hoisted_11$3 = ["x", "y", "fill"];
const _hoisted_12$2 = ["x", "y"];
const _hoisted_13$2 = ["x", "y", "fill"];
const _hoisted_14$2 = ["cx", "cy", "stroke"];
const _hoisted_15$1 = ["x1", "y1", "x2", "y2", "stroke"];
const _hoisted_16$1 = ["x", "y", "fill"];
const _hoisted_17$1 = { key: 1 };
const _hoisted_18$1 = ["cx", "cy"];
const _hoisted_19$1 = ["cx", "cy"];
const _hoisted_20$1 = {
  key: 0,
  class: "legend"
};
const _hoisted_21$1 = ["onClick"];
const _hoisted_22$1 = { class: "legend-text" };
const _hoisted_23$1 = {
  key: 1,
  class: "instructions"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "PathPreviewOverlay",
  props: {
    width: {},
    height: {},
    suggestions: {},
    selectedIndex: {},
    showGrid: { type: Boolean, default: true },
    showPoints: { type: Boolean, default: true },
    showLabels: { type: Boolean, default: true },
    showDepth: { type: Boolean, default: true },
    showLegend: { type: Boolean, default: true },
    showAnimation: { type: Boolean, default: true },
    gridSize: { default: 50 }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const overlayRef = ref(null);
    const animatedPosition = ref(null);
    let animationFrame = 0;
    let animationId = null;
    const pathColors = [
      "#4a90d9",
      // Blue
      "#d94a4a",
      // Red
      "#4ad94a",
      // Green
      "#d9d94a",
      // Yellow
      "#d94ad9",
      // Magenta
      "#4ad9d9"
      // Cyan
    ];
    const overlayStyle = computed(() => ({
      width: `${props.width}px`,
      height: `${props.height}px`
    }));
    const cameraSuggestions = computed(() => {
      return props.suggestions.filter((s) => s.type === "camera" && s.points && s.points.length >= 2).map((s) => ({
        type: s.description?.split(" ")[0] || "Camera",
        startX: s.points[0].x,
        startY: s.points[0].y,
        endX: s.points[s.points.length - 1].x,
        endY: s.points[s.points.length - 1].y
      }));
    });
    function getPathColor(index, opacity) {
      const baseColor = pathColors[index % pathColors.length];
      if (opacity === 1) return baseColor;
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    function pointsToPathData(points) {
      if (points.length < 2) return "";
      let d = `M ${points[0].x} ${points[0].y}`;
      if (points.length === 2) {
        d += ` L ${points[1].x} ${points[1].y}`;
      } else {
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[Math.max(0, i - 1)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(points.length - 1, i + 2)];
          const tension = 0.3;
          const cp1x = p1.x + (p2.x - p0.x) * tension;
          const cp1y = p1.y + (p2.y - p0.y) * tension;
          const cp2x = p2.x - (p3.x - p1.x) * tension;
          const cp2y = p2.y - (p3.y - p1.y) * tension;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
        }
      }
      return d;
    }
    function startAnimation() {
      if (props.selectedIndex === null) {
        animatedPosition.value = null;
        return;
      }
      const suggestion = props.suggestions[props.selectedIndex];
      if (!suggestion.points || suggestion.points.length < 2) {
        animatedPosition.value = null;
        return;
      }
      const points = suggestion.points;
      const totalLength = points.length - 1;
      function animate() {
        animationFrame = (animationFrame + 0.5) % (totalLength * 60);
        const t = animationFrame / (totalLength * 60);
        const segmentIndex = Math.min(Math.floor(t * totalLength), totalLength - 1);
        const segmentT = t * totalLength - segmentIndex;
        const p1 = points[segmentIndex];
        const p2 = points[segmentIndex + 1];
        animatedPosition.value = {
          x: p1.x + (p2.x - p1.x) * segmentT,
          y: p1.y + (p2.y - p1.y) * segmentT
        };
        animationId = requestAnimationFrame(animate);
      }
      animate();
    }
    function stopAnimation() {
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      animatedPosition.value = null;
    }
    watch(() => props.suggestions, (newSuggestions) => {
      for (const suggestion of newSuggestions) {
        if (suggestion.points && !suggestion.pathData) {
          suggestion.pathData = pointsToPathData(suggestion.points);
        }
      }
    }, { immediate: true, deep: true });
    watch(() => props.selectedIndex, () => {
      stopAnimation();
      if (props.showAnimation) {
        startAnimation();
      }
    });
    onMounted(() => {
      if (props.showAnimation && props.selectedIndex !== null) {
        startAnimation();
      }
    });
    onUnmounted(() => {
      stopAnimation();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "overlayRef",
        ref: overlayRef,
        class: "path-preview-overlay",
        style: normalizeStyle(overlayStyle.value)
      }, [
        (openBlock(), createElementBlock("svg", {
          class: "preview-svg",
          viewBox: `0 0 ${__props.width} ${__props.height}`,
          preserveAspectRatio: "xMidYMid meet"
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("pattern", {
              id: "preview-grid",
              width: __props.gridSize,
              height: __props.gridSize,
              patternUnits: "userSpaceOnUse"
            }, [
              createBaseVNode("path", {
                d: `M ${__props.gridSize} 0 L 0 0 0 ${__props.gridSize}`,
                fill: "none",
                stroke: "rgba(255,255,255,0.05)",
                "stroke-width": "1"
              }, null, 8, _hoisted_3$3)
            ], 8, _hoisted_2$3),
            _cache[0] || (_cache[0] = createStaticVNode('<filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%" data-v-23dc1ec0><feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" data-v-23dc1ec0></feGaussianBlur><feMerge data-v-23dc1ec0><feMergeNode in="blur" data-v-23dc1ec0></feMergeNode><feMergeNode in="SourceGraphic" data-v-23dc1ec0></feMergeNode></feMerge></filter><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse" data-v-23dc1ec0><path d="M 0 0 L 10 5 L 0 10 z" fill="#4a90d9" data-v-23dc1ec0></path></marker>', 2))
          ]),
          __props.showGrid ? (openBlock(), createElementBlock("rect", _hoisted_4$3)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: index,
              class: normalizeClass(["path-group", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 0,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 0.3),
                "stroke-width": "8",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                filter: "url(#path-glow)"
              }, null, 8, _hoisted_6$3)) : createCommentVNode("", true),
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 1,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 1),
                "stroke-width": "2",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-dasharray": __props.selectedIndex === index ? "none" : "8,4",
                "marker-end": "url(#arrow)"
              }, null, 8, _hoisted_7$3)) : createCommentVNode("", true),
              suggestion.points && __props.showPoints ? (openBlock(), createElementBlock("g", _hoisted_8$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(suggestion.points, (point, pIndex) => {
                  return openBlock(), createElementBlock("g", {
                    key: pIndex,
                    class: "control-point"
                  }, [
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "8",
                      fill: "none",
                      stroke: getPathColor(index, 0.5),
                      "stroke-width": "2"
                    }, null, 8, _hoisted_9$3),
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "4",
                      fill: getPathColor(index, 1)
                    }, null, 8, _hoisted_10$3),
                    __props.showLabels ? (openBlock(), createElementBlock("text", {
                      key: 0,
                      x: point.x + 12,
                      y: point.y + 4,
                      class: "point-label",
                      fill: getPathColor(index, 0.8)
                    }, toDisplayString(pIndex + 1), 9, _hoisted_11$3)) : createCommentVNode("", true),
                    point.depth !== void 0 && __props.showDepth ? (openBlock(), createElementBlock("text", {
                      key: 1,
                      x: point.x + 12,
                      y: point.y + 16,
                      class: "depth-label"
                    }, " z: " + toDisplayString(point.depth.toFixed(2)), 9, _hoisted_12$2)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 10, _hoisted_5$3);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(cameraSuggestions.value, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: `cam-${index}`
            }, [
              createBaseVNode("g", {
                class: normalizeClass(["camera-indicator", { selected: __props.selectedIndex === index }])
              }, [
                createBaseVNode("rect", {
                  x: suggestion.startX - 12,
                  y: suggestion.startY - 8,
                  width: "24",
                  height: "16",
                  rx: "2",
                  fill: getPathColor(index, 0.8)
                }, null, 8, _hoisted_13$2),
                createBaseVNode("circle", {
                  cx: suggestion.startX + 8,
                  cy: suggestion.startY,
                  r: "4",
                  fill: "none",
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2"
                }, null, 8, _hoisted_14$2),
                createBaseVNode("line", {
                  x1: suggestion.startX,
                  y1: suggestion.startY,
                  x2: suggestion.endX,
                  y2: suggestion.endY,
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2",
                  "stroke-dasharray": "4,2",
                  "marker-end": "url(#arrow)"
                }, null, 8, _hoisted_15$1),
                createBaseVNode("text", {
                  x: (suggestion.startX + suggestion.endX) / 2,
                  y: (suggestion.startY + suggestion.endY) / 2 - 10,
                  class: "motion-label",
                  fill: getPathColor(index, 1)
                }, toDisplayString(suggestion.type), 9, _hoisted_16$1)
              ], 2)
            ]);
          }), 128)),
          animatedPosition.value && __props.showAnimation ? (openBlock(), createElementBlock("g", _hoisted_17$1, [
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "6",
              fill: "#fff",
              class: "animated-dot"
            }, null, 8, _hoisted_18$1),
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "12",
              fill: "none",
              stroke: "#fff",
              "stroke-width": "2",
              opacity: "0.5",
              class: "animated-ring"
            }, null, 8, _hoisted_19$1)
          ])) : createCommentVNode("", true)
        ], 8, _hoisted_1$3)),
        __props.suggestions.length > 0 && __props.showLegend ? (openBlock(), createElementBlock("div", _hoisted_20$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["legend-item", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              createBaseVNode("span", {
                class: "legend-color",
                style: normalizeStyle({ backgroundColor: getPathColor(index, 1) })
              }, null, 4),
              createBaseVNode("span", _hoisted_22$1, toDisplayString(suggestion.description || `Path ${index + 1}`), 1)
            ], 10, _hoisted_21$1);
          }), 128))
        ])) : createCommentVNode("", true),
        __props.suggestions.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_23$1, " Click a path to select it. Press Enter to accept. ")) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const PathPreviewOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-23dc1ec0"]]);

const _hoisted_1$2 = { class: "preview-header" };
const _hoisted_2$2 = { class: "header-left" };
const _hoisted_3$2 = { class: "resolution-badge" };
const _hoisted_4$2 = { class: "header-center" };
const _hoisted_5$2 = { class: "playback-controls" };
const _hoisted_6$2 = { class: "timecode" };
const _hoisted_7$2 = { class: "header-right" };
const _hoisted_8$2 = ["title"];
const _hoisted_9$2 = ["width", "height"];
const _hoisted_10$2 = {
  key: 0,
  class: "rendering-overlay"
};
const _hoisted_11$2 = { class: "frame-info-overlay" };
const _hoisted_12$1 = { key: 0 };
const _hoisted_13$1 = { class: "progress-bar" };
const _hoisted_14$1 = ["max", "value"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "HDPreviewWindow",
  props: {
    visible: { type: Boolean },
    engine: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const store = useCompositorStore();
    const { currentFrame, frameCount, fps, isPlaying } = storeToRefs(store);
    const overlayRef = ref(null);
    const canvasContainerRef = ref(null);
    const previewCanvas = ref(null);
    const previewScale = ref("fit");
    const isFullscreen = ref(false);
    const isRendering = ref(false);
    const renderTime = ref(null);
    const containerWidth = ref(1280);
    const containerHeight = ref(720);
    const compWidth = computed(() => store.getActiveComp()?.settings.width || 1024);
    const compHeight = computed(() => store.getActiveComp()?.settings.height || 576);
    const canvasWidth = computed(() => {
      if (previewScale.value === "fit") {
        const aspect = compWidth.value / compHeight.value;
        const maxWidth = containerWidth.value - 48;
        const maxHeight = containerHeight.value - 140;
        if (maxWidth / maxHeight > aspect) {
          return Math.round(maxHeight * aspect);
        }
        return maxWidth;
      }
      return Math.round(compWidth.value * Number(previewScale.value));
    });
    const canvasHeight = computed(() => {
      if (previewScale.value === "fit") {
        const aspect = compWidth.value / compHeight.value;
        const maxWidth = containerWidth.value - 48;
        const maxHeight = containerHeight.value - 140;
        if (maxWidth / maxHeight > aspect) {
          return maxHeight;
        }
        return Math.round(maxWidth / aspect);
      }
      return Math.round(compHeight.value * Number(previewScale.value));
    });
    const resolutionLabel = computed(() => {
      return `${compWidth.value}x${compHeight.value}`;
    });
    const formattedTimecode = computed(() => {
      const seconds = currentFrame.value / fps.value;
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = currentFrame.value % fps.value;
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    const containerStyle = computed(() => ({
      width: isFullscreen.value ? "100vw" : "90vw",
      height: isFullscreen.value ? "100vh" : "90vh",
      maxWidth: isFullscreen.value ? "none" : "1600px",
      maxHeight: isFullscreen.value ? "none" : "900px"
    }));
    const canvasStyle = computed(() => ({
      width: `${canvasWidth.value}px`,
      height: `${canvasHeight.value}px`
    }));
    function togglePlayback() {
      store.togglePlayback();
    }
    function goToStart() {
      store.setCurrentFrame(0);
    }
    function goToEnd() {
      store.setCurrentFrame(frameCount.value - 1);
    }
    function stepForward() {
      store.setCurrentFrame(Math.min(currentFrame.value + 1, frameCount.value - 1));
    }
    function stepBackward() {
      store.setCurrentFrame(Math.max(currentFrame.value - 1, 0));
    }
    function onScrub(e) {
      const target = e.target;
      store.setCurrentFrame(parseInt(target.value, 10));
    }
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        overlayRef.value?.requestFullscreen();
        isFullscreen.value = true;
      } else {
        document.exitFullscreen();
        isFullscreen.value = false;
      }
    }
    async function renderFrame() {
      if (!previewCanvas.value || !props.engine) return;
      const start = performance.now();
      isRendering.value = true;
      try {
        const ctx = previewCanvas.value.getContext("2d");
        if (!ctx) return;
        const sourceCanvas = props.engine.getCanvas?.() || props.engine.renderer?.domElement;
        if (sourceCanvas) {
          ctx.clearRect(0, 0, canvasWidth.value, canvasHeight.value);
          ctx.drawImage(
            sourceCanvas,
            0,
            0,
            sourceCanvas.width,
            sourceCanvas.height,
            0,
            0,
            canvasWidth.value,
            canvasHeight.value
          );
        }
        renderTime.value = performance.now() - start;
      } finally {
        isRendering.value = false;
      }
    }
    function updateContainerSize() {
      if (canvasContainerRef.value) {
        const rect = canvasContainerRef.value.getBoundingClientRect();
        containerWidth.value = rect.width;
        containerHeight.value = rect.height;
      }
    }
    watch(() => props.visible, async (visible) => {
      if (visible) {
        await nextTick();
        overlayRef.value?.focus();
        updateContainerSize();
        renderFrame();
      }
    });
    watch(currentFrame, () => {
      if (props.visible) {
        renderFrame();
      }
    });
    onMounted(() => {
      window.addEventListener("resize", updateContainerSize);
      document.addEventListener("fullscreenchange", () => {
        isFullscreen.value = !!document.fullscreenElement;
      });
    });
    onUnmounted(() => {
      window.removeEventListener("resize", updateContainerSize);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "hd-preview-overlay",
          onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.$emit("close"), ["escape"])),
          tabindex: "0",
          ref_key: "overlayRef",
          ref: overlayRef
        }, [
          createBaseVNode("div", {
            class: "hd-preview-container",
            style: normalizeStyle(containerStyle.value)
          }, [
            createBaseVNode("div", _hoisted_1$2, [
              createBaseVNode("div", _hoisted_2$2, [
                _cache[3] || (_cache[3] = createBaseVNode("span", { class: "preview-title" }, "HD Preview", -1)),
                createBaseVNode("span", _hoisted_3$2, toDisplayString(resolutionLabel.value), 1)
              ]),
              createBaseVNode("div", _hoisted_4$2, [
                createBaseVNode("div", _hoisted_5$2, [
                  createBaseVNode("button", {
                    onClick: goToStart,
                    title: "Go to Start"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: stepBackward,
                    title: "Step Back"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: togglePlayback,
                    class: normalizeClass({ playing: unref(isPlaying) })
                  }, toDisplayString(unref(isPlaying) ? "" : ""), 3),
                  createBaseVNode("button", {
                    onClick: stepForward,
                    title: "Step Forward"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: goToEnd,
                    title: "Go to End"
                  }, "")
                ]),
                createBaseVNode("div", _hoisted_6$2, toDisplayString(formattedTimecode.value), 1)
              ]),
              createBaseVNode("div", _hoisted_7$2, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => previewScale.value = $event),
                  class: "scale-select"
                }, [..._cache[4] || (_cache[4] = [
                  createBaseVNode("option", { value: "0.5" }, "50%", -1),
                  createBaseVNode("option", { value: "0.75" }, "75%", -1),
                  createBaseVNode("option", { value: "1" }, "100%", -1),
                  createBaseVNode("option", { value: "1.5" }, "150%", -1),
                  createBaseVNode("option", { value: "2" }, "200%", -1),
                  createBaseVNode("option", { value: "fit" }, "Fit", -1)
                ])], 512), [
                  [vModelSelect, previewScale.value]
                ]),
                createBaseVNode("button", {
                  onClick: toggleFullscreen,
                  title: isFullscreen.value ? "Exit Fullscreen" : "Enter Fullscreen"
                }, toDisplayString(isFullscreen.value ? "" : ""), 9, _hoisted_8$2),
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close")),
                  title: "Close Preview (Esc)"
                }, "")
              ])
            ]),
            createBaseVNode("div", {
              class: "canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                width: canvasWidth.value,
                height: canvasHeight.value,
                style: normalizeStyle(canvasStyle.value)
              }, null, 12, _hoisted_9$2),
              isRendering.value ? (openBlock(), createElementBlock("div", _hoisted_10$2, [
                _cache[5] || (_cache[5] = createBaseVNode("div", { class: "spinner" }, null, -1)),
                createBaseVNode("span", null, "Rendering frame " + toDisplayString(unref(currentFrame)) + "...", 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_11$2, [
                createBaseVNode("span", null, "Frame " + toDisplayString(unref(currentFrame)) + " / " + toDisplayString(unref(frameCount)), 1),
                renderTime.value ? (openBlock(), createElementBlock("span", _hoisted_12$1, toDisplayString(renderTime.value.toFixed(1)) + "ms", 1)) : createCommentVNode("", true)
              ])
            ], 512),
            createBaseVNode("div", _hoisted_13$1, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${unref(currentFrame) / (unref(frameCount) - 1) * 100}%` })
              }, null, 4),
              createBaseVNode("input", {
                type: "range",
                min: 0,
                max: unref(frameCount) - 1,
                value: unref(currentFrame),
                onInput: onScrub,
                class: "scrubber"
              }, null, 40, _hoisted_14$1)
            ])
          ], 4)
        ], 544)) : createCommentVNode("", true)
      ]);
    };
  }
});

const HDPreviewWindow = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-6ea007fd"]]);

const _hoisted_1$1 = ["title"];
const _hoisted_2$1 = { class: "memory-bar" };
const _hoisted_3$1 = { class: "memory-text" };
const _hoisted_4$1 = { class: "details-header" };
const _hoisted_5$1 = {
  key: 0,
  class: "gpu-info"
};
const _hoisted_6$1 = { class: "category-breakdown" };
const _hoisted_7$1 = { class: "category-name" };
const _hoisted_8$1 = { class: "category-value" };
const _hoisted_9$1 = { key: 0 };
const _hoisted_10$1 = {
  key: 2,
  class: "details-footer"
};
const _hoisted_11$1 = ["disabled"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "MemoryIndicator",
  setup(__props) {
    const showDetails = ref(false);
    const isCleaningUp = ref(false);
    const usagePercent = computed(() => Math.round(memoryState.usagePercent.value * 100));
    const totalUsage = computed(() => memoryState.totalUsageMB.value);
    const available = computed(() => memoryState.availableVRAM.value);
    const warningLevel = computed(() => memoryState.warningLevel.value);
    const gpuInfo = computed(() => memoryState.gpuInfo.value);
    const usageByCategory = computed(() => memoryState.usageByCategory.value);
    const warning = computed(() => getWarning());
    const unloadableCount = computed(() => unloadableItems.value.length);
    const warningClass = computed(() => ({
      "level-none": warningLevel.value === "none",
      "level-info": warningLevel.value === "info",
      "level-warning": warningLevel.value === "warning",
      "level-critical": warningLevel.value === "critical"
    }));
    const usageText = computed(() => {
      return `${formatMB(totalUsage.value)} / ${formatMB(available.value)}`;
    });
    const tooltipText = computed(() => {
      const percent = usagePercent.value;
      if (warningLevel.value === "critical") {
        return `CRITICAL: ${percent}% GPU memory used - cleanup needed!`;
      }
      if (warningLevel.value === "warning") {
        return `Warning: ${percent}% GPU memory used - consider cleanup`;
      }
      return `GPU Memory: ${percent}% used`;
    });
    function formatMB(mb) {
      if (mb >= 1e3) {
        return `${(mb / 1e3).toFixed(1)}GB`;
      }
      return `${Math.round(mb)}MB`;
    }
    function formatCategory(category) {
      const labels = {
        model: "AI Models",
        texture: "Textures",
        framebuffer: "Frame Cache",
        particles: "Particles",
        geometry: "3D Geometry",
        audio: "Audio",
        other: "Other"
      };
      return labels[category] || category;
    }
    async function performCleanup() {
      isCleaningUp.value = true;
      try {
        const target = totalUsage.value * 0.3;
        await freeMemory(target);
      } finally {
        isCleaningUp.value = false;
      }
    }
    onMounted(() => {
      initializeGPUDetection();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["memory-indicator", warningClass.value]),
        onClick: _cache[2] || (_cache[2] = ($event) => showDetails.value = !showDetails.value),
        title: tooltipText.value
      }, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("div", {
            class: "memory-fill",
            style: normalizeStyle({ width: `${usagePercent.value}%` })
          }, null, 4)
        ]),
        createBaseVNode("span", _hoisted_3$1, toDisplayString(usageText.value), 1),
        showDetails.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "memory-details",
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_4$1, [
            _cache[4] || (_cache[4] = createBaseVNode("span", null, "GPU Memory Usage", -1)),
            createBaseVNode("button", {
              class: "close-details",
              onClick: _cache[0] || (_cache[0] = ($event) => showDetails.value = false)
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          gpuInfo.value ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
            createBaseVNode("small", null, toDisplayString(gpuInfo.value.renderer), 1),
            createBaseVNode("small", null, "~" + toDisplayString(formatMB(gpuInfo.value.estimatedVRAM)) + " VRAM (" + toDisplayString(gpuInfo.value.tier) + ")", 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_6$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(usageByCategory.value, (value, category) => {
              return withDirectives((openBlock(), createElementBlock("div", {
                key: category,
                class: "category-row"
              }, [
                createBaseVNode("span", _hoisted_7$1, toDisplayString(formatCategory(category)), 1),
                createBaseVNode("span", _hoisted_8$1, toDisplayString(formatMB(value)), 1)
              ])), [
                [vShow, value > 0]
              ]);
            }), 128))
          ]),
          warning.value ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(["warning-box", warning.value.level])
          }, [
            createBaseVNode("p", null, toDisplayString(warning.value.message), 1),
            warning.value.suggestions.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_9$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(warning.value.suggestions.slice(0, 3), (suggestion, i) => {
                return openBlock(), createElementBlock("li", { key: i }, toDisplayString(suggestion), 1);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          unloadableCount.value > 0 ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
            createBaseVNode("button", {
              class: "cleanup-btn",
              onClick: performCleanup,
              disabled: isCleaningUp.value
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("i", { class: "pi pi-trash" }, null, -1)),
              createTextVNode(" " + toDisplayString(isCleaningUp.value ? "Cleaning..." : `Free Memory (${unloadableCount.value} items)`), 1)
            ], 8, _hoisted_11$1)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$1);
    };
  }
});

const MemoryIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-75722aa1"]]);

const useThemeStore = defineStore("theme", {
  state: () => ({
    currentTheme: "violet"
  }),
  getters: {
    themeGradient: (state) => `var(--weyl-theme-${state.currentTheme}-gradient)`,
    themePrimary: (state) => `var(--weyl-theme-${state.currentTheme}-primary)`,
    themeSecondary: (state) => `var(--weyl-theme-${state.currentTheme}-secondary)`
  },
  actions: {
    setTheme(theme) {
      this.currentTheme = theme;
      const root = document.documentElement;
      root.style.setProperty("--weyl-accent", `var(--weyl-theme-${theme}-primary)`);
      root.style.setProperty("--weyl-accent-secondary", `var(--weyl-theme-${theme}-secondary)`);
      root.style.setProperty("--weyl-accent-gradient", `var(--weyl-theme-${theme}-gradient)`);
      const glowColors = {
        violet: "rgba(139, 92, 246, 0.3)",
        ocean: "rgba(6, 182, 212, 0.3)",
        sunset: "rgba(245, 158, 11, 0.3)",
        forest: "rgba(16, 185, 129, 0.3)",
        ember: "rgba(239, 68, 68, 0.3)",
        mono: "rgba(107, 114, 128, 0.3)"
      };
      root.style.setProperty("--weyl-accent-glow", glowColors[theme]);
      localStorage.setItem("weyl-theme", theme);
    },
    loadSavedTheme() {
      const saved = localStorage.getItem("weyl-theme");
      if (saved && ["violet", "ocean", "sunset", "forest", "ember", "mono"].includes(saved)) {
        this.setTheme(saved);
      }
    }
  }
});

const _hoisted_1 = { class: "workspace-layout" };
const _hoisted_2 = {
  class: "toolbar",
  role: "toolbar",
  "aria-label": "Drawing tools"
};
const _hoisted_3 = {
  class: "tool-group labeled-tools",
  role: "group",
  "aria-label": "Selection and drawing tools"
};
const _hoisted_4 = ["aria-pressed"];
const _hoisted_5 = ["aria-pressed"];
const _hoisted_6 = ["aria-pressed"];
const _hoisted_7 = ["aria-pressed"];
const _hoisted_8 = ["aria-pressed"];
const _hoisted_9 = ["aria-pressed"];
const _hoisted_10 = { class: "tool-group segment-options" };
const _hoisted_11 = {
  key: 1,
  class: "loading-indicator"
};
const _hoisted_12 = { class: "tool-group" };
const _hoisted_13 = ["title"];
const _hoisted_14 = { class: "icon" };
const _hoisted_15 = { class: "timecode-display" };
const _hoisted_16 = { class: "tool-group" };
const _hoisted_17 = { class: "tool-group theme-selector-group" };
const _hoisted_18 = {
  key: 0,
  class: "theme-dropdown"
};
const _hoisted_19 = { class: "theme-options" };
const _hoisted_20 = ["title", "onClick"];
const _hoisted_21 = { class: "tool-group" };
const _hoisted_22 = ["disabled"];
const _hoisted_23 = ["disabled"];
const _hoisted_24 = { class: "workspace-content" };
const _hoisted_25 = { class: "panel left-panel" };
const _hoisted_26 = {
  class: "panel-tabs",
  role: "tablist",
  "aria-label": "Left panel tabs"
};
const _hoisted_27 = ["aria-selected"];
const _hoisted_28 = ["aria-selected"];
const _hoisted_29 = ["aria-selected"];
const _hoisted_30 = ["id"];
const _hoisted_31 = { class: "panel viewport-panel" };
const _hoisted_32 = { class: "viewport-header" };
const _hoisted_33 = {
  class: "viewport-tabs",
  role: "tablist",
  "aria-label": "Viewport tabs"
};
const _hoisted_34 = ["aria-selected"];
const _hoisted_35 = ["aria-selected"];
const _hoisted_36 = ["aria-selected"];
const _hoisted_37 = { class: "viewport-controls" };
const _hoisted_38 = ["aria-pressed"];
const _hoisted_39 = ["aria-pressed"];
const _hoisted_40 = { class: "viewport-content" };
const _hoisted_41 = {
  key: 1,
  class: "guides-overlay"
};
const _hoisted_42 = ["onMousedown"];
const _hoisted_43 = {
  key: 2,
  class: "rulers-overlay"
};
const _hoisted_44 = {
  key: 3,
  class: "snap-indicator"
};
const _hoisted_45 = { class: "panel timeline-panel" };
const _hoisted_46 = { class: "panel curve-editor-panel" };
const _hoisted_47 = {
  key: 1,
  class: "panel timeline-panel"
};
const _hoisted_48 = { class: "panel right-panel" };
const _hoisted_49 = {
  class: "panel-tabs",
  role: "tablist",
  "aria-label": "Right panel tabs"
};
const _hoisted_50 = ["aria-selected"];
const _hoisted_51 = ["aria-selected"];
const _hoisted_52 = ["aria-selected"];
const _hoisted_53 = ["aria-selected"];
const _hoisted_54 = ["aria-selected"];
const _hoisted_55 = ["aria-selected"];
const _hoisted_56 = ["aria-selected"];
const _hoisted_57 = ["aria-selected"];
const _hoisted_58 = ["aria-selected"];
const _hoisted_59 = ["id"];
const DOUBLE_TAP_THRESHOLD = 300;
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "WorkspaceLayout",
  setup(__props) {
    const store = useCompositorStore();
    const assetStore = useAssetStore();
    const audioStore = useAudioStore();
    const playbackStore = usePlaybackStore();
    const expressionEditor = useExpressionEditor();
    const themeStore = useThemeStore();
    const showThemeSelector = ref(false);
    const currentTheme = computed(() => themeStore.currentTheme);
    const themeGradient = computed(() => themeStore.themeGradient);
    const themes = [
      { name: "violet", label: "Violet", gradient: "linear-gradient(135deg, #8B5CF6, #EC4899)" },
      { name: "ocean", label: "Ocean", gradient: "linear-gradient(135deg, #06B6D4, #3B82F6)" },
      { name: "sunset", label: "Sunset", gradient: "linear-gradient(135deg, #F59E0B, #EF4444)" },
      { name: "forest", label: "Forest", gradient: "linear-gradient(135deg, #10B981, #06B6D4)" },
      { name: "ember", label: "Ember", gradient: "linear-gradient(135deg, #EF4444, #F97316)" },
      { name: "mono", label: "Mono", gradient: "linear-gradient(135deg, #4B5563, #6B7280)" }
    ];
    function selectTheme(theme) {
      themeStore.setTheme(theme);
      showThemeSelector.value = false;
    }
    const currentTool = computed({
      get: () => store.currentTool,
      set: (tool) => store.setTool(tool)
    });
    const segmentMode = computed(() => store.segmentMode);
    const segmentPendingMask = computed(() => store.segmentPendingMask);
    const segmentIsLoading = computed(() => store.segmentIsLoading);
    function setSegmentMode(mode) {
      store.setSegmentMode(mode);
    }
    async function confirmSegmentMask() {
      await store.confirmSegmentMask();
    }
    function clearSegmentMask() {
      store.clearSegmentPendingMask();
    }
    const activeWorkspace = ref("standard");
    const leftTab = ref("project");
    const rightTab = ref("properties");
    const viewportTab = ref("composition");
    const viewZoom = ref("fit");
    const showCurveEditor = ref(false);
    const showExportDialog = ref(false);
    const showComfyUIExportDialog = ref(false);
    const showCompositionSettingsDialog = ref(false);
    const showPrecomposeDialog = ref(false);
    const showPathSuggestionDialog = ref(false);
    const showKeyframeInterpolationDialog = ref(false);
    const showHDPreview = ref(false);
    const pathSuggestions = ref([]);
    const selectedPathIndex = ref(null);
    const isPlaying = ref(false);
    const gpuTier = ref("cpu");
    const threeCanvasRef = ref(null);
    const canvasEngine = computed(() => threeCanvasRef.value?.engine ?? null);
    const activeCamera = computed(() => {
      const cam = store.getActiveCameraAtFrame();
      if (cam) return cam;
      return createDefaultCamera("default", compWidth.value, compHeight.value);
    });
    const viewportState = ref(createDefaultViewportState());
    const viewOptions = ref({
      showGrid: true,
      showRulers: false,
      showAxes: true,
      showCameraFrustum: true,
      showCompositionBounds: true,
      showFocalPlane: false,
      showLayerOutlines: true,
      showSafeZones: false,
      gridSize: 100,
      gridDivisions: 10
    });
    const gridOverlayStyle = computed(() => {
      const size = viewOptions.value.gridSize || 100;
      const divisions = viewOptions.value.gridDivisions || 10;
      const minorSize = size / divisions;
      return {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: "none",
        zIndex: 5,
        backgroundImage: `
      linear-gradient(to right, ${gridColor.value} 1px, transparent 1px),
      linear-gradient(to bottom, ${gridColor.value} 1px, transparent 1px),
      linear-gradient(to right, ${gridMajorColor.value} 1px, transparent 1px),
      linear-gradient(to bottom, ${gridMajorColor.value} 1px, transparent 1px)
    `,
        backgroundSize: `
      ${minorSize}px ${minorSize}px,
      ${minorSize}px ${minorSize}px,
      ${size}px ${size}px,
      ${size}px ${size}px
    `,
        opacity: 0.5
      };
    });
    function getGuideStyle(guide) {
      if (guide.orientation === "horizontal") {
        return {
          position: "absolute",
          left: 0,
          right: 0,
          top: `${guide.position}px`,
          height: "1px",
          backgroundColor: "#00BFFF",
          cursor: "ns-resize",
          zIndex: 10
        };
      } else {
        return {
          position: "absolute",
          top: 0,
          bottom: 0,
          left: `${guide.position}px`,
          width: "1px",
          backgroundColor: "#00BFFF",
          cursor: "ew-resize",
          zIndex: 10
        };
      }
    }
    function createGuideFromRuler(orientation, event) {
      const rect = event.currentTarget.getBoundingClientRect();
      let position;
      if (orientation === "horizontal") {
        position = event.clientY - rect.top;
      } else {
        position = event.clientX - rect.left;
      }
      addGuide(orientation, position);
    }
    const draggingGuide = ref(null);
    function startGuideDrag(guide, event) {
      event.preventDefault();
      draggingGuide.value = { id: guide.id, orientation: guide.orientation };
      const handleMove = (e) => {
        if (!draggingGuide.value) return;
        const viewportContent = document.querySelector(".viewport-content");
        if (!viewportContent) return;
        const rect = viewportContent.getBoundingClientRect();
        let newPosition;
        if (draggingGuide.value.orientation === "horizontal") {
          newPosition = e.clientY - rect.top;
        } else {
          newPosition = e.clientX - rect.left;
        }
        if (newPosition < 0 || newPosition > (draggingGuide.value.orientation === "horizontal" ? rect.height : rect.width)) {
          removeGuide(draggingGuide.value.id);
          draggingGuide.value = null;
          window.removeEventListener("mousemove", handleMove);
          window.removeEventListener("mouseup", handleUp);
          return;
        }
        updateGuidePosition(draggingGuide.value.id, newPosition);
      };
      const handleUp = () => {
        draggingGuide.value = null;
        window.removeEventListener("mousemove", handleMove);
        window.removeEventListener("mouseup", handleUp);
      };
      window.addEventListener("mousemove", handleMove);
      window.addEventListener("mouseup", handleUp);
    }
    const snapIndicatorX = ref(null);
    const snapIndicatorY = ref(null);
    const compWidth = computed(() => store.project?.composition?.width || 1920);
    const compHeight = computed(() => store.project?.composition?.height || 1080);
    ref(60);
    const memoryUsage = ref("0 MB");
    ref(0);
    const formattedTimecode = computed(() => {
      const frame = store.currentFrame;
      const fpsVal = store.project?.composition?.fps || 30;
      const totalSeconds = frame / fpsVal;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const frames = frame % fpsVal;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    computed(() => {
      return store.project?.meta?.name || "Untitled Project";
    });
    computed(() => {
      const comp = store.project?.composition;
      if (!comp) return "No Composition";
      return `${comp.width}${comp.height} @ ${comp.fps}fps`;
    });
    const canUndo = computed(() => store.canUndo);
    const canRedo = computed(() => store.canRedo);
    function togglePlay() {
      isPlaying.value = !isPlaying.value;
      if (isPlaying.value) {
        store.play();
      } else {
        store.pause();
      }
    }
    function goToStart() {
      store.goToStart();
    }
    function goToEnd() {
      store.goToEnd();
    }
    function stepForward(frames = 1) {
      store.setFrame(Math.min(store.currentFrame + frames, store.frameCount - 1));
    }
    function stepBackward(frames = 1) {
      store.setFrame(Math.max(0, store.currentFrame - frames));
    }
    function applySmoothEasing() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let keyframesUpdated = 0;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              store.setKeyframeInterpolation(layerId, `transform.${propKey}`, kf.id, "bezier");
              keyframesUpdated++;
            }
          }
        }
        if (layer.opacity?.animated && layer.opacity?.keyframes) {
          for (const kf of layer.opacity.keyframes) {
            store.setKeyframeInterpolation(layerId, "opacity", kf.id, "bezier");
            keyframesUpdated++;
          }
        }
      }
      if (keyframesUpdated > 0) {
        console.log(`[Weyl] Applied smooth easing to ${keyframesUpdated} keyframes`);
      }
    }
    function goToPrevKeyframe() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let prevFrame = -1;
      const currentFrame = store.currentFrame;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              if (kf.frame < currentFrame && kf.frame > prevFrame) {
                prevFrame = kf.frame;
              }
            }
          }
        }
      }
      if (prevFrame >= 0) {
        store.setFrame(prevFrame);
      }
    }
    function goToNextKeyframe() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let nextFrame = Infinity;
      const currentFrame = store.currentFrame;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              if (kf.frame > currentFrame && kf.frame < nextFrame) {
                nextFrame = kf.frame;
              }
            }
          }
        }
      }
      if (nextFrame < Infinity) {
        store.setFrame(nextFrame);
      }
    }
    const soloedProperties = ref(/* @__PURE__ */ new Set());
    function soloProperty(prop, additive = false) {
      if (additive) {
        if (soloedProperties.value.has(prop)) {
          soloedProperties.value.delete(prop);
        } else {
          soloedProperties.value.add(prop);
        }
        soloedProperties.value = new Set(soloedProperties.value);
      } else {
        if (soloedProperties.value.size === 1 && soloedProperties.value.has(prop)) {
          soloedProperties.value = /* @__PURE__ */ new Set();
        } else {
          soloedProperties.value = /* @__PURE__ */ new Set([prop]);
        }
      }
    }
    const soloedProperty = computed(() => {
      const arr = Array.from(soloedProperties.value);
      return arr.length > 0 ? arr[0] : null;
    });
    provide("soloedProperty", soloedProperty);
    provide("soloedProperties", soloedProperties);
    const lastKeyPress = ref(null);
    function isDoubleTap(key) {
      const now = Date.now();
      const last = lastKeyPress.value;
      lastKeyPress.value = { key, time: now };
      if (last && last.key === key && now - last.time < DOUBLE_TAP_THRESHOLD) {
        lastKeyPress.value = null;
        return true;
      }
      return false;
    }
    const workAreaStart = ref(null);
    const workAreaEnd = ref(null);
    function setWorkAreaStart() {
      workAreaStart.value = store.currentFrame;
      playbackStore.setWorkArea(workAreaStart.value, workAreaEnd.value);
      console.log(`[Weyl] Work area start set to frame ${store.currentFrame}`);
    }
    function setWorkAreaEnd() {
      workAreaEnd.value = store.currentFrame;
      playbackStore.setWorkArea(workAreaStart.value, workAreaEnd.value);
      console.log(`[Weyl] Work area end set to frame ${store.currentFrame}`);
    }
    provide("workAreaStart", workAreaStart);
    provide("workAreaEnd", workAreaEnd);
    const showHiddenLayers = ref(true);
    function toggleHiddenLayersVisibility() {
      showHiddenLayers.value = !showHiddenLayers.value;
      console.log(`[Weyl] Hidden layers visibility: ${showHiddenLayers.value ? "shown" : "hidden"}`);
    }
    function toggleLayerHidden(layerId) {
      const layer = store.getLayerById(layerId);
      if (layer) {
        store.updateLayer(layerId, { hidden: !layer.hidden });
      }
    }
    provide("showHiddenLayers", showHiddenLayers);
    provide("toggleLayerHidden", toggleLayerHidden);
    const previewUpdatesPaused = ref(false);
    function togglePreviewPause() {
      previewUpdatesPaused.value = !previewUpdatesPaused.value;
      console.log(`[Weyl] Preview updates: ${previewUpdatesPaused.value ? "PAUSED" : "active"}`);
    }
    provide("previewUpdatesPaused", previewUpdatesPaused);
    const showTransparencyGrid = ref(false);
    function toggleTransparencyGrid() {
      showTransparencyGrid.value = !showTransparencyGrid.value;
      console.log(`[Weyl] Transparency grid: ${showTransparencyGrid.value ? "ON" : "OFF"}`);
    }
    provide("showTransparencyGrid", showTransparencyGrid);
    const gridColor = ref("#444444");
    const gridMajorColor = ref("#666666");
    function toggleGrid() {
      viewOptions.value.showGrid = !viewOptions.value.showGrid;
      console.log(`[Weyl] Grid: ${viewOptions.value.showGrid ? "ON" : "OFF"}`);
    }
    provide("gridColor", gridColor);
    provide("gridMajorColor", gridMajorColor);
    const rulerUnits = ref("pixels");
    function toggleRulers() {
      viewOptions.value.showRulers = !viewOptions.value.showRulers;
      console.log(`[Weyl] Rulers: ${viewOptions.value.showRulers ? "ON" : "OFF"}`);
    }
    provide("rulerUnits", rulerUnits);
    const guides = ref([]);
    function addGuide(orientation, position) {
      const id = `guide-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      guides.value.push({ id, orientation, position });
      console.log(`[Weyl] Added ${orientation} guide at ${position}px`);
    }
    function removeGuide(id) {
      guides.value = guides.value.filter((g) => g.id !== id);
    }
    function clearGuides() {
      guides.value = [];
      console.log("[Weyl] Cleared all guides");
    }
    function updateGuidePosition(id, position) {
      const guide = guides.value.find((g) => g.id === id);
      if (guide) {
        guide.position = position;
      }
    }
    provide("guides", guides);
    provide("addGuide", addGuide);
    provide("removeGuide", removeGuide);
    provide("clearGuides", clearGuides);
    provide("updateGuidePosition", updateGuidePosition);
    const snapEnabled = ref(false);
    const snapToGrid = ref(true);
    const snapToGuides = ref(true);
    const snapToLayers = ref(true);
    const snapTolerance = ref(10);
    function toggleSnap() {
      snapEnabled.value = !snapEnabled.value;
      console.log(`[Weyl] Snap: ${snapEnabled.value ? "ON" : "OFF"}`);
    }
    function getSnapPoint(x, y) {
      if (!snapEnabled.value) {
        return { x, y, snappedX: false, snappedY: false };
      }
      let snappedX = false;
      let snappedY = false;
      let resultX = x;
      let resultY = y;
      if (snapToGrid.value && viewOptions.value.showGrid) {
        const currentGridSize = viewOptions.value.gridSize || 50;
        const gridX = Math.round(x / currentGridSize) * currentGridSize;
        const gridY = Math.round(y / currentGridSize) * currentGridSize;
        if (Math.abs(x - gridX) < snapTolerance.value) {
          resultX = gridX;
          snappedX = true;
        }
        if (Math.abs(y - gridY) < snapTolerance.value) {
          resultY = gridY;
          snappedY = true;
        }
      }
      if (snapToGuides.value) {
        for (const guide of guides.value) {
          if (guide.orientation === "vertical" && Math.abs(x - guide.position) < snapTolerance.value) {
            resultX = guide.position;
            snappedX = true;
          }
          if (guide.orientation === "horizontal" && Math.abs(y - guide.position) < snapTolerance.value) {
            resultY = guide.position;
            snappedY = true;
          }
        }
      }
      const compCenterX = compWidth.value / 2;
      const compCenterY = compHeight.value / 2;
      if (Math.abs(x - compCenterX) < snapTolerance.value) {
        resultX = compCenterX;
        snappedX = true;
      }
      if (Math.abs(y - compCenterY) < snapTolerance.value) {
        resultY = compCenterY;
        snappedY = true;
      }
      if (Math.abs(x) < snapTolerance.value) {
        resultX = 0;
        snappedX = true;
      }
      if (Math.abs(y) < snapTolerance.value) {
        resultY = 0;
        snappedY = true;
      }
      if (Math.abs(x - compWidth.value) < snapTolerance.value) {
        resultX = compWidth.value;
        snappedX = true;
      }
      if (Math.abs(y - compHeight.value) < snapTolerance.value) {
        resultY = compHeight.value;
        snappedY = true;
      }
      return { x: resultX, y: resultY, snappedX, snappedY };
    }
    provide("snapEnabled", snapEnabled);
    provide("snapToGrid", snapToGrid);
    provide("snapToGuides", snapToGuides);
    provide("snapToLayers", snapToLayers);
    provide("snapTolerance", snapTolerance);
    provide("getSnapPoint", getSnapPoint);
    provide("toggleSnap", toggleSnap);
    function undo() {
      store.undo();
    }
    function redo() {
      store.redo();
    }
    function updateCamera(camera) {
      if (store.activeCameraId) {
        store.updateCamera(camera.id, camera);
      }
    }
    function playExportChime() {
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        const freqs = [523.25, 659.25];
        freqs.forEach((freq, i) => {
          const osc = audioCtx.createOscillator();
          osc.type = "sine";
          osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.1);
          osc.connect(gainNode);
          osc.start(audioCtx.currentTime + i * 0.1);
          osc.stop(audioCtx.currentTime + 0.5 + i * 0.1);
        });
      } catch (e) {
        console.warn("[Weyl] Audio notification not available:", e);
      }
    }
    function onExportComplete() {
      console.log("[Weyl] Matte export completed");
      playExportChime();
    }
    function onComfyUIExportComplete(result) {
      console.log("[Weyl] ComfyUI export completed", result);
      showComfyUIExportDialog.value = false;
      playExportChime();
    }
    function onCompositionSettingsConfirm(settings) {
      console.log("[Weyl] Composition settings updated:", settings);
      store.updateCompositionSettings(store.activeCompositionId, {
        width: settings.width,
        height: settings.height,
        fps: settings.fps,
        frameCount: settings.frameCount,
        backgroundColor: settings.backgroundColor,
        autoResizeToContent: settings.autoResizeToContent
      });
      store.renameComposition(store.activeCompositionId, settings.name);
      showCompositionSettingsDialog.value = false;
    }
    function onPrecomposeConfirm(name) {
      if (store.selectedLayerIds.length > 0) {
        store.nestSelectedLayers(name);
        showPrecomposeDialog.value = false;
      }
    }
    function onKeyframeInterpolationConfirm(settings) {
      const selectedKeyframeIds = store.selectedKeyframeIds;
      if (selectedKeyframeIds.length === 0) return;
      const layers = store.layers;
      for (const layer of layers) {
        const transform = layer.transform;
        if (!transform) continue;
        const props = ["position", "rotation", "scale", "anchor", "opacity"];
        for (const propName of props) {
          const prop = transform[propName];
          if (!prop?.keyframes) continue;
          for (const kf of prop.keyframes) {
            if (selectedKeyframeIds.includes(kf.id)) {
              kf.interpolation = settings.interpolation;
              kf.controlMode = settings.controlMode;
              if (settings.interpolation === "bezier" && settings.easingPreset) {
                const presetHandles = getEasingPresetHandles(settings.easingPreset);
                if (presetHandles) {
                  kf.outHandle = { x: presetHandles.outX, y: presetHandles.outY };
                  kf.inHandle = { x: presetHandles.inX, y: presetHandles.inY };
                }
              }
            }
          }
        }
      }
      console.log(`[Weyl] Applied ${settings.interpolation} interpolation to ${selectedKeyframeIds.length} keyframes`);
      showKeyframeInterpolationDialog.value = false;
    }
    function getEasingPresetHandles(preset) {
      const presets = {
        // Ease In
        "easeInSine": { outX: 0.47, outY: 0, inX: 0.745, inY: 0.715 },
        "easeInQuad": { outX: 0.55, outY: 0.085, inX: 0.68, inY: 0.53 },
        "easeInCubic": { outX: 0.55, outY: 0.055, inX: 0.675, inY: 0.19 },
        "easeInQuart": { outX: 0.895, outY: 0.03, inX: 0.685, inY: 0.22 },
        "easeInQuint": { outX: 0.755, outY: 0.05, inX: 0.855, inY: 0.06 },
        "easeInExpo": { outX: 0.95, outY: 0.05, inX: 0.795, inY: 0.035 },
        "easeInCirc": { outX: 0.6, outY: 0.04, inX: 0.98, inY: 0.335 },
        "easeInBack": { outX: 0.6, outY: -0.28, inX: 0.735, inY: 0.045 },
        "easeInElastic": { outX: 0.5, outY: -0.5, inX: 0.7, inY: 0 },
        // Ease Out
        "easeOutSine": { outX: 0.39, outY: 0.575, inX: 0.565, inY: 1 },
        "easeOutQuad": { outX: 0.25, outY: 0.46, inX: 0.45, inY: 0.94 },
        "easeOutCubic": { outX: 0.215, outY: 0.61, inX: 0.355, inY: 1 },
        "easeOutQuart": { outX: 0.165, outY: 0.84, inX: 0.44, inY: 1 },
        "easeOutQuint": { outX: 0.23, outY: 1, inX: 0.32, inY: 1 },
        "easeOutExpo": { outX: 0.19, outY: 1, inX: 0.22, inY: 1 },
        "easeOutCirc": { outX: 0.075, outY: 0.82, inX: 0.165, inY: 1 },
        "easeOutBack": { outX: 0.175, outY: 0.885, inX: 0.32, inY: 1.275 },
        "easeOutElastic": { outX: 0.3, outY: 1, inX: 0.5, inY: 1.5 },
        "easeOutBounce": { outX: 0.2, outY: 0.9, inX: 0.3, inY: 1 },
        // Ease In/Out
        "easeInOutSine": { outX: 0.445, outY: 0.05, inX: 0.55, inY: 0.95 },
        "easeInOutQuad": { outX: 0.455, outY: 0.03, inX: 0.515, inY: 0.955 },
        "easeInOutCubic": { outX: 0.645, outY: 0.045, inX: 0.355, inY: 1 },
        "easeInOutQuart": { outX: 0.77, outY: 0, inX: 0.175, inY: 1 },
        "easeInOutQuint": { outX: 0.86, outY: 0, inX: 0.07, inY: 1 },
        "easeInOutExpo": { outX: 1, outY: 0, inX: 0, inY: 1 },
        "easeInOutCirc": { outX: 0.785, outY: 0.135, inX: 0.15, inY: 0.86 },
        "easeInOutBack": { outX: 0.68, outY: -0.55, inX: 0.265, inY: 1.55 },
        "easeInOutElastic": { outX: 0.5, outY: -0.3, inX: 0.5, inY: 1.3 }
      };
      return presets[preset] || null;
    }
    function generatePathDataFromPoints(points, closed) {
      if (points.length === 0) return "";
      if (points.length === 1) return `M ${points[0].x} ${points[0].y}`;
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        if (p0.handleOut && p1.handleIn) {
          const cp1x = p0.x + p0.handleOut.x;
          const cp1y = p0.y + p0.handleOut.y;
          const cp2x = p1.x + p1.handleIn.x;
          const cp2y = p1.y + p1.handleIn.y;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
        } else if (p0.handleOut) {
          const cpx = p0.x + p0.handleOut.x;
          const cpy = p0.y + p0.handleOut.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else if (p1.handleIn) {
          const cpx = p1.x + p1.handleIn.x;
          const cpy = p1.y + p1.handleIn.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else {
          d += ` L ${p1.x} ${p1.y}`;
        }
      }
      if (closed && points.length > 2) {
        d += " Z";
      }
      return d;
    }
    function onPathSuggestionClose() {
      showPathSuggestionDialog.value = false;
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
    }
    function onPathSuggestionPreview(suggestions) {
      pathSuggestions.value = suggestions;
      selectedPathIndex.value = suggestions.length > 0 ? 0 : null;
    }
    function onPathSuggestionAccept(result) {
      console.log("[Weyl] Path suggestion accepted:", result);
      if (result.keyframes && result.keyframes.length > 0) {
        for (const batch of result.keyframes) {
          for (const keyframe of batch.keyframes) {
            store.addKeyframe(batch.layerId, batch.propertyPath, keyframe.frame, keyframe.value, keyframe.easing);
          }
        }
      }
      if (result.splines && result.splines.length > 0) {
        for (const spline of result.splines) {
          const layer = store.createSplineLayer();
          if (spline.name) {
            store.renameLayer(layer.id, spline.name);
          }
          const controlPoints = (spline.points || []).map((p, i) => ({
            id: p.id || `cp_${Date.now()}_${i}`,
            x: p.x,
            y: p.y,
            depth: p.depth ?? 0,
            // Preserve z-space depth
            handleIn: p.handleIn || null,
            // Preserve bezier handles from translator
            handleOut: p.handleOut || null,
            type: p.type || "smooth"
          }));
          const pathData = generatePathDataFromPoints(controlPoints, spline.closed || false);
          store.updateLayerData(layer.id, {
            controlPoints,
            pathData,
            closed: spline.closed || false
          });
        }
      }
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
      showPathSuggestionDialog.value = false;
    }
    const activeCameraKeyframes = computed(() => {
      const activeCam = store.getActiveCameraAtFrame();
      if (!activeCam) return [];
      return store.getCameraKeyframes(activeCam.id);
    });
    function handleZoomChange() {
      if (!threeCanvasRef.value) return;
      if (viewZoom.value === "fit") {
        threeCanvasRef.value.fitToView();
      } else {
        const zoomLevel = parseInt(viewZoom.value) / 100;
        threeCanvasRef.value.setZoom(zoomLevel);
      }
    }
    function onCreateLayersFromSvg(svgId) {
      const storedSvg = assetStore.svgDocuments.get(svgId);
      if (!storedSvg) return;
      storedSvg.document.paths.forEach((path, index) => {
        const config = storedSvg.layerConfigs[index];
        const layer = store.createShapeLayer();
        store.renameLayer(layer.id, `${storedSvg.name}_${path.id}`);
        store.updateLayerData(layer.id, {
          svgDocumentId: svgId,
          svgPathId: path.id,
          svgPathIndex: index,
          extrusionConfig: config,
          // Set Z position based on layer depth
          transform: {
            ...layer.transform,
            position: {
              ...layer.transform.position,
              value: {
                ...layer.transform.position.value,
                z: config?.depth || 0
              }
            }
          }
        });
      });
      console.log(`[Weyl] Created ${storedSvg.document.paths.length} layers from SVG: ${storedSvg.name}`);
    }
    function onUseMeshAsEmitter(meshId) {
      const emitterConfig = assetStore.getMeshEmitterConfig(meshId);
      if (!emitterConfig) return;
      const selectedLayerIds = store.selectedLayerIds;
      if (selectedLayerIds.length === 0) {
        console.warn("[Weyl] No layer selected for mesh emitter");
        return;
      }
      const layer = store.layers.find((l) => l.id === selectedLayerIds[0]);
      if (!layer || layer.type !== "particle") {
        console.warn("[Weyl] Selected layer is not a particle layer");
        return;
      }
      store.updateLayerData(layer.id, {
        emitter: {
          ...layer.data.emitter,
          shape: "mesh",
          meshVertices: emitterConfig.meshVertices,
          meshNormals: emitterConfig.meshNormals
        }
      });
      console.log(`[Weyl] Set mesh emitter for layer: ${layer.name}`);
    }
    function onEnvironmentUpdate(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentConfig(settings);
    }
    async function onEnvironmentLoad(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      if (settings.url) {
        try {
          await engine.loadEnvironmentMap(settings.url, {
            intensity: settings.intensity,
            rotation: settings.rotation,
            backgroundBlur: settings.backgroundBlur,
            useAsBackground: settings.useAsBackground
          });
          console.log("[Weyl] Environment map loaded");
        } catch (error) {
          console.error("[Weyl] Failed to load environment map:", error);
        }
      }
    }
    function onEnvironmentClear() {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentEnabled(false);
    }
    function goToLayerInPoint() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const layer = store.getLayerById(selectedIds[0]);
      if (layer) {
        store.setFrame(layer.inPoint ?? 0);
      }
    }
    function goToLayerOutPoint() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const layer = store.getLayerById(selectedIds[0]);
      if (layer) {
        store.setFrame((layer.outPoint ?? store.frameCount) - 1);
      }
    }
    function moveLayerInPointToPlayhead() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        store.updateLayer(id, { inPoint: store.currentFrame });
      }
    }
    function moveLayerOutPointToPlayhead() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        store.updateLayer(id, { outPoint: store.currentFrame + 1 });
      }
    }
    function trimLayerInPoint() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (layer) {
          const currentIn = layer.inPoint ?? 0;
          if (store.currentFrame > currentIn) {
            store.updateLayer(id, { inPoint: store.currentFrame });
          }
        }
      }
    }
    function trimLayerOutPoint() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (layer) {
          const currentOut = layer.outPoint ?? store.frameCount;
          if (store.currentFrame < currentOut) {
            store.updateLayer(id, { outPoint: store.currentFrame + 1 });
          }
        }
      }
    }
    function selectPreviousLayer(extend = false) {
      const layers = store.layers;
      if (layers.length === 0) return;
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) {
        store.selectLayer(layers[0].id);
        return;
      }
      const currentIndex = layers.findIndex((l) => l.id === selectedIds[0]);
      if (currentIndex > 0) {
        const targetLayer = layers[currentIndex - 1];
        if (extend) {
          store.selectLayer(targetLayer.id, true);
        } else {
          store.selectLayer(targetLayer.id);
        }
      }
    }
    function selectNextLayer(extend = false) {
      const layers = store.layers;
      if (layers.length === 0) return;
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) {
        store.selectLayer(layers[0].id);
        return;
      }
      const lastSelectedIndex = layers.findIndex((l) => l.id === selectedIds[selectedIds.length - 1]);
      if (lastSelectedIndex < layers.length - 1) {
        const targetLayer = layers[lastSelectedIndex + 1];
        if (extend) {
          store.selectLayer(targetLayer.id, true);
        } else {
          store.selectLayer(targetLayer.id);
        }
      }
    }
    function splitLayerAtPlayhead() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const currentFrame = store.currentFrame;
        const inPoint = layer.inPoint ?? 0;
        const outPoint = layer.outPoint ?? store.frameCount;
        if (currentFrame > inPoint && currentFrame < outPoint) {
          store.updateLayer(id, { outPoint: currentFrame });
          const newLayer = store.duplicateLayer(id);
          if (newLayer) {
            store.updateLayer(newLayer.id, {
              inPoint: currentFrame,
              outPoint
            });
            store.renameLayer(newLayer.id, `${layer.name} (split)`);
          }
        }
      }
    }
    function reverseSelectedLayers() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        store.reverseLayer(id);
      }
    }
    const showTimeStretchDialog = ref(false);
    function openTimeStretchDialog() {
      if (store.selectedLayerIds.length === 0) return;
      showTimeStretchDialog.value = true;
    }
    const timelineZoom = ref(1);
    function zoomTimelineIn() {
      timelineZoom.value = Math.min(timelineZoom.value * 1.5, 10);
      store.setTimelineZoom?.(timelineZoom.value);
    }
    function zoomTimelineOut() {
      timelineZoom.value = Math.max(timelineZoom.value / 1.5, 0.1);
      store.setTimelineZoom?.(timelineZoom.value);
    }
    function zoomTimelineToFit() {
      timelineZoom.value = 1;
      store.setTimelineZoom?.(1);
    }
    const viewerZoom = ref(1);
    function zoomViewerIn() {
      viewerZoom.value = Math.min(viewerZoom.value * 1.25, 8);
      if (threeCanvasRef.value) {
        threeCanvasRef.value.setZoom?.(viewerZoom.value);
      }
      const percent = Math.round(viewerZoom.value * 100);
      viewZoom.value = String(percent);
    }
    function zoomViewerOut() {
      viewerZoom.value = Math.max(viewerZoom.value / 1.25, 0.1);
      if (threeCanvasRef.value) {
        threeCanvasRef.value.setZoom?.(viewerZoom.value);
      }
      const percent = Math.round(viewerZoom.value * 100);
      viewZoom.value = String(percent);
    }
    function zoomViewerToFit() {
      viewerZoom.value = 1;
      viewZoom.value = "fit";
      if (threeCanvasRef.value) {
        threeCanvasRef.value.fitToView?.();
      }
    }
    function zoomViewerTo100() {
      viewerZoom.value = 1;
      viewZoom.value = "100";
      if (threeCanvasRef.value) {
        threeCanvasRef.value.setZoom?.(1);
      }
    }
    function applySmoothEaseIn() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let keyframesUpdated = 0;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              store.setKeyframeInterpolation(layerId, `transform.${propKey}`, kf.id, "bezier");
              store.updateKeyframeHandles?.(layerId, `transform.${propKey}`, kf.id, {
                inHandle: { x: -0.42, y: 0 },
                // Pull back (slow arrival)
                outHandle: { x: 0.1, y: 0 }
                // Quick departure
              });
              keyframesUpdated++;
            }
          }
        }
      }
      if (keyframesUpdated > 0) {
        console.log(`[Weyl] Applied Smooth In to ${keyframesUpdated} keyframes`);
      }
    }
    function applySmoothEaseOut() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let keyframesUpdated = 0;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              store.setKeyframeInterpolation(layerId, `transform.${propKey}`, kf.id, "bezier");
              store.updateKeyframeHandles?.(layerId, `transform.${propKey}`, kf.id, {
                inHandle: { x: -0.1, y: 0 },
                // Quick arrival
                outHandle: { x: 0.42, y: 0 }
                // Pull forward (slow departure)
              });
              keyframesUpdated++;
            }
          }
        }
      }
      if (keyframesUpdated > 0) {
        console.log(`[Weyl] Applied Smooth Out to ${keyframesUpdated} keyframes`);
      }
    }
    function convertToHoldKeyframes() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      let keyframesUpdated = 0;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes) {
            for (const kf of prop.keyframes) {
              store.setKeyframeInterpolation(layerId, `transform.${propKey}`, kf.id, "hold");
              keyframesUpdated++;
            }
          }
        }
      }
      if (keyframesUpdated > 0) {
        console.log(`[Weyl] Converted ${keyframesUpdated} keyframes to hold`);
      }
    }
    function timeReverseKeyframes() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer?.transform) continue;
        const transform = layer.transform;
        for (const propKey of ["position", "scale", "rotation", "anchor", "opacity"]) {
          const prop = transform[propKey];
          if (prop?.animated && prop?.keyframes && prop.keyframes.length >= 2) {
            const keyframes = [...prop.keyframes];
            const values = keyframes.map((kf) => kf.value);
            values.reverse();
            for (let i = 0; i < keyframes.length; i++) {
              store.updateKeyframeValue?.(layerId, `transform.${propKey}`, keyframes[i].id, values[i]);
            }
          }
        }
      }
      console.log("[Weyl] Keyframes time-reversed");
    }
    function fitLayerToComp() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const compW = compWidth.value;
      const compH = compHeight.value;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const data = layer.data;
        const layerW = data?.width || compW;
        const layerH = data?.height || compH;
        const scaleX = compW / layerW;
        const scaleY = compH / layerH;
        const scale = Math.max(scaleX, scaleY);
        const centerX = compW / 2;
        const centerY = compH / 2;
        store.updateLayerTransform?.(id, {
          position: { x: centerX, y: centerY, z: 0 },
          scale: { x: scale * 100, y: scale * 100, z: 100 },
          anchor: { x: layerW / 2, y: layerH / 2, z: 0 }
        });
      }
      console.log("[Weyl] Fit layer(s) to composition");
    }
    function fitLayerToCompWidth() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const compW = compWidth.value;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const data = layer.data;
        const layerW = data?.width || compW;
        const scale = compW / layerW;
        store.updateLayerTransform?.(id, {
          scale: { x: scale * 100, y: scale * 100, z: 100 }
        });
      }
      console.log("[Weyl] Fit layer(s) to composition width");
    }
    function fitLayerToCompHeight() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const compH = compHeight.value;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const data = layer.data;
        const layerH = data?.height || compH;
        const scale = compH / layerH;
        store.updateLayerTransform?.(id, {
          scale: { x: scale * 100, y: scale * 100, z: 100 }
        });
      }
      console.log("[Weyl] Fit layer(s) to composition height");
    }
    function toggleLayerLock() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (layer) {
          store.updateLayer(id, { locked: !layer.locked });
        }
      }
    }
    function centerAnchorPoint() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const data = layer.data;
        const layerW = data?.width || compWidth.value;
        const layerH = data?.height || compHeight.value;
        const centerX = layerW / 2;
        const centerY = layerH / 2;
        const transform = layer.transform;
        const currentAnchor = transform?.anchor?.value || transform?.anchor?.defaultValue || { x: 0, y: 0, z: 0 };
        const currentPos = transform?.position?.value || transform?.position?.defaultValue || { x: 0, y: 0, z: 0 };
        const offsetX = centerX - (currentAnchor.x || 0);
        const offsetY = centerY - (currentAnchor.y || 0);
        store.updateLayerTransform?.(id, {
          anchor: { x: centerX, y: centerY, z: currentAnchor.z || 0 },
          position: {
            x: (currentPos.x || 0) + offsetX,
            y: (currentPos.y || 0) + offsetY,
            z: currentPos.z || 0
          }
        });
      }
      console.log("[Weyl] Centered anchor point(s)");
    }
    function centerLayerInComp() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const centerX = compWidth.value / 2;
      const centerY = compHeight.value / 2;
      for (const id of selectedIds) {
        const layer = store.getLayerById(id);
        if (!layer) continue;
        const transform = layer.transform;
        const currentPos = transform?.position?.value || transform?.position?.defaultValue || { z: 0 };
        store.updateLayerTransform?.(id, {
          position: { x: centerX, y: centerY, z: currentPos.z || 0 }
        });
      }
      console.log("[Weyl] Centered layer(s) in composition");
    }
    function createAdjustmentLayer() {
      store.addLayer("adjustment", {
        name: "Adjustment Layer",
        width: compWidth.value,
        height: compHeight.value
      });
      console.log("[Weyl] Created adjustment layer");
    }
    function createNullLayer() {
      store.addLayer("null", {
        name: "Null Object"
      });
      console.log("[Weyl] Created null layer");
    }
    function revealSourceInProject() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) {
        console.log("[Weyl] No layer selected to reveal source");
        return;
      }
      const layer = store.getLayerById(selectedIds[0]);
      if (!layer) return;
      const data = layer.data;
      let assetId = null;
      if (data?.assetId) {
        assetId = data.assetId;
      } else if (layer.type === "precomp") {
        if (data?.compositionId) {
          leftTab.value = "comps";
          console.log(`[Weyl] Revealed precomp source: ${data.compositionId}`);
          return;
        }
      }
      if (assetId) {
        leftTab.value = "assets";
        if (typeof store.selectAsset === "function") {
          store.selectAsset(assetId);
        }
        console.log(`[Weyl] Revealed source asset: ${assetId}`);
      } else {
        console.log(`[Weyl] Layer type '${layer.type}' has no source asset`);
      }
    }
    function selectAllKeyframesOnSelectedLayers() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return false;
      const keyframeIds = [];
      for (const layerId of selectedIds) {
        const layer = store.getLayerById(layerId);
        if (!layer) continue;
        const transform = layer.transform;
        if (transform) {
          const props = ["position", "rotation", "scale", "anchor", "opacity"];
          for (const propName of props) {
            const prop = transform[propName];
            if (prop?.keyframes && Array.isArray(prop.keyframes)) {
              for (const kf of prop.keyframes) {
                if (kf.id) keyframeIds.push(kf.id);
              }
            }
          }
        }
        const data = layer.data;
        if (data) {
          const checkForKeyframes = (obj) => {
            if (!obj || typeof obj !== "object") return;
            if (Array.isArray(obj.keyframes)) {
              for (const kf of obj.keyframes) {
                if (kf.id) keyframeIds.push(kf.id);
              }
            }
            for (const key of Object.keys(obj)) {
              if (typeof obj[key] === "object") checkForKeyframes(obj[key]);
            }
          };
          checkForKeyframes(data);
        }
      }
      if (keyframeIds.length > 0) {
        useSelectionStore().selectKeyframes(keyframeIds);
        console.log(`[Weyl] Selected ${keyframeIds.length} keyframes on ${selectedIds.length} layer(s)`);
        return true;
      }
      return false;
    }
    function selectLayersByLabel() {
      const selectedIds = store.selectedLayerIds;
      if (selectedIds.length === 0) return;
      const firstLayer = store.getLayerById(selectedIds[0]);
      if (!firstLayer) return;
      const targetColor = firstLayer.labelColor || firstLayer.color || "#808080";
      const layers = store.layers;
      const matchingIds = [];
      for (const layer of layers) {
        const layerColor = layer.labelColor || layer.color || "#808080";
        if (layerColor === targetColor) {
          matchingIds.push(layer.id);
        }
      }
      if (matchingIds.length > 0) {
        store.selectLayers?.(matchingIds) || matchingIds.forEach((id) => store.selectLayer(id, true));
        console.log(`[Weyl] Selected ${matchingIds.length} layers with label color ${targetColor}`);
      }
    }
    function handleKeydown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA") {
        return;
      }
      const hasSelectedLayer = store.selectedLayerIds.length > 0;
      switch (e.key.toLowerCase()) {
        case " ":
          e.preventDefault();
          togglePlay();
          break;
        case "p":
          if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            soloProperty("position", e.shiftKey);
          } else if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            currentTool.value = "pen";
          }
          break;
        case "s":
          if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            soloProperty("scale", e.shiftKey);
          }
          break;
        case "t":
          if ((e.ctrlKey || e.metaKey) && e.altKey && hasSelectedLayer) {
            e.preventDefault();
            openTimeStretchDialog();
          } else if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            soloProperty("opacity", e.shiftKey);
          } else if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            currentTool.value = "text";
          }
          break;
        case "a":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (hasSelectedLayer) {
              const selectedKeyframes = selectAllKeyframesOnSelectedLayers();
              if (!selectedKeyframes) {
                store.selectAllLayers();
              }
            } else {
              store.selectAllLayers();
            }
          } else if (hasSelectedLayer) {
            e.preventDefault();
            soloProperty("anchor", e.shiftKey);
          } else if (!e.shiftKey) {
            leftTab.value = "assets";
          }
          break;
        case "u":
          if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (isDoubleTap("u")) {
              soloProperty("modified", e.shiftKey);
            } else {
              soloProperty("animated", e.shiftKey);
            }
          }
          break;
        case "e":
          if ((e.ctrlKey || e.metaKey) && e.altKey && hasSelectedLayer) {
            e.preventDefault();
            revealSourceInProject();
          } else if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (isDoubleTap("e")) {
              soloProperty("expressions", e.shiftKey);
            } else {
              soloProperty("effects", e.shiftKey);
            }
          }
          break;
        case "m":
          if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            if (isDoubleTap("m")) {
              soloProperty("masks", e.shiftKey);
              console.log("[Weyl] Showing all mask properties (MM)");
            } else {
              soloProperty("masks", e.shiftKey);
            }
          } else if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            showExportDialog.value = true;
          }
          break;
        case "h":
          if (e.ctrlKey && e.altKey) {
            e.preventDefault();
            convertToHoldKeyframes();
          } else if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            toggleTransparencyGrid();
          } else if (!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
            currentTool.value = "hand";
          }
          break;
        case "z":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
          } else {
            currentTool.value = "zoom";
          }
          break;
        case "end":
          e.preventDefault();
          goToEnd();
          break;
        case "pageup":
          e.preventDefault();
          stepBackward(e.shiftKey ? 10 : 1);
          break;
        case "pagedown":
          e.preventDefault();
          stepForward(e.shiftKey ? 10 : 1);
          break;
        case "arrowleft":
          e.preventDefault();
          stepBackward(e.shiftKey ? 10 : 1);
          break;
        case "arrowright":
          e.preventDefault();
          stepForward(e.shiftKey ? 10 : 1);
          break;
        case "j":
          if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            goToPrevKeyframe();
          }
          break;
        case "k":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            if (store.selectedKeyframeIds.length > 0) {
              showKeyframeInterpolationDialog.value = true;
            } else {
              console.log("[Weyl] No keyframes selected for interpolation dialog");
            }
          } else if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            showCompositionSettingsDialog.value = true;
          } else {
            e.preventDefault();
            goToNextKeyframe();
          }
          break;
        case "g":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey && hasSelectedLayer) {
            e.preventDefault();
            selectLayersByLabel();
          } else if (e.shiftKey) {
            e.preventDefault();
            showCurveEditor.value = !showCurveEditor.value;
          }
          break;
        case "i":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            triggerAssetImport();
          } else if (hasSelectedLayer) {
            e.preventDefault();
            goToLayerInPoint();
          }
          break;
        case "o":
          if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            goToLayerOutPoint();
          }
          break;
        case "c":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            if (store.selectedLayerIds.length > 0) {
              showPrecomposeDialog.value = true;
            }
          } else if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.copySelectedLayers();
          }
          break;
        case "delete":
        case "backspace":
          if (store.selectedLayerIds.length > 0) {
            e.preventDefault();
            store.deleteSelectedLayers();
          }
          break;
        case "f9":
          e.preventDefault();
          if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            applySmoothEaseOut();
          } else if (e.shiftKey) {
            applySmoothEaseIn();
          } else {
            applySmoothEasing();
          }
          break;
        case "v":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.pasteLayers();
          } else if (!e.shiftKey) {
            currentTool.value = "select";
          }
          break;
        case "x":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.cutSelectedLayers();
          }
          break;
        case "[":
          if (e.altKey) {
            e.preventDefault();
            trimLayerInPoint();
          } else if (hasSelectedLayer) {
            e.preventDefault();
            moveLayerInPointToPlayhead();
          }
          break;
        case "]":
          if (e.altKey) {
            e.preventDefault();
            trimLayerOutPoint();
          } else if (hasSelectedLayer) {
            e.preventDefault();
            moveLayerOutPointToPlayhead();
          }
          break;
        case "arrowup":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            selectPreviousLayer(e.shiftKey);
          }
          break;
        case "arrowdown":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            selectNextLayer(e.shiftKey);
          }
          break;
        case "d":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            splitLayerAtPlayhead();
          } else if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.duplicateSelectedLayers();
          }
          break;
        case "r":
          if ((e.ctrlKey || e.metaKey) && e.altKey && hasSelectedLayer) {
            e.preventDefault();
            reverseSelectedLayers();
          } else if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            soloProperty("rotation", e.shiftKey);
          }
          break;
        case "=":
        case "+":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomViewerIn();
          } else {
            e.preventDefault();
            zoomTimelineIn();
          }
          break;
        case "-":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomViewerOut();
          } else {
            e.preventDefault();
            zoomTimelineOut();
          }
          break;
        case ";":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            toggleSnap();
          } else if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            zoomTimelineToFit();
          }
          break;
        case "0":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomViewerToFit();
          } else if (e.shiftKey && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            zoomViewerTo100();
          }
          break;
        case ".":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            audioStore.toggleAudioPlayback(store.currentFrame, store.fps);
          }
          break;
        case "b":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            e.preventDefault();
            setWorkAreaStart();
          }
          break;
        case "n":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            e.preventDefault();
            setWorkAreaEnd();
          }
          break;
        case "l":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            toggleLayerLock();
          }
          break;
        case "capslock":
          e.preventDefault();
          togglePreviewPause();
          break;
        case "r":
          if ((e.ctrlKey || e.metaKey) && e.shiftKey && !e.altKey) {
            e.preventDefault();
            toggleRulers();
          } else if ((e.ctrlKey || e.metaKey) && e.altKey) {
            e.preventDefault();
            timeReverseKeyframes();
          } else if (hasSelectedLayer && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            soloProperty("rotation", e.shiftKey);
          }
          break;
        case "f":
          if ((e.ctrlKey || e.metaKey) && e.altKey) {
            e.preventDefault();
            if (e.shiftKey) {
              fitLayerToCompHeight();
            } else {
              fitLayerToComp();
            }
          } else if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            fitLayerToCompWidth();
          }
          break;
        case "y":
          if ((e.ctrlKey || e.metaKey) && e.altKey && e.shiftKey) {
            e.preventDefault();
            createNullLayer();
          } else if ((e.ctrlKey || e.metaKey) && e.altKey) {
            e.preventDefault();
            createAdjustmentLayer();
          } else if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();
            toggleHiddenLayersVisibility();
          }
          break;
        case "home":
          if ((e.ctrlKey || e.metaKey) && e.altKey) {
            e.preventDefault();
            centerAnchorPoint();
          } else if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            centerLayerInComp();
          } else {
            e.preventDefault();
            store.setFrame(0);
          }
          break;
        case "'":
        case "`":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            toggleGrid();
          }
          break;
      }
    }
    ref(null);
    function triggerAssetImport() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".svg,.gltf,.glb,.obj,.fbx,.hdr,.exr,.png,.jpg";
      input.multiple = true;
      input.onchange = async (e) => {
        const files = e.target.files;
        if (!files) return;
        for (const file of files) {
          const ext = file.name.split(".").pop()?.toLowerCase();
          if (ext === "svg") {
            await assetStore.importSvgFromFile(file);
          } else if (["hdr", "exr"].includes(ext || "")) {
            await assetStore.loadEnvironment(file);
          }
        }
        leftTab.value = "assets";
      };
      input.click();
    }
    let perfInterval;
    function updatePerformanceStats() {
      if ("memory" in performance) {
        const mem = performance.memory;
        const usedMB = Math.round(mem.usedJSHeapSize / 1024 / 1024);
        memoryUsage.value = `${usedMB} MB`;
      }
    }
    onMounted(async () => {
      const tierInfo = await detectGPUTier();
      gpuTier.value = tierInfo.tier;
      window.addEventListener("keydown", handleKeydown);
      perfInterval = window.setInterval(updatePerformanceStats, 1e3);
      if (store.autosaveEnabled) {
        store.startAutosaveTimer();
      }
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
      clearInterval(perfInterval);
      store.stopAutosaveTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "select" }),
              "aria-pressed": currentTool.value === "select",
              onClick: _cache[0] || (_cache[0] = ($event) => currentTool.value = "select"),
              title: "Select Tool (V) - Select and move layers",
              "aria-label": "Select tool"
            }, [..._cache[51] || (_cache[51] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Select", -1)
            ])], 10, _hoisted_4),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "pen" }),
              "aria-pressed": currentTool.value === "pen",
              onClick: _cache[1] || (_cache[1] = ($event) => currentTool.value = "pen"),
              title: "Pen Tool (P) - Draw paths and shapes",
              "aria-label": "Pen tool"
            }, [..._cache[52] || (_cache[52] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Pen", -1)
            ])], 10, _hoisted_5),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "text" }),
              "aria-pressed": currentTool.value === "text",
              onClick: _cache[2] || (_cache[2] = ($event) => currentTool.value = "text"),
              title: "Text Tool (T) - Add text layers",
              "aria-label": "Text tool"
            }, [..._cache[53] || (_cache[53] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "T", -1),
              createBaseVNode("span", { class: "tool-label" }, "Text", -1)
            ])], 10, _hoisted_6),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "hand" }),
              "aria-pressed": currentTool.value === "hand",
              onClick: _cache[3] || (_cache[3] = ($event) => currentTool.value = "hand"),
              title: "Hand Tool (H) - Pan the viewport",
              "aria-label": "Pan tool"
            }, [..._cache[54] || (_cache[54] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Pan", -1)
            ])], 10, _hoisted_7),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "zoom" }),
              "aria-pressed": currentTool.value === "zoom",
              onClick: _cache[4] || (_cache[4] = ($event) => currentTool.value = "zoom"),
              title: "Zoom Tool (Z) - Zoom in/out the viewport",
              "aria-label": "Zoom tool"
            }, [..._cache[55] || (_cache[55] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Zoom", -1)
            ])], 10, _hoisted_8),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "segment" }),
              "aria-pressed": currentTool.value === "segment",
              onClick: _cache[5] || (_cache[5] = ($event) => currentTool.value = "segment"),
              title: "AI Segment (S) - Auto-select objects using AI",
              "aria-label": "AI Segment tool"
            }, [..._cache[56] || (_cache[56] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "AI Seg", -1)
            ])], 10, _hoisted_9)
          ]),
          _cache[76] || (_cache[76] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", { class: "tool-group" }, [
            createBaseVNode("button", {
              onClick: triggerAssetImport,
              title: "Import Asset (Ctrl+I)",
              class: "import-btn"
            }, [..._cache[57] || (_cache[57] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createBaseVNode("span", { class: "btn-label" }, "Import", -1)
            ])])
          ]),
          currentTool.value === "segment" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _cache[63] || (_cache[63] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("div", _hoisted_10, [
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "point" }),
                onClick: _cache[6] || (_cache[6] = ($event) => setSegmentMode("point")),
                title: "Point Mode - Click to segment"
              }, [..._cache[58] || (_cache[58] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Point ", -1)
              ])], 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "box" }),
                onClick: _cache[7] || (_cache[7] = ($event) => setSegmentMode("box")),
                title: "Box Mode - Draw rectangle to segment"
              }, [..._cache[59] || (_cache[59] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Box ", -1)
              ])], 2),
              segmentPendingMask.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _cache[62] || (_cache[62] = createBaseVNode("div", { class: "divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: confirmSegmentMask,
                  class: "confirm-btn",
                  title: "Create Layer from Selection"
                }, [..._cache[60] || (_cache[60] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Create Layer ", -1)
                ])]),
                createBaseVNode("button", {
                  onClick: clearSegmentMask,
                  class: "cancel-btn",
                  title: "Cancel Selection"
                }, [..._cache[61] || (_cache[61] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])])
              ], 64)) : createCommentVNode("", true),
              segmentIsLoading.value ? (openBlock(), createElementBlock("span", _hoisted_11, "Segmenting...")) : createCommentVNode("", true)
            ])
          ], 64)) : createCommentVNode("", true),
          _cache[77] || (_cache[77] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_12, [
            createBaseVNode("button", {
              onClick: goToStart,
              title: "Go to Start (Home)"
            }, [..._cache[64] || (_cache[64] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: stepBackward,
              title: "Step Backward"
            }, [..._cache[65] || (_cache[65] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: togglePlay,
              title: isPlaying.value ? "Pause (Space)" : "Play (Space)"
            }, [
              createBaseVNode("span", _hoisted_14, toDisplayString(isPlaying.value ? "" : ""), 1)
            ], 8, _hoisted_13),
            createBaseVNode("button", {
              onClick: stepForward,
              title: "Step Forward"
            }, [..._cache[66] || (_cache[66] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: goToEnd,
              title: "Go to End (End)"
            }, [..._cache[67] || (_cache[67] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_15, toDisplayString(formattedTimecode.value), 1),
          _cache[78] || (_cache[78] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_16, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => activeWorkspace.value = $event),
              class: "workspace-selector"
            }, [..._cache[68] || (_cache[68] = [
              createBaseVNode("option", { value: "standard" }, "Standard", -1),
              createBaseVNode("option", { value: "animation" }, "Animation", -1),
              createBaseVNode("option", { value: "effects" }, "Effects", -1),
              createBaseVNode("option", { value: "minimal" }, "Minimal", -1)
            ])], 512), [
              [vModelSelect, activeWorkspace.value]
            ])
          ]),
          createBaseVNode("div", _hoisted_17, [
            createBaseVNode("button", {
              class: normalizeClass(["theme-btn", { active: showThemeSelector.value }]),
              onClick: _cache[9] || (_cache[9] = ($event) => showThemeSelector.value = !showThemeSelector.value),
              title: "Change Theme"
            }, [
              createBaseVNode("span", {
                class: "theme-indicator",
                style: normalizeStyle({ background: themeGradient.value })
              }, null, 4)
            ], 2),
            showThemeSelector.value ? (openBlock(), createElementBlock("div", _hoisted_18, [
              _cache[69] || (_cache[69] = createBaseVNode("div", { class: "theme-dropdown-header" }, "Theme", -1)),
              createBaseVNode("div", _hoisted_19, [
                (openBlock(), createElementBlock(Fragment, null, renderList(themes, (theme) => {
                  return createBaseVNode("button", {
                    key: theme.name,
                    class: normalizeClass(["theme-option", { active: currentTheme.value === theme.name }]),
                    style: normalizeStyle({ background: theme.gradient }),
                    title: theme.label,
                    onClick: ($event) => selectTheme(theme.name)
                  }, null, 14, _hoisted_20);
                }), 64))
              ])
            ])) : createCommentVNode("", true)
          ]),
          _cache[79] || (_cache[79] = createBaseVNode("div", { class: "spacer" }, null, -1)),
          createBaseVNode("div", _hoisted_21, [
            createBaseVNode("span", {
              class: normalizeClass(["gpu-badge", gpuTier.value])
            }, toDisplayString(gpuTier.value.toUpperCase()), 3),
            createVNode(MemoryIndicator),
            createBaseVNode("button", {
              onClick: undo,
              disabled: !canUndo.value,
              title: "Undo (Ctrl+Z)"
            }, [..._cache[70] || (_cache[70] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_22),
            createBaseVNode("button", {
              onClick: redo,
              disabled: !canRedo.value,
              title: "Redo (Ctrl+Shift+Z)"
            }, [..._cache[71] || (_cache[71] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_23),
            _cache[75] || (_cache[75] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("button", {
              onClick: _cache[10] || (_cache[10] = ($event) => showHDPreview.value = true),
              title: "HD Preview (`)"
            }, [..._cache[72] || (_cache[72] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" HD ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[11] || (_cache[11] = ($event) => showExportDialog.value = true),
              title: "Export Matte"
            }, [..._cache[73] || (_cache[73] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Matte ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[12] || (_cache[12] = ($event) => showComfyUIExportDialog.value = true),
              title: "Export to ComfyUI"
            }, [..._cache[74] || (_cache[74] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" ComfyUI ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_24, [
          createVNode(unref(Pe), { class: "default-theme horizontal-split" }, {
            default: withCtx(() => [
              createVNode(unref(ge), {
                size: 14,
                "min-size": 10,
                "max-size": 25
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_25, [
                    createBaseVNode("div", _hoisted_26, [
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "project",
                        "aria-controls": "left-panel-project",
                        class: normalizeClass({ active: leftTab.value === "project" }),
                        onClick: _cache[13] || (_cache[13] = ($event) => leftTab.value = "project")
                      }, " Project ", 10, _hoisted_27),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "effects",
                        "aria-controls": "left-panel-effects",
                        class: normalizeClass({ active: leftTab.value === "effects" }),
                        onClick: _cache[14] || (_cache[14] = ($event) => leftTab.value = "effects")
                      }, " Effects ", 10, _hoisted_28),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "assets",
                        "aria-controls": "left-panel-assets",
                        class: normalizeClass({ active: leftTab.value === "assets" }),
                        onClick: _cache[15] || (_cache[15] = ($event) => leftTab.value = "assets")
                      }, " Assets ", 10, _hoisted_29)
                    ]),
                    createBaseVNode("div", {
                      class: "panel-content",
                      role: "tabpanel",
                      id: `left-panel-${leftTab.value}`
                    }, [
                      leftTab.value === "project" ? (openBlock(), createBlock(ProjectPanel, {
                        key: 0,
                        onOpenCompositionSettings: _cache[16] || (_cache[16] = ($event) => showCompositionSettingsDialog.value = true)
                      })) : leftTab.value === "effects" ? (openBlock(), createBlock(EffectsPanel, { key: 1 })) : leftTab.value === "assets" ? (openBlock(), createBlock(AssetsPanel, {
                        key: 2,
                        onCreateLayersFromSvg,
                        onUseMeshAsEmitter,
                        onEnvironmentUpdate,
                        onEnvironmentLoad,
                        onEnvironmentClear
                      })) : createCommentVNode("", true)
                    ], 8, _hoisted_30)
                  ])
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 62,
                "min-size": 35
              }, {
                default: withCtx(() => [
                  createVNode(unref(Pe), {
                    horizontal: "",
                    class: "default-theme"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ge), {
                        size: 65,
                        "min-size": 20
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_31, [
                            createBaseVNode("div", _hoisted_32, [
                              createBaseVNode("div", _hoisted_33, [
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "composition",
                                  class: normalizeClass({ active: viewportTab.value === "composition" }),
                                  onClick: _cache[17] || (_cache[17] = ($event) => viewportTab.value = "composition")
                                }, " Composition ", 10, _hoisted_34),
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "layer",
                                  class: normalizeClass({ active: viewportTab.value === "layer" }),
                                  onClick: _cache[18] || (_cache[18] = ($event) => viewportTab.value = "layer")
                                }, " Layer ", 10, _hoisted_35),
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "footage",
                                  class: normalizeClass({ active: viewportTab.value === "footage" }),
                                  onClick: _cache[19] || (_cache[19] = ($event) => viewportTab.value = "footage")
                                }, " Footage ", 10, _hoisted_36)
                              ]),
                              createBaseVNode("div", _hoisted_37, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => viewZoom.value = $event),
                                  onChange: handleZoomChange,
                                  class: "zoom-select",
                                  "aria-label": "Zoom level"
                                }, [..._cache[80] || (_cache[80] = [
                                  createBaseVNode("option", { value: "fit" }, "Fit", -1),
                                  createBaseVNode("option", { value: "25" }, "25%", -1),
                                  createBaseVNode("option", { value: "50" }, "50%", -1),
                                  createBaseVNode("option", { value: "75" }, "75%", -1),
                                  createBaseVNode("option", { value: "100" }, "100%", -1),
                                  createBaseVNode("option", { value: "150" }, "150%", -1),
                                  createBaseVNode("option", { value: "200" }, "200%", -1)
                                ])], 544), [
                                  [vModelSelect, viewZoom.value]
                                ]),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showRulers }),
                                  onClick: _cache[21] || (_cache[21] = ($event) => viewOptions.value.showRulers = !viewOptions.value.showRulers),
                                  title: "Toggle Rulers/Guides",
                                  "aria-label": "Toggle rulers and guides",
                                  "aria-pressed": viewOptions.value.showRulers
                                }, [..._cache[81] || (_cache[81] = [
                                  createBaseVNode("span", {
                                    class: "icon",
                                    "aria-hidden": "true"
                                  }, "", -1)
                                ])], 10, _hoisted_38),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showGrid }),
                                  onClick: _cache[22] || (_cache[22] = ($event) => viewOptions.value.showGrid = !viewOptions.value.showGrid),
                                  title: "Toggle Grid",
                                  "aria-label": "Toggle grid",
                                  "aria-pressed": viewOptions.value.showGrid
                                }, [..._cache[82] || (_cache[82] = [
                                  createBaseVNode("span", { class: "icon" }, "", -1)
                                ])], 10, _hoisted_39)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_40, [
                              viewOptions.value.showGrid ? (openBlock(), createElementBlock("div", {
                                key: 0,
                                class: "grid-overlay",
                                style: normalizeStyle(gridOverlayStyle.value)
                              }, null, 4)) : createCommentVNode("", true),
                              guides.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_41, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(guides.value, (guide) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: guide.id,
                                    class: normalizeClass(["guide", guide.orientation]),
                                    style: normalizeStyle(getGuideStyle(guide)),
                                    onMousedown: ($event) => startGuideDrag(guide, $event)
                                  }, null, 46, _hoisted_42);
                                }), 128))
                              ])) : createCommentVNode("", true),
                              viewOptions.value.showRulers ? (openBlock(), createElementBlock("div", _hoisted_43, [
                                createBaseVNode("div", {
                                  class: "ruler ruler-horizontal",
                                  onMousedown: _cache[23] || (_cache[23] = ($event) => createGuideFromRuler("horizontal", $event))
                                }, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "h" + i,
                                      class: "tick",
                                      style: normalizeStyle({ left: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compWidth.value)), 5);
                                  }), 64))
                                ], 32),
                                createBaseVNode("div", {
                                  class: "ruler ruler-vertical",
                                  onMousedown: _cache[24] || (_cache[24] = ($event) => createGuideFromRuler("vertical", $event))
                                }, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "v" + i,
                                      class: "tick",
                                      style: normalizeStyle({ top: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compHeight.value)), 5);
                                  }), 64))
                                ], 32)
                              ])) : createCommentVNode("", true),
                              snapEnabled.value && (snapIndicatorX.value || snapIndicatorY.value) ? (openBlock(), createElementBlock("div", _hoisted_44, [
                                snapIndicatorX.value ? (openBlock(), createElementBlock("div", {
                                  key: 0,
                                  class: "snap-line vertical",
                                  style: normalizeStyle({ left: snapIndicatorX.value + "px" })
                                }, null, 4)) : createCommentVNode("", true),
                                snapIndicatorY.value ? (openBlock(), createElementBlock("div", {
                                  key: 1,
                                  class: "snap-line horizontal",
                                  style: normalizeStyle({ top: snapIndicatorY.value + "px" })
                                }, null, 4)) : createCommentVNode("", true)
                              ])) : createCommentVNode("", true),
                              viewportTab.value === "composition" ? (openBlock(), createBlock(ThreeCanvas, {
                                key: 4,
                                ref_key: "threeCanvasRef",
                                ref: threeCanvasRef
                              }, null, 512)) : (openBlock(), createBlock(ViewportRenderer, {
                                key: 5,
                                camera: activeCamera.value,
                                viewportState: viewportState.value,
                                viewOptions: viewOptions.value,
                                compWidth: compWidth.value,
                                compHeight: compHeight.value
                              }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                            ])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ge), {
                        size: 35,
                        "min-size": 15
                      }, {
                        default: withCtx(() => [
                          showCurveEditor.value ? (openBlock(), createBlock(unref(Pe), {
                            key: 0,
                            horizontal: "",
                            class: "default-theme"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_45, [
                                    createVNode(TimelinePanel, {
                                      onOpenCompositionSettings: _cache[25] || (_cache[25] = ($event) => showCompositionSettingsDialog.value = true),
                                      onOpenPathSuggestion: _cache[26] || (_cache[26] = ($event) => showPathSuggestionDialog.value = true)
                                    })
                                  ])
                                ]),
                                _: 1
                              }),
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_46, [
                                    createVNode(CurveEditor, {
                                      onClose: _cache[27] || (_cache[27] = ($event) => showCurveEditor.value = false)
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })) : (openBlock(), createElementBlock("div", _hoisted_47, [
                            createVNode(TimelinePanel, {
                              onOpenCompositionSettings: _cache[28] || (_cache[28] = ($event) => showCompositionSettingsDialog.value = true),
                              onOpenPathSuggestion: _cache[29] || (_cache[29] = ($event) => showPathSuggestionDialog.value = true)
                            })
                          ]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 24,
                "min-size": 15,
                "max-size": 35
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_48, [
                    createBaseVNode("div", _hoisted_49, [
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "properties",
                        "aria-controls": "right-panel-properties",
                        class: normalizeClass({ active: rightTab.value === "properties" }),
                        onClick: _cache[30] || (_cache[30] = ($event) => rightTab.value = "properties")
                      }, " Properties ", 10, _hoisted_50),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "effects",
                        "aria-controls": "right-panel-effects",
                        class: normalizeClass({ active: rightTab.value === "effects" }),
                        onClick: _cache[31] || (_cache[31] = ($event) => rightTab.value = "effects")
                      }, " Effects ", 10, _hoisted_51),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "camera",
                        "aria-controls": "right-panel-camera",
                        class: normalizeClass({ active: rightTab.value === "camera" }),
                        onClick: _cache[32] || (_cache[32] = ($event) => rightTab.value = "camera")
                      }, " Cam ", 10, _hoisted_52),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "audio",
                        "aria-controls": "right-panel-audio",
                        class: normalizeClass({ active: rightTab.value === "audio" }),
                        onClick: _cache[33] || (_cache[33] = ($event) => rightTab.value = "audio")
                      }, " Audio ", 10, _hoisted_53),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "export",
                        "aria-controls": "right-panel-export",
                        class: normalizeClass({ active: rightTab.value === "export" }),
                        onClick: _cache[34] || (_cache[34] = ($event) => rightTab.value = "export")
                      }, " Export ", 10, _hoisted_54),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "preview",
                        "aria-controls": "right-panel-preview",
                        class: normalizeClass({ active: rightTab.value === "preview" }),
                        onClick: _cache[35] || (_cache[35] = ($event) => rightTab.value = "preview")
                      }, " Preview ", 10, _hoisted_55),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "ai",
                        "aria-controls": "right-panel-ai",
                        class: normalizeClass({ active: rightTab.value === "ai" }),
                        onClick: _cache[36] || (_cache[36] = ($event) => rightTab.value = "ai"),
                        title: "AI Compositor Agent"
                      }, " AI ", 10, _hoisted_56),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "generate",
                        "aria-controls": "right-panel-generate",
                        class: normalizeClass({ active: rightTab.value === "generate" }),
                        onClick: _cache[37] || (_cache[37] = ($event) => rightTab.value = "generate"),
                        title: "AI Generation (Depth, Normal, Segment)"
                      }, " Gen ", 10, _hoisted_57),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "align",
                        "aria-controls": "right-panel-align",
                        class: normalizeClass({ active: rightTab.value === "align" }),
                        onClick: _cache[38] || (_cache[38] = ($event) => rightTab.value = "align"),
                        title: "Align and Distribute Layers"
                      }, " Align ", 10, _hoisted_58)
                    ]),
                    createBaseVNode("div", {
                      class: "panel-content",
                      role: "tabpanel",
                      id: `right-panel-${rightTab.value}`
                    }, [
                      rightTab.value === "effects" ? (openBlock(), createBlock(EffectControlsPanel, { key: 0 })) : rightTab.value === "properties" ? (openBlock(), createBlock(PropertiesPanel, { key: 1 })) : rightTab.value === "camera" ? (openBlock(), createBlock(CameraProperties, {
                        key: 2,
                        camera: activeCamera.value,
                        "onUpdate:camera": updateCamera
                      }, null, 8, ["camera"])) : rightTab.value === "audio" ? (openBlock(), createBlock(AudioPanel, { key: 3 })) : rightTab.value === "export" ? (openBlock(), createBlock(ExportPanel, { key: 4 })) : rightTab.value === "preview" ? (openBlock(), createBlock(PreviewPanel, {
                        key: 5,
                        engine: canvasEngine.value
                      }, null, 8, ["engine"])) : rightTab.value === "ai" ? (openBlock(), createBlock(AIChatPanel, { key: 6 })) : rightTab.value === "generate" ? (openBlock(), createBlock(AIGeneratePanel, { key: 7 })) : rightTab.value === "align" ? (openBlock(), createBlock(AlignPanel, { key: 8 })) : createCommentVNode("", true)
                    ], 8, _hoisted_59)
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        showExportDialog.value ? (openBlock(), createBlock(ExportDialog, {
          key: 0,
          onClose: _cache[39] || (_cache[39] = ($event) => showExportDialog.value = false),
          onExported: onExportComplete
        })) : createCommentVNode("", true),
        showComfyUIExportDialog.value ? (openBlock(), createBlock(ComfyUIExportDialog, {
          key: 1,
          layers: unref(store).layers,
          "camera-keyframes": activeCameraKeyframes.value,
          "current-frame": unref(store).currentFrame,
          "total-frames": unref(store).frameCount,
          onClose: _cache[40] || (_cache[40] = ($event) => showComfyUIExportDialog.value = false),
          onExported: onComfyUIExportComplete
        }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : createCommentVNode("", true),
        createVNode(CompositionSettingsDialog, {
          visible: showCompositionSettingsDialog.value,
          onClose: _cache[41] || (_cache[41] = ($event) => showCompositionSettingsDialog.value = false),
          onConfirm: onCompositionSettingsConfirm
        }, null, 8, ["visible"]),
        createVNode(PrecomposeDialog, {
          visible: showPrecomposeDialog.value,
          "layer-count": unref(store).selectedLayerIds.length,
          onClose: _cache[42] || (_cache[42] = ($event) => showPrecomposeDialog.value = false),
          onConfirm: onPrecomposeConfirm
        }, null, 8, ["visible", "layer-count"]),
        createVNode(KeyframeInterpolationDialog, {
          visible: showKeyframeInterpolationDialog.value,
          "keyframe-count": unref(store).selectedKeyframeIds.length,
          onClose: _cache[43] || (_cache[43] = ($event) => showKeyframeInterpolationDialog.value = false),
          onConfirm: onKeyframeInterpolationConfirm
        }, null, 8, ["visible", "keyframe-count"]),
        createVNode(TimeStretchDialog, {
          visible: showTimeStretchDialog.value,
          "layer-id": unref(store).selectedLayerIds[0] ?? "",
          onClose: _cache[44] || (_cache[44] = ($event) => showTimeStretchDialog.value = false),
          onApplied: _cache[45] || (_cache[45] = ($event) => showTimeStretchDialog.value = false)
        }, null, 8, ["visible", "layer-id"]),
        createVNode(PathSuggestionDialog, {
          visible: showPathSuggestionDialog.value,
          onClose: onPathSuggestionClose,
          onAccept: onPathSuggestionAccept,
          onPreview: onPathSuggestionPreview
        }, null, 8, ["visible"]),
        createVNode(HDPreviewWindow, {
          visible: showHDPreview.value,
          engine: canvasEngine.value,
          onClose: _cache[46] || (_cache[46] = ($event) => showHDPreview.value = false)
        }, null, 8, ["visible", "engine"]),
        createVNode(ExpressionInput, {
          visible: unref(expressionEditor).isVisible.value,
          "current-expression": unref(expressionEditor).currentProperty.value?.expression,
          onClose: _cache[47] || (_cache[47] = ($event) => unref(expressionEditor).closeExpressionEditor()),
          onApply: _cache[48] || (_cache[48] = ($event) => unref(expressionEditor).applyExpression($event)),
          onRemove: _cache[49] || (_cache[49] = ($event) => unref(expressionEditor).removeExpression())
        }, null, 8, ["visible", "current-expression"]),
        pathSuggestions.value.length > 0 ? (openBlock(), createBlock(Teleport, {
          key: 2,
          to: ".viewport-content"
        }, [
          createVNode(PathPreviewOverlay, {
            width: compWidth.value,
            height: compHeight.value,
            suggestions: pathSuggestions.value,
            selectedIndex: selectedPathIndex.value,
            onSelect: _cache[50] || (_cache[50] = ($event) => selectedPathIndex.value = $event)
          }, null, 8, ["width", "height", "suggestions", "selectedIndex"])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const WorkspaceLayout = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-9e849ada"]]);

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const themeStore = useThemeStore();
    onMounted(() => {
      themeStore.loadSavedTheme();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WorkspaceLayout);
    };
  }
});

const BLUR_COMPUTE_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: BlurParams;

struct BlurParams {
  radius: f32,
  direction: f32, // 0 = horizontal, 1 = vertical
  width: f32,
  height: f32,
}

fn gaussian(x: f32, sigma: f32) -> f32 {
  return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma);
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let radius = i32(params.radius);
  let sigma = params.radius / 3.0;
  var color = vec4<f32>(0.0);
  var totalWeight = 0.0;

  // Separable blur: horizontal or vertical pass
  let isHorizontal = params.direction < 0.5;

  for (var i = -radius; i <= radius; i++) {
    var sampleCoords: vec2<i32>;
    if (isHorizontal) {
      sampleCoords = vec2<i32>(clamp(coords.x + i, 0, dims.x - 1), coords.y);
    } else {
      sampleCoords = vec2<i32>(coords.x, clamp(coords.y + i, 0, dims.y - 1));
    }

    let weight = gaussian(f32(i), sigma);
    color += textureLoad(inputTexture, sampleCoords, 0) * weight;
    totalWeight += weight;
  }

  color /= totalWeight;
  textureStore(outputTexture, coords, color);
}
`
);
const COLOR_CORRECTION_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: ColorParams;

struct ColorParams {
  brightness: f32,
  contrast: f32,
  saturation: f32,
  hue: f32,
}

fn rgb_to_hsv(c: vec3<f32>) -> vec3<f32> {
  let K = vec4<f32>(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  let p = mix(vec4<f32>(c.bg, K.wz), vec4<f32>(c.gb, K.xy), step(c.b, c.g));
  let q = mix(vec4<f32>(p.xyw, c.r), vec4<f32>(c.r, p.yzx), step(p.x, c.r));
  let d = q.x - min(q.w, q.y);
  let e = 1.0e-10;
  return vec3<f32>(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

fn hsv_to_rgb(c: vec3<f32>) -> vec3<f32> {
  let K = vec4<f32>(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  let p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, vec3<f32>(0.0), vec3<f32>(1.0)), c.y);
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  var color = textureLoad(inputTexture, coords, 0);

  // Brightness
  color.rgb += params.brightness;

  // Contrast
  color.rgb = (color.rgb - 0.5) * (1.0 + params.contrast) + 0.5;

  // Saturation and Hue
  var hsv = rgb_to_hsv(color.rgb);
  hsv.x = fract(hsv.x + params.hue / 360.0);
  hsv.y = clamp(hsv.y * (1.0 + params.saturation), 0.0, 1.0);
  color.rgb = hsv_to_rgb(hsv);

  // Clamp final color
  color = clamp(color, vec4<f32>(0.0), vec4<f32>(1.0));

  textureStore(outputTexture, coords, color);
}
`
);
const RADIAL_BLUR_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: RadialBlurParams;

struct RadialBlurParams {
  centerX: f32,
  centerY: f32,
  amount: f32,
  samples: u32,
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let center = vec2<f32>(params.centerX * f32(dims.x), params.centerY * f32(dims.y));
  let pos = vec2<f32>(f32(coords.x), f32(coords.y));
  let dir = pos - center;
  let dist = length(dir);

  var color = vec4<f32>(0.0);
  let numSamples = params.samples;

  for (var i = 0u; i < numSamples; i++) {
    let t = f32(i) / f32(numSamples - 1u) - 0.5;
    let offset = dir * t * params.amount * 0.01;
    let samplePos = vec2<i32>(clamp(pos + offset, vec2<f32>(0.0), vec2<f32>(f32(dims.x - 1), f32(dims.y - 1))));
    color += textureLoad(inputTexture, samplePos, 0);
  }

  color /= f32(numSamples);
  textureStore(outputTexture, coords, color);
}
`
);
const DIRECTIONAL_BLUR_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: DirectionalBlurParams;

struct DirectionalBlurParams {
  angle: f32,
  length: f32,
  samples: u32,
  _pad: u32,
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let angleRad = params.angle * 3.14159265 / 180.0;
  let dir = vec2<f32>(cos(angleRad), sin(angleRad)) * params.length;

  var color = vec4<f32>(0.0);
  let numSamples = params.samples;

  for (var i = 0u; i < numSamples; i++) {
    let t = f32(i) / f32(numSamples - 1u) - 0.5;
    let offset = dir * t;
    let samplePos = vec2<i32>(clamp(
      vec2<f32>(f32(coords.x), f32(coords.y)) + offset,
      vec2<f32>(0.0),
      vec2<f32>(f32(dims.x - 1), f32(dims.y - 1))
    ));
    color += textureLoad(inputTexture, samplePos, 0);
  }

  color /= f32(numSamples);
  textureStore(outputTexture, coords, color);
}
`
);
const DISPLACEMENT_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var displacementMap: texture_2d<f32>;
@group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(3) var<uniform> params: DisplacementParams;

struct DisplacementParams {
  maxHorizontal: f32,
  maxVertical: f32,
  hChannel: u32,  // 0=red, 1=green, 2=blue, 3=alpha, 4=luminance
  vChannel: u32,
}

fn getChannelValue(color: vec4<f32>, channel: u32) -> f32 {
  switch channel {
    case 0u: { return color.r; }
    case 1u: { return color.g; }
    case 2u: { return color.b; }
    case 3u: { return color.a; }
    default: { return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b; }
  }
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let mapColor = textureLoad(displacementMap, coords, 0);

  let hValue = getChannelValue(mapColor, params.hChannel);
  let vValue = getChannelValue(mapColor, params.vChannel);

  // Map 0-1 to -1 to 1, then scale by max displacement
  let dx = (hValue - 0.5) * 2.0 * params.maxHorizontal;
  let dy = (vValue - 0.5) * 2.0 * params.maxVertical;

  let srcPos = vec2<i32>(clamp(
    vec2<f32>(f32(coords.x) - dx, f32(coords.y) - dy),
    vec2<f32>(0.0),
    vec2<f32>(f32(dims.x - 1), f32(dims.y - 1))
  ));

  let color = textureLoad(inputTexture, srcPos, 0);
  textureStore(outputTexture, coords, color);
}
`
);
const WARP_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: WarpParams;

struct WarpParams {
  warpStyle: u32,  // 0=bulge, 1=wave, 2=fisheye, 3=twist
  bend: f32,
  hDistort: f32,
  vDistort: f32,
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let centerX = f32(dims.x) / 2.0;
  let centerY = f32(dims.y) / 2.0;

  // Normalize to -1 to 1
  let nx = (f32(coords.x) - centerX) / centerX;
  let ny = (f32(coords.y) - centerY) / centerY;

  var srcX = f32(coords.x);
  var srcY = f32(coords.y);

  switch params.warpStyle {
    case 0u: { // Bulge
      let r = sqrt(nx * nx + ny * ny);
      if (r < 1.0) {
        let factor = 1.0 + params.bend * (1.0 - r * r);
        srcX = centerX + (f32(coords.x) - centerX) / factor;
        srcY = centerY + (f32(coords.y) - centerY) / factor;
      }
    }
    case 1u: { // Wave
      srcX = f32(coords.x) + sin(ny * 3.14159265 * 2.0) * params.bend * f32(dims.x) * 0.1;
      srcY = f32(coords.y) + sin(nx * 3.14159265 * 2.0) * params.bend * f32(dims.y) * 0.1;
    }
    case 2u: { // Fisheye
      let r = sqrt(nx * nx + ny * ny);
      if (r > 0.0 && r < 1.0) {
        let theta = atan2(ny, nx);
        let newR = pow(r, 1.0 + params.bend);
        srcX = centerX + newR * cos(theta) * centerX;
        srcY = centerY + newR * sin(theta) * centerY;
      }
    }
    case 3u: { // Twist
      let r = sqrt(nx * nx + ny * ny);
      let angle = params.bend * 3.14159265 * (1.0 - r);
      let cosA = cos(angle);
      let sinA = sin(angle);
      srcX = centerX + (nx * cosA - ny * sinA) * centerX;
      srcY = centerY + (nx * sinA + ny * cosA) * centerY;
    }
    default: {}
  }

  // Apply additional distortion
  srcX += params.hDistort * centerX * (1.0 - ny * ny);
  srcY += params.vDistort * centerY * (1.0 - nx * nx);

  let srcPos = vec2<i32>(clamp(
    vec2<f32>(srcX, srcY),
    vec2<f32>(0.0),
    vec2<f32>(f32(dims.x - 1), f32(dims.y - 1))
  ));

  let color = textureLoad(inputTexture, srcPos, 0);
  textureStore(outputTexture, coords, color);
}
`
);
const GLOW_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: GlowParams;

struct GlowParams {
  radius: f32,
  intensity: f32,
  threshold: f32,
  _pad: f32,
  glowColor: vec4<f32>,
}

fn gaussian(x: f32, sigma: f32) -> f32 {
  return exp(-(x * x) / (2.0 * sigma * sigma));
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  let originalColor = textureLoad(inputTexture, coords, 0);

  // Sample and blur bright areas
  let radius = i32(params.radius);
  let sigma = params.radius / 3.0;
  var glowAccum = vec4<f32>(0.0);
  var totalWeight = 0.0;

  for (var dy = -radius; dy <= radius; dy++) {
    for (var dx = -radius; dx <= radius; dx++) {
      let sampleCoords = vec2<i32>(
        clamp(coords.x + dx, 0, dims.x - 1),
        clamp(coords.y + dy, 0, dims.y - 1)
      );

      let sampleColor = textureLoad(inputTexture, sampleCoords, 0);
      let luminance = 0.299 * sampleColor.r + 0.587 * sampleColor.g + 0.114 * sampleColor.b;

      if (luminance > params.threshold) {
        let dist = sqrt(f32(dx * dx + dy * dy));
        let weight = gaussian(dist, sigma);
        glowAccum += sampleColor * weight;
        totalWeight += weight;
      }
    }
  }

  var glowColor = vec4<f32>(0.0);
  if (totalWeight > 0.0) {
    glowColor = glowAccum / totalWeight;
    // Tint with glow color if not white
    if (params.glowColor.r < 1.0 || params.glowColor.g < 1.0 || params.glowColor.b < 1.0) {
      glowColor.rgb *= params.glowColor.rgb;
    }
  }

  // Composite: original + glow * intensity
  var finalColor = originalColor + glowColor * params.intensity;
  finalColor = clamp(finalColor, vec4<f32>(0.0), vec4<f32>(1.0));
  finalColor.a = originalColor.a;

  textureStore(outputTexture, coords, finalColor);
}
`
);
const LEVELS_SHADER = (
  /* wgsl */
  `
@group(0) @binding(0) var inputTexture: texture_2d<f32>;
@group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(2) var<uniform> params: LevelsParams;

struct LevelsParams {
  inputBlack: f32,
  inputWhite: f32,
  gamma: f32,
  outputBlack: f32,
  outputWhite: f32,
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

@compute @workgroup_size(16, 16)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let coords = vec2<i32>(global_id.xy);
  let dims = vec2<i32>(textureDimensions(inputTexture));

  if (coords.x >= dims.x || coords.y >= dims.y) {
    return;
  }

  var color = textureLoad(inputTexture, coords, 0);

  // Input levels
  let inputRange = max(params.inputWhite - params.inputBlack, 0.001);
  color.r = clamp((color.r - params.inputBlack) / inputRange, 0.0, 1.0);
  color.g = clamp((color.g - params.inputBlack) / inputRange, 0.0, 1.0);
  color.b = clamp((color.b - params.inputBlack) / inputRange, 0.0, 1.0);

  // Gamma
  color.r = pow(color.r, 1.0 / params.gamma);
  color.g = pow(color.g, 1.0 / params.gamma);
  color.b = pow(color.b, 1.0 / params.gamma);

  // Output levels
  let outputRange = params.outputWhite - params.outputBlack;
  color.r = params.outputBlack + color.r * outputRange;
  color.g = params.outputBlack + color.g * outputRange;
  color.b = params.outputBlack + color.b * outputRange;

  textureStore(outputTexture, coords, color);
}
`
);
class WebGPURenderer {
  capabilities = {
    available: false,
    adapter: null,
    device: null,
    features: [],
    limits: {}
  };
  initialized = false;
  initPromise = null;
  // Shader modules
  blurModule = null;
  colorModule = null;
  radialBlurModule = null;
  directionalBlurModule = null;
  displacementModule = null;
  warpModule = null;
  glowModule = null;
  levelsModule = null;
  // Pipelines
  blurPipeline = null;
  colorPipeline = null;
  radialBlurPipeline = null;
  directionalBlurPipeline = null;
  displacementPipeline = null;
  warpPipeline = null;
  glowPipeline = null;
  levelsPipeline = null;
  // Bind group layouts
  blurBindGroupLayout = null;
  colorBindGroupLayout = null;
  radialBlurBindGroupLayout = null;
  directionalBlurBindGroupLayout = null;
  displacementBindGroupLayout = null;
  warpBindGroupLayout = null;
  glowBindGroupLayout = null;
  levelsBindGroupLayout = null;
  /**
   * Initialize WebGPU renderer
   * Returns true if WebGPU is available and initialized
   */
  async initialize() {
    if (this.initialized) return this.capabilities.available;
    if (this.initPromise) return this.initPromise;
    this.initPromise = this.doInitialize();
    return this.initPromise;
  }
  async doInitialize() {
    try {
      if (!("gpu" in navigator)) {
        engineLogger.info("WebGPU not available - using Canvas2D fallback");
        this.initialized = true;
        return false;
      }
      const adapter = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (!adapter) {
        engineLogger.warn("WebGPU adapter not available");
        this.initialized = true;
        return false;
      }
      const device = await adapter.requestDevice({
        requiredFeatures: [],
        requiredLimits: {}
      });
      this.capabilities = {
        available: true,
        adapter,
        device,
        features: [...adapter.features],
        limits: {
          maxBufferSize: device.limits.maxBufferSize,
          maxComputeWorkgroupSizeX: device.limits.maxComputeWorkgroupSizeX,
          maxComputeWorkgroupSizeY: device.limits.maxComputeWorkgroupSizeY
        }
      };
      await this.createShaderModules();
      await this.createPipelines();
      engineLogger.info("WebGPU initialized successfully", {
        features: this.capabilities.features.slice(0, 5)
      });
      this.initialized = true;
      return true;
    } catch (error) {
      engineLogger.error("WebGPU initialization failed:", error);
      this.initialized = true;
      return false;
    }
  }
  async createShaderModules() {
    if (!this.capabilities.device) return;
    const device = this.capabilities.device;
    this.blurModule = device.createShaderModule({ code: BLUR_COMPUTE_SHADER });
    this.colorModule = device.createShaderModule({ code: COLOR_CORRECTION_SHADER });
    this.radialBlurModule = device.createShaderModule({ code: RADIAL_BLUR_SHADER });
    this.directionalBlurModule = device.createShaderModule({ code: DIRECTIONAL_BLUR_SHADER });
    this.displacementModule = device.createShaderModule({ code: DISPLACEMENT_SHADER });
    this.warpModule = device.createShaderModule({ code: WARP_SHADER });
    this.glowModule = device.createShaderModule({ code: GLOW_SHADER });
    this.levelsModule = device.createShaderModule({ code: LEVELS_SHADER });
  }
  async createPipelines() {
    if (!this.capabilities.device || !this.blurModule || !this.colorModule) return;
    const device = this.capabilities.device;
    const standardLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "float" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: "rgba8unorm", access: "write-only" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }
      ]
    });
    const displacementLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "float" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: "rgba8unorm", access: "write-only" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }
      ]
    });
    this.blurBindGroupLayout = standardLayout;
    this.colorBindGroupLayout = standardLayout;
    this.radialBlurBindGroupLayout = standardLayout;
    this.directionalBlurBindGroupLayout = standardLayout;
    this.warpBindGroupLayout = standardLayout;
    this.glowBindGroupLayout = standardLayout;
    this.levelsBindGroupLayout = standardLayout;
    this.displacementBindGroupLayout = displacementLayout;
    const createPipeline = (module, layout) => device.createComputePipeline({
      layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
      compute: { module, entryPoint: "main" }
    });
    this.blurPipeline = createPipeline(this.blurModule, standardLayout);
    this.colorPipeline = createPipeline(this.colorModule, standardLayout);
    this.radialBlurPipeline = createPipeline(this.radialBlurModule, standardLayout);
    this.directionalBlurPipeline = createPipeline(this.directionalBlurModule, standardLayout);
    this.warpPipeline = createPipeline(this.warpModule, standardLayout);
    this.glowPipeline = createPipeline(this.glowModule, standardLayout);
    this.levelsPipeline = createPipeline(this.levelsModule, standardLayout);
    this.displacementPipeline = createPipeline(this.displacementModule, displacementLayout);
  }
  /**
   * Check if WebGPU is available
   */
  isAvailable() {
    return this.capabilities.available;
  }
  /**
   * Get WebGPU capabilities
   */
  getCapabilities() {
    return { ...this.capabilities };
  }
  /**
   * Apply Gaussian blur using GPU compute shader
   * Falls back to Canvas2D if WebGPU unavailable
   */
  async blur(source, params) {
    if (!this.capabilities.available || !this.capabilities.device) {
      return this.blurCanvas2D(source, params);
    }
    try {
      return await this.blurWebGPU(source, params);
    } catch (error) {
      engineLogger.warn("WebGPU blur failed, falling back to Canvas2D:", error);
      return this.blurCanvas2D(source, params);
    }
  }
  async blurWebGPU(source, params) {
    const device = this.capabilities.device;
    const imageData = this.toImageData(source);
    const { width, height } = imageData;
    const inputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture(
      { texture: inputTexture },
      imageData.data,
      { bytesPerRow: width * 4, rowsPerImage: height },
      { width, height }
    );
    const outputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC
    });
    const paramsBuffer = device.createBuffer({
      size: 16,
      // 4 floats
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set([
      params.radius,
      params.direction === "vertical" ? 1 : 0,
      width,
      height
    ]);
    paramsBuffer.unmap();
    const bindGroup = device.createBindGroup({
      layout: this.blurBindGroupLayout,
      entries: [
        { binding: 0, resource: inputTexture.createView() },
        { binding: 1, resource: outputTexture.createView() },
        { binding: 2, resource: { buffer: paramsBuffer } }
      ]
    });
    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.blurPipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.dispatchWorkgroups(
      Math.ceil(width / 16),
      Math.ceil(height / 16)
    );
    passEncoder.end();
    const outputBuffer = device.createBuffer({
      size: width * height * 4,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    commandEncoder.copyTextureToBuffer(
      { texture: outputTexture },
      { buffer: outputBuffer, bytesPerRow: width * 4 },
      { width, height }
    );
    device.queue.submit([commandEncoder.finish()]);
    await outputBuffer.mapAsync(GPUMapMode.READ);
    const resultData = new Uint8ClampedArray(outputBuffer.getMappedRange().slice(0));
    outputBuffer.unmap();
    inputTexture.destroy();
    outputTexture.destroy();
    paramsBuffer.destroy();
    outputBuffer.destroy();
    return new ImageData(resultData, width, height);
  }
  blurCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    ctx.filter = `blur(${params.radius}px)`;
    ctx.drawImage(canvas, 0, 0);
    return ctx.getImageData(0, 0, imageData.width, imageData.height);
  }
  /**
   * Apply color correction using GPU compute shader
   */
  async colorCorrect(source, params) {
    if (!this.capabilities.available || !this.capabilities.device) {
      return this.colorCorrectCanvas2D(source, params);
    }
    try {
      return await this.colorCorrectWebGPU(source, params);
    } catch (error) {
      engineLogger.warn("WebGPU color correction failed, falling back:", error);
      return this.colorCorrectCanvas2D(source, params);
    }
  }
  async colorCorrectWebGPU(source, params) {
    const device = this.capabilities.device;
    const imageData = this.toImageData(source);
    const { width, height } = imageData;
    const inputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture(
      { texture: inputTexture },
      imageData.data,
      { bytesPerRow: width * 4, rowsPerImage: height },
      { width, height }
    );
    const outputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC
    });
    const paramsBuffer = device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set([
      params.brightness,
      params.contrast,
      params.saturation,
      params.hue
    ]);
    paramsBuffer.unmap();
    const bindGroup = device.createBindGroup({
      layout: this.colorBindGroupLayout,
      entries: [
        { binding: 0, resource: inputTexture.createView() },
        { binding: 1, resource: outputTexture.createView() },
        { binding: 2, resource: { buffer: paramsBuffer } }
      ]
    });
    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.colorPipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.dispatchWorkgroups(
      Math.ceil(width / 16),
      Math.ceil(height / 16)
    );
    passEncoder.end();
    const outputBuffer = device.createBuffer({
      size: width * height * 4,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    commandEncoder.copyTextureToBuffer(
      { texture: outputTexture },
      { buffer: outputBuffer, bytesPerRow: width * 4 },
      { width, height }
    );
    device.queue.submit([commandEncoder.finish()]);
    await outputBuffer.mapAsync(GPUMapMode.READ);
    const resultData = new Uint8ClampedArray(outputBuffer.getMappedRange().slice(0));
    outputBuffer.unmap();
    inputTexture.destroy();
    outputTexture.destroy();
    paramsBuffer.destroy();
    outputBuffer.destroy();
    return new ImageData(resultData, width, height);
  }
  colorCorrectCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      let r = data[i] / 255;
      let g = data[i + 1] / 255;
      let b = data[i + 2] / 255;
      r += params.brightness;
      g += params.brightness;
      b += params.brightness;
      r = (r - 0.5) * (1 + params.contrast) + 0.5;
      g = (g - 0.5) * (1 + params.contrast) + 0.5;
      b = (b - 0.5) * (1 + params.contrast) + 0.5;
      const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      const satMult = 1 + params.saturation;
      r = gray + (r - gray) * satMult;
      g = gray + (g - gray) * satMult;
      b = gray + (b - gray) * satMult;
      data[i] = Math.max(0, Math.min(255, Math.round(r * 255)));
      data[i + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
      data[i + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
    }
    return imageData;
  }
  // ============================================================================
  // NEW GPU-ACCELERATED EFFECTS
  // ============================================================================
  /**
   * Apply radial blur (zoom blur) using GPU compute shader
   */
  async radialBlur(source, params) {
    if (!this.capabilities.available || !this.radialBlurPipeline) {
      return this.radialBlurCanvas2D(source, params);
    }
    return this.runStandardCompute(source, this.radialBlurPipeline, this.radialBlurBindGroupLayout, [
      params.centerX,
      params.centerY,
      params.amount,
      params.samples ?? 32
    ]);
  }
  radialBlurCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    const { width, height, data } = imageData;
    const output = new Uint8ClampedArray(data.length);
    const centerX = params.centerX * width;
    const centerY = params.centerY * height;
    const samples = params.samples ?? 32;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX;
        const dy = y - centerY;
        let r = 0, g = 0, b = 0, a = 0;
        for (let s = 0; s < samples; s++) {
          const t = s / (samples - 1) - 0.5;
          const sx = Math.round(x + dx * t * params.amount * 0.01);
          const sy = Math.round(y + dy * t * params.amount * 0.01);
          const clampX = Math.max(0, Math.min(width - 1, sx));
          const clampY = Math.max(0, Math.min(height - 1, sy));
          const si = (clampY * width + clampX) * 4;
          r += data[si];
          g += data[si + 1];
          b += data[si + 2];
          a += data[si + 3];
        }
        const i = (y * width + x) * 4;
        output[i] = r / samples;
        output[i + 1] = g / samples;
        output[i + 2] = b / samples;
        output[i + 3] = a / samples;
      }
    }
    return new ImageData(output, width, height);
  }
  /**
   * Apply directional (motion) blur using GPU compute shader
   */
  async directionalBlur(source, params) {
    if (!this.capabilities.available || !this.directionalBlurPipeline) {
      return this.directionalBlurCanvas2D(source, params);
    }
    return this.runStandardCompute(source, this.directionalBlurPipeline, this.directionalBlurBindGroupLayout, [
      params.angle,
      params.length,
      params.samples ?? 32,
      0
      // padding
    ]);
  }
  directionalBlurCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    const { width, height, data } = imageData;
    const output = new Uint8ClampedArray(data.length);
    const angleRad = params.angle * Math.PI / 180;
    const dirX = Math.cos(angleRad) * params.length;
    const dirY = Math.sin(angleRad) * params.length;
    const samples = params.samples ?? 32;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let s = 0; s < samples; s++) {
          const t = s / (samples - 1) - 0.5;
          const sx = Math.max(0, Math.min(width - 1, Math.round(x + dirX * t)));
          const sy = Math.max(0, Math.min(height - 1, Math.round(y + dirY * t)));
          const si = (sy * width + sx) * 4;
          r += data[si];
          g += data[si + 1];
          b += data[si + 2];
          a += data[si + 3];
        }
        const i = (y * width + x) * 4;
        output[i] = r / samples;
        output[i + 1] = g / samples;
        output[i + 2] = b / samples;
        output[i + 3] = a / samples;
      }
    }
    return new ImageData(output, width, height);
  }
  /**
   * Apply warp distortion using GPU compute shader
   */
  async warp(source, params) {
    if (!this.capabilities.available || !this.warpPipeline) {
      return this.warpCanvas2D(source, params);
    }
    const styleMap = { bulge: 0, wave: 1, fisheye: 2, twist: 3 };
    return this.runStandardCompute(source, this.warpPipeline, this.warpBindGroupLayout, [
      styleMap[params.style] ?? 0,
      params.bend,
      params.hDistort ?? 0,
      params.vDistort ?? 0
    ]);
  }
  warpCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    return imageData;
  }
  /**
   * Apply glow effect using GPU compute shader
   */
  async glow(source, params) {
    if (!this.capabilities.available || !this.glowPipeline) {
      return this.glowCanvas2D(source, params);
    }
    this.toImageData(source);
    const paramsData = new Float32Array([
      params.radius,
      params.intensity,
      params.threshold ?? 0.5,
      0,
      // padding
      params.color?.r ?? 1,
      params.color?.g ?? 1,
      params.color?.b ?? 1,
      1
      // alpha
    ]);
    return this.runStandardComputeWithParams(source, this.glowPipeline, this.glowBindGroupLayout, paramsData);
  }
  glowCanvas2D(source, params) {
    return this.toImageData(source);
  }
  /**
   * Apply levels adjustment using GPU compute shader
   */
  async levels(source, params) {
    if (!this.capabilities.available || !this.levelsPipeline) {
      return this.levelsCanvas2D(source, params);
    }
    return this.runStandardComputeWithParams(source, this.levelsPipeline, this.levelsBindGroupLayout, new Float32Array([
      params.inputBlack,
      params.inputWhite,
      params.gamma,
      params.outputBlack,
      params.outputWhite,
      0,
      0,
      0
      // padding to 32 bytes
    ]));
  }
  levelsCanvas2D(source, params) {
    const imageData = this.toImageData(source);
    const data = imageData.data;
    const inputRange = Math.max(params.inputWhite - params.inputBlack, 1e-3);
    const outputRange = params.outputWhite - params.outputBlack;
    const invGamma = 1 / params.gamma;
    for (let i = 0; i < data.length; i += 4) {
      for (let c = 0; c < 3; c++) {
        let v = data[i + c] / 255;
        v = Math.max(0, Math.min(1, (v - params.inputBlack) / inputRange));
        v = Math.pow(v, invGamma);
        v = params.outputBlack + v * outputRange;
        data[i + c] = Math.max(0, Math.min(255, Math.round(v * 255)));
      }
    }
    return imageData;
  }
  // ============================================================================
  // HELPER METHODS
  // ============================================================================
  /**
   * Run a standard compute shader with 4 float params
   */
  async runStandardCompute(source, pipeline, layout, params) {
    return this.runStandardComputeWithParams(source, pipeline, layout, new Float32Array(params));
  }
  /**
   * Run a standard compute shader with arbitrary params buffer
   */
  async runStandardComputeWithParams(source, pipeline, layout, paramsData) {
    const device = this.capabilities.device;
    const imageData = this.toImageData(source);
    const { width, height } = imageData;
    const inputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture(
      { texture: inputTexture },
      imageData.data,
      { bytesPerRow: width * 4, rowsPerImage: height },
      { width, height }
    );
    const outputTexture = device.createTexture({
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC
    });
    const bufferSize = Math.max(16, Math.ceil(paramsData.byteLength / 16) * 16);
    const paramsBuffer = device.createBuffer({
      size: bufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set(paramsData);
    paramsBuffer.unmap();
    const bindGroup = device.createBindGroup({
      layout,
      entries: [
        { binding: 0, resource: inputTexture.createView() },
        { binding: 1, resource: outputTexture.createView() },
        { binding: 2, resource: { buffer: paramsBuffer } }
      ]
    });
    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.dispatchWorkgroups(Math.ceil(width / 16), Math.ceil(height / 16));
    passEncoder.end();
    const outputBuffer = device.createBuffer({
      size: width * height * 4,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    commandEncoder.copyTextureToBuffer(
      { texture: outputTexture },
      { buffer: outputBuffer, bytesPerRow: width * 4 },
      { width, height }
    );
    device.queue.submit([commandEncoder.finish()]);
    await outputBuffer.mapAsync(GPUMapMode.READ);
    const resultData = new Uint8ClampedArray(outputBuffer.getMappedRange().slice(0));
    outputBuffer.unmap();
    inputTexture.destroy();
    outputTexture.destroy();
    paramsBuffer.destroy();
    outputBuffer.destroy();
    return new ImageData(resultData, width, height);
  }
  /**
   * Convert source to ImageData
   */
  toImageData(source) {
    if (source instanceof ImageData) {
      return source;
    }
    const ctx = source.getContext("2d");
    return ctx.getImageData(0, 0, source.width, source.height);
  }
  /**
   * Dispose of WebGPU resources
   */
  dispose() {
    if (this.capabilities.device) {
      this.capabilities.device.destroy();
    }
    this.capabilities = {
      available: false,
      adapter: null,
      device: null,
      features: [],
      limits: {}
    };
    this.initialized = false;
    this.initPromise = null;
    this.blurModule = null;
    this.colorModule = null;
    this.radialBlurModule = null;
    this.directionalBlurModule = null;
    this.displacementModule = null;
    this.warpModule = null;
    this.glowModule = null;
    this.levelsModule = null;
    this.blurPipeline = null;
    this.colorPipeline = null;
    this.radialBlurPipeline = null;
    this.directionalBlurPipeline = null;
    this.displacementPipeline = null;
    this.warpPipeline = null;
    this.glowPipeline = null;
    this.levelsPipeline = null;
    this.blurBindGroupLayout = null;
    this.colorBindGroupLayout = null;
    this.radialBlurBindGroupLayout = null;
    this.directionalBlurBindGroupLayout = null;
    this.displacementBindGroupLayout = null;
    this.warpBindGroupLayout = null;
    this.glowBindGroupLayout = null;
    this.levelsBindGroupLayout = null;
    engineLogger.info("WebGPU renderer disposed");
  }
}
const webgpuRenderer = new WebGPURenderer();

class WebGLBlurContext {
  gl = null;
  canvas = null;
  program = null;
  positionBuffer = null;
  texCoordBuffer = null;
  texture = null;
  framebuffer = null;
  pingPongTextures = [];
  _isAvailable = null;
  currentWidth = 0;
  currentHeight = 0;
  /**
   * Vertex shader for fullscreen quad
   */
  vertexShaderSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  /**
   * Fragment shader for separable Gaussian blur
   * Uses 9-tap kernel approximation
   */
  fragmentShaderSource = `
    precision mediump float;
    uniform sampler2D u_image;
    uniform vec2 u_direction;
    uniform vec2 u_resolution;
    uniform float u_radius;
    varying vec2 v_texCoord;

    void main() {
      vec2 texelSize = 1.0 / u_resolution;
      vec4 color = vec4(0.0);
      float total = 0.0;

      // Dynamic kernel based on radius
      int samples = int(min(u_radius * 2.0 + 1.0, 25.0));
      float sigma = max(u_radius / 2.0, 1.0);

      for (int i = -12; i <= 12; i++) {
        if (abs(float(i)) > u_radius) continue;

        float x = float(i);
        float weight = exp(-(x * x) / (2.0 * sigma * sigma));
        vec2 offset = u_direction * texelSize * x;
        color += texture2D(u_image, v_texCoord + offset) * weight;
        total += weight;
      }

      gl_FragColor = color / total;
    }
  `;
  /**
   * Check if WebGL blur is available
   */
  isAvailable() {
    if (this._isAvailable !== null) {
      return this._isAvailable;
    }
    try {
      const testCanvas = document.createElement("canvas");
      testCanvas.width = 1;
      testCanvas.height = 1;
      const gl = testCanvas.getContext("webgl") || testCanvas.getContext("experimental-webgl");
      this._isAvailable = gl !== null;
    } catch {
      this._isAvailable = false;
    }
    return this._isAvailable;
  }
  /**
   * Initialize WebGL context and shaders
   */
  init(width, height) {
    if (!this.isAvailable()) return false;
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
    }
    if (this.currentWidth !== width || this.currentHeight !== height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this.currentWidth = width;
      this.currentHeight = height;
      this.pingPongTextures = [];
    }
    if (!this.gl) {
      this.gl = this.canvas.getContext("webgl", {
        alpha: true,
        premultipliedAlpha: false,
        preserveDrawingBuffer: true
      });
      if (!this.gl) return false;
    }
    const gl = this.gl;
    if (!this.program) {
      const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, this.vertexShaderSource);
      const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, this.fragmentShaderSource);
      if (!vertexShader || !fragmentShader) return false;
      this.program = gl.createProgram();
      gl.attachShader(this.program, vertexShader);
      gl.attachShader(this.program, fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.warn("[WebGLBlur] Program link failed:", gl.getProgramInfoLog(this.program));
        return false;
      }
      this.positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1,
        1
      ]), gl.STATIC_DRAW);
      this.texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1,
        1
      ]), gl.STATIC_DRAW);
    }
    if (this.pingPongTextures.length < 2) {
      for (let i = 0; i < 2; i++) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this.pingPongTextures.push(tex);
      }
      this.framebuffer = gl.createFramebuffer();
    }
    return true;
  }
  /**
   * Compile a shader
   */
  compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.warn("[WebGLBlur] Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  /**
   * Apply Gaussian blur using WebGL
   */
  blur(input, radiusX, radiusY) {
    const { width, height } = input;
    if (!this.init(width, height)) {
      return null;
    }
    const gl = this.gl;
    const program = this.program;
    gl.useProgram(program);
    gl.viewport(0, 0, width, height);
    const positionLoc = gl.getAttribLocation(program, "a_position");
    const texCoordLoc = gl.getAttribLocation(program, "a_texCoord");
    const imageLoc = gl.getUniformLocation(program, "u_image");
    const directionLoc = gl.getUniformLocation(program, "u_direction");
    const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
    const radiusLoc = gl.getUniformLocation(program, "u_radius");
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.enableVertexAttribArray(texCoordLoc);
    gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1i(imageLoc, 0);
    gl.uniform2f(resolutionLoc, width, height);
    if (!this.texture) {
      this.texture = gl.createTexture();
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, input);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    let sourceTexture = this.texture;
    let destIdx = 0;
    if (radiusX > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 1, 0);
      gl.uniform1f(radiusLoc, radiusX);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
      destIdx = 1 - destIdx;
    }
    if (radiusY > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 0, 1);
      gl.uniform1f(radiusLoc, radiusY);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sourceTexture, 0);
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const outputCanvas = document.createElement("canvas");
    outputCanvas.width = width;
    outputCanvas.height = height;
    const ctx = outputCanvas.getContext("2d");
    const imageData = ctx.createImageData(width, height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width * 4;
      const dstRow = y * width * 4;
      for (let x = 0; x < width * 4; x++) {
        imageData.data[dstRow + x] = pixels[srcRow + x];
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return outputCanvas;
  }
  /**
   * Clean up WebGL resources
   */
  dispose() {
    if (this.gl) {
      if (this.program) this.gl.deleteProgram(this.program);
      if (this.texture) this.gl.deleteTexture(this.texture);
      if (this.positionBuffer) this.gl.deleteBuffer(this.positionBuffer);
      if (this.texCoordBuffer) this.gl.deleteBuffer(this.texCoordBuffer);
      if (this.framebuffer) this.gl.deleteFramebuffer(this.framebuffer);
      for (const tex of this.pingPongTextures) {
        this.gl.deleteTexture(tex);
      }
    }
    this.gl = null;
    this.canvas = null;
    this.program = null;
    this._isAvailable = null;
  }
}
const webglBlurContext = new WebGLBlurContext();
const GPU_BLUR_THRESHOLD = 15;
const MUL_TABLE = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
const SHG_TABLE = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function createBlurStack(size) {
  const first = { r: 0, g: 0, b: 0, a: 0, next: null };
  let current = first;
  for (let i = 1; i < size; i++) {
    current.next = { r: 0, g: 0, b: 0, a: 0, next: null };
    current = current.next;
  }
  current.next = first;
  return first;
}
function stackBlur(imageData, radiusX, radiusY) {
  const pixels = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  radiusX = Math.max(0, Math.min(255, Math.round(radiusX)));
  radiusY = Math.max(0, Math.min(255, Math.round(radiusY)));
  if (radiusX === 0 && radiusY === 0) return;
  if (radiusX > 0) {
    stackBlurHorizontal(pixels, width, height, radiusX);
  }
  if (radiusY > 0) {
    stackBlurVertical(pixels, width, height, radiusY);
  }
}
function stackBlurHorizontal(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const widthMinus1 = width - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let y = 0; y < height; y++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    const yOffset = y * width;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[yOffset * 4];
    const pg = pixels[yOffset * 4 + 1];
    const pb = pixels[yOffset * 4 + 2];
    const pa = pixels[yOffset * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, widthMinus1);
      const pOffset = (yOffset + p) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let x = 0; x < width; x++) {
      const pOffset = (yOffset + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(x + radius + 1, widthMinus1);
      const pIn = (yOffset + p) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function stackBlurVertical(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const heightMinus1 = height - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let x = 0; x < width; x++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[x * 4];
    const pg = pixels[x * 4 + 1];
    const pb = pixels[x * 4 + 2];
    const pa = pixels[x * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, heightMinus1);
      const pOffset = (p * width + x) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let y = 0; y < height; y++) {
      const pOffset = (y * width + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(y + radius + 1, heightMinus1);
      const pIn = (p * width + x) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
let webgpuInitialized = false;
let webgpuInitializing = false;
async function ensureWebGPUInitialized() {
  if (webgpuInitialized) return webgpuRenderer.isAvailable();
  if (webgpuInitializing) return false;
  webgpuInitializing = true;
  try {
    await webgpuRenderer.initialize();
    webgpuInitialized = true;
    return webgpuRenderer.isAvailable();
  } catch {
    webgpuInitialized = true;
    return false;
  } finally {
    webgpuInitializing = false;
  }
}
ensureWebGPUInitialized();
function gaussianBlurRenderer(input, params) {
  const blurriness = params.blurriness ?? 10;
  const dimensions = params.blur_dimensions ?? "both";
  const useGpu = params.use_gpu !== false;
  if (blurriness <= 0) {
    return input;
  }
  let radiusX = 0;
  let radiusY = 0;
  switch (dimensions) {
    case "horizontal":
      radiusX = blurriness;
      break;
    case "vertical":
      radiusY = blurriness;
      break;
    case "both":
    default:
      radiusX = blurriness;
      radiusY = blurriness;
      break;
  }
  const maxRadius = Math.max(radiusX, radiusY);
  if (useGpu && maxRadius > GPU_BLUR_THRESHOLD && webgpuInitialized && webgpuRenderer.isAvailable()) ;
  if (useGpu && maxRadius > GPU_BLUR_THRESHOLD && webglBlurContext.isAvailable()) {
    const gpuResult = webglBlurContext.blur(input.canvas, radiusX, radiusY);
    if (gpuResult) {
      const output2 = createMatchingCanvas(input.canvas);
      output2.ctx.drawImage(gpuResult, 0, 0);
      return output2;
    }
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  stackBlur(imageData, radiusX, radiusY);
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function directionalBlurRenderer(input, params) {
  const direction = (params.direction ?? 0) * Math.PI / 180;
  const blurLength = Math.max(0, Math.min(500, params.blur_length ?? 10));
  if (blurLength <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const dx = Math.cos(direction);
  const dy = Math.sin(direction);
  const samples = Math.max(3, Math.ceil(blurLength));
  const halfSamples = Math.floor(samples / 2);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      for (let i = -halfSamples; i <= halfSamples; i++) {
        const sampleX = Math.round(x + dx * i * (blurLength / samples));
        const sampleY = Math.round(y + dy * i * (blurLength / samples));
        const sx = Math.max(0, Math.min(width - 1, sampleX));
        const sy = Math.max(0, Math.min(height - 1, sampleY));
        const idx = (sy * width + sx) * 4;
        r += src[idx];
        g += src[idx + 1];
        b += src[idx + 2];
        a += src[idx + 3];
        count++;
      }
      const outIdx = (y * width + x) * 4;
      dst[outIdx] = Math.round(r / count);
      dst[outIdx + 1] = Math.round(g / count);
      dst[outIdx + 2] = Math.round(b / count);
      dst[outIdx + 3] = Math.round(a / count);
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function radialBlurRenderer(input, params) {
  const type = params.type ?? "spin";
  const amount = Math.max(0, Math.min(100, params.amount ?? 10));
  const center = params.center;
  const centerX = center?.x ?? (params.center_x ?? 50) / 100;
  const centerY = center?.y ?? (params.center_y ?? 50) / 100;
  const antialiasing = params.antialiasing ?? params.quality ?? "high";
  const quality = antialiasing === "low" ? "draft" : antialiasing === "medium" ? "good" : "best";
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const cx = centerX * width;
  const cy = centerY * height;
  const samples = quality === "best" ? 32 : quality === "good" ? 16 : 8;
  if (type === "spin") {
    const maxAngle = amount / 100 * Math.PI * 0.5;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const baseAngle = Math.atan2(dy, dx);
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1) - 0.5;
          const angle = baseAngle + t * maxAngle;
          const sampleX = Math.round(cx + Math.cos(angle) * dist);
          const sampleY = Math.round(cy + Math.sin(angle) * dist);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  } else {
    const maxZoom = amount / 100;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1);
          const scale = 1 - t * maxZoom;
          const sampleX = Math.round(cx + dx * scale);
          const sampleY = Math.round(cy + dy * scale);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function boxBlurRenderer(input, params) {
  const radius = Math.max(0, Math.min(100, Math.round(params.blur_radius ?? params.radius ?? 5)));
  const iterations = Math.max(1, Math.min(5, params.iterations ?? 1));
  if (radius <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  let current = createMatchingCanvas(input.canvas);
  current.ctx.drawImage(input.canvas, 0, 0);
  for (let iter = 0; iter < iterations; iter++) {
    const imageData = current.ctx.getImageData(0, 0, width, height);
    const src = imageData.data;
    const dst = new Uint8ClampedArray(src.length);
    const size = radius * 2 + 1;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dx = -radius; dx <= radius; dx++) {
          const sx = Math.max(0, Math.min(width - 1, x + dx));
          const idx = (y * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    src.set(dst);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dy = -radius; dy <= radius; dy++) {
          const sy = Math.max(0, Math.min(height - 1, y + dy));
          const idx = (sy * width + x) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    imageData.data.set(dst);
    current.ctx.putImageData(imageData, 0, 0);
  }
  return current;
}
function sharpenRenderer(input, params) {
  const amount = (params.sharpen_amount ?? params.amount ?? 50) / 100;
  const radius = Math.max(1, Math.min(100, params.radius ?? 1));
  const threshold = params.threshold ?? 0;
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const blurred = createMatchingCanvas(input.canvas);
  blurred.ctx.drawImage(input.canvas, 0, 0);
  const blurredData = blurred.ctx.getImageData(0, 0, width, height);
  stackBlur(blurredData, radius, radius);
  const output = createMatchingCanvas(input.canvas);
  const originalData = input.ctx.getImageData(0, 0, width, height);
  const orig = originalData.data;
  const blur = blurredData.data;
  for (let i = 0; i < orig.length; i += 4) {
    for (let c = 0; c < 3; c++) {
      const diff = orig[i + c] - blur[i + c];
      if (Math.abs(diff) >= threshold) {
        const sharpened = orig[i + c] + diff * amount;
        orig[i + c] = Math.max(0, Math.min(255, Math.round(sharpened)));
      }
    }
  }
  output.ctx.putImageData(originalData, 0, 0);
  return output;
}
function registerBlurEffects() {
  registerEffectRenderer("gaussian-blur", gaussianBlurRenderer);
  registerEffectRenderer("directional-blur", directionalBlurRenderer);
  registerEffectRenderer("radial-blur", radialBlurRenderer);
  registerEffectRenderer("box-blur", boxBlurRenderer);
  registerEffectRenderer("sharpen", sharpenRenderer);
}

function brightnessContrastRenderer(input, params) {
  const brightness = (params.brightness ?? 0) / 100;
  const contrast = (params.contrast ?? 0) / 100;
  const useLegacy = params.use_legacy ?? false;
  if (brightness === 0 && contrast === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const contrastFactor = useLegacy ? 1 + contrast : 259 * (contrast * 255 + 255) / (255 * (259 - contrast * 255));
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    r += brightness * 255;
    g += brightness * 255;
    b += brightness * 255;
    r = contrastFactor * (r - 128) + 128;
    g = contrastFactor * (g - 128) + 128;
    b = contrastFactor * (b - 128) + 128;
    data[i] = Math.max(0, Math.min(255, r));
    data[i + 1] = Math.max(0, Math.min(255, g));
    data[i + 2] = Math.max(0, Math.min(255, b));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }
  return [h, s, l];
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
function hueSaturationRenderer(input, params) {
  const hueShift = (params.master_hue ?? 0) / 360;
  const saturationShift = (params.master_saturation ?? 0) / 100;
  const lightnessShift = (params.master_lightness ?? 0) / 100;
  const colorize = params.colorize ?? false;
  if (hueShift === 0 && saturationShift === 0 && lightnessShift === 0 && !colorize) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    let [h, s, l] = rgbToHsl(r, g, b);
    if (colorize) {
      h = hueShift;
      s = Math.abs(saturationShift) + 0.25;
    } else {
      h = (h + hueShift) % 1;
      if (h < 0) h += 1;
      s = s + s * saturationShift;
    }
    l = l + l * lightnessShift;
    s = Math.max(0, Math.min(1, s));
    l = Math.max(0, Math.min(1, l));
    const [newR, newG, newB] = hslToRgb(h, s, l);
    data[i] = newR;
    data[i + 1] = newG;
    data[i + 2] = newB;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function levelsRenderer(input, params) {
  const inputBlack = params.input_black ?? 0;
  const inputWhite = params.input_white ?? 255;
  const gamma = params.gamma ?? 1;
  const outputBlack = params.output_black ?? 0;
  const outputWhite = params.output_white ?? 255;
  if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const inputRange = inputWhite - inputBlack;
  const outputRange = outputWhite - outputBlack;
  for (let i = 0; i < 256; i++) {
    let value = (i - inputBlack) / inputRange;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, 1 / gamma);
    value = outputBlack + value * outputRange;
    value = Math.max(0, Math.min(255, value));
    lut[i] = Math.round(value);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function tintRenderer(input, params) {
  const blackColor = params.map_black_to ?? { r: 0, g: 0, b: 0 };
  const whiteColor = params.map_white_to ?? { r: 255, g: 255, b: 255 };
  const amount = (params.amount_to_tint ?? 100) / 100;
  if (amount === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const tintR = blackColor.r + (whiteColor.r - blackColor.r) * lum;
    const tintG = blackColor.g + (whiteColor.g - blackColor.g) * lum;
    const tintB = blackColor.b + (whiteColor.b - blackColor.b) * lum;
    data[i] = Math.round(r + (tintR - r) * amount);
    data[i + 1] = Math.round(g + (tintG - g) * amount);
    data[i + 2] = Math.round(b + (tintB - b) * amount);
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function cubicBezier(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
}
function buildCurveLUT(points) {
  const lut = new Uint8Array(256);
  if (!points || points.length === 0) {
    for (let i = 0; i < 256; i++) {
      lut[i] = i;
    }
    return lut;
  }
  if (points.length === 1) {
    for (let i = 0; i < 256; i++) {
      lut[i] = Math.max(0, Math.min(255, Math.round(points[0].y)));
    }
    return lut;
  }
  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
  if (sortedPoints[0].x > 0) {
    sortedPoints.unshift({ x: 0, y: sortedPoints[0].y });
  }
  if (sortedPoints[sortedPoints.length - 1].x < 255) {
    sortedPoints.push({ x: 255, y: sortedPoints[sortedPoints.length - 1].y });
  }
  for (let i = 0; i < 256; i++) {
    let segmentIndex = 0;
    for (let j = 0; j < sortedPoints.length - 1; j++) {
      if (i >= sortedPoints[j].x && i <= sortedPoints[j + 1].x) {
        segmentIndex = j;
        break;
      }
    }
    const p0 = sortedPoints[segmentIndex];
    const p1 = sortedPoints[segmentIndex + 1];
    const t = (i - p0.x) / (p1.x - p0.x || 1);
    let tangent0 = 0;
    let tangent1 = 0;
    if (segmentIndex > 0) {
      const pPrev = sortedPoints[segmentIndex - 1];
      tangent0 = (p1.y - pPrev.y) / (p1.x - pPrev.x || 1) * (p1.x - p0.x);
    }
    if (segmentIndex < sortedPoints.length - 2) {
      const pNext = sortedPoints[segmentIndex + 2];
      tangent1 = (pNext.y - p0.y) / (pNext.x - p0.x || 1) * (p1.x - p0.x);
    }
    const cp1y = p0.y + tangent0 / 3;
    const cp2y = p1.y - tangent1 / 3;
    const value = cubicBezier(p0.y, cp1y, cp2y, p1.y, t);
    lut[i] = Math.max(0, Math.min(255, Math.round(value)));
  }
  return lut;
}
function curvesRenderer(input, params) {
  const masterCurve = params.master_curve;
  const redCurve = params.red_curve;
  const greenCurve = params.green_curve;
  const blueCurve = params.blue_curve;
  const alphaCurve = params.alpha_curve;
  const blend = (params.blend_with_original ?? 100) / 100;
  const hasCurves = masterCurve || redCurve || greenCurve || blueCurve || alphaCurve;
  if (!hasCurves || blend === 0) {
    return input;
  }
  const masterLUT = buildCurveLUT(masterCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const redLUT = buildCurveLUT(redCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const greenLUT = buildCurveLUT(greenCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const blueLUT = buildCurveLUT(blueCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const alphaLUT = alphaCurve ? buildCurveLUT(alphaCurve) : null;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    const origA = data[i + 3];
    let r = masterLUT[origR];
    let g = masterLUT[origG];
    let b = masterLUT[origB];
    r = redLUT[r];
    g = greenLUT[g];
    b = blueLUT[b];
    const a = alphaLUT ? alphaLUT[origA] : origA;
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
    data[i + 3] = a;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function glowRenderer(input, params, frame) {
  const threshold = params.glow_threshold ?? 128;
  const radius = params.glow_radius ?? 20;
  const rawIntensity = params.glow_intensity ?? 100;
  const intensity = rawIntensity <= 10 ? rawIntensity : rawIntensity / 100;
  const composite = params.composite_original ?? "on-top";
  const operation = params.glow_operation ?? (composite === "on-top" ? "add" : "lighten");
  const glowColors = params.glow_colors ?? "original";
  const colorA = params.color_a ?? { r: 255, g: 255, b: 255};
  const colorB = params.color_b ?? { r: 255, g: 128, b: 0};
  const colorLooping = params.color_looping ?? "none";
  const colorLoopingSpeed = params.color_looping_speed ?? 1;
  const glowDimensions = params.glow_dimensions ?? "both";
  if (intensity === 0 || radius === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  let colorBlend = 0;
  if (colorLooping !== "none" && frame !== void 0) {
    const fps = 16;
    const time = frame / fps;
    const cycle = time * colorLoopingSpeed % 1;
    switch (colorLooping) {
      case "sawtooth_ab":
        colorBlend = cycle;
        break;
      case "sawtooth_ba":
        colorBlend = 1 - cycle;
        break;
      case "triangle":
        colorBlend = cycle < 0.5 ? cycle * 2 : 2 - cycle * 2;
        break;
      default:
        colorBlend = 0;
    }
  }
  const effectiveColor = glowColors === "ab" ? {
    r: colorA.r + (colorB.r - colorA.r) * colorBlend,
    g: colorA.g + (colorB.g - colorA.g) * colorBlend,
    b: colorA.b + (colorB.b - colorA.b) * colorBlend} : null;
  const thresholdCanvas = document.createElement("canvas");
  thresholdCanvas.width = width;
  thresholdCanvas.height = height;
  const thresholdCtx = thresholdCanvas.getContext("2d");
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const thresholdData = thresholdCtx.createImageData(width, height);
  for (let i = 0; i < inputData.data.length; i += 4) {
    const r = inputData.data[i];
    const g = inputData.data[i + 1];
    const b = inputData.data[i + 2];
    const a = inputData.data[i + 3];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    if (lum > threshold) {
      const scale = (lum - threshold) / (255 - threshold) * intensity;
      if (effectiveColor) {
        thresholdData.data[i] = Math.min(255, effectiveColor.r * scale);
        thresholdData.data[i + 1] = Math.min(255, effectiveColor.g * scale);
        thresholdData.data[i + 2] = Math.min(255, effectiveColor.b * scale);
      } else {
        thresholdData.data[i] = Math.min(255, r * scale);
        thresholdData.data[i + 1] = Math.min(255, g * scale);
        thresholdData.data[i + 2] = Math.min(255, b * scale);
      }
      thresholdData.data[i + 3] = a;
    } else {
      thresholdData.data[i] = 0;
      thresholdData.data[i + 1] = 0;
      thresholdData.data[i + 2] = 0;
      thresholdData.data[i + 3] = 0;
    }
  }
  thresholdCtx.putImageData(thresholdData, 0, 0);
  const blurCanvas = document.createElement("canvas");
  blurCanvas.width = width;
  blurCanvas.height = height;
  const blurCtx = blurCanvas.getContext("2d");
  if (glowDimensions === "horizontal") {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = width;
    tempCanvas.height = 1;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(thresholdCanvas, 0, 0, width, 1);
    const blurTemp = document.createElement("canvas");
    blurTemp.width = width;
    blurTemp.height = 1;
    const blurTempCtx = blurTemp.getContext("2d");
    blurTempCtx.filter = `blur(${radius}px)`;
    blurTempCtx.drawImage(tempCanvas, 0, 0);
    blurCtx.drawImage(blurTemp, 0, 0, width, height);
    blurCtx.globalCompositeOperation = "multiply";
    blurCtx.filter = `blur(${radius}px)`;
    blurCtx.drawImage(thresholdCanvas, 0, 0);
    blurCtx.globalCompositeOperation = "source-over";
  } else if (glowDimensions === "vertical") {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = 1;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.drawImage(thresholdCanvas, 0, 0, 1, height);
    const blurTemp = document.createElement("canvas");
    blurTemp.width = 1;
    blurTemp.height = height;
    const blurTempCtx = blurTemp.getContext("2d");
    blurTempCtx.filter = `blur(${radius}px)`;
    blurTempCtx.drawImage(tempCanvas, 0, 0);
    blurCtx.drawImage(blurTemp, 0, 0, width, height);
    blurCtx.globalCompositeOperation = "multiply";
    blurCtx.filter = `blur(${radius}px)`;
    blurCtx.drawImage(thresholdCanvas, 0, 0);
    blurCtx.globalCompositeOperation = "source-over";
  } else {
    blurCtx.filter = `blur(${radius}px)`;
    blurCtx.drawImage(thresholdCanvas, 0, 0);
  }
  if (composite === "none") {
    output.ctx.drawImage(blurCanvas, 0, 0);
  } else if (composite === "behind") {
    output.ctx.drawImage(blurCanvas, 0, 0);
    output.ctx.globalCompositeOperation = "source-over";
    output.ctx.drawImage(input.canvas, 0, 0);
  } else {
    output.ctx.drawImage(input.canvas, 0, 0);
    switch (operation) {
      case "screen":
        output.ctx.globalCompositeOperation = "screen";
        break;
      case "lighten":
        output.ctx.globalCompositeOperation = "lighten";
        break;
      case "add":
      default:
        output.ctx.globalCompositeOperation = "lighter";
        break;
    }
    output.ctx.drawImage(blurCanvas, 0, 0);
  }
  output.ctx.globalCompositeOperation = "source-over";
  return output;
}
function dropShadowRenderer(input, params) {
  const shadowColor = params.shadow_color ?? { r: 0, g: 0, b: 0};
  const opacity = (params.opacity ?? 50) / 100;
  const direction = (params.direction ?? 135) * Math.PI / 180;
  const distance = params.distance ?? 5;
  const softness = params.softness ?? 5;
  const shadowOnly = params.shadow_only ?? false;
  const output = createMatchingCanvas(input.canvas);
  const offsetX = Math.cos(direction) * distance;
  const offsetY = Math.sin(direction) * distance;
  output.ctx.shadowColor = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${opacity})`;
  output.ctx.shadowBlur = softness;
  output.ctx.shadowOffsetX = offsetX;
  output.ctx.shadowOffsetY = offsetY;
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.shadowColor = "transparent";
  output.ctx.shadowBlur = 0;
  output.ctx.shadowOffsetX = 0;
  output.ctx.shadowOffsetY = 0;
  if (!shadowOnly) {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  return output;
}
function colorBalanceRenderer(input, params) {
  const shadowR = (params.shadow_red ?? 0) / 100;
  const shadowG = (params.shadow_green ?? 0) / 100;
  const shadowB = (params.shadow_blue ?? 0) / 100;
  const midtoneR = (params.midtone_red ?? 0) / 100;
  const midtoneG = (params.midtone_green ?? 0) / 100;
  const midtoneB = (params.midtone_blue ?? 0) / 100;
  const highlightR = (params.highlight_red ?? 0) / 100;
  const highlightG = (params.highlight_green ?? 0) / 100;
  const highlightB = (params.highlight_blue ?? 0) / 100;
  const preserveLuminosity = params.preserve_luminosity ?? true;
  if (shadowR === 0 && shadowG === 0 && shadowB === 0 && midtoneR === 0 && midtoneG === 0 && midtoneB === 0 && highlightR === 0 && highlightG === 0 && highlightB === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const shadowWeight = Math.max(0, 1 - lum * 3);
    const highlightWeight = Math.max(0, (lum - 0.67) * 3);
    const midtoneWeight = 1 - shadowWeight - highlightWeight;
    const rAdjust = shadowR * shadowWeight + midtoneR * midtoneWeight + highlightR * highlightWeight;
    const gAdjust = shadowG * shadowWeight + midtoneG * midtoneWeight + highlightG * highlightWeight;
    const bAdjust = shadowB * shadowWeight + midtoneB * midtoneWeight + highlightB * highlightWeight;
    r = r + rAdjust * 255;
    g = g + gAdjust * 255;
    b = b + bAdjust * 255;
    if (preserveLuminosity) {
      const newLum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      if (newLum > 1e-3) {
        const lumRatio = lum / newLum;
        r *= lumRatio;
        g *= lumRatio;
        b *= lumRatio;
      }
    }
    data[i] = Math.max(0, Math.min(255, Math.round(r)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function exposureRenderer(input, params) {
  const exposure = params.exposure ?? 0;
  const offset = params.offset ?? 0;
  const gamma = params.gamma ?? 1;
  if (exposure === 0 && offset === 0 && gamma === 1) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const exposureMultiplier = Math.pow(2, exposure);
  const gammaInv = 1 / gamma;
  for (let i = 0; i < 256; i++) {
    let value = i / 255;
    value *= exposureMultiplier;
    value += offset;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, gammaInv);
    lut[i] = Math.round(value * 255);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function vibranceRenderer(input, params) {
  const vibrance = (params.vibrance ?? 0) / 100;
  const saturation = (params.saturation ?? 0) / 100;
  if (vibrance === 0 && saturation === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i] / 255;
    let g = data[i + 1] / 255;
    let b = data[i + 2] / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const currentSat = max - min;
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const skinProtection = 1 - Math.max(0, Math.min(
      1,
      Math.abs(r - 0.8) * 2 + Math.abs(g - 0.5) * 2 + Math.abs(b - 0.3) * 3
    ));
    const vibranceAmount = vibrance * (1 - currentSat) * (1 - skinProtection * 0.5);
    const satAdjust = 1 + saturation + vibranceAmount;
    r = lum + (r - lum) * satAdjust;
    g = lum + (g - lum) * satAdjust;
    b = lum + (b - lum) * satAdjust;
    data[i] = Math.max(0, Math.min(255, Math.round(r * 255)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function invertRenderer(input, params) {
  const blend = (params.blend ?? 100) / 100;
  const channel = params.channel ?? "rgb";
  if (blend === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    let r = origR;
    let g = origG;
    let b = origB;
    switch (channel) {
      case "rgb":
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
        break;
      case "red":
        r = 255 - r;
        break;
      case "green":
        g = 255 - g;
        break;
      case "blue":
        b = 255 - b;
        break;
      case "hue":
      case "saturation":
      case "lightness": {
        let [h, s, l] = rgbToHsl(r, g, b);
        if (channel === "hue") h = (h + 0.5) % 1;
        else if (channel === "saturation") s = 1 - s;
        else if (channel === "lightness") l = 1 - l;
        [r, g, b] = hslToRgb(h, s, l);
        break;
      }
    }
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function posterizeRenderer(input, params) {
  const levels = Math.max(2, Math.min(256, params.levels ?? 6));
  if (levels === 256) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const step = 255 / (levels - 1);
  for (let i = 0; i < 256; i++) {
    const level = Math.round(i / 255 * (levels - 1));
    lut[i] = Math.round(level * step);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function thresholdRenderer(input, params) {
  const threshold = params.threshold ?? 128;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const value = lum >= threshold ? 255 : 0;
    data[i] = value;
    data[i + 1] = value;
    data[i + 2] = value;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function registerColorEffects() {
  registerEffectRenderer("brightness-contrast", brightnessContrastRenderer);
  registerEffectRenderer("hue-saturation", hueSaturationRenderer);
  registerEffectRenderer("levels", levelsRenderer);
  registerEffectRenderer("tint", tintRenderer);
  registerEffectRenderer("curves", curvesRenderer);
  registerEffectRenderer("glow", glowRenderer);
  registerEffectRenderer("drop-shadow", dropShadowRenderer);
  registerEffectRenderer("color-balance", colorBalanceRenderer);
  registerEffectRenderer("exposure", exposureRenderer);
  registerEffectRenderer("vibrance", vibranceRenderer);
  registerEffectRenderer("invert", invertRenderer);
  registerEffectRenderer("posterize", posterizeRenderer);
  registerEffectRenderer("threshold", thresholdRenderer);
}

function transformRenderer(input, params) {
  const anchorPoint = params.anchor_point ?? { x: 0.5, y: 0.5 };
  const position = params.position ?? { x: 0.5, y: 0.5 };
  const scaleWidth = (params.scale_width ?? 100) / 100;
  const scaleHeight = (params.scale_height ?? 100) / 100;
  const skew = (params.skew ?? 0) * Math.PI / 180;
  const skewAxis = (params.skew_axis ?? 0) * Math.PI / 180;
  const rotation = (params.rotation ?? 0) * Math.PI / 180;
  const opacity = (params.opacity ?? 100) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const anchorX = anchorPoint.x * width;
  const anchorY = anchorPoint.y * height;
  const posX = position.x * width;
  const posY = position.y * height;
  output.ctx.globalAlpha = opacity;
  output.ctx.translate(posX, posY);
  output.ctx.rotate(rotation);
  if (skew !== 0) {
    const skewX = Math.tan(skew) * Math.cos(skewAxis);
    const skewY = Math.tan(skew) * Math.sin(skewAxis);
    output.ctx.transform(1, skewY, skewX, 1, 0, 0);
  }
  output.ctx.scale(scaleWidth, scaleHeight);
  output.ctx.translate(-anchorX, -anchorY);
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.setTransform(1, 0, 0, 1, 0, 0);
  output.ctx.globalAlpha = 1;
  return output;
}
function warpRenderer(input, params) {
  const warpStyle = params.warp_style ?? "arc";
  const bend = (params.bend ?? 0) / 100;
  const hDistort = (params.horizontal_distortion ?? 0) / 100;
  const vDistort = (params.vertical_distortion ?? 0) / 100;
  if (bend === 0 && hDistort === 0 && vDistort === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const nx = (x - centerX) / centerX;
      const ny = (y - centerY) / centerY;
      let srcX = x;
      let srcY = y;
      switch (warpStyle) {
        case "arc": {
          const arcBend = bend * ny * ny;
          srcX = x + arcBend * centerX * nx;
          break;
        }
        case "bulge": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r < 1) {
            const factor = 1 + bend * (1 - r * r);
            srcX = centerX + (x - centerX) / factor;
            srcY = centerY + (y - centerY) / factor;
          }
          break;
        }
        case "wave": {
          srcX = x + Math.sin(ny * Math.PI * 2) * bend * width * 0.1;
          srcY = y + Math.sin(nx * Math.PI * 2) * bend * height * 0.1;
          break;
        }
        case "fisheye": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r > 0 && r < 1) {
            const theta = Math.atan2(ny, nx);
            const newR = Math.pow(r, 1 + bend);
            srcX = centerX + newR * Math.cos(theta) * centerX;
            srcY = centerY + newR * Math.sin(theta) * centerY;
          }
          break;
        }
        case "twist": {
          const r = Math.sqrt(nx * nx + ny * ny);
          const angle = bend * Math.PI * (1 - r);
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          srcX = centerX + (nx * cos - ny * sin) * centerX;
          srcY = centerY + (nx * sin + ny * cos) * centerY;
          break;
        }
      }
      srcX += hDistort * centerX * (1 - ny * ny);
      srcY += vDistort * centerY * (1 - nx * nx);
      srcX = Math.max(0, Math.min(width - 1, srcX));
      srcY = Math.max(0, Math.min(height - 1, srcY));
      const x0 = Math.floor(srcX);
      const y0 = Math.floor(srcY);
      const x1 = Math.min(x0 + 1, width - 1);
      const y1 = Math.min(y0 + 1, height - 1);
      const fx = srcX - x0;
      const fy = srcY - y0;
      const idx00 = (y0 * width + x0) * 4;
      const idx01 = (y0 * width + x1) * 4;
      const idx10 = (y1 * width + x0) * 4;
      const idx11 = (y1 * width + x1) * 4;
      const outIdx = (y * width + x) * 4;
      for (let c = 0; c < 4; c++) {
        const v00 = src[idx00 + c];
        const v01 = src[idx01 + c];
        const v10 = src[idx10 + c];
        const v11 = src[idx11 + c];
        dst[outIdx + c] = Math.round(
          v00 * (1 - fx) * (1 - fy) + v01 * fx * (1 - fy) + v10 * (1 - fx) * fy + v11 * fx * fy
        );
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function getChannelValue(r, g, b, a, channel) {
  switch (channel) {
    case "red":
      return r;
    case "green":
      return g;
    case "blue":
      return b;
    case "alpha":
      return a;
    case "luminance":
    default:
      return 0.299 * r + 0.587 * g + 0.114 * b;
  }
}
function generateProceduralMap(width, height, mapType, scale) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  const imageData = ctx.createImageData(width, height);
  const data = imageData.data;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      let value = 128;
      switch (mapType) {
        case "noise":
          value = Math.floor(Math.random() * 256);
          break;
        case "gradient-h":
          value = Math.floor(x / width * 255);
          break;
        case "gradient-v":
          value = Math.floor(y / height * 255);
          break;
        case "radial":
          const cx = width / 2;
          const cy = height / 2;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          const maxDist = Math.sqrt(cx ** 2 + cy ** 2);
          value = Math.floor((1 - dist / maxDist) * 255);
          break;
        case "sine-h":
          value = Math.floor(128 + 127 * Math.sin(x / width * Math.PI * 2 * scale));
          break;
        case "sine-v":
          value = Math.floor(128 + 127 * Math.sin(y / height * Math.PI * 2 * scale));
          break;
        case "checker":
          const tileSize = Math.max(1, Math.floor(width / (scale * 10)));
          const checkX = Math.floor(x / tileSize) % 2;
          const checkY = Math.floor(y / tileSize) % 2;
          value = (checkX + checkY) % 2 === 0 ? 255 : 0;
          break;
        default:
          value = 128;
      }
      data[i] = value;
      data[i + 1] = value;
      data[i + 2] = value;
      data[i + 3] = 255;
    }
  }
  return imageData;
}
function displacementMapRenderer(input, params) {
  const useHorizontal = params.use_for_horizontal ?? "luminance";
  const useVertical = params.use_for_vertical ?? "luminance";
  const maxHorizontal = params.max_horizontal ?? 0;
  const maxVertical = params.max_vertical ?? 0;
  const mapType = params.map_type ?? "noise";
  const mapScale = params.map_scale ?? 1;
  const wrapMode = params.wrap_pixels ?? "off";
  if ((useHorizontal === "off" || maxHorizontal === 0) && (useVertical === "off" || maxVertical === 0)) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const src = inputData.data;
  const dispMap = generateProceduralMap(width, height, mapType, mapScale);
  const mapData = dispMap.data;
  const outputData = output.ctx.createImageData(width, height);
  const dst = outputData.data;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const mapR = mapData[i];
      const mapG = mapData[i + 1];
      const mapB = mapData[i + 2];
      const mapA = mapData[i + 3];
      let dx = 0;
      let dy = 0;
      if (useHorizontal !== "off" && maxHorizontal !== 0) {
        const hValue = getChannelValue(mapR, mapG, mapB, mapA, useHorizontal);
        dx = (hValue - 128) / 128 * maxHorizontal;
      }
      if (useVertical !== "off" && maxVertical !== 0) {
        const vValue = getChannelValue(mapR, mapG, mapB, mapA, useVertical);
        dy = (vValue - 128) / 128 * maxVertical;
      }
      let srcX = x - dx;
      let srcY = y - dy;
      if (wrapMode === "tiles") {
        srcX = (srcX % width + width) % width;
        srcY = (srcY % height + height) % height;
      } else if (wrapMode === "mirror") {
        srcX = Math.abs(srcX);
        srcY = Math.abs(srcY);
        if (Math.floor(srcX / width) % 2 === 1) srcX = width - 1 - srcX % width;
        else srcX = srcX % width;
        if (Math.floor(srcY / height) % 2 === 1) srcY = height - 1 - srcY % height;
        else srcY = srcY % height;
      } else {
        srcX = Math.max(0, Math.min(width - 1, srcX));
        srcY = Math.max(0, Math.min(height - 1, srcY));
      }
      const x0 = Math.floor(srcX);
      const y0 = Math.floor(srcY);
      const x1 = Math.min(x0 + 1, width - 1);
      const y1 = Math.min(y0 + 1, height - 1);
      const fx = srcX - x0;
      const fy = srcY - y0;
      const i00 = (y0 * width + x0) * 4;
      const i10 = (y0 * width + x1) * 4;
      const i01 = (y1 * width + x0) * 4;
      const i11 = (y1 * width + x1) * 4;
      for (let c = 0; c < 4; c++) {
        const v00 = src[i00 + c];
        const v10 = src[i10 + c];
        const v01 = src[i01 + c];
        const v11 = src[i11 + c];
        dst[i + c] = Math.round(
          v00 * (1 - fx) * (1 - fy) + v10 * fx * (1 - fy) + v01 * (1 - fx) * fy + v11 * fx * fy
        );
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function registerDistortEffects() {
  registerEffectRenderer("transform", transformRenderer);
  registerEffectRenderer("warp", warpRenderer);
  registerEffectRenderer("displacement-map", displacementMapRenderer);
}

class NoiseTileCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 32;
  // Max cached tiles
  maxAgeMs = 3e4;
  // 30 second TTL
  /**
   * Generate cache key from parameters
   */
  makeKey(width, height, scale, octave, seed) {
    const quantizedSeed = Math.round(seed * 100) / 100;
    return `${width}:${height}:${scale}:${octave}:${quantizedSeed}`;
  }
  /**
   * Get cached noise tile or null if not found/expired
   */
  get(width, height, scale, octave, seed) {
    const key = this.makeKey(width, height, scale, octave, seed);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, { ...entry, timestamp: now });
    return entry.tile;
  }
  /**
   * Store noise tile in cache
   */
  set(width, height, scale, octave, seed, tile) {
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    const key = this.makeKey(width, height, scale, octave, seed);
    this.cache.set(key, {
      tile,
      width,
      height,
      scale,
      octave,
      seed,
      timestamp: Date.now()
    });
  }
  /**
   * Clear all cached tiles
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const noiseTileCache = new NoiseTileCache();
function fillRenderer(input, params) {
  const color = params.color ?? { r: 255, g: 0, b: 0, a: 1 };
  const opacity = (params.opacity ?? 100) / 100;
  const invert = params.invert ?? false;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const r = color.r ?? 255;
  const g = color.g ?? 0;
  const b = color.b ?? 0;
  const a = (color.a ?? 1) * 255 * opacity;
  for (let i = 0; i < src.length; i += 4) {
    const srcAlpha = src[i + 3] / 255;
    if (invert) {
      const fillAmount = 1 - srcAlpha;
      dst[i] = Math.round(r * fillAmount + src[i] * (1 - fillAmount));
      dst[i + 1] = Math.round(g * fillAmount + src[i + 1] * (1 - fillAmount));
      dst[i + 2] = Math.round(b * fillAmount + src[i + 2] * (1 - fillAmount));
      dst[i + 3] = Math.max(src[i + 3], Math.round(a * fillAmount));
    } else {
      dst[i] = Math.round(r * srcAlpha * opacity + src[i] * (1 - opacity));
      dst[i + 1] = Math.round(g * srcAlpha * opacity + src[i + 1] * (1 - opacity));
      dst[i + 2] = Math.round(b * srcAlpha * opacity + src[i + 2] * (1 - opacity));
      dst[i + 3] = src[i + 3];
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function gradientRampRenderer(input, params) {
  const startPoint = params.start_of_ramp ?? { x: 0, y: 0.5 };
  const startColor = params.start_color ?? { r: 0, g: 0, b: 0, a: 1 };
  const endPoint = params.end_of_ramp ?? { x: 1, y: 0.5 };
  const endColor = params.end_color ?? { r: 255, g: 255, b: 255, a: 1 };
  const rampShape = params.ramp_shape ?? "linear";
  const scatter = (params.ramp_scatter ?? 0) / 100;
  const blend = (params.blend_with_original ?? 0) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  let gradient;
  if (rampShape === "radial") {
    const cx = startPoint.x * width;
    const cy = startPoint.y * height;
    const dx = (endPoint.x - startPoint.x) * width;
    const dy = (endPoint.y - startPoint.y) * height;
    const radius = Math.sqrt(dx * dx + dy * dy);
    gradient = output.ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  } else {
    gradient = output.ctx.createLinearGradient(
      startPoint.x * width,
      startPoint.y * height,
      endPoint.x * width,
      endPoint.y * height
    );
  }
  const startRgba = `rgba(${startColor.r}, ${startColor.g}, ${startColor.b}, ${startColor.a ?? 1})`;
  const endRgba = `rgba(${endColor.r}, ${endColor.g}, ${endColor.b}, ${endColor.a ?? 1})`;
  gradient.addColorStop(0, startRgba);
  gradient.addColorStop(1, endRgba);
  output.ctx.fillStyle = gradient;
  output.ctx.fillRect(0, 0, width, height);
  if (scatter > 0) {
    const outputData = output.ctx.getImageData(0, 0, width, height);
    const dst = outputData.data;
    const scatterAmount = scatter * 25;
    for (let i = 0; i < dst.length; i += 4) {
      const noise = (Math.random() - 0.5) * scatterAmount;
      dst[i] = Math.max(0, Math.min(255, dst[i] + noise));
      dst[i + 1] = Math.max(0, Math.min(255, dst[i + 1] + noise));
      dst[i + 2] = Math.max(0, Math.min(255, dst[i + 2] + noise));
    }
    output.ctx.putImageData(outputData, 0, 0);
  }
  if (blend > 0) {
    output.ctx.globalAlpha = blend;
    output.ctx.drawImage(input.canvas, 0, 0);
    output.ctx.globalAlpha = 1;
  }
  return output;
}
function noise2D(x, y, seed) {
  const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
  return n - Math.floor(n);
}
function smoothNoise(x, y, seed) {
  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const fx = x - x0;
  const fy = y - y0;
  const v00 = noise2D(x0, y0, seed);
  const v10 = noise2D(x0 + 1, y0, seed);
  const v01 = noise2D(x0, y0 + 1, seed);
  const v11 = noise2D(x0 + 1, y0 + 1, seed);
  const sx = fx * fx * (3 - 2 * fx);
  const sy = fy * fy * (3 - 2 * fy);
  return v00 * (1 - sx) * (1 - sy) + v10 * sx * (1 - sy) + v01 * (1 - sx) * sy + v11 * sx * sy;
}
function getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent) {
  const octaveSeed = seed + octave * 100;
  const cached = noiseTileCache.get(width, height, scale, octave, octaveSeed);
  if (cached) {
    return cached;
  }
  const tile = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const sampleX = x / scale * frequency;
      const sampleY = y / scale * frequency;
      let noiseValue = smoothNoise(sampleX, sampleY, octaveSeed);
      if (isTurbulent) {
        noiseValue = Math.abs(noiseValue * 2 - 1);
      }
      tile[y * width + x] = noiseValue;
    }
  }
  noiseTileCache.set(width, height, scale, octave, octaveSeed, tile);
  return tile;
}
function fractalNoiseRenderer(input, params) {
  const fractalType = params.fractal_type ?? "basic";
  const invert = params.invert ?? false;
  const contrast = (params.contrast ?? 100) / 100;
  const brightness = (params.brightness ?? 0) / 100;
  const scale = params.scale ?? 100;
  const complexity = Math.max(1, Math.min(20, params.complexity ?? 6));
  const evolution = (params.evolution ?? 0) * Math.PI / 180;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const outputData = output.ctx.createImageData(width, height);
  const dst = outputData.data;
  const seed = evolution * 1e3;
  const isTurbulent = fractalType.includes("turbulent");
  const octaveTiles = [];
  const amplitudes = [];
  let frequency = 1;
  let amplitude = 1;
  let maxValue = 0;
  for (let octave = 0; octave < complexity; octave++) {
    octaveTiles.push(getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent));
    amplitudes.push(amplitude);
    maxValue += amplitude;
    amplitude *= 0.5;
    frequency *= 2;
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      const pixelIdx = y * width + x;
      for (let octave = 0; octave < complexity; octave++) {
        value += octaveTiles[octave][pixelIdx] * amplitudes[octave];
      }
      value /= maxValue;
      value = (value - 0.5) * contrast + 0.5 + brightness;
      if (invert) {
        value = 1 - value;
      }
      value = Math.max(0, Math.min(1, value));
      const pixelValue = Math.round(value * 255);
      const idx = pixelIdx * 4;
      dst[idx] = pixelValue;
      dst[idx + 1] = pixelValue;
      dst[idx + 2] = pixelValue;
      dst[idx + 3] = 255;
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function addGrainRenderer(input, params, frame) {
  const intensity = params.intensity ?? 0.5;
  const size = params.size ?? 1;
  const softness = params.softness ?? 0;
  const animate = params.animate ?? true;
  const colorGrain = params.color ?? false;
  if (intensity === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  output.ctx.drawImage(input.canvas, 0, 0);
  const grainScale = Math.max(1, Math.round(size));
  const grainWidth = Math.ceil(width / grainScale);
  const grainHeight = Math.ceil(height / grainScale);
  const grainCanvas = document.createElement("canvas");
  grainCanvas.width = grainWidth;
  grainCanvas.height = grainHeight;
  const grainCtx = grainCanvas.getContext("2d");
  const grainData = grainCtx.createImageData(grainWidth, grainHeight);
  const grain = grainData.data;
  const seed = animate ? (frame ?? 0) * 12345 : 42;
  let rngState = seed;
  const seededRandom = () => {
    rngState = rngState * 1103515245 + 12345 & 2147483647;
    return rngState / 2147483647;
  };
  for (let i = 0; i < grain.length; i += 4) {
    if (colorGrain) {
      grain[i] = Math.round((seededRandom() - 0.5) * 255 * intensity + 128);
      grain[i + 1] = Math.round((seededRandom() - 0.5) * 255 * intensity + 128);
      grain[i + 2] = Math.round((seededRandom() - 0.5) * 255 * intensity + 128);
    } else {
      const grainValue = Math.round((seededRandom() - 0.5) * 255 * intensity + 128);
      grain[i] = grainValue;
      grain[i + 1] = grainValue;
      grain[i + 2] = grainValue;
    }
    grain[i + 3] = 255;
  }
  grainCtx.putImageData(grainData, 0, 0);
  if (softness > 0) {
    const blurAmount = softness * 2;
    grainCtx.filter = `blur(${blurAmount}px)`;
    grainCtx.drawImage(grainCanvas, 0, 0);
    grainCtx.filter = "none";
  }
  output.ctx.globalCompositeOperation = "overlay";
  output.ctx.globalAlpha = intensity;
  if (grainScale > 1) {
    output.ctx.imageSmoothingEnabled = false;
    output.ctx.drawImage(grainCanvas, 0, 0, width, height);
    output.ctx.imageSmoothingEnabled = true;
  } else {
    output.ctx.drawImage(grainCanvas, 0, 0);
  }
  output.ctx.globalCompositeOperation = "source-over";
  output.ctx.globalAlpha = 1;
  return output;
}
function registerGenerateEffects() {
  registerEffectRenderer("fill", fillRenderer);
  registerEffectRenderer("gradient-ramp", gradientRampRenderer);
  registerEffectRenderer("fractal-noise", fractalNoiseRenderer);
  registerEffectRenderer("add-grain", addGrainRenderer);
}

class TimeEffectFrameBuffer {
  buffer = [];
  maxFrames = 64;
  // Max stored frames
  maxAge = 5e3;
  // 5 second TTL
  layerId = "";
  /**
   * Set the layer this buffer is associated with
   */
  setLayer(layerId) {
    if (this.layerId !== layerId) {
      this.clear();
      this.layerId = layerId;
    }
  }
  /**
   * Store a frame in the buffer
   */
  store(frame, canvas) {
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    this.buffer = this.buffer.filter((e) => e.frame !== frame);
    this.buffer.push({
      imageData,
      frame,
      timestamp: Date.now()
    });
    while (this.buffer.length > this.maxFrames) {
      this.buffer.shift();
    }
  }
  /**
   * Get a frame from the buffer
   * Returns null if frame not found
   */
  get(frame) {
    const entry = this.buffer.find((e) => e.frame === frame);
    return entry ? entry.imageData : null;
  }
  /**
   * Get the closest frame to the target
   */
  getClosest(targetFrame) {
    if (this.buffer.length === 0) return null;
    let closest = this.buffer[0];
    let minDist = Math.abs(closest.frame - targetFrame);
    for (const entry of this.buffer) {
      const dist = Math.abs(entry.frame - targetFrame);
      if (dist < minDist) {
        minDist = dist;
        closest = entry;
      }
    }
    return { imageData: closest.imageData, frame: closest.frame };
  }
  /**
   * Get multiple frames for echo effect
   * Returns frames at specified time offsets
   */
  getEchoFrames(currentFrame, echoTimeFrames, numEchoes) {
    const results = [];
    for (let i = 1; i <= numEchoes; i++) {
      const targetFrame = Math.round(currentFrame + echoTimeFrames * i);
      const entry = this.getClosest(targetFrame);
      if (entry) {
        results.push({ ...entry, echoIndex: i });
      }
    }
    return results;
  }
  /**
   * Clear the buffer
   */
  clear() {
    this.buffer = [];
  }
  /**
   * Remove old entries
   */
  cleanup() {
    const now = Date.now();
    this.buffer = this.buffer.filter((e) => now - e.timestamp < this.maxAge);
  }
  /**
   * Get buffer statistics
   */
  getStats() {
    if (this.buffer.length === 0) {
      return { frames: 0, oldestFrame: -1, newestFrame: -1 };
    }
    const frames = this.buffer.map((e) => e.frame);
    return {
      frames: this.buffer.length,
      oldestFrame: Math.min(...frames),
      newestFrame: Math.max(...frames)
    };
  }
}
const frameBuffers = /* @__PURE__ */ new Map();
function getFrameBuffer(layerId) {
  let buffer = frameBuffers.get(layerId);
  if (!buffer) {
    buffer = new TimeEffectFrameBuffer();
    buffer.setLayer(layerId);
    frameBuffers.set(layerId, buffer);
  }
  return buffer;
}
function echoRenderer(input, params) {
  const echoTime = params.echo_time ?? -0.033;
  const numEchoes = Math.max(1, Math.min(50, params.number_of_echoes ?? 8));
  const startingIntensity = Math.max(0, Math.min(1, params.starting_intensity ?? 1));
  const decay = Math.max(0, Math.min(1, params.decay ?? 0.5));
  const operator = params.echo_operator ?? "add";
  const frame = params._frame ?? 0;
  const fps = params._fps ?? 30;
  const layerId = params._layerId ?? "default";
  const echoTimeFrames = echoTime * fps;
  const buffer = getFrameBuffer(layerId);
  buffer.store(frame, input.canvas);
  if (numEchoes === 0 || startingIntensity === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  if (operator === "composite_back") {
    output.ctx.clearRect(0, 0, width, height);
  } else {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  const echoFrames = buffer.getEchoFrames(frame, echoTimeFrames, numEchoes);
  const intensities = [];
  for (let i = 0; i < numEchoes; i++) {
    intensities.push(startingIntensity * Math.pow(1 - decay, i));
  }
  for (const echoData of echoFrames) {
    const intensity = intensities[echoData.echoIndex - 1] ?? 0;
    if (intensity <= 1e-3) continue;
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.putImageData(echoData.imageData, 0, 0);
    switch (operator) {
      case "add":
        output.ctx.globalCompositeOperation = "lighter";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "screen":
        output.ctx.globalCompositeOperation = "screen";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "maximum":
        output.ctx.globalCompositeOperation = "lighten";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "minimum":
        output.ctx.globalCompositeOperation = "darken";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "composite_back":
        output.ctx.globalCompositeOperation = "destination-over";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "composite_front":
        output.ctx.globalCompositeOperation = "source-over";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
      case "blend":
      default:
        output.ctx.globalCompositeOperation = "source-over";
        output.ctx.globalAlpha = intensity;
        output.ctx.drawImage(tempCanvas, 0, 0);
        break;
    }
  }
  output.ctx.globalCompositeOperation = "source-over";
  output.ctx.globalAlpha = 1;
  if (operator === "composite_back") {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  return output;
}
function posterizeTimeRenderer(input, params) {
  const targetFps = Math.max(1, Math.min(60, params.frame_rate ?? 12));
  const frame = params._frame ?? 0;
  const fps = params._fps ?? 30;
  const layerId = params._layerId ?? "default";
  const frameRatio = fps / targetFps;
  const posterizedFrame = Math.floor(frame / frameRatio) * frameRatio;
  const buffer = getFrameBuffer(layerId);
  buffer.store(frame, input.canvas);
  if (Math.abs(frame - posterizedFrame) < 0.5) {
    return input;
  }
  const heldFrame = buffer.getClosest(posterizedFrame);
  if (heldFrame) {
    const output = createMatchingCanvas(input.canvas);
    output.ctx.putImageData(heldFrame.imageData, 0, 0);
    return output;
  }
  return input;
}
function generateTimeDisplacementMap(width, height, mapType, scale) {
  const map = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = y * width + x;
      let value = 0;
      switch (mapType) {
        case "gradient-h":
          value = x / width;
          break;
        case "gradient-v":
          value = y / height;
          break;
        case "radial":
          const cx = width / 2;
          const cy = height / 2;
          const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
          const maxDist = Math.sqrt(cx ** 2 + cy ** 2);
          value = dist / maxDist;
          break;
        case "sine-h":
          value = 0.5 + 0.5 * Math.sin(x / width * Math.PI * 2 * scale);
          break;
        case "sine-v":
          value = 0.5 + 0.5 * Math.sin(y / height * Math.PI * 2 * scale);
          break;
        case "diagonal":
          value = (x / width + y / height) / 2;
          break;
        case "center-out":
          const cx2 = width / 2;
          const cy2 = height / 2;
          const dist2 = Math.sqrt((x - cx2) ** 2 + (y - cy2) ** 2);
          const maxDist2 = Math.sqrt(cx2 ** 2 + cy2 ** 2);
          value = 1 - dist2 / maxDist2;
          break;
        default:
          value = 0.5;
      }
      map[i] = value;
    }
  }
  return map;
}
function timeDisplacementRenderer(input, params) {
  const maxDisplacement = params.max_displacement ?? 10;
  const mapType = params.map_type ?? "gradient-h";
  const mapScale = params.map_scale ?? 1;
  const bias = params.time_offset_bias ?? 0;
  const frame = params._frame ?? 0;
  const layerId = params._layerId ?? "default";
  if (maxDisplacement === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const buffer = getFrameBuffer(layerId);
  buffer.store(frame, input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const dispMap = generateTimeDisplacementMap(width, height, mapType, mapScale);
  const output = createMatchingCanvas(input.canvas);
  const outputData = output.ctx.createImageData(width, height);
  const dst = outputData.data;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = y * width + x;
      const pixelIdx = i * 4;
      const dispValue = dispMap[i];
      const biasedValue = dispValue + bias;
      const frameOffset = Math.round((biasedValue - 0.5) * 2 * maxDisplacement);
      const targetFrame = frame + frameOffset;
      const frameData = buffer.get(targetFrame);
      if (frameData) {
        dst[pixelIdx] = frameData.data[pixelIdx];
        dst[pixelIdx + 1] = frameData.data[pixelIdx + 1];
        dst[pixelIdx + 2] = frameData.data[pixelIdx + 2];
        dst[pixelIdx + 3] = frameData.data[pixelIdx + 3];
      } else {
        dst[pixelIdx] = inputData.data[pixelIdx];
        dst[pixelIdx + 1] = inputData.data[pixelIdx + 1];
        dst[pixelIdx + 2] = inputData.data[pixelIdx + 2];
        dst[pixelIdx + 3] = inputData.data[pixelIdx + 3];
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function registerTimeEffects() {
  registerEffectRenderer("echo", echoRenderer);
  registerEffectRenderer("posterize-time", posterizeTimeRenderer);
  registerEffectRenderer("time-displacement", timeDisplacementRenderer);
}

function initializeEffects() {
  registerBlurEffects();
  registerColorEffects();
  registerDistortEffects();
  registerGenerateEffects();
  registerTimeEffects();
}

let appInstance = null;
function mountApp(container) {
  let el = null;
  if (typeof container === "string") {
    el = document.getElementById(container) || document.querySelector(container);
  } else if (container instanceof HTMLElement) {
    el = container;
  } else {
    el = document.getElementById("weyl-compositor-root") || document.getElementById("app");
  }
  if (!el) return null;
  initializeEffects();
  const app = createApp(_sfc_main);
  app.use(createPinia());
  app.mount(el);
  appInstance = app;
  setupBridge();
  return app;
}
function setupBridge() {
  window.addEventListener("weyl:inputs-ready", (e) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: e.detail }));
  });
}
async function sendToComfyUI(matte, preview) {
  return window.WeylCompositor?.sendOutput?.(matte, preview) ?? false;
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => mountApp());
} else {
  setTimeout(() => {
    if (!appInstance) mountApp();
  }, 0);
}

export { mountApp, sendToComfyUI };
